<!DOCTYPE html>
<html lang="ko">
<meta charset="utf-8">
<script src="https://htmlspecs.com/dropdown.js"></script>
<link rel="icon" href="https://tc39.es/ecma262/img/favicon.ico">
<style>
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }

  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }

  #ecma-logo {
    width: 500px;
  }

  .corner-cell {
    position: relative;
    height: 2lh;
  }
  .corner-cell .slash {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom left, transparent calc(50% - 1px), gray, transparent calc(50% + 1px));
  }
  .corner-cell > .column {
    position: absolute;
    bottom: 0.4em;
    left: 1em;
  }
  .corner-cell > .row {
    position: absolute;
    top: 0.4em;
    right: 1em;
  }
</style>
<style media="print">
  /**
  * ECMA-262-specific hacks. Shouldn't require a ton of maintenance; audit if
  * visual inspection results in unexpected page breaks.
  *
  * For print version, the table captioned "Module fields after the initial Evaluate() call" _may_ need to set the row
  * EVALUATING-ASYNC to one cell with a colspan of 5. It typically does not fit on the page, but the cell merging is
  * not a perfectly accurate solution and will not be merged back in to the specification.
  * See https://github.com/tc39/ecma262/pull/3623#issuecomment-3029366960
  */

  /* Make sure tables are wide enough for their captions */
  table {
    min-width: 135mm;
  }

  /* 2.2 Examples of legacy/normative-optional are small enough to be aggressive against breaks */
  #sec-conformance [example],
  /* 16.2.1.xxx many tables */
  #sec-example-cyclic-module-record-graphs table {
    break-inside: avoid-page;
  }

  /* 12.10.1 long note can break wherever it wants */
  #sec-rules-of-automatic-semicolon-insertion > emu-note {
    break-before: initial;
    break-inside: initial;
  }

  /* 12.10.X Sections start with an <em> not inside a <p> */
  #sec-examples-of-automatic-semicolon-insertion > em,
  #sec-interesting-cases-of-automatic-semicolon-insertion > em,
  #sec-asi-cases-with-no-lineterminator-here > em {
    display: block;
    margin-top: 1.25ex;
  }

  /* 15.1.X missing spacing between intro and first emu-grammar */
  #sec-static-semantics-containsexpression > emu-grammar:first-of-type {
    margin-top: 2ex;
  }

  /* 15.3 A very long term combined with inline-block, nowrap, and justified text resulting in weird punctuation */
  #sec-arrow-function-definitions > p > emu-grammar {
    text-align: left;
  }

  /* 20.X legacy title */
  #sec-object\.prototype\.__proto__ > .attributes-tag {
    break-before: avoid-page;
    break-after: avoid-page;
  }

  /* 21.X table middle column is too narrow */
  #table-time-zone-identifier-record-fields > figure > table th:nth-of-type(2) {
    min-width: 19mm;
  }

  /* 29.X extremely long note */
  #sec-shared-memory-guidelines > emu-note {
    break-inside: auto;
  }

  .unicode-property-table {
    table-layout: initial;
    width: auto;
    font-size: 90%;
  }

  .unicode-property-table th:first-of-type {
    width: 33%;
  }

  .corner-cell {
    background-image: url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI0NiIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNSIgd2lkdGg9IjI0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzE1LjI2NiAzOTYuMzQzIDI0MS4zOTQgNDUuMTU1IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS4wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMxNC45MyAtMzk1LjkzNSkiLz48L3N2Zz4=);
    background-repeat: no-repeat;
    background-size: 100% 3em;
    height: 3em;
    padding: 0;
    vertical-align: inherit;
    position: static;
  }

  .corner-cell .slash {
    display: none;
  }

  .corner-cell > .column, .corner-cell > .row {
    display: block;
    position: relative;
  }

  .corner-cell > .row {
    text-align: right;
    top: -0.75em
  }

  .corner-cell > .column {
    text-align: left;
    bottom: -1.25em;
  }
</style>
<pre class="metadata">
  title: ECMAScript<sup>&reg;</sup> 2026 언어&nbsp;명세서
  shortname: ECMA-262
  status: draft
  location: https://tc39.es/ecma262/
  markEffects: true
</pre>
<p><img src="https://tc39.es/ecma262/img/ecma-logo.svg" id="ecma-logo" alt="Ecma International 로고"></p>
<div id="metadata-block">
  <h1>이 명세서에 대하여</h1>
  <p><a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>에 있는 문서는 가장 정확하고 최신의 ECMAScript 명세서입니다. 이 문서에는 가장 최근 연간 스냅샷의 내용과, 그 스냅샷 이후의 <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md">완료된 제안</a>(<a href="https://tc39.es/process-document/">제안 절차</a>에서 Stage&nbsp;4에 도달하여 여러 구현에 적용되었고 다음 실질적인 개정에 포함될 제안)이 함께 담겨 있습니다.</p>
  <p>이 문서는 <a href>단일 페이지</a>와 <a href="multipage/">여러 페이지</a>로 제공됩니다.</p>
  <h1>이 명세서에 기여하기</h1>
  <p>이 명세서는 ECMAScript 커뮤니티의 도움으로 GitHub에서 개발됩니다. 명세서 개발에 기여하는 방법은 여러 가지가 있습니다:</p>
  <ul>
    <li>GitHub 저장소: <a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></li>
    <li>이슈: <a href="https://github.com/tc39/ecma262/issues">전체 이슈</a>, <a href="https://github.com/tc39/ecma262/issues/new">새 이슈 등록</a></li>
    <li>풀 리퀘스트: <a href="https://github.com/tc39/ecma262/pulls">전체 풀 리퀘스트</a>, <a href="https://github.com/tc39/ecma262/pulls/new">새 풀 리퀘스트 생성</a></li>
    <li>테스트 슈트: <a href="https://github.com/tc39/test262">Test262</a></li>
    <li>
      편집자:
      <ul>
        <li><a href="mailto:shu at rfrn dot org">Shu-yu Guo</a></li>
        <li><a href="mailto:ecma262-editor-list at michael dot ficarra dot me">Michael Ficarra</a> (<a href="https://bsky.app/profile/michael.ficarra.me">@michael.ficarra.me</a>)</li>
        <li><a href="mailto:bakkot at gmail dot com">Kevin Gibbons</a></li>
      </ul>
    </li>
    <li>
      커뮤니티:
      <ul>
        <li>디스코스: <a href="https://es.discourse.group">https://es.discourse.group/</a></li>
        <li>채팅: <a href="https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md">Matrix</a></li>
        <li>이메일 <emu-not-ref>목록</emu-not-ref> 아카이브: <a href="https://esdiscuss.org">https://esdiscuss.org/</a></li>
      </ul>
    </li>
  </ul>
  <p>이 문서가 어떻게 작성되는지 더 자세한 내용은 <emu-xref href="#sec-colophon">colophon</emu-xref>을 참고하세요.</p>
</div>

<emu-intro id="sec-intro">
  <h1>소개</h1>
  <p>이 Ecma 표준은 ECMAScript 2026 언어를 정의합니다. 이는 ECMAScript 언어 명세서의 열일곱 번째 판입니다. 1997년 첫 판이 발표된 이후 ECMAScript는 세계에서 가장 널리 사용되는 범용 프로그래밍 언어 중 하나로 성장했습니다. 웹 브라우저에 내장된 언어로 가장 잘 알려져 있지만, 서버 및 임베디드 애플리케이션에서도 널리 채택되었습니다.</p>
  <p>ECMAScript는 여러 기술에서 유래했으며, 그 중 가장 잘 알려진 것은 JavaScript(Netscape)와 JScript(Microsoft)입니다. 이 언어는 Netscape의 Brendan Eich가 발명하였으며, 최초로 해당 회사의 Navigator 2.0 브라우저에 등장했습니다. 이후 Netscape의 모든 브라우저와 Microsoft의 Internet Explorer 3.0부터 모든 브라우저에 포함되었습니다.</p>
  <p>ECMAScript 언어 명세서의 개발은 1996년 11월에 시작되었습니다. 이 Ecma 표준의 첫 번째 판은 1997년 6월 Ecma 총회에서 채택되었습니다.</p>
  <p>그 Ecma 표준은 ISO/IEC JTC 1에 신속 채택 절차(fast-track procedure)를 통해 제출되었고, 1998년 4월 국제 표준 ISO/IEC 16262로 승인되었습니다. 1998년 6월 Ecma 총회에서 ECMA-262 두 번째 판이 승인되어 ISO/IEC 16262와 완전히 일치하게 되었습니다. 첫 번째 판과 두 번째 판의 변경 사항은 편집상의 변화입니다.</p>
  <p>표준의 세 번째 판에서는 강력한 정규 표현식, 향상된 문자열 처리, 새로운 제어문, try/catch 예외 처리, 오류 정의 강화, 숫자 출력 형식 지정, 그리고 향후 언어 성장을 대비한 소규모 변경 사항이 도입되었습니다. ECMAScript 표준의 세 번째 판은 1999년 12월 Ecma 총회에서 채택되었고, 2002년 6월 ISO/IEC 16262:2002로 출판되었습니다.</p>
  <p>세 번째 판이 출판된 이후 ECMAScript는 월드 와이드 웹과 결합되어 거의 모든 웹 브라우저에서 지원되는 프로그래밍 언어로 대규모로 채택되기에 이르렀습니다. ECMAScript의 네 번째 판 개발을 위한 많은 작업이 이루어졌지만 완전히 완료되지 않았고, ECMAScript의 네 번째 판으로 출판되지 않았습니다. 하지만 그 중 일부는 여섯 번째 판 개발에 통합되었습니다.</p>
  <p>ECMAScript 다섯 번째 판(ECMA-262 5<sup>판</sup>으로 출판)은 브라우저 구현에서 일반적으로 사용되는 언어 명세서의 사실상 해석을 표준화하고, 세 번째 판 출판 이후 등장한 새로운 기능 지원을 추가했습니다. 이러한 기능에는 접근자 속성, 객체의 반사적 생성 및 검사, 속성 속성의 프로그램 제어, 추가 배열 조작 함수, JSON 객체 인코딩 형식 지원, 향상된 오류 검사와 프로그램 보안을 제공하는 엄격 모드 등이 포함됩니다. 다섯 번째 판은 2009년 12월 Ecma 총회에서 채택되었습니다.</p>
  <p>다섯 번째 판은 ISO/IEC JTC 1에 신속 채택 절차로 제출되어 국제 표준 ISO/IEC 16262:2011로 승인되었습니다. ECMAScript 표준의 5.1 판은 소규모 수정이 통합되었고, ISO/IEC 16262:2011과 동일한 텍스트입니다. 5.1 판은 2011년 6월 Ecma 총회에서 채택되었습니다.</p>
  <p>여섯 번째 판의 집중적인 개발은 2009년에 시작되었으며, 다섯 번째 판이 출판 준비 중이던 시점입니다. 하지만 이는 1999년 세 번째 판 출판 이후 진행된 상당한 실험과 언어 개선 설계 노력에 선행되었습니다. 실제로 여섯 번째 판 완성은 15년의 노력의 결실이라 할 수 있습니다. 이 판의 목표에는 대규모 애플리케이션 지원 강화, 라이브러리 제작, 그리고 ECMAScript를 다른 언어의 컴파일 대상로 사용하는 데의 지원 강화가 포함되었습니다. 주요 개선 사항으로는 모듈, 클래스 선언, 렉시컬 블록 스코핑, 이터레이터와 제너레이터, 비동기 프로그래밍을 위한 프로미스, 구조 분해 패턴, proper tail call 등이 있습니다. ECMAScript 내장 라이브러리는 맵, 셋, 바이너리 숫자값 배열과 같은 추가 데이터 추상화를 지원하도록 확장되었고, 문자열과 정규 표현식에서 유니코드 보조 문자 지원이 강화되었습니다. 내장 객체는 서브클래싱을 통해 확장 가능해졌습니다. 여섯 번째 판은 정기적이고 점진적인 언어 및 라이브러리 개선의 기반을 제공합니다. 여섯 번째 판은 2015년 6월 총회에서 채택되었습니다.</p>
  <p>ECMAScript 2016은 Ecma TC39의 새로운 연간 릴리스 주기 및 공개 개발 프로세스 하에 발표된 최초의 ECMAScript 판입니다. 평문 소스 문서가 ECMAScript 2015 소스 문서에서 구축되어 GitHub에서의 추가 개발의 기반이 되었습니다. 이 표준의 개발 기간 동안 수백 건의 풀 리퀘스트와 이슈가 제출되었으며, 이는 수천 건의 버그 수정, 편집적 수정, 기타 개선사항을 대표합니다. 또한 Ecmarkup, Ecmarkdown, Grammarkdown 등 개발을 지원하는 다양한 소프트웨어 도구가 개발되었습니다. ES2016에는 새로운 거듭제곱 연산자와 `Array.prototype`에 `includes`라는 새로운 메소드가 추가되었습니다.</p>
  <p>ECMAScript 2017에서는 Async 함수, Shared Memory, Atomics가 도입되었고, 소규모 언어 및 라이브러리 개선, 버그 수정, 편집적 업데이트가 이루어졌습니다. Async 함수는 프로미스를 반환하는 함수에 대한 문법을 제공하여 비동기 프로그래밍 경험을 향상합니다. Shared Memory와 Atomics는 멀티 에이전트 프로그램이 병렬 CPU 환경에서도 잘 정의된 실행 순서를 보장하는 원자적 연산을 사용하여 통신할 수 있는 새로운 메모리 모델을 도입합니다. 또한 Object에 새로운 정적 메소드인 `Object.values`, `Object.entries`, `Object.getOwnPropertyDescriptors`가 추가되었습니다.</p>
  <p>ECMAScript 2018에서는 async 이터레이터 프로토콜과 async 제너레이터를 통한 비동기 이터레이션 지원이 도입되었습니다. 또한 네 가지 새로운 정규 표현식 기능(`dotAll` 플래그, 명명된 캡처 그룹, 유니코드 속성 이스케이프, 후행 어설션)을 추가하였고, 객체의 rest 및 spread 속성도 포함되었습니다.</p>
  <p>ECMAScript 2019에서는 몇 가지 새로운 내장 함수가 도입되었습니다: 배열 평탄화를 위한 `Array.prototype`의 `flat` 및 `flatMap`, `Object.entries`의 반환값을 바로 새 객체로 변환하는 `Object.fromEntries`, 더 적절한 이름의 `String.prototype.trimStart`와 `trimEnd`(비표준 내장인 `String.prototype.trimLeft`와 `trimRight`의 대안). 또한 구문 및 의미론에 일부 소규모 업데이트가 있었습니다. 업데이트된 구문에는 catch 바인딩 매개변수 선택적 사용, JSON에 맞추어 문자열 리터럴에서 U+2028(줄 구분자) 및 U+2029(단락 구분자) 허용 등이 있습니다. 기타 업데이트로는 `Array.prototype.sort`의 안정 정렬 요구, `JSON.stringify`의 입력과 관계없이 올바른 UTF-8 반환 요구, `Function.prototype.toString`의 명확화(원본 소스 텍스트 또는 표준 플레이스홀더 반환 요구) 등이 있습니다.</p>
  <p>ECMAScript 2020, 11<sup>판</sup>에서는 문자열의 모든 매치 객체를 반복자로 반환하는 `matchAll` 메소드, 동적 지정자를 통해 모듈을 비동기적으로 import할 수 있는 `import()` 구문, 임의 정밀도의 정수 작업을 위한 새로운 숫자 원시 타입인 `BigInt`, 단락 회로 없이 동작하는 새로운 Promise 결합자인 `Promise.allSettled`, 전역 `this` 값을 보편적으로 접근하는 방법인 `globalThis`, 모듈 내에서 사용할 수 있는 `export * as ns from 'module'` 구문, `for-in` 열거 순서의 표준화 강화, 모듈 내에서 컨텍스트 정보를 담을 수 있는 호스트가 채워주는 객체인 `import.meta`, 그리고 nullish 값(*undefined* 또는 *null*)을 다루기 위한 두 가지 구문(nullish 병합 연산자와 옵셔널 체이닝)이 추가되었습니다.</p>
  <p>ECMAScript 2021, 12<sup>판</sup>에서는 문자열의 `replaceAll` 메소드, 입력 값이 이행될 때 단락 회로가 발생하는 Promise 결합자인 `Promise.any`, 여러 오류를 한 번에 표현하는 새로운 오류 타입인 `AggregateError`, 논리 할당 연산자(`??=`, `&&=`, `||=`), 객체를 가비지 컬렉션에서 보호하지 않고 참조할 수 있는 `WeakRef`와 가비지 컬렉션 시 정리 작업 등록 및 해제를 관리하는 `FinalizationRegistry`, 숫자 리터럴 구분자(`1_000`), 그리고 `Array.prototype.sort`의 동작을 더 정확하게 하여 구현 정의 정렬 순서 발생을 줄였습니다.</p>
  <p>ECMAScript 2022, 13<sup>판</sup>에서는 모듈 최상위에서 `await` 키워드를 사용할 수 있게 되었고, 클래스 내에 새로운 요소(공개 및 비공개 인스턴스 필드, 공개 및 비공개 정적 필드, 비공개 인스턴스 메소드 및 접근자, 비공개 정적 메소드 및 접근자), 클래스 내부에서 평가 초기화를 위한 정적 블록, 객체의 비공개 필드 존재를 테스트하는 `#x in obj` 구문, 정규 표현식의 매치 인덱스를 제공하는 `/d` 플래그, 오류의 인과 관계를 기록하는 `Error` 객체의 `cause` 속성, 상대 인덱싱을 가능하게 하는 문자열/배열/TypedArray의 `at` 메소드, 그리고 `Object.hasOwn`(기존 `Object.prototype.hasOwnProperty`의 간편 대안)이 도입되었습니다.</p>
  <p>ECMAScript 2023, 14<sup>판</sup>에서는 `Array.prototype` 및 `TypedArray.prototype`의 `toSorted`, `toReversed`, `with`, `findLast`, `findLastIndex` 메소드, 그리고 `Array.prototype`의 `toSpliced` 메소드가 도입되었습니다. 파일 시작 부분에 `#!` 주석을 허용하여 실행 가능한 ECMAScript 파일 지원이 강화되었고, 대부분의 Symbol을 weak collection의 키로 사용할 수 있게 되었습니다.</p>
  <p>ECMAScript 2024, 15<sup>판</sup>에서는 ArrayBuffer와 SharedArrayBuffer의 크기 조정 및 전송 기능, 문자열 집합 작업을 위한 고급 기능을 가진 RegExp `/v` 플래그, Promise를 쉽게 생성하기 위한 `Promise.withResolvers` 메소드, 데이터 집계용 `Object.groupBy` 및 `Map.groupBy` 메소드, 공유 메모리 변경을 비동기적으로 기다리는 `Atomics.waitAsync` 메소드, 문자열이 올바른 유니코드만 포함하는지 확인/보장하는 `String.prototype.isWellFormed` 및 `String.prototype.toWellFormed` 메소드가 도입되었습니다.</p>
  <p>ECMAScript 2025, 16<sup>판</sup>에서는 이터레이터 작업을 위한 새로운 전역 `Iterator`와 관련 정적 및 프로토타입 메소드, `Set.prototype`의 셋 작업용 메소드, JSON 모듈 import 및 import된 모듈의 속성 선언 구문, 정규 표현식 안전 문자열 이스케이프를 위한 `RegExp.escape` 메소드, 정규 표현식 내에서 인라인 플래그 활성/비활성화 구문, 함수가 Promise를 반환하든 아니든 항상 Promise를 반환하게 하는 `Promise.try` 메소드, 새로운 TypedArray 종류인 `Float16Array`와 관련된 `DataView.prototype.getFloat16`, `DataView.prototype.setFloat16`, `Math.f16round` 메소드가 추가되었습니다.</p>
  <p>Ecma TC39 내에서 많은 단체를 대표하는 수십 명의 개인이 이번 판뿐만 아니라 이전 판의 개발에도 매우 중요한 기여를 했습니다. 또한 TC39의 ECMAScript 활동을 지원하는 활발한 커뮤니티가 성장했습니다. 이 커뮤니티는 수많은 초안 검토, 수천 건의 버그 리포트 제출, 구현 실험, 테스트 슈트 기여, ECMAScript에 대해 전 세계 개발자 커뮤니티를 교육하는 역할을 했습니다. 유감스럽게도 이 노력에 기여한 모든 개인과 단체를 식별하고 인정하는 것은 불가능합니다.</p>
  <p>
    Allen Wirfs-Brock<br>
    ECMA-262, 프로젝트 편집자, 6<sup>판</sup>
  </p>
  <p>
    Brian Terlson<br>
    ECMA-262, 프로젝트 편집자, 7<sup>판</sup> ~ 10<sup>판</sup>
  </p>
  <p>
    Jordan Harband<br>
    ECMA-262, 프로젝트 편집자, 10<sup>판</sup> ~ 12<sup>판</sup>
  </p>
  <p>
    Shu-yu Guo<br>
    ECMA-262, 프로젝트 편집자, 12<sup>판</sup> ~ 16<sup>판</sup>
  </p>
  <p>
    Michael Ficarra<br>
    ECMA-262, 프로젝트 편집자, 12<sup>판</sup> ~ 16<sup>판</sup>
  </p>
  <p>
    Kevin Gibbons<br>
    ECMA-262, 프로젝트 편집자, 12<sup>판</sup> ~ 16<sup>판</sup>
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>범위</h1>
  <p>이 표준은 ECMAScript 2026 범용 프로그래밍 언어를 정의합니다.</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>적합성</h1>
  <p>ECMAScript의 적합한 구현은 이 명세서에 기술된 모든 타입, 값, 객체, 프로퍼티, 함수, 프로그램 문법과 의미를 제공하고 지원해야 합니다.</p>
  <p>ECMAScript의 적합한 구현은 최신 버전의 유니코드 표준과 ISO/IEC 10646에 따라 소스 텍스트 입력을 해석해야 합니다.</p>
  <p>여러 인간 언어와 국가에서 사용되는 언어적, 문화적 관습에 적응해야 하는 프로그램을 지원하는 응용 프로그램 프로그래밍 인터페이스(API)를 제공하는 ECMAScript의 적합한 구현은, 이 명세서와 호환되는 가장 최근 판의 ECMA-402에서 정의된 인터페이스를 구현해야 합니다.</p>
  <p>ECMAScript의 적합한 구현은 이 명세서에 기술된 것 외에도 추가적인 타입, 값, 객체, 프로퍼티, 함수 등을 제공할 수 있습니다. 특히, 이 명세서에 기술된 객체에 대해 명세서에 기술되지 않은 프로퍼티와 해당 프로퍼티의 값을 제공할 수 있습니다.</p>
  <p>ECMAScript의 적합한 구현은 이 명세서에 기술되지 않은 프로그램 및 정규 표현식 문법을 지원할 수 있습니다. 특히, 이 명세서의 <emu-xref href="#sec-keywords-and-reserved-words"></emu-xref> 하위절에 언급된 “future reserved words”를 사용하는 프로그램 문법을 지원할 수 있습니다.</p>
  <p>ECMAScript의 적합한 구현은 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 하위절에 금지 확장(Forbidden Extension)으로 명시된 어떤 확장도 구현해서는 안 됩니다.</p>
  <p>ECMAScript의 적합한 구현은 구현 정의(implementation-defined), 구현 근사(implementation-approximated), 또는 호스트 정의(host-defined)가 아닌 어떠한 기능도 재정의해서는 안 됩니다.</p>
  <p>ECMAScript의 적합한 구현은, 별도의 지시가 없는 한 <dfn>정규적 선택 사항(Normative Optional)</dfn> 하위절을 구현하거나 구현하지 않을 수 있습니다. 웹 브라우저는 일반적으로 모든 정규적 선택 사항 하위절을 구현해야 합니다. (부록 <emu-xref href="#sec-additional-ecmascript-features-for-web-browsers"></emu-xref> 참조.) 만약 어떤 정규적 선택 사항 동작이 구현된다면, 해당 정규적 선택 사항 절에 포함된 모든 동작이 구현되어야 합니다. 정규적 선택 사항 절은 본 명세서에서 아래와 같이 색상 상자에 "Normative Optional"이라는 문구로 표시됩니다.</p>

  <emu-clause id="sec-conformance-normative-optional" oldids="sec-conformance.normative-optional" example normative-optional>
    <h1>정규적 선택 사항 예시 절 제목</h1>
    <p>예시 절 내용.</p>
  </emu-clause>
  <p>ECMAScript의 적합한 구현은 정규적 선택 사항으로도 표시되지 않는 한 <dfn>레거시(Legacy)</dfn> 하위절을 구현해야 합니다. 레거시 하위절에 명시된 모든 언어 기능과 동작은 하나 이상의 바람직하지 않은 특성을 가지고 있습니다. 하지만 기존 애플리케이션에서 계속 사용되고 있기 때문에 이 명세서에서 제거할 수 없습니다. 이러한 기능은 ECMAScript 핵심 언어의 일부로 간주되지 않습니다. 프로그래머는 새로운 ECMAScript 코드를 작성할 때 이러한 기능과 동작을 사용하거나 존재를 가정해서는 안 됩니다.</p>

  <emu-clause id="sec-conformance-legacy" example legacy>
    <h1>레거시 예시 절 제목</h1>
    <p>예시 절 내용.</p>
  </emu-clause>

  <emu-clause id="sec-conformance-legacy-normative-optional" example legacy normative-optional>
    <h1>레거시 정규적 선택 사항 예시 절 제목</h1>
    <p>예시 절 내용.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>정규 참조</h1>
  <p>아래에 참조된 문서는 이 문서의 적용에 필수적입니다. 날짜가 명시된 참조는 해당 판만을 적용합니다. 날짜가 명시되지 않은 참조는 해당 문서의 최신 판(수정 포함)을 적용합니다.</p>
  <p>IEEE 754-2019, <i>IEEE 부동소수점 산술 표준</i>.</p>
  <p>
    유니코드 표준.<br>
    <a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>
  </p>
  <p>ISO/IEC 10646, <i>정보 기술 — 범용 다중 바이트 문자 집합(UCS)</i> 및 Amendment 1:2005, Amendment 2:2006, Amendment 3:2008, Amendment 4:2008, 그리고 추가 개정 및 정정 또는 후속 문서.</p>
  <p>
    ECMA-402, <i>ECMAScript 국제화 API 명세서</i>, 본 명세서와 대응되는 연간 판.<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-402/">https://www.ecma-international.org/publications-and-standards/standards/ecma-402/</a>
  </p>
  <p>
    ECMA-404, <i>JSON 데이터 교환 형식</i>.<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>
  </p>
</emu-clause>

<emu-clause id="sec-overview">
  <h1>개요</h1>
  <p>이 절은 ECMAScript 언어에 대한 비정규적 개요를 포함합니다.</p>
  <p>ECMAScript는 객체 지향 프로그래밍 언어로, 호스트 환경 내에서 계산을 수행하고 계산 객체를 조작합니다. 여기 정의된 ECMAScript는 계산적으로 자급자족하도록 설계된 것이 아니며, 외부 데이터 입력이나 계산 결과 출력에 대한 규정이 없습니다. 대신 ECMAScript 프로그램의 계산 환경은 이 명세서에 기술된 객체와 기타 기능뿐만 아니라 환경 특화 객체도 제공하는 것이 기대되며, 이들의 설명 및 동작은 이 명세서 범위를 벗어나지만 ECMAScript 프로그램에서 접근 가능한 프로퍼티와 호출 가능한 함수가 있을 수 있음을 나타냅니다.</p>
  <p>ECMAScript는 원래 스크립트 언어로 설계되었지만, 현재는 범용 프로그래밍 언어로 널리 사용됩니다. <em>스크립트 언어</em>란 기존 시스템의 기능을 조작, 맞춤화, 자동화하는 데 사용하는 프로그래밍 언어입니다. 이러한 시스템에서는 이미 사용자 인터페이스를 통해 유용한 기능이 제공되며, 스크립트 언어는 해당 기능을 프로그램 제어로 노출하는 역할을 합니다. 이처럼 기존 시스템은 객체와 기능을 제공하는 호스트 환경을 구성하며, 이는 스크립트 언어의 기능을 완성합니다. 스크립트 언어는 전문 프로그래머와 비전문 프로그래머 모두 사용할 수 있도록 설계되었습니다.</p>
  <p>ECMAScript는 원래 <em>웹 스크립트 언어</em>로 설계되어, 브라우저에서 웹 페이지에 생동감을 더하고 웹 기반 클라이언트-서버 아키텍처의 일부로 서버 계산을 수행하는 메커니즘을 제공했습니다. ECMAScript는 현재 다양한 호스트 환경에서 핵심 스크립트 기능을 제공합니다. 따라서 핵심 언어는 특정 호스트 환경과 분리되어 이 문서에서 정의됩니다.</p>
  <p>ECMAScript 사용은 단순한 스크립팅을 넘어 다양한 환경과 규모에서 전체 프로그래밍 작업 영역으로 확장되었습니다. 사용이 늘어남에 따라 ECMAScript가 제공하는 기능과 시설도 확대되었습니다. ECMAScript는 이제 완전한 기능의 범용 프로그래밍 언어입니다.</p>

  <emu-clause id="sec-web-scripting">
    <h1>웹 스크립팅</h1>
    <p>웹 브라우저는 클라이언트 측 계산을 위한 ECMAScript 호스트 환경을 제공합니다. 예를 들어, 창, 메뉴, 팝업, 대화 상자, 텍스트 영역, 앵커, 프레임, 히스토리, 쿠키, 입출력 등을 나타내는 객체를 포함합니다. 또한 호스트 환경은 포커스 변경, 페이지/이미지 로딩 및 언로드, 오류 및 중단, 선택, 폼 제출, 마우스 동작과 같은 이벤트에 스크립트 코드를 연결할 수 있는 수단을 제공합니다. 스크립트 코드는 HTML 내에 나타나며, 표시되는 페이지는 UI 요소와 고정 및 계산된 텍스트/이미지의 조합입니다. 스크립트 코드는 사용자 상호작용에 반응하며, 메인 프로그램이 필요하지 않습니다.</p>
    <p>웹 서버는 서버 측 계산을 위한 다른 호스트 환경을 제공하며, 요청, 클라이언트, 파일을 나타내는 객체와 데이터 잠금/공유 메커니즘을 포함합니다. 브라우저 측과 서버 측 스크립팅을 함께 사용하면, 클라이언트와 서버 간에 계산을 분산시키면서 웹 기반 애플리케이션에 맞춤화된 사용자 인터페이스를 제공할 수 있습니다.</p>
    <p>ECMAScript를 지원하는 각 웹 브라우저와 서버는 자체 호스트 환경을 제공하며, 이것이 ECMAScript 실행 환경을 완성합니다.</p>
  </emu-clause>

  <emu-clause id="sec-hosts-and-implementations">
    <h1>호스트와 구현체</h1>
    <p>ECMAScript를 호스트 환경에 통합하기 위해, 이 명세서는 일부 기능(예: 추상 연산)의 정의를 전적으로 또는 부분적으로 명세서 외부 소스에 위임합니다. 편집상, 이 명세서는 다음과 같은 위임 종류를 구분합니다.</p>
    <p><em id="implementation">구현체</em>란 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열된 시설이나 구현 정의 또는 구현 근사로 표시된 시설을 추가적으로 정의하는 외부 소스를 의미합니다. 비공식적으로 구현체는 특정 웹 브라우저와 같은 구체적인 산출물을 가리킵니다.</p>
    <p><dfn id="implementation-defined">구현 정의</dfn> 시설은 외부 소스에 정의를 위임하며 추가적인 자격을 두지 않습니다. 이 명세서는 특정 동작에 대해 권고하지 않으며, 적합한 구현은 명세서가 제시한 제한 내에서 자유롭게 동작을 선택할 수 있습니다.</p>
    <p><dfn id="implementation-approximated">구현 근사</dfn> 시설은 외부 소스에 정의를 위임하면서 이상적인 동작을 권장합니다. 적합한 구현은 명세서의 제한 내에서 자유롭게 동작을 선택할 수 있지만, 이상적인 동작을 최대한 근사하도록 권장됩니다. 예를 들어 <emu-xref href="#sec-math.exp"><code>Math.exp</code></emu-xref>와 같은 수학 연산이 구현 근사입니다.</p>
    <p><dfn id="host" variants="hosts">호스트</dfn>는 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열된 시설을 추가적으로 정의하지만, 기타 구현 정의 또는 구현 근사 시설은 추가적으로 정의하지 않는 외부 소스입니다. 비공식적으로 호스트는 이 명세서와 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>를 통해 동일하게 인터페이스하는 모든 웹 브라우저 집합 등, 모든 구현체 집합을 의미합니다. 호스트는 종종 WHATWG HTML(<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>)과 같은 외부 명세서입니다. 즉, 호스트 정의 시설은 종종 외부 명세서에서 추가적으로 정의됩니다.</p>
    <p><dfn id="host-hook" variants="host hooks">호스트 후크</dfn>는 전적으로 또는 부분적으로 외부 소스에 의해 정의되는 추상 연산입니다. 모든 호스트 후크는 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열되어야 합니다. 호스트 후크는 최소한 다음 요구 사항을 충족해야 합니다:</p>
    <ul>
      <li>정상 완료 또는 throw 완료 중 하나를 반환해야 합니다.</li>
    </ul>
    <p><dfn id="host-defined">호스트 정의</dfn> 시설은 추가적인 자격 없이 외부 소스에 정의를 위임하며, 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열되어 있습니다. 호스트가 아닌 구현체도 호스트 정의 시설에 대한 정의를 제공할 수 있습니다.</p>
    <p><dfn id="host-environment" variants="host environments">호스트 환경</dfn>은 모든 호스트 정의 시설에 대한 선택적 정의입니다. 호스트 환경에는 일반적으로 입력을 얻거나 출력을 제공하는 객체나 함수가 포함되어 있으며, 전역 객체의 호스트 정의 프로퍼티로 제공됩니다.</p>
    <p>이 명세서는 항상 가장 구체적인 용어를 사용하는 편집 관례를 따릅니다. 예를 들어, 어떤 시설이 호스트 정의인 경우 구현 정의로 지칭하지 않습니다.</p>
    <p>호스트와 구현체 모두 이 명세서에서 정의된 언어 타입, 명세 타입, 추상 연산, 문법 생성, 내장 객체, 내장 심볼을 통해 이 명세서와 인터페이스할 수 있습니다.</p>
  </emu-clause>

  <emu-clause id="sec-ecmascript-overview">
    <h1>ECMAScript 개요</h1>
    <p>아래는 ECMAScript에 대한 비공식 개요이며, 언어의 모든 부분이 기술된 것은 아닙니다. 이 개요는 표준의 일부가 아닙니다.</p>
    <p>ECMAScript는 객체 기반입니다. 기본 언어와 호스트 기능은 객체로 제공되며, ECMAScript 프로그램은 상호 통신하는 객체 집합입니다. ECMAScript에서 <em>객체</em>란 0개 이상의 <em>프로퍼티</em>로 구성되어 있으며, 각 프로퍼티에는 프로퍼티의 사용 방법을 결정하는 <em>특성</em>이 있습니다. 예를 들어, 어떤 프로퍼티의 Writable 특성이 *false*로 설정된 경우, ECMAScript 코드가 해당 프로퍼티에 다른 값을 할당하려고 하면 실패합니다. 프로퍼티는 다른 객체, <em>원시값</em> 또는 <em>함수</em>를 담는 컨테이너입니다. 원시값은 내장 타입 <b>Undefined</b>, <b>Null</b>, <b>Boolean</b>, <b>Number</b>, <b>BigInt</b>, <b>String</b>, <b>Symbol;</b> 중 하나의 멤버입니다. 객체는 내장 타입 <b>Object</b>의 멤버이며, 함수는 호출 가능한 객체입니다. 객체의 프로퍼티에 연결된 함수는 <em>메서드</em>라고 부릅니다.</p>
    <p>ECMAScript는 ECMAScript 엔티티 정의를 완성하는 <em>내장 객체</em> 집합을 정의합니다. 내장 객체에는 전역 객체, 언어의 런타임 의미에 필수적인 `Object`, `Function`, `Boolean`, `Symbol` 및 다양한 `Error` 객체, 숫자값을 나타내고 조작하는 `Math`, `Number`, `Date` 객체, 텍스트 처리를 위한 `String` 및 `RegExp` 객체, 값을 인덱싱하는 컬렉션인 `Array`와 9가지 Typed Array, 키 기반 컬렉션인 `Map`과 `Set` 객체, 구조화 데이터를 지원하는 `JSON` 객체, `ArrayBuffer`, `SharedArrayBuffer`, `DataView`, 제어 추상화를 지원하는 제너레이터 함수와 `Promise` 객체, 그리고 리플렉션을 위한 `Proxy` 및 `Reflect` 객체가 포함됩니다.</p>
    <p>ECMAScript는 <em>내장 연산자</em> 집합도 정의합니다. ECMAScript 연산자에는 다양한 단항 연산, 곱셈 연산자, 덧셈 연산자, 비트 이동 연산자, 관계 연산자, 동등 연산자, 이진 비트 연산자, 이진 논리 연산자, 할당 연산자, 쉼표 연산자가 포함됩니다.</p>
    <p>대규모 ECMAScript 프로그램은 <em>모듈</em>을 통해 여러 문/선언 시퀀스로 분할될 수 있습니다. 각 모듈은 다른 모듈에서 제공해야 하는 선언과 다른 모듈에서 사용할 수 있는 자신의 선언을 명확히 식별합니다.</p>
    <p>ECMAScript 문법은 의도적으로 Java 문법과 유사하게 설계되었습니다. ECMAScript 문법은 스크립트 언어로 쉽게 사용할 수 있도록 완화되어 있습니다. 예를 들어, 변수에 타입 선언이 필요하지 않으며, 프로퍼티에 타입이 연결되지 않고, 함수 선언이 호출보다 먼저 나타나야 할 필요도 없습니다.</p>

    <emu-clause id="sec-objects">
      <h1>객체</h1>
      <p>ECMAScript는 클래스 정의 문법을 포함하지만, ECMAScript 객체는 C++, Smalltalk, Java와 같은 클래스 기반 언어처럼 근본적으로 클래스 기반이 아닙니다. 객체는 리터럴 표기 또는 객체를 생성하고 프로퍼티의 초기값을 할당하는 <em>생성자</em>를 통해 여러 방식으로 생성될 수 있습니다. 각 생성자는 *"prototype"*이라는 프로퍼티를 가진 함수로, <em>프로토타입 기반 상속</em>과 <em>공유 프로퍼티</em>를 구현하는 데 사용됩니다. <b>new</b> 표현식으로 생성자를 사용하면 객체가 생성됩니다. 예를 들어, `new Date(2009, 11)`은 새로운 Date 객체를 만듭니다. 생성자를 <b>new</b> 없이 호출하면 생성자마다 다른 결과가 발생합니다. 예를 들어, `Date()`는 객체가 아닌 현재 날짜와 시간의 문자열 표현을 반환합니다.</p>
      <p>생성자로 생성된 모든 객체는 암시적으로 자신이 속한 생성자의 *"prototype"* 프로퍼티 값에 대한 참조(객체의 <em>프로토타입</em>이라 부름)를 갖습니다. 또한 프로토타입은 자신만의 non-*null* 암시적 참조를 가질 수 있으며, 이를 <em>프로토타입 체인</em>이라 부릅니다. 객체에서 프로퍼티에 대한 참조가 발생하면, 해당 이름의 프로퍼티를 가진 프로토타입 체인에서 첫 번째 객체의 프로퍼티가 참조됩니다. 즉, 먼저 직접 지정된 객체에서 해당 프로퍼티가 있는지 확인하고, 있으면 그 프로퍼티가 참조 대상이 됩니다. 없으면 해당 객체의 프로토타입을 다음으로 검사하고, 계속 반복합니다.</p>
      <emu-figure id="figure-1" caption="객체/프로토타입 관계">
        <img alt="박스와 화살표가 많은 이미지." height="354" src="https://tc39.es/ecma262/img/figure-1.svg" width="719">
      </emu-figure>
      <p>클래스 기반 객체 지향 언어에서는 일반적으로 상태는 인스턴스가, 메서드는 클래스가 담당하며, 상속은 구조와 동작에만 적용됩니다. ECMAScript에서는 상태와 메서드가 객체에 담기며, 구조, 동작, 상태 모두가 상속됩니다.</p>
      <p>프로토타입에 특정 프로퍼티가 있고, 객체에 직접 해당 프로퍼티가 포함되지 않은 모든 객체는 그 프로퍼티와 값을 공유합니다. 그림 1은 이를 보여줍니다:</p>
      <p><b>CF</b>는 생성자(동시에 객체)입니다. <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b> 등 5개의 객체가 `new` 표현식으로 생성되었습니다. 각 객체에는 *"q1"*, *"q2"* 프로퍼티가 있습니다. 점선은 암시적 프로토타입 관계를 나타냅니다. 예를 들어, <b>cf<sub>3</sub></b>의 프로토타입은 <b>CF<sub>p</sub></b>입니다. 생성자인 <b>CF</b>는 *"P1"*, *"P2"*라는 두 개의 프로퍼티를 갖지만, <b>CF<sub>p</sub></b>, <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b>에서는 보이지 않습니다. <b>CF<sub>p</sub></b>의 *"CFP1"* 프로퍼티는 <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b>에서 공유됩니다(<b>CF</b>에서는 공유되지 않음). <b>CF<sub>p</sub></b>의 암시적 프로토타입 체인에 있는 다른 프로퍼티도 *"q1"*, *"q2"*, *"CFP1"*이 아닌 경우 공유됩니다. <b>CF</b>와 <b>CF<sub>p</sub></b> 사이에는 암시적 프로토타입 링크가 없습니다.</p>
      <p>대부분의 클래스 기반 객체 언어와 달리, 객체에는 값을 할당함으로써 동적으로 프로퍼티를 추가할 수 있습니다. 즉, 생성자는 생성된 객체의 모든 프로퍼티를 반드시 명명하거나 값을 할당할 필요가 없습니다. 위 그림에서 <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b>에 대해 <b>CF<sub>p</sub></b>에 새 값을 할당함으로써 새로운 공유 프로퍼티를 추가할 수 있습니다.</p>
      <p>ECMAScript 객체는 본질적으로 클래스 기반이 아니지만, 생성자 함수, 프로토타입 객체, 메서드의 공통 패턴에 기반하여 클래스 유사 추상을 정의하는 것이 편리할 때가 많습니다. ECMAScript 내장 객체도 이런 클래스 유사 패턴을 따릅니다. ECMAScript 2015부터는 내장 객체가 사용하는 동일한 클래스 유사 추상 패턴에 맞는 객체를 간결하게 정의할 수 있는 문법적 클래스 정의가 도입되었습니다.</p>
    </emu-clause>

    <emu-clause id="sec-strict-variant-of-ecmascript">
      <h1>ECMAScript의 엄격 변종</h1>
      <p>ECMAScript 언어는 일부 사용자가 언어에서 제공되는 특정 기능 사용을 제한하고자 할 수 있음을 인식합니다. 이는 보안, 오류 발생 가능성이 높은 기능 회피, 오류 검사 강화 또는 기타 사용자의 목적을 위해서일 수 있습니다. 이런 가능성을 지원하기 위해 ECMAScript는 언어의 엄격 변종을 정의합니다. 엄격 변종은 일반 ECMAScript 언어의 일부 구문 및 의미론적 기능을 제외하고, 일부 기능의 상세 의미론을 수정합니다. 엄격 변종은 비엄격 언어 형식에서는 오류로 지정되지 않은 상황에서도 오류 예외를 반드시 던져야 하는 추가 오류 조건을 명시합니다.</p>
      <p>ECMAScript의 엄격 변종은 언어의 <em>엄격 모드</em>로 일반적으로 불립니다. 엄격 모드의 선택과 엄격 모드 구문 및 의미론 사용은 개별 ECMAScript 소스 텍스트 단위 수준에서 명시적으로 결정됩니다(<emu-xref href="#sec-strict-mode-code"></emu-xref> 참조). 엄격 모드는 구문적 소스 텍스트 단위 수준에서 선택되므로, 제한은 해당 소스 텍스트 단위 내에서만 국지적으로 적용됩니다. 엄격 모드는 여러 소스 텍스트 단위에 걸쳐 일관되게 동작해야 하는 ECMAScript 의미론의 어떤 측면도 제한하거나 수정하지 않습니다. 전체 ECMAScript 프로그램은 엄격 모드와 비엄격 모드 소스 텍스트 단위로 구성될 수 있으며, 이 경우 엄격 모드는 실제로 엄격 모드 소스 텍스트 단위 내에서 정의된 코드를 실행할 때만 적용됩니다.</p>
      <p>이 명세서에 적합하려면 ECMAScript 구현은 이 명세서에서 정의한 완전한 비제한 ECMAScript 언어와 엄격 변종을 모두 구현해야 합니다. 또한, 구현체는 비제한 모드와 엄격 모드 소스 텍스트 단위를 단일 복합 프로그램으로 조합하는 기능을 지원해야 합니다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-terms-and-definitions">
    <h1>용어와 정의</h1>
    <p>이 문서의 목적상, 아래 용어와 정의가 적용됩니다.</p>

    <emu-clause id="sec-terms-and-definitions-implementation-approximated">
      <h1>구현 근사</h1>
      <p>구현 근사 시설은 전체 또는 일부가 외부 소스에 의해 정의되지만, 이 명세서에서 권장되는 이상적 동작을 갖습니다.</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-implementation-defined">
      <h1>구현 정의</h1>
      <p>구현 정의 시설은 전체 또는 일부가 이 명세서 외부 소스에 의해 정의됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-host-defined">
      <h1>호스트 정의</h1>
      <p>구현 정의와 동일함</p>
      <emu-note>
        <p>편집상, <emu-xref href="#sec-hosts-and-implementations"></emu-xref> 절 참조.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-type">
      <h1>타입</h1>
      <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 절에서 정의된 데이터 값 집합</p>
    </emu-clause>

    <emu-clause id="sec-primitive-value">
      <h1>원시값</h1>
      <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 절에서 정의된 Undefined, Null, Boolean, Number, BigInt, Symbol, String 타입 중 하나의 멤버</p>
      <emu-note>
        <p>원시값은 언어 구현의 가장 낮은 수준에서 직접 표현되는 데이터입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-object">
      <h1>객체</h1>
      <p>Object 타입의 멤버</p>
      <emu-note>
        <p>객체는 프로퍼티 집합이며, 하나의 프로토타입 객체를 가집니다. 프로토타입은 *null*일 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-constructor">
      <h1>생성자</h1>
      <p>객체를 생성하고 초기화하는 함수 객체</p>
      <emu-note>
        <p>생성자의 *"prototype"* 프로퍼티 값은 상속 및 공유 프로퍼티 구현에 사용되는 프로토타입 객체입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-prototype">
      <h1>프로토타입</h1>
      <p>다른 객체를 위한 공유 프로퍼티를 제공하는 객체</p>
      <emu-note>
        <p>생성자가 객체를 생성할 때, 해당 객체는 프로퍼티 참조 해결을 위해 생성자의 *"prototype"* 프로퍼티를 암시적으로 참조합니다. 생성자의 *"prototype"* 프로퍼티는 <code><var>constructor</var>.prototype</code> 표현식으로 참조할 수 있으며, 프로토타입에 추가된 프로퍼티는 프로토타입을 공유하는 모든 객체에 상속을 통해 공유됩니다. 또는 `Object.create` 내장 함수를 사용하여 명시적으로 지정된 프로토타입으로 새 객체를 만들 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinary-object">
      <h1>일반 객체</h1>
      <p>모든 객체가 반드시 지원해야 하는 기본 내부 메서드에 대한 기본 동작을 갖는 객체</p>
    </emu-clause>

    <emu-clause id="sec-exotic-object">
      <h1>특수 객체</h1>
      <p>하나 이상의 필수 내부 메서드에 대해 기본 동작을 갖지 않는 객체</p>
      <emu-note>
        <p>일반 객체가 아닌 모든 객체는 특수 객체입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-standard-object">
      <h1>표준 객체</h1>
      <p>이 명세서에서 의미가 정의된 객체</p>
    </emu-clause>

    <emu-clause id="sec-built-in-object">
      <h1>내장 객체</h1>
      <p>ECMAScript 구현체에 의해 지정되고 제공되는 객체</p>
      <emu-note>
        <p>표준 내장 객체는 이 명세서에서 정의됩니다. ECMAScript 구현체는 추가적인 내장 객체 종류를 지정하고 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-undefined-value">
      <h1>undefined 값</h1>
      <p>변수에 값이 할당되지 않았을 때 사용되는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-undefined-type">
      <h1>Undefined 타입</h1>
      <p>유일한 값이 *undefined*인 타입</p>
    </emu-clause>

    <emu-clause id="sec-null-value">
      <h1>null 값</h1>
      <p>어떠한 객체 값도 의도적으로 없음을 나타내는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-null-type">
      <h1>Null 타입</h1>
      <p>유일한 값이 *null*인 타입</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-value">
      <h1>Boolean 값</h1>
      <p>Boolean 타입의 멤버</p>
      <emu-note>
        <p>Boolean 값은 *true*, *false* 두 가지 뿐입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-type">
      <h1>Boolean 타입</h1>
      <p>원시값 *true*와 *false*로 구성된 타입</p>
    </emu-clause>

    <emu-clause id="sec-boolean-object">
      <h1>Boolean 객체</h1>
      <p>표준 내장 Boolean 생성자의 인스턴스인 Object 타입의 멤버</p>
      <emu-note>
        <p>Boolean 객체는 Boolean 생성자를 `new` 표현식으로 사용할 때 생성되며, Boolean 값을 인자로 제공합니다. 결과 객체는 내부 슬롯에 Boolean 값이 저장됩니다. Boolean 객체는 Boolean 값으로 강제 변환될 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-value">
      <h1>String 값</h1>
      <p>0개 이상의 16비트 부호 없는 정수값으로 이루어진 유한 순서의 원시값</p>
      <emu-note>
        <p>String 값은 String 타입의 멤버입니다. 시퀀스 내 각 정수값은 일반적으로 UTF-16 텍스트의 16비트 단위를 나타냅니다. 단, ECMAScript는 값에 대해 16비트 부호 없는 정수라는 점 외에 제한이나 요구 사항을 두지 않습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-type">
      <h1>String 타입</h1>
      <p>모든 가능한 String 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-string-object">
      <h1>String 객체</h1>
      <p>표준 내장 String 생성자의 인스턴스인 Object 타입의 멤버</p>
      <emu-note>
        <p>String 객체는 String 생성자를 `new` 표현식으로 사용할 때 생성되며, String 값을 인자로 제공합니다. 결과 객체는 내부 슬롯에 String 값이 저장됩니다. String 객체는 String 생성자를 함수처럼 호출하면 String 값으로 강제 변환될 수 있습니다(<emu-xref href="#sec-string-constructor-string-value"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-value">
      <h1>Number 값</h1>
      <p>배정밀도 64비트 이진 형식 IEEE 754-2019 값에 해당하는 원시값</p>
      <emu-note>
        <p>Number 값은 Number 타입의 멤버이며, 숫자를 직접 나타냅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-type">
      <h1>Number 타입</h1>
      <p>*NaN* (“not a number”), *+∞*<sub>𝔽</sub> (양의 무한대), *-∞*<sub>𝔽</sub> (음의 무한대)를 포함한 모든 가능한 Number 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-number-object">
      <h1>Number 객체</h1>
      <p>표준 내장 Number 생성자의 인스턴스인 Object 타입의 멤버</p>
      <emu-note>
        <p>Number 객체는 Number 생성자를 `new` 표현식으로 사용할 때 생성되며, Number 값을 인자로 제공합니다. 결과 객체는 내부 슬롯에 Number 값이 저장됩니다. Number 객체는 Number 생성자를 함수처럼 호출하면 Number 값으로 강제 변환될 수 있습니다(<emu-xref href="#sec-number-constructor-number-value"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-infinity">
      <h1>Infinity</h1>
      <p>양의 무한대 Number 값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-nan">
      <h1>NaN</h1>
      <p>IEEE 754-2019 NaN (“not a number”) 값인 Number 값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-value">
      <h1>BigInt 값</h1>
      <p>임의 정밀도의 정수값에 해당하는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-type">
      <h1>BigInt 타입</h1>
      <p>모든 가능한 BigInt 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-bigint-object">
      <h1>BigInt 객체</h1>
      <p>표준 내장 BigInt 생성자의 인스턴스인 Object 타입의 멤버</p>
    </emu-clause>

    <emu-clause id="sec-symbol-value">
      <h1>Symbol 값</h1>
      <p>고유한, 문자열이 아닌 Object 프로퍼티 키를 나타내는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-symbol-type">
      <h1>Symbol 타입</h1>
      <p>모든 가능한 Symbol 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-symbol-object">
      <h1>Symbol 객체</h1>
      <p>표준 내장 Symbol 생성자의 인스턴스인 Object 타입의 멤버</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-function">
      <h1>함수</h1>
      <p>서브루틴으로 호출될 수 있는 Object 타입의 멤버</p>
      <emu-note>
        <p>함수는 프로퍼티 외에도 코드와 상태를 포함하며, 호출 시 동작을 결정합니다. 함수의 코드는 ECMAScript로 작성되었을 수도, 아닐 수도 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function">
      <h1>내장 함수</h1>
      <p>함수인 내장 객체</p>
      <emu-note>
        <p>내장 함수의 예로 `parseInt`, `Math.exp` 등이 있습니다. 호스트나 구현체는 이 명세서에 기술되지 않은 추가 내장 함수를 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-constructor">
      <h1>내장 생성자</h1>
      <p>생성자인 내장 함수</p>
      <emu-note>
        <p>내장 생성자의 예로 `Object`, `Function` 등이 있습니다. 호스트나 구현체는 이 명세서에 기술되지 않은 추가 내장 생성자를 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-property">
      <h1>프로퍼티</h1>
      <p>키(문자열 값 또는 Symbol 값)와 값을 연결하는 객체의 일부</p>
      <emu-note>
        <p>프로퍼티 형태에 따라 값은 데이터 값(원시값, 객체, 함수 객체)으로 직접 표현되거나, 접근자 함수 쌍으로 간접적으로 표현될 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-method">
      <h1>메서드</h1>
      <p>프로퍼티 값인 함수</p>
      <emu-note>
        <p>함수가 객체의 메서드로 호출될 때, 해당 객체가 *this* 값으로 함수에 전달됩니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-method">
      <h1>내장 메서드</h1>
      <p>내장 함수인 메서드</p>
      <emu-note>
        <p>표준 내장 메서드는 이 명세서에서 정의됩니다. 호스트나 구현체는 이 명세서에 기술되지 않은 추가 내장 메서드를 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-attribute">
      <h1>특성</h1>
      <p>프로퍼티의 특성을 정의하는 내부 값</p>
    </emu-clause>

    <emu-clause id="sec-own-property">
      <h1>자체 프로퍼티</h1>
      <p>객체에 직접 포함된 프로퍼티</p>
    </emu-clause>

    <emu-clause id="sec-inherited-property">
      <h1>상속 프로퍼티</h1>
      <p>객체의 자체 프로퍼티가 아니지만, 객체의 프로토타입(자체 또는 상속 프로퍼티)의 프로퍼티인 프로퍼티</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-organization-of-this-specification">
    <h1>이 명세서의 구성</h1>
    <p>이후 명세서는 아래와 같이 구성됩니다:</p>
    <p><emu-xref href="#sec-notational-conventions"></emu-xref> 절은 명세서 전반에서 사용되는 표기 관례를 정의합니다.</p>
    <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> ~ <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 절은 ECMAScript 프로그램이 동작하는 실행 환경을 정의합니다.</p>
    <p><emu-xref href="#sec-ecmascript-language-source-code"></emu-xref> ~ <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 절은 ECMAScript 프로그래밍 언어의 실제 문법 인코딩과 모든 언어 기능의 실행 의미를 정의합니다.</p>
    <p><emu-xref href="#sec-ecmascript-standard-built-in-objects"></emu-xref> ~ <emu-xref href="#sec-reflection"></emu-xref> 절은 ECMAScript 표준 라이브러리를 정의하며, 실행 중 ECMAScript 프로그램에서 사용할 수 있는 모든 표준 객체의 정의를 포함합니다.</p>
    <p><emu-xref href="#sec-memory-model"></emu-xref> 절은 SharedArrayBuffer 기반 메모리 접근 및 Atomics 객체의 메서드에 대한 메모리 일관성 모델을 설명합니다.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>표기 관례</h1>

  <emu-clause id="sec-syntactic-and-lexical-grammars">
    <h1>구문 및 렉시컬 문법</h1>

    <emu-clause id="sec-context-free-grammars">
      <h1>문맥 자유 문법</h1>
      <p><em>문맥 자유 문법</em>은 여러 개의 <em>생산식</em>으로 구성됩니다. 각 생산식에는 <em>비단말기</em>라 불리는 추상 기호가 <em>좌변</em>에, 0개 이상의 비단말기와 <em>단말기</em> 기호가 <em>우변</em>에 나열됩니다. 각 문법에서 단말기 기호는 지정된 알파벳에서 선택됩니다.</p>
      <p><dfn variants="chain productions">체인 생산식</dfn>은 우변에 단 하나의 비단말기 기호와 0개 이상의 단말기 기호가 있는 생산식입니다.</p>
      <p>단일 특수 비단말기로 구성된 문장에서 시작하여, 주어진 문맥 자유 문법은 <em>언어</em>를 정의합니다. 즉, 비단말기를 해당 비단말기가 좌변인 생산식의 우변으로 반복적으로 치환함으로써 생성될 수 있는 단말기 기호의 (아마도 무한한) 가능한 시퀀스 집합입니다.</p>
    </emu-clause>

    <emu-clause id="sec-lexical-and-regexp-grammars">
      <h1>렉시컬 및 정규식 문법</h1>
      <p>ECMAScript의 <em>렉시컬 문법</em>은 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref> 절에 있습니다. 이 문법의 단말기 기호는 <emu-xref href="#sec-source-text"></emu-xref>에서 정의된 |SourceCharacter| 규칙을 따르는 유니코드 코드 포인트입니다. 목표 기호 |InputElementDiv|, |InputElementTemplateTail|, |InputElementRegExp|, |InputElementRegExpOrTemplateTail|, 또는 |InputElementHashbangOrRegExp|에서 시작하여, 이러한 코드 포인트 시퀀스를 입력 요소 시퀀스로 변환하는 방법을 설명하는 생산식 집합을 정의합니다.</p>
      <p>공백과 주석을 제외한 입력 요소는 ECMAScript의 구문 문법의 단말기 기호를 구성하며, ECMAScript <em>토큰</em>이라고 합니다. 이 토큰은 ECMAScript 언어의 예약어, 식별자, 리터럴, 구두점입니다. 또한 줄 종결자는 토큰으로 간주되지 않지만 입력 요소 스트림의 일부가 되어 자동 세미콜론 삽입 과정(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)을 안내합니다. 단순 공백과 한 줄 주석은 버려져서 구문 문법의 입력 요소 스트림에 나타나지 않습니다. |MultiLineComment|(`/*`…`*/` 형태의 주석, 줄을 넘나들든 아니든 관계 없음)도 줄 종결자가 포함되지 않았다면 단순히 버려집니다. 하지만 줄 종결자가 하나 이상 포함된 경우, 단일 줄 종결자로 대체되어 구문 문법의 입력 요소 스트림에 포함됩니다.</p>
      <p>ECMAScript의 <em>정규식 문법</em>은 <emu-xref href="#sec-patterns"></emu-xref>에 있습니다. 이 문법 역시 단말기 기호로 |SourceCharacter|에서 정의된 코드 포인트를 사용합니다. 목표 기호 |Pattern|에서 시작하여, 코드 포인트 시퀀스를 정규 표현식 패턴으로 변환하는 생산식 집합을 정의합니다.</p>
      <p>렉시컬 및 정규식 문법의 생산식은 구분 기호로 두 개의 콜론 “<b>::</b>”을 사용해 구분됩니다. 렉시컬 문법과 정규식 문법은 일부 생산식을 공유합니다.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-string-grammar">
      <h1>숫자 문자열 문법</h1>
      <p><em>숫자 문자열 문법</em>은 <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>에 나옵니다. 단말기 기호로 |SourceCharacter|를 가지며, 목표 기호 |StringNumericLiteral|에서 시작하여 문자열을 숫자 값으로 변환하는 데 사용됩니다(이는 <emu-xref href="#sec-literals-numeric-literals">숫자 리터럴의 렉시컬 문법</emu-xref>과 유사하지만 다릅니다).</p>
      <p>숫자 문자열 문법의 생산식은 세 개의 콜론 “<b>:::</b>”을 구분 기호로 가지며, 소스 텍스트 파싱에는 사용되지 않습니다.</p>
    </emu-clause>

    <emu-clause id="sec-syntactic-grammar">
      <h1>구문 문법</h1>
      <p>ECMAScript의 <em>구문 문법</em>은 <emu-xref href="#sec-ecmascript-language-expressions"></emu-xref> 절부터 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref> 절까지 제시되어 있습니다. 이 문법의 단말기 기호는 렉시컬 문법에서 정의된 ECMAScript 토큰입니다(<emu-xref href="#sec-lexical-and-regexp-grammars"></emu-xref>). 목표 기호 |Script|와 |Module| 두 가지에서 시작하여, 토큰 시퀀스가 ECMAScript 프로그램의 구문적으로 올바른 독립된 구성 요소를 형성하는 방법을 설명하는 생산식 집합을 정의합니다.</p>
      <p>코드 포인트 스트림을 ECMAScript |Script| 또는 |Module|로 파싱하려면, 먼저 렉시컬 문법을 반복적으로 적용하여 입력 요소 스트림으로 변환합니다. 그 후 입력 요소 스트림을 구문 문법을 단일 적용으로 파싱합니다. 입력 스트림의 토큰이 목표 비단말기(|Script| 또는 |Module|)의 단일 인스턴스로 파싱될 수 없거나 토큰이 남는다면 구문 오류입니다.</p>
      <p>파싱이 성공하면 <em>파스 트리</em>가 구성되며, 트리의 각 노드는 <dfn variants="Parse Nodes">파스 노드</dfn>입니다. 각 파스 노드는 문법 기호의 <em>인스턴스</em>이며, 해당 기호에서 유도할 수 있는 소스 텍스트의 범위를 나타냅니다. 파스 트리의 루트 노드는 전체 소스 텍스트를 나타내며, 파싱의 목표 기호의 인스턴스입니다. 파스 노드가 비단말기의 인스턴스라면, 해당 비단말기를 좌변으로 하는 생산식 인스턴스이기도 합니다. 그리고 우변의 각 기호마다 <em>자식</em>을 하나씩 가집니다. 각 자식은 해당 기호의 인스턴스인 파스 노드입니다.</p>
      <p>새로운 파스 노드는 파서가 호출될 때마다 인스턴스화되며, 동일한 소스 텍스트를 파싱하더라도 파싱 간에 재사용되지 않습니다. 파스 노드는 동일한 소스 텍스트 범위를 나타내고, 동일한 문법 기호의 인스턴스이며, 동일한 파서 호출에서 생성된 경우에만 <dfn>동일한 파스 노드</dfn>로 간주됩니다.</p>
      <emu-note>
        <p>같은 문자열을 여러 번 파싱하면 서로 다른 파스 노드가 생성됩니다. 예를 들어:</p>
        <pre><code class="javascript">
          let str = "1 + 1;";
          eval(str);
          eval(str);
        </code></pre>
        <p>`eval`을 호출할 때마다 str의 값을 ECMAScript 소스 텍스트로 변환하고, 각각 독립적으로 자신만의 파스 노드 트리를 생성합니다. 이 트리들은 각각의 파싱이 동일한 문자열 값에서 유도된 소스 텍스트를 대상으로 하더라도 서로 다릅니다.</p>
      </emu-note>
      <emu-note>파스 노드는 명세상의 산출물이며, 실제 구현에서는 유사한 데이터 구조를 사용할 필요가 없습니다.</emu-note>
      <p>구문 문법의 생산식은 구분 기호로 한 개의 콜론 “<b>:</b>”만을 사용합니다.</p>
      <p><emu-xref href="#sec-ecmascript-language-expressions"></emu-xref>부터 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref>까지 제시된 구문 문법은 ECMAScript |Script| 또는 |Module|로서 올바르게 받아들여지는 토큰 시퀀스를 완전히 설명한 것은 아닙니다. 추가적인 토큰 시퀀스도 허용되며, 예를 들어 일부 위치(줄 종결자 앞 등)에 세미콜론만 추가하면 문법에서 기술될 토큰 시퀀스가 허용됩니다. 또한, 일부 위치에 줄 종결자가 나타나면 문법에서 기술된 토큰 시퀀스라 해도 허용되지 않을 수 있습니다.</p>
      <p>일부 경우, 모호성을 피하기 위해 구문 문법은 유효한 ECMAScript |Script| 또는 |Module|을 형성하지 않는 토큰 시퀀스를 허용하는 일반화된 생산식을 사용합니다. 예를 들어, 객체 리터럴 및 객체 구조 분해 패턴에 이 기법이 사용됩니다. 이런 경우, 더 제한적인 <em>보조 문법</em>이 제공되어 허용되는 토큰 시퀀스를 추가로 제한합니다. 일반적으로, 초기 오류 규칙은 특정 문맥에서 "_P_ <dfn id="must-cover">는 반드시 _N_을 커버해야 한다</dfn>"고 명시합니다. 여기서 _P_는 파스 노드(일반화된 생산식의 인스턴스), _N_은 보조 문법의 비단말기입니다. 이는 다음을 의미합니다:</p>
      <ol>
        <li>_P_가 원래 일치시킨 토큰 시퀀스를 _N_을 목표 기호로 하여 다시 파싱합니다. _N_에 문법적 매개변수가 있다면, _P_가 처음 파싱될 때 사용된 값으로 설정합니다.</li>
        <li>토큰 시퀀스를 토큰 남김 없이 _N_의 단일 인스턴스로 파싱할 수 있다면:
          <ol>
            <li>해당 _N_ 인스턴스(특정 _P_에 대해 유일한 파스 노드)를 "_P_가 커버하는 _N_"이라고 합니다.</li>
            <li>_N_ 및 그 파생 생산식에 대한 모든 Early Error 규칙은 _P_가 커버하는 _N_에도 적용됩니다.</li>
          </ol>
        </li>
        <li>그렇지 않으면(파싱이 실패하면), 이는 초기 구문 오류입니다.</li>
      </ol>
    </emu-clause>

    <emu-clause id="sec-grammar-notation" namespace="grammar-notation">
      <h1>문법 표기법</h1>

      <emu-clause id="sec-terminal-symbols">
        <h1>단말기 기호</h1>
        <p>ECMAScript 문법에서 일부 단말기 기호는 `고정폭` 글꼴로 표시됩니다. 이는 소스 텍스트에 정확히 표시된 대로 나타나야 함을 의미합니다. 이렇게 지정된 모든 단말기 기호 코드 포인트는 다른 유사한 유니코드 범위가 아니라 기본 라틴 블록의 적절한 유니코드 코드 포인트로 이해해야 합니다. 단말기 기호의 코드 포인트는 `\\` |UnicodeEscapeSequence|로 표현할 수 없습니다.</p>
        <p>단말기 기호가 개별 유니코드 코드 포인트인 문법(즉, 렉시컬, 정규식, 숫자 문자열 문법)에서는 생산식에 여러 개의 고정폭 코드 포인트가 연속해서 나타날 때, 이는 동일한 시퀀스를 독립된 단말기 기호로 쓴 것과 같습니다.</p>
        <p>예를 들어, 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0x` HexDigits
        </emu-grammar>
        <p>이는 사실 다음과 같은 약어입니다:</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0` `x` HexDigits
        </emu-grammar>
        <p>반면, 구문 문법에서는 고정폭 코드 포인트가 연속해서 나타날 경우 단일 단말기 기호로 취급됩니다.</p>
        <p>단말기 기호는 두 가지 다른 형태도 있습니다:</p>
        <ul>
          <li>렉시컬 및 정규식 문법에서, 일반적인 인쇄 표현이 없는 유니코드 코드 포인트는 "&lt;ABBREV>" 형태로 표시됩니다. 여기서 "ABBREV"는 코드 포인트 또는 코드 포인트 집합의 기억법입니다. 이러한 형태는 <emu-xref href="#sec-unicode-format-control-characters" title></emu-xref>, <emu-xref href="#sec-white-space" title></emu-xref>, <emu-xref href="#sec-line-terminators" title></emu-xref>에서 정의됩니다.</li>
          <li>구문 문법에서는 특정 단말기 기호(예: |IdentifierName|, |RegularExpressionLiteral|)가 이탤릭체로 표시되며, 이는 렉시컬 문법의 동일한 이름의 비단말기를 참조함을 의미합니다.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-nonterminal-symbols-and-productions">
        <h1>비단말기 기호와 생산식</h1>
        <p>비단말기 기호는 <i>이탤릭체</i>로 표시됩니다. 비단말기 정의(생산식이라고도 함)는 정의되는 비단말기 이름 다음에 하나 이상의 콜론이 옵니다. (콜론의 개수는 생산식이 속한 문법을 나타냅니다.) 이어서 비단말기의 하나 이상의 대체 우변이 각각의 줄에 나옵니다. 예를 들어, 다음과 같은 구문 정의가 있습니다:</p>
        <emu-grammar type="definition" example>
          WhileStatement :
            `while` `(` Expression `)` Statement
        </emu-grammar>
        <p>이는 비단말기 |WhileStatement|가 토큰 `while` 다음에 왼쪽 괄호 토큰, |Expression|, 오른쪽 괄호 토큰, |Statement|가 차례로 오는 것을 의미합니다. |Expression|과 |Statement|도 각각 비단말기입니다. 또 다른 예로, 다음과 같은 구문 정의가 있습니다:</p>
        <emu-grammar type="definition" example>
          ArgumentList :
            AssignmentExpression
            ArgumentList `,` AssignmentExpression
        </emu-grammar>
        <p>이는 |ArgumentList|가 단일 |AssignmentExpression| 또는 |ArgumentList|, 쉼표, |AssignmentExpression|로 나타날 수 있음을 의미합니다. 이 |ArgumentList| 정의는 자기 참조적(재귀적)이며, 자신에 대한 정의로 이루어져 있습니다. 결과적으로 |ArgumentList|는 콤마로 구분된 모든 양의 개수의 인자, 각 인자 표현식은 |AssignmentExpression|이 될 수 있습니다. 이러한 비단말기의 재귀적 정의는 흔합니다.</p>
      </emu-clause>

      <emu-clause id="sec-optional-symbols">
        <h1>선택적 기호</h1>
        <p>단말기 또는 비단말기 뒤에 첨자 “<sub>opt</sub>”가 붙으면 선택적 기호임을 나타냅니다. 선택적 기호가 포함된 대안은 실제로 두 가지 우변을 명시합니다. 하나는 선택적 요소를 생략한 것이고, 하나는 포함한 것입니다. 즉,</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer?
        </emu-grammar>
        <p>는 다음의 편리한 약어입니다:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <p>는 다음의 편리한 약어입니다:</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression? `)` Statement
        </emu-grammar>
        <p>이는 다시 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` `)` Statement
            `for` `(` LexicalDeclaration `;` Expression `)` Statement
            `for` `(` LexicalDeclaration Expression `;` `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
        </emu-grammar>
        <p>따라서 이 예시에서 비단말기 |ForStatement|는 실제로 네 가지 대체 우변을 갖습니다.</p>
      </emu-clause>

      <emu-clause id="sec-grammatical-parameters">
        <h1>문법적 매개변수</h1>
        <p>생산식은 첨자 형태의 “<sub>[parameters]</sub>” 주석으로 매개변수화될 수 있으며, 이는 생산식이 정의하는 비단말기 기호 뒤에 접미사로 나타납니다. “<sub>parameters</sub>”는 단일 이름 또는 컴마로 구분된 이름 목록일 수 있습니다. 매개변수화된 생산식은 매개변수 이름 조합마다 해당 비단말기 기호에 언더스코어를 붙여서 정의하는 생산식 집합의 약어입니다. 즉,</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 편리한 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          StatementList[Return, In] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement

          StatementList_In :
            ReturnStatement
            ExpressionStatement

          StatementList_Return_In :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>여러 매개변수가 있으면 조합 수만큼 생산식이 생성되며, 모든 경우가 완전한 문법에서 참조되는 것은 아닙니다.</p>
        <p>생산식의 우변에 있는 비단말기 참조 역시 매개변수화될 수 있습니다. 예를 들어:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[+In]
        </emu-grammar>
        <p>는 다음과 동일합니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement_In
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[~In]
        </emu-grammar>
        <p>는 다음과 동일합니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>비단말기 참조에는 매개변수 목록과 “<sub>opt</sub>” 첨자가 모두 있을 수 있습니다. 예를 들어:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer[+In]?
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>우변 비단말기 참조에 매개변수 이름 앞에 “<sub>?</sub>”가 있으면, 그 매개변수 값은 현재 생산식 좌변의 비단말기 참조에 해당 매개변수 이름이 나타나는지에 따라 결정됩니다. 예를 들어:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration[In] :
            BindingIdentifier Initializer[?In]
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer

          VariableDeclaration_In :
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>우변 대안 앞에 “[+parameter]”가 있으면, 해당 대안은 생산식의 비단말기 기호 참조에 지정된 매개변수가 있을 때만 사용 가능합니다. “[~parameter]”가 있으면, 해당 대안은 지정된 매개변수가 <em>없을 때만</em> 사용 가능합니다. 즉,</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [+Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [~Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ExpressionStatement
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-one-of">
        <h1>one of</h1>
        <p>문법 정의에서 콜론 다음에 “<b>one of</b>”가 나오면, 다음 줄 또는 여러 줄에 있는 각 단말기 기호가 대체 정의임을 의미합니다. 예를 들어 ECMAScript의 렉시컬 문법에는 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          NonZeroDigit :: one of
            `1` `2` `3` `4` `5` `6` `7` `8` `9`
        </emu-grammar>
        <p>이는 다음과 같은 약어일 뿐입니다:</p>
        <emu-grammar type="definition" example>
          NonZeroDigit ::
            `1`
            `2`
            `3`
            `4`
            `5`
            `6`
            `7`
            `8`
            `9`
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-empty">
        <h1>[empty]</h1>
        <p>생산식의 우변에 “[empty]”가 나타나면, 해당 생산식의 우변이 단말기나 비단말기 기호를 전혀 포함하지 않음을 의미합니다.</p>
      </emu-clause>

      <emu-clause id="sec-lookahead-restrictions">
        <h1>앞보기 제한</h1>
        <p>생산식의 우변에 “[lookahead = _seq_]”가 나타나면, 해당 생산식은 토큰 시퀀스 _seq_가 바로 뒤따르는 입력 토큰 시퀀스의 접두사일 때만 사용될 수 있음을 의미합니다. 마찬가지로 “[lookahead ∈ _set_]”에서 _set_은 유한하고 비어 있지 않은 토큰 시퀀스 집합일 때, 집합의 어떤 요소가 바로 뒤따르는 토큰 시퀀스의 접두사일 때만 사용될 수 있음을 의미합니다. 편의상 집합을 비단말기로 쓸 수도 있는데, 이 경우 해당 비단말기가 확장할 수 있는 모든 토큰 시퀀스 집합을 나타냅니다. 비단말기가 무한히 많은 서로 다른 토큰 시퀀스로 확장될 수 있다면 이는 편집 오류로 간주합니다.</p>
        <p>이 조건들은 부정될 수도 있습니다. “[lookahead ≠ _seq_]”는 해당 생산식이 _seq_가 바로 뒤따르는 입력 토큰 시퀀스의 접두사가 <em>아니어야만</em> 사용할 수 있음을 의미하고, “[lookahead ∉ _set_]”는 집합의 어떤 요소도 바로 뒤따르는 토큰 시퀀스의 접두사가 <em>되어서는 안 될 때만</em> 사용될 수 있음을 의미합니다.</p>
        <p>예시로, 다음과 같은 정의를 보면:</p>
        <emu-grammar type="definition" example>
          DecimalDigit :: one of
            `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

          DecimalDigits ::
            DecimalDigit
            DecimalDigits DecimalDigit
        </emu-grammar>
        <p>다음과 같은 정의가 있습니다:</p>
        <emu-grammar type="definition" example>
          LookaheadExample ::
            `n` [lookahead &notin; { `1`, `3`, `5`, `7`, `9` }] DecimalDigits
            DecimalDigit [lookahead &notin; DecimalDigit]
        </emu-grammar>
        <p>이는 문자 `n` 다음에 첫 번째가 짝수인 하나 이상의 십진수 숫자가 오거나, 십진수 숫자 다음에 또 다른 십진수 숫자가 오지 않는 경우를 일치시킵니다.</p>
        <p>이러한 문구가 구문 문법에서 사용될 때, 바로 뒤따르는 토큰 시퀀스를 명확히 식별하는 것이 불가능할 수 있습니다. 이는 이후 토큰을 결정하려면 이후 위치에서 사용할 렉시컬 목표 기호를 알아야 하기 때문입니다. 그러므로 구문 문법에서 이러한 제한이 사용될 때, 토큰 시퀀스 _seq_가 접두사 제한에 나타나면(집합의 일부로 포함된 경우도 포함), 이후 사용할 렉시컬 목표 기호 선택에 따라 _seq_가 실제로 접두사가 되는지 여부가 바뀔 수 있다면, 이는 편집 오류로 간주합니다.</p>
      </emu-clause>

      <emu-clause id="sec-no-lineterminator-here">
        <h1>[여기 |LineTerminator| 없음]</h1>
        <p>구문 문법의 생산식 우변에 “[no |LineTerminator| here]”가 나타나면, 해당 생산식은 <em>제한 생산식</em>이며, 해당 위치에 입력 스트림에서 |LineTerminator|가 나타나면 사용할 수 없습니다. 예를 들어 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          ThrowStatement :
            `throw` [no LineTerminator here] Expression `;`
        </emu-grammar>
        <p>이는 스크립트에서 `throw` 토큰과 |Expression| 사이에 |LineTerminator|가 있으면 해당 생산식을 사용할 수 없음을 의미합니다.</p>
        <p>제한 생산식에서 |LineTerminator|의 존재가 금지되지 않는 한, 입력 요소 스트림의 연속된 두 토큰 사이에는 |LineTerminator|가 아무리 많이 있어도 스크립트의 구문적 허용성에 영향을 주지 않습니다.</p>
      </emu-clause>

      <emu-clause id="sec-but-not">
        <h1>but not</h1>
        <p>생산식의 우변에 “<b>but not</b>” 문구가 오면, 뒤이어 제외할 확장을 명시하여 특정 확장이 허용되지 않음을 나타냅니다. 예를 들어 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          Identifier ::
            IdentifierName but not ReservedWord
        </emu-grammar>
        <p>이는 비단말기 |Identifier|가 |IdentifierName|을 대체할 수 있는 코드 포인트 시퀀스 중, 동일한 시퀀스가 |ReservedWord|를 대체할 수 없는 경우에만 사용할 수 있음을 의미합니다.</p>
      </emu-clause>

      <emu-clause id="sec-descriptive-phrases">
        <h1>서술적 구문</h1>
        <p>마지막으로 일부 비단말기 기호는 모든 대안을 나열하는 것이 비현실적인 경우 산세리프체로 서술적 문구로 설명됩니다:</p>
        <emu-grammar type="definition" example>
          SourceCharacter ::
            &gt; any Unicode code point
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-algorithm-conventions">
    <h1>알고리즘 관례</h1>
    <p>이 명세서는 알고리즘 단계 지정을 위해 주로 번호가 매겨진 목록을 사용합니다. 이러한 알고리즘은 ECMAScript 언어 구성 요소의 요구 의미론을 정확하게 명시하는 데 사용됩니다. 알고리즘이 특정 구현 기법의 사용을 암시하는 것은 아닙니다. 실제로, 주어진 기능을 더 효율적으로 구현할 수 있는 알고리즘이 있을 수 있습니다.</p>
    <p>알고리즘은 명시적으로 순서가 있는 쉼표로 구분된 별칭 이름 시퀀스로 매개변수화될 수 있으며, 알고리즘 단계 내에서 해당 위치에 전달된 인자를 참조하는 데 사용할 수 있습니다. 선택적 매개변수는 대괄호([ , _name_ ])로 나타내며, 알고리즘 단계 내에서는 필수 매개변수와 차이가 없습니다. 나머지 매개변수(rest parameter)는 매개변수 리스트 끝에 ..._name_ 형태로 나타내며, 필수 및 선택적 매개변수 뒤에 전달된 모든 인자를 List로 수집합니다. 추가 인자가 없는 경우 해당 List는 비어 있습니다.</p>
    <p>알고리즘 단계는 순차적 하위 단계로 세분화될 수 있습니다. 하위 단계는 들여쓰기되며, 그 자체로 더 들여쓰기된 하위 단계로 나뉠 수 있습니다. 개요 번호 매기기 규칙은 첫 번째 하위 단계는 소문자 알파벳, 두 번째 하위 단계는 소문자 로마 숫자를 사용합니다. 세 단계보다 더 깊은 단계가 필요할 경우, 네 번째 단계부터는 숫자를 사용합니다. 예시:</p>
    <emu-alg example>
      1. 최상위 단계
        1. 하위 단계.
        1. 하위 단계.
          1. 하위 하위 단계.
            1. 하위 하위 하위 단계
              1. 하위 하위 하위 하위 단계
                1. 하위 하위 하위 하위 하위 단계
    </emu-alg>
    <p>단계나 하위 단계는 "if" 조건문으로 작성될 수 있으며, 이 경우 조건이 true일 때만 하위 단계를 적용합니다. 단계나 하위 단계가 "else"로 시작하면, 해당 단계는 같은 수준의 직전 “if” 조건문의 부정이 됩니다.</p>
    <p>단계는 하위 단계의 반복적 적용을 지정할 수 있습니다.</p>
    <p>"<dfn id="assert">Assert</dfn>:"로 시작하는 단계는 알고리즘의 불변 조건을 단언합니다. 이러한 단언은 암묵적일 수 있는 알고리즘 불변 조건을 명시적으로 만듭니다. 이러한 단언은 추가적인 의미 요구사항을 더하지 않으므로 구현에서는 검사할 필요가 없습니다. 단순히 알고리즘을 명확히 하기 위해 사용됩니다.</p>
    <p>알고리즘 단계에서는 "Let _x_ be _someValue_" 형식으로 어떤 값에 대한 별칭을 선언할 수 있습니다. 이 별칭은 참조와 유사하여 _x_와 _someValue_가 동일한 데이터에 연결되며, 둘 중 하나를 수정하면 모두에 반영됩니다. 참조와 유사한 동작을 피하고 싶으면, 오른쪽 값을 명시적으로 복사하도록 "Let _x_ be a copy of _someValue_"를 사용합니다. 이는 _someValue_의 얕은 복사를 만듭니다.</p>
    <p>별칭이 선언된 이후에는 모든 이후 단계에서 참조할 수 있으며, 선언 이전 단계에서 참조해서는 안 됩니다. 별칭은 "Set _x_ to _someOtherValue_" 형태로 수정할 수 있습니다.</p>

    <emu-clause id="sec-algorithm-conventions-abstract-operations">
      <h1>추상 연산</h1>
      <p>이 명세서의 여러 부분에서 사용할 수 있도록, 일부 알고리즘(추상 연산)은 이름을 붙이고 매개변수화된 함수 형태로 작성되며, 다른 알고리즘 내에서 이름으로 참조될 수 있습니다. 추상 연산은 일반적으로 함수 호출 형태(OperationName(_arg1_, _arg2_))로 참조됩니다. 일부 추상 연산은 클래스와 유사한 명세 추상화의 다형적 메서드로 취급됩니다. 이러한 메서드형 추상 연산은 _someValue_.OperationName(_arg1_, _arg2_)와 같은 메서드 호출 형태로 참조됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-algorithm-conventions-syntax-directed-operations">
      <h1>구문 지향 연산</h1>
      <p><dfn variants="syntax-directed operations">구문 지향 연산</dfn>은 이름이 붙은 연산으로, 각 연산은 ECMAScript 문법의 하나 이상의 생산식과 연결된 알고리즘으로 정의됩니다. 여러 대안 정의가 있는 생산식은 일반적으로 각 대안마다 별도의 알고리즘을 가집니다. 알고리즘이 문법 생산식과 연결되어 있을 때, 해당 생산식의 단말기와 비단말기 기호를 알고리즘의 매개변수처럼 참조할 수 있습니다. 이때 비단말기 기호는 소스 텍스트를 파싱할 때 실제로 일치된 대안 정의를 참조합니다. <dfn oldids="sec-static-semantics-sourcetext">문법 생산식 또는 그로부터 파생된 파스 노드가 일치시킨 소스 텍스트</dfn>는 일치에 참여한 첫 번째 단말기에서 시작하여 마지막 단말기에서 끝나는 소스 텍스트의 부분입니다.</p>
      <p>알고리즘이 생산식 대안과 연결될 때, 대안은 일반적으로 “[ ]” 문법 주석 없이 표시됩니다. 이러한 주석은 대안의 구문 인식에만 영향을 주며, 연결된 의미에는 영향을 주지 않습니다.</p>
      <p>구문 지향 연산은 파스 노드와 필요에 따라 추가 매개변수를 넘겨 호출합니다. 다음 알고리즘의 <emu-xref href="#step-sdo-invocation-example-1"></emu-xref>, <emu-xref href="#step-sdo-invocation-example-2"></emu-xref>, <emu-xref href="#step-sdo-invocation-example-3"></emu-xref> 단계를 참고하세요:</p>
      <emu-alg example>
        1. [id="step-sdo-invocation-example-1"] Let _status_ be SyntaxDirectedOperation of |SomeNonTerminal|.
        1. Let _someParseNode_ be the parse of some source text.
        1. [id="step-sdo-invocation-example-2"] Perform SyntaxDirectedOperation of _someParseNode_.
        1. [id="step-sdo-invocation-example-3"] Perform SyntaxDirectedOperation of _someParseNode_ with argument *"value"*.
      </emu-alg>
      <p>별도로 명시되지 않는 한, 모든 체인 생산식은 해당 좌변 비단말기에 적용될 수 있는 모든 연산에 대해 암시적 정의를 가집니다. 암시적 정의는 동일한 연산을 동일한 매개변수로 체인 생산식의 유일한 우변 비단말기에 다시 적용한 다음 그 결과를 반환합니다. 예를 들어, 어떤 알고리즘에 “Return Evaluation of |Block|”이라는 단계가 있고, 다음과 같은 생산식이 있다고 가정합니다:</p>
      <emu-grammar example>
        Block :
          `{` StatementList `}`
      </emu-grammar>
      <p>Evaluation 연산이 해당 생산식과 연결된 알고리즘을 갖지 않는 경우, Evaluation 연산은 다음과 같은 연결을 암시적으로 포함합니다:</p>
      <p><b>런타임 의미론: Evaluation</b></p>
      <emu-grammar example>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg example>
        1. Return Evaluation of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics">
      <h1>런타임 의미론</h1>
      <p>런타임에 호출되어야 하는 의미론을 명시하는 알고리즘을 <dfn>런타임 의미론</dfn>이라고 합니다. 런타임 의미론은 추상 연산 또는 구문 지향 연산으로 정의됩니다.</p>

      <emu-clause id="sec-completion-ao" type="abstract operation">
        <h1>
          Completion (
            _completionRecord_: a Completion Record,
          ): a Completion Record
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>Completion Record를 반환함을 강조하기 위해 사용됩니다.</dd>
          <dt>return 검사 생략</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: _completionRecord_는 Completion Record이다.
          1. _completionRecord_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throw-an-exception">
        <h1>예외 던지기</h1>
        <p>알고리즘 단계에서 예외를 던지라고 명시된 경우(예:</p>
        <emu-alg example>
          1. *TypeError* 예외를 던진다.
        </emu-alg>
        <p>)는 다음과 동일한 의미입니다:</p>
        <emu-alg example>
          1. Return ThrowCompletion(새로 생성된 *TypeError* 객체).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt" aoid="ReturnIfAbrupt">
        <h1>ReturnIfAbrupt</h1>
        <p>다음과 같이 명시된 알고리즘 단계:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_argument_).
        </emu-alg>
        <p>는 다음과 동일합니다:</p>
        <emu-alg example>
          1. Assert: _argument_는 Completion Record이다.
          1. _argument_가 abrupt completion이면 Completion(_argument_)를 반환한다.
          1. 그렇지 않으면, _argument_를 _argument_.[[Value]]로 설정한다.
        </emu-alg>
        <p>다음과 같이 명시된 알고리즘 단계:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(AbstractOperation()).
        </emu-alg>
        <p>는 다음과 동일합니다:</p>
        <emu-alg example>
          1. Let _hygienicTemp_ be AbstractOperation().
          1. Assert: _hygienicTemp_는 Completion Record이다.
          1. _hygienicTemp_가 abrupt completion이면 Completion(_hygienicTemp_)를 반환한다.
          1. 그렇지 않으면, _hygienicTemp_를 _hygienicTemp_.[[Value]]로 설정한다.
        </emu-alg>
        <p>여기서 _hygienicTemp_는 일시적이며, ReturnIfAbrupt 관련 단계에서만 보입니다.</p>
        <p>다음과 같이 명시된 알고리즘 단계:</p>
        <emu-alg example>
          1. Let _result_ be AbstractOperation(ReturnIfAbrupt(_argument_)).
        </emu-alg>
        <p>는 다음과 동일합니다:</p>
        <emu-alg example>
          1. Assert: _argument_는 Completion Record이다.
          1. _argument_가 abrupt completion이면 Completion(_argument_)를 반환한다.
          1. 그렇지 않으면, _argument_를 _argument_.[[Value]]로 설정한다.
          1. Let _result_ be AbstractOperation(_argument_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt-shorthands">
        <h1>ReturnIfAbrupt 축약 표기</h1>
        <p>추상 연산 및 구문 지향 연산의 호출 앞에 `?`가 붙으면, 결과 Completion Record에 ReturnIfAbrupt를 적용해야 함을 나타냅니다. 예를 들어:</p>
        <emu-alg example>
          1. ? OperationName().
        </emu-alg>
        <p>는 다음 단계와 같습니다:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(OperationName()).
        </emu-alg>
        <p>메서드 호출 형태에서도 마찬가지로 다음 단계:</p>
        <emu-alg example>
          1. ? _someValue_.OperationName().
        </emu-alg>
        <p>는 다음과 같습니다:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_someValue_.OperationName()).
        </emu-alg>
        <p>마찬가지로, `!`를 앞에 붙이면, 해당 추상 또는 구문 지향 연산이 abrupt completion을 반환하지 않음을 의미하며, 결과 Completion Record의 [[Value]] 필드를 연산의 반환값으로 사용함을 나타냅니다. 예를 들어:</p>
        <emu-alg example>
          1. Let _val_ be ! OperationName().
        </emu-alg>
        <p>는 다음 단계와 같습니다:</p>
        <emu-alg example>
          1. Let _val_ be OperationName().
          1. Assert: _val_은 정상 completion이다.
          1. _val_을 _val_.[[Value]]로 설정한다.
        </emu-alg>
        <p>런타임 의미론용 구문 지향 연산에서는 이 축약 표기를 사용하여 연산 호출 앞에 `!` 또는 `?`를 둡니다:</p>
        <emu-alg example>
          1. Perform ! SyntaxDirectedOperation of |NonTerminal|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-implicit-normal-completion" oldids="sec-implicit-completion-values">
        <h1>암시적 정상 Completion</h1>
        <p>Completion Record를 반환하도록 선언된 추상 연산 내부 알고리즘과 모든 내장 함수에서는 반환값이 먼저 NormalCompletion에 전달되고, 그 결과가 대신 사용됩니다. 이 규칙은 Completion 알고리즘 내부 또는 반환되는 값이 해당 단계에서 Completion Record로 명확히 표시된 경우에는 적용되지 않습니다. 적용 예시는 다음과 같습니다:</p>
        <ul>
          <li>Completion, NormalCompletion, ThrowCompletion, ReturnCompletion을 적용한 결과를 바로 반환할 때</li>
          <li>Completion Record를 생성한 결과를 바로 반환할 때</li>
        </ul>
        <p>이러한 추상 연산에서 다른 방식으로 Completion Record를 반환하면 편집 오류입니다. 예를 들어, 다음과 같은 경우,</p>
        <emu-alg example>
          1. Return *true*.
        </emu-alg>
        <p>는 다음 중 아무거나와 동일합니다:</p>
        <emu-alg example>
          1. Return NormalCompletion(*true*).
        </emu-alg>
        <p>또는</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*).
          1. Return Completion(_completion_).
        </emu-alg>
        <p>또는</p>
        <emu-alg example>
          1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: *true*, [[Target]]: ~empty~ }.
        </emu-alg>
        <p>ReturnIfAbrupt 확장에 따라, 다음 예시는 허용됩니다. 확장된 단계 내에서는 Completion 적용 결과가 abrupt인 경우 바로 반환되고, normal인 경우 unwrapping 후 암시적 NormalCompletion이 적용됩니다.</p>
        <emu-alg example>
          1. Return ? _completion_.
        </emu-alg>
        <p>다음 예시는 Completion Record가 해당 단계에서 명시되지 않은 채 반환되므로 편집 오류입니다.</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*).
          1. Return _completion_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-static-semantic-rules">
      <h1>정적 의미론</h1>
      <p>문맥 자유 문법만으로는 입력 요소 스트림이 평가 가능한 ECMAScript |Script| 또는 |Module|로서 유효한지를 정의하는 모든 규칙을 표현할 수 없습니다. 일부 상황에서는 ECMAScript 알고리즘 관례나 산문 요구사항을 활용해서 추가 규칙을 명시해야 하며, 이러한 규칙은 항상 문법의 생산식과 연결되어 <dfn>해당 생산식의 정적 의미론</dfn>이라 불립니다.</p>
      <p>정적 의미론 규칙에는 이름이 있으며, 일반적으로 알고리즘으로 정의됩니다. 이름이 붙은 정적 의미론 규칙은 문법 생산식과 연결되며, 여러 대안 정의가 있는 생산식은 각 대안마다 해당 규칙에 대해 별도의 알고리즘을 가집니다.</p>
      <p>정적 의미론 규칙의 특별한 종류가 <dfn id="early-error-rule">초기 오류 규칙(Early Error Rule)</dfn>입니다. 초기 오류 규칙은 특정 문법 생산식과 연결된 초기 오류 조건을 정의하며(<emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 참조), 대부분의 초기 오류 규칙은 이 명세서 알고리즘에서 명시적으로 호출되지 않습니다. 적합한 구현체는 |Script| 또는 |Module|을 최초로 평가하기 전에, 해당 |Script| 또는 |Module|을 파싱하는 데 사용된 모든 생산식의 초기 오류 규칙을 반드시 검증해야 합니다. 초기 오류 규칙이 하나라도 위반되면 |Script| 또는 |Module|은 유효하지 않으며 평가될 수 없습니다.</p>
    </emu-clause>

    <emu-clause id="sec-mathematical-operations">
      <h1>수학 연산</h1>
      <p>이 명세서에서 참조하는 숫자값 종류는 다음과 같습니다:</p>
      <ul>
        <li><dfn id="mathematical-value" variants="mathematical value,mathematical values">수학적 값</dfn>: 임의의 실수. 기본 숫자 타입으로 사용됨.</li>
        <li><dfn id="extended-mathematical-value" variants="extended mathematical value,extended mathematical values">확장 수학적 값</dfn>: 수학적 값과 +∞, -∞ 포함.</li>
        <li><em>Numbers</em>: IEEE 754-2019 binary64(배정밀도 부동소수점) 값.</li>
        <li><em>BigInts</em>: ECMAScript 언어값으로, 임의의 정수와 일대일 대응됨.</li>
      </ul>

      <p>이 명세서에서 숫자값은 첨자 표기로 종류를 구분합니다. 첨자 <sub>𝔽</sub>는 Numbers를, <sub>ℤ</sub>는 BigInts를 나타냅니다. 첨자 없는 숫자값은 수학적 값을 의미합니다. 대부분의 숫자값은 10진수로 표기되며, 0x로 시작하고 0-9 또는 A-F로 이어지는 값은 16진수로 사용됩니다.</p>
      <p>명세서에서 "the length of _y_"나 "the integer represented by the four hexadecimal digits ..."와 같이 명시적 숫자 종류 없이 숫자값을 언급하면, 이는 수학적 값을 의미합니다. Number나 BigInt 값을 명시할 경우, "the Number value for ..." 또는 "the BigInt value for ..."와 같이 명시적으로 구분합니다.</p>
      <p><dfn id="integer" oldids="mathematical integer" variants="integers">integer</dfn>라는 용어는 별도 명시가 없는 한, 정수 집합에 속하는 수학적 값을 의미합니다. <dfn id="integral-number" oldids="sec-isintegralnumber,sec-isinteger" variants="integral Numbers">integral Number</dfn>라는 용어는 수학적으로 정수 집합에 속하는 유한한 Number 값을 의미합니다.</p>
      <p>+, ×, =, ≥ 등 숫자 연산자는 피연산자의 타입에 따라 연산이 결정됩니다. 수학적 값에 적용하면 일반 수학 연산을, 확장 수학적 값에 적용하면 확장 실수에 대한 연산을 의미합니다. 정의되지 않은 형태는 사용해서는 안 되며, 명세서에 사용되면 편집 오류입니다. Numbers에 적용하면 IEEE 754-2019에 따른 연산을, BigInts에 적용하면 BigInt의 수학적 값에 대한 연산을 의미합니다. 타입이 혼합된(예: Number와 수학적 값) 피연산자에 대한 숫자 연산은 정의되지 않으며, 명세서에서 사용되면 편집 오류입니다.</p>
      <p>수학적 값과 Number 또는 BigInt 간의 변환은 항상 명시적으로 나타납니다. 수학적 값 또는 확장 수학적 값 _x_를 Number로 변환하면 "the Number value for _x_" 또는 <emu-eqn id="𝔽" aoid="𝔽">𝔽(_x_)</emu-eqn>로 표기하며, <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>에서 정의됩니다. 정수 _x_를 BigInt로 변환하면 "the <dfn id="bigint-value-for">BigInt value for</dfn> _x_" 또는 <emu-eqn id="ℤ" aoid="ℤ">ℤ(_x_)</emu-eqn>로 표기합니다. Number 또는 BigInt _x_를 수학적 값으로 변환하면 "the <dfn id="mathematical-value-of">mathematical value of</dfn> _x_" 또는 <emu-eqn id="ℝ" aoid="ℝ">ℝ(_x_)</emu-eqn>로 표기합니다. *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>의 수학적 값은 0입니다. 비유한 값의 수학적 값은 정의되지 않습니다. <dfn id="extended-mathematical-value-of">extended mathematical value of</dfn> _x_는 유한 값에는 수학적 값, *+∞*<sub>𝔽</sub>와 *-∞*<sub>𝔽</sub>에는 각각 +∞, -∞가 되며, *NaN*에는 정의되지 않습니다.</p>
      <p>수학 함수 <emu-eqn id="eqn-abs" aoid="abs">abs(_x_)</emu-eqn>는 _x_의 절댓값을 반환하며, _x_ &lt; 0이면 <emu-eqn>-_x_</emu-eqn>, 그렇지 않으면 _x_ 자체입니다.</p>
      <p>수학 함수 <emu-eqn id="eqn-min" aoid="min">min(_x1_, _x2_, … , _xN_)</emu-eqn>은 <emu-eqn>_x1_</emu-eqn> ~ <emu-eqn>_xN_</emu-eqn> 중 가장 작은 값을 반환합니다. <emu-eqn id="eqn-max" aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn>은 가장 큰 값을 반환합니다. 이 수학 함수의 정의역과 값의 범위는 확장 수학적 값입니다.</p>
      <p>“<emu-eqn id="eqn-modulo" aoid="modulo">_x_ modulo _y_</emu-eqn>”(_y_는 유한하고 0이 아니어야 함)은 _y_와 같은 부호(또는 0)를 가진 값 _k_를 계산하며, <emu-eqn>abs(_k_) &lt; abs(_y_) and _x_ - _k_ = _q_ × _y_</emu-eqn>를 만족하는 정수 _q_가 존재합니다.</p>
      <p>"the result of <dfn id="clamping">clamping</dfn> _x_ between _lower_ and _upper_"(_x_는 확장 수학적 값, _lower_, _upper_는 _lower_ ≤ _upper_인 수학적 값)란, _x_ &lt; _lower_면 _lower_, _x_ > _upper_면 _upper_, 아니면 _x_를 반환합니다.</p>
      <p>수학 함수 <emu-eqn id="eqn-floor" aoid="floor">floor(_x_)</emu-eqn>는 _x_보다 크지 않은 가장 큰 정수(가장 +∞에 가까운)를 반환합니다.</p>
      <emu-note>
        <p><emu-eqn>floor(_x_) = _x_ - (_x_ modulo 1)</emu-eqn>.</p>
      </emu-note>
      <p>수학 함수 <emu-eqn id="eqn-truncate" aoid="truncate">truncate(_x_)</emu-eqn>는 _x_의 소수 부분을 제거하며, _x_ &lt; 0이면 <emu-eqn>-floor(-_x_)</emu-eqn>, 아니면 <emu-eqn>floor(_x_)</emu-eqn>를 반환합니다.</p>
      <p>min, max, abs, floor, truncate 함수는 Numbers와 BigInts에는 정의되지 않으며, 수학적 값이 아닌 인자를 사용하는 경우 명세서에서 편집 오류입니다.</p>
      <p>하한 _a_ ~ 상한 _b_의 <dfn id="interval">구간</dfn>은 동일 숫자 타입의 값 집합이며, 무한 혹은 빈 집합일 수 있습니다. 각 구간의 경계는 포함 또는 제외로 표시되나, 둘 다는 아닙니다. 구간 종류는 다음 네 가지입니다:</p>
      <ul>
        <li>_a_ (포함) ~ _b_ (포함) 구간(<dfn id="inclusive-interval">inclusive interval</dfn>)은 _a_ ≤ _x_ ≤ _b_인 값만 포함합니다.</li>
        <li>_a_ (포함) ~ _b_ (제외) 구간은 _a_ ≤ _x_ &lt; _b_인 값만 포함합니다.</li>
        <li>_a_ (제외) ~ _b_ (포함) 구간은 _a_ &lt; _x_ ≤ _b_인 값만 포함합니다.</li>
        <li>_a_ (제외) ~ _b_ (제외) 구간은 _a_ &lt; _x_ &lt; _b_인 값만 포함합니다.</li>
      </ul>
      <p>예를 들어 1(포함) ~ 2(제외) 구간은 1 이상 2 미만의 모든 수학적 값을 포함하며, 1은 포함, 2는 포함하지 않습니다. 구간 정의에서 *-0*<sub>𝔽</sub> &lt; *+0*<sub>𝔽</sub>이므로, 하한이 *+0*<sub>𝔽</sub>인 포함 구간은 *+0*<sub>𝔽</sub>는 포함하나 *-0*<sub>𝔽</sub>는 포함하지 않습니다. *NaN*은 절대 구간에 포함되지 않습니다.</p>
    </emu-clause>

    <emu-clause id="sec-value-notation">
      <h1>값 표기법</h1>
      <p>이 명세서에서 ECMAScript 언어값은 *굵게* 표시됩니다. 예시로 *null*, *true*, *"hello"* 등이 있으며, `Function.prototype.apply`나 `let n = 42;`처럼 ECMAScript 소스 텍스트와 구분됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-identity">
      <h1>동일성</h1>
      <p>이 명세서에서는 명세 값과 ECMAScript 언어값 모두 동등성 비교를 합니다. 동등성 비교 시 값은 두 가지 범주로 나뉩니다. <dfn variants="values without identity,value without identity">동일성 없는 값</dfn>은 모든 고유 특성이 동일하면 서로 동등합니다(예: 정수 크기나 시퀀스 길이). 이러한 값은 특성만으로 참조 없이 나타낼 수 있습니다. 반면 <dfn variants="values with identity">동일성 있는 값</dfn>은 유일하며 자기 자신과만 동등합니다. 동일성 있는 값은 동일성 없는 값과 같으나, <em>동일성</em>이라는 추정 불가, 변경 불가, 전역적으로 유일한 특성을 추가로 가집니다. 기존 동일성 있는 값 참조는 특성 설명만으로 나타낼 수 없으며, 반드시 값을 명시적으로 전달해야 합니다. 일부 동일성 있는 값은 변경 가능하여, 동일성 외 특성이 변하면 모든 참조자가 변경을 관찰합니다. 동일성 없는 값은 동일성 있는 값과 결코 동등하지 않습니다.</p>
      <p>명세 관점에서 “is”는 두 값을 동등 비교하는 데 사용되며(예: “If _bool_ is *true*, then ...”), “contains”는 리스트 내 값을 동등 비교로 찾는 데 사용됩니다(예: "If _list_ contains a Record _r_ such that _r_.[[Foo]] is *true*, then ..."). 값의 <em>명세 동일성</em>이 비교 결과를 결정하며, 이는 명세적으로 자명합니다.</p>
      <p>ECMAScript 언어 관점에서는 언어값을 SameValue 추상 연산 및 그 하위 추상 연산으로 비교합니다. 이 비교 추상 연산 알고리즘이 ECMAScript 언어값의 <em>언어 동일성</em>을 결정합니다.</p>
      <p>명세 값 중 동일성 없는 예시는: 수학적 값과 확장 수학적 값, ECMAScript 소스 텍스트, surrogate pair, Directive Prologue 등, UTF-16 코드 유닛, 유니코드 코드 포인트, enum, 추상 연산(구문 지향 연산, host hook 등), 정렬된 쌍 등이 있습니다. 동일성 있는 예시는: Property Descriptor, PrivateElement 등 다양한 Record, Parse Node, List, <emu-xref href="#sec-set-and-relation-specification-type">Set</emu-xref>과 Relation, Abstract Closure, Data Block, Private Name, 실행 컨텍스트 및 스택, agent signifier, WaiterList Record 등이 있습니다.</p>
      <p>명세 동일성은 ECMAScript 언어값 중 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>로 생성된 Symbol을 제외하고 언어 동일성과 일치합니다. 명세 동일성 및 언어 동일성 모두 없는 ECMAScript 언어값은 <emu-xref href="#sec-ecmascript-language-types-undefined-type">*undefined*</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-null-type">*null*</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-boolean-type">Boolean</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-string-type">String</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-number-type">Number</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-bigint-type">BigInt</emu-xref>입니다. 명세 동일성과 언어 동일성을 모두 가지는 ECMAScript 언어값은 <emu-xref href="#sec-ecmascript-language-types-symbol-type">Symbol</emu-xref>(단, <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 생성이 아닌 경우) 및 <emu-xref href="#sec-object-type">Object</emu-xref>입니다. <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>로 생성된 Symbol은 명세 동일성은 있으나 언어 동일성은 없습니다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript 데이터 타입과 값</h1>
  <p>이 명세서의 알고리즘은 각각 타입이 연관된 값을 다룹니다. 가능한 값의 타입은 이 절에서 정의된 것들만 해당합니다. 타입은 ECMAScript 언어 타입과 명세 타입으로 분류됩니다.</p>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript 언어 타입</h1>
    <p><dfn variants="ECMAScript language types">ECMAScript 언어 타입</dfn>은 ECMAScript 프로그래머가 ECMAScript 언어를 통해 직접 다루는 값에 해당합니다. ECMAScript 언어 타입에는 Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object가 있습니다. <dfn variants="ECMAScript language values">ECMAScript 언어 값</dfn>은 ECMAScript 언어 타입에 의해 특징지어지는 값입니다.</p>

    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>Undefined 타입</h1>
      <p>Undefined 타입은 *undefined*라는 단 하나의 값만을 가집니다. 값이 할당되지 않은 변수는 *undefined* 값을 가집니다.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>Null 타입</h1>
      <p>Null 타입은 *null*이라는 단 하나의 값만을 가집니다.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>Boolean 타입</h1>
      <p><dfn variants="is a Boolean,is not a Boolean">Boolean 타입</dfn>은 *true*와 *false*라는 두 값을 가지는 논리적 개체를 나타냅니다.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>String 타입</h1>
      <p><dfn variants="is a String,is not a String">String 타입</dfn>은 0개 이상의 16비트 부호 없는 정수값(“요소”)으로 이루어진 모든 순서 있는 시퀀스의 집합이며, 최대 길이는 2<sup>53</sup> - 1 요소까지입니다. String 타입은 일반적으로 ECMAScript 프로그램에서 텍스트 데이터를 표현하는 데 사용되며, 이 경우 String의 각 요소는 UTF-16 코드 유닛 값으로 간주됩니다. 각 요소는 시퀀스 내에서 위치를 가지며, 이 위치는 0 이상의 정수 인덱스로 지정됩니다. 첫 번째 요소(존재한다면)는 인덱스 0, 그 다음 요소는 인덱스 1 등입니다. String의 길이는 그 안에 포함된 요소(즉, 16비트 값)의 개수입니다. 빈 문자열은 길이가 0이며, 요소가 존재하지 않습니다.</p>
      <p>String 내용을 해석하지 않는 ECMAScript 연산은 추가 의미를 적용하지 않습니다. String 값을 해석하는 연산은 각 요소를 단일 UTF-16 코드 유닛으로 취급합니다. 그러나 ECMAScript는 이 코드 유닛의 값이나 관계를 제한하지 않으므로, 추가적으로 String 내용을 UTF-16로 인코딩된 유니코드 코드 포인트 시퀀스로 해석하는 연산은 잘못된 하위 시퀀스를 고려해야 합니다. 이러한 연산은 다음 규칙에 따라 0xD800~0xDBFF(유니코드 표준에서 <dfn id="leading-surrogate" variants="leading surrogates">선행 서러게이트</dfn>, 또는 <dfn id="high-surrogate-code-unit" variants="high-surrogate code units">high-surrogate 코드 유닛</dfn>)와 0xDC00~0xDFFF(<dfn id="trailing-surrogate" variants="trailing surrogates">후행 서러게이트</dfn>, 또는 <dfn id="low-surrogate-code-unit" variants="low-surrogate code units">low-surrogate 코드 유닛</dfn>) 값을 특별 처리합니다:</p>
      <ul>
        <li>
          선행 서러게이트도 아니고 후행 서러게이트도 아닌 코드 유닛은 동일한 값의 코드 포인트로 해석됩니다.
        </li>
        <li>
          첫 번째 코드 유닛 _c1_이 선행 서러게이트이고 두 번째 코드 유닛 _c2_가 후행 서러게이트인 두 개의 코드 유닛 시퀀스는 <dfn id="surrogate-pair" variants="surrogate pairs">서러게이트 페어</dfn>이며, (_c1_ - 0xD800) × 0x400 + (_c2_ - 0xDC00) + 0x10000 값의 코드 포인트로 해석됩니다. (<emu-xref href="#sec-utf16decodesurrogatepair"></emu-xref> 참고)
        </li>
        <li>
          서러게이트 페어의 일부가 아닌 선행 서러게이트 또는 후행 서러게이트 코드 유닛은 동일한 값의 코드 포인트로 해석됩니다.
        </li>
      </ul>
      <p>`String.prototype.normalize` 함수(<emu-xref href="#sec-string.prototype.normalize"></emu-xref>)는 String 값을 명시적으로 정규화하는 데 사용할 수 있습니다. `String.prototype.localeCompare`(<emu-xref href="#sec-string.prototype.localecompare"></emu-xref>)는 내부적으로 String 값을 정규화하지만, 다른 연산은 암묵적으로 문자열을 정규화하지 않습니다. 연산 결과가 언어 또는 로케일에 민감하지 않음이 별도로 명시되지 않는 한 적용됩니다.</p>
      <emu-note>
        <p>이 설계의 취지는 문자열 구현을 최대한 단순하고 고성능으로 유지하는 것이었습니다. ECMAScript 소스 텍스트가 Normalized Form C인 경우, 문자열 리터럴은 유니코드 이스케이프 시퀀스를 포함하지 않는 한 정규화가 보장됩니다.</p>
      </emu-note>
      <p>이 명세서에서 "the <dfn id="string-concatenation">string-concatenation</dfn> of _A_, _B_, ..."라는 구문(각 인자가 String 값, 코드 유닛, 또는 코드 유닛 시퀀스임)은 인자 각각의 코드 유닛을 차례로 이어붙인 시퀀스로 구성된 String 값을 의미합니다.</p>
      <p>"the <dfn id="substring">substring</dfn> of _S_ from _inclusiveStart_ to _exclusiveEnd_"(여기서 _S_는 String 값 또는 코드 유닛 시퀀스, _inclusiveStart_와 _exclusiveEnd_는 정수)라는 구문은 _inclusiveStart_ 인덱스에서 시작하여 _exclusiveEnd_ 바로 앞까지 연속된 코드 유닛으로 구성된 String 값을 의미합니다(_inclusiveStart_ = _exclusiveEnd_이면 빈 문자열). "to" 접미사가 생략된 경우, _S_의 길이가 _exclusiveEnd_로 사용됩니다.</p>
      <p>
        "<dfn id="ASCII-word-characters">ASCII word characters</dfn>"라는 구문은 다음 String 값을 의미하며, 이는 유니코드 Basic Latin 블록 내 모든 문자와 숫자, U+005F(LOW LINE)만으로 구성됩니다:<br>
        *"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"*.<br>
        역사적 이유로 여러 알고리즘에서 의미를 가집니다.
      </p>

      <emu-clause id="sec-stringindexof" type="abstract operation">
        <h1>
          StringIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer 또는 ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _string_의 길이를 _len_으로 한다.
          1. _searchValue_가 빈 문자열이고 _fromIndex_ ≤ _len_이면 _fromIndex_를 반환한다.
          1. _searchValue_의 길이를 _searchLen_으로 한다.
          1. _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_인 각 정수 _i_에 대해 오름차순으로,
            1. _string_의 _i_에서 _i_ + _searchLen_까지의 substring을 _candidate_로 한다.
            1. _candidate_가 _searchValue_와 같다면 _i_를 반환한다.
          1. ~not-found~를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_searchValue_가 빈 문자열이고 _fromIndex_ ≤ _string_의 길이면 이 알고리즘은 _fromIndex_를 반환합니다. 빈 문자열은 문자열 내 모든 위치(마지막 코드 유닛 뒤 포함)에서 발견된 것으로 간주됩니다.</p>
        </emu-note>
        <emu-note>
          <p>_fromIndex_ + _searchValue_의 길이 > _string_의 길이이면 이 알고리즘은 항상 ~not-found~를 반환합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-stringlastindexof" type="abstract operation">
        <h1>
          StringLastIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer 또는 ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _string_의 길이를 _len_으로 한다.
          1. _searchValue_의 길이를 _searchLen_으로 한다.
          1. Assert: _fromIndex_ + _searchLen_ ≤ _len_.
          1. 0 ≤ _i_ ≤ _fromIndex_인 각 정수 _i_에 대해 내림차순으로,
            1. _string_의 _i_에서 _i_ + _searchLen_까지의 substring을 _candidate_로 한다.
            1. _candidate_가 _searchValue_와 같다면 _i_를 반환한다.
          1. ~not-found~를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_searchValue_가 빈 문자열이면 이 알고리즘은 _fromIndex_를 반환합니다. 빈 문자열은 문자열 내 모든 위치(마지막 코드 유닛 뒤 포함)에서 발견된 것으로 간주됩니다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>Symbol 타입</h1>
      <p><dfn variants="is a Symbol,is not a Symbol">Symbol 타입</dfn>은 Object 프로퍼티의 키로 사용될 수 있는 모든 String이 아닌 값의 집합입니다(<emu-xref href="#sec-object-type"></emu-xref> 참고).</p>
      <p>각 Symbol은 고유하며 변하지 않습니다.</p>
      <p>각 Symbol에는 불변의 [[Description]] 내부 슬롯이 있으며, 그 값은 String 또는 *undefined*입니다.</p>

      <emu-clause id="sec-well-known-symbols">
        <h1>잘 알려진 심볼들</h1>
        <p>잘 알려진 심볼은 이 명세서 알고리즘에서 명시적으로 참조되는 내장 Symbol 값입니다. 일반적으로 이 값들은 명세 알고리즘의 확장 지점 역할을 하는 프로퍼티의 키로 사용됩니다. 별도 명시가 없는 한, 잘 알려진 심볼 값은 모든 realm에서 공유됩니다(<emu-xref href="#sec-code-realms"></emu-xref> 참고).</p>
        <p>이 명세서에서는 잘 알려진 심볼을 <emu-xref href="#sec-well-known-intrinsic-objects">intrinsic 표기법</emu-xref>으로 표기하며, intrinsic은 <emu-xref href="#table-well-known-symbols"></emu-xref>에 나열된 값 중 하나입니다.</p>
        <emu-note>이전 명세 판에서는 @@name 형식의 표기를 사용하였으며, 현재 판에서는 `%Symbol.name%`을 사용합니다. 특히 다음 이름들이 사용되었습니다: @@asyncIterator, @@hasInstance, @@isConcatSpreadable, @@<emu-not-ref>iterator</emu-not-ref>, @@match, @@matchAll, @@replace, @@search, @@species, @@split, @@toPrimitive, @@toStringTag, @@unscopables.</emu-note>
        <emu-table id="table-well-known-symbols" caption="잘 알려진 심볼" oldids="table-1">
          <table>
            <thead>
              <tr>
                <th>
                  명세 이름
                </th>
                <th>
                  [[Description]]
                </th>
                <th>
                  값 및 용도
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                <dfn>%Symbol.asyncIterator%</dfn>
              </td>
              <td>
                *"Symbol.asyncIterator"*
              </td>
              <td>
                객체의 기본 비동기 이터레이터를 반환하는 메서드. `for`-`await`-`of` 구문의 의미론에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.hasInstance%</dfn>
              </td>
              <td>
                *"Symbol.hasInstance"*
              </td>
              <td>
                생성자 객체가 특정 객체를 자신의 인스턴스로 인식하는지 결정하는 메서드. `instanceof` 연산자 의미론에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.isConcatSpreadable%</dfn>
              </td>
              <td>
                *"Symbol.isConcatSpreadable"*
              </td>
              <td>
                값이 true면, 객체가 <emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref>에 의해 배열 요소로 평탄화되어야 함을 나타내는 Boolean 프로퍼티.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.iterator%</dfn>
              </td>
              <td>
                *"Symbol.iterator"*
              </td>
              <td>
                객체의 기본 이터레이터를 반환하는 메서드. for-of 구문의 의미론에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.match%</dfn>
              </td>
              <td>
                *"Symbol.match"*
              </td>
              <td>
                정규 표현식을 문자열과 매칭하는 정규식 메서드. <emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.matchAll%</dfn>
              </td>
              <td>
                *"Symbol.matchAll"*
              </td>
              <td>
                정규 표현식을 문자열과 매칭하여 이터레이터로 반환하는 정규식 메서드. <emu-xref href="#sec-string.prototype.matchall">`String.prototype.matchAll`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.replace%</dfn>
              </td>
              <td>
                *"Symbol.replace"*
              </td>
              <td>
                문자열의 매칭된 부분을 교체하는 정규식 메서드. <emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.search%</dfn>
              </td>
              <td>
                *"Symbol.search"*
              </td>
              <td>
                정규 표현식과 매칭되는 문자열 내의 인덱스를 반환하는 정규식 메서드. <emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.species%</dfn>
              </td>
              <td>
                *"Symbol.species"*
              </td>
              <td>
                파생 객체를 생성하는 데 사용되는 생성자 함수값 프로퍼티.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.split%</dfn>
              </td>
              <td>
                *"Symbol.split"*
              </td>
              <td>
                정규 표현식과 매칭되는 인덱스에서 문자열을 분할하는 정규식 메서드. <emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toPrimitive%</dfn>
              </td>
              <td>
                *"Symbol.toPrimitive"*
              </td>
              <td>
                객체를 해당 원시값으로 변환하는 메서드. ToPrimitive 추상 연산에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toStringTag%</dfn>
              </td>
              <td>
                *"Symbol.toStringTag"*
              </td>
              <td>
                객체의 기본 문자열 설명을 생성하는 데 사용되는 String 값 프로퍼티. <emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref> 내장 메서드에서 접근됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.unscopables%</dfn>
              </td>
              <td>
                *"Symbol.unscopables"*
              </td>
              <td>
                자신의 프로퍼티명과 상속된 프로퍼티명이 해당 객체의 `with` 환경 바인딩에서 제외되는 객체 값 프로퍼티.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-numeric-types">
      <h1>숫자 타입</h1>
      <p>ECMAScript에는 두 가지 내장 숫자 타입(Number와 BigInt)이 있습니다. 아래 추상 연산들은 이 숫자 타입에 대해 정의되어 있습니다. "결과(Result)" 열은 반환 타입과, 일부 연산 호출이 abrupt completion을 반환할 수 있는지 여부를 나타냅니다.</p>
      <emu-table id="table-numeric-type-ops" caption="숫자 타입 연산">
        <table>
          <thead>
            <tr>
              <th>
                연산
              </th>
              <th>
                예시 소스
              </th>
              <th>
                평가 의미론에서 호출되는 위치
              </th>
              <th>
                결과
              </th>
            </tr>
          </thead>

          <tr>
            <td>
              Number::unaryMinus
            </td>
            <td rowspan="2">
              `-x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unary-minus-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unaryMinus
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseNOT
            </td>
            <td rowspan="2">
              `~x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-bitwise-not-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseNOT
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::exponentiate
            </td>
            <td rowspan="2">
              `x&nbsp;**&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-exp-operator" title></emu-xref>
              및 <emu-xref href="#sec-math.pow" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::exponentiate
            </td>
            <td>
              정상 완료(BigInt) 또는 throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::multiply
            </td>
            <td rowspan="2">
              `x&nbsp;*&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::multiply
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::divide
            </td>
            <td rowspan="2">
              `x&nbsp;/&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::divide
            </td>
            <td>
              정상 완료(BigInt) 또는 throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::remainder
            </td>
            <td rowspan="2">
              `x&nbsp;%&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::remainder
            </td>
            <td>
              정상 완료(BigInt) 또는 throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::add
            </td>
            <td rowspan="2">
              `x ++`<br>
              `++ x`<br>
              `x&nbsp;+&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-addition-operator-plus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::add
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::subtract
            </td>
            <td rowspan="2">
              `x --`<br>
              `-- x`<br>
              `x&nbsp;-&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-subtraction-operator-minus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::subtract
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::leftShift
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&lt;&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-left-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::leftShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::signedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-signed-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::signedRightShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::unsignedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unsigned-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unsignedRightShift
            </td>
            <td>
              throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::lessThan
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&nbsp;y`<br>
              `x&nbsp;>&nbsp;y`<br>
              `x&nbsp;&lt;=&nbsp;y`<br>
              `x&nbsp;>=&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-relational-operators" title></emu-xref>,
              <emu-xref href="#sec-islessthan" title></emu-xref>
            </td>
            <td>
              Boolean 또는 *undefined* (비정렬 입력)
            </td>
          </tr>

          <tr>
            <td>
              BigInt::lessThan
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::equal
            </td>
            <td rowspan="2">
              `x&nbsp;==&nbsp;y`<br>
              `x&nbsp;!=&nbsp;y`<br>
              `x&nbsp;===&nbsp;y`<br>
              `x&nbsp;!==&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-equality-operators" title></emu-xref>,
              <emu-xref href="#sec-isstrictlyequal" title></emu-xref>
            </td>
            <td rowspan="2">
              Boolean
            </td>
          </tr>
          <tr>
            <td>
              BigInt::equal
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValue
            </td>
            <td>
              `Object.is(x, y)`
            </td>
            <td>
              객체 내부 메서드,
              <emu-xref href="#sec-samevalue" title></emu-xref>를 통해,
              정확한 값 동등성 검사
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValueZero
            </td>
            <td>
              `[x].includes(y)`
            </td>
            <td>
              <emu-xref href="#sec-samevaluezero" title></emu-xref>를 통해,
              값 동등성 검사, Array, Map, Set 메서드에서 *+0*<sub>𝔽</sub>과 *-0*<sub>𝔽</sub> 차이 무시
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseAND
            </td>
            <td rowspan="2">
              `x&nbsp;&amp;&nbsp;y`
            </td>
            <td rowspan="6">
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseAND
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseXOR
            </td>
            <td rowspan="2">
              `x&nbsp;^&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseXOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseOR
            </td>
            <td rowspan="2">
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::toString
            </td>
            <td rowspan="2">
              `String(x)`
            </td>
            <td rowspan="2">
              다양한 표현식 및 내장 함수, <emu-xref href="#sec-tostring" title></emu-xref>를 통해
            </td>
            <td rowspan="2">
              String
            </td>
          </tr>
          <tr>
            <td>
              BigInt::toString
            </td>
          </tr>
        </table>
      </emu-table>
      <p>숫자 타입들은 일반적으로 정밀도 손실이나 절단 없이 변환될 수 없으므로, ECMAScript 언어는 이러한 타입들 간의 암시적 변환을 제공하지 않습니다. 프로그래머는 다른 타입이 필요한 함수를 호출할 때 타입 간 변환을 위해 반드시 `Number`와 `BigInt` 함수를 명시적으로 호출해야 합니다.</p>
      <emu-note>
        <p>ECMAScript의 최초 및 이후 판들은 일부 연산자에 대해 정밀도 손실이나 절단이 발생할 수 있는 암시적 숫자 변환을 제공해왔습니다. 이러한 기존 암시적 변환은 하위 호환성을 위해 유지되지만, BigInt에는 제공되지 않아 프로그래머의 오류 가능성을 최소화하고, 미래 판에서 일반화된 <em>값 타입</em> 옵션을 열어두기 위함입니다.</p>
      </emu-note>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>Number 타입</h1>
        <p><dfn variants="is a Number,is not a Number">Number 타입</dfn>은 정확히 18,437,736,874,454,810,627개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>)의 값을 가지며, 이는 IEEE 이진 부동소수점 산술 표준(IEEE 754-2019)의 binary64의 배정밀도 부동소수점 값을 나타냅니다. 단, IEEE 표준의 9,007,199,254,740,990개(즉, <emu-eqn>2<sup>53</sup> - 2</emu-eqn>)의 NaN 값들은 ECMAScript에서 하나의 특별한 *NaN* 값으로 표현됩니다. (*NaN* 값은 프로그램 표현식 `NaN`에 의해 생성됩니다.) 일부 구현에서는 외부 코드가 다양한 NaN 값을 구분할 수 있지만, 그러한 동작은 구현 정의입니다. ECMAScript 코드에서는 모든 *NaN* 값이 서로 구분되지 않습니다.</p>
        <emu-note>
          <p>Number 값이 ArrayBuffer(<emu-xref href="#sec-arraybuffer-objects"></emu-xref>) 또는 SharedArrayBuffer(<emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>)에 저장된 후 관찰될 수 있는 비트 패턴은 ECMAScript 구현이 내부적으로 사용하는 Number 값의 표현과 반드시 같지는 않습니다.</p>
        </emu-note>
        <p>또 다른 두 개의 특별한 값, *양의 무한대*와 *음의 무한대*가 있습니다. 간결하게 하기 위해, 이 값들은 설명상 각각 *+∞*<sub>𝔽</sub> 및 *-∞*<sub>𝔽</sub> 기호로도 불립니다. (이 두 무한대 Number 값은 프로그램 표현식 `+Infinity`(또는 단순히 `Infinity`) 및 `-Infinity`에 의해 생성됩니다.)</p>
        <p>나머지 18,437,736,874,454,810,624개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup></emu-eqn>)의 값들은 <dfn id="finite">유한</dfn> 숫자라고 불립니다. 이 중 절반은 양수이고, 절반은 음수입니다. 모든 유한 양의 Number 값에는 같은 크기를 가진 음수 값이 대응됩니다.</p>
        <p>양의 0과 음의 0이 모두 존재함을 유의하세요. 설명상 이 값들은 각각 *+0*<sub>𝔽</sub> 및 *-0*<sub>𝔽</sub> 기호로도 불립니다. (이 두 다른 0 Number 값은 프로그램 표현식 `+0`(또는 단순히 `0`) 및 `-0`에 의해 생성됩니다.)</p>
        <p>18,437,736,874,454,810,622개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>)의 유한 0이 아닌 값들은 두 종류로 나뉩니다:</p>
        <p>18,428,729,675,200,069,632개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>54</sup></emu-eqn>)는 정규화된 형태로, 다음과 같습니다</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>여기서 _s_는 1 또는 -1, _m_은 2<sup>52</sup>(포함)에서 2<sup>53</sup>(제외) 사이의 정수, _e_는 -1074에서 971(포함) 사이의 정수입니다.</p>
        <p>나머지 9,007,199,254,740,990개(즉, <emu-eqn>2<sup>53</sup> - 2</emu-eqn>) 값은 비정규화된 형태로, 다음과 같습니다</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>여기서 _s_는 1 또는 -1, _m_은 0(제외)에서 2<sup>52</sup>(제외) 사이의 정수, _e_는 -1074입니다.</p>
        <p>크기가 2<sup>53</sup> 이하인 모든 양의 및 음의 정수가 Number 타입으로 표현 가능합니다. 정수 0은 Number 타입에서 *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub> 두 가지 표현을 가집니다.</p>
        <p>유한 숫자는 0이 아니며 위에 나타난 두 가지 방식 중 한 가지로 표현될 때 정수 _m_이 홀수이면 <em>홀수 시그니피컨드</em>를 가집니다. 그렇지 않으면 <em>짝수 시그니피컨드</em> 입니다.</p>
        <p>본 명세에서 “<dfn id="number-value-for" oldids="number-value">_x_의 Number 값</dfn>”이라는 구절은 _x_가 정확한 실수 수량(π와 같은 무리수일 수도 있음)을 나타내는 경우, 다음 방식으로 선택된 Number 값을 의미합니다. Number 타입의 모든 유한 값 집합을 고려하고, *-0*<sub>𝔽</sub>를 제거하며, Number 타입으로 표현할 수 없는 두 값을 추가합니다: 2<sup>1024</sup>(즉, <emu-eqn>+1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>) 및 <emu-eqn>-2<sup>1024</sup></emu-eqn>(즉, <emu-eqn>-1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>). 이 집합에서 _x_와 가장 가까운 값을 선택합니다. 두 값이 동일하게 가까우면 짝수 시그니피컨드를 가진 값을 선택합니다; 이때 두 추가 값 2<sup>1024</sup> 및 <emu-eqn>-2<sup>1024</sup></emu-eqn>은 짝수 시그니피컨드를 가진 것으로 간주합니다. 마지막으로, 선택된 값이 2<sup>1024</sup>이면 *+∞*<sub>𝔽</sub>로, <emu-eqn>-2<sup>1024</sup></emu-eqn>이면 *-∞*<sub>𝔽</sub>로, *+0*<sub>𝔽</sub>이면 _x_ &lt; 0일 때만 *-0*<sub>𝔽</sub>로 바꿉니다; 그 밖의 값은 그대로 사용합니다. 결과가 _x_의 Number 값입니다. (이 절차는 IEEE 754-2019의 roundTiesToEven 모드와 정확히 일치합니다.)</p>
        <p>+∞의 Number 값은 *+∞*<sub>𝔽</sub>, -∞의 Number 값은 *-∞*<sub>𝔽</sub>입니다.</p>
        <p>일부 ECMAScript 연산자는 <emu-eqn>-2<sup>31</sup></emu-eqn>에서 <emu-eqn>2<sup>31</sup> - 1</emu-eqn>까지와 같이 특정 범위의 정수만 처리합니다. 이러한 연산자는 Number 타입의 임의 값을 받아들이지만, 먼저 해당 값을 예상 범위의 정수 값으로 변환합니다. 숫자 변환 연산에 대한 설명은 <emu-xref href="#sec-type-conversion"></emu-xref>에서 확인하세요.</p>

        <emu-clause id="sec-numeric-types-number-unaryMinus" type="numeric method">
          <h1>
            Number::unaryMinus (
              _x_: a Number,
            ): a Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면, *NaN*을 반환한다.
            1. _x_의 부호를 반전시킨 Number를 반환한다. 즉, 같은 크기이지만 부호가 반대인 Number를 계산한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseNOT" type="numeric method">
          <h1>
            Number::bitwiseNOT (
              _x_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _oldValue_를 ! ToInt32(_x_)로 한다.
            1. _oldValue_의 비트 보수를 반환한다. 결과의 수학적 값은 32비트 2의 보수 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-exponentiate" type="numeric method" oldids="sec-applying-the-exp-operator">
          <h1>
            Number::exponentiate (
              _base_: a Number,
              _exponent_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_base_에 _exponent_ 제곱을 한 결과를 구현에 따라 근사한 값을 반환한다.</dd>
          </dl>
          <emu-alg>
            1. _exponent_가 *NaN*이면, *NaN*을 반환한다.
            1. _exponent_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면, *1*<sub>𝔽</sub>을 반환한다.
            1. _base_가 *NaN*이면, *NaN*을 반환한다.
            1. _base_가 *+∞*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면 *+∞*<sub>𝔽</sub> 반환; 그렇지 않으면 *+0*<sub>𝔽</sub> 반환.
            1. _base_가 *-∞*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면,
                1. _exponent_가 홀수 정수 Number이면 *-∞*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
              1. 그렇지 않으면,
                1. _exponent_가 홀수 정수 Number이면 *-0*<sub>𝔽</sub> 반환; 아니면 *+0*<sub>𝔽</sub> 반환.
            1. _base_가 *+0*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
            1. _base_가 *-0*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면,
                1. _exponent_가 홀수 정수 Number이면 *-0*<sub>𝔽</sub> 반환; 아니면 *+0*<sub>𝔽</sub> 반환.
              1. 그렇지 않으면,
                1. _exponent_가 홀수 정수 Number이면 *-∞*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
            1. 단언: _base_는 유한하며 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>가 아니다.
            1. _exponent_가 *+∞*<sub>𝔽</sub>이면,
              1. abs(ℝ(_base_)) > 1이면 *+∞*<sub>𝔽</sub> 반환.
              1. abs(ℝ(_base_)) = 1이면 *NaN* 반환.
              1. abs(ℝ(_base_)) &lt; 1이면 *+0*<sub>𝔽</sub> 반환.
            1. _exponent_가 *-∞*<sub>𝔽</sub>이면,
              1. abs(ℝ(_base_)) > 1이면 *+0*<sub>𝔽</sub> 반환.
              1. abs(ℝ(_base_)) = 1이면 *NaN* 반환.
              1. abs(ℝ(_base_)) &lt; 1이면 *+∞*<sub>𝔽</sub> 반환.
            1. 단언: _exponent_는 유한하며 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>가 아니다.
            1. _base_ &lt; *-0*<sub>𝔽</sub>이고 _exponent_가 정수 Number가 아니면 *NaN* 반환.
            1. ℝ(_base_)의 ℝ(_exponent_) 제곱을 구현에 따라 근사한 Number 값으로 반환.
          </emu-alg>
          <emu-note>
            <p>_base_가 *1*<sub>𝔽</sub> 또는 *-1*<sub>𝔽</sub>이고 _exponent_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>일 때, 혹은 _base_가 *1*<sub>𝔽</sub>이고 _exponent_가 *NaN*일 때, _base_ `**` _exponent_의 결과는 IEEE 754-2019와 다릅니다. ECMAScript 1판은 이 연산에 대해 *NaN* 결과를 명시했으나, 이후 IEEE 754 개정판은 *1*<sub>𝔽</sub>을 명시했습니다. 호환성을 위해 기존 ECMAScript 동작을 유지합니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-multiply" type="numeric method" oldids="sec-applying-the-mul-operator">
          <h1>
            Number::multiply (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>IEEE 754-2019 배정밀도 이진 산술 규칙에 따라 곱셈을 수행하며, _x_와 _y_의 곱을 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ 또는 _y_가 *NaN*이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면,
              1. _y_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _y_ > *+0*<sub>𝔽</sub>이면 _x_ 반환.
              1. -_x_ 반환.
            1. _y_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면,
              1. _x_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _x_ > *+0*<sub>𝔽</sub>이면 _y_ 반환.
              1. -_y_ 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이면,
              1. _y_가 *-0*<sub>𝔽</sub> 또는 _y_ &lt; *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환.
              1. 아니면 *-0*<sub>𝔽</sub> 반환.
            1. _y_가 *-0*<sub>𝔽</sub>이면,
              1. _x_ &lt; *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환.
              1. 아니면 *-0*<sub>𝔽</sub> 반환.
            1. 𝔽(ℝ(_x_) × ℝ(_y_)) 반환.
          </emu-alg>
          <emu-note>
            <p>유한 정밀 곱셈은 교환법칙은 성립하지만 항상 결합법칙이 성립하지는 않습니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-divide" type="numeric method" oldids="sec-applying-the-div-operator">
          <h1>
            Number::divide (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>IEEE 754-2019 배정밀도 이진 산술 규칙에 따라 나눗셈을 수행하며, _x_는 피제수, _y_는 제수로써 몫을 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ 또는 _y_가 *NaN*이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면,
              1. _y_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _y_가 *+0*<sub>𝔽</sub> 또는 _y_ > *+0*<sub>𝔽</sub>이면 _x_ 반환.
              1. -_x_ 반환.
            1. _y_가 *+∞*<sub>𝔽</sub>이면,
              1. _x_가 *+0*<sub>𝔽</sub> 또는 _x_ > *+0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환; 아니면 *-0*<sub>𝔽</sub> 반환.
            1. _y_가 *-∞*<sub>𝔽</sub>이면,
              1. _x_가 *+0*<sub>𝔽</sub> 또는 _x_ > *+0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub> 반환; 아니면 *+0*<sub>𝔽</sub> 반환.
            1. _x_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면,
              1. _y_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _y_ > *+0*<sub>𝔽</sub>이면 _x_ 반환.
              1. -_x_ 반환.
            1. _y_가 *+0*<sub>𝔽</sub>이면,
              1. _x_ > *+0*<sub>𝔽</sub>이면 *+∞*<sub>𝔽</sub> 반환; 아니면 *-∞*<sub>𝔽</sub> 반환.
            1. _y_가 *-0*<sub>𝔽</sub>이면,
              1. _x_ > *+0*<sub>𝔽</sub>이면 *-∞*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
            1. 𝔽(ℝ(_x_) / ℝ(_y_)) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-remainder" type="numeric method" oldids="sec-applying-the-mod-operator">
          <h1>
            Number::remainder (
              _n_: a Number,
              _d_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>피제수 _n_과 제수 _d_의 암시적 나눗셈에서 나머지를 반환합니다.</dd>
          </dl>
          <emu-alg>
            1. _n_ 또는 _d_가 *NaN*이면 *NaN* 반환.
            1. _n_이 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _d_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 _n_ 반환.
            1. _d_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _n_이 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 _n_ 반환.
            1. 단언: _n_과 _d_는 유한하며 0이 아니다.
            1. _quotient_를 ℝ(_n_) / ℝ(_d_)로 한다.
            1. _q_를 truncate(_quotient_)로 한다.
            1. _r_를 ℝ(_n_) - (ℝ(_d_) × _q_)로 한다.
            1. _r_ = 0이고 _n_ &lt; *-0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub> 반환.
            1. 𝔽(_r_) 반환.
          </emu-alg>
          <emu-note>
            <p>C 및 C++에서 나머지 연산자는 정수 피연산자만 허용하지만, ECMAScript에서는 부동소수점 피연산자도 허용합니다.</p>
          </emu-note>
          <emu-note>부동소수점 나머지 연산의 결과는 IEEE 754-2019의 “remainder” 연산과 다릅니다. IEEE 754-2019 “remainder” 연산은 반올림 나눗셈에서 나머지를 계산하며, 일반적인 <emu-not-ref>정수</emu-not-ref> 나머지 연산자와는 유사하지 않습니다. ECMAScript는 부동소수점 연산에서 `%`가 Java의 <emu-not-ref>정수</emu-not-ref> 나머지 연산자와 유사하게 동작하도록 정의합니다; 이는 C 라이브러리 함수 fmod와 비교할 수 있습니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-add" type="numeric method" oldids="sec-applying-the-additive-operators-to-numbers">
          <h1>
            Number::add (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>IEEE 754-2019 배정밀도 이진 산술 규칙에 따라 덧셈을 수행하며, 두 인자의 합을 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ 또는 _y_가 *NaN*이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub>이고 _y_가 *-∞*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _x_가 *-∞*<sub>𝔽</sub>이고 _y_가 *+∞*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 _x_ 반환.
            1. _y_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 _y_ 반환.
            1. 단언: _x_와 _y_는 모두 유한하다.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub> 반환.
            1. 𝔽(ℝ(_x_) + ℝ(_y_)) 반환.
          </emu-alg>
          <emu-note>
            <p>유한 정밀 덧셈은 교환법칙은 성립하지만 항상 결합법칙이 성립하지는 않습니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-subtract" type="numeric method">
          <h1>
            Number::subtract (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>뺄셈을 수행하며, _x_는 피감수, _y_는 감수로써 차를 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. Number::add(_x_, Number::unaryMinus(_y_))를 반환한다.
          </emu-alg>
          <emu-note>
            <p>항상 `x - y`의 결과는 `x + (-y)`의 결과와 같습니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-leftShift" type="numeric method">
          <h1>
            Number::leftShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToInt32(_x_)로 한다.
            1. _rNum_을 ! ToUint32(_y_)로 한다.
            1. _shiftCount_를 ℝ(_rNum_) mod 32로 한다.
            1. _lNum_을 _shiftCount_ 비트만큼 왼쪽으로 시프트한 결과를 반환한다. 결과의 수학적 값은 32비트 2의 보수 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-signedRightShift" type="numeric method">
          <h1>
            Number::signedRightShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToInt32(_x_)로 한다.
            1. _rNum_을 ! ToUint32(_y_)로 한다.
            1. _shiftCount_를 ℝ(_rNum_) mod 32로 한다.
            1. _lNum_을 _shiftCount_ 비트만큼 부호 확장 우측 시프트한 결과를 반환한다. 최상위 비트가 전파된다. 결과의 수학적 값은 32비트 2의 보수 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-unsignedRightShift" type="numeric method">
          <h1>
            Number::unsignedRightShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToUint32(_x_)로 한다.
            1. _rNum_을 ! ToUint32(_y_)로 한다.
            1. _shiftCount_를 ℝ(_rNum_) mod 32로 한다.
            1. _lNum_을 _shiftCount_ 비트만큼 0으로 채우며 우측 시프트한 결과를 반환한다. 비워진 비트는 0으로 채워진다. 결과의 수학적 값은 32비트 부호 없는 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-lessThan" type="numeric method">
          <h1>
            Number::lessThan (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean or *undefined*
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면 *undefined* 반환.
            1. _y_가 *NaN*이면 *undefined* 반환.
            1. _x_가 _y_와 같으면 *false* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub>이면 *false* 반환.
            1. _y_가 *+∞*<sub>𝔽</sub>이면 *true* 반환.
            1. _y_가 *-∞*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *-∞*<sub>𝔽</sub>이면 *true* 반환.
            1. 단언: _x_와 _y_는 유한하다.
            1. ℝ(_x_) &lt; ℝ(_y_)이면 *true* 반환; 아니면 *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-equal" type="numeric method">
          <h1>
            Number::equal (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면 *false* 반환.
            1. _y_가 *NaN*이면 *false* 반환.
            1. _x_가 _y_와 같으면 *true* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *true* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValue" type="numeric method">
          <h1>
            Number::sameValue (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_와 _y_가 모두 *NaN*이면 *true* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 _y_와 같으면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValueZero" type="numeric method">
          <h1>
            Number::sameValueZero (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_와 _y_가 모두 *NaN*이면 *true* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *true* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *true* 반환.
            1. _x_가 _y_와 같으면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numberbitwiseop" type="abstract operation">
          <h1>
            NumberBitwiseOp (
              _op_: `&amp;`, `^`, 또는 `|`,
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToInt32(_x_)로 한다.
            1. _rNum_을 ! ToInt32(_y_)로 한다.
            1. _lBits_를 ℝ(_lNum_)을 표현하는 32비트 2의 보수 비트 문자열로 한다.
            1. _rBits_를 ℝ(_rNum_)을 표현하는 32비트 2의 보수 비트 문자열로 한다.
            1. _op_이 `&amp;`이면,
              1. _result_를 _lBits_와 _rBits_에 대해 비트 AND 연산한 결과로 한다.
            1. 아니고 _op_이 `^`이면,
              1. _result_를 _lBits_와 _rBits_에 대해 비트 XOR 연산한 결과로 한다.
            1. 그렇지 않으면,
              1. 단언: _op_은 `|`이다.
              1. _result_를 _lBits_와 _rBits_에 대해 비트 OR 연산한 결과로 한다.
            1. _result_가 표현하는 32비트 2의 보수 비트 문자열의 정수에 대한 Number 값을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseAND" type="numeric method">
          <h1>
            Number::bitwiseAND (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`&amp;`, _x_, _y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseXOR" type="numeric method">
          <h1>
            Number::bitwiseXOR (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`^`, _x_, _y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseOR" type="numeric method">
          <h1>
            Number::bitwiseOR (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`|`, _x_, _y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-tostring" type="numeric method" oldids="sec-tostring-applied-to-the-number-type">
          <h1>
            Number::toString (
              _x_: a Number,
              _radix_: an integer in the inclusive interval from 2 to 36,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_를 진법 _radix_를 사용한 위치 기수 체계로 문자열로 표현합니다. 진법 _r_을 사용할 때 사용되는 숫자들은 *"0123456789abcdefghijklmnopqrstuvwxyz"*의 앞에서 _r_개 코드 유닛을 차례로 사용합니다. 크기가 *1*<sub>𝔽</sub> 이상인 숫자의 표현에는 결코 앞에 0이 포함되지 않습니다.</dd>
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면 *"NaN"* 반환.
            1. _x_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *"0"* 반환.
            1. _x_ &lt; *-0*<sub>𝔽</sub>이면 *"-"*와 Number::toString(-_x_, _radix_)를 연결한 문자열 반환.
            1. _x_가 *+∞*<sub>𝔽</sub>이면 *"Infinity"* 반환.
            1. [id="step-number-tostring-intermediate-values"] _n_, _k_, _s_를 다음 조건을 만족하는 정수로 한다: _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>)가 _x_이고, _k_가 가능한 한 작다. _k_는 _s_의 _radix_ 표현에서 자릿수이고, _s_는 _radix_로 나누어떨어지지 않으며, 최소 자리수가 반드시 결정되는 것은 아니다.
            1. _radix_ ≠ 10이거나 _n_이 -5에서 21 사이이면,
              1. _n_ ≥ _k_이면,
                1. 다음을 연결한 문자열 반환:
                  * _s_의 _radix_ 표현에서 _k_개의 자릿수
                  * _n_ - _k_번 반복된 코드 유닛 0x0030(DIGIT ZERO)
              1. _n_ > 0이면,
                1. 다음을 연결한 문자열 반환:
                  * _s_의 _radix_ 표현에서 가장 높은 _n_개의 자릿수
                  * 코드 유닛 0x002E(FULL STOP)
                  * 남은 _k_ - _n_개의 자릿수
              1. 그렇지 않으면,
                1. 단언: _n_ ≤ 0이다.
                1. 다음을 연결한 문자열 반환:
                  * 코드 유닛 0x0030(DIGIT ZERO)
                  * 코드 유닛 0x002E(FULL STOP)
                  * -_n_번 반복된 코드 유닛 0x0030(DIGIT ZERO)
                  * _s_의 _radix_ 표현에서 _k_개의 자릿수
            1. 참고: 이 경우 입력은 과학적 E 표기법으로 표현됩니다(예: `1.2e+3`).
            1. 단언: _radix_는 10이다.
            1. _n_ &lt; 0이면,
              1. _exponentSign_을 코드 유닛 0x002D(HYPHEN-MINUS)로 한다.
            1. 그렇지 않으면,
              1. _exponentSign_을 코드 유닛 0x002B(PLUS SIGN)로 한다.
            1. _k_ = 1이면,
              1. 다음을 연결한 문자열 반환:
                * _s_의 한 자릿수 코드 유닛
                * 코드 유닛 0x0065(LATIN SMALL LETTER E)
                * _exponentSign_
                * abs(_n_ - 1)의 10진수 표현 코드 유닛
            1. 다음을 연결한 문자열 반환:
              * _s_의 10진수 표현에서 가장 높은 자릿수 코드 유닛
              * 코드 유닛 0x002E(FULL STOP)
              * 남은 _k_ - 1개의 10진수 표현 코드 유닛
              * 코드 유닛 0x0065(LATIN SMALL LETTER E)
              * _exponentSign_
              * abs(_n_ - 1)의 10진수 표현 코드 유닛
          </emu-alg>
          <emu-note>
            <p>다음 관찰은 구현 지침으로 유용할 수 있으나, 본 표준의 규범적 요구 사항은 아닙니다:</p>
            <ul>
              <li>
                x가 *-0*<sub>𝔽</sub>을 제외한 모든 Number 값이면 ToNumber(ToString(x))는 x이다.
              </li>
              <li>
                s의 최소 자리수는 항상 명시된 요구 조건에 따라 고유하게 결정되는 것은 아니다(위 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 참조).
              </li>
            </ul>
          </emu-note>
          <emu-note>
            <p>더 정확한 변환을 제공하는 구현의 경우, 아래 대안 버전의 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 단계를 구현 지침으로 사용하는 것을 권장합니다:</p>
            <emu-alg replaces-step="step-number-tostring-intermediate-values">
              1. _n_, _k_, _s_를 다음 조건을 만족하는 정수로 한다: _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>)가 _x_이고, _k_가 가능한 한 작다. 여러 가능성이 있으면, ℝ(_x_)에 근접한 값을 가지는 _s_를 선택한다. 두 가지 가능성이 있으면 짝수 값을 선택한다. _k_는 _s_의 _radix_ 표현에서 자릿수이며, _s_는 _radix_로 나누어떨어지지 않는다.
            </emu-alg>
          </emu-note>
          <emu-note>
            <p>ECMAScript 구현자는 David M. Gay가 작성한 부동소수점 숫자의 이진-10진 변환 관련 논문과 코드를 참고할 수 있습니다:</p>
            <p>
              Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). 1990년 11월 30일.<br>
              <a href="https://ampl.com/_archive/first-website/REFS/rounding.pdf">https://ampl.com/_archive/first-website/REFS/rounding.pdf</a>. 관련 코드:<br>
              <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> 및<br>
              <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a> 그리고 여러 `netlib` 미러 사이트에서 확인 가능.
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>BigInt 타입</h1>
        <p><dfn variants="is a BigInt,is not a BigInt">BigInt 타입</dfn>은 정수 값을 나타냅니다. 값의 크기는 제한이 없으며 특정 비트 폭에 제한되지 않습니다. 별도 언급이 없는 한, 연산들은 일반적으로 정확한 수학적 결과를 반환하도록 설계되었습니다. 이항 연산에서 BigInt는 2의 보수 이진 문자열처럼 동작하며, 음수는 비트가 왼쪽으로 무한히 설정된 것으로 취급됩니다.</p>

        <emu-clause id="sec-numeric-types-bigint-unaryMinus" type="numeric method">
          <h1>
            BigInt::unaryMinus (
              _x_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = *0*<sub>ℤ</sub>이면, *0*<sub>ℤ</sub>를 반환한다.
            1. -_x_를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseNOT" type="numeric method">
          <h1>
            BigInt::bitwiseNOT (
              _x_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_의 1의 보수를 반환합니다.</dd>
          </dl>
          <emu-alg>
            1. -_x_ - *1*<sub>ℤ</sub>를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-exponentiate" type="numeric method">
          <h1>
            BigInt::exponentiate (
              _base_: a BigInt,
              _exponent_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _exponent_ &lt; *0*<sub>ℤ</sub>이면, *RangeError* 예외를 throw한다.
            1. _base_ = *0*<sub>ℤ</sub>이고 _exponent_ = *0*<sub>ℤ</sub>이면, *1*<sub>ℤ</sub>를 반환한다.
            1. _base_의 _exponent_ 제곱을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-multiply" type="numeric method">
          <h1>
            BigInt::multiply (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ × _y_를 반환한다.
          </emu-alg>
          <emu-note>결과가 입력보다 훨씬 큰 비트 폭을 갖더라도, 정확한 수학적 결과가 반환됩니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-divide" type="numeric method">
          <h1>
            BigInt::divide (
              _x_: a BigInt,
              _y_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _y_ = *0*<sub>ℤ</sub>이면, *RangeError* 예외를 throw한다.
            1. _quotient_를 ℝ(_x_) / ℝ(_y_)로 한다.
            1. ℤ(truncate(_quotient_))를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-remainder" type="numeric method">
          <h1>
            BigInt::remainder (
              _n_: a BigInt,
              _d_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _d_ = *0*<sub>ℤ</sub>이면, *RangeError* 예외를 throw한다.
            1. _n_ = *0*<sub>ℤ</sub>이면, *0*<sub>ℤ</sub>를 반환한다.
            1. _quotient_를 ℝ(_n_) / ℝ(_d_)로 한다.
            1. _q_를 ℤ(truncate(_quotient_))로 한다.
            1. _n_ - (_d_ × _q_)를 반환한다.
          </emu-alg>
          <emu-note>결과의 부호는 피제수의 부호와 같습니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-add" type="numeric method">
          <h1>
            BigInt::add (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ + _y_를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-subtract" type="numeric method">
          <h1>
            BigInt::subtract (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ - _y_를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-leftShift" type="numeric method">
          <h1>
            BigInt::leftShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _y_ &lt; *0*<sub>ℤ</sub>이면,
              1. ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>))를 반환한다.
            1. _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>를 반환한다.
          </emu-alg>
          <emu-note>이 의미는 BigInt를 무한 길이 2의 보수 이진 숫자열로 취급하여 비트 시프트와 동등해야 합니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-signedRightShift" type="numeric method">
          <h1>
            BigInt::signedRightShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigInt::leftShift(_x_, -_y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-unsignedRightShift" type="numeric method">
          <h1>
            BigInt::unsignedRightShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. *TypeError* 예외를 throw한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-lessThan" type="numeric method">
          <h1>
            BigInt::lessThan (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ℝ(_x_) &lt; ℝ(_y_)이면 *true* 반환; 아니면 *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-equal" type="numeric method" oldids="sec-numeric-types-bigint-sameValue,sec-numeric-types-bigint-sameValueZero">
          <h1>
            BigInt::equal (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ℝ(_x_) = ℝ(_y_)이면 *true* 반환; 아니면 *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryand" type="abstract operation">
          <h1>
            BinaryAnd (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1이고 _y_ = 1이면 1을 반환한다.
            1. 아니면 0을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryor" type="abstract operation">
          <h1>
            BinaryOr (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1이거나 _y_ = 1이면 1을 반환한다.
            1. 아니면 0을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryxor" type="abstract operation">
          <h1>
            BinaryXor (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1이고 _y_ = 0이면 1을 반환한다.
            1. 아니면 _x_ = 0이고 _y_ = 1이면 1을 반환한다.
            1. 아니면 0을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-bigintbitwiseop" type="abstract operation">
          <h1>
            BigIntBitwiseOp (
              _op_: `&amp;`, `^`, or `|`,
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_를 ℝ(_x_)로 설정한다.
            1. _y_를 ℝ(_y_)로 설정한다.
            1. _result_를 0으로 설정한다.
            1. _shift_를 0으로 설정한다.
            1. (_x_ = 0 또는 _x_ = -1)이고 (_y_ = 0 또는 _y_ = -1)일 때까지 반복한다.
              1. _xDigit_를 _x_ mod 2로 한다.
              1. _yDigit_를 _y_ mod 2로 한다.
              1. _op_이 `&amp;`이면,
                1. _result_를 _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_)로 설정한다.
              1. 아니고 _op_이 `|`이면,
                1. _result_를 _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_)로 설정한다.
              1. 그렇지 않으면,
                1. 단언: _op_은 `^`이다.
                1. _result_를 _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_)로 설정한다.
              1. _shift_를 _shift_ + 1로 설정한다.
              1. _x_를 (_x_ - _xDigit_) / 2로 설정한다.
              1. _y_를 (_y_ - _yDigit_) / 2로 설정한다.
            1. _op_이 `&amp;`이면,
              1. _tmp_를 BinaryAnd(_x_ mod 2, _y_ mod 2)로 한다.
            1. 아니고 _op_이 `|`이면,
              1. _tmp_를 BinaryOr(_x_ mod 2, _y_ mod 2)로 한다.
            1. 그렇지 않으면,
              1. 단언: _op_은 `^`이다.
              1. _tmp_를 BinaryXor(_x_ mod 2, _y_ mod 2)로 한다.
            1. _tmp_ ≠ 0이면,
              1. _result_를 _result_ - 2<sup>_shift_</sup>로 설정한다.
              1. 참고: 이는 부호 확장입니다.
            1. _result_에 대한 BigInt 값을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseAND" type="numeric method">
          <h1>
            BigInt::bitwiseAND (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`&amp;`, _x_, _y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseXOR" type="numeric method">
          <h1>
            BigInt::bitwiseXOR (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`^`, _x_, _y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseOR" type="numeric method">
          <h1>
            BigInt::bitwiseOR (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`|`, _x_, _y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-tostring" type="numeric method">
          <h1>
            BigInt::toString (
              _x_: a BigInt,
              _radix_: an integer in the inclusive interval from 2 to 36,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_를 진법 _radix_를 사용한 위치 기수 체계로 문자열로 표현합니다. 진법 _r_을 사용할 때 사용되는 숫자들은 *"0123456789abcdefghijklmnopqrstuvwxyz"*의 앞에서 _r_개 코드 유닛을 차례로 사용합니다. *0*<sub>ℤ</sub>을 제외한 BigInt의 표현에는 결코 앞에 0이 포함되지 않습니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ &lt; *0*<sub>ℤ</sub>이면 *"-"*와 BigInt::toString(-_x_, _radix_)를 연결한 문자열을 반환한다.
            1. _x_를 _radix_로 표현한 문자열 값을 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-type">
      <h1>Object 타입</h1>
      <p><dfn variants="is an Object,is not an Object">Object 타입</dfn>의 각 인스턴스(간단히 “객체”라고도 함)는 프로퍼티들의 집합을 나타냅니다. 각 프로퍼티는 데이터 프로퍼티 또는 접근자 프로퍼티입니다:</p>
      <ul>
        <li>
          <dfn variants="data properties">데이터 프로퍼티</dfn>는 키 값과 ECMAScript 언어 값, 그리고 불리언 속성 집합을 연관시킵니다.
        </li>
        <li>
          <dfn variants="accessor properties">접근자 프로퍼티</dfn>는 키 값과 하나 또는 두 개의 접근자 함수, 그리고 불리언 속성 집합을 연관시킵니다. 접근자 함수는 해당 프로퍼티에 연관된 ECMAScript 언어 값을 저장하거나 가져오는 데 사용됩니다.
        </li>
      </ul>
      <p>객체의 프로퍼티는 프로퍼티 키를 사용하여 고유하게 식별됩니다. <dfn id="property-key" variants="property keys" oldids="sec-ispropertykey">프로퍼티 키</dfn>는 문자열 또는 심볼입니다. 모든 문자열과 심볼(빈 문자열 포함)은 프로퍼티 키로 유효합니다. <dfn id="property-name" variants="property names">프로퍼티 이름</dfn>은 문자열인 프로퍼티 키입니다.</p>
      <p><dfn id="integer-index" variants="integer indices,integer-indexed">정수 인덱스</dfn>는 CanonicalNumericIndexString(_n_)이 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>53</sup> - 1)까지(포함)의 정수 Number를 반환하는 프로퍼티 이름 _n_입니다. <dfn id="array-index" variants="array indices">배열 인덱스</dfn>는 CanonicalNumericIndexString(_n_)이 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>32</sup> - 2)까지(포함)의 정수 Number를 반환하는 정수 인덱스 _n_입니다.</p>
      <emu-note>
        <p>모든 음수가 아닌 안전한 정수는 해당하는 정수 인덱스를 가집니다. 32비트 부호 없는 정수 중 <emu-eqn>2<sup>32</sup> - 1</emu-eqn>을 제외한 모든 값은 해당하는 배열 인덱스를 가집니다. *"-0"*은 정수 인덱스도 배열 인덱스도 아닙니다.</p>
      </emu-note>
      <p>프로퍼티 키는 프로퍼티와 그 값을 접근하는 데 사용됩니다. 프로퍼티 접근 방식에는 값을 가져오는 <em>get</em>과 값을 할당하는 <em>set</em> 두 가지가 있습니다. get과 set 접근으로 접근 가능한 프로퍼티에는 객체의 직접적인 일부인 <em>자체 프로퍼티</em>와 프로퍼티 상속 관계를 통해 다른 연관 객체로부터 제공받는 <em>상속 프로퍼티</em>가 포함됩니다. 상속 프로퍼티는 연관 객체의 자체 프로퍼티 또는 상속 프로퍼티일 수 있습니다. 각 객체의 자체 프로퍼티는 해당 객체의 다른 자체 프로퍼티의 키 값과 구별되는 키 값을 가져야 합니다.</p>
      <p>모든 객체는 논리적으로 프로퍼티의 집합이지만, 프로퍼티 접근과 조작의 의미론이 다른 여러 형태의 객체가 존재합니다. 여러 형태의 객체 정의는 <emu-xref href="#sec-object-internal-methods-and-internal-slots"></emu-xref>를 참고하세요.</p>
      <p>또한 일부 객체는 호출 가능하며, 이러한 객체를 함수 또는 함수 객체라고 하며 아래에서 추가로 설명합니다. ECMAScript의 모든 함수는 Object 타입의 멤버입니다.</p>

      <emu-clause id="sec-property-attributes">
        <h1>프로퍼티 속성</h1>
        <p>속성은 <emu-xref href="#table-object-property-attributes"></emu-xref>에 설명된 Object 프로퍼티의 상태를 정의하고 설명하는 데 사용됩니다. 명시적으로 지정되지 않는 한, 각 속성의 초기값은 기본값입니다.</p>
        <emu-table id="table-object-property-attributes" caption="Object 프로퍼티의 속성" oldids="table-2,table-3,table-4,table-data-property-attributes,table-accessor-property-attributes,table-default-attribute-values">
          <table>
            <thead>
              <tr>
                <th>속성 이름</th>
                <th>해당되는 프로퍼티 종류</th>
                <th>값 도메인</th>
                <th>기본값</th>
                <th>설명</th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                데이터 프로퍼티
              </td>
              <td>
                ECMAScript 언어 값
              </td>
              <td>
                *undefined*
              </td>
              <td>
                get 접근으로 프로퍼티에서 가져오는 값입니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                데이터 프로퍼티
              </td>
              <td>
                불리언
              </td>
              <td>
                *false*
              </td>
              <td>
                *false*인 경우, ECMAScript 코드가 [[Set]]을 사용하여 [[Value]] 속성을 변경하려고 해도 성공하지 않습니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                접근자 프로퍼티
              </td>
              <td>
                Object 또는 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                값이 Object인 경우, 반드시 함수 객체여야 합니다. get 접근 시마다 해당 함수의 [[Call]] 내부 메소드(<emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>)가 빈 인자 리스트로 호출되어 프로퍼티 값을 가져옵니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                접근자 프로퍼티
              </td>
              <td>
                Object 또는 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                값이 Object인 경우, 반드시 함수 객체여야 합니다. set 접근 시마다 해당 함수의 [[Call]] 내부 메소드(<emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>)가 할당 값을 유일한 인자로 포함하는 인자 리스트로 호출됩니다. 프로퍼티의 [[Set]] 내부 메소드 효과는, 반드시 그런 것은 아니지만, 이후 [[Get]] 내부 메소드 호출에서 반환되는 값에 영향을 줄 수 있습니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                데이터 프로퍼티 또는 접근자 프로퍼티
              </td>
              <td>
                불리언
              </td>
              <td>
                *false*
              </td>
              <td>
                *true*인 경우, for-in 열거(see <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>)에 의해 프로퍼티가 열거됩니다. 그렇지 않으면 비열거 프로퍼티라고 합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                데이터 프로퍼티 또는 접근자 프로퍼티
              </td>
              <td>
                불리언
              </td>
              <td>
                *false*
              </td>
              <td>
                *false*인 경우, 프로퍼티 삭제, 데이터 프로퍼티에서 접근자 프로퍼티로의 변경 또는 그 반대, 속성 변경(기존 [[Value]] 교체 또는 [[Writable]]을 *false*로 설정하는 경우 제외)은 모두 실패합니다.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>Object 내부 메소드와 내부 슬롯</h1>
        <p>ECMAScript에서 객체의 실제 의미론은 <em>내부 메소드</em>라 불리는 알고리즘을 통해 지정됩니다. ECMAScript 엔진의 각 객체는 런타임 행동을 정의하는 내부 메소드 집합과 연결되어 있습니다. 이러한 내부 메소드는 ECMAScript 언어의 일부가 아닙니다. 이 명세에서는 순전히 설명 목적으로 정의됩니다. 하지만 ECMAScript 구현 내의 각 객체는 해당 객체에 연결된 내부 메소드로 지정된 대로 동작해야 합니다. 이를 구현하는 정확한 방법은 구현에 따라 결정됩니다.</p>
        <p>내부 메소드 이름은 다형적입니다. 즉, 서로 다른 객체 값이 동일한 내부 메소드 이름이 호출될 때 서로 다른 알고리즘을 실행할 수 있습니다. 내부 메소드가 호출되는 실제 객체는 호출의 “대상”입니다. 런타임에 알고리즘 구현이 객체가 지원하지 않는 내부 메소드를 사용하려 하면 *TypeError* 예외가 발생합니다.</p>
        <p>내부 슬롯은 객체, 심볼, 또는 Private Name에 연결된 내부 상태로, 여러 ECMAScript 명세 알고리즘에서 사용됩니다. 내부 슬롯은 객체 프로퍼티가 아니며 상속되지 않습니다. 내부 슬롯 명세에 따라 해당 상태는 ECMAScript 언어의 모든 타입 값이나 특정 ECMAScript 명세 타입 값일 수 있습니다. 명시적으로 달리 지정되지 않는 한, 내부 슬롯은 객체, 심볼, 또는 Private Name 생성 과정에서 할당되며 동적으로 추가할 수 없습니다. 별도 지정이 없는 한, 내부 슬롯의 초기값은 *undefined*입니다. 이 명세의 여러 알고리즘은 내부 슬롯을 가진 값을 생성합니다. 하지만 ECMAScript 언어는 내부 슬롯을 직접 조작할 방법을 제공하지 않습니다.</p>
        <p>모든 객체는 [[PrivateElements]]라는 내부 슬롯을 가지며, 이는 PrivateElements의 리스트입니다. 이 리스트는 객체의 private 필드, 메소드, 접근자의 값을 나타냅니다. 초기에는 빈 리스트입니다.</p>
        <p>내부 메소드와 내부 슬롯은 이 명세에서 [[ ]]로 둘러싼 이름으로 식별됩니다.</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref>는 ECMAScript 코드로 생성하거나 조작하는 모든 객체에 적용되는 <em>필수 내부 메소드</em>를 요약합니다. 모든 객체는 모든 필수 내부 메소드에 대한 알고리즘을 가져야 합니다. 하지만 모든 객체가 반드시 동일한 알고리즘을 사용하는 것은 아닙니다.</p>
        <p><dfn id="ordinary-object" variants="ordinary objects">일반 객체</dfn>는 다음 기준을 모두 만족하는 객체입니다:</p>
        <ul>
          <li>
            <emu-xref href="#table-essential-internal-methods"></emu-xref>에 나열된 내부 메소드에 대해 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>에 정의된 메소드를 사용합니다.
          </li>
          <li>
            객체에 [[Call]] 내부 메소드가 있으면, <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 또는 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref>에 정의된 것 중 하나를 사용합니다.
          </li>
          <li>
            객체에 [[Construct]] 내부 메소드가 있으면, <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 또는 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref>에 정의된 것 중 하나를 사용합니다.
          </li>
        </ul>
        <p><dfn id="exotic-object" variants="exotic objects">이국 객체</dfn>는 일반 객체가 아닌 객체입니다.</p>
        <p>이 명세는 내부 메소드에 따라 여러 종류의 이국 객체를 인식합니다. 특정 종류의 이국 객체(Array 이국 객체, 바운드 함수 이국 객체 등)와 행동적으로 동등하지만 해당 종류에 대해 명세된 내부 메소드 집합이 동일하지 않은 객체는 해당 종류의 이국 객체로 인식되지 않습니다.</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref> 및 유사한 표의 “서명(Signature)” 열은 각 내부 메소드의 호출 패턴을 설명합니다. 호출 패턴에는 항상 괄호로 둘러싼 설명적 매개변수 이름 목록이 포함됩니다. 매개변수 이름이 ECMAScript 타입 이름과 같다면 해당 타입의 값이어야 함을 의미합니다. 내부 메소드가 명시적으로 값을 반환하면, 매개변수 목록 뒤에 “→”와 반환 타입 이름이 따라옵니다. 서명에서 사용된 타입 이름은 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>에서 정의된 타입에, 아래 추가 이름이 보강된 것입니다. “<em>any</em>”는 값이 ECMAScript 언어 타입 중 아무거나 될 수 있음을 의미합니다.</p>
        <p>내부 메소드는 매개변수 외에도 항상 해당 메소드 호출의 대상 객체에 접근할 수 있습니다.</p>
        <p>내부 메소드는 암시적으로 Completion Record를 반환하며, 반환 타입에 표시된 값을 감싼 정상 완료 또는 throw 완료입니다.</p>
        <emu-table id="table-essential-internal-methods" caption="필수 내부 메소드" oldids="table-5">
          <table>
            <thead>
              <tr>
                <th>
                  내부 메소드
                </th>
                <th>
                  서명(Signature)
                </th>
                <th>
                  설명
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[GetPrototypeOf]]
              </td>
              <td>
                ( ) <b>→</b> Object | Null
              </td>
              <td>
                이 객체의 상속 프로퍼티를 제공하는 객체를 결정합니다. *null* 값이면 상속 프로퍼티가 없음을 의미합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[SetPrototypeOf]]
              </td>
              <td>
                (Object | Null) <b>→</b> Boolean
              </td>
              <td>
                이 객체를 상속 프로퍼티를 제공하는 다른 객체와 연결합니다. *null*을 전달하면 상속 프로퍼티가 없음을 의미합니다. 연산이 성공적으로 완료되면 *true*, 실패하면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[IsExtensible]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                이 객체에 추가 프로퍼티를 추가할 수 있는지 결정합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[PreventExtensions]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                객체에 새 프로퍼티를 추가할 수 있는지 제어합니다. 연산이 성공하면 *true*, 실패하면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[GetOwnProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Undefined | Property Descriptor
              </td>
              <td>
                이 객체의 키가 _propertyKey_인 자체 프로퍼티에 대한 프로퍼티 설명자를 반환하거나, 해당 프로퍼티가 없으면 *undefined*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[DefineOwnProperty]]
              </td>
              <td>
                (_propertyKey_, _PropertyDescriptor_) <b>→</b> Boolean
              </td>
              <td>
                키가 _propertyKey_인 자체 프로퍼티를 생성하거나 상태를 _PropertyDescriptor_로 변경합니다. 프로퍼티가 성공적으로 생성/업데이트되면 *true*, 생성/업데이트할 수 없으면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[HasProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                이 객체에 _propertyKey_인 자체 또는 상속 프로퍼티가 이미 있는지 불리언 값으로 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                (_propertyKey_, _Receiver_) <b>→</b> <em>any</em>
              </td>
              <td>
                이 객체에서 키가 _propertyKey_인 프로퍼티의 값을 반환합니다. 프로퍼티 값을 가져오려면 ECMAScript 코드 실행이 필요할 수 있으며, 그 경우 _Receiver_가 코드 평가 시 *this* 값으로 사용됩니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                (_propertyKey_, _value_, _Receiver_) <b>→</b> Boolean
              </td>
              <td>
                키가 _propertyKey_인 프로퍼티 값을 _value_로 설정합니다. ECMAScript 코드 실행이 필요하면, _Receiver_가 *this* 값으로 사용됩니다. 값이 설정되면 *true*, 설정할 수 없으면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Delete]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                키가 _propertyKey_인 자체 프로퍼티를 객체에서 제거합니다. 프로퍼티가 삭제되지 않고 여전히 존재하면 *false*, 삭제되었거나 존재하지 않으면 *true*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[OwnPropertyKeys]]
              </td>
              <td>
                ( ) <b>→</b> 프로퍼티 키 리스트
              </td>
              <td>
                객체에 대한 모든 자체 프로퍼티 키를 요소로 하는 리스트를 반환합니다.
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>는 함수로 호출 가능한 객체가 지원하는 추가 필수 내부 메소드를 요약합니다. <dfn id="function-object" variants="function objects">함수 객체</dfn>란 [[Call]] 내부 메소드를 지원하는 객체입니다. <dfn id="constructor" variants="constructors">생성자</dfn>란 [[Construct]] 내부 메소드를 지원하는 객체입니다. [[Construct]]를 지원하는 모든 객체는 [[Call]]도 지원해야 하며, 즉 생성자는 항상 함수 객체입니다. 따라서 생성자는 <em>생성자 함수</em> 또는 <em>생성자 함수 객체</em>라고도 부를 수 있습니다.</p>
        <emu-table id="table-additional-essential-internal-methods-of-function-objects" caption="함수 객체의 추가 필수 내부 메소드" oldids="table-6">
          <table>
            <thead>
              <tr>
                <th>
                  내부 메소드
                </th>
                <th>
                  서명(Signature)
                </th>
                <th>
                  설명
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Call]]
              </td>
              <td>
                (<em>any</em>, <em>any</em>의 리스트) <b>→</b> <em>any</em>
              </td>
              <td>
                이 객체와 연관된 코드를 실행합니다. 함수 호출 표현식으로 호출됩니다. 내부 메소드의 인자는 *this* 값과 함수 호출 표현식에서 전달된 인자를 요소로 하는 리스트입니다. 이 내부 메소드를 구현한 객체는 <em>호출 가능</em>합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Construct]]
              </td>
              <td>
                (<em>any</em>의 리스트, Object) <b>→</b> Object
              </td>
              <td>
                객체를 생성합니다. `new` 연산자나 `super` 호출로 호출됩니다. 내부 메소드의 첫 번째 인자는 생성자 호출 또는 `super` 호출의 인자 리스트이고, 두 번째 인자는 `new` 연산자가 최초로 적용된 객체입니다. 이 내부 메소드를 구현한 객체는 <em>생성자</em>입니다. 함수 객체가 반드시 생성자인 것은 아니며, 생성자가 아닌 함수 객체는 [[Construct]] 내부 메소드가 없습니다.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>일반 객체 및 표준 이국 객체의 필수 내부 메소드 의미론은 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>에서 지정됩니다. 구현에서 이국 객체의 내부 메소드 사용이 지원되지 않는 경우, 해당 사용 시 *TypeError* 예외를 throw해야 합니다.</p>
      </emu-clause>

      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1>필수 내부 메소드의 불변성</h1>
        <p>ECMAScript 엔진의 객체 내부 메소드는 아래에 명시된 불변성 목록을 준수해야 합니다. 일반 ECMAScript 객체와 이 명세의 모든 표준 이국 객체는 이 불변성을 유지합니다. ECMAScript Proxy 객체는 [[ProxyHandler]] 객체의 트랩 결과에 대한 런타임 검사를 통해 이 불변성을 유지합니다.</p>
        <p>구현에서 제공하는 이국 객체도 해당 객체에 대해 이 불변성을 유지해야 합니다. 이 불변성을 위반하면 ECMAScript 코드의 예측 불가능한 동작이나 보안 문제를 일으킬 수 있습니다. 그러나 이 불변성 위반으로 구현의 메모리 안전성이 훼손되어서는 안 됩니다.</p>
        <p>이 불변성을 필수 내부 메소드의 기능을 대체하는 대체 인터페이스를 제공하는 등 어떤 방식으로든 우회하도록 허용해서는 안 됩니다.</p>
        <h2>정의:</h2>
        <ul>
          <li>
            내부 메소드의 <em>대상(target)</em>은 내부 메소드가 호출되는 객체입니다.
          </li>
          <li>
            대상이 [[IsExtensible]] 내부 메소드에서 *false*를 반환하거나 [[PreventExtensions]] 내부 메소드에서 *true*를 반환한 것으로 관찰되면, <em>비확장 대상</em>입니다.
          </li>
          <li>
            <em>존재하지 않는(non-existent)</em> 프로퍼티는 비확장 대상에 자체 프로퍼티로 존재하지 않는 프로퍼티입니다.
          </li>
          <li>
            <em>SameValue</em>에 대한 모든 참조는 SameValue 알고리즘 정의를 따릅니다.
          </li>
        </ul>
        <h2>반환값:</h2>
        <p>모든 내부 메소드가 반환하는 값은 다음 중 하나인 Completion Record여야 합니다:</p>
        <ul>
          <li>[[Type]] = ~normal~, [[Target]] = ~empty~, 그리고 [[Value]]가 해당 내부 메소드의 “정상 반환 타입”에 표시된 값</li>
          <li>[[Type]] = ~throw~, [[Target]] = ~empty~, 그리고 [[Value]]가 ECMAScript 언어 값</li>
        </ul>
        <emu-note>
          <p>내부 메소드는 continue, break, return 완료를 반환하면 안 됩니다.</p>
        </emu-note>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Object 또는 Null입니다.
          </li>
          <li>
            대상이 비확장 상태이고 [[GetPrototypeOf]]가 값 _V_를 반환하면, 이후 [[GetPrototypeOf]] 호출은 항상 _V_와 SameValue여야 합니다.
          </li>
        </ul>
        <emu-note>
          <p>객체의 프로토타입 체인은 유한 길이를 가져야 합니다(즉, 어떤 객체에서 시작해서 [[GetPrototypeOf]] 내부 메소드를 재귀적으로 적용하면 결국 *null*에 도달해야 함). 하지만 프로토타입 체인에 일반 객체 정의를 사용하지 않는 이국 객체가 포함되면, 이 요구사항은 객체 수준 불변성으로 강제할 수 없습니다. 이런 순환 프로토타입 체인은 객체 프로퍼티 접근 시 무한 루프를 유발할 수 있습니다.</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] ( _V_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            대상이 비확장 상태면, [[SetPrototypeOf]]는 _V_가 대상의 [[GetPrototypeOf]]로 관찰된 값과 SameValue가 아니면 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            [[IsExtensible]]가 *false*를 반환하면, 이후 해당 대상에서 [[IsExtensible]]은 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            [[PreventExtensions]]가 *true*를 반환하면, 이후 해당 대상에서 [[IsExtensible]]은 반드시 *false*를 반환해야 하며, 이제 대상은 비확장 상태로 간주됩니다.
          </li>
        </ul>
        <h2>[[GetOwnProperty]] ( _P_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Property Descriptor 또는 Undefined입니다.
          </li>
          <li>
            반환값이 프로퍼티 설명자이면, 반드시 완전히 채워진 설명자여야 합니다.
          </li>
          <li>
            _P_가 비구성, 비쓰기 자체 데이터 프로퍼티로 기술된 경우, 이후 [[GetOwnProperty]] ( _P_ ) 호출은 반드시 _P_의 [[Value]]와 SameValue인 [[Value]] 속성을 가진 설명자를 반환해야 합니다.
          </li>
          <li>
            _P_의 [[Writable]], [[Value]] 외의 속성이 시간에 따라 변경될 수 있거나 프로퍼티가 삭제될 수 있으면, _P_의 [[Configurable]] 속성은 반드시 *true*여야 합니다.
          </li>
          <li>
            [[Writable]] 속성이 *false*에서 *true*로 변할 수 있다면, [[Configurable]] 속성은 반드시 *true*여야 합니다.
          </li>
          <li>
            대상이 비확장 상태이고 _P_가 존재하지 않는 프로퍼티면, 이후 해당 대상에서 [[GetOwnProperty]] (_P_)는 반드시 _P_를 존재하지 않는 것으로 기술해야 합니다(즉, [[GetOwnProperty]] (_P_)는 *undefined*를 반환해야 함).
          </li>
        </ul>
        <emu-note>
          <p>세 번째 불변성의 결과로, 데이터 프로퍼티로 기술된 프로퍼티가 시간에 따라 다른 값을 반환할 수 있으면, 다른 메소드에서 값을 변경하는 메커니즘이 노출되지 않아도 [[Writable]]과 [[Configurable]] 중 하나 또는 둘 다 반드시 *true*여야 합니다.</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] ( _P_, _Desc_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            [[DefineOwnProperty]]는 _P_가 이전에 대상의 비구성 자체 프로퍼티로 관찰된 경우, 다음 중 하나가 아니면 반드시 *false*를 반환해야 합니다:
            <ol>
              <li>
                _P_가 쓰기 가능한 데이터 프로퍼티이다. 비구성 쓰기 가능 데이터 프로퍼티는 비구성 비쓰기 데이터 프로퍼티로 변경될 수 있다.
              </li>
              <li>
                _Desc_의 모든 속성이 _P_의 속성과 SameValue이다.
              </li>
            </ol>
          </li>
          <li>
            [[DefineOwnProperty]] (_P_, _Desc_)는 대상이 비확장 상태이고 _P_가 존재하지 않는 자체 프로퍼티이면 반드시 *false*를 반환해야 합니다. 즉, 비확장 대상 객체는 새 프로퍼티로 확장될 수 없습니다.
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            _P_가 이전에 대상의 비구성 자체 데이터 또는 접근자 프로퍼티로 관찰된 경우, [[HasProperty]]는 반드시 *true*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[Get]] ( _P_, _Receiver_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 ECMAScript 언어의 어떤 타입이든 가능합니다.
          </li>
          <li>
            _P_가 대상의 비구성, 비쓰기 자체 데이터 프로퍼티로 관찰된 값 _V_이면, [[Get]]은 반드시 _V_와 SameValue를 반환해야 합니다.
          </li>
          <li>
            _P_가 대상의 비구성 자체 접근자 프로퍼티로 관찰되고 [[Get]] 속성이 *undefined*이면, [[Get]] 연산은 반드시 *undefined*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            _P_가 대상의 비구성, 비쓰기 자체 데이터 프로퍼티로 관찰된 경우, [[Set]]은 _V_가 _P_의 [[Value]] 속성과 SameValue가 아니면 반드시 *false*를 반환해야 합니다.
          </li>
          <li>
            _P_가 대상의 비구성 자체 접근자 프로퍼티로 관찰되고 [[Set]] 속성이 *undefined*이면, [[Set]] 연산은 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            _P_가 대상의 비구성 자체 데이터 또는 접근자 프로퍼티로 관찰된 경우, [[Delete]]는 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 리스트입니다.
          </li>
          <li>
            반환된 리스트에는 중복 항목이 포함되면 안 됩니다.
          </li>
          <li>
            반환된 리스트의 각 요소는 프로퍼티 키여야 합니다.
          </li>
          <li>
            반환된 리스트에는 이전에 관찰된 모든 비구성 자체 프로퍼티의 키가 반드시 포함되어야 합니다.
          </li>
          <li>
            대상이 비확장 상태면, 반환된 리스트에는 [[GetOwnProperty]]로 관찰 가능한 대상의 모든 자체 프로퍼티 키만 포함되어야 합니다.
          </li>
        </ul>
        <h2>[[Call]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 ECMAScript 언어의 어떤 타입이든 가능합니다.
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Object입니다.
          </li>
          <li>
            대상은 반드시 [[Call]] 내부 메소드도 가져야 합니다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>잘 알려진 내장 객체</h1>
        <p>잘 알려진 내장 객체는 이 명세의 알고리즘에서 명시적으로 참조되는 내장 객체이며, 일반적으로 realm별로 별도의 정체성을 가집니다. 별도 지정이 없는 한, 각 내장 객체는 실제로 realm별로 하나씩 유사한 객체 집합에 해당합니다.</p>
        <p>이 명세 내에서 %name%과 같은 참조는 현재 realm과 연결된 해당 이름의 내장 객체를 의미합니다. %name.a.b%와 같은 참조는, 어떤 ECMAScript 코드가 평가되기 전에 내장 객체 %name%의 "a" 프로퍼티 값의 "b" 프로퍼티 값에 접근한 것과 같습니다. 현재 realm 및 그 내장 객체 결정 방법은 <emu-xref href="#sec-execution-contexts"></emu-xref>에 설명되어 있습니다. 잘 알려진 내장 객체 목록은 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>에 나와 있습니다.</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="잘 알려진 내장 객체" oldids="table-7">
          <table>
            <thead>
              <tr>
                <th>
                  내장 객체 이름
                </th>
                <th>
                  글로벌 이름
                </th>
                <th>
                  ECMAScript 언어 연관
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                `AggregateError` 생성자 (<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                Array 생성자 (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                ArrayBuffer 생성자 (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Array Iterator 객체의 프로토타입 (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Async-from-Sync Iterator 객체의 프로토타입 (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                async 함수 객체의 생성자 (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                async generator 함수 객체의 생성자 (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                async generator 객체의 프로토타입 (<emu-xref href="#sec-asyncgenerator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                모든 표준 내장 async iterator 객체가 간접적으로 상속하는 객체
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                `Atomics` 객체 (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                BigInt 생성자 (<emu-xref href="#sec-bigint-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                BigInt64Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                BigUint64Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                Boolean 생성자 (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                DataView 생성자 (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                Date 생성자 (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                `decodeURI` 함수 (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                `decodeURIComponent` 함수 (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                `encodeURI` 함수 (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                `encodeURIComponent` 함수 (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                Error 생성자 (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                `eval` 함수 (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                EvalError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                FinalizationRegistry 생성자 (<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float16Array%
              </td>
              <td>
                `Float16Array`
              </td>
              <td>
                Float16Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                Float32Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                Float64Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                For-In Iterator 객체의 프로토타입 (<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                Function 생성자 (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                generator 함수 객체의 생성자 (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                generator 객체의 프로토타입 (<emu-xref href="#sec-generator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                Int8Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                Int16Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                Int32Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                `isFinite` 함수 (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                `isNaN` 함수 (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Iterator%
              </td>
              <td>
                `Iterator`
              </td>
              <td>
                `Iterator` 생성자 (<emu-xref href="#sec-iterator-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorHelperPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator Helper 객체의 프로토타입 (<emu-xref href="#sec-%iteratorhelperprototype%-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                `JSON` 객체 (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                Map 생성자 (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Map Iterator 객체의 프로토타입 (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                `Math` 객체 (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                Number 생성자 (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                Object 생성자 (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                `parseFloat` 함수 (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                `parseInt` 함수 (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                Promise 생성자 (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                Proxy 생성자 (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                RangeError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                ReferenceError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                `Reflect` 객체 (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                RegExp 생성자 (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                RegExp String Iterator 객체의 프로토타입 (<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                Set 생성자 (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Set Iterator 객체의 프로토타입 (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                SharedArrayBuffer 생성자 (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                String 생성자 (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                String Iterator 객체의 프로토타입 (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                Symbol 생성자 (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                SyntaxError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                무조건 새로운 %TypeError% 인스턴스를 throw하는 함수 객체
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                모든 typed Array 생성자의 슈퍼 클래스 (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                TypeError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                Uint8Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                Uint8ClampedArray 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                Uint16Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                Uint32Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                URIError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                WeakMap 생성자 (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                WeakRef 생성자 (<emu-xref href="#sec-weak-ref-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                WeakSet 생성자 (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WrapForValidIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator.from에서 반환된 래핑된 iterator 객체의 프로토타입 (<emu-xref href="#sec-%wrapforvaliditeratorprototype%-object"></emu-xref>)
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>에 추가 항목이 있습니다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript 명세 타입</h1>
    <p>명세 타입은 ECMAScript 언어 구조와 ECMAScript 언어 타입의 의미론을 설명하기 위해 알고리즘 내에서 사용되는 메타 값에 해당합니다. 명세 타입에는 Reference Record, List, Completion Record, Property Descriptor, Environment Record, Abstract Closure, Data Block이 포함됩니다. 명세 타입 값은 ECMAScript 구현 내의 특정 엔티티에 반드시 대응하지는 않는 명세 산출물입니다. 명세 타입 값은 ECMAScript 표현식 평가의 중간 결과를 설명하는 데 사용할 수 있지만, 이러한 값은 객체의 프로퍼티나 ECMAScript 언어 변수의 값으로 저장될 수 없습니다.</p>

    <emu-clause id="sec-enum-specification-type">
      <h1>Enum 명세 타입</h1>
      <p><dfn variants="enum,enums">Enum</dfn>은 명세 내부에서만 사용되며 ECMAScript 코드에서는 직접적으로 관찰할 수 없는 값입니다. Enum은 ~sans-serif~ 서체로 표시됩니다. 예를 들어, Completion Record의 [[Type]] 필드는 ~normal~, ~return~, ~throw~와 같은 값을 가집니다. Enum은 이름 이외의 특징을 가지지 않습니다. Enum의 이름은 다른 Enum과 구별하기 위함이며, 그 사용이나 의미를 암시하지 않습니다.</p>
    </emu-clause>

    <emu-clause id="sec-list-and-record-specification-type">
      <h1>List와 Record 명세 타입</h1>
      <p><dfn variants="Lists">List</dfn> 타입은 `new` 표현식, 함수 호출, 그 외 값의 단순 순서 리스트가 필요한 알고리즘에서 인자 리스트 평가를 설명하는 데 사용됩니다(<emu-xref href="#sec-argument-lists"></emu-xref> 참조). List 타입의 값은 각 개별 값을 담고 있는 리스트 요소들의 순서 있는 시퀀스입니다. 이 시퀀스는 길이에 제한이 없습니다. 리스트의 요소는 0부터 시작하는 인덱스로 임의 접근할 수 있습니다. 표기상의 편의를 위해 배열과 유사한 문법으로 List 요소에 접근할 수 있습니다. 예를 들어, _arguments_[2]는 List _arguments_의 3번째 요소를 의미합니다.</p>
      <p>알고리즘이 List의 요소를 반복할 때 순서를 지정하지 않으면 List 요소의 순서대로 사용됩니다.</p>
      <p>이 명세에서는 리터럴 문법을 사용해 새로운 List 값을 표현할 수 있습니다. 예를 들어, « 1, 2 »는 두 개의 요소를 특정 값으로 초기화한 List 값을 정의합니다. 새로운 빈 List는 « »로 표현할 수 있습니다.</p>
      <p>이 명세에서 “the <dfn id="list-concatenation">list-concatenation</dfn> of _A_, _B_, ...”(각 인자가 비어 있을 수도 있는 List)라는 표현은 각 인자(순서대로)의 요소를 이어붙인(순서대로) 새로운 List 값을 의미합니다.</p>
      <p>List가 String 요소로 구성된 경우 “sorted according to <dfn id="lexicographic-code-unit-order">lexicographic code unit order</dfn>”란, IsLessThan 추상 연산에서 설명한 대로, 짧은 문자열 길이까지 각 코드 유닛의 숫자값으로 정렬하며, 모든 코드 유닛이 같으면 짧은 문자열이 긴 문자열보다 먼저 오도록 정렬한다는 뜻입니다.</p>
      <p><dfn variants="Records">Record</dfn> 타입은 이 명세의 알고리즘 내에서 데이터 집합을 설명하는 데 사용됩니다. Record 타입 값은 하나 이상의 이름 있는 필드로 구성됩니다. 각 필드의 값은 ECMAScript 언어 값 또는 명세 값입니다. 필드 이름은 항상 [[ ]]로 둘러싸입니다(예: [[Value]]).</p>
      <p>이 명세에서는 객체 리터럴과 유사한 문법으로 Record 값을 표현할 수 있습니다. 예를 들어, { [[Field1]]: 42, [[Field2]]: *false*, [[Field3]]: ~empty~ }는 세 개의 필드가 각각 특정 값으로 초기화된 Record 값을 정의합니다. 필드 이름의 순서는 중요하지 않습니다. 명시적으로 나열되지 않은 필드는 없는 것으로 간주합니다.</p>
      <p>명세 텍스트와 알고리즘에서 점 표기법으로 Record 값의 특정 필드를 참조할 수 있습니다. 예를 들어, 위의 예시 Record R에 대해 R.[[Field2]]는 “R의 [[Field2]] 필드”를 의미합니다.</p>
      <p>자주 사용되는 Record 필드 조합에 대해 스키마 이름을 붙일 수 있으며, 그 이름을 리터럴 Record 값에 접두어로 사용해 특정 집합의 집계임을 명시할 수 있습니다. 예: PropertyDescriptor { [[Value]]: 42, [[Writable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>Set과 Relation 명세 타입</h1>
      <p><em>Set</em> 타입은 메모리 모델에서 사용될 무순서 요소 집합을 설명하는 데 사용됩니다. ECMAScript 컬렉션 타입 Set과는 다릅니다. 혼동을 피하기 위해, 명세에서는 ECMAScript 컬렉션 인스턴스를 “Set 객체”라고 일관되게 부릅니다. Set 타입 값은 중복 없는 간단한 요소 집합입니다. 요소는 추가·제거할 수 있으며, Set끼리 합집합·교집합·차집합 연산이 가능합니다.</p>
      <p><dfn variants="Relations">Relation</dfn> 타입은 Set에 대한 제약을 설명하는 데 사용됩니다. Relation 타입 값은 값 도메인에서 가져온 순서쌍의 Set입니다. 예를 들어, 이벤트에 대한 Relation은 이벤트들의 순서쌍 집합입니다. Relation _R_과 값 도메인 내 두 값 _a_, _b_에 대해 _a_ _R_ _b_는 (_a_, _b_)가 _R_의 원소임을 뜻합니다. Relation이 어떤 조건에 대해 <dfn id="least-relation">최소 Relation</dfn>임은 그 조건을 만족하는 가장 작은 Relation임을 의미합니다.</p>
      <p><dfn variants="strict partial orders">엄격 부분 순서(strict partial order)</dfn>는 다음을 만족하는 Relation 값 _R_입니다.</p>
      <ul>
        <li>
          <p>모든 _R_의 도메인 내 _a_, _b_, _c_에 대해:</p>
          <ul>
            <li>_a_ _R_ _a_는 성립하지 않으며,</li>
            <li>_a_ _R_ _b_ 및 _b_ _R_ _c_이면, _a_ _R_ _c_이다.</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>위 두 속성은 각각 반사 불가성(irreflexivity)과 추이성(transitivity)이라 부릅니다.</p>
      </emu-note>
      <p><dfn variants="strict total orders">엄격 전순서(strict total order)</dfn>는 다음을 만족하는 Relation 값 _R_입니다.</p>
      <ul>
        <li>
          <p>모든 _R_의 도메인 내 _a_, _b_, _c_에 대해:</p>
          <ul>
            <li>_a_는 _b_이거나, _a_ _R_ _b_이거나, _b_ _R_ _a_이다.</li>
            <li>_a_ _R_ _a_는 성립하지 않는다.</li>
            <li>_a_ _R_ _b_ 그리고 _b_ _R_ _c_이면, _a_ _R_ _c_이다.</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>위 세 속성은 각각 전체성(totality), 반사 불가성(irreflexivity), 추이성(transitivity)이라 부릅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-completion-record-specification-type">
      <h1>Completion Record 명세 타입</h1>
      <p><dfn variants="Completion Records">Completion Record</dfn> 명세 타입은 실행 중 값의 전달과 제어 흐름(비지역적 제어 이동을 수행하는 문장인 `break`, `continue`, `return`, `throw`의 동작 등)을 설명하는 데 사용됩니다.</p>
      <p>Completion Record는 <emu-xref href="#table-completion-record-fields"></emu-xref>에 정의된 필드를 가집니다.</p>
      <emu-table id="table-completion-record-fields" caption="Completion Record 필드" oldids="table-8">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              ~normal~, ~break~, ~continue~, ~return~, ~throw~
            </td>
            <td>
              발생한 completion의 타입
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              Completion Record가 아닌 임의 값
            </td>
            <td>
              생성된 값
            </td>
          </tr>
          <tr>
            <td>
              [[Target]]
            </td>
            <td>
              문자열 또는 ~empty~
            </td>
            <td>
              지시된 제어 이동의 대상 레이블
            </td>
          </tr>
        </table>
      </emu-table>
      <p>다음과 같은 용어들이 Completion Record를 참조할 때 종종 사용됩니다.</p>
      <ul>
        <li><dfn variants="normal completions">normal completion</dfn>은 [[Type]] 값이 ~normal~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="break completions">break completion</dfn>은 [[Type]] 값이 ~break~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="continue completions">continue completion</dfn>은 [[Type]] 값이 ~continue~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="return completions">return completion</dfn>은 [[Type]] 값이 ~return~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="throw completions">throw completion</dfn>은 [[Type]] 값이 ~throw~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="abrupt completions">abrupt completion</dfn>은 [[Type]] 값이 ~normal~이 아닌 Completion Record를 의미합니다.</li>
        <li><dfn variants="normal completions containing">normal completion containing</dfn>은 [[Value]] 필드에 해당 타입의 값이 포함된 normal completion을 의미합니다.</li>
      </ul>
      <p>이 명세에서 정의된 호출 가능한 객체는 항상 normal completion이나 throw completion만 반환합니다. 그 외 Completion Record를 반환하는 것은 편집 오류로 간주합니다.</p>
      <p>구현 정의 호출 가능 객체도 normal completion 또는 throw completion만 반환해야 합니다.</p>

      <emu-clause id="sec-normalcompletion" type="abstract operation">
        <h1>
          NormalCompletion (
            _value_: Completion Record가 아닌 임의 값,
          ): normal completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throwcompletion" type="abstract operation">
        <h1>
          ThrowCompletion (
            _value_: ECMAScript 언어 값,
          ): throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returncompletion" type="abstract operation">
        <h1>
          ReturnCompletion (
            _value_: ECMAScript 언어 값,
          ): return completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-updateempty" type="abstract operation">
        <h1>
          UpdateEmpty (
            _completionRecord_: Completion Record,
            _value_: Completion Record가 아닌 임의 값,
          ): Completion Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: _completionRecord_가 return completion 또는 throw completion이면, _completionRecord_.[[Value]]는 ~empty~가 아니다.
          1. _completionRecord_.[[Value]]가 ~empty~가 아니면, ? _completionRecord_를 반환한다.
          1. Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>Reference Record 명세 타입</h1>
      <p><dfn variants="Reference Records">Reference Record</dfn> 타입은 `delete`, `typeof`, 대입 연산자, `super` 키워드 및 기타 언어 기능의 동작을 설명하는 데 사용됩니다. 예를 들어, 대입의 왼쪽 피연산자는 Reference Record를 생성해야 합니다.</p>
      <p>Reference Record는 해석된 이름 또는(아직 해석되지 않았을 수도 있는) 프로퍼티 바인딩이며, 필드는 <emu-xref href="#table-reference-record-fields"></emu-xref>에 정의되어 있습니다.</p>

      <emu-table id="table-reference-record-fields" caption="Reference Record 필드">
        <table>
          <thead>
            <tr>
              <th>필드 이름</th>
              <th>값</th>
              <th>의미</th>
            </tr>
          </thead>
          <tr>
            <td oldids="sec-getbase,ao-getbase">[[Base]]</td>
            <td>ECMAScript 언어 값, Environment Record, ~unresolvable~</td>
            <td>바인딩을 담고 있는 값 또는 Environment Record. [[Base]]가 ~unresolvable~이면 바인딩을 해석할 수 없음을 의미합니다.</td>
          </tr>
          <tr>
            <td oldids="sec-getreferencedname,ao-getreferencedname">[[ReferencedName]]</td>
            <td>ECMAScript 언어 값 또는 Private Name</td>
            <td>바인딩의 이름. [[Base]] 값이 Environment Record면 항상 문자열입니다. 그렇지 않으면, ToPropertyKey가 수행되기 전까지 문자열이나 심볼이 아닌 ECMAScript 언어 값일 수 있습니다.</td>
          </tr>
          <tr>
            <td oldids="sec-isstrictreference,ao-isstrictreference">[[Strict]]</td>
            <td>불리언</td>
            <td>Reference Record가 strict 모드 코드에서 생성되었으면 *true*, 아니면 *false*입니다.</td>
          </tr>
          <tr>
            <td>[[ThisValue]]</td>
            <td>ECMAScript 언어 값 또는 ~empty~</td>
            <td>~empty~가 아니면, Reference Record가 `super` 키워드로 표현된 프로퍼티 바인딩을 나타냅니다. 이를 <dfn id="super-reference-record" oldids="super-reference" variants="Super Reference Records">Super Reference Record</dfn>라 하며, [[Base]] 값은 Environment Record가 될 수 없습니다. 이 경우 [[ThisValue]] 필드는 Reference Record가 생성된 시점의 *this* 값을 담습니다.</td>
          </tr>
        </table>
      </emu-table>

      <p>Reference Record를 다루기 위해 명세에서 다음과 같은 추상 연산을 사용합니다:</p>

      <emu-clause id="sec-ispropertyreference" type="abstract operation" oldids="ao-ispropertyreference">
        <h1>
          IsPropertyReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[Base]]가 ~unresolvable~이면 *false* 반환.
          1. _V_.[[Base]]가 Environment Record이면 *false* 반환; 아니면 *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" type="abstract operation" oldids="ao-isunresolvablereference">
        <h1>
          IsUnresolvableReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[Base]]가 ~unresolvable~이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" type="abstract operation" oldids="ao-issuperreference">
        <h1>
          IsSuperReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[ThisValue]]가 ~empty~가 아니면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isprivatereference" type="abstract operation">
        <h1>
          IsPrivateReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[ReferencedName]]이 Private Name이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvalue" type="abstract operation">
        <h1>
          GetValue (
            _V_: Reference Record 또는 ECMAScript 언어 값,
          ): ECMAScript 언어 값을 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_가 Reference Record가 아니면 _V_를 반환한다.
          1. IsUnresolvableReference(_V_)가 *true*이면 *ReferenceError* 예외를 throw한다.
          1. IsPropertyReference(_V_)가 *true*이면,
            1. [id="step-getvalue-toobject"] _baseObj_를 ? ToObject(_V_.[[Base]])로 한다.
            1. IsPrivateReference(_V_)가 *true*이면,
              1. ? PrivateGet(_baseObj_, _V_.[[ReferencedName]])를 반환한다.
            1. _V_.[[ReferencedName]]이 프로퍼티 키가 아니면,
              1. _V_.[[ReferencedName]]을 ? ToPropertyKey(_V_.[[ReferencedName]])로 설정한다.
            1. ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_))를 반환한다.
          1. 아니면,
            1. _base_를 _V_.[[Base]]로 한다.
            1. 단언: _base_는 Environment Record이다.
            1. ? <emu-meta effects="user-code">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]])를 반환한다(<emu-xref href="#sec-environment-records"></emu-xref> 참조).
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-getvalue-toobject"></emu-xref> 단계에서 생성되는 객체는 위 추상 연산과 ordinary object [[Get]] 내부 메소드 외부에서는 접근할 수 없습니다. 구현에서는 실제 객체 생성을 생략할 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" type="abstract operation">
        <h1>
          PutValue (
            _V_: Reference Record 또는 ECMAScript 언어 값,
            _W_: ECMAScript 언어 값,
          ): ~unused~을 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_가 Reference Record가 아니면 *ReferenceError* 예외를 throw한다.
          1. IsUnresolvableReference(_V_)가 *true*이면,
            1. _V_.[[Strict]]가 *true*이면 *ReferenceError* 예외를 throw한다.
            1. _globalObj_를 GetGlobalObject()로 한다.
            1. ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*)를 수행한다.
            1. ~unused~를 반환한다.
          1. IsPropertyReference(_V_)가 *true*이면,
            1. [id="step-putvalue-toobject"] _baseObj_를 ? ToObject(_V_.[[Base]])로 한다.
            1. IsPrivateReference(_V_)가 *true*이면,
              1. ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_)를 반환한다.
            1. _V_.[[ReferencedName]]이 프로퍼티 키가 아니면,
              1. _V_.[[ReferencedName]]을 ? ToPropertyKey(_V_.[[ReferencedName]])로 설정한다.
            1. _succeeded_를 ? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_))로 한다.
            1. _succeeded_가 *false*이고 _V_.[[Strict]]가 *true*이면 *TypeError* 예외를 throw한다.
            1. ~unused~를 반환한다.
          1. 아니면,
            1. _base_를 _V_.[[Base]]로 한다.
            1. 단언: _base_는 Environment Record이다.
            1. ? <emu-meta effects="user-code">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]])를 반환한다(<emu-xref href="#sec-environment-records"></emu-xref> 참조).
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-putvalue-toobject"></emu-xref> 단계에서 생성되는 객체는 위 추상 연산과 ordinary object [[Set]] 내부 메소드 외부에서는 접근할 수 없습니다. 구현에서는 실제 객체 생성을 생략할 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getthisvalue" type="abstract operation">
        <h1>
          GetThisValue (
            _V_: Reference Record,
          ): ECMAScript 언어 값
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: IsPropertyReference(_V_)는 *true*이다.
          1. IsSuperReference(_V_)가 *true*이면 _V_.[[ThisValue]] 반환; 아니면 _V_.[[Base]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: Reference Record,
            _W_: ECMAScript 언어 값,
          ): ~unused~을 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: IsUnresolvableReference(_V_)는 *false*이다.
          1. _base_를 _V_.[[Base]]로 한다.
          1. 단언: _base_는 Environment Record이다.
          1. ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeprivatereference" type="abstract operation">
        <h1>
          MakePrivateReference (
            _baseValue_: ECMAScript 언어 값,
            _privateIdentifier_: 문자열,
          ): Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _privateEnv_를 실행 중인 실행 컨텍스트의 PrivateEnvironment로 한다.
          1. 단언: _privateEnv_는 *null*이 아니다.
          1. _privateName_을 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)로 한다.
          1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-descriptor-specification-type">
      <h1>Property Descriptor 명세 타입</h1>
      <p><dfn variants="Property Descriptors">Property Descriptor</dfn> 타입은 Object 프로퍼티 속성의 조작과 구체화를 설명하는 데 사용됩니다. Property Descriptor는 0개 이상의 필드를 갖는 Record이며, 각 필드 이름은 속성 이름이고 값은 <emu-xref href="#sec-property-attributes"></emu-xref>에 지정된 속성 값입니다. 명세에서 Property Descriptor 레코드의 리터럴 설명을 태그하는 스키마 이름은 “PropertyDescriptor”입니다.</p>
      <p>Property Descriptor 값은 특정 필드의 존재나 사용에 따라 데이터 Property Descriptor와 접근자 Property Descriptor로 더 분류할 수 있습니다. [[Value]] 또는 [[Writable]] 필드가 있으면 데이터 Property Descriptor, [[Get]] 또는 [[Set]] 필드가 있으면 접근자 Property Descriptor입니다. 모든 Property Descriptor에는 [[Enumerable]]과 [[Configurable]] 필드가 있을 수 있습니다. 한 Property Descriptor 값은 데이터 Property Descriptor와 접근자 Property Descriptor를 동시에 가질 수 없지만, 둘 다 아닐 수도 있습니다(이 경우 generic Property Descriptor). <dfn>완전한 Property Descriptor</dfn>는 접근자 또는 데이터 Property Descriptor이면서 <emu-xref href="#table-object-property-attributes"></emu-xref>의 해당 필드를 모두 가지고 있는 것입니다.</p>
      <p>이 명세에서 Property Descriptor 값을 다루기 위해 다음 추상 연산을 사용합니다:</p>

      <emu-clause id="sec-isaccessordescriptor" type="abstract operation">
        <h1>
          IsAccessorDescriptor (
            _Desc_: Property Descriptor,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_에 [[Get]] 필드가 있으면 *true* 반환.
          1. _Desc_에 [[Set]] 필드가 있으면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdatadescriptor" type="abstract operation">
        <h1>
          IsDataDescriptor (
            _Desc_: Property Descriptor,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_에 [[Value]] 필드가 있으면 *true* 반환.
          1. _Desc_에 [[Writable]] 필드가 있으면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isgenericdescriptor" type="abstract operation">
        <h1>
          IsGenericDescriptor (
            _Desc_: Property Descriptor,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsAccessorDescriptor(_Desc_)가 *true*면 *false* 반환.
          1. IsDataDescriptor(_Desc_)가 *true*면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frompropertydescriptor" type="abstract operation">
        <h1>
          FromPropertyDescriptor (
            _Desc_: Property Descriptor 또는 *undefined*,
          ): Object 또는 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_가 *undefined*면 *undefined* 반환.
          1. _obj_를 OrdinaryObjectCreate(%Object.prototype%)로 한다.
          1. 단언: _obj_는 확장 가능한 ordinary object이며 자체 프로퍼티가 없다.
          1. _Desc_에 [[Value]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _Desc_.[[Value]])를 수행한다.
          1. _Desc_에 [[Writable]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"writable"*, _Desc_.[[Writable]])를 수행한다.
          1. _Desc_에 [[Get]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"get"*, _Desc_.[[Get]])를 수행한다.
          1. _Desc_에 [[Set]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"set"*, _Desc_.[[Set]])를 수행한다.
          1. _Desc_에 [[Enumerable]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"enumerable"*, _Desc_.[[Enumerable]])를 수행한다.
          1. _Desc_에 [[Configurable]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"configurable"*, _Desc_.[[Configurable]])를 수행한다.
          1. _obj_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-topropertydescriptor" type="abstract operation">
        <h1>
          ToPropertyDescriptor (
            _Obj_: ECMAScript 언어 값,
          ): Property Descriptor를 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Obj_가 Object가 아니면 *TypeError* 예외를 throw한다.
          1. _desc_를 초기에는 필드가 없는 새로운 Property Descriptor로 한다.
          1. _hasEnumerable_을 ? HasProperty(_Obj_, *"enumerable"*)로 한다.
          1. _hasEnumerable_이 *true*면,
            1. _enumerable_을 ToBoolean(? Get(_Obj_, *"enumerable"*))로 한다.
            1. _desc_.[[Enumerable]]에 _enumerable_을 할당한다.
          1. _hasConfigurable_을 ? HasProperty(_Obj_, *"configurable"*)로 한다.
          1. _hasConfigurable_이 *true*면,
            1. _configurable_을 ToBoolean(? Get(_Obj_, *"configurable"*))로 한다.
            1. _desc_.[[Configurable]]에 _configurable_을 할당한다.
          1. _hasValue_를 ? HasProperty(_Obj_, *"value"*)로 한다.
          1. _hasValue_가 *true*면,
            1. _value_를 ? Get(_Obj_, *"value"*)로 한다.
            1. _desc_.[[Value]]에 _value_를 할당한다.
          1. _hasWritable_을 ? HasProperty(_Obj_, *"writable"*)로 한다.
          1. _hasWritable_이 *true*면,
            1. _writable_을 ToBoolean(? Get(_Obj_, *"writable"*))로 한다.
            1. _desc_.[[Writable]]에 _writable_을 할당한다.
          1. _hasGet_을 ? HasProperty(_Obj_, *"get"*)로 한다.
          1. _hasGet_이 *true*면,
            1. _getter_를 ? Get(_Obj_, *"get"*)로 한다.
            1. IsCallable(_getter_)가 *false*이고 _getter_가 *undefined*가 아니면 *TypeError* 예외를 throw한다.
            1. _desc_.[[Get]]에 _getter_를 할당한다.
          1. _hasSet_을 ? HasProperty(_Obj_, *"set"*)로 한다.
          1. _hasSet_이 *true*면,
            1. _setter_를 ? Get(_Obj_, *"set"*)로 한다.
            1. IsCallable(_setter_)가 *false*이고 _setter_가 *undefined*가 아니면 *TypeError* 예외를 throw한다.
            1. _desc_.[[Set]]에 _setter_를 할당한다.
          1. _desc_에 [[Get]] 또는 [[Set]] 필드가 있으면,
            1. _desc_에 [[Value]] 또는 [[Writable]] 필드가 있으면 *TypeError* 예외를 throw한다.
          1. _desc_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-completepropertydescriptor" type="abstract operation">
        <h1>
          CompletePropertyDescriptor (
            _Desc_: Property Descriptor,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _like_를 Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }로 한다.
          1. IsGenericDescriptor(_Desc_)가 *true*이거나 IsDataDescriptor(_Desc_)가 *true*이면,
            1. _Desc_에 [[Value]] 필드가 없으면 _Desc_.[[Value]]에 _like_.[[Value]]를 할당한다.
            1. _Desc_에 [[Writable]] 필드가 없으면 _Desc_.[[Writable]]에 _like_.[[Writable]]를 할당한다.
          1. 아니면,
            1. _Desc_에 [[Get]] 필드가 없으면 _Desc_.[[Get]]에 _like_.[[Get]]를 할당한다.
            1. _Desc_에 [[Set]] 필드가 없으면 _Desc_.[[Set]]에 _like_.[[Set]]를 할당한다.
          1. _Desc_에 [[Enumerable]] 필드가 없으면 _Desc_.[[Enumerable]]에 _like_.[[Enumerable]]를 할당한다.
          1. _Desc_에 [[Configurable]] 필드가 없으면 _Desc_.[[Configurable]]에 _like_.[[Configurable]]를 할당한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-and-environment-record-specification-types">
      <h1>Environment Record 명세 타입</h1>
      <p>Environment Record 타입은 중첩 함수와 블록에서 이름 해석 동작을 설명하는 데 사용됩니다. 이 타입과 관련 연산은 <emu-xref href="#sec-environment-records"></emu-xref>에 정의되어 있습니다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-closure">
      <h1>Abstract Closure 명세 타입</h1>
      <p><dfn variants="Abstract Closures">Abstract Closure</dfn> 명세 타입은 알고리즘 단계와 값 집합을 함께 참조하는 데 사용됩니다. Abstract Closure는 메타 값이며 함수 호출 방식(_closure_(_arg1_, _arg2_))으로 호출됩니다. 추상 연산과 마찬가지로, 호출 시 Abstract Closure에 기술된 알고리즘 단계를 수행합니다.</p>
      <p>Abstract Closure를 생성하는 알고리즘 단계에서는 "capture" 뒤에 별칭 목록으로 값을 캡처합니다. Abstract Closure가 생성될 때 각 별칭에 연관된 값을 캡처합니다. Abstract Closure가 호출될 때 수행할 알고리즘 단계에서는 캡처된 값을 캡처 당시 사용된 별칭으로 참조합니다.</p>
      <p>Abstract Closure가 Completion Record를 반환하면, 반드시 normal completion 또는 throw completion이어야 합니다.</p>
      <p>Abstract Closure는 다른 알고리즘의 일부로 인라인 생성됩니다. 예시는 다음과 같습니다.</p>
      <emu-alg example>
        1. _addend_를 41로 한다.
        1. _closure_를 매개변수(_x_)를 가지며, _addend_를 캡처하고 호출 시 다음 단계를 수행하는 새로운 Abstract Closure로 한다:
          1. _x_ + _addend_를 반환한다.
        1. _val_을 _closure_(1)로 한다.
        1. 단언: _val_은 42이다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-data-blocks">
      <h1>Data Block</h1>
      <p><dfn variants="Data Blocks">Data Block</dfn> 명세 타입은 개별적이고 변경 가능한 바이트 크기(8비트)의 숫자값 시퀀스를 설명하는 데 사용됩니다. <dfn variants="byte values">byte value</dfn>는 0부터 255(포함) 사이의 정수입니다. Data Block 값은 고정된 바이트 수로 생성되며 각 바이트의 초기값은 0입니다.</p>
      <p>이 명세에서는 배열과 유사한 문법으로 Data Block 값의 개별 바이트에 접근할 수 있습니다. 이 표기법은 Data Block 값을 0 기반 <emu-not-ref>integer-indexed</emu-not-ref> 바이트 시퀀스로 표현합니다. 예를 들어, _db_가 5바이트 Data Block 값이면 _db_[2]는 3번째 바이트에 접근할 수 있습니다.</p>
      <p>메모리 내에서 여러 agent가 동시에 참조할 수 있는 data block은 <dfn variants="Shared Data Blocks">Shared Data Block</dfn>이라 부릅니다. Shared Data Block은 <em>주소 자유(address-free)</em>의 정체성을 갖습니다(Shared Data Block 값의 동등성 검사 목적). 이는 해당 블록이 어떤 프로세스의 가상 주소에 매핑되어 있든 상관없이, 그 블록이 나타내는 메모리 위치 집합에 따라 정체성이 결정됨을 뜻합니다. 두 data block은 그 위치 집합이 같을 때만 같고, 그렇지 않으면 다르며, 위치 집합의 교집합은 비어 있습니다. 마지막으로, Shared Data Block과 Data Block은 구별할 수 있습니다.</p>
      <p>Shared Data Block의 의미론은 메모리 모델에서 Shared Data Block 이벤트를 사용해 정의됩니다. 아래 추상 연산들은 Shared Data Block 이벤트를 도입하며, 평가 의미론과 메모리 모델의 이벤트 의미론 사이의 인터페이스 역할을 합니다. 이벤트들은 후보 실행(candidate execution)을 구성하며, 메모리 모델은 후보 실행에 필터로 작동합니다. 전체 의미론은 메모리 모델을 참고하세요.</p>
      <p>Shared Data Block 이벤트는 메모리 모델에서 정의된 Record로 모델링됩니다.</p>
      <p>이 명세에서 Data Block 값을 다루기 위해 다음과 같은 추상 연산을 사용합니다:</p>

      <emu-clause id="sec-createbytedatablock" type="abstract operation">
        <h1>
          CreateByteDataBlock (
            _size_: 0 이상 정수,
          ): Data Block을 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _size_ > 2<sup>53</sup> - 1이면 *RangeError* 예외를 throw한다.
          1. _db_를 _size_ 바이트로 구성된 새로운 Data Block 값으로 한다. 생성이 불가능하면 *RangeError* 예외를 throw한다.
          1. _db_의 모든 바이트를 0으로 설정한다.
          1. _db_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createsharedbytedatablock" type="abstract operation">
        <h1>
          CreateSharedByteDataBlock (
            _size_: 0 이상 정수,
          ): Shared Data Block을 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _db_를 _size_ 바이트로 구성된 새로운 Shared Data Block 값으로 한다. 생성이 불가능하면 *RangeError* 예외를 throw한다.
          1. _execution_을 주위 agent의 Agent Record의 [[CandidateExecution]] 필드로 한다.
          1. _eventsRecord_를 _execution_.[[EventsRecords]] 중 [[AgentSignifier]]가 AgentSignifier()인 Agent Events Record로 한다.
          1. _zero_를 « 0 »으로 한다.
          1. _db_의 각 인덱스 _i_에 대해,
            1. WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ }를 _eventsRecord_.[[EventList]]에 추가한다.
          1. _db_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-copydatablockbytes" type="abstract operation">
        <h1>
          CopyDataBlockBytes (
            _toBlock_: Data Block 또는 Shared Data Block,
            _toIndex_: 0 이상 정수,
            _fromBlock_: Data Block 또는 Shared Data Block,
            _fromIndex_: 0 이상 정수,
            _count_: 0 이상 정수,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: _fromBlock_과 _toBlock_은 서로 다른 값이다.
          1. _fromSize_를 _fromBlock_의 바이트 수로 한다.
          1. 단언: _fromIndex_ + _count_ ≤ _fromSize_이다.
          1. _toSize_를 _toBlock_의 바이트 수로 한다.
          1. 단언: _toIndex_ + _count_ ≤ _toSize_이다.
          1. _count_ > 0 동안 반복한다,
            1. _fromBlock_이 Shared Data Block이면,
              1. _execution_을 주위 agent의 Agent Record의 [[CandidateExecution]] 필드로 한다.
              1. _eventsRecord_를 _execution_.[[EventsRecords]] 중 [[AgentSignifier]]가 AgentSignifier()인 Agent Events Record로 한다.
              1. _bytes_를 nondeterministically 선택된 byte value 1개만 담은 List로 한다.
              1. 참고: 구현에서 _bytes_는 기저 하드웨어에서 비원자적 읽기 명령 결과입니다. 이 nondeterminism은 하드웨어의 약한 일관성에서 관찰 가능한 행동을 설명하기 위한 메모리 모델의 의미론적 처방입니다.
              1. _readEvent_를 ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }로 한다.
              1. _readEvent_를 _eventsRecord_.[[EventList]]에 추가한다.
              1. Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ }를 _execution_.[[ChosenValues]]에 추가한다.
              1. _toBlock_이 Shared Data Block이면,
                1. WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ }를 _eventsRecord_.[[EventList]]에 추가한다.
              1. 아니면,
                1. _toBlock_[_toIndex_]를 _bytes_[0]로 설정한다.
            1. 아니면,
              1. 단언: _toBlock_은 Shared Data Block이 아니다.
              1. _toBlock_[_toIndex_]를 _fromBlock_[_fromIndex_]로 설정한다.
            1. _toIndex_를 _toIndex_ + 1로 한다.
            1. _fromIndex_를 _fromIndex_ + 1로 한다.
            1. _count_를 _count_ - 1로 한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-privateelement-specification-type">
      <h1>PrivateElement 명세 타입</h1>
      <p>PrivateElement 타입은 private 클래스 필드, 메소드, 접근자 명세에 사용되는 Record입니다. Property Descriptor는 private element에 사용되지 않지만, private 필드는 비구성·비열거·쓰기 가능한 데이터 프로퍼티와, private 메소드는 비구성·비열거·쓰기 불가능한 데이터 프로퍼티와, private 접근자는 비구성·비열거 접근자 프로퍼티와 유사하게 동작합니다.</p>
      <p>PrivateElement 타입의 값은 <emu-xref href="#table-privateelement-fields"></emu-xref>에 정의된 필드를 갖는 Record 값입니다. 이러한 값을 <dfn variants="PrivateElement">PrivateElement</dfn>라 합니다.</p>
      <emu-table id="table-privateelement-fields" caption="PrivateElement 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                [[Kind]] 필드 값이 있을 때
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Key]]
            </td>
            <td>
              전체
            </td>
            <td>
              Private Name
            </td>
            <td>
              필드, 메소드, 접근자의 이름
            </td>
          </tr>
          <tr>
            <td>
              [[Kind]]
            </td>
            <td>
              전체
            </td>
            <td>
              ~field~, ~method~, ~accessor~
            </td>
            <td>
              element의 종류
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              ~field~, ~method~
            </td>
            <td>
              ECMAScript 언어 값
            </td>
            <td>
              필드의 값
            </td>
          </tr>
          <tr>
            <td>
              [[Get]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              함수 객체 또는 *undefined*
            </td>
            <td>
              private 접근자의 getter
            </td>
          </tr>
          <tr>
            <td>
              [[Set]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              함수 객체 또는 *undefined*
            </td>
            <td>
              private 접근자의 setter
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-classfielddefinition-record-specification-type">
      <h1>ClassFieldDefinition Record 명세 타입</h1>
      <p>ClassFieldDefinition 타입은 클래스 필드 명세에 사용되는 Record입니다.</p>
      <p>ClassFieldDefinition 타입의 값은 <emu-xref href="#table-classfielddefinition-fields"></emu-xref>에 정의된 필드를 갖는 Record 값입니다. 이러한 값을 <dfn variants="ClassFieldDefinition Record">ClassFieldDefinition Record</dfn>라 합니다.</p>
      <emu-table id="table-classfielddefinition-fields" caption="ClassFieldDefinition Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Name]]
            </td>
            <td>
              Private Name, 문자열, 심볼
            </td>
            <td>
              필드의 이름
            </td>
          </tr>
          <tr>
            <td>
              [[Initializer]]
            </td>
            <td>
              ECMAScript 함수 객체 또는 ~empty~
            </td>
            <td>
              필드의 초기화 함수(있으면)
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-private-names">
      <h1>Private Name</h1>
      <p><dfn variants="Private Names">Private Name</dfn> 명세 타입은 전역적으로 고유한 값(다른 Private Name과 구별됨, 설령 구별 불가해 보여도)을 설명하는 데 사용됩니다. 이 값은 private 클래스 요소(필드, 메소드, 접근자)의 키를 나타냅니다. 각 Private Name은 불변의 [[Description]] 내부 슬롯을 가지며, 이는 문자열입니다. Private Name은 ECMAScript 객체에 PrivateFieldAdd 또는 PrivateMethodOrAccessorAdd로 설치할 수 있으며, PrivateGet과 PrivateSet을 통해 읽거나 쓸 수 있습니다.</p>
    </emu-clause>

    <emu-clause id="sec-classstaticblockdefinition-record-specification-type">
      <h1>ClassStaticBlockDefinition Record 명세 타입</h1>
      <p><dfn variants="ClassStaticBlockDefinition Records">ClassStaticBlockDefinition Record</dfn>는 클래스 static 초기화 블록의 실행 코드를 캡슐화하는 데 사용되는 Record 값입니다.</p>
      <p>ClassStaticBlockDefinition Record는 <emu-xref href="#table-classstaticblockdefinition-record-fields"></emu-xref>에 나열된 필드를 가집니다.</p>
      <emu-table id="table-classstaticblockdefinition-record-fields" caption="ClassStaticBlockDefinition Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BodyFunction]]
            </td>
            <td>
              ECMAScript 함수 객체
            </td>
            <td>
              클래스 static 초기화 시 호출되는 함수 객체
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>추상 연산(Abstract Operations)</h1>
  <p>이 연산들은 ECMAScript 언어의 일부가 아니며; ECMAScript 언어의 의미론을 명세하기 쉽게 하기 위해 여기에서만 정의됩니다. 이 명세 전반에 걸쳐 보다 특수화된 다른 추상 연산들이 정의됩니다.</p>

  <emu-clause id="sec-type-conversion">
    <h1>타입 변환(Type Conversion)</h1>
    <p>ECMAScript 언어는 필요에 따라 자동으로 암시적 타입 변환을 수행합니다. 특정 구성의 의미론을 명확히 하기 위해 일련의 변환 추상 연산을 정의하는 것이 유용합니다. 변환 추상 연산은 다형적이며; 어떤 ECMAScript 언어 타입의 값이든 받을 수 있습니다. 그러나 다른 명세 타입은 이러한 연산과 함께 사용되지 않습니다.</p>
    <p>BigInt 타입은 ECMAScript 언어에서 암시적 변환이 없습니다; 프로그래머는 다른 타입에서 값을 변환하기 위해 반드시 BigInt를 명시적으로 호출해야 합니다.</p>

    <emu-clause id="sec-toprimitive" type="abstract operation" oldids="table-9">
      <h1>
        ToPrimitive (
          _input_: ECMAScript 언어 값,
          optional _preferredType_: ~string~ 또는 ~number~,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_input_ 인수를 비-Object 타입으로 변환합니다. 객체가 둘 이상의 원시 타입으로 변환 가능하다면 선택적 힌트 _preferredType_을 사용하여 그 타입을 우선할 수 있습니다.</dd>
      </dl>
      <emu-alg>
        1. _input_이 Object이면,
          1. _exoticToPrim_을 ? GetMethod(_input_, %Symbol.toPrimitive%)로 둔다.
          1. _exoticToPrim_이 *undefined*가 아니면,
            1. _preferredType_이 존재하지 않으면,
              1. _hint_를 *"default"*로 둔다.
            1. Else if _preferredType_이 ~string~이면,
              1. _hint_를 *"string"*으로 둔다.
            1. Else,
              1. 단언: _preferredType_은 ~number~이다.
              1. _hint_를 *"number"*로 둔다.
            1. _result_를 ? Call(_exoticToPrim_, _input_, « _hint_ »)로 둔다.
            1. _result_가 Object가 아니면 _result_를 반환한다.
            1. *TypeError* 예외를 던진다.
          1. _preferredType_이 존재하지 않으면 _preferredType_을 ~number~로 둔다.
          1. ? OrdinaryToPrimitive(_input_, _preferredType_)을 반환한다.
        1. _input_을 반환한다.
      </emu-alg>
      <emu-note>
        <p>ToPrimitive가 힌트 없이 호출되면 일반적으로 힌트가 ~number~인 것처럼 동작합니다. 그러나 객체는 %Symbol.toPrimitive% 메서드를 정의하여 이 동작을 재정의할 수 있습니다. 이 명세에 정의된 객체 중 Date( <emu-xref href="#sec-date.prototype-%symbol.toprimitive%"></emu-xref> 참조 )와 Symbol 객체( <emu-xref href="#sec-symbol.prototype-%symbol.toprimitive%"></emu-xref> 참조 )만이 기본 ToPrimitive 동작을 재정의합니다. Date는 힌스가 없는 경우 힌트가 ~string~인 것처럼 취급합니다.</p>
      </emu-note>

      <emu-clause id="sec-ordinarytoprimitive" type="abstract operation">
        <h1>
          OrdinaryToPrimitive (
            _O_: Object,
            _hint_: ~string~ 또는 ~number~,
          ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _hint_가 ~string~이면,
            1. _methodNames_를 « *"toString"*, *"valueOf"* »로 둔다.
          1. Else,
            1. _methodNames_를 « *"valueOf"*, *"toString"* »으로 둔다.
          1. _methodNames_의 각 요소 _name_에 대해,
            1. _method_를 ? Get(_O_, _name_)으로 둔다.
            1. IsCallable(_method_)가 *true*이면,
              1. _result_를 ? Call(_method_, _O_)로 둔다.
              1. _result_가 Object가 아니면 _result_를 반환한다.
          1. *TypeError* 예외를 던진다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toboolean" oldids="table-toboolean-conversions,sec-IsHTMLDDA-internal-slot-to-boolean" type="abstract operation">
      <h1>
        ToBoolean (
          _argument_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 Boolean 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Boolean이면 _argument_를 반환한다.
        1. _argument_가 *undefined*, *null*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *NaN*, *0*<sub>ℤ</sub>, 또는 빈 String 중 하나이면 *false*를 반환한다.
        1. [id="step-to-boolean-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>를 지원하면,
          1. _argument_가 Object이고 [[IsHTMLDDA]] 내부 슬롯을 갖고 있으면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumeric" type="abstract operation">
      <h1>
        ToNumeric (
          _value_: ECMAScript 언어 값,
        ): Number 또는 BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_value_를 Number 또는 BigInt로 변환하여 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _primValue_를 ? ToPrimitive(_value_, ~number~)로 둔다.
        1. _primValue_가 BigInt이면 _primValue_를 반환한다.
        1. ? <emu-meta suppress-effects="user-code">ToNumber(_primValue_)</emu-meta>를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumber" oldids="table-tonumber-conversions" type="abstract operation">
      <h1>
        ToNumber (
          _argument_: ECMAScript 언어 값,
        ): Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 Number 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Number이면 _argument_를 반환한다.
        1. _argument_가 Symbol 또는 BigInt이면 *TypeError* 예외를 던진다.
        1. _argument_가 *undefined*이면 *NaN*을 반환한다.
        1. _argument_가 *null* 또는 *false*이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _argument_가 *true*이면 *1*<sub>𝔽</sub>을 반환한다.
        1. _argument_가 String이면 StringToNumber(_argument_)를 반환한다.
        1. 단언: _argument_는 Object이다.
        1. _primValue_를 ? ToPrimitive(_argument_, ~number~)로 둔다.
        1. 단언: _primValue_는 Object가 아니다.
        1. ? ToNumber(_primValue_)를 반환한다.
      </emu-alg>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>String 타입에 적용된 ToNumber</h1>
        <p>추상 연산 StringToNumber는 다음 문법을 사용하여 String 값을 Number 값으로 변환하는 방법을 지정합니다.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringNumericLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

          StrWhiteSpace :::
            StrWhiteSpaceChar StrWhiteSpace?

          StrWhiteSpaceChar :::
            WhiteSpace
            LineTerminator

          StrNumericLiteral :::
            StrDecimalLiteral
            NonDecimalIntegerLiteral[~Sep]

          StrDecimalLiteral :::
            StrUnsignedDecimalLiteral
            `+` StrUnsignedDecimalLiteral
            `-` StrUnsignedDecimalLiteral

          StrUnsignedDecimalLiteral :::
            `Infinity`
            DecimalDigits[~Sep] `.` DecimalDigits[~Sep]? ExponentPart[~Sep]?
            `.` DecimalDigits[~Sep] ExponentPart[~Sep]?
            DecimalDigits[~Sep] ExponentPart[~Sep]?
        </emu-grammar>
        <p>위에서 명시적으로 정의되지 않은 모든 문법 기호는 숫자 리터럴에 대한 어휘 문법(<emu-xref href="#sec-literals-numeric-literals"></emu-xref>)에서 사용된 정의를 갖습니다.</p>
        <emu-note>
          <p>|StringNumericLiteral|과 |NumericLiteral|의 문법에는 다음과 같은 차이가 있습니다:</p>
          <ul>
            <li>|StringNumericLiteral|은 선행 및/또는 후행 공백 및/또는 줄 종결자를 포함할 수 있습니다.</li>
            <li>십진 |StringNumericLiteral|은 선행 `0` 숫자를 임의 개수 포함할 수 있습니다.</li>
            <li>십진 |StringNumericLiteral|은 부호를 나타내기 위해 `+` 또는 `-`를 포함할 수 있습니다.</li>
            <li>비어 있거나 공백만 포함하는 |StringNumericLiteral|은 *+0*<sub>𝔽</sub>으로 변환됩니다.</li>
            <li>`Infinity` 및 `-Infinity`는 |StringNumericLiteral|로 인식되지만 |NumericLiteral|로는 인식되지 않습니다.</li>
            <li>|StringNumericLiteral|은 |BigIntLiteralSuffix|를 포함할 수 없습니다.</li>
            <li>|StringNumericLiteral|은 |NumericLiteralSeparator|를 포함할 수 없습니다.</li>
          </ul>
        </emu-note>

        <emu-clause id="sec-stringtonumber" type="abstract operation">
          <h1>
            StringToNumber (
              _str_: String,
            ): Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _literal_을 ParseText(_str_, |StringNumericLiteral|)로 둔다.
            1. _literal_이 오류들의 List이면 *NaN*을 반환한다.
            1. _literal_의 StringNumericValue를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-stringnumericvalue" type="sdo" oldids="sec-runtime-semantics-mv-s">
          <h1>런타임 의미론: StringNumericValue ( ): Number</h1>
          <dl class="header">
          </dl>
          <emu-note>
            <p>|StringNumericLiteral|을 Number 값으로 변환하는 과정은 전반적으로 |NumericLiteral|의 NumericValue 결정(<emu-xref href="#sec-literals-numeric-literals"></emu-xref>)과 유사하지만 일부 세부 사항은 다릅니다.</p>
          </emu-note>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. *+0*<sub>𝔽</sub>을 반환한다.
          </emu-alg>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. |StrNumericLiteral|의 StringNumericValue를 반환한다.
          </emu-alg>
          <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
          <emu-alg>
            1. 𝔽(MV of |NonDecimalIntegerLiteral|)을 반환한다.
          </emu-alg>
          <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
          <emu-alg>
            1. _a_를 |StrUnsignedDecimalLiteral|의 StringNumericValue로 둔다.
            1. _a_가 *+0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub>을 반환한다.
            1. -_a_를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
          <emu-alg>
            1. *+∞*<sub>𝔽</sub>를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
          <emu-alg>
            1. _a_를 첫 번째 |DecimalDigits|의 MV로 둔다.
            1. 두 번째 |DecimalDigits|가 존재하면,
              1. _b_를 두 번째 |DecimalDigits|의 MV로 둔다.
              1. _n_을 두 번째 |DecimalDigits|의 코드 포인트 수로 둔다.
            1. Else,
              1. _b_를 0으로 둔다.
              1. _n_을 0으로 둔다.
            1. |ExponentPart|가 존재하면 _e_를 |ExponentPart|의 MV로, 아니면 _e_를 0으로 둔다.
            1. RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>)를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. _b_를 |DecimalDigits|의 MV로 둔다.
            1. |ExponentPart|가 존재하면 _e_를 |ExponentPart|의 MV로, 아니면 _e_를 0으로 둔다.
            1. _n_을 |DecimalDigits|의 코드 포인트 수로 둔다.
            1. RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>)를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. _a_를 |DecimalDigits|의 MV로 둔다.
            1. |ExponentPart|가 존재하면 _e_를 |ExponentPart|의 MV로, 아니면 _e_를 0으로 둔다.
            1. RoundMVResult(_a_ × 10<sup>_e_</sup>)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-roundmvresult" type="abstract operation">
          <h1>
            RoundMVResult (
              _n_: 수학적 값,
            ): Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>구현 정의 방식으로 _n_을 Number로 변환합니다. 이 추상 연산의 목적상, 어떤 자릿수가 0이 아니거나 그 왼쪽에 0이 아닌 자릿수가 있고 오른쪽에 0이 아닌 자릿수가 있는 경우 유효 자릿수입니다. 또한 “수학적 값을 나타내는 표현”의 수학적 값은 “수학적 값의 10진 표현”의 역입니다.</dd>
          </dl>
          <emu-alg>
            1. _n_의 10진 표현이 20개 이하의 유효 자릿수를 가지면 𝔽(_n_)을 반환한다.
            1. _option1_을: _n_의 10진 표현에서 20번째 이후 모든 유효 자릿수를 0으로 대체한 결과가 나타내는 수학적 값으로 둔다.
            1. _option2_를: _n_의 10진 표현에서 20번째 이후 모든 유효 자릿수를 0으로 대체한 다음 20번째 위치를 (필요한 자리 올림과 함께) 1 증가시킨 결과가 나타내는 수학적 값으로 둔다.
            1. _chosen_을 구현 정의로 _option1_ 또는 _option2_ 중 하나로 둔다.
            1. 𝔽(_chosen_)을 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tointegerorinfinity" type="abstract operation" oldids="sec-tointeger">
      <h1>
        ToIntegerOrInfinity (
          _argument_: ECMAScript 언어 값,
        ): 정수, +&infin; 또는 -&infin; 중 하나를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 그 Number 값에서 소수 부분을 절단한 정수로, 혹은 그 Number 값이 무한대일 경우 +∞ 또는 -∞로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 0을 반환한다.
        1. _number_가 *+∞*<sub>𝔽</sub>이면 +∞를 반환한다.
        1. _number_가 *-∞*<sub>𝔽</sub>이면 -∞를 반환한다.
        1. truncate(ℝ(_number_))를 반환한다.
      </emu-alg>
      <emu-note>
        𝔽(ToIntegerOrInfinity(_x_))는 어떤 _x_에 대해서도 *-0*<sub>𝔽</sub>을 반환하지 않습니다. 소수 부분 절단은 _x_를 수학적 값으로 변환한 후 수행됩니다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint32" type="abstract operation">
      <h1>
        ToInt32 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 𝔽(-2<sup>31</sup>)부터 𝔽(2<sup>31</sup> - 1)까지(포함) 2<sup>32</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int32bit_를 _int_ modulo 2<sup>32</sup>로 둔다.
        1. _int32bit_ ≥ 2<sup>31</sup>이면 𝔽(_int32bit_ - 2<sup>32</sup>)을, 아니면 𝔽(_int32bit_)을 반환한다.
      </emu-alg>
      <emu-note>
        <p>위 정의에 따른 ToInt32의 성질:</p>
        <ul>
          <li>ToInt32 추상 연산은 멱등성: 자신의 결과에 다시 적용해도 값은 변하지 않습니다.</li>
          <li>모든 _x_에 대해 ToInt32(ToUint32(_x_))는 ToInt32(_x_)와 동일한 값입니다. (이 후속 성질을 보존하기 위해 *+∞*<sub>𝔽</sub>와 *-∞*<sub>𝔽</sub>이 *+0*<sub>𝔽</sub>으로 매핑됩니다.)</li>
          <li>ToInt32는 *-0*<sub>𝔽</sub>을 *+0*<sub>𝔽</sub>으로 매핑합니다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-touint32" type="abstract operation">
      <h1>
        ToUint32 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>32</sup> - 1)까지(포함) 2<sup>32</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int32bit_를 _int_ modulo 2<sup>32</sup>로 둔다.
        1. [id="step-touint32-return"] 𝔽(_int32bit_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>위 정의에 따른 ToUint32의 성질:</p>
        <ul>
          <li><emu-xref href="#step-touint32-return"></emu-xref> 단계가 ToUint32와 ToInt32의 유일한 차이점입니다.</li>
          <li>ToUint32 추상 연산은 멱등성입니다.</li>
          <li>모든 _x_에 대해 ToUint32(ToInt32(_x_))는 ToUint32(_x_)와 동일합니다. (*+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub>이 *+0*<sub>𝔽</sub>으로 매핑되는 이유.)</li>
          <li>ToUint32는 *-0*<sub>𝔽</sub>을 *+0*<sub>𝔽</sub>으로 매핑합니다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint16" type="abstract operation">
      <h1>
        ToInt16 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 𝔽(-2<sup>15</sup>)부터 𝔽(2<sup>15</sup> - 1)까지(포함) 2<sup>16</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int16bit_를 _int_ modulo 2<sup>16</sup>으로 둔다.
        1. _int16bit_ ≥ 2<sup>15</sup>이면 𝔽(_int16bit_ - 2<sup>16</sup>)을, 아니면 𝔽(_int16bit_)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint16" type="abstract operation">
      <h1>
        ToUint16 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>16</sup> - 1)까지(포함) 2<sup>16</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. [id="step-touint16-mod"] _int16bit_를 _int_ modulo 2<sup>16</sup>으로 둔다.
        1. 𝔽(_int16bit_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>위 정의에 따른 ToUint16의 성질:</p>
        <ul>
          <li><emu-xref href="#step-touint16-mod"></emu-xref> 단계에서 2<sup>16</sup>을 2<sup>32</sup> 대신 사용하는 점이 ToUint32와 ToUint16의 유일한 차이입니다.</li>
          <li>ToUint16은 *-0*<sub>𝔽</sub>을 *+0*<sub>𝔽</sub>으로 매핑합니다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint8" type="abstract operation">
      <h1>
        ToInt8 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *-128*<sub>𝔽</sub>에서 *127*<sub>𝔽</sub>까지(포함) 2<sup>8</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int8bit_를 _int_ modulo 2<sup>8</sup>로 둔다.
        1. _int8bit_ ≥ 2<sup>7</sup>이면 𝔽(_int8bit_ - 2<sup>8</sup>)을, 아니면 𝔽(_int8bit_)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8" type="abstract operation">
      <h1>
        ToUint8 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 *255*<sub>𝔽</sub>까지(포함) 2<sup>8</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int8bit_를 _int_ modulo 2<sup>8</sup>로 둔다.
        1. 𝔽(_int8bit_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8clamp" type="abstract operation">
      <h1>
        ToUint8Clamp (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 *255*<sub>𝔽</sub>까지(포함) 2<sup>8</sup>개의 적분 Number 값 중 하나로 클램프(clamp)하고 반올림합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 *NaN*이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _mv_를 _number_의 확장된 수학적 값으로 둔다.
        1. _clamped_를 _mv_를 0과 255 사이로 클램프한 결과로 둔다.
        1. _f_를 floor(_clamped_)로 둔다.
        1. _clamped_ &lt; _f_ + 0.5이면 𝔽(_f_)를 반환한다.
        1. _clamped_ > _f_ + 0.5이면 𝔽(_f_ + 1)을 반환한다.
        1. _f_가 짝수이면 𝔽(_f_)를; 아니면 𝔽(_f_ + 1)을 반환한다.
      </emu-alg>
      <emu-note>
        <p>대부분 다른 ECMAScript 정수 변환 연산과 달리 ToUint8Clamp는 비정수 값을 절단(truncate)하지 않고 반올림합니다. 또한 “round half up”을 사용하는 <emu-xref href="#sec-math.round">`Math.round`</emu-xref>와 달리 “round half to even” 절충 규칙을 사용합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-tobigint" type="abstract operation">
      <h1>
        ToBigInt (
          _argument_: ECMAScript 언어 값,
        ): BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 BigInt 값으로 변환하며, Number에서의 암시적 변환이 필요하다면 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _prim_을 ? ToPrimitive(_argument_, ~number~)로 둔다.
        1. <emu-xref href="#table-tobigint"></emu-xref>의 _prim_이 대응하는 값을 반환한다.
      </emu-alg>
      <emu-table id="table-tobigint" caption="BigInt 변환">
        <table>
          <thead>
            <tr>
              <th>
                Argument 타입
              </th>
              <th>
                결과
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              _prim_이 *true*이면 `1n`, *false*이면 `0n`을 반환한다.
            </td>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              _prim_을 반환한다.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              <emu-alg>
                1. _n_을 StringToBigInt(_prim_)로 둔다.
                1. _n_이 *undefined*이면 *SyntaxError* 예외를 던진다.
                1. _n_을 반환한다.
              </emu-alg>
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-stringtobigint" type="abstract operation">
      <h1>
        StringToBigInt (
          _str_: String,
        ): BigInt 또는 *undefined*
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _literal_을 ParseText(_str_, |StringIntegerLiteral|)로 둔다.
        1. _literal_이 오류들의 List이면 *undefined*를 반환한다.
        1. _mv_를 _literal_의 MV로 둔다.
        1. 단언: _mv_는 정수이다.
        1. ℤ(_mv_)를 반환한다.
      </emu-alg>

      <emu-clause id="sec-stringintegerliteral-grammar">
        <h1>StringIntegerLiteral 문법</h1>
        <p>StringToBigInt는 다음 문법을 사용합니다.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringIntegerLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?

          StrIntegerLiteral :::
            SignedInteger[~Sep]
            NonDecimalIntegerLiteral[~Sep]
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-mv-for-stringintegerliteral">
        <h1>런타임 의미론: MV</h1>
        <ul>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace?</emu-grammar>의 MV는 0이다.
          </li>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?</emu-grammar>의 MV는 |StrIntegerLiteral|의 MV이다.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tobigint64" type="abstract operation">
      <h1>
        ToBigInt64 (
          _argument_: ECMAScript 언어 값,
        ): BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 ℤ(-2<sup>63</sup>)부터 ℤ(2<sup>63</sup> - 1)까지(포함) 2<sup>64</sup>개의 BigInt 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _n_을 ? ToBigInt(_argument_)로 둔다.
        1. _int64bit_를 ℝ(_n_) modulo 2<sup>64</sup>로 둔다.
        1. _int64bit_ ≥ 2<sup>63</sup>이면 ℤ(_int64bit_ - 2<sup>64</sup>)을, 아니면 ℤ(_int64bit_)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tobiguint64" type="abstract operation">
      <h1>
        ToBigUint64 (
          _argument_: ECMAScript 언어 값,
        ): BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *0*<sub>ℤ</sub>에서 ℤ(2<sup>64</sup> - 1)까지(포함) 2<sup>64</sup>개의 BigInt 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _n_을 ? ToBigInt(_argument_)로 둔다.
        1. _int64bit_를 ℝ(_n_) modulo 2<sup>64</sup>로 둔다.
        1. ℤ(_int64bit_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tostring" oldids="table-tostring-conversions" type="abstract operation">
      <h1>
        ToString (
          _argument_: ECMAScript 언어 값,
        ): String을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 String 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 String이면 _argument_를 반환한다.
        1. _argument_가 Symbol이면 *TypeError* 예외를 던진다.
        1. _argument_가 *undefined*이면 *"undefined"*를 반환한다.
        1. _argument_가 *null*이면 *"null"*을 반환한다.
        1. _argument_가 *true*이면 *"true"*를 반환한다.
        1. _argument_가 *false*이면 *"false"*를 반환한다.
        1. _argument_가 Number이면 Number::toString(_argument_, 10)을 반환한다.
        1. _argument_가 BigInt이면 BigInt::toString(_argument_, 10)을 반환한다.
        1. 단언: _argument_는 Object이다.
        1. _primValue_를 ? ToPrimitive(_argument_, ~string~)으로 둔다.
        1. 단언: _primValue_는 Object가 아니다.
        1. ? ToString(_primValue_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-toobject" type="abstract operation" oldids="table-toobject-conversions,table-13">
      <h1>
        ToObject (
          _argument_: ECMAScript 언어 값,
        ): Object를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 Object 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 *undefined* 또는 *null*이면 *TypeError* 예외를 던진다.
        1. _argument_가 Boolean이면 [[BooleanData]] 내부 슬롯이 _argument_로 설정된 새 Boolean 객체를 반환한다. Boolean 객체 설명은 <emu-xref href="#sec-boolean-objects"></emu-xref> 참조.
        1. _argument_가 Number이면 [[NumberData]] 내부 슬롯이 _argument_로 설정된 새 Number 객체를 반환한다. Number 객체 설명은 <emu-xref href="#sec-number-objects"></emu-xref> 참조.
        1. _argument_가 String이면 [[StringData]] 내부 슬롯이 _argument_로 설정된 새 String 객체를 반환한다. String 객체 설명은 <emu-xref href="#sec-string-objects"></emu-xref> 참조.
        1. _argument_가 Symbol이면 [[SymbolData]] 내부 슬롯이 _argument_로 설정된 새 Symbol 객체를 반환한다. Symbol 객체 설명은 <emu-xref href="#sec-symbol-objects"></emu-xref> 참조.
        1. _argument_가 BigInt이면 [[BigIntData]] 내부 슬롯이 _argument_로 설정된 새 BigInt 객체를 반환한다. BigInt 객체 설명은 <emu-xref href="#sec-bigint-objects"></emu-xref> 참조.
        1. 단언: _argument_는 Object이다.
        1. _argument_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-topropertykey" type="abstract operation">
      <h1>
        ToPropertyKey (
          _argument_: ECMAScript 언어 값,
        ): 프로퍼티 키를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 프로퍼티 키로 사용할 수 있는 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _key_를 ? ToPrimitive(_argument_, ~string~)으로 둔다.
        1. _key_가 Symbol이면
          1. _key_를 반환한다.
        1. ! ToString(_key_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolength" type="abstract operation">
      <h1>
        ToLength (
          _argument_: ECMAScript 언어 값,
        ): 음이 아닌 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 배열 유사 객체의 length로 사용 가능하도록 음이 아닌 적분 Number로 클램프(clamp) 및 절단(truncate)합니다.</dd>
      </dl>
      <emu-alg>
        1. _len_을 ? ToIntegerOrInfinity(_argument_)로 둔다.
        1. _len_ ≤ 0이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. 𝔽(min(_len_, 2<sup>53</sup> - 1))을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalnumericindexstring" type="abstract operation">
      <h1>
        CanonicalNumericIndexString (
          _argument_: String,
        ): Number 또는 *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 *"-0"*이거나 어떤 Number 값 _n_에 대해 ToString(_n_)과 정확히 일치하면 해당 Number 값을 반환합니다. 그렇지 않으면 *undefined*를 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 *"-0"*이면 *-0*<sub>𝔽</sub>을 반환한다.
        1. _n_을 ! ToNumber(_argument_)로 둔다.
        1. ! ToString(_n_)이 _argument_이면 _n_을 반환한다.
        1. *undefined*를 반환한다.
      </emu-alg>
      <p><dfn variants="canonical numeric strings">canonical numeric string</dfn>은 CanonicalNumericIndexString 추상 연산이 *undefined*를 반환하지 않는 모든 String입니다.</p>
    </emu-clause>

    <emu-clause id="sec-toindex" type="abstract operation">
      <h1>
        ToIndex (
          _value_: ECMAScript 언어 값,
        ): 음이 아닌 정수를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_value_를 정수로 변환하고, 그 정수가 음이 아니며 정수 인덱스에 대응되면 그 정수를 반환합니다. 그렇지 않으면 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _integer_를 ? ToIntegerOrInfinity(_value_)로 둔다.
        1. _integer_가 0에서 2<sup>53</sup> - 1 (포함) 사이에 없으면 *RangeError* 예외를 던진다.
        1. _integer_를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>테스트 및 비교 연산(Testing and Comparison Operations)</h1>

    <emu-clause id="sec-requireobjectcoercible" type="abstract operation" oldids="table-requireobjectcoercible-results,table-14">
      <h1>
        RequireObjectCoercible (
          _argument_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 ToObject로 Object로 변환될 수 없는 값이면 에러를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 *undefined* 또는 *null*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isarray" type="abstract operation">
      <h1>
        IsArray (
          _argument_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _argument_가 Array 이국 객체이면 *true*를 반환한다.
        1. _argument_가 Proxy 이국 객체이면,
          1. ? ValidateNonRevokedProxy(_argument_)를 수행한다.
          1. _proxyTarget_을 _argument_.[[ProxyTarget]]으로 둔다.
          1. ? IsArray(_proxyTarget_)을 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iscallable" type="abstract operation">
      <h1>
        IsCallable (
          _argument_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 [[Call]] 내부 메소드를 가진 호출 가능 함수인지 결정합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _argument_가 [[Call]] 내부 메소드를 가지면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isconstructor" type="abstract operation">
      <h1>
        IsConstructor (
          _argument_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 [[Construct]] 내부 메소드를 가진 함수 객체인지 결정합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _argument_가 [[Construct]] 내부 메소드를 가지면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isextensible-o" type="abstract operation">
      <h1>
        IsExtensible (
          _O_: Object,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_에 추가 프로퍼티를 더할 수 있는지 결정하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[IsExtensible]]</emu-meta>()를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isregexp" type="abstract operation">
      <h1>
        IsRegExp (
          _argument_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _matcher_를 ? Get(_argument_, %Symbol.match%)로 둔다.
        1. _matcher_가 *undefined*가 아니면 ToBoolean(_matcher_)를 반환한다.
        1. _argument_가 [[RegExpMatcher]] 내부 슬롯을 가지면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstringwellformedunicode" type="abstract operation">
      <h1>
        Static Semantics: IsStringWellFormedUnicode (
          _string_: String,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd><emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>에 설명된 대로 _string_을 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하고 이것이 <a href="http://www.unicode.org/glossary/#well_formed_code_unit_sequence">well formed</a> UTF-16 시퀀스인지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. _len_을 _string_의 길이로 둔다.
        1. _k_를 0으로 둔다.
        1. _k_ &lt; _len_ 동안 반복,
          1. _cp_를 CodePointAt(_string_, _k_)로 둔다.
          1. _cp_.[[IsUnpairedSurrogate]]가 *true*이면 *false*를 반환한다.
          1. _k_를 _k_ + _cp_.[[CodeUnitCount]]로 둔다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sametype" type="abstract operation">
      <h1>
        SameType (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>두 인수가 같은 타입인지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. _x_가 *undefined*이고 _y_가 *undefined*이면 *true*를 반환한다.
        1. _x_가 *null*이고 _y_가 *null*이면 *true*를 반환한다.
        1. _x_가 Boolean이고 _y_가 Boolean이면 *true*를 반환한다.
        1. _x_가 Number이고 _y_가 Number이면 *true*를 반환한다.
        1. _x_가 BigInt이고 _y_가 BigInt이면 *true*를 반환한다.
        1. _x_가 Symbol이고 _y_가 Symbol이면 *true*를 반환한다.
        1. _x_가 String이고 _y_가 String이면 *true*를 반환한다.
        1. _x_가 Object이고 _y_가 Object이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-samevalue" type="abstract operation">
      <h1>
        SameValue (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>두 인수가 같은 값인지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *false*이면 *false*를 반환한다.
        1. _x_가 Number이면,
          1. Number::sameValue(_x_, _y_)를 반환한다.
        1. SameValueNonNumber(_x_, _y_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 알고리즘은 모든 *NaN* 값을 동등하게 취급하고 *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>을 구분한다는 점에서 IsStrictlyEqual 알고리즘과 다릅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluezero" type="abstract operation">
      <h1>
        SameValueZero (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>두 인수가 같은 값인지 ( *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>의 차이를 무시하고 ) 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *false*이면 *false*를 반환한다.
        1. _x_가 Number이면,
          1. Number::sameValueZero(_x_, _y_)를 반환한다.
        1. SameValueNonNumber(_x_, _y_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>SameValueZero는 *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>을 동일하게 취급한다는 점만 SameValue와 다릅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" type="abstract operation" oldids="sec-samevaluenonnumeric">
      <h1>
        SameValueNonNumber (
          _x_: Number가 아닌 ECMAScript 언어 값,
          _y_: Number가 아닌 ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 단언: SameType(_x_, _y_)는 *true*이다.
        1. _x_가 *undefined* 또는 *null*이면 *true*를 반환한다.
        1. _x_가 BigInt이면
          1. BigInt::equal(_x_, _y_)를 반환한다.
        1. _x_가 String이면
          1. _x_와 _y_가 동일 길이이며 같은 위치에 동일 코드 유닛을 가지면 *true*, 아니면 *false*를 반환한다.
        1. _x_가 Boolean이면
          1. _x_와 _y_가 모두 *true* 또는 모두 *false*이면 *true*, 아니면 *false*를 반환한다.
        1. 주: 다른 모든 ECMAScript 언어 값은 동일성(identity)으로 비교된다.
        1. _x_가 _y_이면 *true*, 아니면 *false*를 반환한다.
      </emu-alg>
      <emu-note>
        설명을 위해 일부 경우는 필요 없더라도 별도로 다룹니다.
      </emu-note>
      <emu-note>
        "_x_ is _y_"의 구체적 의미는 <emu-xref href="#sec-identity"></emu-xref>에 자세히 있습니다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islessthan" type="abstract operation" oldids="sec-abstract-relational-comparison">
      <h1>
        IsLessThan (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
          _LeftFirst_: Boolean,
        ): Boolean 또는 *undefined*를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_x_ &lt; _y_ 비교의 의미론을 제공하며, *true*, *false*, 또는 (적어도 한 피연산자가 *NaN*임을 나타내는) *undefined*를 반환합니다. _LeftFirst_ 플래그는 _x_, _y_에 잠재적으로 부작용 있는 연산의 순서를 제어합니다. 이는 ECMAScript가 표현식을 좌→우로 평가하도록 규정하기 때문에 필요합니다. _LeftFirst_가 *true*이면 _x_ 매개변수는 _y_ 매개변수 표현식의 왼쪽에 오는 표현식에 해당합니다. *false*이면 반대이며 연산은 _x_ 이전에 _y_에 수행되어야 합니다.</dd>
      </dl>
      <emu-alg>
        1. _LeftFirst_가 *true*이면,
          1. _px_를 ? ToPrimitive(_x_, ~number~)로 둔다.
          1. _py_를 ? ToPrimitive(_y_, ~number~)로 둔다.
        1. Else,
          1. 주: 좌→우 평가를 보존하기 위해 평가 순서를 반전해야 한다.
          1. _py_를 ? ToPrimitive(_y_, ~number~)로 둔다.
          1. _px_를 ? ToPrimitive(_x_, ~number~)로 둔다.
        1. [id="step-arc-string-check"] _px_가 String이고 _py_가 String이면,
          1. _lx_를 _px_의 길이로 둔다.
          1. _ly_를 _py_의 길이로 둔다.
          1. 0 ≤ _i_ &lt; min(_lx_, _ly_)인 각 정수 _i_에 대해 오름차순으로,
            1. _cx_를 _px_의 인덱스 _i_ 위치 코드 유닛의 숫자 값으로 둔다.
            1. _cy_를 _py_의 인덱스 _i_ 위치 코드 유닛의 숫자 값으로 둔다.
            1. _cx_ &lt; _cy_이면 *true*를 반환한다.
            1. _cx_ > _cy_이면 *false*를 반환한다.
          1. _lx_ &lt; _ly_이면 *true*, 아니면 *false*를 반환한다.
        1. Else,
          1. _px_가 BigInt이고 _py_가 String이면,
            1. _ny_를 StringToBigInt(_py_)로 둔다.
            1. _ny_가 *undefined*이면 *undefined*를 반환한다.
            1. BigInt::lessThan(_px_, _ny_)를 반환한다.
          1. _px_가 String이고 _py_가 BigInt이면,
            1. _nx_를 StringToBigInt(_px_)로 둔다.
            1. _nx_가 *undefined*이면 *undefined*를 반환한다.
            1. BigInt::lessThan(_nx_, _py_)를 반환한다.
          1. 주: _px_, _py_는 원시 값이므로 평가 순서는 중요하지 않다.
          1. _nx_를 ? <emu-meta suppress-effects="user-code">ToNumeric(_px_)</emu-meta>로 둔다.
          1. _ny_를 ? <emu-meta suppress-effects="user-code">ToNumeric(_py_)</emu-meta>로 둔다.
          1. SameType(_nx_, _ny_)가 *true*이면,
            1. _nx_가 Number이면
              1. Number::lessThan(_nx_, _ny_)를 반환한다.
            1. Else,
              1. 단언: _nx_는 BigInt이다.
              1. BigInt::lessThan(_nx_, _ny_)를 반환한다.
          1. 단언: _nx_는 BigInt이고 _ny_는 Number, 또는 _nx_는 Number이고 _ny_는 BigInt.
          1. _nx_ 또는 _ny_가 *NaN*이면 *undefined*를 반환한다.
          1. _nx_가 *-∞*<sub>𝔽</sub>이거나 _ny_가 *+∞*<sub>𝔽</sub>이면 *true*를 반환한다.
          1. _nx_가 *+∞*<sub>𝔽</sub>이거나 _ny_가 *-∞*<sub>𝔽</sub>이면 *false*를 반환한다.
          1. ℝ(_nx_) &lt; ℝ(_ny_)이면 *true*, 아니면 *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-arc-string-check"></emu-xref> 단계는 덧셈 연산자 `+`를 처리하는 알고리즘(<emu-xref href="#sec-applystringornumericbinaryoperator"></emu-xref>)의 <emu-xref href="#step-binary-op-string-check"></emu-xref> 단계와 논리 OR 대신 논리 AND를 사용하는 점에서 다릅니다.</p>
      </emu-note>
      <emu-note>
        <p>String 비교는 UTF-16 코드 유닛 값 시퀀스에 대한 단순한 사전식(lexicographic) 순서를 사용합니다. Unicode 명세에서 정의한 더 복잡하고 의미론 지향적인 문자/문자열 동등성이나 정렬 순서를 사용하려 하지 않습니다. 따라서 Unicode 표준에 따라 정규적으로 동등하지만 정규화 형태가 다른 String 값은 불일치로 판정될 수 있습니다. 또한 surrogate pair를 포함한 String의 경우 코드 유닛 기반 사전식 순서는 코드 포인트 기반 순서와 다를 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islooselyequal" type="abstract operation" oldids="sec-abstract-equality-comparison,sec-IsHTMLDDA-internal-slot-aec">
      <h1>
        IsLooselyEqual (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`==` 연산자의 의미론을 제공합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *true*이면,
          1. IsStrictlyEqual(_x_, _y_)를 반환한다.
        1. _x_가 *null*이고 _y_가 *undefined*이면 *true*를 반환한다.
        1. _x_가 *undefined*이고 _y_가 *null*이면 *true*를 반환한다.
        1. [id="step-abstract-equality-comparison-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>를 지원하면,
          1. _x_가 Object이고 _x_가 [[IsHTMLDDA]] 내부 슬롯을 가지며 _y_가 *undefined* 또는 *null*이면 *true*를 반환한다.
          1. _x_가 *undefined* 또는 *null*이고 _y_가 Object이며 _y_가 [[IsHTMLDDA]] 내부 슬롯을 가지면 *true*를 반환한다.
        1. _x_가 Number이고 _y_가 String이면 ! IsLooselyEqual(_x_, ! ToNumber(_y_))를 반환한다.
        1. _x_가 String이고 _y_가 Number이면 ! IsLooselyEqual(! ToNumber(_x_), _y_)를 반환한다.
        1. _x_가 BigInt이고 _y_가 String이면,
          1. _n_을 StringToBigInt(_y_)로 둔다.
          1. _n_이 *undefined*이면 *false*를 반환한다.
          1. ! IsLooselyEqual(_x_, _n_)을 반환한다.
        1. _x_가 String이고 _y_가 BigInt이면 ! IsLooselyEqual(_y_, _x_)를 반환한다.
        1. _x_가 Boolean이면 ! IsLooselyEqual(! ToNumber(_x_), _y_)를 반환한다.
        1. _y_가 Boolean이면 ! IsLooselyEqual(_x_, ! ToNumber(_y_))를 반환한다.
        1. _x_가 String, Number, BigInt, Symbol 중 하나이고 _y_가 Object이면 ! IsLooselyEqual(_x_, ? ToPrimitive(_y_))를 반환한다.
        1. _x_가 Object이고 _y_가 String, Number, BigInt, Symbol 중 하나이면 ! IsLooselyEqual(? ToPrimitive(_x_), _y_)를 반환한다.
        1. _x_가 BigInt이고 _y_가 Number이거나 _x_가 Number이고 _y_가 BigInt이면,
          1. _x_ 또는 _y_가 유한이 아니면 *false*를 반환한다.
          1. ℝ(_x_) = ℝ(_y_)이면 *true*, 아니면 *false*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstrictlyequal" type="abstract operation" oldids="sec-strict-equality-comparison">
      <h1>
        IsStrictlyEqual (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`===` 연산자의 의미론을 제공합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *false*이면 *false*를 반환한다.
        1. _x_가 Number이면,
          1. Number::equal(_x_, _y_)를 반환한다.
        1. SameValueNonNumber(_x_, _y_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 알고리즘은 부호 있는 0 및 NaN 처리에서 SameValue 알고리즘과 다릅니다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-objects">
    <h1>객체에 대한 연산(Operations on Objects)</h1>

    <emu-clause id="sec-makebasicobject" type="abstract operation">
      <h1>
        MakeBasicObject (
          _internalSlotsList_: 내부 슬롯 이름들의 List,
        ): Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>알고리즘적으로 생성되는 모든 ECMAScript 객체(ordinary 및 exotic 포함)의 근원입니다. 모든 객체 생성에서 사용되는 공통 단계를 분리하고 객체 생성을 중앙화합니다.</dd>
      </dl>

      <emu-alg>
        1. _internalSlotsList_를 _internalSlotsList_와 « [[PrivateElements]] »의 list-concatenation으로 설정한다.
        1. _internalSlotsList_의 각 이름에 대한 내부 슬롯을 가진 새로 생성된 객체 _obj_를 둔다.
        1. 주: <emu-xref href="#sec-object-internal-methods-and-internal-slots" title></emu-xref>에 설명된 대로 달리 지정되지 않으면 각 내부 슬롯의 초기값은 *undefined*이다.
        1. _obj_.[[PrivateElements]]를 새 빈 List로 둔다.
        1. _obj_의 essential 내부 메소드를 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>에 지정된 기본 ordinary object 정의로 설정한다.
        1. 단언: 호출자가 _obj_의 [[GetPrototypeOf]]와 [[SetPrototypeOf]] essential 내부 메소드를 모두 재정의하지 않을 경우 _internalSlotsList_는 [[Prototype]]을 포함한다.
        1. 단언: 호출자가 _obj_의 [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]] essential 내부 메소드를 모두 재정의하지 않을 경우 _internalSlotsList_는 [[Extensible]]을 포함한다.
        1. _internalSlotsList_가 [[Extensible]]을 포함하면 _obj_.[[Extensible]]를 *true*로 둔다.
        1. _obj_를 반환한다.
      </emu-alg>

      <emu-note>
        <p>이 명세 내에서 exotic 객체는 ArrayCreate, BoundFunctionCreate 같은 추상 연산에서 먼저 MakeBasicObject를 호출하여 기본 객체를 얻고 그 후 그 객체의 일부 또는 모든 내부 메소드를 재정의하여 생성됩니다. exotic 객체 생성을 캡슐화하기 위해 객체의 essential 내부 메소드는 그러한 연산 외부에서는 수정되지 않습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-o-p" type="abstract operation">
      <h1>
        Get (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 특정 프로퍼티 값을 가져오는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _O_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getv" type="abstract operation">
      <h1>
        GetV (
          _V_: ECMAScript 언어 값,
          _P_: 프로퍼티 키,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ECMAScript 언어 값의 특정 프로퍼티 값을 가져오는 데 사용됩니다. 값이 객체가 아니면 해당 타입에 적합한 래퍼 객체를 사용하여 프로퍼티 조회가 수행됩니다.</dd>
      </dl>
      <emu-alg>
        1. _O_를 ? ToObject(_V_)로 둔다.
        1. ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _V_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-set-o-p-v-throw" type="abstract operation">
      <h1>
        Set (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
          _Throw_: Boolean,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 특정 프로퍼티 값을 설정하는 데 사용됩니다. _V_는 프로퍼티의 새 값입니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? <emu-meta effects="user-code">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_)로 둔다.
        1. _success_가 *false*이고 _Throw_가 *true*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdataproperty" type="abstract operation">
      <h1>
        CreateDataProperty (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 새로운 own 프로퍼티를 생성하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _newDesc_를 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }로 둔다.
        1. ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 추상 연산은 ECMAScript 대입 연산자가 생성하는 프로퍼티와 동일 기본 속성 값을 가진 프로퍼티를 생성합니다. 일반적으로 프로퍼티는 미존재 상태입니다. 존재하고 비구성이거나 _O_가 비확장 가능이면 [[DefineOwnProperty]]는 *false*를 반환합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createdatapropertyorthrow" type="abstract operation">
      <h1>
        CreateDataPropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 새로운 own 프로퍼티를 생성하는 데 사용되며, 요청된 프로퍼티 갱신이 수행될 수 없으면 *TypeError* 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? CreateDataProperty(_O_, _P_, _V_)로 둔다.
        1. _success_가 *false*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 추상 연산은 ECMAScript 대입 연산자가 생성하는 프로퍼티와 동일 기본 속성을 가지는 프로퍼티를 생성합니다. 일반적으로 프로퍼티는 미존재 상태입니다. 존재하고 비구성이거나 _O_가 비확장 가능이면 [[DefineOwnProperty]]는 *false*를 반환하여 이 연산이 *TypeError*를 던지게 됩니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createnonenumerabledatapropertyorthrow" type="abstract operation">
      <h1>
        CreateNonEnumerableDataPropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ordinary 객체의 새 비열거 own 프로퍼티를 생성하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _O_는 비구성 프로퍼티가 없는 ordinary, 확장 가능한 객체이다.
        1. _newDesc_를 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }로 둔다.
        1. ! DefinePropertyOrThrow(_O_, _P_, _newDesc_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 추상 연산은 ECMAScript 대입 연산자가 생성하는 프로퍼티와 동일 기본 속성을 가지되 열거 가능하지 않은 프로퍼티를 생성합니다. 일반적으로 프로퍼티는 미존재 상태입니다. 존재하는 경우 DefinePropertyOrThrow는 정상적으로 완료됨이 보장됩니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-definepropertyorthrow" type="abstract operation">
      <h1>
        DefinePropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
          _desc_: Property Descriptor,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 [[DefineOwnProperty]] 내부 메소드를 호출하되, 요청된 프로퍼티 갱신이 수행될 수 없으면 *TypeError* 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_)로 둔다.
        1. _success_가 *false*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-deletepropertyorthrow" type="abstract operation">
      <h1>
        DeletePropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 특정 own 프로퍼티를 제거하는 데 사용됩니다. 프로퍼티가 비구성이면 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? <emu-meta effects="user-code">_O_.[[Delete]]</emu-meta>(_P_)로 둔다.
        1. _success_가 *false*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getmethod" type="abstract operation">
      <h1>
        GetMethod (
          _V_: ECMAScript 언어 값,
          _P_: 프로퍼티 키,
        ): 함수 객체 또는 *undefined*를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>프로퍼티 값이 함수일 것으로 기대되는 ECMAScript 언어 값의 특정 프로퍼티 값을 얻는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _func_을 ? GetV(_V_, _P_)로 둔다.
        1. _func_이 *undefined* 또는 *null*이면 *undefined*를 반환한다.
        1. IsCallable(_func_)가 *false*이면 *TypeError* 예외를 던진다.
        1. _func_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasproperty" type="abstract operation">
      <h1>
        HasProperty (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체가 지정된 프로퍼티 키를 가진 프로퍼티(own 또는 상속)를 갖는지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[HasProperty]]</emu-meta>(_P_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasownproperty" type="abstract operation">
      <h1>
        HasOwnProperty (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체가 지정된 프로퍼티 키를 가진 own 프로퍼티를 갖는지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. _desc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)로 둔다.
        1. _desc_가 *undefined*이면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-call" type="abstract operation">
      <h1>
        Call (
          _F_: ECMAScript 언어 값,
          _V_: ECMAScript 언어 값,
          optional _argumentsList_: ECMAScript 언어 값들의 List,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>함수 객체의 [[Call]] 내부 메소드를 호출하는 데 사용됩니다. _F_는 함수 객체, _V_는 [[Call]]의 *this* 값, _argumentsList_는 내부 메소드의 해당 인자에 전달되는 값입니다. _argumentsList_가 없으면 새 빈 List가 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _argumentsList_가 존재하지 않으면 새 빈 List로 설정한다.
        1. IsCallable(_F_)가 *false*이면 *TypeError* 예외를 던진다.
        1. ? <emu-meta effects="user-code">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-construct" type="abstract operation">
      <h1>
        Construct (
          _F_: 생성자,
          optional _argumentsList_: ECMAScript 언어 값들의 List,
          optional _newTarget_: 생성자,
        ): Object를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>함수 객체의 [[Construct]] 내부 메소드를 호출하는 데 사용됩니다. _argumentsList_, _newTarget_은 내부 메소드에 전달될 해당 인자 값입니다. _argumentsList_가 없으면 새 빈 List가, _newTarget_이 없으면 _F_가 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _newTarget_이 존재하지 않으면 _newTarget_을 _F_로 둔다.
        1. _argumentsList_가 존재하지 않으면 새 빈 List로 둔다.
        1. ? <emu-meta effects="user-code">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>_newTarget_이 없으면 이 연산은 `new F(...argumentsList)`와 동일합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-setintegritylevel" type="abstract operation">
      <h1>
        SetIntegrityLevel (
          _O_: Object,
          _level_: ~sealed~ 또는 ~frozen~,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 own 프로퍼티 집합을 고정(fix)하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _status_를 ? _O_.[[PreventExtensions]]()로 둔다.
        1. _status_가 *false*이면 *false*를 반환한다.
        1. _keys_를 ? _O_.[[OwnPropertyKeys]]()로 둔다.
        1. _level_이 ~sealed~이면,
          1. _keys_의 각 요소 _k_에 대해
            1. ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* })를 수행한다.
        1. Else,
          1. 단언: _level_은 ~frozen~.
          1. _keys_의 각 요소 _k_에 대해
            1. _currentDesc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)로 둔다.
            1. _currentDesc_가 *undefined*가 아니면,
              1. IsAccessorDescriptor(_currentDesc_)가 *true*이면
                1. _desc_를 PropertyDescriptor { [[Configurable]]: *false* }로 둔다.
              1. Else,
                1. _desc_를 PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }로 둔다.
              1. ? DefinePropertyOrThrow(_O_, _k_, _desc_)를 수행한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-testintegritylevel" type="abstract operation">
      <h1>
        TestIntegrityLevel (
          _O_: Object,
          _level_: ~sealed~ 또는 ~frozen~,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 own 프로퍼티 집합이 고정되어 있는지 판정하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _extensible_을 ? IsExtensible(_O_)로 둔다.
        1. _extensible_이 *true*이면 *false*를 반환한다.
        1. 주: 객체가 확장이 가능하면 프로퍼티를 검사하지 않는다.
        1. _keys_를 ? _O_.[[OwnPropertyKeys]]()로 둔다.
        1. _keys_의 각 요소 _k_에 대해
          1. _currentDesc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)로 둔다.
          1. _currentDesc_가 *undefined*가 아니면,
            1. _currentDesc_.[[Configurable]]이 *true*이면 *false*를 반환한다.
            1. _level_이 ~frozen~이고 IsDataDescriptor(_currentDesc_)가 *true*이면,
              1. _currentDesc_.[[Writable]]이 *true*이면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createarrayfromlist" type="abstract operation">
      <h1>
        CreateArrayFromList (
          _elements_: ECMAScript 언어 값들의 List,
        ): Array
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>요소가 _elements_로 제공되는 Array를 생성하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _array_를 ! ArrayCreate(0)로 둔다.
        1. _n_을 0으로 둔다.
        1. _elements_의 각 요소 _e_에 대해
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_)를 수행한다.
          1. _n_을 _n_ + 1로 둔다.
        1. _array_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-lengthofarraylike" type="abstract operation">
      <h1>
        LengthOfArrayLike (
          _obj_: Object,
        ): 음이 아닌 정수를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>배열 유사 객체의 *"length"* 프로퍼티 값을 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. ℝ(? ToLength(? Get(_obj_, *"length"*)))를 반환한다.
      </emu-alg>
      <p><dfn variants="array-like objects">array-like object</dfn>는 이 연산이 normal completion을 반환하는 모든 객체입니다.</p>
      <emu-note>
        일반적으로 array-like object는 정수 인덱스 이름을 가진 몇몇 프로퍼티도 가집니다. 그러나 이것은 필수 조건이 아닙니다.
      </emu-note>
      <emu-note>
        Array와 String 객체가 array-like object의 예입니다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createlistfromarraylike" type="abstract operation">
      <h1>
        CreateListFromArrayLike (
          _obj_: ECMAScript 언어 값,
          optional _validElementTypes_: ~all~ 또는 ~property-key~,
        ): ECMAScript 언어 값들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_obj_의 인덱스된 프로퍼티가 제공하는 요소로 이루어진 List 값을 생성하는 데 사용됩니다. _validElementTypes_는 요소로 허용되는 값 타입을 지정합니다.</dd>
      </dl>
      <emu-alg>
        1. _validElementTypes_가 존재하지 않으면 ~all~로 설정한다.
        1. _obj_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. _len_을 ? LengthOfArrayLike(_obj_)로 둔다.
        1. _list_를 새 빈 List로 둔다.
        1. _index_를 0으로 둔다.
        1. _index_ &lt; _len_ 동안 반복,
          1. _indexName_을 ! ToString(𝔽(_index_))로 둔다.
          1. _next_를 ? Get(_obj_, _indexName_)로 둔다.
          1. _validElementTypes_가 ~property-key~이고 _next_가 프로퍼티 키가 아니면 *TypeError* 예외를 던진다.
          1. _next_를 _list_에 추가한다.
          1. _index_를 _index_ + 1로 둔다.
        1. _list_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-invoke" type="abstract operation">
      <h1>
        Invoke (
          _V_: ECMAScript 언어 값,
          _P_: 프로퍼티 키,
          optional _argumentsList_: ECMAScript 언어 값들의 List,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ECMAScript 언어 값의 메서드 프로퍼티를 호출하는 데 사용됩니다. _V_는 프로퍼티 조회 지점이자 호출의 *this* 값입니다. _argumentsList_는 메서드에 전달되는 인자 값 리스트입니다. _argumentsList_가 없으면 새 빈 List가 사용됩니다.</dd>
      </dl>

      <emu-alg>
        1. _argumentsList_가 존재하지 않으면 새 빈 List로 둔다.
        1. _func_을 ? GetV(_V_, _P_)로 둔다.
        1. ? Call(_func_, _V_, _argumentsList_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryhasinstance" type="abstract operation">
      <h1>
        OrdinaryHasInstance (
          _C_: ECMAScript 언어 값,
          _O_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_가 _C_가 제공한 인스턴스 객체 상속 경로를 상속하는지 여부를 결정하는 기본 알고리즘을 구현합니다.</dd>
      </dl>
      <emu-alg>
        1. IsCallable(_C_)가 *false*이면 *false*를 반환한다.
        1. _C_가 [[BoundTargetFunction]] 내부 슬롯을 가지면,
          1. _BC_를 _C_.[[BoundTargetFunction]]으로 둔다.
          1. ? InstanceofOperator(_O_, _BC_)를 반환한다.
        1. _O_가 Object가 아니면 *false*를 반환한다.
        1. _P_를 ? Get(_C_, *"prototype"*)으로 둔다.
        1. _P_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. 반복,
          1. _O_를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()로 둔다.
          1. _O_가 *null*이면 *false*를 반환한다.
          1. SameValue(_P_, _O_)가 *true*이면 *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-speciesconstructor" type="abstract operation">
      <h1>
        SpeciesConstructor (
          _O_: Object,
          _defaultConstructor_: 생성자,
        ): 생성자를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_로부터 파생된 새 객체를 생성할 때 사용해야 하는 생성자를 가져오는 데 사용됩니다. _defaultConstructor_는 _O_부터 시작하여 %Symbol.species% 프로퍼티 생성자를 찾을 수 없을 때 사용할 생성자입니다.</dd>
      </dl>
      <emu-alg>
        1. _C_를 ? Get(_O_, *"constructor"*)로 둔다.
        1. _C_가 *undefined*이면 _defaultConstructor_를 반환한다.
        1. _C_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. _S_를 ? Get(_C_, %Symbol.species%)로 둔다.
        1. _S_가 *undefined* 또는 *null*이면 _defaultConstructor_를 반환한다.
        1. IsConstructor(_S_)가 *true*이면 _S_를 반환한다.
        1. *TypeError* 예외를 던진다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-enumerableownproperties" type="abstract operation" oldids="sec-enumerableownpropertynames">
      <h1>
        EnumerableOwnProperties (
          _O_: Object,
          _kind_: ~key~, ~value~, 또는 ~key+value~,
        ): ECMAScript 언어 값들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _ownKeys_를 ? <emu-meta effects="user-code">_O_.[[OwnPropertyKeys]]</emu-meta>()로 둔다.
        1. _results_를 새 빈 List로 둔다.
        1. _ownKeys_의 각 요소 _key_에 대해
          1. _key_가 String이면,
            1. _desc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)로 둔다.
            1. _desc_가 *undefined*가 아니고 _desc_.[[Enumerable]]이 *true*이면,
              1. _kind_가 ~key~이면
                1. _key_를 _results_에 추가한다.
              1. Else,
                1. _value_를 ? Get(_O_, _key_)로 둔다.
                1. _kind_가 ~value~이면
                  1. _value_를 _results_에 추가한다.
                1. Else,
                  1. 단언: _kind_는 ~key+value~.
                  1. _entry_를 CreateArrayFromList(« _key_, _value_ »)로 둔다.
                  1. _entry_를 _results_에 추가한다.
        1. _results_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getfunctionrealm" type="abstract operation">
      <h1>
        GetFunctionRealm (
          _obj_: 함수 객체,
        ): Realm Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _obj_가 [[Realm]] 내부 슬롯을 가지면
          1. _obj_.[[Realm]]을 반환한다.
        1. _obj_가 bound function exotic 객체이면
          1. _boundTargetFunction_을 _obj_.[[BoundTargetFunction]]으로 둔다.
          1. ? GetFunctionRealm(_boundTargetFunction_)을 반환한다.
        1. _obj_가 Proxy 이국 객체이면
          1. ? ValidateNonRevokedProxy(_obj_)를 수행한다.
          1. _proxyTarget_을 _obj_.[[ProxyTarget]]으로 둔다.
          1. 단언: _proxyTarget_은 함수 객체이다.
          1. ? GetFunctionRealm(_proxyTarget_)을 반환한다.
        1. [id="step-getfunctionrealm-default-return"] 현재 Realm Record를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-getfunctionrealm-default-return"></emu-xref> 단계는 _obj_가 [[Realm]] 내부 슬롯이 없는 비표준 함수 이국 객체인 경우에만 도달합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-copydataproperties" type="abstract operation">
      <h1>
        CopyDataProperties (
          _target_: Object,
          _source_: ECMAScript 언어 값,
          _excludedItems_: 프로퍼티 키들의 List,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _source_가 *undefined* 또는 *null*이면 ~unused~를 반환한다.
        1. _from_을 ! ToObject(_source_)로 둔다.
        1. _keys_를 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]</emu-meta>()로 둔다.
        1. _keys_의 각 요소 _nextKey_에 대해
          1. _excluded_를 *false*로 둔다.
          1. _excludedItems_의 각 요소 _e_에 대해
            1. SameValue(_e_, _nextKey_)가 *true*이면
              1. _excluded_를 *true*로 둔다.
          1. _excluded_가 *false*이면
            1. _desc_를 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_)로 둔다.
            1. _desc_가 *undefined*가 아니고 _desc_.[[Enumerable]]이 *true*이면
              1. _propValue_를 ? Get(_from_, _nextKey_)로 둔다.
              1. ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>여기에 전달되는 target은 항상 새로 생성된 객체이며, 오류 발생 시 직접 접근할 수 없습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-privateelementfind" type="abstract operation">
      <h1>
        PrivateElementFind (
          _O_: Object,
          _P_: Private Name,
        ): PrivateElement 또는 ~empty~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _O_.[[PrivateElements]]가 _pe_.[[Key]]가 _P_인 PrivateElement _pe_를 포함하면
          1. _pe_를 반환한다.
        1. ~empty~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatefieldadd" type="abstract operation">
      <h1>
        PrivateFieldAdd (
          _O_: Object,
          _P_: Private Name,
          _value_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 호스트가 웹 브라우저이면
          1. ? HostEnsureCanAddPrivateElement(_O_)를 수행한다.
        1. _entry_를 PrivateElementFind(_O_, _P_)로 둔다.
        1. _entry_가 ~empty~가 아니면 *TypeError* 예외를 던진다.
        1. PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ }를 _O_.[[PrivateElements]]에 추가한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatemethodoraccessoradd" type="abstract operation">
      <h1>
        PrivateMethodOrAccessorAdd (
          _O_: Object,
          _method_: PrivateElement,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 단언: _method_.[[Kind]]는 ~method~ 또는 ~accessor~이다.
        1. 호스트가 웹 브라우저이면
          1. ? HostEnsureCanAddPrivateElement(_O_)를 수행한다.
        1. _entry_를 PrivateElementFind(_O_, _method_.[[Key]])로 둔다.
        1. _entry_가 ~empty~가 아니면 *TypeError* 예외를 던진다.
        1. _method_를 _O_.[[PrivateElements]]에 추가한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>private 메서드와 접근자의 값은 인스턴스 간에 공유됩니다. 이 연산은 메서드나 접근자의 새 복사본을 만들지 않습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostensurecanaddprivateelement" type="host-defined abstract operation">
      <h1>
        HostEnsureCanAddPrivateElement (
          _O_: Object,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>호스트 환경이 특정 호스트 정의 exotic 객체에 private element 추가를 방지할 수 있도록 합니다.</dd>
      </dl>
      <p>HostEnsureCanAddPrivateElement 구현은 다음 요구사항을 따라야 합니다:</p>
      <ul>
        <li>_O_가 호스트 정의 exotic 객체가 아니면 이 추상 연산은 NormalCompletion(~unused~)을 반환하고 다른 단계를 수행하지 않아야 합니다.</li>
        <li>같은 인수로 이 추상 연산을 두 번 호출하면 동일한 종류의 Completion Record를 반환해야 합니다.</li>
      </ul>
      <p>HostEnsureCanAddPrivateElement의 기본 구현은 NormalCompletion(~unused~)을 반환하는 것입니다.</p>
      <p>이 추상 연산은 ECMAScript 호스트가 웹 브라우저인 경우에만 호출됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-privateget" type="abstract operation">
      <h1>
        PrivateGet (
          _O_: Object,
          _P_: Private Name,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _entry_를 PrivateElementFind(_O_, _P_)로 둔다.
        1. _entry_가 ~empty~이면 *TypeError* 예외를 던진다.
        1. _entry_.[[Kind]]가 ~field~ 또는 ~method~이면
          1. _entry_.[[Value]]를 반환한다.
        1. 단언: _entry_.[[Kind]]는 ~accessor~이다.
        1. _entry_.[[Get]]이 *undefined*이면 *TypeError* 예외를 던진다.
        1. _getter_를 _entry_.[[Get]]으로 둔다.
        1. ? Call(_getter_, _O_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privateset" type="abstract operation">
      <h1>
        PrivateSet (
          _O_: Object,
          _P_: Private Name,
          _value_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _entry_를 PrivateElementFind(_O_, _P_)로 둔다.
        1. _entry_가 ~empty~이면 *TypeError* 예외를 던진다.
        1. _entry_.[[Kind]]가 ~field~이면
          1. _entry_.[[Value]]를 _value_로 설정한다.
        1. Else if _entry_.[[Kind]]가 ~method~이면
          1. *TypeError* 예외를 던진다.
        1. Else,
          1. 단언: _entry_.[[Kind]]는 ~accessor~.
          1. _entry_.[[Set]]이 *undefined*이면 *TypeError* 예외를 던진다.
          1. _setter_를 _entry_.[[Set]]으로 둔다.
          1. ? Call(_setter_, _O_, « _value_ »)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definefield" type="abstract operation">
      <h1>
        DefineField (
          _receiver_: Object,
          _fieldRecord_: ClassFieldDefinition Record,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _fieldName_을 _fieldRecord_.[[Name]]으로 둔다.
        1. _initializer_를 _fieldRecord_.[[Initializer]]로 둔다.
        1. _initializer_가 ~empty~가 아니면
          1. _initValue_를 ? Call(_initializer_, _receiver_)로 둔다.
        1. Else,
          1. _initValue_를 *undefined*로 둔다.
        1. _fieldName_이 Private Name이면
          1. ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_)를 수행한다.
        1. Else,
          1. 단언: _fieldName_은 프로퍼티 키이다.
          1. ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializeinstanceelements" type="abstract operation">
      <h1>
        InitializeInstanceElements (
          _O_: 객체,
          _constructor_: ECMAScript 함수 객체 또는 내장 함수 객체,
        ): ~unused~를 포함하는 정상적 완료 또는 throw 완료
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _methods_를 _constructor_.[[PrivateMethods]]로 둔다.
        1. _methods_의 각 PrivateElement _method_에 대해
          1. ? PrivateMethodOrAccessorAdd(_O_, _method_)를 수행한다.
        1. _fields_를 _constructor_.[[Fields]]로 둔다.
        1. _fields_의 각 요소 _fieldRecord_에 대해
          1. ? DefineField(_O_, _fieldRecord_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-value-to-keyed-group" type="abstract operation">
      <h1>
        AddValueToKeyedGroup (
          _groups_: 필드 [[Key]](ECMAScript 언어 값)와 [[Elements]](ECMAScript 언어 값들의 List)를 가진 Record들의 List,
          _key_: ECMAScript 언어 값,
          _value_: ECMAScript 언어 값,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _groups_의 각 Record { [[Key]], [[Elements]] } _g_에 대해
          1. SameValue(_g_.[[Key]], _key_)가 *true*이면
            1. 단언: 정확히 한 요소만 이 조건을 만족한다.
            1. _value_를 _g_.[[Elements]]에 추가한다.
            1. ~unused~를 반환한다.
        1. _group_을 Record { [[Key]]: _key_, [[Elements]]: « _value_ » }로 둔다.
        1. _group_을 _groups_에 추가한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-groupby" type="abstract operation">
      <h1>
        GroupBy (
          _items_: ECMAScript 언어 값,
          _callback_: ECMAScript 언어 값,
          _keyCoercion_: ~property~ 또는 ~collection~,
        ): 필드 [[Key]](ECMAScript 언어 값) 및 [[Elements]](ECMAScript 언어 값들의 List)를 가진 Record들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ? RequireObjectCoercible(_items_)를 수행한다.
        1. IsCallable(_callback_)이 *false*이면 *TypeError* 예외를 던진다.
        1. _groups_를 새 빈 List로 둔다.
        1. _iteratorRecord_를 ? GetIterator(_items_, ~sync~)로 둔다.
        1. _k_를 0으로 둔다.
        1. 반복,
          1. _k_ ≥ 2<sup>53</sup> - 1이면
            1. _error_를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
            1. ? IteratorClose(_iteratorRecord_, _error_)를 반환한다.
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. _groups_를 반환한다.
          1. _value_를 _next_로 둔다.
          1. _key_를 Completion(Call(_callback_, *undefined*, « _value_, 𝔽(_k_) »))로 둔다.
          1. IfAbruptCloseIterator(_key_, _iteratorRecord_).
          1. _keyCoercion_이 ~property~이면
            1. _key_를 Completion(ToPropertyKey(_key_))로 둔다.
            1. IfAbruptCloseIterator(_key_, _iteratorRecord_).
          1. Else,
            1. 단언: _keyCoercion_은 ~collection~.
            1. _key_를 CanonicalizeKeyedCollectionKey(_key_)로 둔다.
          1. AddValueToKeyedGroup(_groups_, _key_, _value_)를 수행한다.
          1. _k_를 _k_ + 1로 둔다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getoptionsobject" type="abstract operation">
      <h1>
        GetOptionsObject (
          _options_: ECMAScript 언어 값,
        ): Object를 포함하는 normal completion 또는 throw completion 중 하나
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _options_가 *undefined*이면,
          1. OrdinaryObjectCreate(*null*)을 반환한다.
        1. _options_가 Object이면,
          1. _options_를 반환한다.
        1. *TypeError* 예외를 throw한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-SetterThatIgnoresPrototypeProperties" type="abstract operation">
      <h1>
        SetterThatIgnoresPrototypeProperties (
          _thisValue_: ECMAScript 언어 값,
          _home_: Object,
          _p_: 프로퍼티 키,
          _v_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _thisValue_가 Object가 아니면
          1. *TypeError* 예외를 던진다.
        1. SameValue(_thisValue_, _home_)가 *true*이면
          1. 주: 여기서 던지는 것은 strict mode 코드에서 _home_ 객체의 쓰기 불가능 데이터 프로퍼티에 대입하는 것과 유사하다.
          1. *TypeError* 예외를 던진다.
        1. _desc_를 ? _thisValue_.[[GetOwnProperty]](_p_)로 둔다.
        1. _desc_가 *undefined*이면
          1. ? CreateDataPropertyOrThrow(_thisValue_, _p_, _v_)를 수행한다.
        1. Else,
          1. ? Set(_thisValue_, _p_, _v_, *true*)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>이터레이터 객체에 대한 연산(Operations on Iterator Objects)</h1>
    <p>공통 반복 인터페이스는 <emu-xref href="#sec-iteration"></emu-xref> 참조.</p>

    <emu-clause id="sec-iterator-records">
      <h1>Iterator Record</h1>
      <p><dfn variants="Iterator Records">Iterator Record</dfn>는 이터레이터 또는 async 이터레이터와 그 `next` 메서드를 캡슐화하는 데 사용되는 Record 값입니다.</p>
      <p>Iterator Record는 <emu-xref href="#table-iterator-record-fields"></emu-xref>에 나열된 필드를 가집니다.</p>
      <emu-table id="table-iterator-record-fields" caption="Iterator Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Iterator]]
            </td>
            <td>
              Object
            </td>
            <td>
              이터레이터 인터페이스 또는 async 이터레이터 인터페이스를 준수하는 객체.
            </td>
          </tr>
          <tr>
            <td>
              [[NextMethod]]
            </td>
            <td>
              ECMAScript 언어 값
            </td>
            <td>
              [[Iterator]] 객체의 `next` 메서드.
            </td>
          </tr>
          <tr>
            <td>
              [[Done]]
            </td>
            <td>
              Boolean
            </td>
            <td>
              이터레이터가 완료되었거나 닫혔는지 여부.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-getiteratordirect" type="abstract operation">
      <h1>
        GetIteratorDirect (
          _obj_: Object,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _nextMethod_를 ? Get(_obj_, *"next"*)로 둔다.
        1. _iteratorRecord_를 Iterator Record { [[Iterator]]: _obj_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }로 둔다.
        1. _iteratorRecord_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorfrommethod" type="abstract operation">
      <h1>
        GetIteratorFromMethod (
          _obj_: ECMAScript 언어 값,
          _method_: 함수 객체,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _iterator_를 ? Call(_method_, _obj_)로 둔다.
        1. _iterator_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? GetIteratorDirect(_iterator_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiterator" type="abstract operation">
      <h1>
        GetIterator (
          _obj_: ECMAScript 언어 값,
          _kind_: ~sync~ 또는 ~async~,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _kind_가 ~async~이면,
          1. _method_를 ? GetMethod(_obj_, %Symbol.asyncIterator%)로 둔다.
          1. _method_가 *undefined*이면,
            1. _syncMethod_를 ? GetMethod(_obj_, %Symbol.iterator%)로 둔다.
            1. _syncMethod_가 *undefined*이면 *TypeError* 예외를 던진다.
            1. _syncIteratorRecord_를 ? GetIteratorFromMethod(_obj_, _syncMethod_)로 둔다.
            1. CreateAsyncFromSyncIterator(_syncIteratorRecord_)를 반환한다.
        1. Else,
          1. _method_를 ? GetMethod(_obj_, %Symbol.iterator%)로 둔다.
        1. _method_가 *undefined*이면 *TypeError* 예외를 던진다.
        1. ? GetIteratorFromMethod(_obj_, _method_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorflattenable" type="abstract operation">
      <h1>
        GetIteratorFlattenable (
          _obj_: ECMAScript 언어 값,
          _primitiveHandling_: ~iterate-string-primitives~ 또는 ~reject-primitives~,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _obj_가 Object가 아니면,
          1. _primitiveHandling_이 ~reject-primitives~이면 *TypeError* 예외를 던진다.
          1. 단언: _primitiveHandling_은 ~iterate-string-primitives~.
          1. _obj_가 String이 아니면 *TypeError* 예외를 던진다.
        1. _method_를 ? GetMethod(_obj_, %Symbol.iterator%)로 둔다.
        1. _method_가 *undefined*이면
          1. _iterator_를 _obj_로 둔다.
        1. Else,
          1. _iterator_를 ? Call(_method_, _obj_)로 둔다.
        1. _iterator_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? GetIteratorDirect(_iterator_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratornext" type="abstract operation">
      <h1>
        IteratorNext (
          _iteratorRecord_: Iterator Record,
          optional _value_: ECMAScript 언어 값,
        ): Object를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _value_가 존재하지 않으면
          1. _result_를 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]))로 둔다.
        1. Else,
          1. _result_를 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »))로 둔다.
        1. _result_가 throw completion이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. ? _result_를 반환한다.
        1. _result_를 ! _result_로 둔다.
        1. _result_가 Object가 아니면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. *TypeError* 예외를 던진다.
        1. _result_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorcomplete" type="abstract operation">
      <h1>
        IteratorComplete (
          _iteratorResult_: Object,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ToBoolean(? Get(_iteratorResult_, *"done"* ))을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorvalue" type="abstract operation">
      <h1>
        IteratorValue (
          _iteratorResult_: Object,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ? Get(_iteratorResult_, *"value"*)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstep" type="abstract operation">
      <h1>
        IteratorStep (
          _iteratorRecord_: Iterator Record,
        ): Object 또는 ~done~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_iteratorRecord_.[[Iterator]]에서 _iteratorRecord_.[[NextMethod]]를 호출해 다음 값을 요청하고, 이터레이터가 끝에 도달했음을 나타내는 ~done~ 또는 다음 값을 사용할 수 있다면 IteratorResult 객체를 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _result_를 ? IteratorNext(_iteratorRecord_)로 둔다.
        1. _done_을 Completion(IteratorComplete(_result_))로 둔다.
        1. _done_이 throw completion이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. ? _done_을 반환한다.
        1. _done_을 ! _done_으로 둔다.
        1. _done_이 *true*이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. ~done~을 반환한다.
        1. _result_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstepvalue" type="abstract operation">
      <h1>
        IteratorStepValue (
          _iteratorRecord_: Iterator Record,
        ): ECMAScript 언어 값 또는 ~done~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_iteratorRecord_.[[Iterator]]에서 _iteratorRecord_.[[NextMethod]]를 호출해 다음 값을 요청하고, 끝에 도달했으면 ~done~을, 다음 값이 있으면 IteratorResult 객체의 값을 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _result_를 ? IteratorStep(_iteratorRecord_)로 둔다.
        1. _result_가 ~done~이면
          1. ~done~을 반환한다.
        1. _value_를 Completion(IteratorValue(_result_))로 둔다.
        1. _value_가 throw completion이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
        1. ? _value_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorclose" type="abstract operation">
      <h1>
        IteratorClose (
          _iteratorRecord_: Iterator Record,
          _completion_: Completion Record,
        ): Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>이터레이터가 완료 상태에 도달했을 때 일반적으로 수행할 동작을 실행하도록 알리는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _iteratorRecord_.[[Iterator]]는 Object이다.
        1. _iterator_를 _iteratorRecord_.[[Iterator]]로 둔다.
        1. _innerResult_를 Completion(GetMethod(_iterator_, *"return"* ))로 둔다.
        1. _innerResult_가 normal completion이면
          1. _return_을 _innerResult_.[[Value]]로 둔다.
          1. _return_이 *undefined*이면 ? _completion_을 반환한다.
          1. _innerResult_를 Completion(Call(_return_, _iterator_))로 둔다.
        1. _completion_이 throw completion이면 ? _completion_을 반환한다.
        1. _innerResult_가 throw completion이면 ? _innerResult_를 반환한다.
        1. _innerResult_.[[Value]]가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? _completion_을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ifabruptcloseiterator" aoid="IfAbruptCloseIterator">
      <h1>IfAbruptCloseIterator ( _value_, _iteratorRecord_ )</h1>
      <p>IfAbruptCloseIterator는 Iterator Record를 사용하는 알고리즘 단계의 축약 표현입니다. 다음 형태의 알고리즘 단계:</p>
      <emu-alg>
        1. IfAbruptCloseIterator(_value_, _iteratorRecord_).
      </emu-alg>
      <p>는 다음과 동일한 의미입니다:</p>
      <emu-alg>
        1. 단언: _value_는 Completion Record이다.
        1. _value_가 abrupt completion이면 ? IteratorClose(_iteratorRecord_, _value_)를 반환한다.
        1. Else, _value_를 ! _value_로 설정한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asynciteratorclose" type="abstract operation">
      <h1>
        AsyncIteratorClose (
          _iteratorRecord_: Iterator Record,
          _completion_: Completion Record,
        ): Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>async 이터레이터가 완료 상태에 도달했을 때 일반적으로 수행할 동작을 실행하도록 알리는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _iteratorRecord_.[[Iterator]]는 Object이다.
        1. _iterator_를 _iteratorRecord_.[[Iterator]]로 둔다.
        1. _innerResult_를 Completion(GetMethod(_iterator_, *"return"* ))로 둔다.
        1. _innerResult_가 normal completion이면
          1. _return_을 _innerResult_.[[Value]]로 둔다.
          1. _return_이 *undefined*이면 ? _completion_을 반환한다.
          1. _innerResult_를 Completion(Call(_return_, _iterator_))로 둔다.
          1. _innerResult_가 normal completion이면 _innerResult_를 Completion(Await(_innerResult_.[[Value]]))로 둔다.
        1. _completion_이 throw completion이면 ? _completion_을 반환한다.
        1. _innerResult_가 throw completion이면 ? _innerResult_를 반환한다.
        1. _innerResult_.[[Value]]가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? _completion_을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createiterresultobject" type="abstract operation">
      <h1>
        CreateIteratorResultObject (
          _value_: ECMAScript 언어 값,
          _done_: Boolean,
        ): IteratorResult 인터페이스를 준수하는 Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>IteratorResult 인터페이스를 준수하는 객체를 생성합니다.</dd>
      </dl>
      <emu-alg>
        1. _obj_를 OrdinaryObjectCreate(%Object.prototype%)로 둔다.
        1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_)를 수행한다.
        1. ! CreateDataPropertyOrThrow(_obj_, *"done"*, _done_)를 수행한다.
        1. _obj_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistiteratorRecord" type="abstract operation" oldids="sec-createlistiterator,sec-listiteratornext-functions,sec-listiterator-next">
      <h1>
        CreateListIteratorRecord (
          _list_: ECMAScript 언어 값들의 List,
        ): Iterator Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>[[NextMethod]]가 _list_의 연속 요소를 반환하는 Iterator Record를 생성합니다.</dd>
      </dl>
      <emu-alg>
        1. _closure_를 매개변수 없고 _list_를 캡처하며 호출 시 다음 단계를 수행하는 새 Abstract Closure로 둔다:
          1. _list_의 각 요소 _E_에 대해
            1. ? GeneratorYield(CreateIteratorResultObject(_E_, *false*))를 수행한다.
          1. NormalCompletion(*undefined*)를 반환한다.
        1. _iterator_를 CreateIteratorFromClosure(_closure_, ~empty~, %Iterator.prototype%)로 둔다.
        1. Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorPrototype.next%, [[Done]]: *false* }를 반환한다.
      </emu-alg>
      <emu-note>
        <p>list 이터레이터 객체는 ECMAScript 코드에서 직접 접근할 수 없습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-iteratortolist" oldids="sec-iterabletolist" type="abstract operation">
      <h1>
        IteratorToList (
          _iteratorRecord_: Iterator Record,
        ): ECMAScript 언어 값들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _values_를 새 빈 List로 둔다.
        1. 반복,
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. _values_를 반환한다.
          1. _next_를 _values_에 추가한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>구문 지향 연산(Syntax-Directed Operations)</h1>
  <p>이 절에서 정의된 것들 외에도, 특수화된 구문 지향 연산들이 이 명세 전반에 걸쳐 정의된다.</p>

  <emu-clause id="sec-evaluation" type="sdo">
    <h1>런타임 의미론: Evaluation ( ): Completion Record</h1>
    <dl class="header">
      <dt>effects</dt>
      <dd>user-code</dd>
    </dl>
    <emu-note>
      이 연산의 정의는 이 명세의 "ECMAScript Language" 절들에 분산되어 있다. 각 정의는 관련 생성규칙(production)이 정의적으로 등장한 직후에 나타난다.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>스코프 분석(Scope Analysis)</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>정적 의미론: BoundNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* 문자열은 모듈의 기본(default) export가 다른 이름을 가지지 않을 때 그 모듈의 기본 export를 위한 합성된 이름으로 이 명세 내부에서 사용된다. 모듈의 [[Environment]] 내에 그 이름으로 항목이 생성되어 해당 값을 보유하고, 모듈에 대해 <emu-xref href="#sec-resolveexport" title></emu-xref>를 호출하여 *"default"*라는 export를 해석하면 [[BindingName]]이 *"\*default\*"*인 ResolvedBinding Record를 반환하며, 이는 모듈 [[Environment]]에서 상술한 값으로 다시 해석된다. 이는 명세 편의를 위한 것이며, 익명 기본 export도 다른 export와 동일하게 해석될 수 있도록 한다. 이 *"\*default\*"* 문자열은 ECMAScript 코드나 모듈 링크 알고리즘에서 접근될 수 없다.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. |Identifier|의 StringValue만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. « *"yield"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. « *"await"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. |BindingList|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingList|의 BoundNames로 둔다.
        1. _names2_를 |LexicalBinding|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. |BindingPattern|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. _names1_을 |VariableDeclarationList|의 BoundNames로 둔다.
        1. _names2_를 |VariableDeclaration|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. |BindingPattern|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingPropertyList|의 BoundNames로 둔다.
        1. _names2_를 |BindingRestProperty|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingRestElement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingElementList|의 BoundNames로 둔다.
        1. _names2_를 |BindingRestElement|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingPropertyList|의 BoundNames로 둔다.
        1. _names2_를 |BindingProperty|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingElementList|의 BoundNames로 둔다.
        1. _names2_를 |BindingElisionElement|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingPattern|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. |ForBinding|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. _names1_을 |FormalParameterList|의 BoundNames로 둔다.
        1. _names2_를 |FunctionRestParameter|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. _names1_을 |FormalParameterList|의 BoundNames로 둔다.
        1. _names2_를 |FormalParameter|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_를 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ArrowFormalParameters|로 둔다.
        1. _formals_의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. _head_를 |CoverCallExpressionAndAsyncArrowHead|가 커버하는 |AsyncArrowHead|로 둔다.
        1. _head_의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
      <emu-alg>
        1. |ImportClause|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. _names1_을 |ImportedDefaultBinding|의 BoundNames로 둔다.
        1. _names2_를 |NameSpaceImport|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. _names1_을 |ImportedDefaultBinding|의 BoundNames로 둔다.
        1. _names2_를 |NamedImports|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. _names1_을 |ImportsList|의 BoundNames로 둔다.
        1. _names2_를 |ImportSpecifier|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. |ImportedBinding|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. |VariableStatement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. _declarationNames_를 |HoistableDeclaration|의 BoundNames로 둔다.
        1. _declarationNames_에 *"\*default\*"* 요소가 없으면 *"\*default\*"*를 _declarationNames_에 추가한다.
        1. _declarationNames_를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. _declarationNames_를 |ClassDeclaration|의 BoundNames로 둔다.
        1. _declarationNames_에 *"\*default\*"* 요소가 없으면 *"\*default\*"*를 _declarationNames_에 추가한다.
        1. _declarationNames_를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-declarationpart" type="sdo">
      <h1>정적 의미론: DeclarationPart ( ): Parse Node</h1>
      <dl class="header">
      </dl>
      <emu-grammar>HoistableDeclaration : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : GeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. |GeneratorDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncFunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |AsyncFunctionDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncGeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. |AsyncGeneratorDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>Declaration : ClassDeclaration</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>Declaration : LexicalDeclaration</emu-grammar>
      <emu-alg>
        1. |LexicalDeclaration|을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>정적 의미론: IsConstantDeclaration ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. |LetOrConst|의 IsConstantDeclaration을 반환한다.
      </emu-alg>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p>`export default` |AssignmentExpression|을 상수 선언으로 다룰 필요는 없다. 이는 모듈의 기본 객체를 참조하는 내부 바운드 이름에 대입을 허용하는 구문이 존재하지 않기 때문이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallydeclarednames" oldids="sec-block-static-semantics-lexicallydeclarednames,sec-switch-statement-static-semantics-lexicallydeclarednames,sec-labelled-statements-static-semantics-lexicallydeclarednames,sec-function-definitions-static-semantics-lexicallydeclarednames,sec-arrow-function-definitions-static-semantics-lexicallydeclarednames,sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames,sec-scripts-static-semantics-lexicallydeclarednames,sec-module-semantics-static-semantics-lexicallydeclarednames" type="sdo">
      <h1>정적 의미론: LexicallyDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 LexicallyDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 LexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |LabelledStatement|의 LexicallyDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _names1_을 그 LexicallyDeclaredNames로 둔다.
        1. 아니면 _names1_을 새 빈 List로 둔다.
        1. _names2_를 |DefaultClause|의 LexicallyDeclaredNames로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _names3_을 그 LexicallyDeclaredNames로 둔다.
        1. 아니면 _names3_을 새 빈 List로 둔다.
        1. _names1_, _names2_, _names3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _names1_을 |CaseClauses|의 LexicallyDeclaredNames로 둔다.
        1. _names2_를 |CaseClause|의 LexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 LexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|Script|의 최상위(top level)에서 함수 선언은 lexical 선언이 아닌 var 선언처럼 다루어진다.</p>
      </emu-note>
      <emu-note>
        <p>|Module|의 LexicallyDeclaredNames에는 모든 import된 바인딩의 이름이 포함된다.</p>
      </emu-note>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |ModuleItemList|의 LexicallyDeclaredNames로 둔다.
        1. _names2_를 |ModuleItem|의 LexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. |ImportDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration|이 `export` |VariableStatement|이면 새 빈 List를 반환한다.
        1. |ExportDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
      <emu-alg>
        1. |StatementListItem|의 LexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|Module|의 최상위에서는 함수 선언이 var 선언이 아닌 lexical 선언처럼 다루어진다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" oldids="sec-block-static-semantics-lexicallyscopeddeclarations,sec-switch-statement-static-semantics-lexicallyscopeddeclarations,sec-labelled-statements-static-semantics-lexicallyscopeddeclarations,sec-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations,sec-scripts-static-semantics-lexicallyscopeddeclarations,sec-module-semantics-static-semantics-lexicallyscopeddeclarations,sec-exports-static-semantics-lexicallyscopeddeclarations" type="sdo">
      <h1>정적 의미론: LexicallyScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |LabelledStatement|의 LexicallyScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 DeclarationPart만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _declarations1_을 그 LexicallyScopedDeclarations로 둔다.
        1. 아니면 _declarations1_을 새 빈 List로 둔다.
        1. _declarations2_를 |DefaultClause|의 LexicallyScopedDeclarations로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _declarations3_을 그 LexicallyScopedDeclarations로 둔다.
        1. 아니면 _declarations3_을 새 빈 List로 둔다.
        1. _declarations1_, _declarations2_, _declarations3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |CaseClauses|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |CaseClause|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 LexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » 를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |ModuleItemList|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |ModuleItem|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 DeclarationPart만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. |HoistableDeclaration|의 DeclarationPart만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration|만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 이 |ExportDeclaration|만을 요소로 갖는 List를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-vardeclarednames" oldids="sec-statement-semantics-static-semantics-vardeclarednames,sec-block-static-semantics-vardeclarednames,sec-variable-statement-static-semantics-vardeclarednames,sec-if-statement-static-semantics-vardeclarednames,sec-do-while-statement-static-semantics-vardeclarednames,sec-while-statement-static-semantics-vardeclarednames,sec-for-statement-static-semantics-vardeclarednames,sec-for-in-and-for-of-statements-static-semantics-vardeclarednames,sec-with-statement-static-semantics-vardeclarednames,sec-switch-statement-static-semantics-vardeclarednames,sec-labelled-statements-static-semantics-vardeclarednames,sec-try-statement-static-semantics-vardeclarednames,sec-function-definitions-static-semantics-vardeclarednames,sec-arrow-function-definitions-static-semantics-vardeclarednames,sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames,sec-scripts-static-semantics-vardeclarednames,sec-module-semantics-static-semantics-vardeclarednames" type="sdo">
      <h1>정적 의미론: VarDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 VarDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
      <emu-alg>
        1. |VariableDeclarationList|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _names1_을 첫 번째 |Statement|의 VarDeclaredNames로 둔다.
        1. _names2_를 두 번째 |Statement|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. _names1_을 |VariableDeclarationList|의 BoundNames로 둔다.
        1. _names2_를 |Statement|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. _names1_을 « |ForBinding| »으로 둔다.
        1. _names2_를 |Statement|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _names1_을 그 VarDeclaredNames로 둔다.
        1. 아니면 _names1_을 새 빈 List로 둔다.
        1. _names2_를 |DefaultClause|의 VarDeclaredNames로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _names3_을 그 VarDeclaredNames로 둔다.
        1. 아니면 _names3_을 새 빈 List로 둔다.
        1. _names1_, _names2_, _names3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _names1_을 |CaseClauses|의 VarDeclaredNames로 둔다.
        1. _names2_를 |CaseClause|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _names1_을 |Block|의 VarDeclaredNames로 둔다.
        1. _names2_를 |Catch|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _names1_을 |Block|의 VarDeclaredNames로 둔다.
        1. _names2_를 |Finally|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _names1_을 |Block|의 VarDeclaredNames로 둔다.
        1. _names2_를 |Catch|의 VarDeclaredNames로 둔다.
        1. _names3_을 |Finally|의 VarDeclaredNames로 둔다.
        1. _names1_, _names2_, _names3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |ModuleItemList|의 VarDeclaredNames로 둔다.
        1. _names2_를 |ModuleItem|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration|이 `export` |VariableStatement|이면 |ExportDeclaration|의 BoundNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-varscopeddeclarations" oldids="sec-statement-semantics-static-semantics-varscopeddeclarations,sec-block-static-semantics-varscopeddeclarations,sec-variable-statement-static-semantics-varscopeddeclarations,sec-if-statement-static-semantics-varscopeddeclarations,sec-do-while-statement-static-semantics-varscopeddeclarations,sec-while-statement-static-semantics-varscopeddeclarations,sec-for-statement-static-semantics-varscopeddeclarations,sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations,sec-with-statement-static-semantics-varscopeddeclarations,sec-switch-statement-static-semantics-varscopeddeclarations,sec-labelled-statements-static-semantics-varscopeddeclarations,sec-try-statement-static-semantics-varscopeddeclarations,sec-function-definitions-static-semantics-varscopeddeclarations,sec-arrow-function-definitions-static-semantics-varscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations,sec-scripts-static-semantics-varscopeddeclarations,sec-module-semantics-static-semantics-varscopeddeclarations" type="sdo">
      <h1>정적 의미론: VarScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclaration</emu-grammar>
      <emu-alg>
        1. « |VariableDeclaration| » 를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |VariableDeclarationList|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 « |VariableDeclaration| »의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_을 첫 번째 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 두 번째 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |VariableDeclarationList|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. _declarations1_을 « |ForBinding| »으로 둔다.
        1. _declarations2_를 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _declarations1_을 그 VarScopedDeclarations로 둔다.
        1. 아니면 _declarations1_을 새 빈 List로 둔다.
        1. _declarations2_를 |DefaultClause|의 VarScopedDeclarations로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _declarations3_을 그 VarScopedDeclarations로 둔다.
        1. 아니면 _declarations3_을 새 빈 List로 둔다.
        1. _declarations1_, _declarations2_, _declarations3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |CaseClauses|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |CaseClause|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |Block|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Catch|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |Block|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Finally|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |Block|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Catch|의 VarScopedDeclarations로 둔다.
        1. _declarations3_을 |Finally|의 VarScopedDeclarations로 둔다.
        1. _declarations1_, _declarations2_, _declarations3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |ModuleItemList|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |ModuleItem|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration|이 `export` |VariableStatement|이면 |VariableStatement|의 VarScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallydeclarednames" oldids="sec-block-static-semantics-toplevellexicallydeclarednames,sec-labelled-statements-static-semantics-toplevellexicallydeclarednames" type="sdo">
      <h1>정적 의미론: TopLevelLexicallyDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 TopLevelLexicallyDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 TopLevelLexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. 새 빈 List를 반환한다.
        1. |Declaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>함수나 스크립트의 최상위에서는 함수 선언이 lexical 선언이 아닌 var 선언처럼 취급된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallyscopeddeclarations" oldids="sec-block-static-semantics-toplevellexicallyscopeddeclarations,sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations" type="sdo">
      <h1>정적 의미론: TopLevelLexicallyScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 TopLevelLexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 TopLevelLexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. 새 빈 List를 반환한다.
        1. « |Declaration| » 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvardeclarednames" oldids="sec-block-static-semantics-toplevelvardeclarednames,sec-labelled-statements-static-semantics-toplevelvardeclarednames" type="sdo">
      <h1>정적 의미론: TopLevelVarDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 TopLevelVarDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 TopLevelVarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. |HoistableDeclaration|의 BoundNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarDeclaredNames를 반환한다.
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>함수나 스크립트의 최상위에서 내부 함수 선언은 var 선언처럼 다루어진다.</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarDeclaredNames를 반환한다.
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvarscopeddeclarations" oldids="sec-block-static-semantics-toplevelvarscopeddeclarations,sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations" type="sdo">
      <h1>정적 의미론: TopLevelVarScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 TopLevelVarScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 TopLevelVarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarScopedDeclarations를 반환한다.
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. _declaration_을 |HoistableDeclaration|의 DeclarationPart로 둔다.
          1. « _declaration_ » 를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarScopedDeclarations를 반환한다.
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » 를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-labels">
    <h1>레이블(Labels)</h1>

    <emu-clause id="sec-static-semantics-containsduplicatelabels" oldids="sec-statement-semantics-static-semantics-containsduplicatelabels,sec-block-static-semantics-containsduplicatelabels,sec-if-statement-static-semantics-containsduplicatelabels,sec-do-while-statement-static-semantics-containsduplicatelabels,sec-while-statement-static-semantics-containsduplicatelabels,sec-for-statement-static-semantics-containsduplicatelabels,sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels,sec-with-statement-static-semantics-containsduplicatelabels,sec-switch-statement-static-semantics-containsduplicatelabels,sec-labelled-statements-static-semantics-containsduplicatelabels,sec-try-statement-static-semantics-containsduplicatelabels,sec-function-definitions-static-semantics-containsduplicatelabels,sec-module-semantics-static-semantics-containsduplicatelabels" type="sdo">
      <h1>
        정적 의미론: ContainsDuplicateLabels (
        _labelSet_: 문자열들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |StatementList|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasDuplicate_를 첫 번째 |Statement|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicate_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면
          1. 첫 번째 |CaseClauses|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 존재하지 않으면 *false*를 반환한다.
        1. 두 번째 |CaseClauses|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |CaseClauses|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_을 |LabelIdentifier|의 StringValue로 둔다.
        1. _labelSet_이 _label_을 포함하면 *true*를 반환한다.
        1. _newLabelSet_을 _labelSet_과 « _label_ »의 list-concatenation으로 둔다.
        1. |LabelledItem|의 ContainsDuplicateLabels(_newLabelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |Block|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |Block|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |ModuleItemList|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |ModuleItem|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedbreaktarget" oldids="sec-statement-semantics-static-semantics-containsundefinedbreaktarget,sec-block-static-semantics-containsundefinedbreaktarget,sec-if-statement-static-semantics-containsundefinedbreaktarget,sec-do-while-statement-static-semantics-containsundefinedbreaktarget,sec-while-statement-static-semantics-containsundefinedbreaktarget,sec-for-statement-static-semantics-containsundefinedbreaktarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget,sec-break-statement-static-semantics-containsundefinedbreaktarget,sec-with-statement-static-semantics-containsundefinedbreaktarget,sec-switch-statement-static-semantics-containsundefinedbreaktarget,sec-labelled-statements-static-semantics-containsundefinedbreaktarget,sec-try-statement-static-semantics-containsundefinedbreaktarget,sec-function-definitions-static-semantics-containsundefinedbreaktarget,sec-module-semantics-static-semantics-containsundefinedbreaktarget" type="sdo">
      <h1>
        정적 의미론: ContainsUndefinedBreakTarget (
        _labelSet_: 문자열들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |StatementList|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 첫 번째 |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _labelSet_이 |LabelIdentifier|의 StringValue를 포함하지 않으면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면
          1. 첫 번째 |CaseClauses|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 존재하지 않으면 *false*를 반환한다.
        1. 두 번째 |CaseClauses|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |CaseClauses|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_을 |LabelIdentifier|의 StringValue로 둔다.
        1. _newLabelSet_을 _labelSet_과 « _label_ »의 list-concatenation으로 둔다.
        1. |LabelledItem|의 ContainsUndefinedBreakTarget(_newLabelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |ModuleItemList|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |ModuleItem|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedcontinuetarget" oldids="sec-statement-semantics-static-semantics-containsundefinedcontinuetarget,sec-block-static-semantics-containsundefinedcontinuetarget,sec-if-statement-static-semantics-containsundefinedcontinuetarget,sec-do-while-statement-static-semantics-containsundefinedcontinuetarget,sec-while-statement-static-semantics-containsundefinedcontinuetarget,sec-for-statement-static-semantics-containsundefinedcontinuetarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget,sec-continue-statement-static-semantics-containsundefinedcontinuetarget,sec-with-statement-static-semantics-containsundefinedcontinuetarget,sec-switch-statement-static-semantics-containsundefinedcontinuetarget,sec-labelled-statements-static-semantics-containsundefinedcontinuetarget,sec-try-statement-static-semantics-containsundefinedcontinuetarget,sec-function-definitions-static-semantics-containsundefinedcontinuetarget,sec-module-semantics-static-semantics-containsundefinedcontinuetarget" type="sdo">
      <h1>
        정적 의미론: ContainsUndefinedContinueTarget (
        _iterationSet_: 문자열들의 List,
        _labelSet_: 문자열들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>Statement : BlockStatement</emu-grammar>
      <emu-alg>
        1. |BlockStatement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _newIterationSet_을 _iterationSet_과 _labelSet_의 list-concatenation으로 둔다.
        1. |IterationStatement|의 ContainsUndefinedContinueTarget(_newIterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |StatementList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 첫 번째 |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _iterationSet_이 |LabelIdentifier|의 StringValue를 포함하지 않으면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면
          1. 첫 번째 |CaseClauses|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 존재하지 않으면 *false*를 반환한다.
        1. 두 번째 |CaseClauses|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |CaseClauses|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_을 |LabelIdentifier|의 StringValue로 둔다.
        1. _newLabelSet_을 _labelSet_과 « _label_ »의 list-concatenation으로 둔다.
        1. |LabelledItem|의 ContainsUndefinedContinueTarget(_iterationSet_, _newLabelSet_)을 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |ModuleItemList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |ModuleItem|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-function-name-inference">
    <h1>함수 이름 추론(Function Name Inference)</h1>

    <emu-clause id="sec-static-semantics-hasname" oldids="sec-semantics-static-semantics-hasname,sec-function-definitions-static-semantics-hasname,sec-arrow-function-definitions-static-semantics-hasname,sec-generator-function-definitions-static-semantics-hasname,sec-async-generator-function-definitions-static-semantics-hasname,sec-class-definitions-static-semantics-hasname,sec-async-function-definitions-static-semantics-HasName,sec-async-arrow-function-definitions-static-semantics-HasName" type="sdo">
      <h1>정적 의미론: HasName ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. IsFunctionDefinition of _expr_이 *false*이면 *false*를 반환한다.
        1. HasName of _expr_을 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ArrowFunction :
          ArrowParameters `=>` ConciseBody

        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

        ClassExpression :
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier ClassTail
      </emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isfunctiondefinition" oldids="sec-semantics-static-semantics-isfunctiondefinition,sec-grouping-operator-static-semantics-isfunctiondefinition,sec-static-semantics-static-semantics-isfunctiondefinition,sec-update-expressions-static-semantics-isfunctiondefinition,sec-unary-operators-static-semantics-isfunctiondefinition,sec-exp-operator-static-semantics-isfunctiondefinition,sec-multiplicative-operators-static-semantics-isfunctiondefinition,sec-additive-operators-static-semantics-isfunctiondefinition,sec-bitwise-shift-operators-static-semantics-isfunctiondefinition,sec-relational-operators-static-semantics-isfunctiondefinition,sec-equality-operators-static-semantics-isfunctiondefinition,sec-binary-bitwise-operators-static-semantics-isfunctiondefinition,sec-binary-logical-operators-static-semantics-isfunctiondefinition,sec-conditional-operator-static-semantics-isfunctiondefinition,sec-assignment-operators-static-semantics-isfunctiondefinition,sec-comma-operator-static-semantics-isfunctiondefinition,sec-function-definitions-static-semantics-isfunctiondefinition,sec-generator-function-definitions-static-semantics-isfunctiondefinition,sec-async-generator-function-definitions-static-semantics-isfunctiondefinition,sec-class-definitions-static-semantics-isfunctiondefinition,sec-async-function-definitions-static-semantics-IsFunctionDefinition" type="sdo">
      <h1>정적 의미론: IsFunctionDefinition ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. IsFunctionDefinition of _expr_을 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          RegularExpressionLiteral
          TemplateLiteral

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isanonymousfunctiondefinition" type="abstract operation">
      <h1>
        정적 의미론: IsAnonymousFunctionDefinition (
        _expr_: |AssignmentExpression| Parse Node, |Initializer| Parse Node, 또는 |Expression| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>인수가 이름을 바인딩하지 않는 함수 정의인지 판정한다.</dd>
      </dl>
      <emu-alg>
        1. IsFunctionDefinition of _expr_이 *false*이면 *false*를 반환한다.
        1. _hasName_을 HasName of _expr_으로 둔다.
        1. _hasName_이 *true*이면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isidentifierref" oldids="sec-semantics-static-semantics-isidentifierref,sec-static-semantics-static-semantics-isidentifierref" type="sdo">
      <h1>정적 의미론: IsIdentifierRef ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
          CoverParenthesizedExpressionAndArrowParameterList

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-namedevaluation" oldids="sec-grouping-operator-runtime-semantics-namedevaluation,sec-function-definitions-runtime-semantics-namedevaluation,sec-arrow-function-definitions-runtime-semantics-namedevaluation,sec-generator-function-definitions-runtime-semantics-namedevaluation,sec-asyncgenerator-definitions-namedevaluation,sec-class-definitions-runtime-semantics-namedevaluation,sec-async-function-definitions-runtime-semantics-namedevaluation,sec-async-arrow-function-definitions-runtime-semantics-namedevaluation" type="sdo">
      <h1>
        런타임 의미론: NamedEvaluation (
        _name_: 프로퍼티 키 또는 Private Name,
        ): 함수 객체를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. _name_ 인수를 사용하여 _expr_의 NamedEvaluation을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
      <emu-alg>
        1. 단언: IsAnonymousFunctionDefinition(|Expression|)은 *true*이다.
        1. _name_ 인수를 사용하여 |Expression|의 NamedEvaluation을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |FunctionExpression|의 InstantiateOrdinaryFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |GeneratorExpression|의 InstantiateGeneratorFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |AsyncGeneratorExpression|의 InstantiateAsyncGeneratorFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |AsyncFunctionExpression|의 InstantiateAsyncFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |ArrowFunction|의 InstantiateArrowFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |AsyncArrowFunction|의 InstantiateAsyncArrowFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. _sourceText_를 |ClassExpression|이 매치한 소스 텍스트로 둔다.
        1. *undefined*, _name_, _sourceText_ 인수로 |ClassTail|의 ClassDefinitionEvaluation을 ?로 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        정적 의미론: Contains (
        _symbol_: 문법 기호,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>아래에 나열되지 않은 명세의 모든 문법 생성 규칙 대안은 암묵적으로 다음 기본 Contains 정의를 갖는다:</p>
      <emu-alg>
        1. 이 Parse Node의 각 자식 노드 _child_에 대해
          1. _child_가 _symbol_의 인스턴스이면 *true*를 반환한다.
          1. _child_가 비종결(nonterminal) 인스턴스이면
            1. _contained_를 _child_ Contains _symbol_의 결과로 둔다.
            1. _contained_가 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p>부분 구조에 의존하는 정적 의미 규칙은 일반적으로 함수 정의 내부를 들여다보지 않는다.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <emu-alg>
        1. _symbol_이 |ClassBody|이면 *true*를 반환한다.
        1. _symbol_이 |ClassHeritage|이면
          1. |ClassHeritage|가 존재하면 *true*, 아니면 *false*를 반환한다.
        1. |ClassHeritage|가 존재하면
          1. |ClassHeritage| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. |ClassBody|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-note>
        <p>부분 구조에 의존하는 정적 의미 규칙은 일반적으로 |PropertyName|을 제외하고 클래스 본문 내부를 들여다보지 않는다.</p>
      </emu-note>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p>부분 구조에 의존하는 정적 의미 규칙은 일반적으로 `static` 초기화 블록 내부를 들여다보지 않는다.</p>
      </emu-note>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _symbol_이 |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` 중 하나가 아니면 *false*를 반환한다.
        1. |ArrowParameters| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. |ConciseBody| Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_를 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ArrowFormalParameters|로 둔다.
        1. _formals_ Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _symbol_이 |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` 중 하나가 아니면 *false*를 반환한다.
        1. |AsyncConciseBody| Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _symbol_이 |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` 중 하나가 아니면 *false*를 반환한다.
        1. _head_를 |CoverCallExpressionAndAsyncArrowHead|가 커버하는 |AsyncArrowHead|로 둔다.
        1. _head_ Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. |AsyncConciseBody| Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-note>
        <p>Contains는 |ArrowFunction| 또는 |AsyncArrowFunction| 내에서 `new.target`, `this`, `super` 사용을 탐지하는 데 사용된다.</p>
      </emu-note>
      <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
      <emu-alg>
        1. _symbol_이 |MethodDefinition|이면 *true*를 반환한다.
        1. |MethodDefinition|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |MemberExpression| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. _symbol_이 |ReservedWord| `super`이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |CallExpression| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |OptionalChain| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-computedpropertycontains" oldids="sec-object-initializer-static-semantics-computedpropertycontains,sec-method-definitions-static-semantics-computedpropertycontains,sec-generator-function-definitions-static-semantics-computedpropertycontains,sec-async-generator-function-definitions-static-semantics-computedpropertycontains,sec-class-definitions-static-semantics-computedpropertycontains,sec-async-function-definitions-static-semantics-ComputedPropertyContains" type="sdo">
      <h1>
        정적 의미론: ComputedPropertyContains (
        _symbol_: 문법 기호,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ClassElementName : PrivateIdentifier

        PropertyName : LiteralPropertyName
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
      <emu-alg>
        1. |ComputedPropertyName| Contains _symbol_의 결과를 반환한다.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _inList_를 |ClassElementList|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과로 둔다.
        1. _inList_가 *true*이면 *true*를 반환한다.
        1. |ClassElement|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>기타(Miscellaneous)</h1>
    <p>이 연산들은 명세 전반 여러 위치에서 사용된다.</p>

    <emu-clause id="sec-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |FunctionDeclaration|의 InstantiateOrdinaryFunctionObject를 반환한다.
      </emu-alg>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |GeneratorDeclaration|의 InstantiateGeneratorFunctionObject를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |AsyncGeneratorDeclaration|의 InstantiateAsyncGeneratorFunctionObject를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |AsyncFunctionDeclaration|의 InstantiateAsyncFunctionObject를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindinginitialization" oldids="sec-identifiers-runtime-semantics-bindinginitialization,sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization" type="sdo">
      <h1>
        런타임 의미론: BindingInitialization (
        _value_: ECMAScript 언어 값,
        _environment_: Environment Record 또는 *undefined*,
        ): ~unused~를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_environment_에 *undefined*가 전달되면 초기화 값을 할당하는 데 PutValue 연산을 사용해야 함을 나타낸다. 이는 `var` 문 및 일부 non-strict 함수의 매개변수 목록( <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref> 참조)에 해당한다. 이 경우 렉시컬 바인딩은 초기화자 평가 전에 호이스팅되어 사전 초기화된다.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. _name_을 |Identifier|의 StringValue로 둔다.
        1. ? InitializeBoundName(_name_, _value_, _environment_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. ? InitializeBoundName(*"yield"*, _value_, _environment_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. ? InitializeBoundName(*"await"*, _value_, _environment_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingPattern : ObjectBindingPattern</emu-grammar>
      <emu-alg>
        1. ? RequireObjectCoercible(_value_)를 수행한다.
        1. _value_, _environment_ 인수로 |ObjectBindingPattern|의 BindingInitialization을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingPattern : ArrayBindingPattern</emu-grammar>
      <emu-alg>
        1. _iteratorRecord_를 ? GetIterator(_value_, ~sync~)로 둔다.
        1. _result_를 (|ArrayBindingPattern|의 IteratorBindingInitialization(_iteratorRecord_, _environment_))의 Completion으로 둔다.
        1. _iteratorRecord_.[[Done]]이 *false*이면 ? IteratorClose(_iteratorRecord_, _result_)를 반환한다.
        1. ? _result_를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>
        ObjectBindingPattern :
          `{` BindingPropertyList `}`
          `{` BindingPropertyList `,` `}`
      </emu-grammar>
      <emu-alg>
        1. _value_, _environment_ 인수로 |BindingPropertyList|의 PropertyBindingInitialization을 ? 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _excludedNames_를 새 빈 List로 둔다.
        1. _value_, _environment_, _excludedNames_ 인수로 |BindingRestProperty|의 RestBindingInitialization을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _excludedNames_를 _value_, _environment_ 인수로 |BindingPropertyList|의 PropertyBindingInitialization 결과로 둔다.
        1. _value_, _environment_, _excludedNames_ 인수로 |BindingRestProperty|의 RestBindingInitialization을 ?로 반환한다.
      </emu-alg>

      <emu-clause id="sec-initializeboundname" type="abstract operation">
        <h1>
          InitializeBoundName (
            _name_: String,
            _value_: ECMAScript 언어 값,
            _environment_: Environment Record 또는 *undefined*,
          ): ~unused~를 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _environment_가 *undefined*가 아니면
            1. ! _environment_.InitializeBinding(_name_, _value_)를 수행한다.
            1. ~unused~를 반환한다.
          1. Else,
            1. _lhs_를 ? ResolveBinding(_name_)으로 둔다.
            1. ? PutValue(_lhs_, _value_)를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        런타임 의미론: IteratorBindingInitialization (
        _iteratorRecord_: Iterator Record,
        _environment_: Environment Record 또는 *undefined*,
        ): ~unused~를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_environment_에 *undefined*가 전달되면 초기화 값 할당에 PutValue 연산을 사용해야 함을 나타낸다. 이는 non-strict 함수의 매개변수 목록에 해당한다. 그 경우 동일 이름 매개변수 가능성 때문에 사전 초기화된다.</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |Elision|이 존재하면
          1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ? 수행한다.
        1. |BindingRestElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |Elision|이 존재하면
          1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ? 수행한다.
        1. |BindingRestElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |BindingElisionElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ? 수행한다.
        1. |BindingElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. _bindingId_를 |BindingIdentifier|의 StringValue로 둔다.
        1. _lhs_를 ? ResolveBinding(_bindingId_, _environment_)로 둔다.
        1. _v_를 *undefined*로 둔다.
        1. _iteratorRecord_.[[Done]]이 *false*이면
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |Initializer|가 존재하고 _v_가 *undefined*이면
          1. IsAnonymousFunctionDefinition(|Initializer|)이 *true*이면
            1. _v_를 ? NamedEvaluation(|Initializer|, _bindingId_)로 둔다.
          1. Else
            1. _defaultValue_를 ? Evaluation(|Initializer|)로 둔다.
            1. _v_를 ? GetValue(_defaultValue_)로 둔다.
        1. _environment_가 *undefined*이면 ? PutValue(_lhs_, _v_)를 반환한다.
        1. ? InitializeReferencedBinding(_lhs_, _v_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. _v_를 *undefined*로 둔다.
        1. _iteratorRecord_.[[Done]]이 *false*이면
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |Initializer|가 존재하고 _v_가 *undefined*이면
          1. _defaultValue_를 ? Evaluation(|Initializer|)로 둔다.
          1. _v_를 ? GetValue(_defaultValue_)로 둔다.
        1. |BindingPattern|의 BindingInitialization(_v_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. _lhs_를 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_)로 둔다.
        1. _A_를 ! ArrayCreate(0)로 둔다.
        1. _n_을 0으로 둔다.
        1. 반복,
          1. _next_를 ~done~으로 둔다.
          1. _iteratorRecord_.[[Done]]이 *false*이면
            1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. _environment_가 *undefined*이면 ? PutValue(_lhs_, _A_)를 반환한다.
            1. ? InitializeReferencedBinding(_lhs_, _A_)를 반환한다.
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)를 수행한다.
          1. _n_을 _n_ + 1로 둔다.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. _A_를 ! ArrayCreate(0)로 둔다.
        1. _n_을 0으로 둔다.
        1. 반복,
          1. _next_를 ~done~으로 둔다.
          1. _iteratorRecord_.[[Done]]이 *false*이면
            1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. |BindingPattern|의 BindingInitialization(_A_, _environment_)을 ?로 반환한다.
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)를 수행한다.
          1. _n_을 _n_ + 1로 둔다.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |FunctionRestParameter|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |FormalParameter|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. _v_를 *undefined*로 둔다.
        1. 단언: _iteratorRecord_.[[Done]]는 *false*이다.
        1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
        1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |BindingIdentifier|의 BindingInitialization(_v_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_를 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ArrowFormalParameters|로 둔다.
        1. _formals_의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. _v_를 *undefined*로 둔다.
        1. 단언: _iteratorRecord_.[[Done]]는 *false*이다.
        1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
        1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |BindingIdentifier|의 BindingInitialization(_v_, _environment_)을 ?로 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-assignmenttargettype" oldids="sec-identifiers-static-semantics-assignmenttargettype,sec-identifiers-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype,sec-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-grouping-operator-static-semantics-assignmenttargettype,sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget,sec-static-semantics-static-semantics-assignmenttargettype,sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-update-expressions-static-semantics-assignmenttargettype,sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget,sec-unary-operators-static-semantics-assignmenttargettype,sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget,sec-exp-operator-static-semantics-assignmenttargettype,sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget,sec-multiplicative-operators-static-semantics-assignmenttargettype,sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget,sec-additive-operators-static-semantics-assignmenttargettype,sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget,sec-bitwise-shift-operators-static-semantics-assignmenttargettype,sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget,sec-relational-operators-static-semantics-assignmenttargettype,sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget,sec-equality-operators-static-semantics-assignmenttargettype,sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-bitwise-operators-static-semantics-assignmenttargettype,sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-logical-operators-static-semantics-assignmenttargettype,sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-conditional-operator-static-semantics-assignmenttargettype,sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget,sec-assignment-operators-static-semantics-assignmenttargettype,sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget,sec-comma-operator-static-semantics-assignmenttargettype,sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" type="sdo">
      <h1>정적 의미론: AssignmentTargetType ( ): ~simple~, ~web-compat~, 또는 ~invalid~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. IsStrict(this |IdentifierReference|)가 *true*이고 |Identifier|의 StringValue가 *"eval"*, *"arguments"* 중 하나이면 ~invalid~를 반환한다.
        1. ~simple~을 반환한다.
      </emu-alg>
      <emu-grammar>
        IdentifierReference :
          `yield`
          `await`

        CallExpression :
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MemberExpression `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. ~simple~을 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          CoverParenthesizedExpressionAndArrowParameterList
      </emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. _expr_의 AssignmentTargetType을 반환한다.
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. [id="step-assignmenttargettype-web-compat", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-runtime-errors-for-function-call-assignment-targets" title></emu-xref>를 지원하고 IsStrict(this |CallExpression|)이 *false*이면
          1. ~web-compat~을 반환한다.
        1. ~invalid~를 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral

        CallExpression :
          SuperCall
          ImportCall
          CallExpression TemplateLiteral

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression TemplateLiteral
          `new` MemberExpression Arguments

        NewTarget :
          `new` `.` `target`

        ImportMeta :
          `import` `.` `meta`

        LeftHandSideExpression :
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. ~invalid~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-propname" oldids="sec-object-initializer-static-semantics-propname,sec-method-definitions-static-semantics-propname,sec-generator-function-definitions-static-semantics-propname,sec-async-generator-function-definitions-static-semantics-propname,sec-class-definitions-static-semantics-propname,sec-async-function-definitions-static-semantics-PropName" type="sdo">
      <h1>정적 의미론: PropName ( ): String 또는 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
      <emu-alg>
        1. |IdentifierReference|의 StringValue를 반환한다.
      </emu-alg>
      <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. |PropertyName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : IdentifierName

        AttributeKey : IdentifierName
      </emu-grammar>
      <emu-alg>
        1. |IdentifierName|의 StringValue를 반환한다.
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : StringLiteral

        AttributeKey : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. |StringLiteral|의 SV를 반환한다.
      </emu-alg>
      <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
      <emu-alg>
        1. _nbr_를 |NumericLiteral|의 NumericValue로 둔다.
        1. ! ToString(_nbr_)을 반환한다.
      </emu-alg>
      <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>실행 가능한 코드와 실행 컨텍스트(Executable Code and Execution Contexts)</h1>

  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>Environment Record</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn>는 ECMAScript 코드의 렉시컬 중첩 구조를 기반으로 |Identifier|들을 특정 변수와 함수에 연계(association)하기 위해 사용되는 명세 타입이다. 보통 Environment Record는 |FunctionDeclaration|, |BlockStatement|, |TryStatement|의 |Catch| 절과 같은 ECMAScript 코드의 특정 구문 구조와 연관된다. 그러한 코드가 실행될 때마다 그 코드가 생성하는 식별자 바인딩을 기록하기 위해 새로운 Environment Record가 생성된다.</p>
    <p>모든 Environment Record는 [[OuterEnv]] 필드를 가지며, 이는 *null*이거나 바깥(Environment Record) 환경 레코드에 대한 참조이다. 이는 Environment Record 값들의 논리적 중첩을 모델링하는 데 사용된다. (내부) Environment Record의 바깥 참조는 논리적으로 그 내부 Environment Record를 둘러싸는 Environment Record에 대한 참조이다. 바깥 Environment Record 역시 자체의 바깥 Environment Record를 가질 수 있다. 하나의 Environment Record는 여러 내부 Environment Record의 바깥 환경으로 사용될 수 있다. 예를 들어, 어떤 |FunctionDeclaration|이 두 개의 중첩된 |FunctionDeclaration|을 포함한다면 각각의 중첩 함수 Environment Record의 바깥 Environment Record는 둘러싼 함수의 현재 평가에 대한 Environment Record가 된다.</p>
    <p>Environment Record는 순수히 명세 메커니즘이며 ECMAScript 구현의 특정한 실체(artefact)에 대응할 필요는 없다. ECMAScript 프로그램이 그러한 값을 직접 접근하거나 조작하는 것은 불가능하다.</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>Environment Record 타입 계층(The Environment Record Type Hierarchy)</h1>
      <p>Environment Record는 단순한 객체 지향 계층에 존재한다고 생각할 수 있는데, Environment Record 자체가 추상 클래스이고 세 개의 구체 하위 클래스(Declarative Environment Record, Object Environment Record, Global Environment Record)가 있다. Function Environment Record와 Module Environment Record는 Declarative Environment Record의 하위 클래스이다.</p>
      <ul>
        <li>
          <p>Environment Record (abstract)</p>
          <ul>
            <li>
              <p><em>Declarative Environment Record</em>는 |FunctionDeclaration|, |VariableDeclaration|, |Catch| 절처럼 식별자 바인딩을 ECMAScript 언어 값과 직접 연관시키는 ECMAScript 언어 구문 요소들의 효과를 정의하는 데 사용된다.</p>
              <ul>
                <li>
                  <p><em>Function Environment Record</em>는 ECMAScript 함수 객체의 호출에 대응하며 함수 내 최상위 선언들에 대한 바인딩을 포함한다. 새로운 `this` 바인딩을 설정할 수 있고 `super` 메서드 호출을 지원하기 위한 상태도 포착한다.</p>
                </li>
                <li>
                  <p><em>Module Environment Record</em>는 |Module|의 최상위 선언 바인딩을 포함한다. 또한 |Module|이 명시적으로 import한 바인딩을 포함한다. 그 [[OuterEnv]]는 Global Environment Record이다.</p>
                </li>
              </ul>
            </li>
            <li>
              <p><em>Object Environment Record</em>는 |WithStatement|처럼 식별자 바인딩을 어떤 객체의 프로퍼티와 연관시키는 ECMAScript 요소들의 효과를 정의하는 데 사용된다.</p>
            </li>
            <li>
              <p><em>Global Environment Record</em>는 |Script| 전역 선언에 사용된다. 바깥 환경을 가지지 않으며 [[OuterEnv]]는 *null*이다. 사전 채워진 식별자 바인딩을 가질 수 있고 관련된 전역 객체를 포함하며 그 전역 객체의 프로퍼티는 일부 전역 환경 식별자 바인딩을 제공한다. ECMAScript 코드가 실행되면서 전역 객체에 프로퍼티가 추가될 수 있고 초기 프로퍼티가 수정될 수 있다.</p>
            </li>
          </ul>
        </li>
      </ul>

      <p>Environment Record 추상 클래스는 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>에 정의된 추상 명세 메서드를 포함한다. 이 추상 메서드들은 각 구체 하위 클래스마다 구별되는 구체 알고리즘을 가진다.</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Environment Record의 추상 메서드(Abstract Methods of Environment Records)" oldids="table-15">
        <table>
          <thead>
            <tr>
              <th>
                메서드(Method)
              </th>
              <th>
                목적(Purpose)
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Environment Record가 문자열 값 _N_에 대한 바인딩을 가지는지 결정한다. 있다면 *true*, 없으면 *false*를 반환.
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Environment Record에 새이지만 아직 초기화되지 않은 변경 가능(mutable) 바인딩을 생성한다. 문자열 값 _N_은 바운드 이름 텍스트다. Boolean 인자 _D_가 *true*이면 해당 바인딩은 이후 삭제될 수 있다.
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Environment Record에 새이지만 아직 초기화되지 않은 변경 불가능(immutable) 바인딩을 생성한다. 문자열 값 _N_은 바운드 이름 텍스트다. _S_가 *true*이면 초기화 후 설정하려는 모든 시도는 (참조하는 연산의 strict 모드 설정과 무관하게) 항상 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              Environment Record 내 이미 존재하지만 초기화되지 않은 바인딩의 값을 설정한다. 문자열 값 _N_은 바운드 이름 텍스트. _V_는 바인딩에 대한 값이며 임의의 ECMAScript 언어 타입 값이다.
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              이미 존재하는 mutable 바인딩의 값을 설정한다. 문자열 값 _N_은 바운드 이름 텍스트, _V_는 값, _S_는 Boolean 플래그. _S_가 *true*이고 바인딩을 설정할 수 없다면 *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              이미 존재하는 바인딩의 값을 반환한다. 문자열 값 _N_은 바운드 이름 텍스트. _S_는 strict 모드 코드에서 기원했거나 strict 모드 참조语 의미를 요구하는지 식별하는 데 사용된다. _S_가 *true*이고 바인딩이 존재하지 않으면 *ReferenceError*를 던진다. 바인딩이 존재하지만 초기화되지 않았다면 _S_ 값과 무관하게 *ReferenceError*를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              바인딩을 삭제한다. 문자열 값 _N_은 바운드 이름 텍스트. _N_에 대한 바인딩이 존재하면 제거하고 *true* 반환. 존재하지만 제거 불가하면 *false* 반환. 존재하지 않으면 *true* 반환.
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              Environment Record가 `this` 바인딩을 설정하는지 결정. 그렇다면 *true*, 아니면 *false*.
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              Environment Record가 `super` 메서드 바인딩을 설정하는지 결정. 그렇다면 *true*, 아니면 *false*. *true*이면 해당 Environment Record는 Function Environment Record임을 시사하지만, 그 역은 성립하지 않는다.
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              이 Environment Record가 `with` 문과 연관되면 with 객체를 반환. 아니면 *undefined* 반환.
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>Declarative Environment Record</h1>
        <p>각 <dfn variants="Declarative Environment Records">Declarative Environment Record</dfn>는 변수, constant, let, class, module, import 그리고/또는 function 선언을 포함하는 ECMAScript 프로그램 스코프와 연관된다. Declarative Environment Record는 그 스코프에 포함된 선언들이 정의한 식별자 집합을 바인딩한다.</p>

        <emu-clause id="sec-declarative-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean을 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>인수 식별자가 이 레코드에 의해 바인딩된 식별자 중 하나인지 판정한다.</dd>
          </dl>
          <emu-alg>
            1. _envRec_이 _N_에 대한 바인딩을 가지고 있으면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~를 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 이름 _N_에 대한 새로운 mutable 바인딩을 생성한다. 이미 존재해서는 안 된다. _D_가 *true*이면 삭제 대상 표시.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 이미 _N_ 바인딩을 갖지 않는다.
            1. _envRec_ 안에 _N_에 대한 초기화되지 않은 mutable 바인딩을 생성하고 _D_가 *true*이면 이후 DeleteBinding 호출로 삭제 가능함을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: String,
              _S_: Boolean,
            ): ~unused~를 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 이름 _N_에 대한 immutable 바인딩을 생성. 이미 존재해서는 안 된다. _S_가 *true*이면 strict 바인딩으로 표시.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 이미 _N_ 바인딩을 갖지 않는다.
            1. _envRec_에 _N_ immutable 바인딩을 생성하고 초기화되지 않았음을 기록. _S_가 *true*이면 strict 바인딩임을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
            ): ~unused~를 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이미 존재하는 식별자 _N_의 현재 바인딩 값(bound value)을 _V_로 설정한다. _N_에 대한 초기화되지 않은 바인딩이 이미 있어야 한다.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 _N_에 대한 초기화되지 않은 바인딩을 가져야 한다.
            1. _envRec_에서 _N_의 바운드 값을 _V_로 설정.
            1. <emu-not-ref>Record</emu-not-ref> _envRec_의 _N_ 바인딩이 초기화되었음을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 현재 바인딩 값을 _V_로 변경 시도. 보통 바인딩은 이미 존재하지만 드물게 없을 수도 있다. 바인딩이 immutable이고 _S_가 *true*이면 *TypeError*.</dd>
          </dl>
          <emu-alg>
            1. [id="step-setmutablebinding-missing-binding"] _envRec_에 _N_ 바인딩이 없다면
              1. _S_가 *true*이면 *ReferenceError* 예외.
              1. ! _envRec_.CreateMutableBinding(_N_, *true*) 수행.
              1. ! _envRec_.InitializeBinding(_N_, _V_) 수행.
              1. ~unused~ 반환.
            1. _envRec_에서 _N_ 바인딩이 strict 바인딩이면 _S_를 *true*로 설정.
            1. _envRec_에서 _N_ 바인딩이 아직 초기화되지 않았다면 *ReferenceError* 예외.
            1. Else if _envRec_에서 _N_ 바인딩이 mutable이면
              1. 그 값을 _V_로 변경.
            1. Else
              1. 단언: immutable 바인딩 값을 변경하려는 시도.
              1. _S_가 *true*이면 *TypeError* 예외.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>단계 <emu-xref href="#step-setmutablebinding-missing-binding"></emu-xref>에서 바인딩이 누락되는 ECMAScript 코드 예:</p>
            <pre><code class="javascript">function f() { eval("var x; x = (delete x, 0);"); }</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이름이 _N_인 바인딩된 식별자의 값을 반환. 바인딩이 존재하지만 초기화되지 않았으면 _S_와 무관하게 *ReferenceError*.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 _N_ 바인딩을 가진다.
            1. _envRec_의 _N_ 바인딩이 초기화되지 않았다면 *ReferenceError* 예외.
            1. 현재 _envRec_에 _N_으로 바인딩된 값을 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean을 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>삭제 대상으로 명시적으로 지정된 바인딩만 삭제할 수 있다.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 _N_ 바인딩을 가진다.
            1. _envRec_의 _N_ 바인딩이 삭제 불가라면 *false* 반환.
            1. _envRec_에서 _N_ 바인딩 제거.
            1. *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>일반 Declarative Environment Record(즉 Function Environment Record나 Module Environment Record가 아닌 것)는 `this` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>일반 Declarative Environment Record는 `super` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>Object Environment Record</h1>
        <p>각 <dfn variants="Object Environment Records">Object Environment Record</dfn>는 <em>binding object</em>라 불리는 객체와 연관된다. Object Environment Record는 그 binding object의 프로퍼티 이름과 직접 대응하는 문자열 식별자 이름 집합을 바인딩한다. |IdentifierName| 형태가 아닌 프로퍼티 키는 포함되지 않는다. own 및 상속 프로퍼티 모두 [[Enumerable]] 속성과 무관하게 포함된다. 객체에 프로퍼티가 동적으로 추가/삭제될 수 있으므로 Object Environment Record가 바인딩하는 식별자 집합은 프로퍼티를 추가/삭제하는 어떤 연산의 부수 효과로 잠재적으로 변화할 수 있다. 그러한 부수 효과로 생성된 바인딩은 대응 프로퍼티의 Writable 속성이 *false*일지라도 mutable 바인딩으로 간주된다. Object Environment Record에는 immutable 바인딩이 존재하지 않는다.</p>
        <p>`with` 문(<emu-xref href="#sec-with-statement"></emu-xref>)에 대해 생성된 Object Environment Record는 함수 호출에서 사용할 암묵적 *this* 값을 그 binding object로 제공할 수 있다. 이 기능은 Boolean [[IsWithEnvironment]] 필드로 제어된다.</p>
        <p>Object Environment Record는 <emu-xref href="#table-additional-fields-of-object-environment-records"></emu-xref>에 나열된 추가 상태 필드를 가진다.</p>
        <emu-table id="table-additional-fields-of-object-environment-records" caption="Object Environment Record의 추가 필드(Additional Fields of Object Environment Records)">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름(Field Name)
                </th>
                <th>
                  값(Value)
                </th>
                <th>
                  의미(Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[BindingObject]]
              </td>
              <td>
                객체(Object)
              </td>
              <td>
                이 Environment Record의 바인딩 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[IsWithEnvironment]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                이 Environment Record가 `with` 문을 위해 생성되었는지 여부.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-object-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>연관된 binding object가 이름 _N_인 프로퍼티를 가지는지 판정한다.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. _foundBinding_을 ? HasProperty(_bindingObject_, _N_)로 둔다.
            1. _foundBinding_이 *false*이면 *false* 반환.
            1. _envRec_.[[IsWithEnvironment]]가 *false*이면 *true* 반환.
            1. _unscopables_를 ? Get(_bindingObject_, %Symbol.unscopables%)로 둔다.
            1. _unscopables_가 Object이면
              1. _blocked_를 ToBoolean(? Get(_unscopables_, _N_))로 둔다.
              1. _blocked_가 *true*이면 *false* 반환.
            1. *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>Environment Record의 binding object에 이름 _N_ 프로퍼티를 생성하고 값을 *undefined*로 초기화. _D_가 *true*이면 새 프로퍼티 [[Configurable]]을 *true*, 아니면 *false*.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }) 수행.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>보통 _envRec_은 _N_ 바인딩을 갖지 않지만 갖고 있다면 DefinePropertyOrThrow 의미론이 기존 바인딩을 교체/섀도우하거나 abrupt completion을 유발할 수 있다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>Object Environment Record의 CreateImmutableBinding 구체 메서드는 이 명세 내에서 사용되지 않는다.</p>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이름 _N_인 바인딩 객체 프로퍼티의 값을 _V_로 설정.</dd>
          </dl>
          <emu-alg>
            1. ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>이 명세에서 Object Environment Record에 대한 모든 CreateMutableBinding 사용은 같은 이름에 대한 InitializeBinding 호출로 즉시 이어지므로, 초기화 상태를 명시적으로 추적하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>연관된 binding object의 프로퍼티 _N_ 값을 _V_로 설정 시도. 보통 존재하지만 없거나 쓰기 불가능이면 _S_에 따라 오류 처리.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. _stillExists_를 ? HasProperty(_bindingObject_, _N_)로 둔다.
            1. _stillExists_가 *false*이고 _S_가 *true*이면 *ReferenceError* 예외.
            1. ? Set(_bindingObject_, _N_, _V_, _S_) 수행.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>binding object의 이름 _N_ 프로퍼티 값을 반환. 존재하지 않을 경우 _S_에 따라 결과 결정.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. _value_를 ? HasProperty(_bindingObject_, _N_)로 둔다.
            1. _value_가 *false*이면
              1. _S_가 *false*이면 *undefined* 반환; 아니면 *ReferenceError* 예외.
            1. ? Get(_bindingObject_, _N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>[[Configurable]]이 *true*인 환경 객체 프로퍼티에 대응되는 바인딩만 삭제 가능.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. ? <emu-meta effects="user-code">_bindingObject_.[[Delete]]</emu-meta>(_N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>Object Environment Record는 `this` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>Object Environment Record는 `super` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): Object 또는 *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[IsWithEnvironment]]가 *true*이면 _envRec_.[[BindingObject]] 반환.
            1. 아니면 *undefined* 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records" oldids="function-environment">
        <h1>Function Environment Record</h1>
        <p><dfn variants="Function Environment Records">Function Environment Record</dfn>는 함수의 최상위 스코프를 나타내는 Declarative Environment Record이며 함수가 |ArrowFunction|이 아니면 `this` 바인딩을 제공한다. 함수가 |ArrowFunction|이 아니고 `super`를 참조하는 경우 그 Function Environment Record는 함수 내에서 `super` 메서드 호출을 수행하는 데 사용되는 상태도 포함한다.</p>
        <p>Function Environment Record는 <emu-xref href="#table-additional-fields-of-function-environment-records"></emu-xref>에 나열된 추가 상태 필드를 가진다.</p>
        <emu-table id="table-additional-fields-of-function-environment-records" caption="Function Environment Record의 추가 필드(Additional Fields of Function Environment Records)" oldids="table-16">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                ECMAScript 언어 값
              </td>
              <td>
                이 함수 호출에 사용되는 *this* 값.
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                ~lexical~, ~initialized~, 또는 ~uninitialized~
              </td>
              <td>
                값이 ~lexical~이면 이는 |ArrowFunction|이며 로컬 *this* 값이 없다.
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                ECMAScript 함수 객체
              </td>
              <td>
                이 Environment Record를 생성한 호출의 대상 함수 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                생성자 또는 *undefined*
              </td>
              <td>
                [[Construct]] 내부 메서드로 생성되었다면 [[Construct]] _newTarget_ 매개변수의 값; 아니면 *undefined*.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>Function Environment Record는 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>에 나열된 모든 Declarative Environment Record 메서드를 지원하고 HasThisBinding 및 HasSuperBinding을 제외한 명세는 동일하다. 추가로 <emu-xref href="#table-additional-methods-of-function-environment-records"></emu-xref>에 나열된 메서드를 지원한다:</p>
        <emu-table id="table-additional-methods-of-function-environment-records" caption="Function Environment Record의 추가 메서드(Additional Methods of Function Environment Records)" oldids="table-17">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                이 Environment Record의 `this` 바인딩 값을 반환. 초기화되지 않았으면 *ReferenceError*.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-bindthisvalue" type="abstract operation">
          <h1>
            BindThisValue (
              _envRec_: Function Environment Record,
              _V_: ECMAScript 언어 값,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_envRec_.[[ThisValue]]를 설정하고 초기화되었음을 기록한다.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_.[[ThisBindingStatus]]는 ~lexical~이 아니다.
            1. _envRec_.[[ThisBindingStatus]]가 ~initialized~이면 *ReferenceError* 예외.
            1. _envRec_.[[ThisValue]]를 _V_로 설정.
            1. _envRec_.[[ThisBindingStatus]]를 ~initialized~로 설정.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): Boolean</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[ThisBindingStatus]]가 ~lexical~이면 *false*, 아니면 *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): Boolean</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[ThisBindingStatus]]가 ~lexical~이면 *false* 반환.
            1. _envRec_.[[FunctionObject]].[[HomeObject]]가 *undefined*이면 *false*, 아니면 *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): ECMAScript 언어 값 또는 throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_.[[ThisBindingStatus]]는 ~lexical~이 아니다.
            1. _envRec_.[[ThisBindingStatus]]가 ~uninitialized~이면 *ReferenceError* 예외.
            1. _envRec_.[[ThisValue]] 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getsuperbase" type="abstract operation">
          <h1>
            GetSuperBase (
              _envRec_: Function Environment Record,
            ): Object, *null*, 또는 *undefined*
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_envRec_에 바인딩된 `super` 프로퍼티 접근의 기반 객체를 반환한다. *undefined* 값은 그러한 접근이 런타임 오류를 낼 것임을 나타낸다.</dd>
          </dl>
          <emu-alg>
            1. _home_을 _envRec_.[[FunctionObject]].[[HomeObject]]로 둔다.
            1. _home_이 *undefined*이면 *undefined* 반환.
            1. 단언: _home_은 ordinary object.
            1. ! _home_.[[GetPrototypeOf]]() 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>Global Environment Record</h1>
        <p><dfn variants="Global Environment Records">Global Environment Record</dfn>는 공통 realm에서 처리되는 모든 ECMAScript |Script| 요소가 공유하는 가장 바깥 스코프를 나타낸다. Global Environment Record는 내장(global) 전역(<emu-xref href="#sec-global-object"></emu-xref> 절), 전역 객체의 프로퍼티 및 |Script| 내 모든 최상위 선언(<emu-xref href="#sec-static-semantics-toplevellexicallyscopeddeclarations"></emu-xref>, <emu-xref href="#sec-static-semantics-toplevelvarscopeddeclarations"></emu-xref>)의 바인딩을 제공한다.</p>
        <p>Global Environment Record는 논리적으로 단일 레코드이지만 Object Environment Record와 Declarative Environment Record를 캡슐화한 합성체로 명세된다. Object Environment Record는 관련 Realm Record의 전역 객체를 기본 객체로 가진다. 이 전역 객체는 Global Environment Record의 GetThisBinding 구체 메서드가 반환하는 값이다. Global Environment Record의 Object Environment Record 구성 요소는 모든 내장 전역(<emu-xref href="#sec-global-object"></emu-xref>)과 전역 코드에 포함된 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableStatement|이 도입한 바인딩을 포함한다. 전역 코드의 다른 ECMAScript 선언에 대한 바인딩은 Global Environment Record의 Declarative Environment Record 구성 요소에 들어 있다.</p>
        <p>프로퍼티는 전역 객체에 직접 생성될 수 있다. 따라서 Global Environment Record의 Object Environment Record 구성 요소는 선언에 의해 명시적으로 생성된 바인딩과 전역 객체의 프로퍼티로 암묵적으로 생성된 바인딩을 모두 포함할 수 있다. 어느 바인딩이 선언을 통해 명시적으로 생성되었는지 식별하기 위해 Global Environment Record는 CreateGlobalVarBinding 및 CreateGlobalFunctionBinding 추상 연산을 사용해 바인딩된 이름 목록을 유지한다.</p>
        <p>Global Environment Record는 <emu-xref href="#table-additional-fields-of-global-environment-records"></emu-xref>에 나열된 추가 필드와 <emu-xref href="#table-additional-methods-of-global-environment-records"></emu-xref>에 나열된 추가 메서드를 가진다.</p>
        <emu-table id="table-additional-fields-of-global-environment-records" caption="Global Environment Record의 추가 필드(Additional Fields of Global Environment Records)" oldids="table-18">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ObjectRecord]]
              </td>
              <td>
                Object Environment Record
              </td>
              <td>
                바인딩 객체는 전역 객체. 관련 realm의 전역 코드 내 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableDeclaration| 바인딩과 전역 내장 바인딩을 포함.
              </td>
            </tr>
            <tr>
              <td>
                [[GlobalThisValue]]
              </td>
              <td>
                Object
              </td>
              <td>
                전역 스코프에서 `this`가 반환하는 값. 호스트는 임의의 ECMAScript Object 값을 제공할 수 있다.
              </td>
            </tr>
            <tr>
              <td>
                [[DeclarativeRecord]]
              </td>
              <td>
                Declarative Environment Record
              </td>
              <td>
                <emu-not-ref>Contains</emu-not-ref> 전역 코드 선언 중 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableDeclaration|을 제외한 모든 선언 바인딩.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-additional-methods-of-global-environment-records" caption="Global Environment Record의 추가 메서드(Additional Methods of Global Environment Records)" oldids="table-19">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                이 Environment Record의 `this` 바인딩 값을 반환.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-global-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>인수 식별자가 레코드에 의해 바인딩된 식별자 중 하나인지 판정.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면 *true* 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.HasBinding</emu-meta>(_N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 _N_ mutable 바인딩을 새로 생성. 관련 DeclarativeRecord에 생성. 이미 존재하면 안 됨. _D_가 *true*면 삭제 가능 표시.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면 *TypeError* 예외.
            1. ! _DclRec_.CreateMutableBinding(_N_, _D_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: String,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 _N_ immutable 바인딩 생성. 이미 존재하면 안 됨. _S_가 *true*이면 strict 바인딩.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면 *TypeError* 예외.
            1. ! _DclRec_.CreateImmutableBinding(_N_, _S_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 현재 바인딩 값을 _V_로 설정. _N_에 대한 초기화되지 않은 바인딩이 이미 존재해야 한다.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ! _DclRec_.InitializeBinding(_N_, _V_) 반환.
            1. 단언: 바인딩이 존재한다면 Object Environment Record에 있다.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 현재 바인딩 값을 _V_로 변경 시도. immutable 바인딩이고 _S_가 *true*이면 *TypeError*. 프로퍼티 _N_은 보통 존재하지만 없거나 현재 writable이 아닐 수도 있으며 이는 _S_에 따라 처리.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ? _DclRec_.SetMutableBinding(_N_, _V_, _S_) 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 값을 반환. 바인딩이 초기화되지 않았으면 *ReferenceError*. 프로퍼티 _N_은 보통 존재하지만 없거나 writable이 아닐 수도 있는데 이는 _S_에 따라 처리.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ? _DclRec_.GetBindingValue(_N_, _S_) 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>삭제 대상으로 명시된 바인딩만 삭제 가능.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ! _DclRec_.DeleteBinding(_N_) 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? HasOwnProperty(_globalObject_, _N_)로 둔다.
            1. _existingProp_이 *true*이면
              1. ? <emu-meta effects="user-code">_ObjRec_.DeleteBinding</emu-meta>(_N_) 반환.
            1. *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *true* 반환.
          </emu-alg>
          <emu-note>
            <p>Global Environment Record는 항상 `this` 바인딩을 제공한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>Global Environment Record는 `super` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): Object를 담는 normal completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[GlobalThisValue]] 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-haslexicaldeclaration" type="abstract operation">
          <h1>
            HasLexicalDeclaration (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>인수 식별자가 _envRec_에서 |LexicalDeclaration| 또는 |ClassDeclaration| 같은 렉시컬 선언을 사용해 생성된 바인딩을 가지는지 판정.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasrestrictedglobalproperty" type="abstract operation">
          <h1>
            HasRestrictedGlobalProperty (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>인수 식별자가 전역 객체의, 전역 렉시컬 바인딩으로 섀도우 되어서는 안 되는 프로퍼티 이름인지 판정.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)로 둔다.
            1. _existingProp_이 *undefined*이면 *false* 반환.
            1. _existingProp_.[[Configurable]]이 *true*이면 *false* 반환.
            1. *true* 반환.
          </emu-alg>
          <emu-note>
            <p>프로퍼티는 var나 function 선언 대신 직접 전역 객체에 존재할 수도 있다. 글로벌 렉시컬 바인딩은 전역 객체의 non-configurable 프로퍼티와 같은 이름으로 생성될 수 없다. *"undefined"* 전역 프로퍼티가 예.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalvar" type="abstract operation">
          <h1>
            CanDeclareGlobalVar (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>같은 _N_으로 CreateGlobalVarBinding 호출이 성공할지 여부 결정. 중복 var 선언 및 기존 전역 객체 프로퍼티에 대한 var 선언 허용.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _hasProperty_를 ? HasOwnProperty(_globalObject_, _N_)로 둔다.
            1. _hasProperty_가 *true*이면 *true* 반환.
            1. ? IsExtensible(_globalObject_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalfunction" type="abstract operation">
          <h1>
            CanDeclareGlobalFunction (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>같은 _N_으로 CreateGlobalFunctionBinding 호출이 성공할지 여부 결정.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)로 둔다.
            1. _existingProp_이 *undefined*이면 ? IsExtensible(_globalObject_) 반환.
            1. _existingProp_.[[Configurable]]이 *true*이면 *true* 반환.
            1. IsDataDescriptor(_existingProp_)가 *true*이고 _existingProp_ 속성 값이 { [[Writable]]: *true*, [[Enumerable]]: *true* }이면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalvarbinding" type="abstract operation">
          <h1>
            CreateGlobalVarBinding (
              _envRec_: Global Environment Record,
              _N_: String,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>연관된 Object Environment Record에 mutable 바인딩을 생성·초기화. 이미 존재하면 재사용되고 초기화된 것으로 간주.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _hasProperty_를 ? HasOwnProperty(_globalObject_, _N_)로 둔다.
            1. _extensible_을 ? IsExtensible(_globalObject_)로 둔다.
            1. _hasProperty_가 *false*이고 _extensible_이 *true*이면
              1. ? <emu-meta effects="user-code">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_) 수행.
              1. ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalfunctionbinding" type="abstract operation">
          <h1>
            CreateGlobalFunctionBinding (
              _envRec_: Global Environment Record,
              _N_: String,
              _V_: ECMAScript 언어 값,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>연관된 Object Environment Record에 mutable 바인딩을 생성·초기화. 이미 존재하면 대체.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)로 둔다.
            1. _existingProp_이 *undefined*이거나 _existingProp_.[[Configurable]]이 *true*이면
              1. _desc_를 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }로 둔다.
            1. Else
              1. _desc_를 PropertyDescriptor { [[Value]]: _V_ }로 둔다.
            1. ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_) 수행.
            1. [id="step-createglobalfunctionbinding-set"] ? Set(_globalObject_, _N_, _V_, *false*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>전역 함수 선언은 항상 전역 객체의 own 프로퍼티로 표현된다. 가능하면 기존 own 프로퍼티가 표준 속성 집합으로 재구성된다. 단계 <emu-xref href="#step-createglobalfunctionbinding-set"></emu-xref>은 InitializeBinding 구체 메서드 호출과 동등하며 _globalObject_가 Proxy이면 동일한 Proxy 트랩 호출 순서를 만든다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-module-environment-records" oldids="module-environment">
        <h1>Module Environment Record</h1>
        <p><dfn variants="Module Environment Records">Module Environment Record</dfn>는 ECMAScript |Module|의 바깥 스코프를 나타내는 Declarative Environment Record이며, 일반 mutable/immutable 바인딩 외에 다른 Environment Record에 존재하는 대상 바인딩에 간접 접근을 제공하는 immutable import 바인딩도 제공한다.</p>
        <p>Module Environment Record는 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>에 나열된 모든 Declarative Environment Record 메서드를 지원하며 GetBindingValue, DeleteBinding, HasThisBinding, GetThisBinding을 제외하고 동일한 명세를 공유한다. 추가로 <emu-xref href="#table-additional-methods-of-module-environment-records"></emu-xref>에 나열된 메서드를 지원한다:</p>
        <emu-table id="table-additional-methods-of-module-environment-records" caption="Module Environment Record의 추가 메서드(Additional Methods of Module Environment Records)" oldids="table-20">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                이 Environment Record의 `this` 바인딩 값을 반환.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-module-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이름 _N_인 바인딩된 식별자 값을 반환. 간접 바인딩이면 대상 바인딩 값을 반환. 바인딩이 존재하지만 초기화되지 않았으면 *ReferenceError*.</dd>
          </dl>
          <emu-alg>
            1. 단언: _S_는 *true*.
            1. 단언: _envRec_은 _N_ 바인딩을 가진다.
            1. _N_에 대한 바인딩이 간접 바인딩이면
              1. 이 _N_ 바인딩 생성 시 제공된 간접 값 _M_, _N2_를 둔다.
              1. _targetEnv_를 _M_.[[Environment]]로 둔다.
              1. _targetEnv_가 ~empty~이면 *ReferenceError* 예외.
              1. ? <emu-meta effects="user-code">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*) 반환.
            1. _envRec_의 _N_ 바인딩이 초기화되지 않았으면 *ReferenceError* 예외.
            1. 현재 _envRec_에 _N_으로 바인딩된 값을 반환.
          </emu-alg>
          <emu-note>
            <p>_S_는 항상 *true*인데 |Module|은 항상 strict 모드 코드이기 때문이다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>Module Environment Record의 DeleteBinding 구체 메서드는 이 명세 내에서 사용되지 않는다.</p>
          <emu-note>
            <p>Module Environment Record는 strict 코드 내에서만 사용되고 초기 에러 규칙이 strict 코드에서 delete 연산자가 Module Environment Record 바인딩으로 해석될 Reference Record에 적용되는 것을 방지한다. <emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref> 참조.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *true* 반환.
          </emu-alg>
          <emu-note>
            <p>Module Environment Record는 항상 `this` 바인딩을 제공한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): *undefined*를 담는 normal completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createimportbinding" type="abstract operation">
          <h1>
            CreateImportBinding (
              _envRec_: Module Environment Record,
              _N_: String,
              _M_: Module Record,
              _N2_: String,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>이름 _N_에 대한 새로 초기화된 immutable 간접 바인딩을 생성. _envRec_에 _N_ 바인딩이 이미 존재해서는 안 됨. _N2_는 _M_의 Module Environment Record에 존재하는 바인딩 이름. 새 바인딩의 값 접근은 대상 바인딩 값을 간접적으로 접근.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 이미 _N_ 바인딩을 갖지 않는다.
            1. 단언: _M_.[[Environment]]가 인스턴스화될 때 _N2_에 대한 direct 바인딩을 가진다.
            1. _envRec_에 _N_ immutable 간접 바인딩을 생성하여 _M_, _N2_를 대상 바인딩으로 참조하고 초기화되었음을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>Environment Record 연산(Environment Record Operations)</h1>
      <p>다음 추상 연산들은 명세에서 Environment Record를 조작하기 위해 사용된다:</p>

      <emu-clause id="sec-getidentifierreference" type="abstract operation">
        <h1>
          GetIdentifierReference (
            _env_: Environment Record 또는 *null*,
            _name_: String,
            _strict_: Boolean,
          ): Reference Record 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _env_가 *null*이면
            1. Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 반환.
          1. _exists_를 ? <emu-meta effects="user-code">_env_.HasBinding</emu-meta>(_name_)로 둔다.
          1. _exists_가 *true*이면
            1. Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 반환.
          1. Else
            1. _outer_를 _env_.[[OuterEnv]]로 둔다.
            1. ? GetIdentifierReference(_outer_, _name_, _strict_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newdeclarativeenvironment" type="abstract operation">
        <h1>
          NewDeclarativeEnvironment (
            _E_: Environment Record 또는 *null*,
          ): Declarative Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 바인딩이 없는 새 Declarative Environment Record _env_를 만든다.
          1. _env_.[[OuterEnv]]를 _E_로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newobjectenvironment" type="abstract operation">
        <h1>
          NewObjectEnvironment (
            _O_: Object,
            _W_: Boolean,
            _E_: Environment Record 또는 *null*,
          ): Object Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 새 Object Environment Record _env_ 생성.
          1. _env_.[[BindingObject]]를 _O_로 설정.
          1. _env_.[[IsWithEnvironment]]를 _W_로 설정.
          1. _env_.[[OuterEnv]]를 _E_로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" type="abstract operation">
        <h1>
          NewFunctionEnvironment (
            _F_: ECMAScript 함수 객체,
            _newTarget_: Object 또는 *undefined*,
          ): Function Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 바인딩이 없는 새 Function Environment Record _env_ 생성.
          1. _env_.[[FunctionObject]]를 _F_로 설정.
          1. _F_.[[ThisMode]]가 ~lexical~이면 _env_.[[ThisBindingStatus]]를 ~lexical~로 설정.
          1. Else _env_.[[ThisBindingStatus]]를 ~uninitialized~로 설정.
          1. _env_.[[NewTarget]]를 _newTarget_으로 설정.
          1. _env_.[[OuterEnv]]를 _F_.[[Environment]]로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newglobalenvironment" type="abstract operation">
        <h1>
          NewGlobalEnvironment (
            _G_: Object,
            _thisValue_: Object,
          ): Global Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _objRec_을 NewObjectEnvironment(_G_, *false*, *null*)로 둔다.
          1. _dclRec_를 NewDeclarativeEnvironment(*null*)로 둔다.
          1. 새 Global Environment Record _env_ 생성.
          1. _env_.[[ObjectRecord]]를 _objRec_로 설정.
          1. _env_.[[GlobalThisValue]]를 _thisValue_로 설정.
          1. _env_.[[DeclarativeRecord]]를 _dclRec_로 설정.
          1. _env_.[[OuterEnv]]를 *null*로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" type="abstract operation">
        <h1>
          NewModuleEnvironment (
            _E_: Environment Record,
          ): Module Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 바인딩이 없는 새 Module Environment Record _env_ 생성.
          1. _env_.[[OuterEnv]]를 _E_로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-privateenvironment-records">
    <h1>PrivateEnvironment 레코드(PrivateEnvironment Records)</h1>
    <p><dfn id="privateenvironment-record" variants="PrivateEnvironment Records">PrivateEnvironment Record</dfn>는 ECMAScript 코드에서 |ClassDeclaration| 및 |ClassExpression|의 렉시컬 중첩 구조를 기반으로 Private Name들을 추적하기 위해 사용되는 명세 메커니즘이다. 이는 Environment Record와 유사하지만 별개의 것이다. 각 PrivateEnvironment Record는 하나의 |ClassDeclaration| 또는 |ClassExpression|에 연결된다. 그러한 클래스가 평가될 때마다, 그 클래스가 선언한 Private Name들을 기록하기 위해 새로운 PrivateEnvironment Record가 생성된다.</p>
    <p>각 PrivateEnvironment Record는 <emu-xref href="#table-privateenvironment-records"></emu-xref>에 정의된 필드들을 가진다.</p>
    <emu-table id="table-privateenvironment-records" caption="PrivateEnvironment Record 필드(PrivateEnvironment Record Fields)">
      <table>
        <thead>
          <tr>
            <th>
              필드 이름(Field Name)
            </th>
            <th>
              값 타입(Value Type)
            </th>
            <th>
              의미(Meaning)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[OuterPrivateEnvironment]]
          </td>
          <td>
            PrivateEnvironment Record 또는 *null*
          </td>
          <td>
            가장 가까운 둘러싸는 클래스의 PrivateEnvironment Record. 이 PrivateEnvironment Record가 연결된 클래스가 다른 어떤 클래스에도 포함되지 않았다면 *null*.
          </td>
        </tr>
        <tr>
          <td>
            [[Names]]
          </td>
          <td>
            Private Name들의 List
          </td>
          <td>
            이 클래스가 선언한 Private Name들.
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-privateenvironment-record-operations">
      <h1>PrivateEnvironment Record 연산(PrivateEnvironment Record Operations)</h1>
      <p>다음 추상 연산들은 이 명세에서 PrivateEnvironment Record에 대해 동작하기 위해 사용된다:</p>

      <emu-clause id="sec-newprivateenvironment" type="abstract operation">
        <h1>
          NewPrivateEnvironment (
            _outerPrivateEnv_: PrivateEnvironment Record 또는 *null*,
          ): PrivateEnvironment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _names_를 새 빈 List로 둔다.
          1. PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivateEnv_, [[Names]]: _names_ } 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-resolve-private-identifier" type="abstract operation">
        <h1>
          ResolvePrivateIdentifier (
            _privateEnv_: PrivateEnvironment Record,
            _identifier_: String,
          ): Private Name
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _names_를 _privateEnv_.[[Names]]로 둔다.
          1. _names_의 각 Private Name _pn_에 대해
            1. _pn_.[[Description]]이 _identifier_이면
              1. _pn_을 반환한다.
          1. _outerPrivateEnv_를 _privateEnv_.[[OuterPrivateEnvironment]]로 둔다.
          1. 단언: _outerPrivateEnv_는 *null*이 아니다.
          1. ResolvePrivateIdentifier(_outerPrivateEnv_, _identifier_)를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realm들(Realms)</h1>
    <p>평가되기 전에 모든 ECMAScript 코드는 하나의 <dfn id="realm" variants="realms">realm</dfn>과 연계되어야 한다. 개념적으로 realm은 일련의 intrinsic 객체, ECMAScript 전역 환경, 그 전역 환경의 범위 내에서 로드된 모든 ECMAScript 코드, 그리고 기타 관련 상태 및 자원으로 구성된다.</p>
    <p>realm은 이 명세에서 <emu-xref href="#table-realm-record-fields"></emu-xref>에 지정된 필드를 가진 <dfn id="realm-record" variants="Realm Records">Realm Record</dfn>로 표현된다:</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record 필드(Realm Record Fields)" oldids="table-21">
      <table>
        <thead>
          <tr>
            <th>
              필드 이름(Field Name)
            </th>
            <th>
              값(Value)
            </th>
            <th>
              의미(Meaning)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[AgentSignifier]]
          </td>
          <td>
            에이전트 식별자(agent signifier)
          </td>
          <td>
            이 realm을 소유하는 에이전트
          </td>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td>
            필드 이름이 intrinsic key이고 값이 객체인 Record
          </td>
          <td>
            이 realm에 연계된 코드가 사용하는 intrinsic 값들
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            이 realm의 전역 객체
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td>
            Global Environment Record
          </td>
          <td>
            이 realm의 전역 환경
          </td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td>
            필드 [[Site]] (|TemplateLiteral| Parse Node) 및 [[Array]] (Array)를 갖는 Record들의 List
          </td>
          <td>
            <p>템플릿 객체들은 각 realm별로 그 Realm Record의 [[TemplateMap]]을 사용하여 정규화(canonicalize)된다. 각 [[Site]] 값은 |TemplateLiteral| 인 Parse Node이다. 연계된 [[Array]] 값은 태그 함수에 전달되는 해당 템플릿 객체이다.</p>
            <emu-note>어떤 Parse Node가 도달 불가능(unreachable)이 되면, 대응하는 [[Array]] 또한 도달 불가능해지며, 구현이 그 쌍을 [[TemplateMap]] 리스트에서 제거하더라도 관측 불가능하다.</emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[LoadedModules]]
          </td>
          <td>
            LoadedModuleRequest Record들의 List
          </td>
          <td>
            <p>이 realm이 import한 명세자(specifier) 문자열에서 해석된 Module Record로의 매핑. 리스트에는 ModuleRequestsEqual(_r1_, _r2_)가 *true*인 서로 다른 Record _r1_, _r2_ 두 개가 존재하지 않는다.</p>
            <emu-note>
              HostLoadImportedModule (<emu-xref href="#note-HostLoadImportedModule-referrer-Realm-Record"></emu-xref>)에서 언급했듯이, Realm Record의 [[LoadedModules]]는 활성 스크립트나 모듈이 없는 문맥에서 `import()` 표현식을 실행할 때만 사용된다.
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            임의(anything) (*undefined*가 기본값)
          </td>
          <td>
            호스트가 Realm Record와 추가 정보를 연계할 필요가 있을 때 사용하기 위한 예약 필드.
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-initializehostdefinedrealm" type="abstract operation" oldids="sec-createrealm,sec-setrealmglobalobject">
      <h1>InitializeHostDefinedRealm ( ): ~unused~를 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _realm_을 새로운 Realm Record로 둔다.
        1. CreateIntrinsics(_realm_)를 수행한다.
        1. _realm_.[[AgentSignifier]]를 AgentSignifier()로 설정한다.
        1. _realm_.[[TemplateMap]]을 새 빈 List로 설정한다.
        1. _newContext_를 새 실행 컨텍스트로 둔다.
        1. _newContext_의 Function을 *null*로 설정한다.
        1. _newContext_의 Realm을 _realm_으로 설정한다.
        1. _newContext_의 ScriptOrModule을 *null*로 설정한다.
        1. 실행 컨텍스트 스택에 _newContext_를 push한다; 이제 _newContext_가 실행 중(running) 실행 컨텍스트다.
        1. 호스트가 _realm_의 전역 객체로서 익조틱(exotic) 객체 사용을 요구한다면
          1. _global_을 호스트 정의 방식으로 생성된 그러한 객체로 둔다.
        1. Else,
          1. _global_을 OrdinaryObjectCreate(_realm_.[[Intrinsics]].[[%Object.prototype%]])로 둔다.
        1. 호스트가 _realm_ 전역 스코프의 `this` 바인딩이 전역 객체와 다른 객체를 반환하도록 요구한다면
          1. _thisValue_를 호스트 정의 방식으로 생성된 그러한 객체로 둔다.
        1. Else,
          1. _thisValue_를 _global_로 둔다.
        1. _realm_.[[GlobalObject]]를 _global_로 설정한다.
        1. _realm_.[[GlobalEnv]]를 NewGlobalEnvironment(_global_, _thisValue_)로 설정한다.
        1. ? SetDefaultGlobalBindings(_realm_)를 수행한다.
        1. 호스트 정의 전역 객체 프로퍼티들을 _global_에 생성한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createintrinsics" type="abstract operation">
      <h1>
        CreateIntrinsics (
          _realmRec_: Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _realmRec_.[[Intrinsics]]를 새 Record로 설정한다.
        1. [declared="steps,name,length,slots,prototype"] _realmRec_.[[Intrinsics]]의 필드들을 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>에 나열된 값으로 설정한다. 필드 이름은 테이블 첫 번째 열의 이름들이다. 각 필드 값은 <emu-xref href="#sec-global-object"></emu-xref>부터 <emu-xref href="#sec-reflection"></emu-xref>까지의 각 객체 명세에 따라 그 프로퍼티 값으로 완전하고 재귀적으로 채워진 새 객체 값이다. 모든 객체 프로퍼티 값은 새로 생성된 객체 값이다. 내장 함수 객체인 모든 값은 CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_)을 수행하여 생성되는데, 여기서 _steps_는 이 명세가 제공하는 그 함수의 정의, _name_은 함수의 초기 *"name"* 프로퍼티 값, _length_는 함수의 초기 *"length"* 프로퍼티 값, _slots_는 (있다면) 함수의 지정된 내부 슬롯 이름들의 리스트, _prototype_은 함수 [[Prototype]] 내부 슬롯의 지정된 값이다. intrinsic과 그 프로퍼티 생성은 아직 생성되지 않은 객체에 대한 의존성이 없도록 순서가 정해져야 한다.
        1. AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setdefaultglobalbindings" type="abstract operation">
      <h1>
        SetDefaultGlobalBindings (
          _realmRec_: Realm Record,
        ): ~unused~를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _global_을 _realmRec_.[[GlobalObject]]로 둔다.
        1. <emu-xref href="#sec-global-object"></emu-xref> 절에 지정된 전역 객체의 각 프로퍼티에 대해
          1. _name_을 그 프로퍼티 이름의 String 값으로 둔다.
          1. _desc_를 그 프로퍼티에 대해 지정된 속성들을 포함하는 완전히 채워진 데이터 프로퍼티 디스크립터로 둔다. <emu-xref href="#sec-function-properties-of-the-global-object"></emu-xref>, <emu-xref href="#sec-constructor-properties-of-the-global-object"></emu-xref>, 또는 <emu-xref href="#sec-other-properties-of-the-global-object"></emu-xref>에 나열된 프로퍼티의 경우 [[Value]] 속성 값은 _realmRec_의 해당 intrinsic 객체이다.
          1. ? DefinePropertyOrThrow(_global_, _name_, _desc_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>실행 컨텍스트들(Execution Contexts)</h1>
    <p><dfn variants="execution contexts">execution context</dfn>는 ECMAScript 구현이 코드의 런타임 평가를 추적하기 위해 사용하는 명세 장치이다. 어느 시점에도 코드 실행 중인 에이전트당 실제로 코드를 실행하는 실행 컨텍스트는 최대 하나이다. 이는 그 에이전트의 <dfn id="running-execution-context" variants="running execution contexts">running execution context</dfn>로 알려져 있다. 이 명세에서 running execution context에 대한 모든 언급은 둘러싼 에이전트의 running execution context를 가리킨다.</p>
    <p><dfn id="execution-context-stack" variants="execution context stacks">execution context stack</dfn>은 실행 컨텍스트들을 추적하는 데 사용된다. running execution context는 항상 이 스택의 최상단 요소이다. 현재 running execution context에 연계된 실행 가능한 코드로부터 그 실행 컨텍스트와 연계되지 않은 실행 가능한 코드로 제어가 이전될 때마다 새로운 실행 컨텍스트가 생성된다. 새로 생성된 실행 컨텍스트는 스택에 push되며 running execution context가 된다.</p>
    <p>실행 컨텍스트는 그 연계된 코드의 실행 진행을 추적하는 데 필요한 구현별 상태를 포함한다. 각 실행 컨텍스트는 최소한 <emu-xref href="#table-state-components-for-all-execution-contexts"></emu-xref>에 나열된 상태 구성 요소들을 가진다.</p>
    <emu-table id="table-state-components-for-all-execution-contexts" caption="모든 실행 컨텍스트의 상태 구성 요소(State Components for All Execution Contexts)" oldids="table-22">
      <table>
        <thead>
          <tr>
            <th>
              구성 요소(Component)
            </th>
            <th>
              목적(Purpose)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            code evaluation state
          </td>
          <td>
            이 실행 컨텍스트와 연계된 코드의 평가 수행, 일시중단, 재개에 필요한 모든 상태.
          </td>
        </tr>
        <tr>
          <td>
            Function
          </td>
          <td>
            이 실행 컨텍스트가 함수 객체의 코드를 평가 중이면 이 구성 요소 값은 그 함수 객체이고, |Script| 또는 |Module|의 코드를 평가 중이면 값은 *null*.
          </td>
        </tr>
        <tr>
          <td>
            Realm
          </td>
          <td>
            연계된 코드가 ECMAScript 자원에 접근하는 데 사용하는 Realm Record.
          </td>
        </tr>
        <tr>
          <td>
            ScriptOrModule
          </td>
          <td>
            연계된 코드가 기원한 Module Record 또는 Script Record. 원래 실행 컨텍스트(InitializeHostDefinedRealm에서 생성된)처럼 기원 스크립트나 모듈이 없는 경우 값은 *null*.
          </td>
        </tr>
      </table>
    </emu-table>
    <p>running execution context에 의한 코드 평가는 이 명세에 정의된 여러 지점에서 일시중단(suspend)될 수 있다. 한 번 running execution context가 일시중단되면, 다른 실행 컨텍스트가 running execution context가 되어 자신의 코드를 평가하기 시작할 수 있다. 이후 어느 시점에 일시중단된 실행 컨텍스트가 다시 running execution context가 되어 이전에 일시중단된 지점부터 자신의 코드를 계속 평가할 수 있다. running execution context 상태의 전환은 보통 스택과 같은 후입선출(LIFO) 방식으로 발생하지만, 일부 ECMAScript 기능은 비 LIFO 전환을 요구한다.</p>
    <p>running execution context의 Realm 구성 요소 값은 <dfn id="current-realm">current Realm Record</dfn>라고도 한다. running execution context의 Function 구성 요소 값은 <dfn id="active-function-object">active function object</dfn>라고도 한다.</p>
    <p><dfn id="ecmascript-code-execution-context" variants="ECMAScript code execution context">ECMAScript 코드 실행 컨텍스트</dfn>는 <emu-xref href="#table-additional-state-components-for-ecmascript-code-execution-contexts"></emu-xref>에 나열된 추가 상태 구성 요소를 가진다.</p>
    <emu-table id="table-additional-state-components-for-ecmascript-code-execution-contexts" caption="ECMAScript 코드 실행 컨텍스트의 추가 상태 구성 요소(Additional State Components for ECMAScript Code Execution Contexts)" oldids="table-23">
      <table>
        <thead>
          <tr>
            <th>
              구성 요소(Component)
            </th>
            <th>
              목적(Purpose)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            이 실행 컨텍스트 내 코드가 수행하는 식별자 참조를 해석하는 데 사용되는 Environment Record를 식별.
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            이 실행 컨텍스트 내 |VariableStatement|에 의해 생성된 바인딩을 보유하는 Environment Record를 식별.
          </td>
        </tr>
        <tr>
          <td>
            PrivateEnvironment
          </td>
          <td>
            가장 가까운 둘러싸는 클래스의 |ClassElement|들이 생성한 Private Name들을 보유하는 PrivateEnvironment Record를 식별. 둘러싸는 클래스가 없으면 *null*.
          </td>
        </tr>
      </table>
    </emu-table>
    <p>실행 컨텍스트의 LexicalEnvironment 및 VariableEnvironment 구성 요소는 항상 Environment Record이다.</p>
    <p>Generator 평가를 나타내는 실행 컨텍스트는 <emu-xref href="#table-additional-state-components-for-generator-execution-contexts"></emu-xref>에 나열된 추가 상태 구성 요소를 가진다.</p>
    <emu-table id="table-additional-state-components-for-generator-execution-contexts" caption="Generator 실행 컨텍스트의 추가 상태 구성 요소(Additional State Components for Generator Execution Contexts)" oldids="table-24">
      <table>
        <thead>
          <tr>
            <th>
              구성 요소(Component)
            </th>
            <th>
              목적(Purpose)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Generator
          </td>
          <td>
            이 실행 컨텍스트가 평가 중인 Generator.
          </td>
        </tr>
      </table>
    </emu-table>
    <p>대부분의 상황에서 이 명세의 알고리즘이 직접 조작하는 것은 running execution context(실행 컨텍스트 스택의 최상단)이다. 따라서 “LexicalEnvironment”, “VariableEnvironment”라는 용어가 한정 없이 사용될 때 그것들은 running execution context의 해당 구성 요소를 의미한다.</p>
    <p>실행 컨텍스트는 순수한 명세 메커니즘이며 ECMAScript 구현의 특정한 실체에 대응할 필요가 없다. ECMAScript 코드는 실행 컨텍스트를 직접 접근하거나 관찰할 수 없다.</p>

    <emu-clause id="sec-getactivescriptormodule" type="abstract operation">
      <h1>GetActiveScriptOrModule ( ): Script Record, Module Record, 또는 *null*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>running execution context를 기반으로 실행 중인 스크립트 또는 모듈을 결정하는 데 사용된다.</dd>
      </dl>

      <emu-alg>
        1. 실행 컨텍스트 스택이 비어 있으면 *null*을 반환한다.
        1. _ec_를 실행 컨텍스트 스택의 최상단에서 ScriptOrModule 구성 요소가 *null*이 아닌 실행 컨텍스트로 둔다.
        1. 그러한 실행 컨텍스트가 없으면 *null*을 반환하고; 그렇지 않으면 _ec_의 ScriptOrModule을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvebinding" type="abstract operation">
      <h1>
        ResolveBinding (
          _name_: String,
          optional _env_: Environment Record 또는 *undefined*,
        ): Reference Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_name_의 바인딩을 결정하는 데 사용된다. _env_는 검색할 Environment Record를 명시적으로 제공하는 데 사용할 수 있다.</dd>
      </dl>
      <emu-alg>
        1. _env_가 제공되지 않았거나 _env_가 *undefined*이면
          1. _env_를 running execution context의 LexicalEnvironment로 설정한다.
        1. 단언: _env_는 Environment Record이다.
        1. _strict_를 (평가 중인) 구문 생성 규칙에 대한 IsStrict의 결과로 둔다.
        1. ? GetIdentifierReference(_env_, _name_, _strict_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>ResolveBinding의 결과는 항상 [[ReferencedName]] 필드가 _name_인 Reference Record이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getthisenvironment" type="abstract operation">
      <h1>GetThisEnvironment ( ): Environment Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>현재 `this` 키워드의 바인딩을 제공하는 Environment Record를 찾는다.</dd>
      </dl>
      <emu-alg>
        1. _env_를 running execution context의 LexicalEnvironment로 둔다.
        1. [id="step-getthisenvironment-loop"] 반복,
          1. _exists_를 _env_.HasThisBinding()으로 둔다.
          1. _exists_가 *true*이면 _env_를 반환한다.
          1. _outer_를 _env_.[[OuterEnv]]로 둔다.
          1. 단언: _outer_는 *null*이 아니다.
          1. _env_를 _outer_로 설정한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-getthisenvironment-loop"></emu-xref> 단계의 루프는 환경들의 리스트가 항상 `this` 바인딩을 가진 전역 환경으로 끝나므로 반드시 종료된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-resolvethisbinding" type="abstract operation">
      <h1>ResolveThisBinding ( ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>running execution context의 LexicalEnvironment를 사용하여 `this` 키워드의 바인딩을 결정한다.</dd>
      </dl>
      <emu-alg>
        1. _envRec_를 GetThisEnvironment()로 둔다.
        1. ? _envRec_.GetThisBinding()을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getnewtarget" type="abstract operation">
      <h1>GetNewTarget ( ): Object 또는 *undefined*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>running execution context의 LexicalEnvironment를 사용하여 NewTarget 값을 결정한다.</dd>
      </dl>
      <emu-alg>
        1. _envRec_를 GetThisEnvironment()로 둔다.
        1. 단언: _envRec_는 [[NewTarget]] 필드를 가진다.
        1. _envRec_.[[NewTarget]]을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getglobalobject" type="abstract operation">
      <h1>GetGlobalObject ( ): Object</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>현재 running execution context가 사용하는 전역 객체를 반환한다.</dd>
      </dl>
      <emu-alg>
        1. _currentRealm_을 current Realm Record로 둔다.
        1. _currentRealm_.[[GlobalObject]]를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-jobs" oldids="sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue">
    <h1>잡과 잡을 대기열에 넣기 위한 호스트 연산(Jobs and Host Operations to Enqueue Jobs)</h1>
    <p><dfn id="job" variants="Jobs">Job</dfn>은 파라미터가 없는 추상 클로저(Abstract Closure)로, 다른 ECMAScript 계산이 현재 진행 중이지 않을 때 ECMAScript 계산을 개시한다.</p>
    <p>잡은 특정 에이전트 내에서 ECMAScript 호스트 환경에 의해 실행이 스케줄된다. 이 명세는 잡을 스케줄하기 위해 HostEnqueueGenericJob, HostEnqueueFinalizationRegistryCleanupJob, HostEnqueuePromiseJob, HostEnqueueTimeoutJob 호스트 훅을 기술한다. 이 명세의 호스트 훅들은 잡 스케줄링에 추가로 부과되는 제약들에 따라 조직되어 있다. 호스트는 잡을 스케줄하는 추가적인 추상 연산을 정의할 수 있다. 그러한 연산은 Job 추상 클로저와 realm(Realm Record 또는 *null*)을 인자로 받는다. Realm Record가 제공되면, 그 연산들은 해당 realm을 소유한 에이전트에서 미래의 어느 시점에 그 realm 안에서 잡이 수행되도록 스케줄한다. realm이 대신 *null*로 제공되면, 그 잡은 ECMAScript 코드를 평가하지 않는다. 구현은 다음 요구 사항을 따라야 한다:</p>

    <ul>
      <li>미래의 어떤 시점에, 그 잡이 스케줄된 에이전트에 실행 중인 컨텍스트가 없고 그 에이전트의 실행 컨텍스트 스택이 비어 있을 때, 구현은 반드시:
        <ol>
          <li>호스트 정의 준비 단계를 수행한다.</li>
          <li><emu-not-ref>Invoke</emu-not-ref> Job 추상 클로저를 호출한다.</li>
          <li>호스트 정의 정리 단계를 수행하며, 그 후 실행 컨텍스트 스택은 비어 있어야 한다.</li>
        </ol>
      </li>
      <li>어느 시점에도 하나의 에이전트에서 동시에 평가 중인 Job은 하나만 존재할 수 있다.</li>
      <li>Job의 평가가 시작되면, 그 에이전트에서 다른 어떤 Job의 평가가 시작되기 전에 완료까지 실행되어야 한다(run to completion).</li>
      <li>추상 클로저는 오류 처리를 자체적으로 구현하여 정상 완료(normal completion)를 반환해야 한다.</li>
    </ul>

    <emu-note>
      호스트 환경은 스케줄링 측면에서 모든 Job을 동일하게 취급할 필요가 없다. 예를 들어, 웹 브라우저와 Node.js는 Promise 처리 잡을 다른 작업보다 더 높은 우선순위로 다룬다; 향후 기능은 그렇게 높은 우선순위로 다루어지지 않는 잡을 추가할 수 있다.
    </emu-note>

    <p>어떤 특정 시점에, 다음 모든 조건이 참이라면 _scriptOrModule_(Script Record, Module Record, 또는 *null*)은 <dfn id="job-activescriptormodule">active script or module(활성 스크립트 또는 모듈)</dfn>이다:</p>
    <ul>
      <li>GetActiveScriptOrModule() 결과가 _scriptOrModule_이다.</li>
      <li>_scriptOrModule_이 Script Record 또는 Module Record라면, _ec_를 실행 컨텍스트 스택의 최상단에서 ScriptOrModule 구성 요소가 _scriptOrModule_인 실행 컨텍스트로 둔다. _ec_의 Realm 구성 요소는 _scriptOrModule_.[[Realm]]이다.</li>
    </ul>

    <p>어떤 특정 시점에, 다음 모든 조건이 참이면 실행은 <dfn id="job-preparedtoevaluatecode">ECMAScript 코드를 평가할 준비가 되었다(prepared to evaluate ECMAScript code)</dfn>고 한다:</p>
    <ul>
      <li>실행 컨텍스트 스택이 비어 있지 않다.</li>
      <li>실행 컨텍스트 스택 최상단 실행 컨텍스트의 Realm 구성 요소가 Realm Record이다.</li>
    </ul>

    <emu-note>
      <p>호스트 환경은 실행 컨텍스트들을 실행 컨텍스트 스택에 push하여 코드를 평가할 준비를 시킬 수 있다. 구체적인 단계는 구현 정의이다.</p>
      <p>Realm의 구체적 선택은 호스트 환경에 달려 있다. 이 초기 실행 컨텍스트와 Realm은 어떤 콜백 함수가 호출되기 전까지만 사용된다. Promise 핸들러 같은 잡 관련 콜백 함수가 호출되면, 그 호출은 자체 실행 컨텍스트와 Realm을 push한다.</p>
    </emu-note>

    <p>특정 종류의 Job은 추가적인 적합성 요구 사항을 가진다.</p>

    <emu-clause id="sec-jobcallback-records">
      <h1>JobCallback 레코드(JobCallback Records)</h1>
      <p><dfn variants="JobCallback Records">JobCallback Record</dfn>는 함수 객체와 호스트 정의 값을 저장하기 위해 사용되는 Record 값이다. 호스트가 대기열에 넣은 Job을 통해 호출되는 함수 객체는 추가적인 호스트 정의 컨텍스트를 가질 수 있다. 이 상태를 전파하기 위해, Job 추상 클로저는 함수 객체를 직접 캡처하고 호출하지 않아야 한다. 대신 HostMakeJobCallback 및 HostCallJobCallback을 사용한다.</p>
      <emu-note>
        <p>예를 들어 WHATWG HTML 명세(<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>)는 Promise 콜백에 대해 incumbent settings object를 전파하기 위해 호스트 정의 값을 사용한다.</p>
      </emu-note>
      <p>JobCallback Record는 <emu-xref href="#table-jobcallback-records"></emu-xref>에 나열된 필드를 가진다.</p>
      <emu-table id="table-jobcallback-records" caption="JobCallback Record 필드(JobCallback Record Fields)">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름(Field Name)
              </th>
              <th>
                값(Value)
              </th>
              <th>
                의미(Meaning)
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Callback]]
            </td>
            <td>
              함수 객체
            </td>
            <td>
              Job이 호출될 때 호출할 함수.
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (기본값은 ~empty~)
            </td>
            <td>
              호스트 사용을 위한 예약 필드.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-hostmakejobcallback" type="host-defined abstract operation">
      <h1>
        HostMakeJobCallback (
          _callback_: 함수 객체,
        ): JobCallback Record
      </h1>
      <dl class="header">
      </dl>
      <p>HostMakeJobCallback 구현은 다음 요구 사항을 따라야 한다:</p>
      <ul>
        <li>[[Callback]] 필드가 _callback_인 JobCallback Record를 반환해야 한다.</li>
      </ul>
      <p>HostMakeJobCallback의 기본 구현은 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }를 반환한다.
      </emu-alg>
      <p>웹 브라우저가 아닌 ECMAScript 호스트는 HostMakeJobCallback의 기본 구현을 사용해야 한다.</p>
      <emu-note>
        <p>이는 콜백이 궁극적으로 스케줄되고 실행되도록 책임지는 함수에 콜백이 전달되는 시점에 호출된다. 예를 들어, `promise.then(thenAction)`은 반응 Job이 스케줄되는 시점이 아니라 `Promise.prototype.then`을 호출하는 시점에 `thenAction`에 대해 MakeJobCallback을 호출한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostcalljobcallback" type="host-defined abstract operation">
      <h1>
        HostCallJobCallback (
          _jobCallback_: JobCallback Record,
          _V_: ECMAScript 언어 값,
          _argumentsList_: ECMAScript 언어 값들의 List,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <p>HostCallJobCallback 구현은 다음 요구 사항을 따라야 한다:</p>
      <ul>
        <li>Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)의 결과를 수행하고 반환해야 한다.</li>
      </ul>
      <emu-note>
        <p>이 요구 사항은 호스트가 이 명세에서 정의된 함수 객체의 [[Call]] 동작을 변경할 수 없음을 의미한다.</p>
      </emu-note>
      <p>HostCallJobCallback의 기본 구현은 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. 단언: IsCallable(_jobCallback_.[[Callback]])가 *true*이다.
        1. ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)를 반환한다.
      </emu-alg>
      <p>웹 브라우저가 아닌 ECMAScript 호스트는 HostCallJobCallback의 기본 구현을 사용해야 한다.</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuegenericjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueGenericJob (
          _job_: Job 추상 클로저,
          _realm_: Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_realm_.[[AgentSignifier]]로 표시된 에이전트에서 _realm_ 내에 _job_을 미래의 어느 시점에 수행하도록 스케줄한다. 이 알고리즘과 함께 사용되는 추상 클로저는 우선순위나 순서 같은 추가 제약 없이 스케줄되는 것을 의도한다.</dd>
      </dl>
      <p>HostEnqueueGenericJob 구현은 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항을 따라야 한다.</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuepromisejob" type="host-defined abstract operation">
      <h1>
        HostEnqueuePromiseJob (
          _job_: Job 추상 클로저,
          _realm_: Realm Record 또는 *null*,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_job_을 미래의 어느 시점에 수행하도록 스케줄한다. 이 알고리즘과 함께 사용되는 추상 클로저는 Promise 처리와 관련이 있거나 그렇지 않더라도 Promise 처리 연산과 동일한 우선순위로 스케줄되는 것을 의도한다.</dd>
      </dl>

      <p>HostEnqueuePromiseJob 구현은 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항과 아래 사항을 따라야 한다:</p>
      <ul>
        <li>_realm_이 *null*이 아니면, _job_이 호출될 때마다 구현은 _job_ 호출 시점에 실행이 ECMAScript 코드를 평가할 준비가 되도록 구현 정의 단계를 수행해야 한다.</li>
        <li>HostEnqueuePromiseJob이 호출되는 시점에 _scriptOrModule_을 GetActiveScriptOrModule()으로 둔다. _realm_이 *null*이 아니면, _job_이 호출될 때마다 구현은 _scriptOrModule_이 _job_ 호출 시점에 활성 스크립트 또는 모듈이 되도록 구현 정의 단계를 수행해야 한다.</li>
        <li>잡은 그들을 스케줄한 HostEnqueuePromiseJob 호출과 동일한 순서로 실행되어야 한다.</li>
      </ul>

      <emu-note>
        <p>NewPromiseResolveThenableJob이 반환한 잡의 _realm_은 보통 _then_ 함수 객체에 대해 GetFunctionRealm을 호출한 결과이다. NewPromiseReactionJob이 반환한 잡의 _realm_은 핸들러가 *undefined*가 아니면 보통 핸들러에 대해 GetFunctionRealm을 호출한 결과이다. 핸들러가 *undefined*이면 _realm_은 *null*이다. 두 종류의 잡 모두에서 GetFunctionRealm이 비정상적으로 완료(예: 철회된 Proxy에 대해 호출)되면 _realm_은 GetFunctionRealm 호출 시점의 현재 Realm Record이다. _realm_이 *null*이면 어떤 사용자 ECMAScript 코드도 평가되지 않고 새로운 ECMAScript 객체(예: Error 객체)도 생성되지 않는다. WHATWG HTML 명세(<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>)는 예를 들어 _realm_을 사용하여 스크립트 실행 가능 여부와 <a href="https://html.spec.whatwg.org/#entry">entry</a> 개념을 확인한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostenqueuetimeoutjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueTimeoutJob (
          _timeoutJob_: Job 추상 클로저,
          _realm_: Realm Record,
          _milliseconds_: 음이 아닌 유한 Number,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_realm_.[[AgentSignifier]]로 표시된 에이전트에서 _realm_ 내에 _timeoutJob_을 최소 _milliseconds_ 밀리초 후에 수행되도록 스케줄한다.</dd>
      </dl>
      <p>HostEnqueueTimeoutJob 구현은 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항을 따라야 한다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agents">
    <h1>에이전트(Agents)</h1>

    <p><dfn id="agent" variants="agents">agent</dfn>는 ECMAScript 실행 컨텍스트 집합, 실행 컨텍스트 스택, 실행 중 실행 컨텍스트(running execution context), <dfn id="agent-record" variants="Agent Records">Agent Record</dfn>, 그리고 <dfn id="executing-thread" variants="executing threads">executing thread</dfn>로 구성된다. executing thread를 제외한 구성 요소들은 오직 그 에이전트에만 속한다.</p>
    <p>에이전트의 executing thread는 다른 에이전트와 독립적으로 그 에이전트의 실행 컨텍스트들에 대해 알고리즘 단계를 실행한다. 단, 여러 에이전트가 하나의 executing thread를 공유할 수 있는데, 그 공유하는 에이전트 중 어느 것도 Agent Record의 [[CanBlock]] 필드가 *true*이면 안 된다.</p>
    <emu-note>
      <p>예를 들어 일부 웹 브라우저는 서로 관계없는 여러 탭이 단일 executing thread를 공유한다.</p>
    </emu-note>
    <p>에이전트의 executing thread가 알고리즘 단계를 실행하는 동안, 그 에이전트는 그 단계들의 <dfn id="surrounding-agent" variants="surrounding agents">surrounding agent(둘러싼 에이전트)</dfn>이다. 그 단계들은 둘러싼 에이전트를 사용하여 에이전트가 보유한 명세 수준 실행 객체—실행 중 실행 컨텍스트, 실행 컨텍스트 스택, Agent Record의 필드—에 접근한다.</p>
    <p><dfn variants="agent signifiers">agent signifier(에이전트 식별자)</dfn>는 에이전트를 식별하기 위해 사용되는 전역적으로 고유한 불투명 값이다.</p>
    <emu-table id="table-agent-record" caption="Agent Record 필드(Agent Record Fields)">
      <table>
        <thead>
          <tr>
            <th>필드 이름(Field Name)</th>
            <th>값(Value)</th>
            <th>의미(Meaning)</th>
          </tr>
        </thead>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>Boolean</td>
          <td>알고리즘 GetValueFromBuffer 및 SetValueInBuffer가 필요할 때 <em>isLittleEndian</em> 파라미터에 대해 계산되는 기본 값. 선택은 구현 정의이며 구현에 가장 효율적인 대안을 사용해야 한다. 한 번 관측된 후에는 변경될 수 없다.</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>Boolean</td>
          <td>에이전트가 블록(block)될 수 있는지 여부를 결정.</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>agent signifier</td>
          <td>에이전트를 그 에이전트 클러스터 내에서 고유하게 식별.</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>Boolean</td>
          <td>1-<emu-not-ref>byte 값</emu-not-ref>에 대한 원자적 연산이 lock-free이면 *true*, 아니면 *false*.</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>Boolean</td>
          <td>2-<emu-not-ref>byte 값</emu-not-ref>에 대한 원자적 연산이 lock-free이면 *true*, 아니면 *false*.</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>Boolean</td>
          <td>8-<emu-not-ref>byte 값</emu-not-ref>에 대한 원자적 연산이 lock-free이면 *true*, 아니면 *false*.</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>candidate execution Record</td>
          <td>메모리 모델 참조.</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>Objects 또는 Symbols 중 하나의 List</td>
          <td>초기에는 새 빈 List로, 현재 Job 끝까지 유지(kept alive)되어야 하는 객체 및/또는 심볼들의 목록.</td>
        </tr>
        <tr>
          <td>[[ModuleAsyncEvaluationCount]]</td>
          <td>정수</td>
          <td>초기값 0. 비동기 또는 비동기 의존성을 가진 모듈들의 [[AsyncEvaluationOrder]] 필드에 고유 증가값을 할당하는 데 사용.</td>
        </tr>
      </table>
    </emu-table>

    <p>[[Signifier]], [[IsLockFree1]], [[IsLockFree2]]의 값은 에이전트 클러스터의 어떤 에이전트에 의해 관측된 후에는 변경될 수 없다.</p>

    <emu-note>
      <p>[[IsLockFree1]]과 [[IsLockFree2]]의 값은 반드시 하드웨어에 의해 결정되는 것은 아니며, 시간에 따라 또는 ECMAScript 구현 간에 달라질 수 있는 구현 선택을 반영할 수도 있다.</p>

      <p>[[IsLockFree4]] 필드는 없다: 4-byte 원자 연산은 항상 lock-free이다.</p>

      <p>실제로 어떤 종류의 락을 사용해 원자 연산이 구현된다면 그 연산은 lock-free가 아니다. Lock-free는 wait-free를 의미하지 않는다: lock-free 원자 연산을 완료하는 데 필요한 기계 단계 수에 상한은 없다.</p>

      <p>크기 <em>n</em>의 원자 접근이 lock-free라고 해서 크기 <em>n</em>의 비원자(non-atomic) 접근의 (인지된) 원자성에 대해 아무것도 의미하지 않는다. 특히 비원자 접근은 여전히 여러 개의 별도 메모리 접근 시퀀스로 수행될 수 있다. 세부 사항은 ReadSharedMemory와 WriteSharedMemory 참조.</p>
    </emu-note>

    <emu-note>
      <p>에이전트는 명세 메커니즘이며 ECMAScript 구현의 특정 실체에 대응할 필요가 없다.</p>
    </emu-note>

    <emu-clause id="sec-agentsignifier" type="abstract operation">
      <h1>AgentSignifier ( ): agent signifier</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_를 둘러싼 에이전트의 Agent Record로 둔다.
        1. _AR_.[[Signifier]]를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-agentcansuspend" type="abstract operation">
      <h1>AgentCanSuspend ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_를 둘러싼 에이전트의 Agent Record로 둔다.
        1. _AR_.[[CanBlock]]를 반환한다.
      </emu-alg>
      <emu-note>
        <p>일부 환경에서는 특정 에이전트가 일시중단(suspend)되는 것이 타당하지 않을 수 있다. 예를 들어 웹 브라우저 환경에서는 문서의 메인 이벤트 처리 스레드를 일시중단하지 않는 것이 합리적일 수 있지만 워커의 이벤트 처리 스레드는 가능하게 할 수 있다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-IncrementModuleAsyncEvaluationCount" type="abstract operation">
      <h1>IncrementModuleAsyncEvaluationCount ( ): 정수</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_를 둘러싼 에이전트의 Agent Record로 둔다.
        1. _count_를 _AR_.[[ModuleAsyncEvaluationCount]]로 둔다.
        1. _AR_.[[ModuleAsyncEvaluationCount]]를 _count_ + 1로 설정한다.
        1. _count_를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 값은 보류 중(pending) 모듈 사이의 상대적 평가 순서를 추적하기 위해서만 사용된다. 보류 중인 모듈이 없다면 구현은 관측 불가능하게 [[ModuleAsyncEvaluationCount]]를 0으로 재설정할 수 있다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agent-clusters">
    <h1>에이전트 클러스터(Agent Clusters)</h1>

    <p><dfn variants="agent clusters">agent cluster</dfn>는 공유 메모리를 조작함으로써 통신할 수 있는 에이전트들의 최대 집합이다.</p>

    <emu-note>
      <p>서로 다른 에이전트 내의 프로그램들은 명시되지 않은 수단으로 메모리를 공유할 수 있다. 최소한 SharedArrayBuffers의 백업 메모리는 클러스터의 에이전트들 간에 공유될 수 있다.</p>

      <p>메시지 전달로 통신할 수 있지만 메모리를 공유할 수 없는 에이전트들도 있을 수 있으며, 그들은 절대 같은 에이전트 클러스터에 속하지 않는다.</p>
    </emu-note>

    <p>모든 에이전트는 정확히 하나의 에이전트 클러스터에 속한다.</p>

    <emu-note>
      <p>클러스터의 에이전트들이 어떤 특정 시점에 모두 살아 있을 필요는 없다. 에이전트 <b>A</b>가 다른 에이전트 <b>B</b>를 생성하고, 그 후 <b>A</b>가 종료되고 <b>B</b>가 에이전트 <b>C</b>를 생성한다면, <b>A</b>가 <b>B</b>와 일부 메모리를 공유할 수 있었고 <b>B</b>가 <b>C</b>와 일부 메모리를 공유할 수 있었다면 세 에이전트는 같은 클러스터에 속한다.</p>
    </emu-note>

    <p>클러스터 내 모든 에이전트는 각각의 Agent Record에서 [[LittleEndian]] 필드에 대해 동일한 값을 가져야 한다.</p>

    <emu-note>
      <p>에이전트 클러스터 내의 에이전트들이 [[LittleEndian]] 값이 서로 다르다면, 다중 바이트 데이터에 대해 공유 메모리를 사용하는 것이 어려워진다.</p>
    </emu-note>

    <p>클러스터 내 모든 에이전트는 [[IsLockFree1]] 필드에 대해 동일한 값을 가져야 하며 [[IsLockFree2]] 필드도 마찬가지이다.</p>

    <p>클러스터 내 모든 에이전트는 각각의 Agent Record에서 [[Signifier]] 필드에 대해 서로 다른 값을 가져야 한다.</p>

    <p>임베딩은 에이전트의 지식이나 협력 없이 에이전트를 비활성화(진행 중단)하거나 활성화(진행 재개)할 수 있다. 임베딩이 그렇게 한다면, 클러스터 내 일부 에이전트만 활성 상태로 남기고 다른 에이전트들을 무기한 비활성화된 상태로 두어서는 안 된다.</p>

    <emu-note>
      <p>위 제한의 목적은 어떤 에이전트가 다른 에이전트가 비활성화되었기 때문에 데드락 또는 기아(starvation)에 빠지는 상황을 피하기 위함이다. 예를 들어, 창 윈도우의 어떤 문서에도 독립적인 수명(lifetime)을 가진 HTML 공유 워커가 그런 독립 문서의 전용(dedicated) 워커와 메모리를 공유할 수 있고, 그 후 문서와 전용 워커가 (예: 문서가 히스토리에 들어가면서) 비활성화되었으며 전용 워커가 락을 보유한 상태이고, 공유 워커가 락을 획득하려 하면 공유 워커는 전용 워커가 다시 활성화될 때까지(혹은 영원히) 블록된다. 그동안 다른 윈도우에서 공유 워커에 접근하려는 다른 워커들은 기아 상태에 빠진다.</p>

      <p>이 제한의 함의는 임베딩 내에서 동일한 suspend/wake 집합에 속하지 않는 에이전트들 사이에서는 메모리를 공유할 수 없다는 것이다.</p>
    </emu-note>

    <p>임베딩은 에이전트 클러스터의 다른 에이전트의 사전 지식이나 협력 없이 에이전트를 종료할 수 있다. 에이전트가 자체 또는 클러스터 내 다른 에이전트의 프로그래밍 동작이 아니라 클러스터 외부의 힘에 의해 종료된다면, 임베딩은 두 전략 중 하나를 선택해야 한다: 클러스터의 모든 에이전트를 종료하거나, 클러스터의 에이전트들이 협력하여 종료를 감지할 수 있도록 신뢰 가능한 API를 제공하되, 종료 데이터는 종료된 에이전트를 식별하기에 충분한 정보를 포함해야 한다.</p>

    <emu-note>
      <p>그러한 종료 유형의 예로는: 별도 프로세스에서 실행 중인 에이전트를 운영체제나 사용자가 종료하는 경우; per-agent 자원 계정이 에이전트가 runaway임을 나타낼 때 같은 프로세스에서 다른 에이전트와 함께 실행 중인 에이전트를 임베딩 자체가 종료하는 경우 등이 있다.</p>
    </emu-note>

    <p>다음 명세 값 각각과 그들로부터 추이적으로 도달 가능한 값들은 정확히 하나의 에이전트 클러스터에 속한다.</p>
    <ul>
      <li>candidate execution Record</li>
      <li>Shared Data Block</li>
      <li>WaiterList Record</li>
    </ul>

    <p>클러스터 내 어떤 에이전트가 ECMAScript 코드를 평가하기 이전에, 클러스터의 모든 에이전트에 대한 Agent Record의 [[CandidateExecution]] 필드는 초기 candidate execution으로 설정된다. 초기 candidate execution은 비어 있는 candidate execution으로, 그 [[EventsRecords]] 필드는 각 에이전트에 대해 [[AgentSignifier]] 필드가 그 에이전트의 agent signifier이고 [[EventList]] 및 [[AgentSynchronizesWith]] 필드가 빈 List인 Agent Events Record를 포함하는 List이다.</p>

    <emu-note>
      <p>에이전트 클러스터의 모든 에이전트는 Agent Record의 [[CandidateExecution]] 필드에서 동일한 candidate execution을 공유한다. candidate execution은 메모리 모델에서 사용되는 명세 메커니즘이다.</p>
    </emu-note>

    <emu-note>
      <p>에이전트 클러스터는 명세 메커니즘이며 ECMAScript 구현의 특정 실체에 대응할 필요가 없다.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forward-progress">
    <h1>Forward Progress</h1>
    <p>에이전트가 <em>forward progress를 만든다(make forward progress)</em>는 것은 이 명세에 따라 평가 단계(evaluation step)를 수행하는 것이다.</p>
    <p>에이전트의 실행 중 실행 컨텍스트가 외부 이벤트를 동기적으로 무기한 기다릴 때, 그 에이전트는 <em>blocked</em>가 된다. Agent Record의 [[CanBlock]] 필드가 *true*인 에이전트만 이런 의미에서 blocked 상태가 될 수 있다. <em>unblocked</em> 에이전트는 blocked가 아닌 에이전트이다.</p>

    <p>구현은 다음을 보장해야 한다:</p>
    <ul>
      <li>전용 executing thread를 가진 모든 unblocked 에이전트는 결국 forward progress를 만든다.</li>
      <li>executing thread를 공유하는 에이전트 집합에서는 하나의 에이전트가 결국 forward progress를 만든다.</li>
      <li>에이전트는 차단(blocking)을 제공하는 명시적 API를 통한 경우를 제외하고 다른 에이전트를 blocked 상태로 만들지 않는다.</li>
    </ul>

    <emu-note>
      <p>이는 메모리 모델의 liveness 보장과 함께 모든 ~seq-cst~ 쓰기가 결국 모든 에이전트에 관측 가능해짐을 보장한다.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-weakref-processing-model">
    <h1>WeakRef 및 FinalizationRegistry 대상 처리 모델(Processing Model of WeakRef and FinalizationRegistry Targets)</h1>

    <emu-clause id="sec-weakref-invariants">
      <h1>목표(Objectives)</h1>

      <p>이 명세는 어떤 객체나 심볼이 가비지 컬렉션될 것이라는 보장을 제공하지 않는다. live가 아닌 객체나 심볼은 긴 시간이 지난 후 해제되거나 전혀 해제되지 않을 수 있다. 이런 이유로 본 명세는 가비지 컬렉션에 의해 트리거되는 동작을 설명할 때 "may"라는 용어를 사용한다.</p>

      <p>WeakRef와 FinalizationRegistry의 의미론은 특정 시점에 발생하는 두 연산에 기반한다:</p>

      <ul>
        <li>
          `WeakRef.prototype.deref`가 호출될 때, ( *undefined* 가 반환되지 않는 경우) 참조 대상(referent)은 이후의 동기적 접근에서 동일한 값을 반환할 수 있도록 살아 있게 유지된다. 이 목록(list)은 ClearKeptObjects 추상 연산을 사용해 동기 작업이 완료될 때 리셋된다.
        </li>

        <li>
          FinalizationRegistry에 등록된 객체나 심볼이 도달 불가능(unreachable)이 되면, FinalizationRegistry의 cleanup 콜백 호출이 동기 ECMAScript 실행이 완료된 후 언젠가 수행될 수 있다. FinalizationRegistry 정리는 CleanupFinalizationRegistry 추상 연산으로 수행된다.
        </li>
      </ul>

      <p>이 두 동작(ClearKeptObjects 또는 CleanupFinalizationRegistry)은 동기 ECMAScript 실행을 중단(interrupt)해서는 안 된다. 호스트는 더 긴 동기 ECMAScript 실행 구간을 구성할 수 있으므로, 이 명세는 ClearKeptObjects와 CleanupFinalizationRegistry의 스케줄링을 호스트 환경에 위임한다.</p>

      <p>일부 ECMAScript 구현에는 ECMAScript가 유휴(idle) 상태일 때를 포함해 백그라운드로 실행되는 가비지 컬렉터 구현이 포함되어 있다. 호스트 환경이 CleanupFinalizationRegistry를 스케줄하도록 하면, 구현이 파이널라이저 작업을 실행하기 위해 ECMAScript 실행을 재개하여 유지 중인 값을 해제함으로써 전체 메모리 사용량을 줄일 수 있다.</p>
    </emu-clause>

    <emu-clause id="sec-liveness">
      <h1>Liveness</h1>

      <p>객체 및/또는 심볼의 집합 _S_에 대해 <dfn>hypothetical WeakRef-oblivious(가설적 WeakRef-무관)</dfn> 실행이란, _S_의 요소인 참조 대상을 가진 WeakRef의 WeakRefDeref 추상 연산이 항상 *undefined*를 반환하는 실행을 말한다.</p>

      <emu-note>
        WeakRef-obliviousness와 liveness는 두 개념을 함께 포착한다. 첫째, WeakRef 자체는 그 참조 대상을 살아 있게 유지하지 않는다. 둘째, liveness에서의 사이클이 값이 live임을 의미하지는 않는다. 구체적으로, _v_의 liveness 결정이 WeakRef referent _r_의 liveness 결정에 의존한다면, _r_의 liveness는 _v_의 liveness를 가정할 수 없는데, 이는 순환 논리이기 때문이다.
      </emu-note>
      <emu-note>
        WeakRef-obliviousness는 사이클을 고려하기 위해 개별 값이 아닌 객체 또는 심볼 집합에 대해 정의된다. 개별 값에 대해 정의된다면, 사이클 내 WeakRef referent는 사이클 내 다른 WeakRef referent를 통해서만 그 정체성이 관측되더라도 live로 간주될 것이다.
      </emu-note>
      <emu-note>
        구어적으로는, 어떤 개별 객체나 심볼이 속한 모든 집합이 live이면 그 객체나 심볼을 live라고 말한다.
      </emu-note>

      <p>평가 도중 어느 시점에서든, 객체 및/또는 심볼 집합 _S_가 아래 조건 중 하나를 만족하면 <dfn>live</dfn>로 간주한다:</p>

      <ul>
        <li>
          _S_의 어떤 요소라도 어떤 에이전트의 [[KeptAlive]] List에 포함된다.
        </li>
        <li>
          _S_에 대한 어떤 유효한 미래의 가설적 WeakRef-oblivious 실행이 _S_ 내 값의 정체성을 관측한다.
        </li>
      </ul>
      <emu-note>
        두 번째 조건은 값의 정체성이 WeakRef 이외의 수단으로 관측 가능하다면 그 값이 live라는 직관을 포착하려는 것이다. 값의 정체성은 엄격 동등성 비교를 관측하거나 Map의 키로 사용되는 값을 관측함으로써 관측될 수 있다.
      </emu-note>
      <emu-note>
        <p>필드, 내부 슬롯, 프로퍼티 내 객체 또는 심볼의 존재는 그 값이 live임을 의미하지 않는다. 예를 들어 해당 값이 프로그램에 다시 전달되지 않는다면 관측될 수 없다.</p>

        <p>이는 WeakMap의 키, WeakSet의 멤버, 그리고 FinalizationRegistry Cell record의 [[WeakRefTarget]] 및 [[UnregisterToken]] 필드에 해당한다.</p>

        <p>위 정의는 WeakMap에서 어떤 키가 live가 아니면 그에 대응하는 값도 반드시 live일 필요는 없음을 의미한다.</p>
      </emu-note>
      <emu-note>
        Liveness는 엔진이 비워서는 안 되는 WeakRef에 대해 보장해야 하는 하한(lower bound)이다. 여기 정의된 Liveness는 결정 불가능(undecidable)하다. 실제로 엔진은 도달 가능성 같은 보수적 근사(approximation)를 사용한다. 구현 재량의 폭이 크다.
        <p></p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-execution">
      <h1>Execution</h1>

      <p>어느 시점에서든 객체 및/또는 심볼 집합 _S_가 live가 아니라면, ECMAScript 구현은 다음 단계를 원자적으로 수행할 수 있다:</p>

      <emu-alg>
        1. _S_의 각 요소 _value_에 대해
          1. _ref_.[[WeakRefTarget]]이 _value_인 각 WeakRef _ref_에 대해
            1. _ref_.[[WeakRefTarget]]을 ~empty~로 설정한다.
          1. _fg_.[[Cells]]가 [[WeakRefTarget]]이 _value_인 Record _cell_을 포함하는 각 FinalizationRegistry _fg_에 대해
            1. _cell_.[[WeakRefTarget]]을 ~empty~로 설정한다.
            1. 선택적으로 HostEnqueueFinalizationRegistryCleanupJob(_fg_)를 수행한다.
          1. _map_.[[WeakMapData]]가 [[Key]]가 _value_인 Record _r_을 포함하는 각 WeakMap _map_에 대해
            1. _r_.[[Key]]를 ~empty~로 설정한다.
            1. _r_.[[Value]]를 ~empty~로 설정한다.
          1. _set_.[[WeakSetData]]가 _value_를 포함하는 각 WeakSet _set_에 대해
            1. 값이 _value_인 _set_.[[WeakSetData]]의 요소를 값이 ~empty~인 요소로 교체한다.
      </emu-alg>

      <emu-note>
        <p>Liveness 정의와 함께, 본 절은 구현이 WeakRef에 관해 적용할 수 있는 최적화들을 규정한다.</p>

        <p>객체의 정체성을 관측하지 않고 객체에 접근하는 것이 가능하다. 정체성이 관측되지 않는, escape하지 않는 객체의 프로퍼티에 대해 dead variable elimination, scalar replacement 같은 최적화는 허용된다. 그러한 최적화는 해당 객체를 가리키는 WeakRef들을 관측 가능하게 비울 수 있다.</p>

        <p>반면 객체의 정체성이 관측 가능하고 그 객체가 WeakRef의 [[WeakRefTarget]] 내부 슬롯에 있다면, WeakRef를 관측 가능하게 비워 버리는 rematerialization 같은 최적화는 금지된다.</p>

        <p>HostEnqueueFinalizationRegistryCleanupJob 호출이 선택적이므로, FinalizationRegistry에 등록된 객체는 반드시 그 FinalizationRegistry를 live로 유지하지 않는다. 구현은 FinalizationRegistry 자체가 dead가 되었거나 애플리케이션이 종료 중인 경우 등 어떤 이유로든 FinalizationRegistry 콜백을 생략할 수 있다.</p>
      </emu-note>
      <emu-note>
        <p>구현은 live가 아닌 객체나 심볼의 최대 집합에 대해 WeakRef를 반드시 비울 필요는 없다.</p>
        <p>구현이 WeakRef를 비울 live가 아닌 집합 _S_를 선택한다면, 이 정의는 _S_ 내 모든 값에 대한 WeakRef를 동시에 비우도록 요구한다. 즉, 값 _v_를 가리키는 WeakRef 하나를 비우면서, 비워지지 않았다면 _v_의 값을 관측할 수도 있는 다른 WeakRef를 비우지 않은 채 두는 것은 적합(conformant)하지 않다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-host-hooks">
      <h1>호스트 훅(Host Hooks)</h1>

      <emu-clause id="sec-host-cleanup-finalization-registry" type="host-defined abstract operation">
        <h1>
          HostEnqueueFinalizationRegistryCleanupJob (
            _finalizationRegistry_: FinalizationRegistry,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <p>_finalizationRegistry_를 캡처하고 호출 시 다음 단계를 수행하는, 파라미터 없는 새 Job 추상 클로저 _cleanupJob_을 둔다:</p>
        <emu-alg>
          1. _cleanupResult_를 Completion(CleanupFinalizationRegistry(_finalizationRegistry_))로 둔다.
          1. _cleanupResult_가 abrupt completion이면 오류 보고를 위한 호스트 정의 단계를 수행한다.
          1. ~unused~를 반환한다.
        </emu-alg>
        <p>HostEnqueueFinalizationRegistryCleanupJob 구현은 가능하다면 미래의 어느 시점에 _cleanupJob_이 수행되도록 스케줄한다. 또한 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항을 따라야 한다.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-clear-kept-objects" type="abstract operation">
    <h1>ClearKeptObjects ( ): ~unused~</h1>
    <dl class="header">
      <dt>description</dt>
      <dd>ECMAScript 구현은 동기적인 ECMAScript 실행 시퀀스가 완료될 때 ClearKeptObjects를 호출하는 것이 기대된다.</dd>
    </dl>
    <emu-alg>
      1. _agentRecord_를 둘러싼 에이전트의 Agent Record로 둔다.
      1. _agentRecord_.[[KeptAlive]]를 새 빈 List로 설정한다.
      1. ~unused~를 반환한다.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-addtokeptobjects" type="abstract operation">
    <h1>
      AddToKeptObjects (
        _value_: an Object or a Symbol,
      ): ~unused~
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. _agentRecord_를 둘러싼 에이전트의 Agent Record로 둔다.
      1. _agentRecord_.[[KeptAlive]]에 _value_를 추가(Append)한다.
      1. ~unused~를 반환한다.
    </emu-alg>
    <emu-note>
      추상 연산 AddToKeptObjects가 어떤 대상 객체나 심볼과 함께 호출되면, ClearKeptObjects가 호출될 때까지 그 대상을 강하게 참조하는 목록에 대상을 추가한다.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-cleanup-finalization-registry" type="abstract operation">
    <h1>
      CleanupFinalizationRegistry (
        _finalizationRegistry_: a FinalizationRegistry,
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. 단언: _finalizationRegistry_는 [[Cells]] 및 [[CleanupCallback]] 내부 슬롯을 가진다.
      1. _callback_을 _finalizationRegistry_.[[CleanupCallback]]로 둔다.
      1. _finalizationRegistry_.[[Cells]]가 [[WeakRefTarget]]이 ~empty~인 Record _cell_을 포함하는 동안, 구현은 다음 단계를 수행할 수 있다:
        1. 그러한 _cell_ 중 임의의 하나를 선택한다.
        1. _finalizationRegistry_.[[Cells]]에서 _cell_을 제거한다.
        1. ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »)를 수행한다.
      1. ~unused~를 반환한다.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-canbeheldweakly" type="abstract operation">
    <h1>
      CanBeHeldWeakly (
        _v_: an ECMAScript language value,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>_v_가 약한 참조(weak reference)에 사용하기에 적합한 경우에만 *true*를 반환한다. 약한 참조에 사용하기에 적합한 값만이 WeakMap의 키, WeakSet의 요소, WeakRef의 target, 또는 FinalizationRegistry의 target들 중 하나가 될 수 있다.</dd>
    </dl>
    <emu-alg>
      1. _v_가 Object이면 *true*를 반환한다.
      1. _v_가 Symbol이고 KeyForSymbol(_v_)이 *undefined*이면 *true*를 반환한다.
      1. *false*를 반환한다.
    </emu-alg>
    <emu-note>
      <p><emu-xref href="#sec-identity">언어 정체성(language identity)</emu-xref>이 없는 언어 값은 사전 참조 없이도 나타날 수 있으며 약한 참조로 사용하기에 부적합하다. <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>로 생성된 Symbol 값은 다른 Symbol 값과 달리 언어 정체성이 없으므로 약한 참조로 사용하기에 부적합하다. <emu-xref href="#sec-well-known-symbols">Well-known symbols</emu-xref>는 수집되지 않을 가능성이 높지만, 그 수가 제한되어 있고 다양한 구현 방식으로 관리 가능하므로 약한 참조로 사용하기에 적합한 것으로 간주된다. 그러나 live한 WeakMap 안의 well-known symbol에 연관된 어떤 값도 수집되지 않아 메모리 자원이 “누수”될 가능성이 있다.</p>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>일반(Ordinary) 및 이그조틱(Exotic) 객체 동작</h1>

  <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
    <h1>일반 객체의 내부 메서드와 내부 슬롯(Ordinary Object Internal Methods and Internal Slots)</h1>
    <p>모든 일반 객체는 [[Prototype]]이라 불리는 내부 슬롯을 가진다. 이 내부 슬롯의 값은 *null* 혹은 객체이며 상속을 구현하는 데 사용된다. 일반 객체 _O_ 에 속성 _P_ 가 없지만 그 객체의 [[Prototype]] 객체에는 존재한다고 가정하자. _P_ 가 [[Prototype]] 객체의 데이터 프로퍼티를 가리키면 _O_ 는 get 접근에 대해 그것을 상속하여 _P_ 가 마치 _O_ 의 자체 프로퍼티인 것처럼 동작한다. _P_ 가 [[Prototype]] 객체의 쓰기 가능한(writable) 데이터 프로퍼티를 가리키면 _O_ 에서 _P_ 에 대한 set 접근은 _O_ 에 이름이 _P_ 인 새로운 데이터 프로퍼티를 생성한다. _P_ 가 [[Prototype]] 객체의 쓰기 불가능한(non-writable) 데이터 프로퍼티를 가리키면 _O_ 에서 _P_ 에 대한 set 접근은 실패한다. _P_ 가 [[Prototype]] 객체의 접근자(accessor) 프로퍼티를 가리키면 그 접근자는 get 과 set 둘 다에 대해 _O_ 에 상속된다.</p>
    <p>모든 일반 객체는 Boolean 값을 갖는 [[Extensible]] 내부 슬롯을 가지며 이는 <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 에 명시된 확장성 관련 내부 메서드 불변식을 충족하는 데 사용된다. 즉, 객체의 [[Extensible]] 내부 슬롯 값이 *false* 로 설정되면 더 이상 그 객체에 새로운 프로퍼티를 추가하거나 객체의 [[Prototype]] 내부 슬롯 값을 수정하거나 이후 [[Extensible]] 값을 *true* 로 되돌릴 수 없다.</p>
    <p>이하의 알고리즘 설명에서 _O_ 는 일반 객체, _P_ 는 프로퍼티 키 값, _V_ 는 임의의 ECMAScript 언어 값, _Desc_ 는 프로퍼티 디스크립터(Property Descriptor) 레코드라고 가정한다.</p>
    <p>각 일반 객체 내부 메서드는 동일하거나 유사한 이름의 추상 연산에 위임한다. 그러한 추상 연산이 또 다른 내부 메서드에 의존하는 경우, 동일 이름의 추상 연산을 직접 호출하지 않고 _O_ 에 그 내부 메서드를 호출한다. 이러한 의미론은 일반 객체 내부 메서드가 이그조틱 객체에 적용될 때 해당 이그조틱 객체가 재정의한 내부 메서드가 호출되도록 보장한다.</p>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): 객체 또는 *null* 을 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryGetPrototypeOf(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarygetprototypeof" type="abstract operation">
        <h1>
          OrdinaryGetPrototypeOf (
            _O_: an Object,
          ): an Object or *null*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Prototype]] 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): Boolean 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinarySetPrototypeOf(_O_, _V_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarysetprototypeof" type="abstract operation">
        <h1>
          OrdinarySetPrototypeOf (
            _O_: an Object,
            _V_: an Object or *null*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ 를 _O_.[[Prototype]] 로 둔다.
          1. SameValue(_V_, _current_) 가 *true* 이면 *true* 를 반환한다.
          1. _extensible_ 을 _O_.[[Extensible]] 로 둔다.
          1. _extensible_ 이 *false* 이면 *false* 를 반환한다.
          1. _p_ 를 _V_ 로 둔다.
          1. _done_ 을 *false* 로 둔다.
          1. [id="step-ordinarysetprototypeof-loop"] _done_ 이 *false* 인 동안 반복한다,
            1. _p_ 가 *null* 이면
              1. _done_ 을 *true* 로 설정한다.
            1. 아니고 SameValue(_p_, _O_) 가 *true* 이면
              1. *false* 를 반환한다.
            1. 그 밖의 경우,
              1. _p_.[[GetPrototypeOf]] 가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref> 에 정의된 일반 객체 내부 메서드가 아니면 _done_ 을 *true* 로 설정한다.
              1. 아니면 _p_ 를 _p_.[[Prototype]] 로 설정한다.
          1. _O_.[[Prototype]] 을 _V_ 로 설정한다.
          1. *true* 를 반환한다.
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-ordinarysetprototypeof-loop"></emu-xref> 단계의 루프는 [[GetPrototypeOf]] 와 [[SetPrototypeOf]] 에 대한 일반 객체 정의만 사용하는 객체들로 이루어진 어떤 프로토타입 체인에도 순환이 생기지 않도록 보장한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): Boolean 을 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryIsExtensible(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryisextensible" type="abstract operation">
        <h1>
          OrdinaryIsExtensible (
            _O_: an Object,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Extensible]] 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): *true* 를 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryPreventExtensions(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarypreventextensions" type="abstract operation">
        <h1>
          OrdinaryPreventExtensions (
            _O_: an Object,
          ): *true*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Extensible]] 를 *false* 로 설정한다.
          1. *true* 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): Property Descriptor 또는 *undefined* 를 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryGetOwnProperty(_O_, _P_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarygetownproperty" type="abstract operation">
        <h1>
          OrdinaryGetOwnProperty (
            _O_: an Object,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_ 가 키 _P_ 인 자체 프로퍼티를 갖지 않으면 *undefined* 를 반환한다.
          1. 필드가 없는 새 프로퍼티 디스크립터 _D_ 를 생성한다.
          1. _X_ 를 키 _P_ 인 _O_ 의 자체 프로퍼티로 둔다.
          1. _X_ 가 데이터 프로퍼티라면
            1. _D_.[[Value]] 를 _X_ 의 [[Value]] 속성 값으로 설정한다.
            1. _D_.[[Writable]] 을 _X_ 의 [[Writable]] 속성 값으로 설정한다.
          1. 그렇지 않으면
            1. 단언: _X_ 는 접근자 프로퍼티이다.
            1. _D_.[[Get]] 을 _X_ 의 [[Get]] 속성 값으로 설정한다.
            1. _D_.[[Set]] 을 _X_ 의 [[Set]] 속성 값으로 설정한다.
          1. _D_.[[Enumerable]] 을 _X_ 의 [[Enumerable]] 속성 값으로 설정한다.
          1. _D_.[[Configurable]] 을 _X_ 의 [[Configurable]] 속성 값으로 설정한다.
          1. _D_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarydefineownproperty" type="abstract operation">
        <h1>
          OrdinaryDefineOwnProperty (
            _O_: an Object,
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _extensible_ 을 ? IsExtensible(_O_) 로 둔다.
          1. ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iscompatiblepropertydescriptor" type="abstract operation">
        <h1>
          IsCompatiblePropertyDescriptor (
            _Extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _Current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ValidateAndApplyPropertyDescriptor(*undefined*, *""*, _Extensible_, _Desc_, _Current_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateandapplypropertydescriptor" type="abstract operation">
        <h1>
          ValidateAndApplyPropertyDescriptor (
            _O_: an Object or *undefined*,
            _P_: a property key,
            _extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_Desc_ 가 지정된 _extensibility_ 와 현재 프로퍼티 _current_ 를 가진 객체의 프로퍼티로 ( <emu-xref href="#sec-invariants-of-the-essential-internal-methods">불변식</emu-xref> 을 유지하면서) 적용될 수 있을 때에만 *true* 를 반환한다. 적용 가능하고 _O_ 가 *undefined* 가 아니면 이름이 _P_ 인 프로퍼티(필요 시 생성됨)에 대해 실제로 적용한다.</dd>
        </dl>
        <emu-alg>
          1. 단언: _P_ 는 프로퍼티 키이다.
          1. _current_ 가 *undefined* 이면
            1. _extensible_ 이 *false* 이면 *false* 반환.
            1. _O_ 가 *undefined* 이면 *true* 반환.
            1. IsAccessorDescriptor(_Desc_) 가 *true* 이면
              1. 객체 _O_ 에 이름 _P_ 인 자체 접근자 프로퍼티를 생성하되 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 그 속성의 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 으로 설정.
            1. 그렇지 않으면
              1. 객체 _O_ 에 이름 _P_ 인 자체 데이터 프로퍼티를 생성하되 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 그 속성의 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 으로 설정.
            1. *true* 반환.
          1. 단언: _current_ 는 완전히 채워진(Property Descriptor 모든 필드 보유) 프로퍼티 디스크립터이다.
          1. _Desc_ 가 어떤 필드도 갖지 않으면 *true* 반환.
          1. _current_.[[Configurable]] 이 *false* 이면
            1. _Desc_ 에 [[Configurable]] 필드가 있고 _Desc_.[[Configurable]] 이 *true* 이면 *false* 반환.
            1. _Desc_ 에 [[Enumerable]] 필드가 있고 _Desc_.[[Enumerable]] 이 _current_.[[Enumerable]] 와 다르면 *false* 반환.
            1. IsGenericDescriptor(_Desc_) 가 *false* 이고 IsAccessorDescriptor(_Desc_) 가 IsAccessorDescriptor(_current_) 와 다르면 *false* 반환.
            1. IsAccessorDescriptor(_current_) 가 *true* 이면
              1. _Desc_ 에 [[Get]] 필드가 있고 SameValue(_Desc_.[[Get]], _current_.[[Get]]) 가 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Set]] 필드가 있고 SameValue(_Desc_.[[Set]], _current_.[[Set]]) 가 *false* 이면 *false* 반환.
            1. Else if _current_.[[Writable]] 이 *false* 이면
              1. _Desc_ 에 [[Writable]] 필드가 있고 _Desc_.[[Writable]] 이 *true* 이면 *false* 반환.
              1. NOTE: SameValue 는 *NaN* 에 대해 *true* 를 반환한다. 여기서 반환하면 기존 프로퍼티가 수정되지 않음을 보장한다.
              1. _Desc_ 에 [[Value]] 필드가 있으면 SameValue(_Desc_.[[Value]], _current_.[[Value]]) 를 반환.
          1. _O_ 가 *undefined* 가 아니면
            1. IsDataDescriptor(_current_) 가 *true* 이고 IsAccessorDescriptor(_Desc_) 가 *true* 이면
              1. _Desc_ 에 [[Configurable]] 필드가 있으면 _configurable_ 을 그 값으로, 아니면 _current_.[[Configurable]] 로 둔다.
              1. _Desc_ 에 [[Enumerable]] 필드가 있으면 _enumerable_ 을 그 값으로, 아니면 _current_.[[Enumerable]] 로 둔다.
              1. 객체 _O_ 의 이름 _P_ 인 프로퍼티를 접근자 프로퍼티로 교체하되 [[Configurable]] 과 [[Enumerable]] 은 각각 _configurable_, _enumerable_ 로, [[Get]], [[Set]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 로 설정.
            1. Else if IsAccessorDescriptor(_current_) 가 *true* 이고 IsDataDescriptor(_Desc_) 가 *true* 이면
              1. _Desc_ 에 [[Configurable]] 필드가 있으면 _configurable_ 을 그 값으로, 아니면 _current_.[[Configurable]] 로 둔다.
              1. _Desc_ 에 [[Enumerable]] 필드가 있으면 _enumerable_ 을 그 값으로, 아니면 _current_.[[Enumerable]] 로 둔다.
              1. 객체 _O_ 의 이름 _P_ 인 프로퍼티를 데이터 프로퍼티로 교체하되 [[Configurable]] 과 [[Enumerable]] 은 각각 _configurable_, _enumerable_ 로, [[Value]], [[Writable]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 로 설정.
            1. Else
              1. _Desc_ 의 각 필드에 대해 객체 _O_ 의 이름 _P_ 인 프로퍼티의 대응 속성을 그 필드 값으로 설정.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryHasProperty(_O_, _P_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryhasproperty" type="abstract operation">
        <h1>
          OrdinaryHasProperty (
            _O_: an Object,
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _hasOwn_ 을 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _hasOwn_ 이 *undefined* 가 아니면 *true* 반환.
          1. _parent_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
          1. _parent_ 가 *null* 이 아니면
            1. ? <emu-meta effects="user-code">_parent_.[[HasProperty]]</emu-meta>(_P_) 를 반환한다.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>

      <emu-alg>
        1. ? OrdinaryGet(_O_, _P_, _Receiver_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryget" type="abstract operation">
        <h1>
          OrdinaryGet (
            _O_: an Object,
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면
            1. _parent_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
            1. _parent_ 가 *null* 이면 *undefined* 반환.
            1. ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_) 를 반환한다.
          1. IsDataDescriptor(_desc_) 가 *true* 이면 _desc_.[[Value]] 를 반환한다.
          1. 단언: IsAccessorDescriptor(_desc_) 는 *true* 이다.
          1. _getter_ 를 _desc_.[[Get]] 로 둔다.
          1. _getter_ 가 *undefined* 이면 *undefined* 반환.
          1. ? Call(_getter_, _Receiver_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinarySet(_O_, _P_, _V_, _Receiver_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryset" type="abstract operation">
        <h1>
          OrdinarySet (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _ownDesc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarysetwithowndescriptor" type="abstract operation">
        <h1>
          OrdinarySetWithOwnDescriptor (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
            _ownDesc_: a Property Descriptor or *undefined*,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _ownDesc_ 가 *undefined* 이면
            1. _parent_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
            1. _parent_ 가 *null* 이 아니면
              1. ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_) 를 반환한다.
            1. 그렇지 않으면
              1. _ownDesc_ 를 PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } 로 설정한다.
          1. IsDataDescriptor(_ownDesc_) 가 *true* 이면
            1. _ownDesc_.[[Writable]] 이 *false* 이면 *false* 반환.
            1. _Receiver_ 가 객체가 아니면 *false* 반환.
            1. _existingDescriptor_ 를 ? <emu-meta effects="user-code">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
            1. _existingDescriptor_ 가 *undefined* 가 아니면
              1. IsAccessorDescriptor(_existingDescriptor_) 가 *true* 이면 *false* 반환.
              1. _existingDescriptor_.[[Writable]] 이 *false* 이면 *false* 반환.
              1. _valueDesc_ 를 PropertyDescriptor { [[Value]]: _V_ } 로 둔다.
              1. ? <emu-meta effects="user-code">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_) 를 반환한다.
            1. 그렇지 않으면
              1. 단언: _Receiver_ 는 현재 프로퍼티 _P_ 를 갖지 않는다.
              1. ? CreateDataProperty(_Receiver_, _P_, _V_) 를 반환한다.
          1. 단언: IsAccessorDescriptor(_ownDesc_) 는 *true* 이다.
          1. _setter_ 를 _ownDesc_.[[Set]] 로 둔다.
          1. _setter_ 가 *undefined* 이면 *false* 반환.
          1. ? Call(_setter_, _Receiver_, « _V_ ») 를 수행한다.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryDelete(_O_, _P_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarydelete" type="abstract operation">
        <h1>
          OrdinaryDelete (
            _O_: an Object,
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면 *true* 반환.
          1. _desc_.[[Configurable]] 이 *true* 이면
            1. 이름 _P_ 인 자체 프로퍼티를 _O_ 에서 제거한다.
            1. *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryOwnPropertyKeys(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryownpropertykeys" type="abstract operation">
        <h1>
          OrdinaryOwnPropertyKeys (
            _O_: an Object,
          ): a List of property keys
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _keys_ 를 새 빈 List 로 둔다.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 배열 인덱스인 것들을 숫자 인덱스 오름차순으로 순회하며
            1. _keys_ 에 _P_ 를 추가한다.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 String 이고 배열 인덱스가 아닌 것들을 생성 시점의 시간 순(chronological order) 오름차순으로 순회하며
            1. _keys_ 에 _P_ 를 추가한다.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 Symbol 인 것들을 생성 시점의 시간 순 오름차순으로 순회하며
            1. _keys_ 에 _P_ 를 추가한다.
          1. _keys_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinaryobjectcreate" type="abstract operation" oldids="sec-objectcreate">
      <h1>
        OrdinaryObjectCreate (
          _proto_: an Object or *null*,
          optional _additionalInternalSlotsList_: a List of names of internal slots,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>새 일반 객체를 런타임에 생성하는 과정을 명세하는 데 사용된다. _additionalInternalSlotsList_ 는 [[Prototype]] 과 [[Extensible]] 외에 객체 일부로 정의되어야 하는 추가 내부 슬롯 이름을 담는다. _additionalInternalSlotsList_ 가 제공되지 않으면 새 빈 List 를 사용한다.</dd>
      </dl>
      <emu-alg>
        1. _internalSlotsList_ 를 « [[Prototype]], [[Extensible]] » 로 둔다.
        1. _additionalInternalSlotsList_ 가 주어지면 _internalSlotsList_ 를 그 뒤에 _additionalInternalSlotsList_ 를 이어붙인(list-concatenation) 리스트로 갱신한다.
        1. _O_ 를 MakeBasicObject(_internalSlotsList_) 로 둔다.
        1. _O_.[[Prototype]] 을 _proto_ 로 설정한다.
        1. _O_ 를 반환한다.
      </emu-alg>

      <emu-note>
        <p>OrdinaryObjectCreate 는 MakeBasicObject 호출 외에 많은 일을 하지 않지만, 이를 사용함으로써 이그조틱이 아닌 “일반 객체” 를 만들고자 함을 전달한다. 따라서 이 명세에서 결과 객체의 내부 메서드를 비일반적으로 만들 방식으로 이후 수정하는 어떤 알고리즘도 이를 호출하지 않는다. 이그조틱 객체를 생성하는 연산은 MakeBasicObject 를 직접 호출한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinarycreatefromconstructor" type="abstract operation">
      <h1>
        OrdinaryCreateFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
          optional _internalSlotsList_: a List of names of internal slots,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>생성자의 *"prototype"* 프로퍼티가 존재하면 거기서 가져온 값을 [[Prototype]] 으로 하는 일반 객체를 생성한다. 그렇지 않으면 _intrinsicDefaultProto_ 로 명명된 intrinsic 이 [[Prototype]] 으로 사용된다. _internalSlotsList_ 는 객체 일부로 정의되어야 하는 추가 내부 슬롯 이름을 담으며 제공되지 않으면 새 빈 List 를 사용한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _intrinsicDefaultProto_ 는 이 명세에서 정의한 intrinsic 객체의 이름이다. 해당 객체는 다른 객체의 [[Prototype]] 값으로 사용되도록 의도된 intrinsic 이어야 한다.
        1. _proto_ 를 ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_) 로 둔다.
        1. _internalSlotsList_ 가 존재하면 _slotsList_ 를 _internalSlotsList_ 로 둔다.
        1. 아니면 _slotsList_ 를 새 빈 List 로 둔다.
        1. OrdinaryObjectCreate(_proto_, _slotsList_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getprototypefromconstructor" type="abstract operation">
      <h1>
        GetPrototypeFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>특정 생성자에 대응하는 객체를 만들 때 사용할 [[Prototype]] 값을 결정한다. 생성자의 *"prototype"* 프로퍼티가 존재하면 그 값이 사용되고, 그렇지 않으면 _intrinsicDefaultProto_ 로 명명된 intrinsic 이 [[Prototype]] 으로 사용된다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _intrinsicDefaultProto_ 는 이 명세에서 정의한 intrinsic 객체의 이름이다. 해당 객체는 객체의 [[Prototype]] 값으로 사용되도록 의도된 intrinsic 이어야 한다.
        1. _proto_ 를 ? Get(_constructor_, *"prototype"*) 로 둔다.
        1. _proto_ 가 객체가 아니면
          1. _realm_ 을 ? GetFunctionRealm(_constructor_) 로 둔다.
          1. _proto_ 를 _realm_ 의 _intrinsicDefaultProto_ 라는 이름의 intrinsic 객체로 설정한다.
        1. _proto_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>_constructor_ 가 [[Prototype]] 값을 제공하지 않으면 사용되는 기본값은 실행 중인 실행 컨텍스트가 아니라 _constructor_ 함수의 realm 에서 얻는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-requireinternalslot" type="abstract operation">
      <h1>
        RequireInternalSlot (
          _O_: an ECMAScript language value,
          _internalSlot_: an internal slot name,
        ): ~unused~ 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_ 가 객체가 아니거나 지정된 내부 슬롯을 가지지 않으면 예외를 던진다.</dd>
      </dl>
      <emu-alg>
        1. _O_ 가 객체가 아니면 *TypeError* 예외를 던진다.
        1. _O_ 에 _internalSlot_ 내부 슬롯이 없으면 *TypeError* 예외를 던진다.
        1. ~unused~ 를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript 함수 객체(ECMAScript Function Objects)</h1>
    <p>ECMAScript 함수 객체는 렉시컬 환경을 클로즈(over)한 매개변수화된 ECMAScript 코드를 캡슐화하며 그 코드를 동적으로 평가할 수 있게 해준다. ECMAScript 함수 객체는 일반 객체(ordinary object)이며 다른 일반 객체와 동일한 내부 슬롯과 내부 메서드를 가진다. ECMAScript 함수 객체의 코드는 strict 모드 코드(<emu-xref href="#sec-strict-mode-code"></emu-xref>) 또는 비 strict 코드일 수 있다. 코드가 strict 모드 코드인 ECMAScript 함수 객체를 <dfn id="strict-function" variants="strict functions">strict 함수</dfn>라 한다. 코드가 strict 모드 코드가 아닌 것을 <dfn id="non-strict-function" variants="non-strict functions">non‑strict 함수</dfn>라 한다.</p>
    <p>[[Extensible]] 및 [[Prototype]] 외에도, ECMAScript 함수 객체는 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>에 나열된 내부 슬롯을 추가로 가진다.</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="ECMAScript 함수 객체의 내부 슬롯(Internal Slots of ECMAScript Function Objects)" oldids="table-27">
      <table>
        <thead>
          <tr>
            <th>Internal Slot</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tr>
          <td>[[Environment]]</td>
          <td>an Environment Record</td>
          <td>함수가 클로즈한 Environment Record. 함수 코드 평가 시 외부 환경(outer environment)으로 사용.</td>
        </tr>
        <tr>
          <td>[[PrivateEnvironment]]</td>
          <td>a PrivateEnvironment Record or *null*</td>
          <td>함수가 클로즈한 Private Name 용 PrivateEnvironment Record. 함수가 문법적으로 어떤 클래스 내부에도 포함되지 않았다면 *null*. 함수 코드 평가 시 내부 클래스들의 외부 PrivateEnvironment로 사용.</td>
        </tr>
        <tr>
          <td>[[FormalParameters]]</td>
          <td>a Parse Node</td>
          <td>함수의 형식 매개변수 목록을 정의하는 소스 텍스트의 루트 Parse Node.</td>
        </tr>
        <tr>
          <td>[[ECMAScriptCode]]</td>
          <td>a Parse Node</td>
          <td>함수 본문을 정의하는 소스 텍스트의 루트 Parse Node.</td>
        </tr>
        <tr>
          <td>[[ConstructorKind]]</td>
          <td>~base~ or ~derived~</td>
          <td>함수가 파생 클래스 생성자인지 여부.</td>
        </tr>
        <tr>
          <td>[[Realm]]</td>
          <td>a Realm Record</td>
          <td>함수가 생성된 realm이며 함수 평가 시 접근되는 intrinsic 객체들을 제공.</td>
        </tr>
        <tr>
          <td>[[ScriptOrModule]]</td>
          <td>a Script Record or a Module Record</td>
          <td>함수가 생성된 스크립트 또는 모듈.</td>
        </tr>
        <tr>
          <td>[[ThisMode]]</td>
          <td>~lexical~, ~strict~, or ~global~</td>
          <td>`this` 참조가 형식 매개변수 및 함수 본문 내에서 어떻게 해석되는지 정의. ~lexical~ 은 `this` 가 렉시컬로 둘러싼 함수의 *this* 값을 가리킴. ~strict~ 은 *this* 값이 호출 시 제공된 그대로 사용됨. ~global~ 은 *undefined* 또는 *null* 인 *this* 값을 전역 객체 참조로 해석하고, 다른 *this* 값은 먼저 ToObject 적용.</td>
        </tr>
        <tr>
          <td>[[Strict]]</td>
          <td>a Boolean</td>
          <td>*true* 이면 strict 함수, *false* 이면 non‑strict 함수.</td>
        </tr>
        <tr>
          <td>[[HomeObject]]</td>
          <td>an Object</td>
          <td>함수가 `super`를 사용한다면, `super` 프로퍼티 조회의 시작점을 제공하는 [[GetPrototypeOf]] 대상 객체.</td>
        </tr>
        <tr>
          <td>[[SourceText]]</td>
          <td>a sequence of Unicode code points</td>
          <td>함수를 정의하는 <emu-xref href="#sec-source-text">소스 텍스트</emu-xref>.</td>
        </tr>
        <tr>
          <td>[[Fields]]</td>
          <td>a List of ClassFieldDefinition Records</td>
          <td>함수가 클래스라면, 비정적 필드 및 그 초기화자를 나타내는 Record들의 목록.</td>
        </tr>
        <tr>
          <td>[[PrivateMethods]]</td>
          <td>a List of PrivateElements</td>
          <td>함수가 클래스라면, 비정적 private 메서드 및 접근자들을 나타내는 목록.</td>
        </tr>
        <tr>
          <td>[[ClassFieldInitializerName]]</td>
          <td>a String, a Symbol, a Private Name, or ~empty~</td>
          <td>함수가 클래스 필드 초기화자로 생성된 경우, 필드의 NamedEvaluation에 사용할 이름; 그렇지 않으면 ~empty~.</td>
        </tr>
        <tr>
          <td>[[IsClassConstructor]]</td>
          <td>a Boolean</td>
          <td>함수가 클래스 생성자인지 나타냄. (*true* 이면 함수의 [[Call]] 호출은 즉시 *TypeError* 예외 throw).</td>
        </tr>
      </table>
    </emu-table>
    <p>모든 ECMAScript 함수 객체는 여기 정의된 [[Call]] 내부 메서드를 가진다. 동시에 생성자인 ECMAScript 함수는 추가로 [[Construct]] 내부 메서드를 가진다.</p>

    <emu-clause id="sec-ecmascript-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>ECMAScript 함수 객체 _F_</dd>
      </dl>
      <emu-alg>
        1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _calleeContext_ 를 PrepareForOrdinaryCall(_F_, *undefined*) 로 둔다.
        1. 단언: _calleeContext_ 가 이제 실행 중 실행 컨텍스트.
        1. _F_.[[IsClassConstructor]] 가 *true* 이면
          1. 새 *TypeError* 객체 _error_ 를 생성한다.
          1. NOTE: _error_ 는 _calleeContext_ 에서 _F_ 의 Realm Record 로 생성된다.
          1. 실행 컨텍스트 스택에서 _calleeContext_ 를 제거하고 _callerContext_ 를 실행 중 실행 컨텍스트로 복원한다.
          1. ThrowCompletion(_error_) 를 반환한다.
        1. OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_) 를 수행한다.
        1. _result_ 를 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)) 로 둔다.
        1. [id="step-call-pop-context-stack"] 실행 컨텍스트 스택에서 _calleeContext_ 를 제거하고 _callerContext_ 를 실행 중 실행 컨텍스트로 복원한다.
        1. _result_ 가 return completion 이면 _result_.[[Value]] 반환.
        1. 단언: _result_ 는 throw completion.
        1. ? _result_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>단계 <emu-xref href="#step-call-pop-context-stack"></emu-xref> 에서 _calleeContext_ 가 스택에서 제거될 때 접근 가능한 Generator 에 의해 나중 재개를 위해 suspend 및 보존된 경우 파괴되면 안 된다.</p>
      </emu-note>

      <emu-clause id="sec-prepareforordinarycall" type="abstract operation">
        <h1>
          PrepareForOrdinaryCall (
            _F_: an ECMAScript function object,
            _newTarget_: an Object or *undefined*,
          ): an execution context
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
          1. _calleeContext_ 를 새 ECMAScript 코드 실행 컨텍스트로 둔다.
          1. _calleeContext_ 의 Function 을 _F_ 로 설정.
          1. _calleeRealm_ 을 _F_.[[Realm]] 로 둔다.
          1. _calleeContext_ 의 Realm 을 _calleeRealm_ 으로 설정.
          1. _calleeContext_ 의 ScriptOrModule 을 _F_.[[ScriptOrModule]] 로 설정.
          1. _localEnv_ 를 NewFunctionEnvironment(_F_, _newTarget_) 로 둔다.
          1. _calleeContext_ 의 LexicalEnvironment 를 _localEnv_ 로 설정.
          1. _calleeContext_ 의 VariableEnvironment 를 _localEnv_ 로 설정.
          1. _calleeContext_ 의 PrivateEnvironment 를 _F_.[[PrivateEnvironment]] 로 설정.
          1. _callerContext_ 가 아직 suspend 되어 있지 않다면 suspend 한다.
          1. _calleeContext_ 를 실행 컨텍스트 스택에 push; _calleeContext_ 가 이제 실행 중 실행 컨텍스트.
          1. NOTE: 이 지점 이후 생성되는 모든 예외 객체는 _calleeRealm_ 과 연관됨.
          1. _calleeContext_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallbindthis" type="abstract operation">
        <h1>
          OrdinaryCallBindThis (
            _F_: an ECMAScript function object,
            _calleeContext_: an execution context,
            _thisArgument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _thisMode_ 를 _F_.[[ThisMode]] 로 둔다.
          1. _thisMode_ 가 ~lexical~ 이면 ~unused~ 반환.
          1. _calleeRealm_ 을 _F_.[[Realm]] 로 둔다.
          1. _localEnv_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
          1. _thisMode_ 가 ~strict~ 이면
            1. _thisValue_ 를 _thisArgument_ 로 둔다.
          1. 그렇지 않으면
            1. _thisArgument_ 가 *undefined* 또는 *null* 이면
              1. _globalEnv_ 를 _calleeRealm_.[[GlobalEnv]] 로 둔다.
              1. 단언: _globalEnv_ 는 Global Environment Record.
              1. _thisValue_ 를 _globalEnv_.[[GlobalThisValue]] 로 둔다.
            1. 아니면
              1. _thisValue_ 를 ! ToObject(_thisArgument_) 로 둔다.
              1. NOTE: ToObject 는 _calleeRealm_ 을 사용하여 wrapper 객체를 생성.
          1. 단언: _localEnv_ 는 Function Environment Record.
          1. 단언: 다음 단계는 _localEnv_.[[ThisBindingStatus]] 가 ~initialized~ 가 아니므로 abrupt completion 을 반환하지 않는다.
          1. ! BindThisValue(_localEnv_, _thisValue_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-evaluatebody" type="sdo">
        <h1>
          Runtime Semantics: EvaluateBody (
            _functionObject_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header"></dl>
        <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
        <emu-alg>
          1. |FunctionBody| 의 EvaluateFunctionBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. |ConciseBody| 의 EvaluateConciseBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |GeneratorBody| 의 EvaluateGeneratorBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>AsyncGeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |AsyncGeneratorBody| 의 EvaluateAsyncGeneratorBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>AsyncFunctionBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |AsyncFunctionBody| 의 EvaluateAsyncFunctionBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. |AsyncConciseBody| 의 EvaluateAsyncConciseBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>
          Initializer :
            `=` AssignmentExpression
        </emu-grammar>
        <emu-alg>
          1. 단언: _argumentsList_ 는 비어 있다.
          1. 단언: _functionObject_.[[ClassFieldInitializerName]] 는 ~empty~ 가 아니다.
            1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이면
              1. _value_ 를 |Initializer| 의 NamedEvaluation (인수 _functionObject_.[[ClassFieldInitializerName]]) ? 로 둔다.
            1. 그렇지 않으면
              1. _rhs_ 를 |AssignmentExpression| 의 Evaluation ? 로 둔다.
              1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. ReturnCompletion(_value_) 를 반환.
        </emu-alg>
        <emu-note>
          <p>필드 초기화자는 함수 경계를 형성하지만 FunctionDeclarationInstantiation 호출은 관측 가능한 효과가 없으므로 생략된다.</p>
        </emu-note>
        <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
        <emu-alg>
          1. 단언: _argumentsList_ 는 비어 있다.
          1. |ClassStaticBlockBody| 의 EvaluateClassStaticBlockBody (인수 _functionObject_) ? 를 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallevaluatebody" type="abstract operation">
        <h1>
          OrdinaryCallEvaluateBody (
            _F_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _F_.[[ECMAScriptCode]] 의 EvaluateBody (인수 _F_, _argumentsList_) ? 를 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>ECMAScript 함수 객체 _F_</dd>
      </dl>
      <emu-alg>
        1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _kind_ 를 _F_.[[ConstructorKind]] 로 둔다.
        1. _kind_ 가 ~base~ 이면
          1. _thisArgument_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*) 로 둔다.
        1. _calleeContext_ 를 PrepareForOrdinaryCall(_F_, _newTarget_) 로 둔다.
        1. 단언: _calleeContext_ 가 이제 실행 중 실행 컨텍스트.
        1. _kind_ 가 ~base~ 이면
          1. OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_) 수행.
          1. _initializeResult_ 를 Completion(InitializeInstanceElements(_thisArgument_, _F_)) 로 둔다.
          1. _initializeResult_ 가 abrupt completion 이면
            1. 실행 컨텍스트 스택에서 _calleeContext_ 제거 후 _callerContext_ 복원.
            1. ? _initializeResult_ 반환.
        1. _constructorEnv_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
        1. _result_ 를 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)) 로 둔다.
        1. 실행 컨텍스트 스택에서 _calleeContext_ 제거 후 _callerContext_ 복원.
        1. _result_ 가 throw completion 이면
          1. ? _result_ 반환.
        1. 단언: _result_ 는 return completion.
        1. _result_.[[Value]] 가 객체이면 그 값 반환.
        1. _kind_ 가 ~base~ 이면 _thisArgument_ 반환.
        1. _result_.[[Value]] 가 *undefined* 가 아니면 *TypeError* 예외 throw.
        1. _thisBinding_ 을 ? _constructorEnv_.GetThisBinding() 로 둔다.
        1. 단언: _thisBinding_ 은 객체.
        1. _thisBinding_ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" type="abstract operation" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>
        OrdinaryFunctionCreate (
          _functionPrototype_: an Object,
          _sourceText_: a sequence of Unicode code points,
          _ParameterList_: a Parse Node,
          _Body_: a Parse Node,
          _thisMode_: ~lexical-this~ or ~non-lexical-this~,
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>기본 [[Call]] 내부 메서드만 있고 [[Construct]] 내부 메서드는 없는(단, 이후 MakeConstructor 같은 연산으로 추가될 수 있음) 새 함수를 런타임에 생성하는 과정을 명세한다. _sourceText_ 는 생성할 함수 문법 정의의 소스 텍스트.</dd>
      </dl>
      <emu-alg>
        1. _internalSlotsList_ 를 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 나열된 내부 슬롯으로 둔다.
        1. _F_ 를 OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_) 로 둔다.
        1. _F_.[[Call]] 을 <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 에 명시된 정의로 설정.
        1. _F_.[[SourceText]] 를 _sourceText_ 로 설정.
        1. _F_.[[FormalParameters]] 를 _ParameterList_ 로 설정.
        1. _F_.[[ECMAScriptCode]] 를 _Body_ 로 설정.
        1. _Strict_ 를 IsStrict(_Body_) 로 둔다.
        1. _F_.[[Strict]] 를 _Strict_ 로 설정.
        1. _thisMode_ 가 ~lexical-this~ 이면 _F_.[[ThisMode]] 를 ~lexical~ 로 설정.
        1. Else if _Strict_ 가 *true* 이면 _F_.[[ThisMode]] 를 ~strict~ 로 설정.
        1. Else _F_.[[ThisMode]] 를 ~global~ 로 설정.
        1. _F_.[[IsClassConstructor]] 를 *false* 로 설정.
        1. _F_.[[Environment]] 를 _env_ 로 설정.
        1. _F_.[[PrivateEnvironment]] 를 _privateEnv_ 로 설정.
        1. _F_.[[ScriptOrModule]] 를 GetActiveScriptOrModule() 로 설정.
        1. _F_.[[Realm]] 을 current Realm Record 로 설정.
        1. _F_.[[HomeObject]] 를 *undefined* 로 설정.
        1. _F_.[[Fields]] 를 새 빈 List 로 설정.
        1. _F_.[[PrivateMethods]] 를 새 빈 List 로 설정.
        1. _F_.[[ClassFieldInitializerName]] 를 ~empty~ 로 설정.
        1. _len_ 을 _ParameterList_ 의 ExpectedArgumentCount 로 둔다.
        1. SetFunctionLength(_F_, _len_) 수행.
        1. _F_ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addrestrictedfunctionproperties" type="abstract operation">
      <h1>
        AddRestrictedFunctionProperties (
          _F_: a function object,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 단언: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] 가 존재하며 초기화됨.
        1. _thrower_ 를 _realm_.[[Intrinsics]].[[%ThrowTypeError%]] 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"caller"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ! DefinePropertyOrThrow(_F_, *"arguments"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>

      <emu-clause id="sec-%throwtypeerror%">
        <h1>%ThrowTypeError% ( )</h1>
        <p>이 함수는 <dfn>%ThrowTypeError%</dfn> intrinsic 객체이다.</p>
        <p>각 realm 마다 한 번 정의되는 익명 내장 함수 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *TypeError* 예외를 throw 한다.
        </emu-alg>
        <p>이 함수의 [[Extensible]] 내부 슬롯 값은 *false* 이다.</p>
        <p>이 함수의 *"length"* 프로퍼티 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <p>이 함수의 *"name"* 프로퍼티 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-makeconstructor" type="abstract operation">
      <h1>
        MakeConstructor (
          _F_: an ECMAScript function object or a built-in function object,
          optional _writablePrototype_: a Boolean,
          optional _prototype_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 를 생성자로 변환한다.</dd>
      </dl>
      <emu-alg>
        1. _F_ 가 ECMAScript 함수 객체이면
          1. 단언: IsConstructor(_F_) 는 *false*.
          1. 단언: _F_ 는 *"prototype"* 자체 프로퍼티가 없는 extensible 객체.
          1. _F_.[[Construct]] 를 <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 에 명시된 정의로 설정.
        1. 그렇지 않으면
          1. _F_.[[Construct]] 를 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 에 명시된 정의로 설정.
        1. _F_.[[ConstructorKind]] 를 ~base~ 로 설정.
        1. _writablePrototype_ 이 제공되지 않았다면 *true* 로 설정.
        1. _prototype_ 이 제공되지 않았다면
          1. _prototype_ 을 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ! DefinePropertyOrThrow(_prototype_, *"constructor"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeclassconstructor" type="abstract operation">
      <h1>
        MakeClassConstructor (
          _F_: an ECMAScript function object,
        ): ~unused~
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 단언: _F_.[[IsClassConstructor]] 는 *false*.
        1. _F_.[[IsClassConstructor]] 를 *true* 로 설정.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" type="abstract operation">
      <h1>
        MakeMethod (
          _F_: an ECMAScript function object,
          _homeObject_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 를 메서드로 구성한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _homeObject_ 는 일반 객체.
        1. _F_.[[HomeObject]] 를 _homeObject_ 로 설정.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definemethodproperty" oldids="sec-createmethodproperty" type="abstract operation">
      <h1>
        DefineMethodProperty (
          _homeObject_: an Object,
          _key_: a property key or Private Name,
          _closure_: a function object,
          _enumerable_: a Boolean,
        ): PrivateElement 또는 ~unused~ 를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 단언: _homeObject_ 는 ordinary 이며 extensible 한 객체.
        1. _key_ 가 Private Name 이면
          1. PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ } 를 반환.
        1. 그렇지 않으면
          1. _desc_ 를 PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* } 로 둔다.
          1. ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_) 수행.
          1. NOTE: _key_ 가 *"prototype"* 인 class static method 정의 시에만 abrupt completion 반환 가능.
          1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionname" type="abstract operation">
      <h1>
        SetFunctionName (
          _F_: a function object,
          _name_: a property key or Private Name,
          optional _prefix_: a String,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 에 *"name"* 프로퍼티를 추가한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _F_ 는 *"name"* 자체 프로퍼티가 없는 extensible 객체.
        1. _name_ 이 Symbol 이면
          1. _description_ 을 _name_.[[Description]] 로 둔다.
          1. _description_ 이 *undefined* 이면 _name_ 을 빈 문자열로 설정.
          1. 그렇지 않으면 _name_ 을 *"["*, _description_, *"]"* 의 문자열 연결로 설정.
        1. Else if _name_ 이 Private Name 이면
          1. _name_ 을 _name_.[[Description]] 로 설정.
        1. _F_ 가 [[InitialName]] 내부 슬롯을 가진다면
          1. _F_.[[InitialName]] 를 _name_ 으로 설정.
        1. _prefix_ 가 존재하면
          1. _name_ 을 (_prefix_ + 0x0020(SPACE) + _name_) 문자열 연결로 설정.
          1. _F_ 가 [[InitialName]] 내부 슬롯을 가진다면
            1. NOTE: 다음 선택은 이 Abstract Operation 이 호출될 때마다 독립적으로 이루어짐.
            1. 선택적으로 _F_.[[InitialName]] 를 _name_ 으로 설정.
        1. ! DefinePropertyOrThrow(_F_, *"name"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionlength" type="abstract operation">
      <h1>
        SetFunctionLength (
          _F_: a function object,
          _length_: a non-negative integer or +&infin;,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 에 *"length"* 프로퍼티를 추가한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _F_ 는 *"length"* 자체 프로퍼티가 없는 extensible 객체.
        1. ! DefinePropertyOrThrow(_F_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-functiondeclarationinstantiation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): ~unused~ 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ 는 실행 컨텍스트를 설정 중인 함수 객체이다.</dd>
      </dl>
      <emu-note>
        <p>ECMAScript 함수를 평가하기 위한 실행 컨텍스트가 설정될 때 새로운 Function Environment Record 가 생성되고 각 형식 매개변수에 대한 바인딩이 그 Environment Record 에서 인스턴스화된다. 함수 본문 내 모든 선언도 인스턴스화된다. 함수의 형식 매개변수에 기본값 초기화자가 없으면 본문 선언들은 매개변수와 동일한 Environment Record 에서 인스턴스화된다. 기본값 매개변수 초기화자가 있으면 본문 선언을 위한 두 번째 Environment Record 가 생성된다. 형식 매개변수와 함수들은 FunctionDeclarationInstantiation 의 일부로 초기화된다. 다른 모든 바인딩은 함수 본문 평가 중 초기화된다.</p>
      </emu-note>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _calleeContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _code_ 를 _func_.[[ECMAScriptCode]] 로 둔다.
        1. _strict_ 를 _func_.[[Strict]] 로 둔다.
        1. _formals_ 를 _func_.[[FormalParameters]] 로 둔다.
        1. _parameterNames_ 를 _formals_ 의 BoundNames 로 둔다.
        1. _parameterNames_ 가 중복 항목을 가지면 _hasDuplicates_ 를 *true*, 아니면 *false* 로 둔다.
        1. _simpleParameterList_ 를 IsSimpleParameterList of _formals_ 로 둔다.
        1. _hasParameterExpressions_ 를 ContainsExpression of _formals_ 로 둔다.
        1. _varNames_ 를 _code_ 의 VarDeclaredNames 로 둔다.
        1. _varDeclarations_ 를 _code_ 의 VarScopedDeclarations 로 둔다.
        1. _lexicalNames_ 를 _code_ 의 LexicallyDeclaredNames 로 둔다.
        1. _functionNames_ 를 새 빈 List 로 둔다.
        1. _functionsToInitialize_ 를 새 빈 List 로 둔다.
        1. _varDeclarations_ 의 각 요소 _d_ 에 대해 (역순으로):
          1. _d_ 가 |VariableDeclaration|, |ForBinding|, |BindingIdentifier| 가 아니면
            1. 단언: _d_ 는 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| 중 하나.
            1. _fn_ 을 _d_ 의 BoundNames 의 유일한 요소로 둔다.
            1. _functionNames_ 가 _fn_ 을 포함하지 않으면
              1. _fn_ 을 _functionNames_ 의 첫 요소로 삽입.
              1. NOTE: 동일 이름 함수 선언이 여러 개면 마지막 선언 사용.
              1. _d_ 를 _functionsToInitialize_ 의 첫 요소로 삽입.
        1. _argumentsObjectNeeded_ 를 *true* 로 둔다.
        1. _func_.[[ThisMode]] 가 ~lexical~ 이면
          1. NOTE: 화살표 함수는 arguments 객체를 갖지 않는다.
          1. _argumentsObjectNeeded_ 를 *false* 로 설정.
        1. Else if _parameterNames_ 가 *"arguments"* 를 포함하면
          1. _argumentsObjectNeeded_ 를 *false* 로.
        1. Else if _hasParameterExpressions_ 가 *false* 이면
          1. _functionNames_ 가 *"arguments"* 를 포함하거나 _lexicalNames_ 가 *"arguments"* 를 포함하면
            1. _argumentsObjectNeeded_ 를 *false* 로.
        1. _strict_ 이 *true* 이거나 _hasParameterExpressions_ 가 *false* 이면
          1. NOTE: strict 모드 eval 은 외부에서 보이는 새 바인딩을 만들 수 없으므로 매개변수에 단일 Environment Record 만 필요.
          1. _env_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
        1. Else
          1. NOTE: 형식 매개변수 리스트 내 direct eval 이 만든 바인딩이 매개변수 선언 환경 밖에 위치하도록 분리된 Environment Record 필요.
          1. _calleeEnv_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
          1. _env_ 를 NewDeclarativeEnvironment(_calleeEnv_) 로 둔다.
          1. 단언: _calleeContext_ 의 VariableEnvironment 와 _calleeEnv_ 는 동일한 Environment Record.
          1. _calleeContext_ 의 LexicalEnvironment 를 _env_ 로 설정.
        1. _parameterNames_ 의 각 String _paramName_ 에 대해
          1. _alreadyDeclared_ 를 ! _env_.HasBinding(_paramName_) 로 둔다.
          1. NOTE: 중복 매개변수 이름은 기본값/나머지 매개변수 없는 non‑strict 함수에만 가능(초기 에러 규칙).
          1. _alreadyDeclared_ 가 *false* 이면
            1. ! _env_.CreateMutableBinding(_paramName_, *false*) 수행.
            1. _hasDuplicates_ 가 *true* 이면
              1. ! _env_.InitializeBinding(_paramName_, *undefined*) 수행.
        1. _argumentsObjectNeeded_ 가 *true* 이면
          1. _strict_ 이 *true* 이거나 _simpleParameterList_ 가 *false* 이면
            1. _ao_ 를 CreateUnmappedArgumentsObject(_argumentsList_) 로 둔다.
          1. Else
            1. NOTE: mapped arguments 객체는 rest, 기본값, 구조분해 매개변수 없는 non‑strict 함수에만 제공.
            1. _ao_ 를 CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_) 로 둔다.
          1. _strict_ 이 *true* 이면
            1. ! _env_.CreateImmutableBinding(*"arguments"*, *false*) 수행.
            1. NOTE: strict 코드에서는 이 바인딩에 할당 시도 자체가 조기 에러로 금지되어 불변성 관측 불가.
          1. Else
            1. ! _env_.CreateMutableBinding(*"arguments"*, *false*) 수행.
          1. ! _env_.InitializeBinding(*"arguments"*, _ao_) 수행.
          1. _parameterBindings_ 를 _parameterNames_ 와 « *"arguments"* » 의 리스트 연결로 둔다.
        1. Else
          1. _parameterBindings_ 를 _parameterNames_ 로 둔다.
        1. _iteratorRecord_ 를 CreateListIteratorRecord(_argumentsList_) 로 둔다.
        1. _hasDuplicates_ 가 *true* 이면
          1. _usedEnv_ 를 *undefined* 로 둔다.
        1. Else
          1. _usedEnv_ 를 _env_ 로 둔다.
        1. NOTE: 다음 단계는 표현식 위치에서 |YieldExpression| 사용으로만 ReturnCompletion 이 가능하나 파라미터 리스트에서 조기 에러로 금지됨.
        1. ? IteratorBindingInitialization of _formals_ (인수 _iteratorRecord_, _usedEnv_) 수행.
        1. _hasParameterExpressions_ 가 *false* 이면
          1. NOTE: 매개변수와 최상위 var 에 단일 Environment Record 사용.
          1. _instantiatedVarNames_ 를 _parameterBindings_ 복사본으로 둔다.
          1. _varNames_ 의 각 _n_ 에 대해
            1. _instantiatedVarNames_ 가 _n_ 을 포함하지 않으면
              1. _instantiatedVarNames_ 에 _n_ 추가.
              1. ! _env_.CreateMutableBinding(_n_, *false*) 수행.
              1. ! _env_.InitializeBinding(_n_, *undefined*) 수행.
          1. _varEnv_ 를 _env_ 로 둔다.
        1. Else
          1. NOTE: 형식 매개변수 표현식이 만든 클로저가 함수 본문 선언을 보지 못하도록 별도 Environment Record 필요.
          1. _varEnv_ 를 NewDeclarativeEnvironment(_env_) 로 둔다.
          1. _calleeContext_ 의 VariableEnvironment 를 _varEnv_ 로 설정.
          1. _instantiatedVarNames_ 를 새 빈 List 로 둔다.
          1. _varNames_ 의 각 _n_ 에 대해
            1. _instantiatedVarNames_ 가 _n_ 을 포함하지 않으면
              1. _instantiatedVarNames_ 에 _n_ 추가.
              1. ! _varEnv_.CreateMutableBinding(_n_, *false*) 수행.
              1. (_parameterBindings_ 가 _n_ 을 포함하지 않거나 _functionNames_ 가 _n_ 을 포함하면)
                1. _initialValue_ 를 *undefined* 로 둔다.
              1. Else
                1. _initialValue_ 를 ! _env_.GetBindingValue(_n_, *false*) 로 둔다.
              1. ! _varEnv_.InitializeBinding(_n_, _initialValue_) 수행.
              1. NOTE: 형식 매개변수와 같은 이름의 var 는 초기에는 해당 매개변수 초기화 값과 동일.
        1. _strict_ 이 *true* 이면
          1. _lexEnv_ 를 _varEnv_ 로 둔다.
        1. Else
          1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
            1. _code_ Contains _x_ 가 *true* 인 어떤 |Block|, |CaseClause|, |DefaultClause| _x_ 의 |StatementList| 에 직접 포함된 각 |FunctionDeclaration| _f_ 에 대해
              1. _F_ 를 _f_ 의 |BindingIdentifier| 의 StringValue 로 둔다.
              1. |FunctionDeclaration| _f_ 를 _F_ 를 |BindingIdentifier| 로 갖는 |VariableStatement| 로 대체해도 _func_ 에 대해 Early Errors 가 발생하지 않고 _parameterNames_ 가 _F_ 를 포함하지 않으면
                1. NOTE: _F_ 에 대한 var 바인딩은 VarDeclaredName 이 아니고 형식 매개변수 이름도 아니며 다른 |FunctionDeclaration| 도 아닐 때만 여기서 인스턴스화.
                1. _instantiatedVarNames_ 가 _F_ 를 포함하지 않고 _F_ 가 *"arguments"* 가 아니면
                  1. ! _varEnv_.CreateMutableBinding(_F_, *false*) 수행.
                  1. ! _varEnv_.InitializeBinding(_F_, *undefined*) 수행.
                  1. _instantiatedVarNames_ 에 _F_ 추가.
                1. [id="step-functiondeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ 평가 시 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 의 Evaluation 알고리즘 대신 다음 수행:
                  1. _fEnv_ 를 실행 중 실행 컨텍스트의 VariableEnvironment 로 둔다.
                  1. _bEnv_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
                  1. _fObj_ 를 ! _bEnv_.GetBindingValue(_F_, *false*) 로 둔다.
                  1. ! _fEnv_.SetMutableBinding(_F_, _fObj_, *false*) 수행.
                  1. ~unused~ 반환.
          1. _lexEnv_ 를 NewDeclarativeEnvironment(_varEnv_) 로 둔다.
          1. NOTE: non‑strict 함수는 direct eval 이 생성한 var 스코프 선언과 기존 최상위 lexical 선언 충돌 여부를 판단할 수 있도록 top-level lexical 선언에 별도의 Environment Record 사용. strict 함수는 항상 새 Environment Record 사용하므로 불필요.
        1. _calleeContext_ 의 LexicalEnvironment 를 _lexEnv_ 로 설정.
        1. _lexDeclarations_ 를 _code_ 의 LexicallyScopedDeclarations 로 둔다.
        1. _lexDeclarations_ 의 각 _d_ 에 대해
          1. NOTE: lexical 선언 이름은 함수/제너레이터 선언, 형식 매개변수, var 이름과 같을 수 없으며 여기서 인스턴스화만 되고 초기화는 안 됨.
          1. _d_ 의 BoundNames 각 _dn_ 에 대해
            1. IsConstantDeclaration of _d_ 가 *true* 이면
              1. ! _lexEnv_.CreateImmutableBinding(_dn_, *true*) 수행.
            1. Else
              1. ! _lexEnv_.CreateMutableBinding(_dn_, *false*) 수행.
        1. _privateEnv_ 를 _calleeContext_ 의 PrivateEnvironment 로 둔다.
        1. _functionsToInitialize_ 의 각 Parse Node _f_ 에 대해
          1. _fn_ 을 _f_ 의 BoundNames 유일 요소로 둔다.
          1. _fo_ 를 InstantiateFunctionObject of _f_ (인수 _lexEnv_, _privateEnv_) 로 둔다.
          1. ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-function-objects">
    <h1>내장 함수 객체(Built-in Function Objects)</h1>
    <p>내장 함수 객체는 일반 객체이며; <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>에 규정된 일반 객체 요건을 만족해야 한다.</p>
    <p>모든 일반 객체에 요구되는 내부 슬롯(<emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 참조)에 더해, 내장 함수 객체는 다음 내부 슬롯도 가져야 한다:</p>
    <ul>
      <li>[[Realm]]: 함수가 생성된 realm 을 나타내는 Realm Record.</li>
      <li>[[InitialName]]: 함수의 초기 이름인 String. <emu-xref href="#sec-function.prototype.tostring"></emu-xref>에서 사용된다.</li>
    </ul>
    <p>명시적으로 달리 지정되지 않은 한, 내장 함수 객체의 [[Prototype]] 내부 슬롯 초기 값은 %Function.prototype% 이다.</p>
    <p>내장 함수 객체는 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref>의 정의에 부합하는 [[Call]] 내부 메서드를 가져야 한다.</p>
    <p>내장 함수 객체는 “constructor”로 기술되었거나 이 명세의 어떤 알고리즘이 그 [[Construct]] 내부 메서드를 명시적으로 설정한 경우에만 [[Construct]] 내부 메서드를 가진다. 그러한 [[Construct]] 내부 메서드는 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref>의 정의를 준수해야 한다.</p>
    <p>구현은 이 명세에 정의되지 않은 추가 내장 함수 객체를 제공할 수 있다.</p>

    <emu-clause id="sec-built-in-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>내장 함수 객체 _F_</dd>
      </dl>
      <emu-alg>
        1. ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-built-in-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>내장 함수 객체 _F_ (이 메서드가 존재할 때)</dd>
      </dl>
      <emu-alg>
        1. _result_ 를 ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_) 로 둔다.
        1. 단언: _result_ 는 Object.
        1. _result_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-builtincallorconstruct" type="abstract operation">
      <h1>
        BuiltinCallOrConstruct (
          _F_: a built-in function object,
          _thisArgument_: an ECMAScript language value or ~uninitialized~,
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor or *undefined*,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _callerContext_ 가 아직 suspend 되어 있지 않다면 suspend 한다.
        1. _calleeContext_ 를 새 실행 컨텍스트로 둔다.
        1. _calleeContext_ 의 Function 을 _F_ 로 설정한다.
        1. _calleeRealm_ 을 _F_.[[Realm]] 로 둔다.
        1. _calleeContext_ 의 Realm 을 _calleeRealm_ 로 설정한다.
        1. _calleeContext_ 의 ScriptOrModule 을 *null* 로 설정한다.
        1. 구현 정의된 필요 초기화를 _calleeContext_ 에 수행한다.
        1. _calleeContext_ 를 실행 컨텍스트 스택에 push; 이제 _calleeContext_ 가 실행 중 실행 컨텍스트이다.
        1. [id="step-call-builtin-function-result"] _result_ 를 _F_ 의 명세에 부합하는 방식으로 _F_ 를 평가하여 얻은 Completion Record 로 둔다. _thisArgument_ 가 ~uninitialized~ 이면 *this* 값은 초기화되지 않은 상태이며; 그렇지 않으면 _thisArgument_ 가 *this* 값을 제공한다. _argumentsList_ 는 명명된 매개변수들을 제공한다. _newTarget_ 은 NewTarget 값을 제공한다.
        1. NOTE: _F_ 가 이 문서에서 정의된 경우 “the specification of _F_” 는 알고리즘 단계 등으로 기술된 그 동작을 의미한다.
        1. 실행 컨텍스트 스택에서 _calleeContext_ 를 제거하고 _callerContext_ 를 실행 중 실행 컨텍스트로 복원한다.
        1. ? _result_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>_calleeContext_ 가 실행 컨텍스트 스택에서 제거될 때 접근 가능한 Generator 에 의해 suspend 및 보존되어 후속 재개가 예정된 경우 파괴되어서는 안 된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createbuiltinfunction" type="abstract operation">
      <h1>
        CreateBuiltinFunction (
          _behaviour_: an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification,
          _length_: a non-negative integer or +&infin;,
          _name_: a property key or a Private Name,
          _additionalInternalSlotsList_: a List of names of internal slots,
          optional _realm_: a Realm Record,
          optional _prototype_: an Object or *null*,
          optional _prefix_: a String,
        ): a built-in function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_additionalInternalSlotsList_ 는 객체 일부로 정의되어야 하는 추가 내부 슬롯 이름을 담는다. 이 연산은 내장 함수 객체를 생성한다.</dd>
      </dl>
      <emu-alg>
        1. _realm_ 이 제공되지 않았다면 current Realm Record 로 설정한다.
        1. _prototype_ 이 제공되지 않았다면 _prototype_ 을 _realm_.[[Intrinsics]].[[%Function.prototype%]] 로 설정한다.
        1. _internalSlotsList_ 를 곧 생성할 내장 함수 객체에 대해 <emu-xref href="#sec-built-in-function-objects"></emu-xref>가 요구하는 모든 내부 슬롯 이름을 담는 List 로 둔다.
        1. _additionalInternalSlotsList_ 의 요소들을 _internalSlotsList_ 에 추가(Append)한다.
        1. _func_ 를 새 내장 함수 객체로 두되, 호출 시 _behaviour_ 가 지정한 매개변수에 제공 인수를 값으로 하여 _behaviour_ 에 기술된 동작을 수행한다. 새 함수 객체는 _internalSlotsList_ 요소 이름의 내부 슬롯과 [[InitialName]] 내부 슬롯을 가진다.
        1. _func_.[[Prototype]] 을 _prototype_ 으로 설정한다.
        1. _func_.[[Extensible]] 를 *true* 로 설정한다.
        1. _func_.[[Realm]] 을 _realm_ 으로 설정한다.
        1. _func_.[[InitialName]] 을 *null* 로 설정한다.
        1. SetFunctionLength(_func_, _length_) 를 수행한다.
        1. _prefix_ 가 제공되지 않았다면
          1. SetFunctionName(_func_, _name_) 를 수행한다.
        1. 그렇지 않으면
          1. SetFunctionName(_func_, _name_, _prefix_) 를 수행한다.
        1. _func_ 를 반환한다.
      </emu-alg>
      <p>이 명세에 정의된 각 내장 함수는 CreateBuiltinFunction 추상 연산을 호출하여 생성된다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>내장 이그조틱 객체의 내부 메서드와 슬롯(Built-in Exotic Object Internal Methods and Slots)</h1>
    <p>이 명세는 여러 종류의 내장 이그조틱 객체를 정의한다. 이 객체들은 특정한 몇몇 상황을 제외하면 일반 객체와 유사하게 동작한다. 다음 이그조틱 객체들은 아래에서 명시적으로 달리 지정된 경우를 제외하고 일반 객체 내부 메서드를 사용한다:</p>

    <emu-clause id="sec-bound-function-exotic-objects">
      <h1>바운드 함수 이그조틱 객체(Bound Function Exotic Objects)</h1>
      <p>바운드 함수 이그조틱 객체는 다른 함수 객체를 감싸는 이그조틱 객체이다. 바운드 함수 이그조틱 객체는 호출 가능(callable)하며([[Call]] 내부 메서드를 가지며 필요 시 [[Construct]] 내부 메서드도 가질 수 있음), 호출하면 보통 감싼 함수가 호출된다.</p>

      <p>객체의 [[Call]] 및 (해당하는 경우) [[Construct]] 내부 메서드가 아래 구현을 사용하고, 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>의 정의를 사용한다면 그 객체는 <dfn id="bound-function-exotic-object" variants="bound function exotic objects">바운드 함수 이그조틱 객체</dfn>이다. 이러한 메서드는 BoundFunctionCreate 에서 설치된다.</p>

      <p>바운드 함수 이그조틱 객체는 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>에 나열된 ECMAScript 함수 객체의 내부 슬롯을 가지지 않는다. 대신 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref>에 나열된 내부 슬롯을 [[Prototype]], [[Extensible]]와 더불어 가진다.</p>
      <emu-table id="table-internal-slots-of-bound-function-exotic-objects" caption="바운드 함수 이그조틱 객체의 내부 슬롯(Internal Slots of Bound Function Exotic Objects)" oldids="table-28">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[BoundTargetFunction]]</td>
            <td>a callable Object</td>
            <td>감싸진(wrapped) 함수 객체.</td>
          </tr>
          <tr>
            <td>[[BoundThis]]</td>
            <td>an ECMAScript language value</td>
            <td>감싸진 함수를 호출할 때 항상 *this* 값으로 전달되는 값.</td>
          </tr>
          <tr>
            <td>[[BoundArguments]]</td>
            <td>a List of ECMAScript language values</td>
            <td>감싸진 함수 호출 시 선행 인수로 사용되는 값들의 리스트.</td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-bound-function-exotic-objects-call-thisargument-argumentslist" type="internal method">
        <h1>
          [[Call]] (
            _thisArgument_: an ECMAScript language value,
            _argumentsList_: a List of ECMAScript language values,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>바운드 함수 이그조틱 객체 _F_</dd>
        </dl>
        <emu-alg>
          1. _target_ 을 _F_.[[BoundTargetFunction]] 로 둔다.
          1. _boundThis_ 를 _F_.[[BoundThis]] 로 둔다.
          1. _boundArgs_ 를 _F_.[[BoundArguments]] 로 둔다.
          1. _args_ 를 _boundArgs_ 와 _argumentsList_ 의 리스트 연결(list-concatenation)으로 둔다.
          1. ? Call(_target_, _boundThis_, _args_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bound-function-exotic-objects-construct-argumentslist-newtarget" type="internal method">
        <h1>
          [[Construct]] (
            _argumentsList_: a List of ECMAScript language values,
            _newTarget_: a constructor,
          ): 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>바운드 함수 이그조틱 객체 _F_</dd>
        </dl>
        <emu-alg>
          1. _target_ 을 _F_.[[BoundTargetFunction]] 로 둔다.
          1. 단언: IsConstructor(_target_) 는 *true*.
          1. _boundArgs_ 를 _F_.[[BoundArguments]] 로 둔다.
          1. _args_ 를 _boundArgs_ 와 _argumentsList_ 의 리스트 연결로 둔다.
          1. SameValue(_F_, _newTarget_) 가 *true* 이면 _newTarget_ 을 _target_ 으로 설정한다.
          1. ? Construct(_target_, _args_, _newTarget_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundfunctioncreate" type="abstract operation">
        <h1>
          BoundFunctionCreate (
            _targetFunction_: a function object,
            _boundThis_: an ECMAScript language value,
            _boundArgs_: a List of ECMAScript language values,
          ): 함수 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 바운드 함수 이그조틱 객체 생성을 명세하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _proto_ 를 ? <emu-meta effects="user-code">_targetFunction_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
          1. _internalSlotsList_ 를 « [[Prototype]], [[Extensible]] » 와 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref>에 나열된 내부 슬롯의 리스트 연결로 둔다.
          1. _obj_ 를 MakeBasicObject(_internalSlotsList_) 로 둔다.
          1. _obj_.[[Prototype]] 을 _proto_ 로 설정한다.
          1. _obj_.[[Call]] 을 <emu-xref href="#sec-bound-function-exotic-objects-call-thisargument-argumentslist"></emu-xref>에 기술된 대로 설정한다.
          1. IsConstructor(_targetFunction_) 가 *true* 이면
            1. _obj_.[[Construct]] 를 <emu-xref href="#sec-bound-function-exotic-objects-construct-argumentslist-newtarget"></emu-xref>에 기술된 대로 설정한다.
          1. _obj_.[[BoundTargetFunction]] 을 _targetFunction_ 으로 설정한다.
          1. _obj_.[[BoundThis]] 를 _boundThis_ 로 설정한다.
          1. _obj_.[[BoundArguments]] 를 _boundArgs_ 로 설정한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-exotic-objects">
      <h1>배열(Array) 이그조틱 객체(Array Exotic Objects)</h1>
      <p>Array 는 배열 인덱스 프로퍼티 키(<emu-xref href="#sec-object-type"></emu-xref> 참조)에 특별 취급을 제공하는 이그조틱 객체이다. 프로퍼티 이름이 배열 인덱스인 프로퍼티를 <em>element</em> 라고도 부른다. 모든 Array 는 재정의 불가(non-configurable) *"length"* 프로퍼티를 가지며 그 값은 2<sup>32</sup> 보다 작은 0 이상 정수 Number 이다. *"length"* 프로퍼티 값은 이름이 배열 인덱스인 모든 자체 프로퍼티 이름보다 수치적으로 크다; Array 의 자체 프로퍼티가 생성되거나 변경될 때마다 이 불변식을 유지하도록 다른 프로퍼티들이 필요 시 조정된다. 구체적으로 배열 인덱스 이름의 자체 프로퍼티가 추가되면 *"length"* 값은 필요 시 그 인덱스의 수치 값보다 1 큰 값으로 변경되고; *"length"* 값이 변경되면 새 length 보다 크거나 같았던 배열 인덱스 이름의 모든 자체 프로퍼티는 삭제된다. 이 제약은 Array 의 자체 프로퍼티에만 적용되며 프로토타입에서 상속될 수 있는 *"length"* 또는 배열 인덱스 프로퍼티에는 영향받지 않는다.</p>

      <p>객체의 [[DefineOwnProperty]] 내부 메서드가 아래 구현을 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>의 정의를 사용하면 그 객체는 <dfn id="array-exotic-object" variants="Array exotic objects">Array 이그조틱 객체</dfn>(간단히 Array)이다. 이러한 메서드는 ArrayCreate 에서 설치된다.</p>

      <emu-clause id="sec-array-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>Array 이그조틱 객체 _A_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 *"length"* 이면
            1. ? ArraySetLength(_A_, _Desc_) 를 반환한다.
          1. Else if _P_ 가 배열 인덱스이면
            1. _lengthDesc_ 를 OrdinaryGetOwnProperty(_A_, *"length"*) 로 둔다.
            1. 단언: _lengthDesc_ 는 *undefined* 가 아님.
            1. 단언: IsDataDescriptor(_lengthDesc_) 는 *true*.
            1. 단언: _lengthDesc_.[[Configurable]] 는 *false*.
            1. _length_ 를 _lengthDesc_.[[Value]] 로 둔다.
            1. 단언: _length_ 는 0 이상 정수 Number.
            1. _index_ 를 ! ToUint32(_P_) 로 둔다.
            1. _index_ ≥ _length_ 이고 _lengthDesc_.[[Writable]] 이 *false* 이면 *false* 반환.
            1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_) 로 둔다.
            1. _succeeded_ 가 *false* 이면 *false* 반환.
            1. _index_ ≥ _length_ 이면
              1. _lengthDesc_.[[Value]] 를 _index_ + *1*<sub>𝔽</sub> 로 설정.
              1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _lengthDesc_) 로 설정.
              1. 단언: _succeeded_ 는 *true*.
            1. *true* 반환.
          1. ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraycreate" type="abstract operation">
        <h1>
          ArrayCreate (
            _length_: a non-negative integer,
            optional _proto_: an Object,
          ): Array 이그조틱 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 Array 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _length_ > 2<sup>32</sup> - 1 이면 *RangeError* 예외 throw.
          1. _proto_ 가 제공되지 않았다면 _proto_ 를 %Array.prototype% 으로 설정.
          1. _A_ 를 MakeBasicObject(« [[Prototype]], [[Extensible]] ») 로 둔다.
          1. _A_.[[Prototype]] 을 _proto_ 로 설정.
          1. _A_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>에 지정된 대로 설정.
          1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arrayspeciescreate" type="abstract operation">
        <h1>
          ArraySpeciesCreate (
            _originalArray_: an Object,
            _length_: a non-negative integer,
          ): 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_originalArray_ 에서 파생된 constructor 함수를 사용하여 새 Array 또는 유사 객체를 생성하는 과정을 명세한다. constructor 가 반드시 Array 를 반환하도록 강제하지 않는다.</dd>
        </dl>
        <emu-alg>
          1. _isArray_ 를 ? IsArray(_originalArray_) 로 둔다.
          1. _isArray_ 가 *false* 이면 ? ArrayCreate(_length_) 반환.
          1. _C_ 를 ? Get(_originalArray_, *"constructor"*) 로 둔다.
          1. IsConstructor(_C_) 가 *true* 이면
            1. _thisRealm_ 을 current Realm Record 로 둔다.
            1. _realmC_ 를 ? GetFunctionRealm(_C_) 로 둔다.
            1. _thisRealm_ 과 _realmC_ 가 동일 Realm Record 가 아니면
              1. SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) 가 *true* 이면 _C_ 를 *undefined* 로 설정.
          1. _C_ 가 Object 이면
            1. _C_ 를 ? Get(_C_, %Symbol.species%) 로 설정.
            1. _C_ 가 *null* 이면 _C_ 를 *undefined* 로 설정.
          1. _C_ 가 *undefined* 이면 ? ArrayCreate(_length_) 반환.
          1. IsConstructor(_C_) 가 *false* 이면 *TypeError* 예외 throw.
          1. ? Construct(_C_, « 𝔽(_length_) ») 반환.
        </emu-alg>
        <emu-note>
          <p>_originalArray_ 가 실행 중 실행 컨텍스트의 realm 이 아닌 realm 의 표준 내장 Array 생성자로 생성되었다면, 실행 중 실행 컨텍스트 realm 을 사용하여 새 Array 가 생성된다. 이는 ArraySpeciesCreate 로 정의된 `Array.prototype` 메서드들에 대해 역사적으로 그러한 동작을 가진 웹 브라우저와의 호환성을 유지한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-arraysetlength" type="abstract operation">
        <h1>
          ArraySetLength (
            _A_: an Array,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _Desc_ 가 [[Value]] 필드를 가지지 않으면
            1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _Desc_) 반환.
          1. _newLenDesc_ 를 _Desc_ 의 복사본으로 둔다.
          1. [id="step-arraysetlength-newlen"] _newLen_ 을 ? ToUint32(_Desc_.[[Value]]) 로 둔다.
          1. [id="step-arraysetlength-numberlen"] _numberLen_ 을 ? ToNumber(_Desc_.[[Value]]) 로 둔다.
          1. SameValueZero(_newLen_, _numberLen_) 가 *false* 이면 *RangeError* 예외 throw.
          1. _newLenDesc_.[[Value]] 를 _newLen_ 으로 설정.
          1. _oldLenDesc_ 를 OrdinaryGetOwnProperty(_A_, *"length"*) 로 둔다.
          1. 단언: _oldLenDesc_ 는 *undefined* 아님.
          1. 단언: IsDataDescriptor(_oldLenDesc_) 는 *true*.
          1. 단언: _oldLenDesc_.[[Configurable]] 는 *false*.
          1. _oldLen_ 을 _oldLenDesc_.[[Value]] 로 둔다.
          1. _newLen_ ≥ _oldLen_ 이면
            1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) 반환.
          1. _oldLenDesc_.[[Writable]] 이 *false* 이면 *false* 반환.
          1. _newLenDesc_ 가 [[Writable]] 필드를 가지지 않거나 _newLenDesc_.[[Writable]] 이 *true* 이면
            1. _newWritable_ 를 *true* 로 둔다.
          1. Else
            1. NOTE: 어떤 element 를 삭제할 수 없는 경우를 대비하여 [[Writable]] 을 *false* 로 설정하는 것을 지연.
            1. _newWritable_ 를 *false* 로 둔다.
            1. _newLenDesc_.[[Writable]] 을 *true* 로 설정.
          1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) 로 둔다.
          1. _succeeded_ 가 *false* 이면 *false* 반환.
          1. _A_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 배열 인덱스이고 ! ToUint32(_P_) ≥ _newLen_ 인 것들을 내림차순 숫자 인덱스 순으로 순회하며
            1. _deleteSucceeded_ 를 ! _A_.[[Delete]](_P_) 로 둔다.
            1. _deleteSucceeded_ 가 *false* 이면
              1. _newLenDesc_.[[Value]] 를 ! ToUint32(_P_) + *1*<sub>𝔽</sub> 로 설정.
              1. _newWritable_ 이 *false* 이면 _newLenDesc_.[[Writable]] 을 *false* 로 설정.
              1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) 수행.
              1. *false* 반환.
          1. _newWritable_ 이 *false* 이면
            1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Writable]]: *false* }) 로 설정.
            1. 단언: _succeeded_ 는 *true*.
          1. *true* 반환.
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-arraysetlength-newlen"></emu-xref> 및 <emu-xref href="#step-arraysetlength-numberlen"></emu-xref> 단계에서 _Desc_.[[Value]] 가 객체이면 그 `valueOf` 메서드는 두 번 호출된다. 이는 명세 2<sup>판</sup>부터 이런 효과로 규정된 레거시 동작이다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-exotic-objects">
      <h1>문자열(String) 이그조틱 객체(String Exotic Objects)</h1>
      <p>String 객체는 String 값을 캡슐화하고 그 String 값의 개별 코드 유닛 요소에 해당하는 가상 정수 인덱스 데이터 프로퍼티를 노출하는 이그조틱 객체이다. String 이그조틱 객체는 캡슐화된 String 값 길이를 값으로 갖는 *"length"* 데이터 프로퍼티를 항상 가진다. 코드 유닛 데이터 프로퍼티와 *"length"* 프로퍼티 모두 쓰기 불가능 및 재정의 불가이다.</p>

      <p>객체의 [[GetOwnProperty]], [[DefineOwnProperty]], [[OwnPropertyKeys]] 내부 메서드가 아래 구현을 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 정의를 사용하면 그 객체는 <dfn id="string-exotic-object" variants="String exotic objects">String 이그조틱 객체</dfn>(간단히 String 객체)이다. 이러한 메서드는 StringCreate 에서 설치된다.</p>

      <p>String 이그조틱 객체는 일반 객체와 동일한 내부 슬롯을 갖는다. 추가로 [[StringData]] 내부 슬롯을 가진다.</p>

      <emu-clause id="sec-string-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String 이그조틱 객체 _S_</dd>
        </dl>
        <emu-alg>
          1. _desc_ 를 OrdinaryGetOwnProperty(_S_, _P_) 로 둔다.
          1. _desc_ 가 *undefined* 가 아니면 _desc_ 반환.
          1. StringGetOwnProperty(_S_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String 이그조틱 객체 _S_</dd>
        </dl>
        <emu-alg>
          1. _stringDesc_ 를 StringGetOwnProperty(_S_, _P_) 로 둔다.
          1. _stringDesc_ 가 *undefined* 가 아니면
            1. _extensible_ 을 _S_.[[Extensible]] 로 둔다.
            1. IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_) 반환.
          1. ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _keys_ 를 새 빈 List 로 둔다.
          1. _str_ 을 _O_.[[StringData]] 로 둔다.
          1. 단언: _str_ 은 String.
          1. _len_ 을 _str_ 의 길이로 둔다.
          1. 0 ≤ _i_ < _len_ 인 각 정수 _i_ 에 대해 오름차순으로
            1. ! ToString(𝔽(_i_)) 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 배열 인덱스이며 ! ToIntegerOrInfinity(_P_) ≥ _len_ 인 것들을 숫자 인덱스 오름차순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 String 이고 배열 인덱스가 아닌 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 Symbol 인 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _keys_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringcreate" type="abstract operation">
        <h1>
          StringCreate (
            _value_: a String,
            _prototype_: an Object,
          ): String 이그조틱 객체
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 String 이그조틱 객체 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _S_ 를 MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] ») 로 둔다.
          1. _S_.[[Prototype]] 을 _prototype_ 으로 설정.
          1. _S_.[[StringData]] 를 _value_ 로 설정.
          1. _S_.[[GetOwnProperty]] 를 <emu-xref href="#sec-string-exotic-objects-getownproperty-p"></emu-xref>에 지정된 대로 설정.
          1. _S_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-string-exotic-objects-defineownproperty-p-desc"></emu-xref>에 지정된 대로 설정.
          1. _S_.[[OwnPropertyKeys]] 를 <emu-xref href="#sec-string-exotic-objects-ownpropertykeys"></emu-xref>에 지정된 대로 설정.
          1. _length_ 를 _value_ 길이로 둔다.
          1. ! DefinePropertyOrThrow(_S_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. _S_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringgetownproperty" type="abstract operation">
        <h1>
          StringGetOwnProperty (
            _S_: an Object that has a [[StringData]] internal slot,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _P_ 가 String 이 아니면 *undefined* 반환.
          1. _index_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
          1. _index_ 가 정수 Number 가 아니면 *undefined* 반환.
          1. _index_ 가 *-0*<sub>𝔽</sub> 이거나 _index_ < *-0*<sub>𝔽</sub> 이면 *undefined* 반환.
          1. _str_ 을 _S_.[[StringData]] 로 둔다.
          1. 단언: _str_ 은 String.
          1. _len_ 을 _str_ 길이로 둔다.
          1. ℝ(_index_) ≥ _len_ 이면 *undefined* 반환.
          1. _resultStr_ 을 _str_ 의 ℝ(_index_) 부터 ℝ(_index_) + 1 까지 부분 문자열로 둔다.
          1. PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* } 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arguments-exotic-objects">
      <h1>Arguments 이그조틱 객체(Arguments Exotic Objects)</h1>

      <p>대부분의 ECMAScript 함수는 코드에서 사용할 수 있는 arguments 객체를 제공한다. 함수 정의 특성에 따라 그 arguments 객체는 일반 객체이거나 arguments 이그조틱 객체가 된다. arguments 이그조틱 객체는 배열 인덱스 프로퍼티들이 관련 ECMAScript 함수 호출의 형식 매개변수 바인딩에 매핑되는 이그조틱 객체이다.</p>

      <p>객체의 내부 메서드가 아래 구현을 사용하고 여기 명시되지 않은 메서드는 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>의 정의를 사용하면 그 객체는 <dfn id="arguments-exotic-object" variants="arguments exotic objects">arguments 이그조틱 객체</dfn>이다. 이러한 메서드는 CreateMappedArgumentsObject 에서 설치된다.</p>

      <emu-note>
        <p>CreateUnmappedArgumentsObject 는 이 절에 묶여 있지만, 이그조틱이 아닌 일반 객체를 생성한다.</p>
      </emu-note>

      <p>Arguments 이그조틱 객체는 일반 객체와 동일한 내부 슬롯을 가지며 추가로 [[ParameterMap]] 내부 슬롯을 가진다. 일반 arguments 객체 또한 값이 항상 *undefined* 인 [[ParameterMap]] 내부 슬롯을 갖는다. 일반 arguments 객체의 [[ParameterMap]] 내부 슬롯은 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>)이 그것을 식별하는 데만 사용된다.</p>

      <emu-note>
        <p>arguments 이그조틱 객체 중 숫자 이름 값이 대응 함수 객체의 형식 매개변수 수보다 작은 정수 인덱스 데이터 프로퍼티는 초기에는 함수 실행 컨텍스트의 해당 인자 바인딩과 값을 공유한다. 즉 프로퍼티를 바꾸면 매개변수 바인딩 값도 바뀌며 그 반대도 같다. 이 대응 관계는 그러한 프로퍼티가 삭제 후 재정의되거나 접근자 프로퍼티로 바뀌면 끊어진다. arguments 객체가 일반 객체인 경우 그 프로퍼티 값은 단지 전달된 인자의 복사이며 동적 연결은 없다.</p>
      </emu-note>
      <emu-note>
        <p>ParameterMap 객체와 그 프로퍼티 값들은 arguments 객체와 인자 바인딩 간의 대응 관계를 명세하기 위한 장치이다. ParameterMap 객체와 그 프로퍼티 값 객체들은 ECMAScript 코드에서 직접 관측될 수 없다. 구현은 명세된 의미론을 위해 실제로 이러한 객체를 생성하거나 사용할 필요가 없다.</p>
      </emu-note>
      <emu-note>
        <p>일반 arguments 객체는 접근 시 *TypeError* 예외를 throw 하는 재정의 불가 accessor 프로퍼티 *"callee"* 를 정의한다. *"callee"* 프로퍼티는 non‑strict 함수 일부에 대해서만 생성되는 arguments 이그조틱 객체에서 더 구체적 의미를 가진다. 일반 변형에서의 정의는 적합한 구현이 다른 방식으로 정의하지 못하도록 하기 위함이다.</p>
      </emu-note>
      <emu-note>
        <p>역사적으로 arguments 이그조틱 객체 구현은 *"caller"* 라는 accessor 프로퍼티를 포함했다. ECMAScript 2017 이전 명세는 일반 arguments 객체에 throwing *"caller"* 프로퍼티 정의를 포함했다. 구현이 더 이상 이 확장을 포함하지 않으므로 ECMAScript 2017 은 throwing *"caller"* accessor 요구를 제거했다.</p>
      </emu-note>

      <emu-clause id="sec-arguments-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _desc_ 를 OrdinaryGetOwnProperty(_args_, _P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면 *undefined* 반환.
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _isMapped_ 가 *true* 이면
            1. _desc_.[[Value]] 를 ! Get(_map_, _P_) 로 설정.
          1. _desc_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _newArgDesc_ 를 _Desc_ 로 둔다.
          1. _isMapped_ 가 *true* 이고 IsDataDescriptor(_Desc_) 가 *true* 이면
            1. _Desc_ 가 [[Value]] 필드를 갖지 않고 [[Writable]] 필드를 가지며 그 값이 *false* 이면
              1. _newArgDesc_ 를 _Desc_ 복사본으로 둔다.
              1. _newArgDesc_.[[Value]] 를 ! Get(_map_, _P_) 로 설정.
          1. _allowed_ 를 ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_) 로 둔다.
          1. _allowed_ 가 *false* 이면 *false* 반환.
          1. _isMapped_ 가 *true* 이면
            1. IsAccessorDescriptor(_Desc_) 가 *true* 이면
              1. ! _map_.[[Delete]](_P_) 수행.
            1. Else
              1. _Desc_ 가 [[Value]] 필드를 가지면
                1. 단언: arguments 객체가 매핑한 형식 매개변수는 항상 writable 이므로 Set 성공.
                1. ! Set(_map_, _P_, _Desc_.[[Value]], *false*) 수행.
              1. _Desc_ 가 [[Writable]] 필드를 가지고 그 값이 *false* 이면
                1. ! _map_.[[Delete]](_P_) 수행.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _isMapped_ 가 *false* 이면
            1. ? OrdinaryGet(_args_, _P_, _Receiver_) 반환.
          1. Else
            1. 단언: _map_ 은 _P_ 에 대한 형식 매개변수 매핑을 포함.
            1. ! Get(_map_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. SameValue(_args_, _Receiver_) 가 *false* 이면
            1. _isMapped_ 를 *false* 로 둔다.
          1. Else
            1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
            1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _isMapped_ 가 *true* 이면
            1. 단언: 아래 Set 은 성공 (매핑된 형식 매개변수는 항상 writable).
            1. ! Set(_map_, _P_, _V_, *false*) 수행.
          1. ? OrdinarySet(_args_, _P_, _V_, _Receiver_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _result_ 를 ? OrdinaryDelete(_args_, _P_) 로 둔다.
          1. _result_ 가 *true* 이고 _isMapped_ 가 *true* 이면
            1. ! _map_.[[Delete]](_P_) 수행.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createunmappedargumentsobject" type="abstract operation">
        <h1>
          CreateUnmappedArgumentsObject (
            _argumentsList_: a List of ECMAScript language values,
          ): an ordinary object
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _len_ 을 _argumentsList_ 요소 개수로 둔다.
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] ») 로 둔다.
          1. _obj_.[[ParameterMap]] 을 *undefined* 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. _index_ 를 0 으로 둔다.
          1. _index_ < _len_ 인 동안 반복
            1. _val_ 를 _argumentsList_[_index_] 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_) 수행.
            1. _index_ 를 _index_ + 1 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. _obj_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createmappedargumentsobject" type="abstract operation">
        <h1>
          CreateMappedArgumentsObject (
            _func_: an Object,
            _formals_: a Parse Node,
            _argumentsList_: a List of ECMAScript language values,
            _env_: an Environment Record,
          ): an arguments exotic object
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 단언: _formals_ 는 rest 매개변수, 바인딩 패턴, 초기화자를 포함하지 않는다. 중복 식별자는 있을 수 있다.
          1. _len_ 을 _argumentsList_ 요소 개수로 둔다.
          1. _obj_ 를 MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] ») 로 둔다.
          1. _obj_.[[GetOwnProperty]] 를 <emu-xref href="#sec-arguments-exotic-objects-getownproperty-p"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-arguments-exotic-objects-defineownproperty-p-desc"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Get]] 를 <emu-xref href="#sec-arguments-exotic-objects-get-p-receiver"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Set]] 를 <emu-xref href="#sec-arguments-exotic-objects-set-p-v-receiver"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Delete]] 를 <emu-xref href="#sec-arguments-exotic-objects-delete-p"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Prototype]] 을 %Object.prototype% 으로 설정.
          1. _map_ 을 OrdinaryObjectCreate(*null*) 로 둔다.
          1. _obj_.[[ParameterMap]] 을 _map_ 으로 설정.
          1. _parameterNames_ 를 _formals_ 의 BoundNames 로 둔다.
          1. _numberOfParameters_ 를 _parameterNames_ 요소 개수로 둔다.
          1. _index_ 를 0 으로 둔다.
          1. _index_ < _len_ 인 동안 반복
            1. _val_ 를 _argumentsList_[_index_] 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_) 수행.
            1. _index_ 를 _index_ + 1 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. _mappedNames_ 를 새 빈 List 로 둔다.
          1. _index_ 를 _numberOfParameters_ - 1 로 설정.
          1. _index_ ≥ 0 인 동안 반복
            1. _name_ 을 _parameterNames_[_index_] 로 둔다.
            1. _mappedNames_ 가 _name_ 을 포함하지 않으면
              1. _mappedNames_ 에 _name_ 추가.
              1. _index_ < _len_ 이면
                1. _g_ 를 MakeArgGetter(_name_, _env_) 로 둔다.
                1. _p_ 를 MakeArgSetter(_name_, _env_) 로 둔다.
                1. ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
            1. _index_ 를 _index_ - 1 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. _obj_ 반환.
        </emu-alg>

        <emu-clause id="sec-makearggetter" type="abstract operation">
          <h1>
            MakeArgGetter (
              _name_: a String,
              _env_: an Environment Record,
            ): a function object
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>실행 시 _env_ 에서 _name_ 에 바인딩된 값을 반환하는 내장 함수 객체를 생성한다.</dd>
          </dl>
          <emu-alg>
            1. _getterClosure_ 를 매개변수 없고 _name_, _env_ 를 캡처하며 호출 시 다음 단계를 수행하는 새 Abstract Closure 로 둔다:
              1. NormalCompletion(! _env_.GetBindingValue(_name_, *false*)) 반환.
            1. _getter_ 를 CreateBuiltinFunction(_getterClosure_, 0, *""*, « ») 로 둔다.
            1. NOTE: _getter_ 는 ECMAScript 코드에서 직접 접근 불가.
            1. _getter_ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-makeargsetter" type="abstract operation">
          <h1>
            MakeArgSetter (
              _name_: a String,
              _env_: an Environment Record,
            ): a function object
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>실행 시 _env_ 에서 _name_ 에 바인딩된 값을 설정하는 내장 함수 객체를 생성한다.</dd>
          </dl>
          <emu-alg>
            1. _setterClosure_ 를 매개변수 (_value_) 를 가지며 _name_, _env_ 를 캡처하고 호출 시 다음을 수행하는 새 Abstract Closure 로 둔다:
              1. NormalCompletion(! _env_.SetMutableBinding(_name_, _value_, *false*)) 반환.
            1. _setter_ 를 CreateBuiltinFunction(_setterClosure_, 1, *""*, « ») 로 둔다.
            1. NOTE: _setter_ 는 ECMAScript 코드에서 직접 접근 불가.
            1. _setter_ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-exotic-objects" oldids="sec-integer-indexed-exotic-objects">
      <h1>TypedArray 이그조틱 객체(TypedArray Exotic Objects)</h1>
      <p>TypedArray 는 정규화 수치 문자열(canonical numeric string) 프로퍼티 키를 특별 처리하고 그 중 경계 내(in-bounds) 정수 인덱스를 균일 타입 요소에 매핑하며 나머지는 프로토타입 체인 탐색 없이 부재로 유지하는 이그조틱 객체이다.</p>
      <emu-note>
        <p>임의의 Number _n_ 에 대해 ToString(_n_)이 정규화 수치 문자열이므로, 구현은 실제 문자열 변환 없이 Number 를 TypedArray 프로퍼티 키로 다룰 수 있다.</p>
      </emu-note>
      <p>TypedArray 는 일반 객체와 동일한 내부 슬롯을 가지며 추가로 [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] 내부 슬롯을 가진다.</p>
      <p>객체의 [[PreventExtensions]], [[GetOwnProperty]], [[HasProperty]], [[DefineOwnProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]] 내부 메서드가 이 절의 정의를 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 정의를 사용하면 그 객체는 <dfn id="typedarray" oldids="integer-indexed-exotic-object" variants="TypedArrays">TypedArray</dfn> 이다. 이러한 메서드는 TypedArrayCreate 에 의해 설치된다.</p>

      <emu-clause id="sec-typedarray-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): Boolean 을 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. NOTE: <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref>에 규정된 확장성 관련 불변식은 _O_ 가 프로퍼티를 얻거나(또는 잃고 다시 얻을) 수 있는 경우 *true* 를 반환하지 못하게 한다; 이는 underlying buffer 가 resize 될 때 정수 인덱스 이름 프로퍼티에서 발생할 수 있다.
          1. IsTypedArrayFixedLength(_O_) 가 *false* 이면 *false* 반환.
          1. OrdinaryPreventExtensions(_O_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-getownproperty" oldids="sec-integer-indexed-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. _value_ 를 TypedArrayGetElement(_O_, _numericIndex_) 로 둔다.
              1. _value_ 가 *undefined* 이면 *undefined* 반환.
              1. PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } 반환.
          1. OrdinaryGetOwnProperty(_O_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-hasproperty" oldids="sec-integer-indexed-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면 IsValidIntegerIndex(_O_, _numericIndex_) 반환.
          1. ? OrdinaryHasProperty(_O_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-defineownproperty" oldids="sec-integer-indexed-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. IsValidIntegerIndex(_O_, _numericIndex_) 가 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Configurable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Enumerable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
              1. IsAccessorDescriptor(_Desc_) 가 *true* 이면 *false* 반환.
              1. _Desc_ 에 [[Writable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Value]] 필드가 있으면 ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]]) 수행.
              1. *true* 반환.
          1. ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-get" oldids="sec-integer-indexed-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. TypedArrayGetElement(_O_, _numericIndex_) 반환.
          1. ? OrdinaryGet(_O_, _P_, _Receiver_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-set" oldids="sec-integer-indexed-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. SameValue(_O_, _Receiver_) 가 *true* 이면
                1. ? TypedArraySetElement(_O_, _numericIndex_, _V_) 수행.
                1. *true* 반환.
              1. IsValidIntegerIndex(_O_, _numericIndex_) 가 *false* 이면 *true* 반환.
          1. ? OrdinarySet(_O_, _P_, _V_, _Receiver_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-delete" oldids="sec-integer-indexed-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. IsValidIntegerIndex(_O_, _numericIndex_) 가 *false* 이면 *true* 반환; else *false* 반환.
          1. ! OrdinaryDelete(_O_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-ownpropertykeys" oldids="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _taRecord_ 를 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~) 로 둔다.
          1. _keys_ 를 새 빈 List 로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *false* 이면
            1. _length_ 를 TypedArrayLength(_taRecord_) 로 둔다.
            1. 0 ≤ _i_ < _length_ 인 각 정수 _i_ 에 대해 오름차순으로
              1. ! ToString(𝔽(_i_)) 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 String 이고 정수 인덱스가 아닌 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 Symbol 인 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _keys_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-with-buffer-witness-records" oldids="sec-integer-indexed-object-with-buffer-witness-records">
        <h1>버퍼 증인 레코드가 있는 TypedArray (TypedArray With Buffer Witness Records)</h1>
        <p><dfn variants="TypedArray With Buffer Witness Records">TypedArray With Buffer Witness Record</dfn> 는 TypedArray 와, 보기 버퍼(viewed buffer)의 캐시된 byte length 를 함께 캡슐화하는 Record 값이다. growable SharedArrayBuffer 를 보는 경우 byte length 데이터 블록에 대한 단일 공유 메모리 읽기 이벤트를 보장하는 데 사용된다.</p>
        <p>TypedArray With Buffer Witness Record 는 <emu-xref href="#table-typedarray-with-buffer-witness-record-fields"></emu-xref>에 나온 필드를 가진다.</p>
        <emu-table id="table-typedarray-with-buffer-witness-record-fields" oldids="table-integer-indexed-object-with-buffer-witness-record-fields" caption="TypedArray With Buffer Witness Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Object]]</td>
              <td>a TypedArray</td>
              <td>버퍼 byte length 가 로드된 TypedArray.</td>
            </tr>
            <tr>
              <td>[[CachedBufferByteLength]]</td>
              <td>a non-negative integer or ~detached~</td>
              <td>Record 생성 시 객체의 [[ViewedArrayBuffer]] byte length.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-maketypedarraywithbufferwitnessrecord" oldids="sec-makeintegerindexedobjectwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeTypedArrayWithBufferWitnessRecord (
            _obj_: a TypedArray,
            _order_: ~seq-cst~ or ~unordered~,
          ): a TypedArray With Buffer Witness Record
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _buffer_ 를 _obj_.[[ViewedArrayBuffer]] 로 둔다.
          1. IsDetachedBuffer(_buffer_) 가 *true* 이면
            1. _byteLength_ 를 ~detached~ 로 둔다.
          1. Else
            1. _byteLength_ 를 ArrayBufferByteLength(_buffer_, _order_) 로 둔다.
          1. TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ } 를 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraycreate" oldids="sec-integerindexedobjectcreate" type="abstract operation">
        <h1>
          TypedArrayCreate (
            _prototype_: an Object,
          ): a TypedArray
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 TypedArray 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _internalSlotsList_ 를 « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] » 로 둔다.
          1. _A_ 를 MakeBasicObject(_internalSlotsList_) 로 둔다.
          1. _A_.[[PreventExtensions]] 를 <emu-xref href="#sec-typedarray-preventextensions"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[GetOwnProperty]] 를 <emu-xref href="#sec-typedarray-getownproperty"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[HasProperty]] 를 <emu-xref href="#sec-typedarray-hasproperty"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-typedarray-defineownproperty"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Get]] 를 <emu-xref href="#sec-typedarray-get"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Set]] 를 <emu-xref href="#sec-typedarray-set"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Delete]] 를 <emu-xref href="#sec-typedarray-delete"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[OwnPropertyKeys]] 를 <emu-xref href="#sec-typedarray-ownpropertykeys"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Prototype]] 을 _prototype_ 으로 설정.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraybytelength" oldids="sec-integerindexedobjectbytelength" type="abstract operation">
        <h1>
          TypedArrayByteLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *true* 이면 0 반환.
          1. _length_ 를 TypedArrayLength(_taRecord_) 로 둔다.
          1. _length_ = 0 이면 0 반환.
          1. _O_ 를 _taRecord_.[[Object]] 로 둔다.
          1. _O_.[[ByteLength]] 이 ~auto~ 가 아니면 _O_.[[ByteLength]] 반환.
          1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
          1. _length_ × _elementSize_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraylength" oldids="sec-integerindexedobjectlength" type="abstract operation">
        <h1>
          TypedArrayLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 단언: IsTypedArrayOutOfBounds(_taRecord_) 는 *false*.
          1. _O_ 를 _taRecord_.[[Object]] 로 둔다.
          1. _O_.[[ArrayLength]] 이 ~auto~ 가 아니면 _O_.[[ArrayLength]] 반환.
          1. 단언: IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) 는 *false*.
          1. _byteOffset_ 을 _O_.[[ByteOffset]] 로 둔다.
          1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
          1. _byteLength_ 를 _taRecord_.[[CachedBufferByteLength]] 로 둔다.
          1. 단언: _byteLength_ 는 ~detached~ 아님.
          1. floor((_byteLength_ - _byteOffset_) / _elementSize_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayoutofbounds" oldids="sec-isintegerindexedobjectoutofbounds" type="abstract operation">
        <h1>
          IsTypedArrayOutOfBounds (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>객체의 어떤 수치 프로퍼티라도 underlying buffer 범위를 벗어난 인덱스 값을 참조하는지 검사한다.</dd>
        </dl>
        <emu-alg>
          1. _O_ 를 _taRecord_.[[Object]] 로 둔다.
          1. _bufferByteLength_ 를 _taRecord_.[[CachedBufferByteLength]] 로 둔다.
          1. 단언: IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 는 _bufferByteLength_ 가 ~detached~ 일 때 그리고 그럴 때에만 *true*.
          1. _bufferByteLength_ 가 ~detached~ 이면 *true* 반환.
          1. _byteOffsetStart_ 를 _O_.[[ByteOffset]] 로 둔다.
          1. _O_.[[ArrayLength]] 이 ~auto~ 이면
            1. _byteOffsetEnd_ 를 _bufferByteLength_ 로 둔다.
          1. Else
            1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
            1. _byteOffsetEnd_ 를 _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_ 로 둔다.
          1. _byteOffsetStart_ > _bufferByteLength_ 또는 _byteOffsetEnd_ > _bufferByteLength_ 이면 *true* 반환.
          1. NOTE: 길이 0 TypedArray 는 out-of-bounds 로 간주되지 않는다.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayfixedlength" type="abstract operation">
        <h1>
          IsTypedArrayFixedLength (
            _O_: a TypedArray,
          ): a Boolean
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _O_.[[ArrayLength]] 이 ~auto~ 이면 *false* 반환.
          1. _buffer_ 를 _O_.[[ViewedArrayBuffer]] 로 둔다.
          1. IsFixedLengthArrayBuffer(_buffer_) 가 *false* 이고 IsSharedArrayBuffer(_buffer_) 가 *false* 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isvalidintegerindex" type="abstract operation">
        <h1>
          IsValidIntegerIndex (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Boolean
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 가 *true* 이면 *false* 반환.
          1. _index_ 가 정수 Number 가 아니면 *false* 반환.
          1. _index_ 가 *-0*<sub>𝔽</sub> 이거나 _index_ < *-0*<sub>𝔽</sub> 이면 *false* 반환.
          1. _taRecord_ 를 MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~) 로 둔다.
          1. NOTE: _O_ 의 버퍼가 growable SharedArrayBuffer 일 때 경계 검사(bound check)는 동기화 연산이 아니다.
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *true* 이면 *false* 반환.
          1. _length_ 를 TypedArrayLength(_taRecord_) 로 둔다.
          1. ℝ(_index_) ≥ _length_ 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraygetelement" oldids="sec-integerindexedelementget" type="abstract operation">
        <h1>
          TypedArrayGetElement (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Number, a BigInt, or *undefined*
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. IsValidIntegerIndex(_O_, _index_) 가 *false* 이면 *undefined* 반환.
          1. _offset_ 을 _O_.[[ByteOffset]] 로 둔다.
          1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
          1. _byteIndexInBuffer_ 를 (ℝ(_index_) × _elementSize_) + _offset_ 으로 둔다.
          1. _elementType_ 을 TypedArrayElementType(_O_) 로 둔다.
          1. GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraysetelement" oldids="sec-integerindexedelementset" type="abstract operation">
        <h1>
          TypedArraySetElement (
            _O_: a TypedArray,
            _index_: a Number,
            _value_: an ECMAScript language value,
          ): ~unused~ 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _O_.[[ContentType]] 가 ~bigint~ 이면 _numValue_ 를 ? ToBigInt(_value_) 로 둔다.
          1. 아니면 _numValue_ 를 ? ToNumber(_value_) 로 둔다.
          1. IsValidIntegerIndex(_O_, _index_) 가 *true* 이면
            1. _offset_ 을 _O_.[[ByteOffset]] 로 둔다.
            1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
            1. _byteIndexInBuffer_ 를 (ℝ(_index_) × _elementSize_) + _offset_ 으로 둔다.
            1. _elementType_ 을 TypedArrayElementType(_O_) 로 둔다.
            1. SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-note>
          <p>이 연산은 항상 성공하는 것처럼 보이나, TypedArray 끝을 넘어 쓰거나 분리(detached)된 ArrayBuffer 기반 TypedArray 에 쓰려 할 때는 효과가 없다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation">
        <h1>
          IsArrayBufferViewOutOfBounds (
            _O_: a TypedArray or a DataView,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>TypedArray 의 수치 프로퍼티 또는 DataView 메서드가 underlying data block 범위를 벗어난 인덱스 값을 참조할 수 있는지 검사한다. 상위(spec) 명세 편의를 위해 존재.</dd>
        </dl>
        <emu-alg>
          1. _O_ 가 [[DataView]] 내부 슬롯을 가지면
            1. _viewRecord_ 를 MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~) 로 둔다.
            1. IsViewOutOfBounds(_viewRecord_) 반환.
          1. _taRecord_ 를 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~) 로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-module-namespace-exotic-objects">
      <h1>모듈 네임스페이스 이그조틱 객체(Module Namespace Exotic Objects)</h1>
      <p>모듈 네임스페이스 이그조틱 객체는 ECMAScript |Module|에서 export 된 바인딩을 노출하는 이그조틱 객체이다(<emu-xref href="#sec-exports"></emu-xref> 참조). 모듈 네임스페이스 이그조틱 객체의 String-keyed 자체 프로퍼티와 |Module| 이 export 한 바인딩 이름 사이엔 1:1 대응이 있다. export 된 바인딩에는 `export *` 로 간접 export 된 바인딩도 포함된다. 각 String 값인 자체 프로퍼티 키는 해당 export 바인딩 이름의 StringValue 이다. 이들이 모듈 네임스페이스 이그조틱 객체의 유일한 String-keyed 프로퍼티이다. 각 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* } 속성을 가진다. 모듈 네임스페이스 이그조틱 객체는 비확장(extensible 아님)이다.</p>
      <p>객체의 [[GetPrototypeOf]], [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]], [[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]] 내부 메서드가 이 절의 정의를 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 정의를 사용하면 그 객체는 <dfn id="module-namespace-exotic-object" variants="module namespace exotic objects">모듈 네임스페이스 이그조틱 객체</dfn>이다. 이러한 메서드는 ModuleNamespaceCreate 에 의해 설치된다.</p>
      <p>모듈 네임스페이스 이그조틱 객체는 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref>에 정의된 내부 슬롯을 가진다.</p>
      <emu-table id="table-internal-slots-of-module-namespace-exotic-objects" caption="모듈 네임스페이스 이그조틱 객체의 내부 슬롯(Internal Slots of Module Namespace Exotic Objects)" oldids="table-29">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[Module]]</td>
            <td>a Module Record</td>
            <td>이 네임스페이스가 export 를 노출하는 Module Record.</td>
          </tr>
          <tr>
            <td>[[Exports]]</td>
            <td>a List of Strings</td>
            <td>이 객체의 자체 프로퍼티로 노출되는 export 이름들의 String 값 요소를 가진 List. 코드 유닛 사전식 순서로 정렬됨.</td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-module-namespace-exotic-objects-getprototypeof" type="internal method">
        <h1>[[GetPrototypeOf]] ( ): *null* 을 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *null* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. ! SetImmutablePrototype(_O_, _V_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-isextensible" type="internal method">
        <h1>[[IsExtensible]] ( ): *false* 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): *true* 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면 OrdinaryGetOwnProperty(_O_, _P_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하지 않으면 *undefined* 반환.
          1. _value_ 를 ? _O_.[[Get]](_P_, _O_) 로 둔다.
          1. PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* } 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면 ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) 반환.
          1. _current_ 를 ? _O_.[[GetOwnProperty]](_P_) 로 둔다.
          1. _current_ 가 *undefined* 이면 *false* 반환.
          1. _Desc_ 에 [[Configurable]] 필드가 있고 그 값이 *true* 이면 *false* 반환.
          1. _Desc_ 에 [[Enumerable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
          1. IsAccessorDescriptor(_Desc_) 가 *true* 이면 *false* 반환.
          1. _Desc_ 에 [[Writable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
          1. _Desc_ 에 [[Value]] 필드가 있으면 SameValue(_Desc_.[[Value]], _current_.[[Value]]) 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면 ! OrdinaryHasProperty(_O_, _P_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면
            1. ! OrdinaryGet(_O_, _P_, _Receiver_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하지 않으면 *undefined* 반환.
          1. _m_ 을 _O_.[[Module]] 로 둔다.
          1. _binding_ 을 _m_.ResolveExport(_P_) 로 둔다.
          1. 단언: _binding_ 은 ResolvedBinding Record.
          1. _targetModule_ 을 _binding_.[[Module]] 로 둔다.
          1. 단언: _targetModule_ 은 *undefined* 가 아님.
          1. _binding_.[[BindingName]] 이 ~namespace~ 이면
            1. GetModuleNamespace(_targetModule_) 반환.
          1. _targetEnv_ 를 _targetModule_.[[Environment]] 로 둔다.
          1. _targetEnv_ 가 ~empty~ 이면 *ReferenceError* 예외 throw.
          1. ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*) 반환.
        </emu-alg>
        <emu-note>
          <p>ResolveExport 는 부작용이 없다. 특정 _exportName_, _resolveSet_ 인수 쌍으로 이 연산을 호출할 때마다 동일 결과를 반환해야 한다. 구현은 각 모듈 네임스페이스 이그조틱 객체의 [[Exports]] 에 대한 ResolveExport 결과를 미리 계산하거나 캐시할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): *false* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면
            1. ! OrdinaryDelete(_O_, _P_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _symbolKeys_ 를 OrdinaryOwnPropertyKeys(_O_) 로 둔다.
          1. _exports_ 와 _symbolKeys_ 의 리스트 연결(list-concatenation) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulenamespacecreate" type="abstract operation">
        <h1>
          ModuleNamespaceCreate (
            _module_: a Module Record,
            _exports_: a List of Strings,
          ): a module namespace exotic object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 모듈 네임스페이스 이그조틱 객체 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. 단언: _module_.[[Namespace]] 는 ~empty~.
          1. _internalSlotsList_ 를 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref>에 나열된 내부 슬롯으로 둔다.
          1. _M_ 을 MakeBasicObject(_internalSlotsList_) 로 둔다.
          1. _M_ 의 핵심 내부 메서드를 <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref>에 지정된 정의로 설정.
          1. _M_.[[Module]] 을 _module_ 로 설정.
          1. _sortedExports_ 를 _exports_ 요소를 코드 유닛 사전식 순서로 정렬한 List 로 둔다.
          1. _M_.[[Exports]] 를 _sortedExports_ 로 설정.
          1. <emu-xref href="#sec-module-namespace-objects"></emu-xref>에 정의된 대로 _M_ 의 자체 프로퍼티를 생성.
          1. _module_.[[Namespace]] 를 _M_ 으로 설정.
          1. _M_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-immutable-prototype-exotic-objects">
      <h1>불변 프로토타입 이그조틱 객체(Immutable Prototype Exotic Objects)</h1>
      <p>불변 프로토타입 이그조틱 객체는 초기화 이후 변경되지 않는 [[Prototype]] 내부 슬롯을 가진 이그조틱 객체이다.</p>

      <p>객체의 [[SetPrototypeOf]] 내부 메서드가 아래 구현을 사용한다면 그 객체는 <dfn id="immutable-prototype-exotic-object" variants="immutable prototype exotic objects">불변 프로토타입 이그조틱 객체</dfn>이다. (그 외 핵심 내부 메서드는 구체적 객체에 따라 임의 구현을 사용할 수 있다.)</p>

      <emu-note>
        <p>다른 이그조틱 객체와 달리 불변 프로토타입 이그조틱 객체를 위한 전용 생성 추상 연산은 제공되지 않는다. 이는 %Object.prototype% 및 호스트 환경에서만 사용되고, 호스트 환경에서는 관련 객체들이 다른 방식으로도 이그조틱일 수 있어 자체 전용 생성 연산이 필요하기 때문이다.</p>
      </emu-note>

      <emu-clause id="sec-immutable-prototype-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>불변 프로토타입 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. ? SetImmutablePrototype(_O_, _V_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set-immutable-prototype" type="abstract operation">
        <h1>
          SetImmutablePrototype (
            _O_: an Object,
            _V_: an Object or *null*,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _current_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
          1. SameValue(_V_, _current_) 가 *true* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
    <h1>Proxy 객체의 내부 메서드와 내부 슬롯(Proxy Object Internal Methods and Internal Slots)</h1>
    <p>Proxy 객체는 필수 내부 메서드가 ECMAScript 코드로 일부 구현된 이그조틱 객체이다. 모든 Proxy 객체는 [[ProxyHandler]] 라는 내부 슬롯을 가진다. [[ProxyHandler]] 의 값은 프록시의 <em>handler object</em> 라 불리는 객체이거나 *null* 이다. 핸들러 객체의 메서드들(<emu-xref href="#table-proxy-handler-methods"></emu-xref> 참조)은 하나 이상 Proxy 객체 내부 메서드 구현을 확장(augment)하는 데 사용될 수 있다. 모든 Proxy 객체는 또한 [[ProxyTarget]] 이라 불리는 내부 슬롯을 가지며 그 값은 객체 또는 *null* 이다. 이 객체를 프록시의 <em>target object</em> 라고 한다.</p>

    <p>객체의 (해당한다면 [[Call]] 및 [[Construct]] 포함) 필수 내부 메서드가 이 절의 정의를 사용한다면 그 객체는 <dfn id="proxy-exotic-object" variants="Proxy exotic objects">Proxy 이그조틱 객체</dfn>이다. 이러한 내부 메서드는 ProxyCreate 에서 설치된다.</p>

    <emu-table id="table-proxy-handler-methods" caption="Proxy Handler Methods" oldids="table-30">
      <table>
        <thead>
          <tr>
            <th>
              Internal Method
            </th>
            <th>
              Handler Method
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[GetPrototypeOf]]
          </td>
          <td>
            `getPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[SetPrototypeOf]]
          </td>
          <td>
            `setPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[IsExtensible]]
          </td>
          <td>
            `isExtensible`
          </td>
        </tr>
        <tr>
          <td>
            [[PreventExtensions]]
          </td>
          <td>
            `preventExtensions`
          </td>
        </tr>
        <tr>
          <td>
            [[GetOwnProperty]]
          </td>
          <td>
            `getOwnPropertyDescriptor`
          </td>
        </tr>
        <tr>
          <td>
            [[DefineOwnProperty]]
          </td>
          <td>
            `defineProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[HasProperty]]
          </td>
          <td>
            `has`
          </td>
        </tr>
        <tr>
          <td>
            [[Get]]
          </td>
          <td>
            `get`
          </td>
        </tr>
        <tr>
          <td>
            [[Set]]
          </td>
          <td>
            `set`
          </td>
        </tr>
        <tr>
          <td>
            [[Delete]]
          </td>
          <td>
            `deleteProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[OwnPropertyKeys]]
          </td>
          <td>
            `ownKeys`
          </td>
        </tr>
        <tr>
          <td>
            [[Call]]
          </td>
          <td>
            `apply`
          </td>
        </tr>
        <tr>
          <td>
            [[Construct]]
          </td>
          <td>
            `construct`
          </td>
        </tr>
      </table>
    </emu-table>
    <p>프록시 객체 내부 메서드 구현을 제공하기 위해 핸들러 메서드가 호출될 때 핸들러 메서드에는 프록시의 target 객체가 매개변수로 전달된다. 프록시의 핸들러 객체가 모든 필수 내부 메서드에 대응하는 메서드를 반드시 가질 필요는 없다. 프록시에서 내부 메서드를 호출했을 때 핸들러 객체가 해당 내부 트랩에 대응하는 메서드를 가지지 않으면 프록시 target 객체의 대응 내부 메서드가 호출된다.</p>
    <p>Proxy 객체의 [[ProxyHandler]] 와 [[ProxyTarget]] 내부 슬롯은 객체 생성 시 항상 초기화되며 일반적으로 수정될 수 없다. 일부 Proxy 객체는 이후 <em>revoked</em> 될 수 있는 방식으로 생성된다. 프록시가 철회(revoke)되면 그 [[ProxyHandler]] 및 [[ProxyTarget]] 내부 슬롯이 *null* 로 설정되어 이후 그 Proxy 객체의 내부 메서드 호출은 *TypeError* 예외를 던진다.</p>
    <p>Proxy 객체는 내부 메서드 구현을 임의의 ECMAScript 코드로 제공할 수 있게 하므로, <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 에 정의된 불변식을 위반하는 핸들러 메서드를 가진 Proxy 객체를 정의할 가능성이 있다. <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 에 정의된 내부 메서드 불변식 중 일부는 필수 무결성 불변식이며, 이들은 이 절에 명시된 Proxy 객체 내부 메서드에 의해 명시적으로 강제된다. ECMAScript 구현은 모든 가능한 불변식 위반 존재 시에도 견고해야 한다.</p>
    <p>이하 알고리즘 설명에서 _O_ 는 ECMAScript Proxy 객체, _P_ 는 프로퍼티 키 값, _V_ 는 임의의 ECMAScript 언어 값, _Desc_ 는 Property Descriptor 레코드라고 가정한다.</p>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): Object 또는 *null* 을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 를 수행한다.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"getPrototypeOf"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() 를 반환한다.
        1. _handlerProto_ 를 ? Call(_trap_, _handler_, « _target_ ») 로 둔다.
        1. _handlerProto_ 가 Object 도 아니고 *null* 도 아니면 *TypeError* 예외 throw.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _extensibleTarget_ 이 *true* 이면 _handlerProto_ 반환.
        1. _targetProto_ 를 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
        1. SameValue(_handlerProto_, _targetProto_) 가 *false* 이면 *TypeError* 예외 throw.
        1. _handlerProto_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[GetPrototypeOf]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[GetPrototypeOf]] 결과는 Object 또는 *null* 이어야 한다.</li>
          <li>target 객체가 비확장(non-extensible) 이면 Proxy 객체에 적용한 [[GetPrototypeOf]] 는 target 객체에 적용한 [[GetPrototypeOf]] 와 동일 값을 반환해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"setPrototypeOf"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_V_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _extensibleTarget_ 이 *true* 이면 *true* 반환.
        1. _targetProto_ 를 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
        1. SameValue(_V_, _targetProto_) 가 *false* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[SetPrototypeOf]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[SetPrototypeOf]] 의 결과는 Boolean 값이다.</li>
          <li>target 객체가 비확장이라면 인수 값은 target 객체에 적용한 [[GetPrototypeOf]] 결과와 동일해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): Boolean 을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"isExtensible"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? IsExtensible(_target_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_ »)) 로 둔다.
        1. _targetResult_ 를 ? IsExtensible(_target_) 로 둔다.
        1. _booleanTrapResult_ 가 _targetResult_ 와 다르면 *TypeError* 예외 throw.
        1. _booleanTrapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[IsExtensible]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[IsExtensible]] 결과는 Boolean 값이다.</li>
          <li>Proxy 객체에 적용한 [[IsExtensible]] 결과는 동일 인수로 target 객체에 적용한 [[IsExtensible]] 결과와 동일해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): Boolean 을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"preventExtensions"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta> 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *true* 이면
          1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
          1. _extensibleTarget_ 이 *true* 이면 *TypeError* 예외 throw.
        1. _booleanTrapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[PreventExtensions]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[PreventExtensions]] 결과는 Boolean 값이다.</li>
          <li>Proxy 객체에 적용한 [[PreventExtensions]] 가 *true* 를 반환하는 경우는 target 객체에 적용한 [[IsExtensible]] 가 *false* 일 때뿐이다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): Property Descriptor 또는 *undefined* 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"getOwnPropertyDescriptor"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 반환.
        1. _trapResultObj_ 를 ? Call(_trap_, _handler_, « _target_, _P_ ») 로 둔다.
        1. _trapResultObj_ 가 Object 도 아니고 *undefined* 도 아니면 *TypeError* 예외 throw.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _trapResultObj_ 가 *undefined* 이면
          1. _targetDesc_ 가 *undefined* 이면 *undefined* 반환.
          1. _targetDesc_.[[Configurable]] 이 *false* 이면 *TypeError* 예외 throw.
          1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
          1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
          1. *undefined* 반환.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _resultDesc_ 를 ? ToPropertyDescriptor(_trapResultObj_) 로 둔다.
        1. CompletePropertyDescriptor(_resultDesc_) 수행.
        1. _valid_ 를 IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_) 로 둔다.
        1. _valid_ 가 *false* 이면 *TypeError* 예외 throw.
        1. _resultDesc_.[[Configurable]] 이 *false* 이면
          1. _targetDesc_ 가 *undefined* 이거나 _targetDesc_.[[Configurable]] 이 *true* 이면
            1. *TypeError* 예외 throw.
          1. _resultDesc_ 에 [[Writable]] 필드가 있고 _resultDesc_.[[Writable]] 이 *false* 이면
            1. 단언: _targetDesc_ 는 [[Writable]] 필드를 가진다.
            1. _targetDesc_.[[Writable]] 이 *true* 이면 *TypeError* 예외 throw.
        1. _resultDesc_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[GetOwnProperty]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[GetOwnProperty]] 결과는 Object 또는 *undefined* 여야 한다.</li>
          <li>target 객체에 비구성 가능(non-configurable) 자체 프로퍼티로 존재하면 그 프로퍼티를 비존재로 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 자체 프로퍼티로 존재하면 비존재로 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 target 에 자체 프로퍼티로 존재하지 않으면 존재한다고 보고할 수 없다.</li>
          <li>target 객체에 대응 비구성 가능 자체 프로퍼티가 없으면 프로퍼티를 비구성 가능으로 보고할 수 없다.</li>
          <li>target 객체에 대응 비구성 가능·비쓰기(non-writable) 자체 프로퍼티가 없으면 프로퍼티를 동시에 비구성 가능 & 비쓰기라고 보고할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"defineProperty"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_) 반환.
        1. _descObj_ 를 FromPropertyDescriptor(_Desc_) 로 둔다.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _Desc_ 에 [[Configurable]] 필드가 있고 _Desc_.[[Configurable]] 이 *false* 이면
          1. _settingConfigFalse_ 를 *true* 로 둔다.
        1. Else
          1. _settingConfigFalse_ 를 *false* 로 둔다.
        1. _targetDesc_ 가 *undefined* 이면
          1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
          1. _settingConfigFalse_ 가 *true* 이면 *TypeError* 예외 throw.
        1. Else
          1. IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) 가 *false* 이면 *TypeError* 예외 throw.
          1. _settingConfigFalse_ 가 *true* 이고 _targetDesc_.[[Configurable]] 이 *true* 이면 *TypeError* 예외 throw.
          1. IsDataDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Configurable]] 이 *false* 이며 _targetDesc_.[[Writable]] 이 *true* 이면
            1. _Desc_ 에 [[Writable]] 필드가 있고 _Desc_.[[Writable]] 이 *false* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[DefineOwnProperty]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[DefineOwnProperty]] 결과는 Boolean 값이다.</li>
          <li>target 객체가 비확장이라면 프로퍼티를 추가할 수 없다.</li>
          <li>target 객체에 대응 비구성 가능 자체 프로퍼티가 없으면 프로퍼티를 비구성 가능으로 만들 수 없다.</li>
          <li>대응 비구성 가능·비쓰기 자체 프로퍼티가 없으면 비구성 가능 프로퍼티를 비쓰기 상태로 만들 수 없다.</li>
          <li>프로퍼티에 대응하는 target 프로퍼티가 존재한다면 그 프로퍼티의 Descriptor 를 target 에 [[DefineOwnProperty]] 로 적용해도 예외가 발생하지 않아야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"has"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_P_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면
          1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _targetDesc_ 가 *undefined* 가 아니면
            1. _targetDesc_.[[Configurable]] 이 *false* 이면 *TypeError* 예외 throw.
            1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
            1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
        1. _booleanTrapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[HasProperty]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[HasProperty]] 결과는 Boolean 값이다.</li>
          <li>target 객체에 비구성 가능 자체 프로퍼티로 존재하면 비존재로 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 자체 프로퍼티로 존재하면 비존재로 보고할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"get"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_P_, _Receiver_) 반환.
        1. _trapResult_ 를 ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ ») 로 둔다.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _targetDesc_ 가 *undefined* 가 아니고 _targetDesc_.[[Configurable]] 이 *false* 이면
          1. IsDataDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Writable]] 이 *false* 이면
            1. SameValue(_trapResult_, _targetDesc_.[[Value]]) 가 *false* 이면 *TypeError* 예외 throw.
          1. IsAccessorDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Get]] 이 *undefined* 이면
            1. _trapResult_ 가 *undefined* 가 아니면 *TypeError* 예외 throw.
        1. _trapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[Get]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>target 객체 프로퍼티가 비쓰기·비구성 가능 자체 데이터 프로퍼티라면 보고되는 값은 target 프로퍼티 값과 동일해야 한다.</li>
          <li>target 객체 프로퍼티가 [[Get]] 이 *undefined* 인 비구성 가능 자체 접근자 프로퍼티라면 보고되는 값은 *undefined* 이어야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"set"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _targetDesc_ 가 *undefined* 가 아니고 _targetDesc_.[[Configurable]] 이 *false* 이면
          1. IsDataDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Writable]] 이 *false* 이면
            1. SameValue(_V_, _targetDesc_.[[Value]]) 가 *false* 이면 *TypeError* 예외 throw.
          1. IsAccessorDescriptor(_targetDesc_) 가 *true* 이면
            1. _targetDesc_.[[Set]] 이 *undefined* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[Set]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[Set]] 결과는 Boolean 값이다.</li>
          <li>대응 target 프로퍼티가 비쓰기·비구성 가능 자체 데이터 프로퍼티라면 그 값을 다른 값으로 바꿀 수 없다.</li>
          <li>대응 target 프로퍼티가 [[Set]] 이 *undefined* 인 비구성 가능 자체 접근자 프로퍼티라면 값을 설정할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"deleteProperty"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_P_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _targetDesc_ 가 *undefined* 이면 *true* 반환.
        1. _targetDesc_.[[Configurable]] 이 *false* 이면 *TypeError* 예외 throw.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[Delete]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[Delete]] 결과는 Boolean 값이다.</li>
          <li>target 객체에 비구성 가능 자체 프로퍼티로 존재하면 삭제되었다고 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 자체 프로퍼티로 존재하면 삭제되었다고 보고할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"ownKeys"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> 반환.
        1. _trapResultArray_ 를 ? Call(_trap_, _handler_, « _target_ ») 로 둔다.
        1. _trapResult_ 를 ? CreateListFromArrayLike(_trapResultArray_, ~property-key~) 로 둔다.
        1. _trapResult_ 가 중복 항목을 포함하면 *TypeError* 예외 throw.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _targetKeys_ 를 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
        1. 단언: _targetKeys_ 는 프로퍼티 키들의 List.
        1. 단언: _targetKeys_ 는 중복 항목이 없다.
        1. _targetConfigurableKeys_ 를 새 빈 List 로 둔다.
        1. _targetNonconfigurableKeys_ 를 새 빈 List 로 둔다.
        1. _targetKeys_ 의 각 요소 _key_ 에 대해
          1. _desc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
          1. _desc_ 가 *undefined* 가 아니고 _desc_.[[Configurable]] 이 *false* 이면
            1. _targetNonconfigurableKeys_ 에 _key_ 추가.
          1. Else
            1. _targetConfigurableKeys_ 에 _key_ 추가.
        1. _extensibleTarget_ 이 *true* 이고 _targetNonconfigurableKeys_ 가 비어 있으면
          1. _trapResult_ 반환.
        1. _uncheckedResultKeys_ 를 _trapResult_ 요소들로 구성된 List 로 둔다.
        1. _targetNonconfigurableKeys_ 의 각 _key_ 에 대해
          1. _uncheckedResultKeys_ 가 _key_ 를 포함하지 않으면 *TypeError* 예외 throw.
          1. _uncheckedResultKeys_ 에서 _key_ 제거.
        1. _extensibleTarget_ 이 *true* 이면 _trapResult_ 반환.
        1. _targetConfigurableKeys_ 의 각 _key_ 에 대해
          1. _uncheckedResultKeys_ 가 _key_ 를 포함하지 않으면 *TypeError* 예외 throw.
          1. _uncheckedResultKeys_ 에서 _key_ 제거.
        1. _uncheckedResultKeys_ 가 비어 있지 않으면 *TypeError* 예외 throw.
        1. _trapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[OwnPropertyKeys]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[OwnPropertyKeys]] 결과는 List 이다.</li>
          <li>반환된 List 에는 중복 항목이 없다.</li>
          <li>반환 List 의 각 요소는 프로퍼티 키이다.</li>
          <li>결과 List 는 target 객체의 모든 비구성 가능 자체 프로퍼티의 키를 포함해야 한다.</li>
          <li>target 객체가 비확장이라면 결과 List 는 target 객체 자체 프로퍼티의 모든 키만 포함해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"apply"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? Call(_target_, _thisArgument_, _argumentsList_) 반환.
        1. _argArray_ 를 CreateArrayFromList(_argumentsList_) 로 둔다.
        1. ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ ») 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 이그조틱 객체는 [[ProxyTarget]] 내부 슬롯 초기 값이 [[Call]] 내부 메서드를 가진 객체인 경우에만 [[Call]] 내부 메서드를 가진다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): Object 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. 단언: IsConstructor(_target_) 는 *true*.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"construct"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? Construct(_target_, _argumentsList_, _newTarget_) 반환.
        1. _argArray_ 를 CreateArrayFromList(_argumentsList_) 로 둔다.
        1. _newObj_ 를 ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ ») 로 둔다.
        1. _newObj_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. _newObj_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 이그조틱 객체는 [[ProxyTarget]] 내부 슬롯 초기 값이 [[Construct]] 내부 메서드를 가진 객체인 경우에만 [[Construct]] 내부 메서드를 가진다.</p>
      </emu-note>
      <emu-note>
        <p>Proxy 객체의 [[Construct]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[Construct]] 결과는 Object 이어야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-validatenonrevokedproxy" type="abstract operation">
      <h1>
        ValidateNonRevokedProxy (
          _proxy_: a Proxy exotic object,
        ): ~unused~ 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_proxy_ 가 revoke 되었다면 *TypeError* 예외를 던진다.</dd>
      </dl>
      <emu-alg>
        1. _proxy_.[[ProxyTarget]] 이 *null* 이면 *TypeError* 예외 throw.
        1. 단언: _proxy_.[[ProxyHandler]] 는 *null* 이 아님.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-proxycreate" type="abstract operation">
      <h1>
        ProxyCreate (
          _target_: an ECMAScript language value,
          _handler_: an ECMAScript language value,
        ): Proxy 이그조틱 객체를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>새 Proxy 객체 생성 과정을 명세하는 데 사용된다.</dd>
      </dl>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외 throw.
        1. _handler_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. _P_ 를 MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] ») 로 둔다.
        1. _P_ 의 핵심 내부 메서드( [[Call]], [[Construct]] 제외)를 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots"></emu-xref> 에 지정된 정의로 설정.
        1. IsCallable(_target_) 이 *true* 이면
          1. _P_.[[Call]] 을 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist"></emu-xref> 에서 지정된 대로 설정.
          1. IsConstructor(_target_) 이 *true* 이면
            1. _P_.[[Construct]] 를 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget"></emu-xref> 에서 지정된 대로 설정.
        1. _P_.[[ProxyTarget]] 을 _target_ 으로 설정.
        1. _P_.[[ProxyHandler]] 를 _handler_ 로 설정.
        1. _P_ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-source-code">
  <h1>ECMAScript 언어: 소스 텍스트(ECMAScript Language: Source Text)</h1>

  <emu-clause id="sec-source-text">
    <h1>소스 텍스트(Source Text)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SourceCharacter ::
        &gt; any Unicode code point
    </emu-grammar>
    <p><dfn>ECMAScript source text</dfn>는 유니코드 코드 포인트들의 시퀀스이다. ECMAScript 문법이 허용하는 위치에서는 U+0000 부터 U+10FFFF 까지의 모든 유니코드 코드 포인트 값(서러게이트 코드 포인트 포함)이 ECMAScript 소스 텍스트에 나타날 수 있다. ECMAScript 소스 텍스트를 저장·교환하는 실제 인코딩은 이 명세와 무관하다. 외부 소스 텍스트 인코딩이 무엇이든, 적합한 ECMAScript 구현은 소스 텍스트를 동등한 |SourceCharacter| 값들의 시퀀스로 처리하며, 각 |SourceCharacter| 는 하나의 유니코드 코드 포인트이다. 적합한 ECMAScript 구현은 소스 텍스트에 대해 어떤 정규화(normalization)를 수행할 필요도 없으며 정규화를 수행하는 것처럼 동작할 필요도 없다.</p>
    <p>결합 문자 시퀀스(combining character sequence)의 구성 요소들은 사용자가 전체를 단일 문자로 생각할지라도 개별 유니코드 코드 포인트로 취급된다.</p>
    <emu-note>
      <p>문자열 리터럴, 정규 표현식 리터럴, 템플릿 리터럴 및 식별자에서 모든 유니코드 코드 포인트는 해당 코드 포인트의 수치 값을 명시적으로 표현하는 유니코드 이스케이프 시퀀스로도 표현할 수 있다. 주석 안에서는 그러한 이스케이프 시퀀스는 주석 일부로서 사실상 무시된다.</p>
      <p>ECMAScript 는 유니코드 이스케이프 시퀀스 동작에서 Java 프로그래밍 언어와 다르다. 예를 들어 Java 프로그램에서 유니코드 이스케이프 시퀀스 `\\u000A` 가 단일 행 주석 내에 나타나면 그것은 행 종결자(유니코드 코드 포인트 U+000A 는 LINE FEED (LF))로 해석되어 다음 코드 포인트는 더 이상 주석의 일부가 아니다. 마찬가지로 Java 프로그램의 문자열 리터럴에 `\\u000A` 가 나타나면 그것 역시 행 종결자로 해석되며 문자열 리터럴 내부에는 허용되지 않는다—문자열 값에 LINE FEED (LF)를 포함하려면 `\\u000A` 대신 `\\n` 을 써야 한다. ECMAScript 프로그램에서는 주석 내부에 나타나는 유니코드 이스케이프 시퀀스가 절대 해석되지 않으며 따라서 주석 종료에 기여할 수 없다. 유사하게 ECMAScript 프로그램의 문자열 리터럴 내부에 나타나는 유니코드 이스케이프 시퀀스는 항상 리터럴의 일부로 기여하고 결코 행 종결자나 문자열 리터럴을 종료시킬 수 있는 코드 포인트로 해석되지 않는다.</p>
    </emu-note>

    <emu-clause id="sec-utf16encodecodepoint" type="abstract operation" oldids="sec-utf16encoding,sec-codepointtoutf16codeunits">
      <h1>
        정적 의미론(Static Semantics): UTF16EncodeCodePoint (
        _cp_: a Unicode code point,
        ): a String
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 단언: 0 ≤ _cp_ ≤ 0x10FFFF.
        1. _cp_ ≤ 0xFFFF 이면, 수치 값이 _cp_ 인 코드 유닛으로 구성된 String 값을 반환한다.
        1. _cu1_ 를 수치 값이 floor((_cp_ - 0x10000) / 0x400) + 0xD800 인 코드 유닛으로 둔다.
        1. _cu2_ 를 수치 값이 ((_cp_ - 0x10000) modulo 0x400) + 0xDC00 인 코드 유닛으로 둔다.
        1. _cu1_ 과 _cu2_ 의 문자열 연결(string-concatenation)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointstostring" type="abstract operation" oldids="sec-utf16encode">
      <h1>
        정적 의미론(Static Semantics): CodePointsToString (
        _text_: a sequence of Unicode code points,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>이는 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 설명된 대로 _text_ 를 String 값으로 변환한다.</dd>
      </dl>
      <emu-alg>
        1. _result_ 를 빈 문자열로 둔다.
        1. _text_ 의 각 코드 포인트 _cp_ 에 대해
          1. _result_ 를 _result_ 와 UTF16EncodeCodePoint(_cp_) 의 문자열 연결로 설정한다.
        1. _result_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-utf16decodesurrogatepair" type="abstract operation" oldids="sec-utf16decode,utf16decodesurrogatepair">
      <h1>
        정적 의미론(Static Semantics): UTF16SurrogatePairToCodePoint (
        _lead_: a code unit,
        _trail_: a code unit,
        ): a code point
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>UTF-16 서로게이트 쌍을 이루는 두 코드 유닛을 코드 포인트로 변환한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _lead_ 는 선행 서로게이트이고 _trail_ 은 후행 서로게이트이다.
        1. _cp_ 를 (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000 으로 둔다.
        1. 코드 포인트 _cp_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointat" type="abstract operation">
      <h1>
        정적 의미론(Static Semantics): CodePointAt (
        _string_: a String,
        _position_: a non-negative integer,
        ): a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd><emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 설명된 대로 _string_ 을 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하고, 인덱스 _position_ 에 있는 코드 유닛에서 시작하는 단일 코드 포인트를 읽는다.</dd>
      </dl>
      <emu-alg>
        1. _size_ 를 _string_ 길이로 둔다.
        1. 단언: _position_ ≥ 0 그리고 _position_ &lt; _size_.
        1. _first_ 를 _string_ 내 인덱스 _position_ 의 코드 유닛으로 둔다.
        1. _cp_ 를 수치 값이 _first_ 의 수치 값인 코드 포인트로 둔다.
        1. _first_ 가 선행 서로게이트도 후행 서로게이트도 아니면
          1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* } 를 반환한다.
        1. _first_ 가 후행 서로게이트이거나 _position_ + 1 = _size_ 이면
          1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* } 를 반환한다.
        1. _second_ 를 _string_ 내 인덱스 _position_ + 1 의 코드 유닛으로 둔다.
        1. _second_ 가 후행 서로게이트가 아니면
          1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* } 를 반환한다.
        1. _cp_ 를 UTF16SurrogatePairToCodePoint(_first_, _second_) 로 설정한다.
        1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* } 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-stringtocodepoints" type="abstract operation" oldids="sec-utf16decodestring">
      <h1>
        정적 의미론(Static Semantics): StringToCodePoints (
        _string_: a String,
        ): a List of code points
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd><emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 설명된 대로 _string_ 을 UTF-16 인코딩된 유니코드 텍스트로 해석하여 얻어지는 유니코드 코드 포인트 시퀀스를 반환한다.</dd>
      </dl>
      <emu-alg>
        1. _codePoints_ 를 새 빈 List 로 둔다.
        1. _size_ 를 _string_ 길이로 둔다.
        1. _position_ 을 0 으로 둔다.
        1. _position_ &lt; _size_ 인 동안 반복,
          1. _cp_ 를 CodePointAt(_string_, _position_) 로 둔다.
          1. _cp_.[[CodePoint]] 를 _codePoints_ 에 추가한다.
          1. _position_ 을 _position_ + _cp_.[[CodeUnitCount]] 로 설정한다.
        1. _codePoints_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parsetext" type="abstract operation">
      <h1>
        정적 의미론(Static Semantics): ParseText (
        _sourceText_: a String or a sequence of Unicode code points,
        _goalSymbol_: a nonterminal in one of the ECMAScript grammars,
        ): a Parse Node or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _sourceText_ 가 String 이면 _sourceText_ 를 StringToCodePoints(_sourceText_) 로 설정한다.
        1. _goalSymbol_ 을 목표 심볼(goal symbol)로 사용하여 _sourceText_ 를 파싱하고, 파싱 결과를 조기 오류(early error) 조건이 있는지 분석한다. 파싱과 조기 오류 검출은 구현 정의 방식으로 상호 교차(interleaved)될 수 있다.
        1. 파싱이 성공했고 조기 오류가 발견되지 않았다면, 파싱에서 생성된 파스 트리의 루트에 있는 Parse Node ( _goalSymbol_ 의 인스턴스) 를 반환한다.
        1. 그렇지 않으면, 파싱 오류 및/또는 조기 오류를 나타내는 하나 이상의 *SyntaxError* 객체들의 List 를 반환한다. 둘 이상의 파싱 오류 또는 조기 오류가 있을 경우, 리스트 내 오류 객체의 수와 순서는 구현 정의이지만 최소 하나는 있어야 한다.
      </emu-alg>
      <emu-note>
        <p>특정 지점에 조기 오류가 있고 이후 지점에 구문 오류가 있는 텍스트를 생각해보자. 파싱 후 조기 오류 패스를 수행하는 구현은 구문 오류를 보고하고 조기 오류 패스로 진행하지 않을 수 있다. 두 활동을 교차 수행하는 구현은 조기 오류를 보고하고 구문 오류 탐지를 진행하지 않을 수 있다. 세 번째 구현은 두 오류를 모두 보고할 수 있다. 이 모든 동작은 적합하다.</p>
      </emu-note>
      <emu-note>
        <p><emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 절도 참조.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-types-of-source-code">
    <h1>소스 코드의 유형(Types of Source Code)</h1>
    <p>ECMAScript 코드는 네 가지 유형이 있다:</p>
    <ul>
      <li>
        <dfn>Global code</dfn> 는 ECMAScript |Script| 로 취급되는 소스 텍스트이다. 특정 |Script| 의 global code 는 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| 의 일부로 파싱되는 어떤 소스 텍스트도 포함하지 않는다.
      </li>
      <li>
        <dfn>Eval code</dfn> 는 내장 `eval` 함수에 제공되는 소스 텍스트이다. 더 정확히 말해 내장 `eval` 함수의 매개변수가 String 이면 ECMAScript |Script| 로 취급된다. 특정 `eval` 호출에 대한 eval code 는 그 |Script| 의 global code 부분이다.
      </li>
      <li>
        <p><dfn>Function code</dfn> 는 ECMAScript 함수 객체의 [[ECMAScriptCode]] 및 [[FormalParameters]] 내부 슬롯 값( <emu-xref href="#sec-ecmascript-function-objects"></emu-xref> 참조 )을 제공하기 위해 파싱되는 소스 텍스트이다. 특정 ECMAScript 함수의 function code 는 중첩된 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| 의 function code 로 파싱되는 어떤 소스 텍스트도 포함하지 않는다.</p>
        <p>추가로, 위에서 언급한 소스 텍스트가 다음으로 파싱되는 경우:</p>
        <ul>
          <li>|FunctionDeclaration| 또는 |FunctionExpression| 의 |FormalParameters| 및 |FunctionBody|,</li>
          <li>|GeneratorDeclaration| 또는 |GeneratorExpression| 의 |FormalParameters| 및 |GeneratorBody|,</li>
          <li>|AsyncFunctionDeclaration| 또는 |AsyncFunctionExpression| 의 |FormalParameters| 및 |AsyncFunctionBody|, 또는</li>
          <li>|AsyncGeneratorDeclaration| 또는 |AsyncGeneratorExpression| 의 |FormalParameters| 및 |AsyncGeneratorBody|,</li>
        </ul>
        <p>그 선언 또는 표현식의 |BindingIdentifier| (있다면) 에 매치되는 소스 텍스트 역시 해당 함수의 function code 에 포함된다.</p>
      </li>
      <li>
        <dfn>Module code</dfn> 는 |ModuleBody| 로 제공되는 소스 텍스트이다. 이는 모듈이 초기화될 때 직접 평가되는 코드이다. 특정 모듈의 module code 는 중첩된 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| 의 일부로 파싱되는 어떤 소스 텍스트도 포함하지 않는다.
      </li>
    </ul>
    <emu-note>
      <p>Function code 는 일반적으로 Function Definitions (<emu-xref href="#sec-function-definitions"></emu-xref>), Arrow Function Definitions (<emu-xref href="#sec-arrow-function-definitions"></emu-xref>), Method Definitions (<emu-xref href="#sec-method-definitions"></emu-xref>), Generator Function Definitions (<emu-xref href="#sec-generator-function-definitions"></emu-xref>), Async Function Definitions (<emu-xref href="#sec-async-function-definitions"></emu-xref>), Async Generator Function Definitions (<emu-xref href="#sec-async-generator-function-definitions"></emu-xref>), Async Arrow Functions (<emu-xref href="#sec-async-arrow-function-definitions"></emu-xref>) 의 본문으로 제공된다. Function code 는 또한 Function 생성자 (<emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>), GeneratorFunction 생성자 (<emu-xref href="#sec-generatorfunction"></emu-xref>), AsyncFunction 생성자 (<emu-xref href="#sec-async-function-constructor-arguments"></emu-xref>), AsyncGeneratorFunction 생성자 (<emu-xref href="#sec-asyncgeneratorfunction"></emu-xref>) 의 인자에서 파생된다.</p>
    </emu-note>
    <emu-note>
      <p>function code 에 |BindingIdentifier| 를 포함하는 실질적 효과는 주변 코드가 strict 모드 코드가 아니더라도 함수 본문에 "use strict" 지시문을 포함하는 함수 이름인 |BindingIdentifier| 에 strict 모드 코드의 Early Errors 가 적용되게 한다.</p>
    </emu-note>

    <emu-clause id="sec-directive-prologues-and-the-use-strict-directive">
      <h1>지시문 프로로그와 Use Strict 지시문(Directive Prologues and the Use Strict Directive)</h1>
      <p><dfn id="directive-prologue" variants="Directive Prologues">Directive Prologue</dfn> 는 |FunctionBody|, |ScriptBody|, 또는 |ModuleBody| 의 처음 |StatementListItem| 들 또는 |ModuleItem| 들로 발생하는 |ExpressionStatement| 들의 가장 긴 시퀀스로서, 그 시퀀스의 각 |ExpressionStatement| 가 완전히 |StringLiteral| 토큰 뒤에 세미콜론이 따라오는 형태로만 구성된다. 세미콜론은 명시적으로 나타나거나 자동 세미콜론 삽입(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)에 의해 삽입될 수 있다. Directive Prologue 는 빈 시퀀스일 수 있다.</p>
      <p><dfn id="use-strict-directive" variants="Use Strict Directives">Use Strict Directive</dfn> 는 |StringLiteral| 이 정확히 `"use strict"` 또는 `'use strict'` 코드 포인트 시퀀스인 Directive Prologue 내의 |ExpressionStatement| 이다. Use Strict Directive 는 |EscapeSequence| 또는 |LineContinuation| 을 포함할 수 없다.</p>
      <p>Directive Prologue 는 둘 이상의 Use Strict Directive 를 포함할 수 있다. 단, 구현은 이 경우 경고를 발행할 수 있다.</p>
      <emu-note>
        <p>Directive Prologue 의 |ExpressionStatement| 들은 포함하는 생성물(production)을 평가하는 동안 정상적으로 평가된다. 구현은 Use Strict Directive 가 아니면서 Directive Prologue 에 등장하는 |ExpressionStatement| 에 대해 구현별 의미를 정의할 수 있다. 적절한 통지 메커니즘이 존재한다면, 구현은 Directive Prologue 에서 Use Strict Directive 가 아니고 구현이 정의한 의미도 가지지 않는 |ExpressionStatement| 를 발견할 경우 경고를 발행해야 한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-strict-mode-code">
      <h1>Strict 모드 코드(Strict Mode Code)</h1>
      <p>ECMAScript 구문 단위는 비제한(unrestricted) 또는 strict 모드 문법과 의미론(<emu-xref href="#sec-strict-variant-of-ecmascript"></emu-xref>)을 사용하여 처리될 수 있다. 다음 상황에서 코드는 <dfn>strict mode code</dfn> 로 해석된다:</p>
      <ul>
        <li>
          Global code 는 Use Strict Directive 를 포함하는 Directive Prologue 로 시작하면 strict mode code 이다.
        </li>
        <li>
          Module code 는 항상 strict mode code 이다.
        </li>
        <li>
          |ClassDeclaration| 또는 |ClassExpression| 의 모든 부분은 strict mode code 이다.
        </li>
        <li>
          Eval code 는 Use Strict Directive 를 포함하는 Directive Prologue 로 시작하거나 호출되는 `eval` 이 strict mode code 에 포함된 direct eval 이면 strict mode code 이다.
        </li>
        <li>
          Function code 는 연관된 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction| 이 strict mode code 에 포함되거나 그 함수의 [[ECMAScriptCode]] 내부 슬롯 값을 생성하는 코드가 Use Strict Directive 를 포함하는 Directive Prologue 로 시작하면 strict mode code 이다.
        </li>
        <li>
          내장 Function, Generator, AsyncFunction, AsyncGenerator 생성자에 인자로 제공되는 Function code 는 마지막 인자가 String 이고 그것을 처리했을 때 |FunctionBody| 가 Use Strict Directive 를 포함하는 Directive Prologue 로 시작한다면 strict mode code 이다.
        </li>
      </ul>
      <p>strict mode code 가 아닌 ECMAScript 코드는 <dfn id="non-strict-code">non-strict code</dfn> 라고 한다.</p>

      <emu-clause id="sec-isstrict" type="abstract operation">
        <h1>
          정적 의미론(Static Semantics): IsStrict (
          _node_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _node_ 가 매치한 소스 텍스트가 strict mode code 이면 *true* 반환; 그렇지 않으면 *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-non-ecmascript-functions">
      <h1>비 ECMAScript 함수(Non-ECMAScript Functions)</h1>
      <p>ECMAScript 구현은 평가 동작이 ECMAScript 소스 텍스트가 아닌 호스트 정의 실행 가능 코드 형태로 표현된 함수 이그조틱 객체의 평가를 지원할 수 있다. 함수 객체가 ECMAScript 코드 내에서 정의되었는지 또는 내장 함수인지 여부는 그러한 함수 객체를 호출하거나 그에 의해 호출되는 ECMAScript 코드의 관점에서는 관측할 수 없다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-lexical-grammar">
  <h1>ECMAScript 언어: 어휘 문법( Lexical Grammar )</h1>
  <p>ECMAScript |Script| 또는 |Module| 의 소스 텍스트는 먼저 입력 요소들의 시퀀스로 변환되는데, 이는 토큰(token), 줄 종결자(line terminator), 주석(comment), 또는 공백(white space)이다. 소스 텍스트는 왼쪽에서 오른쪽으로 스캔되며, 매번 가능한 한 가장 긴 코드 포인트 시퀀스를 다음 입력 요소로 선택한다.</p>
  <p>입력 요소를 소비하는 구문 문법(syntactic grammar) 문맥에 따라 어휘 입력 요소 식별이 민감하게 달라지는 여러 상황이 있다. 이는 어휘 문법에 여러 목표 심볼(lexical goal symbol)이 필요한 이유이다. |InputElementHashbangOrRegExp| 목표는 |Script| 또는 |Module| 의 시작에서 사용된다. |InputElementRegExpOrTemplateTail| 목표는 |RegularExpressionLiteral|, |TemplateMiddle| 또는 |TemplateTail| 이 허용되는 구문 문맥에서 사용된다. |InputElementRegExp| 목표 심볼은 |RegularExpressionLiteral| 이 허용되지만 |TemplateMiddle| 과 |TemplateTail| 은 허용되지 않는 모든 구문 문맥에서 사용된다. |InputElementTemplateTail| 목표는 |TemplateMiddle| 또는 |TemplateTail| 이 허용되지만 |RegularExpressionLiteral| 은 허용되지 않는 모든 구문 문맥에서 사용된다. 그 외 모든 문맥에서는 |InputElementDiv| 가 어휘 목표 심볼로 사용된다.</p>
  <emu-note>
    <p>여러 어휘 목표를 사용하는 것은 자동 세미콜론 삽입에 영향을 주는 어휘적 모호성이 없도록 보장한다. 예를 들어 선행 division 또는 division-assignment 와 선행 |RegularExpressionLiteral| 이 동시에 허용되는 구문 문맥은 존재하지 않는다. 이는 세미콜론 삽입 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) 에 의해 영향을 받지 않는다. 다음 예와 같이:</p>
    <pre><code class="javascript">
      a = b
      /hi/g.exec(c).map(d);
    </code></pre>
    <p>|LineTerminator| 뒤의 첫 공백·주석이 아닌 코드 포인트가 U+002F (SOLIDUS) 이고, 구문 문맥이 division 또는 division-assignment 를 허용한다면, 해당 |LineTerminator| 위치에는 세미콜론이 삽입되지 않는다. 즉, 위 예는 다음과 동일하게 해석된다:</p>
    <pre><code class="javascript">
      a = b / hi / g.exec(c).map(d);
    </code></pre>
  </emu-note>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    InputElementDiv ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      RightBracePunctuator

    InputElementRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RightBracePunctuator
      RegularExpressionLiteral

    InputElementRegExpOrTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RegularExpressionLiteral
      TemplateSubstitutionTail

    InputElementTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      TemplateSubstitutionTail

    InputElementHashbangOrRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      HashbangComment
      RegularExpressionLiteral
  </emu-grammar>

  <emu-clause id="sec-unicode-format-control-characters">
    <h1>유니코드 서식 제어 문자(Unicode Format-Control Characters)</h1>
    <p>유니코드 서식 제어 문자(즉, 유니코드 문자 데이터베이스 범주 “Cf” 에 속하는 LEFT-TO-RIGHT MARK, RIGHT-TO-LEFT MARK 등)는 상위 수준 프로토콜(예: 마크업 언어)이 없는 상황에서 텍스트 범위 서식을 제어하는 데 사용하는 제어 코드이다.</p>
    <p>소스 텍스트에서 편집 및 표시를 용이하게 하기 위해 서식 제어 문자를 허용하는 것이 유용하다. 모든 서식 제어 문자는 주석 내부, 그리고 문자열 리터럴, 템플릿 리터럴, 정규 표현식 리터럴 내부에 사용할 수 있다.</p>
    <p>U+FEFF (ZERO WIDTH NO-BREAK SPACE)는 주로 텍스트 시작 부분에서 해당 텍스트가 유니코드임을 표시하고 인코딩과 바이트 순서를 감지할 수 있도록 하는 서식 제어 문자이다. 이 목적을 위한 &lt;ZWNBSP> 문자가 파일을 연결(concatenate)한 결과 등으로 텍스트 시작 이후에 나타나는 경우도 있다. ECMAScript 소스 텍스트에서 &lt;ZWNBSP> 코드 포인트는 주석, 문자열 리터럴, 템플릿 리터럴, 정규 표현식 리터럴 밖에서는 공백 문자(<emu-xref href="#sec-white-space"></emu-xref> 참조)로 취급된다.</p>
  </emu-clause>

  <emu-clause id="sec-white-space">
    <h1>공백(White Space)</h1>
    <p>공백 코드 포인트는 소스 텍스트 가독성을 높이고 토큰(분할 불가능한 어휘 단위)들을 분리하기 위해 사용되며, 그 외에는 의미가 없다. 공백 코드 포인트는 임의의 두 토큰 사이 및 입력 시작과 끝에 나타날 수 있다. 공백 코드 포인트는 |StringLiteral|, |RegularExpressionLiteral|, |Template|, |TemplateSubstitutionTail| 내부에 나타날 수 있으며 그 경우 리터럴 값의 일부를 구성하는 의미 있는(code point)로 간주된다. |Comment| 내부에도 나타날 수 있지만 그 밖의 다른 종류의 토큰 내부에는 나타날 수 없다.</p>
    <p>ECMAScript 공백 코드 포인트는 <emu-xref href="#table-white-space-code-points"></emu-xref>에 나열되어 있다.</p>
    <emu-table id="table-white-space-code-points" caption="White Space Code Points" oldids="table-32">
      <table>
        <thead>
          <tr>
            <th>
              Code Points
            </th>
            <th>
              Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+0009`
          </td>
          <td>
            CHARACTER TABULATION
          </td>
          <td>
            &lt;TAB>
          </td>
        </tr>
        <tr>
          <td>
            `U+000B`
          </td>
          <td>
            LINE TABULATION
          </td>
          <td>
            &lt;VT>
          </td>
        </tr>
        <tr>
          <td>
            `U+000C`
          </td>
          <td>
            FORM FEED (FF)
          </td>
          <td>
            &lt;FF>
          </td>
        </tr>
        <tr>
          <td>
            `U+FEFF`
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP>
          </td>
        </tr>
        <tr>
          <td>
            any code point in general category “Space_Separator”
          </td>
          <td>
          </td>
          <td>
            &lt;USP>
          </td>
        </tr>
      </table>
    </emu-table>
    <emu-note>
      <p>U+0020 (SPACE) 과 U+00A0 (NO-BREAK SPACE) 코드 포인트는 &lt;USP> 에 속한다.</p>
    </emu-note>
    <emu-note>
      <p><emu-xref href="#table-white-space-code-points"></emu-xref> 에 나열된 코드 포인트를 제외하고 ECMAScript |WhiteSpace| 는 “White_Space” 유니코드 속성을 가지지만 일반 범주 “Space_Separator”(“Zs”) 에 속하지 않는 모든 코드 포인트를 의도적으로 제외한다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WhiteSpace ::
        &lt;TAB&gt;
        &lt;VT&gt;
        &lt;FF&gt;
        &lt;ZWNBSP&gt;
        &lt;USP&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-line-terminators">
    <h1>줄 종결자(Line Terminators)</h1>
    <p>공백 코드 포인트와 마찬가지로 줄 종결자 코드 포인트는 소스 텍스트 가독성을 높이고 토큰을 서로 분리한다. 그러나 공백 코드 포인트와 달리 줄 종결자는 구문 문법 동작에 일부 영향을 준다. 일반적으로 줄 종결자는 임의의 두 토큰 사이에 나타날 수 있지만, 구문 문법이 금지하는 몇몇 위치에는 나타날 수 없다. 줄 종결자는 자동 세미콜론 삽입 과정(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)에도 영향을 준다. 줄 종결자는 |StringLiteral|, |Template|, |TemplateSubstitutionTail| 을 제외한 어떤 토큰 내부에도 나타날 수 없다. &lt;LF> 및 &lt;CR> 줄 종결자는 |LineContinuation| 의 일부가 아닌 한 |StringLiteral| 토큰 내부에 나타날 수 없다.</p>
    <p>줄 종결자는 |MultiLineComment| 내부에 나타날 수 있지만 |SingleLineComment| 내부에는 나타날 수 없다.</p>
    <p>줄 종결자는 정규 표현식에서 `\\s` 클래스가 매칭하는 공백 코드 포인트 집합에 포함된다.</p>
    <p>ECMAScript 줄 종결자 코드 포인트는 <emu-xref href="#table-line-terminator-code-points"></emu-xref>에 나열되어 있다.</p>
    <emu-table id="table-line-terminator-code-points" caption="Line Terminator Code Points" oldids="table-33">
      <table>
        <thead>
          <tr>
            <th>
              Code Point
            </th>
            <th>
              Unicode Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+000A`
          </td>
          <td>
            LINE FEED (LF)
          </td>
          <td>
            &lt;LF>
          </td>
        </tr>
        <tr>
          <td>
            `U+000D`
          </td>
          <td>
            CARRIAGE RETURN (CR)
          </td>
          <td>
            &lt;CR>
          </td>
        </tr>
        <tr>
          <td>
            `U+2028`
          </td>
          <td>
            LINE SEPARATOR
          </td>
          <td>
            &lt;LS>
          </td>
        </tr>
        <tr>
          <td>
            `U+2029`
          </td>
          <td>
            PARAGRAPH SEPARATOR
          </td>
          <td>
            &lt;PS>
          </td>
        </tr>
      </table>
    </emu-table>
    <p><emu-xref href="#table-line-terminator-code-points"></emu-xref> 의 유니코드 코드 포인트만 줄 종결자로 취급된다. 다른 개행(new line) 또는 줄 분리(line breaking) 유니코드 코드 포인트는 줄 종결자로 취급되지 않지만 <emu-xref href="#table-white-space-code-points"></emu-xref> 에 명시된 요구를 만족하면 공백으로 취급된다. 시퀀스 &lt;CR>&lt;LF> 는 일반적으로 하나의 줄 종결자로 사용된다. 행 번호 보고 목적으로는 단일 |SourceCharacter| 로 간주해야 한다.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LineTerminator ::
        &lt;LF&gt;
        &lt;CR&gt;
        &lt;LS&gt;
        &lt;PS&gt;

      LineTerminatorSequence ::
        &lt;LF&gt;
        &lt;CR&gt; [lookahead != &lt;LF&gt;]
        &lt;LS&gt;
        &lt;PS&gt;
        &lt;CR&gt; &lt;LF&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-comments">
    <h1>주석(Comments)</h1>
    <p>주석은 단일 행 또는 다중 행일 수 있다. 다중 행 주석은 중첩될 수 없다.</p>
    <p>단일 행 주석은 |LineTerminator| 코드 포인트를 제외한 임의의 유니코드 코드 포인트를 포함할 수 있고, 토큰은 항상 가능한 한 가장 길게 인식된다는 일반 규칙 때문에, 단일 행 주석은 `//` 마커로부터 그 줄 끝까지의 모든 코드 포인트로 구성된다. 단, 줄 끝의 |LineTerminator| 는 단일 행 주석의 일부로 간주되지 않으며 어휘 문법에 의해 별도로 인식되어 구문 문법을 위한 입력 요소 스트림의 일부가 된다. 이 점은 단일 행 주석의 존재 여부가 자동 세미콜론 삽입 과정 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) 에 영향을 주지 않음을 의미하므로 매우 중요하다.</p>
    <p>주석은 공백처럼 동작하며 폐기되지만, |MultiLineComment| 가 줄 종결자 코드 포인트를 포함하면 구문 문법이 파싱할 때 전체 주석이 |LineTerminator| 로 간주된다.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Comment ::
        MultiLineComment
        SingleLineComment

      MultiLineComment ::
        `/*` MultiLineCommentChars? `*/`

      MultiLineCommentChars ::
        MultiLineNotAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      PostAsteriskCommentChars ::
        MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      MultiLineNotAsteriskChar ::
        SourceCharacter but not `*`

      MultiLineNotForwardSlashOrAsteriskChar ::
        SourceCharacter but not one of `/` or `*`

      SingleLineComment ::
        `//` SingleLineCommentChars?

      SingleLineCommentChars ::
        SingleLineCommentChar SingleLineCommentChars?

      SingleLineCommentChar ::
        SourceCharacter but not LineTerminator
    </emu-grammar>
    <p>이 절의 다수 생성물은 <emu-xref href="#sec-html-like-comments"></emu-xref> 절에서 대체 정의를 가진다.</p>
  </emu-clause>

  <emu-clause id="sec-hashbang">
    <h1>Hashbang 주석(Hashbang Comments)</h1>

    <p>Hashbang 주석은 위치에 민감하며 다른 종류의 주석처럼 구문 문법 입력 요소 스트림에서 제거(discard)된다.</p>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      HashbangComment ::
        `#!` SingleLineCommentChars?
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-tokens">
    <h1>토큰(Tokens)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CommonToken ::
        IdentifierName
        PrivateIdentifier
        Punctuator
        NumericLiteral
        StringLiteral
        Template
    </emu-grammar>
    <emu-note>
      <p>|DivPunctuator|, |RegularExpressionLiteral|, |RightBracePunctuator|, |TemplateSubstitutionTail| 생성물은 |CommonToken| 생성물에 포함되지 않는 추가 토큰을 도출한다.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-names-and-keywords">
    <h1>이름과 키워드(Names and Keywords)</h1>
    <p>|IdentifierName| 과 |ReservedWord| 는 Unicode Standard Annex #31 (Identifier and Pattern Syntax)에 규정된 기본 식별자 문법(Default Identifier Syntax)을 (소규모 수정과 함께) 따른 토큰이다. |ReservedWord| 는 |IdentifierName| 의 열거된 부분집합이다. 구문 문법은 |Identifier| 를 |IdentifierName| 이면서 |ReservedWord| 가 아닌 것으로 정의한다. 유니코드 식별자 문법은 유니코드 표준이 규정한 문자 속성에 기반한다. 최신 유니코드 표준 버전에 지정된 범주의 유니코드 코드 포인트는 모든 적합 ECMAScript 구현에서 그 범주에 속한 것으로 취급되어야 한다. ECMAScript 구현은 추후판 유니코드 표준에서 정의된 식별자 코드 포인트를 추가로 인식할 수 있다.</p>
    <emu-note>
      <p>본 표준은 특정 코드 포인트 추가를 지정한다: U+0024 (DOLLAR SIGN) 과 U+005F (LOW LINE)는 |IdentifierName| 내 어디서든 허용된다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrivateIdentifier ::
        `#` IdentifierName

      IdentifierName ::
        IdentifierStart
        IdentifierName IdentifierPart

      IdentifierStart ::
        IdentifierStartChar
        `\` UnicodeEscapeSequence

      IdentifierPart ::
        IdentifierPartChar
        `\` UnicodeEscapeSequence

      IdentifierStartChar ::
        UnicodeIDStart
        `$`
        `_`

      IdentifierPartChar ::
        UnicodeIDContinue
        `$`

      // emu-format ignore
      AsciiLetter :: one of
        `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
        `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

      UnicodeIDStart ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;

      UnicodeIDContinue ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;
    </emu-grammar>
    <p>비단말 |UnicodeEscapeSequence| 의 정의는 <emu-xref href="#sec-literals-string-literals"></emu-xref>에 있다.</p>
    <emu-note>
      <p>비단말 |IdentifierPart| 는 |UnicodeIDContinue| 를 통해 `_` 를 도출한다.</p>
    </emu-note>
    <emu-note>
      <p>유니코드 속성 “ID_Start” 와 “ID_Continue” 를 가진 코드 포인트 집합은 각각 “Other_ID_Start” 및 “Other_ID_Continue” 속성의 코드 포인트를 포함한다.</p>
    </emu-note>

    <emu-clause id="sec-identifier-names">
      <h1>식별자 이름(Identifier Names)</h1>
      <p>유니코드 이스케이프 시퀀스는 |IdentifierName| 내에서 허용되며 해당 |UnicodeEscapeSequence| 의 IdentifierCodePoint 와 동일한 단일 유니코드 코드 포인트를 기여한다. |UnicodeEscapeSequence| 앞의 `\\` 는 어떠한 코드 포인트도 기여하지 않는다. |UnicodeEscapeSequence| 는 원래라면 무효인 코드 포인트를 |IdentifierName| 에 기여하는 데 사용할 수 없다. 즉 `\\` |UnicodeEscapeSequence| 시퀀스를 그것이 기여하는 |SourceCharacter| 로 치환해도 결과는 동일한 |SourceCharacter| 시퀀스를 가지는 여전히 유효한 |IdentifierName| 이어야 한다. 본 명세에서 |IdentifierName| 의 해석은 특정 코드 포인트가 이스케이프로 입력되었는지 여부와 관계없이 실제 코드 포인트에 기반한다.</p>
      <p>유니코드 표준에 따라 정규적으로 등가(canonically equivalent)인 두 |IdentifierName| 은 각 |UnicodeEscapeSequence| 를 치환한 뒤 정확히 동일한 코드 포인트 시퀀스로 표현되지 않는 한 <em>동일하지 않다</em>.</p>

      <emu-clause id="sec-identifier-names-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>IdentifierStart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>|UnicodeEscapeSequence| 의 IdentifierCodePoint 가 |IdentifierStartChar| 어휘 문법 생성물에 매칭되는 유니코드 코드 포인트가 아니면 Syntax Error.</li>
        </ul>
        <emu-grammar>IdentifierPart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>|UnicodeEscapeSequence| 의 IdentifierCodePoint 가 |IdentifierPartChar| 어휘 문법 생성물에 매칭되는 유니코드 코드 포인트가 아니면 Syntax Error.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoints" type="sdo">
        <h1>정적 의미론: IdentifierCodePoints ( ): 코드 포인트 List</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierName :: IdentifierStart</emu-grammar>
        <emu-alg>
          1. _cp_ 를 |IdentifierStart| 의 IdentifierCodePoint 로 둔다.
          1. « _cp_ » 반환.
        </emu-alg>
        <emu-grammar>IdentifierName :: IdentifierName IdentifierPart</emu-grammar>
        <emu-alg>
          1. _cps_ 를 파생된 |IdentifierName| 의 IdentifierCodePoints 로 둔다.
          1. _cp_ 를 |IdentifierPart| 의 IdentifierCodePoint 로 둔다.
          1. _cps_ 와 « _cp_ » 의 리스트 연결을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoint" type="sdo">
        <h1>정적 의미론: IdentifierCodePoint ( ): 코드 포인트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierStartChar| 가 매칭한 코드 포인트 반환.
        </emu-alg>
        <emu-grammar>IdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierPartChar| 가 매칭한 코드 포인트 반환.
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. |Hex4Digits| 의 MV 인 수치 값을 가진 코드 포인트 반환.
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. |CodePoint| 의 MV 인 수치 값을 가진 코드 포인트 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-keywords-and-reserved-words" oldids="sec-reserved-words,sec-keywords,sec-future-reserved-words">
      <h1>키워드와 예약어(Keywords and Reserved Words)</h1>
      <p><dfn variants="keywords">키워드(keyword)</dfn> 는 |IdentifierName| 에 매칭되면서 구문적 용도를 가지는 토큰, 즉 어떤 구문 생성물에 고정폭(`fixed width`) 글꼴로 문자 그대로 등장하는 토큰이다. ECMAScript 키워드에는 `if`, `while`, `async`, `await` 등 다수가 포함된다.</p>
      <p><dfn variants="reserved words">예약어(reserved word)</dfn> 는 식별자로 사용할 수 없는 |IdentifierName| 이다. 다수 키워드는 예약어이지만 아닌 것도 있으며 어떤 것은 특정 문맥에서만 예약된다. `if`, `while` 은 항상 예약어이다. `await` 는 async 함수 및 모듈 내부에서만 예약된다. `async` 는 예약되지 않으며 제한 없이 변수 이름이나 레이블로 사용할 수 있다.</p>
      <p>이 명세는 문법 생성물과 조기 오류 규칙을 조합하여 어떤 이름이 유효한 식별자이고 어떤 것이 예약어인지 지정한다. 아래 |ReservedWord| 목록의 모든 토큰( `await`, `yield` 제외)은 무조건 예약된다. `await`, `yield` 예외는 매개변수화된 구문 생성물을 사용하는 <emu-xref href="#sec-identifiers"></emu-xref> 에서 지정된다. 마지막으로 여러 조기 오류 규칙이 유효한 식별자 집합을 제한한다. <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-let-and-const-declarations-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-class-definitions-static-semantics-early-errors"></emu-xref> 참조. 요약하면 식별자 이름은 다섯 범주로 나뉜다:</p>
      <ul>
        <li>
          <p>`Math`, `window`, `toString`, `_` 처럼 항상 식별자로 허용되고 키워드가 아닌 것;</p>
        </li>
        <li>
          <p>`await`, `yield` 를 제외한 아래 |ReservedWord| 들처럼 결코 식별자로 허용되지 않는 것;</p>
        </li>
        <li>
          <p>`await`, `yield` 처럼 문맥적으로 식별자로 허용되는 것;</p>
        </li>
        <li>
          <p>strict 모드 코드에서 문맥적으로 식별자로 허용되지 않는 것: `let`, `static`, `implements`, `interface`, `package`, `private`, `protected`, `public`;</p>
        </li>
        <li>
          <p>`as`, `async`, `from`, `get`, `meta`, `of`, `set`, `target` 처럼 항상 식별자로 허용되지만 특정 구문 생성물 안에서 |Identifier| 가 허용되지 않는 위치에 키워드로 나타나기도 하는 것.</p>
        </li>
      </ul>
      <p><dfn variants="conditional keywords">조건부 키워드</dfn> 또는 <dfn variants="contextual keywords">문맥적 키워드(contextual keyword)</dfn> 라는 용어는 마지막 세 범주에 속해 어떤 문맥에서는 식별자, 다른 문맥에서는 키워드로 쓰일 수 있는 키워드를 가리킬 때 사용되기도 한다.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        // emu-format ignore
        ReservedWord :: one of
          `await`
          `break`
          `case` `catch` `class` `const` `continue`
          `debugger` `default` `delete` `do`
          `else` `enum` `export` `extends`
          `false` `finally` `for` `function`
          `if` `import` `in` `instanceof`
          `new` `null`
          `return`
          `super` `switch`
          `this` `throw` `true` `try` `typeof`
          `var` `void`
          `while` `with`
          `yield`
      </emu-grammar>
      <emu-note>
        <p><emu-xref href="#sec-grammar-notation"></emu-xref> 에 따라 문법의 키워드는 특정 |SourceCharacter| 요소들의 리터럴 시퀀스에 매칭된다. 키워드 내 코드 포인트는 `\\` |UnicodeEscapeSequence| 로 표현될 수 없다.</p>
        <p>|IdentifierName| 은 `\\` |UnicodeEscapeSequence| 를 포함할 수 있지만 `els\u{65}` 처럼 작성하여 이름이 "else" 인 변수를 선언할 수는 없다. <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref> 의 조기 오류 규칙이 예약어와 StringValue 가 동일한 식별자를 배제한다.</p>
      </emu-note>
      <emu-note>
        <p>`enum` 은 현재 본 명세에서 키워드로 사용되지 않는다. 이는 향후 언어 확장을 위해 예약된 <em>미래 예약어</em> (future reserved word)이다.</p>
        <p>마찬가지로 `implements`, `interface`, `package`, `private`, `protected`, `public` 는 strict 모드 코드에서 미래 예약어이다.</p>
      </emu-note>
      <emu-note>
        <p>`arguments` 와 `eval` 은 키워드는 아니지만 strict 모드 코드에서 몇 가지 제약을 받는다. <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-static-semantics-assignmenttargettype"></emu-xref>, <emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-function-definitions-static-semantics-early-errors"></emu-xref> 참조.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-punctuators">
    <h1>구두점 기호(Punctuators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Punctuator ::
        OptionalChainingPunctuator
        OtherPunctuator

      OptionalChainingPunctuator ::
        `?.` [lookahead &notin; DecimalDigit]

      // emu-format ignore
      OtherPunctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||` `??`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `&amp;&amp;=` `||=` `??=`
        `=&gt;`

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-ecmascript-language-lexical-grammar-literals">
    <h1>리터럴(Literals)</h1>

    <emu-clause id="sec-null-literals">
      <h1>null 리터럴(Null Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NullLiteral ::
          `null`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-boolean-literals">
      <h1>Boolean 리터럴(Boolean Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BooleanLiteral ::
          `true`
          `false`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-literals-numeric-literals" oldids="sec-additional-syntax-numeric-literals">
      <h1>숫자 리터럴(Numeric Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NumericLiteralSeparator ::
          `_`

        NumericLiteral ::
          DecimalLiteral
          DecimalBigIntegerLiteral
          NonDecimalIntegerLiteral[+Sep]
          NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
          LegacyOctalIntegerLiteral

        DecimalBigIntegerLiteral ::
          `0` BigIntLiteralSuffix
          NonZeroDigit DecimalDigits[+Sep]? BigIntLiteralSuffix
          NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

        NonDecimalIntegerLiteral[Sep] ::
          BinaryIntegerLiteral[?Sep]
          OctalIntegerLiteral[?Sep]
          HexIntegerLiteral[?Sep]

        BigIntLiteralSuffix ::
          `n`

        DecimalLiteral ::
          DecimalIntegerLiteral `.` DecimalDigits[+Sep]? ExponentPart[+Sep]?
          `.` DecimalDigits[+Sep] ExponentPart[+Sep]?
          DecimalIntegerLiteral ExponentPart[+Sep]?

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit
          NonZeroDigit NumericLiteralSeparator? DecimalDigits[+Sep]
          NonOctalDecimalIntegerLiteral

        DecimalDigits[Sep] ::
          DecimalDigit
          DecimalDigits[?Sep] DecimalDigit
          [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`

        ExponentPart[Sep] ::
          ExponentIndicator SignedInteger[?Sep]

        ExponentIndicator :: one of
          `e` `E`

        SignedInteger[Sep] ::
          DecimalDigits[?Sep]
          `+` DecimalDigits[?Sep]
          `-` DecimalDigits[?Sep]

        BinaryIntegerLiteral[Sep] ::
          `0b` BinaryDigits[?Sep]
          `0B` BinaryDigits[?Sep]

        BinaryDigits[Sep] ::
          BinaryDigit
          BinaryDigits[?Sep] BinaryDigit
          [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

        BinaryDigit :: one of
          `0` `1`

        OctalIntegerLiteral[Sep] ::
          `0o` OctalDigits[?Sep]
          `0O` OctalDigits[?Sep]

        OctalDigits[Sep] ::
          OctalDigit
          OctalDigits[?Sep] OctalDigit
          [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

        LegacyOctalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalIntegerLiteral OctalDigit

        NonOctalDecimalIntegerLiteral ::
          `0` NonOctalDigit
          LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
          NonOctalDecimalIntegerLiteral DecimalDigit

        LegacyOctalLikeDecimalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalLikeDecimalIntegerLiteral OctalDigit

        OctalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7`

        NonOctalDigit :: one of
          `8` `9`

        HexIntegerLiteral[Sep] ::
          `0x` HexDigits[?Sep]
          `0X` HexDigits[?Sep]

        HexDigits[Sep] ::
          HexDigit
          HexDigits[?Sep] HexDigit
          [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

        // emu-format ignore
        HexDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`
      </emu-grammar>
      <p>|NumericLiteral| 바로 뒤 |SourceCharacter| 는 |IdentifierStart| 또는 |DecimalDigit| 이면 안 된다.</p>
      <emu-note>
        <p>예: `3in` 은 오류이며 `3` 과 `in` 두 입력 요소가 아니다.</p>
      </emu-note>

      <emu-clause id="sec-numeric-literals-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          NumericLiteral :: LegacyOctalIntegerLiteral

          DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
        </emu-grammar>
        <ul>
          <li>IsStrict(this production) 이 *true* 이면 Syntax Error.</li>
        </ul>
        <emu-note>비 strict 코드에서 이 문법은 레거시이다.</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-mv" oldids="sec-additional-syntax-numeric-literals-status-semantics">
        <h1>정적 의미론: MV</h1>
        <p>숫자 리터럴은 Number 타입 또는 BigInt 타입의 값을 나타낸다.</p>
        <ul>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits</emu-grammar> 의 MV 는 |DecimalIntegerLiteral| 의 MV + (|DecimalDigits| 의 MV × 10<sup>-_n_</sup>) 이며 여기서 _n_ 은 |NumericLiteralSeparator| 를 모두 제외한 |DecimalDigits| 의 코드 포인트 수.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart</emu-grammar> 의 MV 는 |DecimalIntegerLiteral| 의 MV × 10<sup>_e_</sup> 이며 _e_ 는 |ExponentPart| 의 MV.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart</emu-grammar> 의 MV 는 (|DecimalIntegerLiteral| MV + (|DecimalDigits| MV × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits</emu-grammar> 의 MV 는 |DecimalDigits| MV × 10<sup>-_n_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits ExponentPart</emu-grammar> 의 MV 는 |DecimalDigits| MV × 10<sup>_e_ - _n_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral ExponentPart</emu-grammar> 의 MV 는 |DecimalIntegerLiteral| MV × 10<sup>_e_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: `0`</emu-grammar> 의 MV 는 0.
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparator? DecimalDigits</emu-grammar> 의 MV 는 (|NonZeroDigit| MV × 10<sup>_n_</sup>) + |DecimalDigits| MV.
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits DecimalDigit</emu-grammar> 의 MV 는 (|DecimalDigits| MV × 10) + |DecimalDigit| MV.
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit</emu-grammar> 의 MV 도 위와 동일.
          </li>
          <li>
            <emu-grammar>ExponentPart :: ExponentIndicator SignedInteger</emu-grammar> 의 MV 는 |SignedInteger| MV.
          </li>
          <li>
            <emu-grammar>SignedInteger :: `-` DecimalDigits</emu-grammar> 의 MV 는 |DecimalDigits| MV 의 음수.
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `0`</emu-grammar>, <emu-grammar>HexDigit :: `0`</emu-grammar>, <emu-grammar>OctalDigit :: `0`</emu-grammar>, <emu-grammar>LegacyOctalEscapeSequence :: `0`</emu-grammar>, <emu-grammar>BinaryDigit :: `0`</emu-grammar> 의 MV 는 0.
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `1`</emu-grammar> 등 동일 패턴으로 1.
          </li>
          <li>
            (2~9, a~f, A~F 등에 대한 MV 서술은 원문과 동일 규칙 반복 — 이하 각각 명시된 값.)
          </li>
          <li>
            <emu-grammar>BinaryDigits :: BinaryDigits BinaryDigit</emu-grammar> MV = (이전 × 2) + 새 |BinaryDigit| MV.
          </li>
          <li>
            NumericLiteralSeparator 가 있는 Binary / Octal / HexDigits 경우도 동일 방식.
          </li>
          <li>
            Legacy / NonOctal / HexDigits 조합의 MV 는 표기된 진법에 따라 누적 계산(8 또는 10 또는 16 배) + 새 자리 MV.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-numericvalue" type="sdo">
        <h1>정적 의미론: NumericValue ( ): Number 또는 BigInt</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NumericLiteral :: DecimalLiteral</emu-grammar>
        <emu-alg>
          1. RoundMVResult(|DecimalLiteral| MV) 반환.
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 𝔽(|NonDecimalIntegerLiteral| MV) 반환.
        </emu-alg>
        <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 𝔽(|LegacyOctalIntegerLiteral| MV) 반환.
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. |NonDecimalIntegerLiteral| MV 에 대한 BigInt 값 반환.
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: `0` BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. *0*<sub>ℤ</sub> 반환.
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. |NonZeroDigit| MV 에 대한 BigInt 값 반환.
        </emu-alg>
        <emu-grammar>
          DecimalBigIntegerLiteral ::
            NonZeroDigit DecimalDigits BigIntLiteralSuffix
            NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
        </emu-grammar>
        <emu-alg>
          1. _n_ = |DecimalDigits| 에서 |NumericLiteralSeparator| 제외한 코드 포인트 수.
          1. _mv_ = (|NonZeroDigit| MV × 10<sup>_n_</sup>) + |DecimalDigits| MV.
          1. ℤ(_mv_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-string-literals" oldids="sec-additional-syntax-string-literals">
      <h1>문자열 리터럴(String Literals)</h1>
      <emu-note>
        <p>문자열 리터럴은 작은따옴표 또는 큰따옴표로 둘러싸인 0개 이상의 유니코드 코드 포인트이다. 유니코드 코드 포인트는 이스케이프 시퀀스로도 표현할 수 있다. 닫는 따옴표 코드 포인트, U+005C (REVERSE SOLIDUS), U+000D (CR), U+000A (LF)를 제외한 모든 코드 포인트는 문자열 리터럴 안에 그대로 나타날 수 있다. 어떤 코드 포인트든 이스케이프 시퀀스 형태로 나타날 수 있다. 문자열 리터럴은 ECMAScript String 값을 평가 결과로 가진다. 이러한 String 값을 생성할 때 유니코드 코드 포인트는 <emu-xref href="#sec-utf16encodecodepoint"></emu-xref> 에 정의된 대로 UTF-16 으로 인코딩된다. 기본 다국어 평면(BMP)의 코드 포인트는 하나의 코드 유닛으로, 그 밖의 코드 포인트는 두 코드 유닛으로 인코딩된다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        StringLiteral ::
          `"` DoubleStringCharacters? `"`
          `'` SingleStringCharacters? `'`

        DoubleStringCharacters ::
          DoubleStringCharacter DoubleStringCharacters?

        SingleStringCharacters ::
          SingleStringCharacter SingleStringCharacters?

        DoubleStringCharacter ::
          SourceCharacter but not one of `"` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        SingleStringCharacter ::
          SourceCharacter but not one of `'` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        LineContinuation ::
          `\` LineTerminatorSequence

        EscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          LegacyOctalEscapeSequence
          NonOctalDecimalEscapeSequence
          HexEscapeSequence
          UnicodeEscapeSequence

        CharacterEscapeSequence ::
          SingleEscapeCharacter
          NonEscapeCharacter

        SingleEscapeCharacter :: one of
          `'` `"` `\` `b` `f` `n` `r` `t` `v`

        NonEscapeCharacter ::
          SourceCharacter but not one of EscapeCharacter or LineTerminator

        EscapeCharacter ::
          SingleEscapeCharacter
          DecimalDigit
          `x`
          `u`

        LegacyOctalEscapeSequence ::
          `0` [lookahead &isin; { `8`, `9` }]
          NonZeroOctalDigit [lookahead &notin; OctalDigit]
          ZeroToThree OctalDigit [lookahead &notin; OctalDigit]
          FourToSeven OctalDigit
          ZeroToThree OctalDigit OctalDigit

        NonZeroOctalDigit ::
          OctalDigit but not `0`

        ZeroToThree :: one of
          `0` `1` `2` `3`

        FourToSeven :: one of
          `4` `5` `6` `7`

        NonOctalDecimalEscapeSequence :: one of
          `8` `9`

        HexEscapeSequence ::
          `x` HexDigit HexDigit

        UnicodeEscapeSequence ::
          `u` Hex4Digits
          `u{` CodePoint `}`

        Hex4Digits ::
          HexDigit HexDigit HexDigit HexDigit
      </emu-grammar>
      <p>비단말 |HexDigit| 정의는 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>, |SourceCharacter| 는 <emu-xref href="#sec-source-text"></emu-xref> 에 있다.</p>
      <emu-note>
        <p>&lt;LF>, &lt;CR> 은 |LineContinuation| 일부가 아닌 한 문자열 리터럴 내에 나타날 수 없다(빈 코드 포인트 시퀀스 생성). 문자열 값에 포함하려면 `\\n` 또는 `\\u000A` 같은 이스케이프를 사용해야 한다.</p>
      </emu-note>

      <emu-clause id="sec-string-literals-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          EscapeSequence ::
            LegacyOctalEscapeSequence
            NonOctalDecimalEscapeSequence
        </emu-grammar>
        <ul>
          <li>IsStrict(this production) 이 *true* 이면 Syntax Error.</li>
        </ul>
        <emu-note>비 strict 코드에서 이 문법은 레거시.</emu-note>
        <emu-note>
          <p>문자열 리터럴이 뒤따르는 Use Strict Directive 를 통해 strict 모드가 되는 경우가 있으므로 구현은 위 규칙을 철저히 적용해야 한다. 예:</p>
          <pre><code class="javascript">
            function invalid() { "\7"; "use strict"; }
          </code></pre>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sv" oldids="sec-string-literals-static-semantics-stringvalue,sec-additional-syntax-string-literals-static-semantics" type="sdo">
        <h1>정적 의미론: SV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            <p>문자열 리터럴은 String 타입 값에 해당한다. SV 는 문자열 리터럴의 여러 부분에 재귀 적용되어 String 값을 생성한다. 이 과정에서 문자열 리터럴 내 일부 유니코드 코드 포인트는 아래 또는 <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 에 설명된 대로 수학적 값을 가진 것으로 해석된다.</p>
          </dd>
        </dl>
        <ul>
          <li><emu-grammar>StringLiteral :: `"` `"`</emu-grammar> 의 SV 는 빈 문자열.</li>
          <li><emu-grammar>StringLiteral :: `'` `'`</emu-grammar> 의 SV 는 빈 문자열.</li>
          <li><emu-grammar>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters</emu-grammar> 의 SV 는 두 SV 의 문자열 연결.</li>
          <li><emu-grammar>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters</emu-grammar> 도 동일.</li>
          <li><emu-grammar>DoubleStringCharacter :: SourceCharacter but not one of `"` or `\` or LineTerminator</emu-grammar> 의 SV 는 해당 |SourceCharacter| 코드 포인트 UTF16EncodeCodePoint 결과.</li>
          <li><emu-grammar>DoubleStringCharacter :: &lt;LS&gt;</emu-grammar> SV = 코드 유닛 0x2028.</li>
          <li><emu-grammar>DoubleStringCharacter :: &lt;PS&gt;</emu-grammar> SV = 코드 유닛 0x2029.</li>
          <li><emu-grammar>DoubleStringCharacter :: LineContinuation</emu-grammar> SV = 빈 문자열.</li>
          <li>SingleStringCharacter 변형도 동일 규칙.</li>
          <li><emu-grammar>EscapeSequence :: `0`</emu-grammar> SV = 코드 유닛 0x0000.</li>
          <li><emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> SV 는 대응 표 (<emu-xref href="#table-string-single-character-escape-sequences"></emu-xref>)의 코드 유닛.</li>
        </ul>
        <emu-table id="table-string-single-character-escape-sequences" caption="String Single Character Escape Sequences" oldids="table-34">
          <table>
            <thead>
              <tr>
                <th>
                  Escape Sequence
                </th>
                <th>
                  Code Unit Value
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Symbol
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `\\b`
              </td>
              <td>
                `0x0008`
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                &lt;BS>
              </td>
            </tr>
            <tr>
              <td>
                `\\t`
              </td>
              <td>
                `0x0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `\\n`
              </td>
              <td>
                `0x000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `\\v`
              </td>
              <td>
                `0x000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `\\f`
              </td>
              <td>
                `0x000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `\\r`
              </td>
              <td>
                `0x000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
            <tr>
              <td>
                `\\"`
              </td>
              <td>
                `0x0022`
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `"`
              </td>
            </tr>
            <tr>
              <td>
                `\\'`
              </td>
              <td>
                `0x0027`
              </td>
              <td>
                APOSTROPHE
              </td>
              <td>
                `'`
              </td>
            </tr>
            <tr>
              <td>
                `\\\\`
              </td>
              <td>
                `0x005C`
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\`
              </td>
            </tr>
          </table>
        </emu-table>
        <ul>
          <li><emu-grammar>NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator</emu-grammar> SV = UTF16EncodeCodePoint 결과.</li>
          <li><emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> SV = |LegacyOctalEscapeSequence| MV 값 코드 유닛.</li>
          <li><emu-grammar>NonOctalDecimalEscapeSequence :: `8`</emu-grammar> SV = 코드 유닛 0x0038.</li>
          <li><emu-grammar>NonOctalDecimalEscapeSequence :: `9`</emu-grammar> SV = 코드 유닛 0x0039.</li>
          <li><emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> SV = MV 에 해당 코드 유닛.</li>
          <li><emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> SV = MV 코드 유닛.</li>
          <li><emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> SV = |CodePoint| MV UTF16EncodeCodePoint.</li>
          <li><emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> SV = 코드 유닛 0x0000.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-string-literals-static-semantics-mv">
        <h1>정적 의미론: MV</h1>
        <ul>
          <li><emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit</emu-grammar> MV = (8 × |ZeroToThree| MV) + |OctalDigit| MV.</li>
          <li><emu-grammar>LegacyOctalEscapeSequence :: FourToSeven OctalDigit</emu-grammar> MV = (8 × |FourToSeven| MV) + |OctalDigit| MV.</li>
          <li><emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit</emu-grammar> MV = (64 × |ZeroToThree| MV) + (8 × 첫 |OctalDigit| MV) + 둘째 |OctalDigit| MV.</li>
          <li><emu-grammar>ZeroToThree :: `0`</emu-grammar> MV = 0.</li>
          <li><emu-grammar>ZeroToThree :: `1`</emu-grammar> MV = 1. (2,3 동일 패턴)</li>
          <li><emu-grammar>FourToSeven :: `4`</emu-grammar> MV = 4. (5,6,7 동일 패턴)</li>
          <li><emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> MV = (16 × 첫 |HexDigit| MV) + 둘째 |HexDigit| MV.</li>
          <li><emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> MV = (0x1000 × 첫) + (0x100 × 둘째) + (0x10 × 셋째) + 넷째.</li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-regular-expression-literals">
      <h1>정규 표현식 리터럴(Regular Expression Literals)</h1>
      <emu-note>
        <p>정규 표현식 리터럴은 평가될 때마다 RegExp 객체 (<emu-xref href="#sec-regexp-regular-expression-objects"></emu-xref>) 로 변환되는 입력 요소이다. 동일한 내용을 가진 두 리터럴이라도 서로 `===` 비교에서 같지 않다. 런타임에 `new RegExp` 또는 RegExp 생성자 호출 (<emu-xref href="#sec-regexp-constructor"></emu-xref>) 로도 생성할 수 있다.</p>
      </emu-note>
      <p>아래 생성물은 정규 표현식 리터럴의 구문을 기술하며 입력 요소 스캐너가 리터럴 끝을 찾는 데 사용된다. |RegularExpressionBody| 와 |RegularExpressionFlags| 를 이루는 소스 텍스트는 이후 더 엄격한 ECMAScript 정규식 문법 (<emu-xref href="#sec-patterns"></emu-xref>) 으로 다시 파싱된다.</p>
      <p>구현은 <emu-xref href="#sec-patterns"></emu-xref> 의 ECMAScript 정규식 문법을 확장할 수 있으나 아래 |RegularExpressionBody|, |RegularExpressionFlags| 생성물 및 그 종속 생성물은 확장할 수 없다.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        RegularExpressionLiteral ::
          `/` RegularExpressionBody `/` RegularExpressionFlags

        RegularExpressionBody ::
          RegularExpressionFirstChar RegularExpressionChars

        RegularExpressionChars ::
          [empty]
          RegularExpressionChars RegularExpressionChar

        RegularExpressionFirstChar ::
          RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionChar ::
          RegularExpressionNonTerminator but not one of `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionBackslashSequence ::
          `\` RegularExpressionNonTerminator

        RegularExpressionNonTerminator ::
          SourceCharacter but not LineTerminator

        RegularExpressionClass ::
          `[` RegularExpressionClassChars `]`

        RegularExpressionClassChars ::
          [empty]
          RegularExpressionClassChars RegularExpressionClassChar

        RegularExpressionClassChar ::
          RegularExpressionNonTerminator but not one of `]` or `\`
          RegularExpressionBackslashSequence

        RegularExpressionFlags ::
          [empty]
          RegularExpressionFlags IdentifierPartChar
      </emu-grammar>
      <emu-note>
        <p>정규 표현식 리터럴은 비어 있을 수 없다. `//` 는 빈 정규식이 아니라 단일 행 주석 시작이다. 빈 정규식을 지정하려면 `/(?:)/` 사용.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-bodytext" type="sdo">
        <h1>정적 의미론: BodyText ( ): 소스 텍스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. |RegularExpressionBody| 로 인식된 소스 텍스트 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-flagtext" type="sdo">
        <h1>정적 의미론: FlagText ( ): 소스 텍스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. |RegularExpressionFlags| 로 인식된 소스 텍스트 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literal-lexical-components">
      <h1>템플릿 리터럴 어휘 구성 요소(Template Literal Lexical Components)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Template ::
          NoSubstitutionTemplate
          TemplateHead

        NoSubstitutionTemplate ::
          ``` TemplateCharacters? ```

        TemplateHead ::
          ``` TemplateCharacters? `${`

        TemplateSubstitutionTail ::
          TemplateMiddle
          TemplateTail

        TemplateMiddle ::
          `}` TemplateCharacters? `${`

        TemplateTail ::
          `}` TemplateCharacters? ```

        TemplateCharacters ::
          TemplateCharacter TemplateCharacters?

        TemplateCharacter ::
          `$` [lookahead != `{`]
          `\` TemplateEscapeSequence
          `\` NotEscapeSequence
          LineContinuation
          LineTerminatorSequence
          SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

        TemplateEscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          UnicodeEscapeSequence

        NotEscapeSequence ::
          `0` DecimalDigit
          DecimalDigit but not `0`
          `x` [lookahead &notin; HexDigit]
          `x` HexDigit [lookahead &notin; HexDigit]
          `u` [lookahead &notin; HexDigit] [lookahead != `{`]
          `u` HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` `{` [lookahead &notin; HexDigit]
          `u` `{` NotCodePoint [lookahead &notin; HexDigit]
          `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]

        NotCodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| > 0x10FFFF]

        CodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| &le; 0x10FFFF]
      </emu-grammar>
      <emu-note>
        <p>|TemplateSubstitutionTail| 은 |InputElementTemplateTail| 대안 어휘 목표에서 사용된다.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-tv" type="sdo" oldids="sec-static-semantics-tv-and-trv">
        <h1>정적 의미론: TV ( ): String 또는 *undefined*</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>템플릿 리터럴 구성 요소는 TV 에 의해 String 타입 값으로 해석된다(TV 는 템플릿 객체의 인덱스된 값 목록—template values—구성에 사용). TV 에서는 이스케이프 시퀀스가 해당 유니코드 코드 포인트의 UTF-16 코드 유닛(들)로 치환된다.</dd>
        </dl>
        <ul>
          <li><emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateHead :: ``` `${`</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateTail :: `}` ```</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> TV 는 어느 하나라도 *undefined* 이면 *undefined*, 아니면 둘의 문자열 연결.</li>
          <li><emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> TV = UTF16EncodeCodePoint 결과.</li>
          <li><emu-grammar>TemplateCharacter :: `$`</emu-grammar> TV = 코드 유닛 0x0024.</li>
          <li><emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> TV = |TemplateEscapeSequence| SV.</li>
          <li><emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> TV = *undefined*.</li>
          <li><emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> TV = |LineTerminatorSequence| TRV.</li>
          <li><emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> TV = 빈 문자열.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-trv" type="sdo">
        <h1>정적 의미론: TRV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>템플릿 리터럴 구성 요소는 TRV 에 의해 String 값으로 해석(템플릿 raw 값 구성). TRV 는 TV 와 유사하지만 이스케이프 시퀀스를 그대로(문자열 상 표기 그대로) 반영한다.</dd>
        </dl>
        <ul>
          <li>
            The TRV of <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateTail :: `}` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> is the string-concatenation of the TRV of |TemplateCharacter| and the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `$`</emu-grammar> is the String value consisting of the code unit 0x0024 (DOLLAR SIGN).
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |TemplateEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |NotEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> is the String value consisting of the code unit 0x0030 (DIGIT ZERO).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `0` DecimalDigit</emu-grammar> is the string-concatenation of the code unit 0x0030 (DIGIT ZERO) and the TRV of |DecimalDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` [lookahead &notin; HexDigit]</emu-grammar> is the String value consisting of the code unit 0x0078 (LATIN SMALL LETTER X).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X) and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` [lookahead &notin; HexDigit] [lookahead != `{`]</emu-grammar> is the String value consisting of the code unit 0x0075 (LATIN SMALL LETTER U).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first |HexDigit|, and the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first |HexDigit|, the TRV of the second |HexDigit|, and the TRV of the third |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the code unit 0x007B (LEFT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` NotCodePoint [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of |NotCodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of |CodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>DecimalDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> is the SV of |NonEscapeCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>SingleEscapeCharacter :: one of `'` `"` `\` `b` `f` `n` `r` `t` `v`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is the string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X), the TRV of the first |HexDigit|, and the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of |Hex4Digits|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), the TRV of |CodePoint|, and the code unit 0x007D (RIGHT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is the string-concatenation of the TRV of the first |HexDigit|, the TRV of the second |HexDigit|, the TRV of the third |HexDigit|, and the TRV of the fourth |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> is the string-concatenation of the TRV of |HexDigits| and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LF&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LS&gt;</emu-grammar> is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;PS&gt;</emu-grammar> is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt; &lt;LF&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
        </ul>
        <emu-note>
          <p>TV 는 |LineContinuation| 의 코드 유닛을 제외하지만 TRV 는 포함한다. &lt;CR>&lt;LF>, &lt;CR> 줄 종결 시퀀스는 TV 와 TRV 모두에서 &lt;LF> 로 정규화된다. &lt;CR> 또는 &lt;CR>&lt;LF> 를 원형(raw) 그대로 포함하려면 명시적 |TemplateEscapeSequence| 가 필요하다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>자동 세미콜론 삽입(Automatic Semicolon Insertion)</h1>
    <p>대부분의 ECMAScript 문과 선언은 세미콜론으로 종료되어야 하며, 그 세미콜론은 항상 소스에 명시적으로 쓸 수 있다. 편의를 위해 특정 상황에서는 세미콜론을 생략할 수 있으며, 이 상황에서는 세미콜론이 소스 코드 토큰 스트림에 자동 삽입된다고 기술한다.</p>

    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace="asi-rules">
      <h1>자동 세미콜론 삽입 규칙(Rules of Automatic Semicolon Insertion)</h1>
      <p>다음 규칙에서 “토큰(token)” 은 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref> 에 설명된 현재 어휘 목표 심볼을 사용해 실제로 인식된 어휘 토큰을 뜻한다.</p>
      <p>세 가지 기본 규칙은 다음과 같다:</p>
      <ol>
        <li>
          <p>왼쪽에서 오른쪽으로 파싱 중 문법의 어떤 생성물에도 허용되지 않는 토큰(“오류 토큰(offending token)”)을 만났을 때, 아래 조건 중 하나 이상이 참이면 그 토큰 앞에 세미콜론을 자동 삽입한다:</p>
          <ul>
            <li>오류 토큰이 이전 토큰과 하나 이상의 |LineTerminator| 로 분리되어 있음.</li>
            <li>오류 토큰이 `}` 임.</li>
            <li>이전 토큰이 `)` 이고 삽입된 세미콜론이 do-while 문(<emu-xref href="#sec-do-while-statement"></emu-xref>) 종료 세미콜론으로 파싱될 수 있음.</li>
          </ul>
        </li>
        <li>
          입력 토큰 스트림 끝에 도달했고 파서가 목표 비단말의 단일 인스턴스로 파싱할 수 없다면 입력 스트림 끝에 세미콜론을 자동 삽입.
        </li>
        <li>
          문법 생성물 중 <em>제한 생성물(restricted production)</em> 에 허용되는 토큰이지만 생성물 내 “[no |LineTerminator| here]” 주석 바로 뒤 등장할 수 있는 첫 토큰(제한 토큰)이며 그 제한 토큰이 이전 토큰과 하나 이상의 |LineTerminator| 로 분리되어 있다면 제한 토큰 앞에 세미콜론 자동 삽입.
        </li>
      </ol>
      <p>그러나 추가 최우선 조건이 있다: 세미콜론이 빈 문(empty statement)으로 파싱되거나 `for` 문의 두 세미콜론 중 하나가 되게 하는 경우에는 자동 삽입되지 않는다 (<emu-xref href="#sec-for-statement"></emu-xref> 참조).</p>
      <emu-note>
        <p>문법 내 유일한 제한 생성물은 다음과 같다:</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          YieldExpression[In, Await] :
            `yield`
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

          AsyncFunctionDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
            [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncFunctionExpression :
            `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncMethod[Yield, Await] :
            `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncGeneratorDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
            [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorExpression :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorMethod[Yield, Await] :
            `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncArrowFunction[In, Yield, Await] :
            `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
            CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

          AsyncArrowHead :
            `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
        </emu-grammar>
        <p>실질적 효과:</p>
        <ul>
          <li>`++` / `--` 가 후위(postfix)로 해석될 위치에서 그 앞에 |LineTerminator| 가 있으면 앞에 세미콜론 삽입.</li>
          <li>`continue`, `break`, `return`, `throw`, `yield` 뒤에 |LineTerminator| 있으면 해당 토큰 뒤에 세미콜론 삽입.</li>
          <li>화살표 함수 매개변수 끝과 `=>` 사이에 |LineTerminator| 있으면 세미콜론 삽입 후 구문 오류.</li>
          <li>`async` 뒤 `function` / 식별자 / `(` 전에 |LineTerminator| 있으면 세미콜론 삽입, 이후 토큰과 같은 구성요소로 간주되지 않음.</li>
          <li>`async` 뒤 `*` 전에 |LineTerminator| 있으면 세미콜론 삽입 후 구문 오류.</li>
        </ul>
        <p>프로그래머를 위한 요약:</p>
        <ul>
          <li>후위 `++` / `--` 는 피연산자와 같은 줄에 둔다.</li>
          <li>`return`, `throw`, `yield` 뒤 표현식은 같은 줄에서 시작.</li>
          <li>`break`, `continue` 뒤 |LabelIdentifier| 는 같은 줄.</li>
          <li>화살표 함수 매개변수와 `=>` 는 같은 줄.</li>
          <li>비동기 함수/메서드 앞 `async` 는 바로 뒤 토큰과 같은 줄.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>자동 세미콜론 삽입 예(Examples of Automatic Semicolon Insertion)</h1>
      <em>본 절은 비규범적이다.</em>
      <p>다음 소스</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>는 자동 삽입 규칙이 있어도 유효한 ECMAScript 문장이 아니다. 반면:</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>역시 유효하지 않지만 자동 삽입으로 다음으로 변환된다:</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>이는 유효한 문장이다.</p>
      <p>다음 소스</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>는 유효하지 않으며 `for` 문 헤더 세미콜론은 자동 삽입되지 않으므로 변경되지 않는다.</p>
      <p>다음 소스</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>는 다음으로 변환된다:</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>`a + b` 는 |LineTerminator| 로 인해 `return` 반환 값이 아니다.</p>
      </emu-note>
      <p>다음 소스</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>는 다음으로 변환된다:</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>`++` 는 `b` 의 후위 연산자가 아니다 (줄 종결자 존재).</p>
      </emu-note>
      <p>다음 소스</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>는 유효하지 않으며 `else` 앞에 자동 삽입되지 않는다 (그 위치 삽입 시 빈 문 생성).</p>
      <p>다음 소스</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p>는 변환되지 않는다. 괄호로 시작하는 두 번째 줄은 함수 호출 인수 목록으로 해석될 수 있기 때문이다:</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>할당문이 왼쪽 괄호로 시작해야 한다면 이전 문 끝에 명시적으로 세미콜론을 쓰는 것이 좋다.</p>
    </emu-clause>

    <emu-clause id="sec-interesting-cases-of-automatic-semicolon-insertion">
      <h1>흥미로운 자동 세미콜론 삽입 사례(Interesting Cases of Automatic Semicolon Insertion)</h1>
      <em>본 절은 비규범적이다.</em>
      <p>프로그래머는 자동 세미콜론 삽입에 의존하여 매우 적은 세미콜론으로 프로그램을 작성할 수 있다. 위에서 설명했듯 세미콜론은 모든 줄바꿈마다 삽입되지 않으며 줄 종결자를 넘어 여러 토큰에 의존할 수 있다.</p>

      <p>새 구문 기능이 추가되면서 기존 자동 삽입에 의존하던 줄이 다른 방식으로 파싱될 수 있는 추가 생성물이 도입될 수 있다.</p>

      <p>이 절에서는 앞선 소스 텍스트에 따라 세미콜론이 삽입될 수도/안 될 수도 있는 위치를 ‘흥미로운’ 사례로 본다. 이하에서는 이 ECMAScript 버전의 그러한 사례들을 기술한다.</p>

      <emu-clause id="sec-asi-interesting-cases-in-statement-lists">
        <h1>문 목록에서의 흥미로운 사례(Statement Lists)</h1>
        <p>|StatementList| 에서 다수 |StatementListItem| 은 세미콜론으로 끝나며 자동 삽입으로 생략 가능하다. 그 결과 표현식이 끝나는 줄의 다음 줄이 아래 중 하나로 시작하면 끝에 세미콜론이 필요하다:</p>
        <ul>
          <li><strong>여는 괄호 (<code>(</code>)</strong>: 없으면 두 줄이 |CallExpression| 으로 결합.</li>
          <li><strong>여는 대괄호 (<code>[</code>)</strong>: 없으면 속성 접근으로 간주 (|ArrayLiteral| 또는 |ArrayAssignmentPattern| 아님).</li>
          <li><strong>템플릿 리터럴 (<code>`</code>)</strong>: 없으면 태그드 템플릿으로 해석(앞 표현식이 |MemberExpression|).</li>
          <li><strong>단항 <code>+</code> 또는 <code>-</code></strong>: 없으면 이항 연산 조합으로 해석될 수 있음.</li>
          <li><strong>정규 표현식 리터럴</strong>: 없으면 `/` 가 |MultiplicativeOperator| 로 해석될 여지.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-asi-cases-with-no-lineterminator-here">
        <h1>“[no |LineTerminator| here]” 관련 사례</h1>
        <em>본 절은 비규범적이다.</em>
        <p>ECMAScript 는 “[no |LineTerminator| here]” 를 포함하는 문법 생성물을 가진다. 이는 종종 문법에서 선택적 피연산자를 두기 위한 수단이다. 해당 위치에 |LineTerminator| 를 넣으면 선택적 피연산자가 없는 다른 생성물로 해석이 바뀐다.</p>

        <p>이 절의 나머지 부분은 본 ECMAScript 버전의 이러한 생성물 사례들을 나열한다.</p>

        <emu-clause id="sec-no-lineterminator-here-automatic-semicolon-insertion-list">
          <h1>선택적 피연산자와 “[no |LineTerminator| here]” 를 가진 생성물 목록</h1>
          <ul>
            <li>|UpdateExpression|.</li>
            <li>|ContinueStatement|.</li>
            <li>|BreakStatement|.</li>
            <li>|ReturnStatement|.</li>
            <li>|YieldExpression|.</li>
            <li>Async Function Definitions ( <emu-xref href="#sec-async-function-definitions"></emu-xref> ) 과 Function Definitions (<emu-xref href="#sec-function-definitions"></emu-xref>) 관계.</li>
          </ul>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript 언어: 표현식(Expressions)</h1>

  <emu-clause id="sec-identifiers">
    <h1>식별자(Identifiers)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IdentifierReference[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      BindingIdentifier[Yield, Await] :
        Identifier
        `yield`
        `await`

      LabelIdentifier[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      Identifier :
        IdentifierName but not ReservedWord
    </emu-grammar>

    <emu-note>
      <p>`yield` 와 `await` 는 문법상 |BindingIdentifier| 로 허용되며, 아래 정적 의미론에서 금지되어 다음과 같은 경우의 자동 세미콜론 삽입을 막는다:</p>
      <pre><code class="javascript">
        let
        await 0;
      </code></pre>
    </emu-note>

    <emu-clause id="sec-identifiers-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Early Errors)</h1>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <ul>
        <li>
          IsStrict(this production) 가 *true* 이고 |Identifier| 의 StringValue 가 *"arguments"* 또는 *"eval"* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(this production) 가 *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          구문 문법의 목표 심볼이 |Module| 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `yield`
      </emu-grammar>
      <ul>
        <li>
          이 생성물이 <sub>[Yield]</sub> 매개변수를 가지면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `await`
      </emu-grammar>
      <ul>
        <li>
          이 생성물이 <sub>[Await]</sub> 매개변수를 가지면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference[Yield, Await] : Identifier

        BindingIdentifier[Yield, Await] : Identifier

        LabelIdentifier[Yield, Await] : Identifier
      </emu-grammar>
      <ul>
        <li>
          이 생성물이 <sub>[Yield]</sub> 매개변수를 가지고 |Identifier| 의 StringValue 가 *"yield"* 이면 Syntax Error.
        </li>
        <li>
          이 생성물이 <sub>[Await]</sub> 매개변수를 가지고 |Identifier| 의 StringValue 가 *"await"* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <ul>
        <li>
          IsStrict(this phrase) 가 *true* 이고 |IdentifierName| 의 StringValue 가 *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"*, *"yield"* 중 하나이면 Syntax Error.
        </li>
        <li>
          구문 문법의 목표 심볼이 |Module| 이고 |IdentifierName| 의 StringValue 가 *"await"* 이면 Syntax Error.
        </li>
        <li>
          |IdentifierName| 의 StringValue 가 `yield`, `await` 를 제외한 어느 |ReservedWord| 의 StringValue 와 같으면 Syntax Error.
        </li>
      </ul>
      <emu-note>
        <p>|IdentifierName| 의 StringValue 는 |IdentifierName| 내 유니코드 escape 시퀀스를 정규화하므로, 그러한 escape 로 |ReservedWord| 와 동일한 코드 포인트 시퀀스를 가진 |Identifier| 를 작성할 수 없다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-stringvalue" oldids="sec-identifiers-static-semantics-stringvalue,sec-identifier-names-static-semantics-stringvalue" type="sdo">
      <h1>정적 의미론: StringValue ( ): String</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        IdentifierName ::
          IdentifierStart
          IdentifierName IdentifierPart
      </emu-grammar>
      <emu-alg>
        1. _idTextUnescaped_ 를 |IdentifierName| 의 IdentifierCodePoints 로 둔다.
        1. CodePointsToString(_idTextUnescaped_) 를 반환한다.
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <emu-alg>
        1. *"yield"* 를 반환한다.
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <emu-alg>
        1. *"await"* 를 반환한다.
      </emu-alg>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <emu-alg>
        1. |IdentifierName| 의 StringValue 를 반환한다.
      </emu-alg>
      <emu-grammar>
        PrivateIdentifier ::
          `#` IdentifierName
      </emu-grammar>
      <emu-alg>
        1. 0x0023 (NUMBER SIGN) 과 |IdentifierName| 의 StringValue 의 문자열 연결을 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleExportName : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. |StringLiteral| 의 SV 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Evaluation)</h1>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(StringValue of |Identifier|) 를 반환한다.
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(*"yield"*) 를 반환한다.
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(*"await"*) 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|IdentifierReference| 평가 결과는 항상 Reference 타입 값이다.</p>
      </emu-note>
      <emu-note>
        <p>비 strict 코드에서 키워드 `yield` 는 식별자로 사용할 수 있다. |IdentifierReference| 평가 시 `yield` 바인딩을 |Identifier| 처럼 해석한다. 조기 오류 제한이 그러한 평가가 비 strict 코드에서만 일어날 수 있게 보장한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-primary-expression">
    <h1>기본 표현식(Primary Expression)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        AsyncGeneratorExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await, ~Tagged]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>보충 문법(Supplemental Syntax)</h2>
    <p>
      다음 생성물 인스턴스를 처리할 때<br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      |CoverParenthesizedExpressionAndArrowParameterList| 의 해석은 아래 문법을 사용해 정밀화된다:
    </p>
    <emu-grammar type="definition">
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-this-keyword">
      <h1>`this` 키워드(The `this` Keyword)</h1>

      <emu-clause id="sec-this-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. ? ResolveThisBinding() 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifier-reference">
      <h1>식별자 참조(Identifier Reference)</h1>
      <p>|IdentifierReference| 는 <emu-xref href="#sec-identifiers"></emu-xref> 를 참조.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-literals">
      <h1>리터럴(Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Literal :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-literals-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>Literal : NullLiteral</emu-grammar>
        <emu-alg>
          1. *null* 을 반환한다.
        </emu-alg>
        <emu-grammar>Literal : BooleanLiteral</emu-grammar>
        <emu-alg>
          1. |BooleanLiteral| 이 토큰 `false` 이면 *false* 반환.
          1. |BooleanLiteral| 이 토큰 `true` 이면 *true* 반환.
        </emu-alg>
        <emu-grammar>Literal : NumericLiteral</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 에 정의된 |NumericLiteral| 의 NumericValue 를 반환한다.
        </emu-alg>
        <emu-grammar>Literal : StringLiteral</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-static-semantics-sv"></emu-xref> 에 정의된 |StringLiteral| 의 SV 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-initializer">
      <h1>배열 이니셜라이저(Array Initializer)</h1>
      <emu-note>
        <p>|ArrayLiteral| 은 0 개 이상 표현식(각각 배열 요소를 나타냄) 리스트를 대괄호로 둘러 배열 초기화를 기술하는 표현식이다. 요소는 리터럴일 필요가 없으며 배열 이니셜라이저가 평가될 때마다 평가된다.</p>
      </emu-note>
      <p>배열 요소는 목록의 시작·중간·끝에서 생략(elide)될 수 있다. 요소 목록에서 쉼표 앞에 |AssignmentExpression| 이 없을 때(즉, 시작의 쉼표나 또 다른 쉼표 뒤) 빠진 요소는 배열 length 에 기여하며 이후 요소의 인덱스를 증가시킨다. 생략된 요소는 정의되지 않는다. 배열 끝에서 생략된 요소는 length 에 기여하지 않는다.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]
          Elision? SpreadElement[?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-arrayaccumulation" oldids="sec-static-semantics-elisionwidth" type="sdo">
        <h1>
          런타임 의미론: ArrayAccumulation (
          _array_: an Array,
          _nextIndex_: an integer,
          ): 정상 완료 시 정수 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. _len_ 을 _nextIndex_ + 1 로 둔다.
          1. ? Set(_array_, *"length"*, 𝔽(_len_), *true*) 수행.
          1. NOTE: _len_ 이 2<sup>32</sup> - 1 을 초과하면 위 단계는 throw.
          1. _len_ 을 반환한다.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. |Elision| 의 ArrayAccumulation 을 (_array_, (_nextIndex_ + 1)) 인수로 호출한 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ElementList : Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. _initResult_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _initValue_ 를 ? GetValue(_initResult_) 로 둔다.
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_) 수행.
          1. _nextIndex_ + 1 반환.
        </emu-alg>
        <emu-grammar>ElementList : Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |SpreadElement| 의 ArrayAccumulation(_array_, _nextIndex_) 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _nextIndex_ 를 |ElementList| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. _initResult_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _initValue_ 를 ? GetValue(_initResult_) 로 둔다.
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_) 수행.
          1. _nextIndex_ + 1 반환.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. _nextIndex_ 를 |ElementList| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |SpreadElement| 의 ArrayAccumulation(_array_, _nextIndex_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>SpreadElement : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _spreadRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _spreadObj_ 를 ? GetValue(_spreadRef_) 로 둔다.
          1. _iteratorRecord_ 를 ? GetIterator(_spreadObj_, ~sync~) 로 둔다.
          1. 반복,
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이면 _nextIndex_ 반환.
            1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_) 수행.
            1. _nextIndex_ 를 _nextIndex_ + 1 로 설정.
        </emu-alg>
        <emu-note>
          <p>CreateDataPropertyOrThrow 는 표준 내장 Array 프로토타입이 [[Set]] 으로 새로운 자체 프로퍼티 생성을 막도록 수정된 경우에도 자체 프로퍼티 정의를 보장하기 위해 사용된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>ArrayLiteral : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. _array_ 를 ! ArrayCreate(0) 로 둔다.
          1. |Elision| 이 존재하면
            1. |Elision| 의 ArrayAccumulation(_array_, 0) 를 ? 로 수행.
          1. _array_ 반환.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `]`</emu-grammar>
        <emu-alg>
          1. _array_ 를 ! ArrayCreate(0) 로 둔다.
          1. |ElementList| 의 ArrayAccumulation(_array_, 0) 를 ? 로 수행.
          1. _array_ 반환.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. _array_ 를 ! ArrayCreate(0) 로 둔다.
          1. _nextIndex_ 를 |ElementList| 의 ArrayAccumulation(_array_, 0) 결과 (?) 로 둔다.
          1. |Elision| 이 존재하면
            1. |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 를 ? 로 수행.
          1. _array_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>객체 이니셜라이저(Object Initializer)</h1>
      <emu-note>
        <p>객체 이니셜라이저는 리터럴과 유사한 형태로 객체 초기화를 기술하는 표현식이다. 중괄호로 둘러싸인 0 개 이상 (프로퍼티 키, 값) 쌍 목록이며 값은 리터럴일 필요가 없고 이니셜라이저 평가 시마다 평가된다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| 은 <emu-xref href="#sec-method-definitions"></emu-xref> 에 정의되어 있다.</p>
      </emu-note>
      <emu-note>
        <p>특정 문맥에서 |ObjectLiteral| 은 더 제한된 2차 문법을 덮는 cover 문법으로 사용된다. |CoverInitializedName| 생성물은 이러한 2차 문법을 완전히 덮기 위해 필요하다. 그러나 이 생성물 사용은 실제 |ObjectLiteral| 이 기대되는 일반 문맥에서 조기 Syntax Error 를 발생시킨다.</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors" oldids="sec-__proto__-property-names-in-object-initializers">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            HasDirectSuper(|MethodDefinition|) 가 *true* 이면 Syntax Error.
          </li>
          <li>
            |MethodDefinition| 의 PrivateBoundIdentifiers 가 비어있지 않으면 Syntax Error.
          </li>
        </ul>
        <p>실제 객체 이니셜라이저를 기술하는 것 외에도 |ObjectLiteral| 생성물은 |ObjectAssignmentPattern| 의 cover 문법으로 사용될 수 있으며 |CoverParenthesizedExpressionAndArrowParameterList| 의 일부로 인식될 수 있다. |ObjectLiteral| 이 |ObjectAssignmentPattern| 이 필요한 문맥에 나타나면 아래 Early Error 규칙은 적용되지 <b>않는다</b>. 또한 초기 |CoverParenthesizedExpressionAndArrowParameterList| 또는 |CoverCallExpressionAndAsyncArrowHead| 파싱 시에도 적용되지 않는다.</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            이 생성물이 어떤 소스 텍스트를 매칭하면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p>이 생성물은 |ObjectLiteral| 이 |ObjectAssignmentPattern| 의 cover 문법이 되도록 존재한다. 실제 객체 이니셜라이저에는 나타날 수 없다.</p>
        </emu-note>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <ul>
          <li>
            |PropertyDefinitionList| 의 PropertyNameList 가 *"__proto__"* 에 대한 중복 항목을 포함하고 그 중 둘 이상이 <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar> 형태 생성물에서 얻어진 경우 Syntax Error. 이 규칙은 이 |ObjectLiteral| 이 ParseJSON 용으로 파싱 중인 |Script| 에 포함된 경우 (ParseJSON 의 단계 <emu-xref href="#step-json-parse-parse"></emu-xref> 참조) 적용되지 않는다.
          </li>
        </ul>
        <emu-note>
          <p>PropertyNameList 가 반환한 List 는 |ComputedPropertyName| 으로 정의된 프로퍼티 이름을 포함하지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-iscomputedpropertykey" type="sdo">
        <h1>정적 의미론: IsComputedPropertyKey ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-propertynamelist" type="sdo">
        <h1>정적 의미론: PropertyNameList ( ): String 들의 List</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinition</emu-grammar>
        <emu-alg>
          1. _propName_ 을 |PropertyDefinition| 의 PropName 으로 둔다.
          1. _propName_ 이 ~empty~ 이면 새 빈 List 반환.
          1. « _propName_ » 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. _list_ 를 |PropertyDefinitionList| 의 PropertyNameList 로 둔다.
          1. _propName_ 을 |PropertyDefinition| 의 PropName 으로 둔다.
          1. _propName_ 이 ~empty~ 이면 _list_ 반환.
          1. _list_ 와 « _propName_ » 의 리스트 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>ObjectLiteral : `{` `}`</emu-grammar>
        <emu-alg>
          1. OrdinaryObjectCreate(%Object.prototype%) 반환.
        </emu-alg>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. |PropertyDefinitionList| 의 PropertyDefinitionEvaluation(_obj_) 를 ? 로 수행.
          1. _obj_ 반환.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. |IdentifierName| 의 StringValue 반환.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. |StringLiteral| 의 SV 반환.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. _nbr_ 을 |NumericLiteral| 의 NumericValue 로 둔다.
          1. ! ToString(_nbr_) 반환.
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. _exprValue_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _propName_ 을 ? GetValue(_exprValue_) 로 둔다.
          1. ? ToPropertyKey(_propName_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydefinitionevaluation" oldids="sec-object-initializer-runtime-semantics-propertydefinitionevaluation" type="sdo">
        <h1>
          런타임 의미론: PropertyDefinitionEvaluation (
          _object_: an Object,
          ): ~unused~ 를 담는 정상 완료 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. |PropertyDefinitionList| 의 PropertyDefinitionEvaluation(_object_) 를 ? 로 수행.
          1. |PropertyDefinition| 의 PropertyDefinitionEvaluation(_object_) 를 ? 로 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _exprValue_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _fromValue_ 를 ? GetValue(_exprValue_) 로 둔다.
          1. _excludedNames_ 를 새 빈 List 로 둔다.
          1. ? CopyDataProperties(_object_, _fromValue_, _excludedNames_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. _propName_ 을 |IdentifierReference| 의 StringValue 로 둔다.
          1. _exprValue_ 를 |IdentifierReference| Evaluation 결과 (?) 로 둔다.
          1. _propValue_ 를 ? GetValue(_exprValue_) 로 둔다.
          1. 단언: _object_ 는 비구성 불가능한 프로퍼티가 없는 보통의(extensible) 객체.
          1. ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _propKey_ 를 |PropertyName| Evaluation 결과 (?) 로 둔다.
          1. 이 |PropertyDefinition| 이 ParseJSON 평가 중인 |Script| 에 포함 (ParseJSON 단계 <emu-xref href="#step-json-parse-eval"></emu-xref>) 이면
            1. _isProtoSetter_ 를 *false* 로 둔다.
          1. Else if _propKey_ 가 *"__proto__"* 이고 |PropertyName| 의 IsComputedPropertyKey 가 *false* 이면
            1. _isProtoSetter_ 를 *true* 로 둔다.
          1. Else,
            1. _isProtoSetter_ 를 *false* 로 둔다.
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 _isProtoSetter_ 가 *false* 이면
            1. _propValue_ 를 |AssignmentExpression| 의 NamedEvaluation(_propKey_) 결과 (?) 로 둔다.
          1. Else,
            1. _exprValueRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
            1. _propValue_ 를 ? GetValue(_exprValueRef_) 로 둔다.
          1. _isProtoSetter_ 가 *true* 이면
            1. _propValue_ 가 Object 이거나 *null* 이면
              1. ! <emu-meta effects="user-code">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_) 수행.
            1. ~unused~ 반환.
          1. 단언: _object_ 는 비구성 불가능한 프로퍼티가 없는 보통의 확장 가능한 객체.
          1. ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <emu-alg>
          1. |MethodDefinition| 의 MethodDefinitionEvaluation(_object_, *true*) 를 ? 로 수행.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-defining-expressions">
      <h1>함수 정의 표현식(Function Defining Expressions)</h1>
      <p><emu-grammar>PrimaryExpression : FunctionExpression</emu-grammar> 은 <emu-xref href="#sec-function-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : GeneratorExpression</emu-grammar> 은 <emu-xref href="#sec-generator-function-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : ClassExpression</emu-grammar> 은 <emu-xref href="#sec-class-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : AsyncFunctionExpression</emu-grammar> 은 <emu-xref href="#sec-async-function-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : AsyncGeneratorExpression</emu-grammar> 은 <emu-xref href="#sec-async-generator-function-definitions"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>정규 표현식 리터럴(Regular Expression Literals)</h1>
      <h2>Syntax</h2>
      <p><emu-xref href="#sec-literals-regular-expression-literals"></emu-xref> 참조.</p>

      <emu-clause id="sec-primary-expression-regular-expression-literals-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <ul>
          <li>
            IsValidRegularExpressionLiteral(|RegularExpressionLiteral|) 이 *false* 이면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-isvalidregularexpressionliteral" type="abstract operation">
        <h1>
          정적 의미론: IsValidRegularExpressionLiteral (
          _literal_: a |RegularExpressionLiteral| Parse Node,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>인수가 유효한 정규 표현식 리터럴인지 판정한다.</dd>
        </dl>
        <emu-alg>
          1. _flags_ 를 _literal_ 의 FlagText 로 둔다.
          1. _flags_ 가 `d`, `g`, `i`, `m`, `s`, `u`, `v`, `y` 이외 코드 포인트를 포함하거나 동일 코드 포인트를 중복 포함하면 *false* 반환.
          1. _flags_ 가 `u` 포함하면 _u_ = *true*, 아니면 *false*.
          1. _flags_ 가 `v` 포함하면 _v_ = *true*, 아니면 *false*.
          1. _patternText_ 를 _literal_ 의 BodyText 로 둔다.
          1. _u_ 가 *false* 이고 _v_ 가 *false* 이면
            1. _stringValue_ 를 CodePointsToString(_patternText_) 로 둔다.
            1. _stringValue_ 의 16비트 요소 각각을 유니코드 BMP 코드 포인트로 해석한 코드 포인트 시퀀스로 _patternText_ 재설정 (UTF-16 디코딩 미적용).
          1. _parseResult_ 를 ParsePattern(_patternText_, _u_, _v_) 로 둔다.
          1. _parseResult_ 가 Parse Node 이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regular-expression-literals-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <emu-alg>
          1. _pattern_ 을 CodePointsToString(BodyText of |RegularExpressionLiteral|) 로 둔다.
          1. _flags_ 를 CodePointsToString(FlagText of |RegularExpressionLiteral|) 로 둔다.
          1. ! RegExpCreate(_pattern_, _flags_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literals">
      <h1>템플릿 리터럴(Template Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        TemplateLiteral[Yield, Await, Tagged] :
          NoSubstitutionTemplate
          SubstitutionTemplate[?Yield, ?Await, ?Tagged]

        SubstitutionTemplate[Yield, Await, Tagged] :
          TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

        TemplateSpans[Yield, Await, Tagged] :
          TemplateTail
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

        TemplateMiddleList[Yield, Await, Tagged] :
          TemplateMiddle Expression[+In, ?Yield, ?Await]
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-template-early-errors" oldids="sec-primary-expression-template-literals-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 매개변수가 설정되지 않았고 |NoSubstitutionTemplate| 가 |NotEscapeSequence| 를 포함하면 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            인수 *false* 로 한 |TemplateLiteral| 의 TemplateStrings 요소 수가 2<sup>32</sup> 이상이면 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 매개변수가 설정되지 않았고 |TemplateHead| 가 |NotEscapeSequence| 포함 시 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          TemplateSpans[Yield, Await, Tagged] : TemplateTail
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 미설정이고 |TemplateTail| 이 |NotEscapeSequence| 포함 시 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          TemplateMiddleList[Yield, Await, Tagged] :
            TemplateMiddle Expression[+In, ?Yield, ?Await]
            TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 미설정이고 |TemplateMiddle| 이 |NotEscapeSequence| 포함 시 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-templatestrings" type="sdo">
        <h1>
          정적 의미론: TemplateStrings (
          _raw_: Boolean,
          ): String 또는 *undefined* 요소들의 List
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. « TemplateString(|NoSubstitutionTemplate|, _raw_) » 반환.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _head_ 를 « TemplateString(|TemplateHead|, _raw_) » 로 둔다.
          1. _tail_ 을 |TemplateSpans| 의 TemplateStrings(_raw_) 로 둔다.
          1. _head_ 와 _tail_ 의 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. « TemplateString(|TemplateTail|, _raw_) » 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. _middle_ 을 |TemplateMiddleList| 의 TemplateStrings(_raw_) 로 둔다.
          1. _tail_ 을 « TemplateString(|TemplateTail|, _raw_) » 로 둔다.
          1. 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. « TemplateString(|TemplateMiddle|, _raw_) » 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _front_ 을 |TemplateMiddleList| 의 TemplateStrings(_raw_) 로 둔다.
          1. _last_ 를 « TemplateString(|TemplateMiddle|, _raw_) » 로 둔다.
          1. _front_ 와 _last_ 리스트 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-templatestring" type="abstract operation">
        <h1>
          정적 의미론: TemplateString (
          _templateToken_: |NoSubstitutionTemplate| / |TemplateHead| / |TemplateMiddle| / |TemplateTail| Parse Node,
          _raw_: Boolean,
          ): String 또는 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _raw_ 가 *true* 이면
            1. _string_ 을 _templateToken_ 의 TRV 로 둔다.
          1. Else
            1. _string_ 을 _templateToken_ 의 TV 로 둔다.
          1. _string_ 반환.
        </emu-alg>
        <emu-note>
          <p>_raw_ 가 *false* 이고 _templateToken_ 이 |NotEscapeSequence| 포함 시 *undefined* 반환. 그 외에는 String 반환.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-gettemplateobject" type="abstract operation">
        <h1>
          GetTemplateObject (
            _templateLiteral_: Parse Node,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _realm_ 을 현재 Realm Record 로 둔다.
          1. _templateRegistry_ 를 _realm_.[[TemplateMap]] 로 둔다.
          1. _templateRegistry_ 의 각 요소 _e_ 에 대해
            1. _e_.[[Site]] 가 _templateLiteral_ 과 같은 Parse Node 이면
              1. _e_.[[Array]] 반환.
          1. _rawStrings_ 를 _templateLiteral_ 의 TemplateStrings(*true*) 로 둔다.
          1. 단언: _rawStrings_ 는 String 들의 List.
          1. _cookedStrings_ 를 _templateLiteral_ 의 TemplateStrings(*false*) 로 둔다.
          1. _count_ 를 _cookedStrings_ 요소 수로 둔다.
          1. 단언: _count_ ≤ 2<sup>32</sup> - 1.
          1. _template_ 를 ! ArrayCreate(_count_) 로 둔다.
          1. _rawObj_ 를 ! ArrayCreate(_count_) 로 둔다.
          1. _index_ 를 0 으로 둔다.
          1. _index_ &lt; _count_ 동안 반복,
            1. _prop_ 를 ! ToString(𝔽(_index_)) 로 둔다.
            1. _cookedValue_ 를 _cookedStrings_[_index_] 로 둔다.
            1. ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }) 수행.
            1. _rawValue_ 를 _rawStrings_[_index_] 의 String 값으로 둔다.
            1. ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }) 수행.
            1. _index_ 를 _index_ + 1 로 설정.
          1. ! SetIntegrityLevel(_rawObj_, ~frozen~) 수행.
          1. ! DefinePropertyOrThrow(_template_, *"raw"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. ! SetIntegrityLevel(_template_, ~frozen~) 수행.
          1. Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } 를 _realm_.[[TemplateMap]] 에 추가.
          1. _template_ 반환.
        </emu-alg>
        <emu-note>
          <p>템플릿 객체 생성은 abrupt completion 을 일으킬 수 없다.</p>
        </emu-note>
        <emu-note>
          <p>한 realm 의 프로그램 코드 내 각 |TemplateLiteral| 은 태그드 템플릿 (<emu-xref href="#sec-template-literals-runtime-semantics-evaluation"></emu-xref>) 평가에 사용되는 고유한 템플릿 객체와 연관된다. 템플릿 객체는 freeze 되고 동일 템플릿이 평가될 때마다 같은 객체가 재사용된다. 지연 생성 또는 사전 생성 여부는 구현 선택이며 관측 불가.</p>
        </emu-note>
        <emu-note>
          <p>향후 판에서 템플릿 객체의 비열거(non-enumerable) 프로퍼티가 추가로 정의될 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-substitutionevaluation" type="sdo">
        <h1>런타임 의미론: SubstitutionEvaluation ( ): ECMAScript 값 List 를 담는 정상 완료 또는 abrupt completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. 새 빈 List 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. |TemplateMiddleList| 의 SubstitutionEvaluation 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. « _sub_ » 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _preceding_ 을 |TemplateMiddleList| 의 SubstitutionEvaluation 결과 (?) 로 둔다.
          1. _nextRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _next_ 를 ? GetValue(_nextRef_) 로 둔다.
          1. _preceding_ 과 « _next_ » 리스트 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |NoSubstitutionTemplate| 의 TV 반환.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _head_ 를 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateHead| 의 TV 로 둔다.
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. _middle_ 를 ? ToString(_sub_) 로 둔다.
          1. _tail_ 을 |TemplateSpans| Evaluation 결과 (?) 로 둔다.
          1. _head_, _middle_, _tail_ 의 문자열 연결 반환.
        </emu-alg>
        <emu-note>
          <p>|Expression| 값에 적용되는 문자열 변환 의미론은 `+` 연산자보다 `String.prototype.concat` 과 유사하다.</p>
        </emu-note>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateTail| 의 TV 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. _head_ 를 |TemplateMiddleList| Evaluation 결과 (?) 로 둔다.
          1. _tail_ 을 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateTail| 의 TV 로 둔다.
          1. _head_ 와 _tail_ 문자열 연결 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _head_ 를 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateMiddle| 의 TV 로 둔다.
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. _middle_ 를 ? ToString(_sub_) 로 둔다.
          1. _head_ 와 _middle_ 문자열 연결 반환.
        </emu-alg>
        <emu-note>
          <p>|Expression| 값의 문자열 변환은 `String.prototype.concat` 과 유사.</p>
        </emu-note>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _rest_ 를 |TemplateMiddleList| Evaluation 결과 (?) 로 둔다.
          1. _middle_ 을 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateMiddle| 의 TV 로 둔다.
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. _last_ 를 ? ToString(_sub_) 로 둔다.
          1. _rest_, _middle_, _last_ 문자열 연결 반환.
        </emu-alg>
        <emu-note>
          <p>|Expression| 값의 문자열 변환은 `String.prototype.concat` 과 유사.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-grouping-operator">
      <h1>그룹 연산자(The Grouping Operator)</h1>

      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            |CoverParenthesizedExpressionAndArrowParameterList| 는 |ParenthesizedExpression| 을 커버해야 한다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ParenthesizedExpression| 으로 둔다.
          1. _expr_ 의 Evaluation 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. |Expression| 의 Evaluation 결과를 ? 로 반환. 이는 Reference 일 수 있다.
        </emu-alg>
        <emu-note>
          <p>이 알고리즘은 |Expression| 평가에 GetValue 를 적용하지 않는다. 이는 `delete`, `typeof` 같은 연산자가 괄호 친 표현식에 적용될 수 있도록 하는 주된 동기다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>좌변 표현식(Left-Hand-Side Expressions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget
        ImportMeta

      NewTarget :
        `new` `.` `target`

      ImportMeta :
        `import` `.` `meta`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      OptionalExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

      OptionalChain[Yield, Await] :
        `?.` Arguments[?Yield, ?Await]
        `?.` `[` Expression[+In, ?Yield, ?Await] `]`
        `?.` IdentifierName
        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]
        `?.` PrivateIdentifier
        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        OptionalChain[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        OptionalChain[?Yield, ?Await] `.` IdentifierName
        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        OptionalChain[?Yield, ?Await] `.` PrivateIdentifier

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>보충 문법(Supplemental Syntax)</h2>
    <p>
      다음 생성물 인스턴스를 처리할 때<br>
      <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar><br>
      |CoverCallExpressionAndAsyncArrowHead| 의 해석은 아래 문법을 사용해 정밀화된다:
    </p>
    <emu-grammar type="definition">
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics">
      <h1>정적 의미론(Static Semantics)</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          OptionalChain :
            `?.` TemplateLiteral
            OptionalChain TemplateLiteral
        </emu-grammar>
        <ul>
          <li>
            이 생성물이 어떤 소스 텍스트와 매칭되면 Syntax Error이다.
          </li>
        </ul>
        <emu-note>
          <p>이 생성물은 아래 코드에 대해 자동 세미콜론 삽입 규칙(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)이 적용되어 두 개의 유효한 문장으로 해석되는 것을 방지하기 위해 존재한다:</p>
          <pre><code class="javascript">
            a?.b
            `c`
          </code></pre>
          <p>이는 선택적 체이닝이 없는 유사 코드와의 일관성을 유지하려는 목적이다:</p>
          <pre><code class="javascript">
            a.b
            `c`
          </code></pre>
          <p>위 코드는 유효한 문장이며 자동 세미콜론 삽입이 적용되지 않는다.</p>
        </emu-note>

        <emu-grammar>
          ImportMeta :
            `import` `.` `meta`
        </emu-grammar>
        <ul>
          <li>
            구문 목표 심볼이 |Module| 이 아니면 Syntax Error이다.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-accessors">
      <h1>프로퍼티 접근자(Property Accessors)</h1>
      <emu-note>
        <p>프로퍼티는 이름으로 접근하며, 점 표기법(dot notation)을 사용할 수 있다:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|<br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>또는 대괄호 표기법(bracket notation)을 사용할 수 있다:</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`<br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>점 표기법은 다음 구문 변환으로 설명된다:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>는 동작상 다음과 동일하다:</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>비슷하게</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>도 동작상 다음과 동일하다:</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>여기서 &lt;<i>identifier-name-string</i>> 는 |IdentifierName| 의 StringValue 이다.</p>
      </emu-note>

      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |MemberExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |MemberExpression|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |MemberExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |MemberExpression|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |MemberExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_baseValue_, _fieldNameString_) 를 반환한다.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |CallExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |CallExpression|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |CallExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |CallExpression|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |CallExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_baseValue_, _fieldNameString_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-expression-key" type="abstract operation" oldids="sec-evaluate-expression-key-property-access">
      <h1>
        EvaluatePropertyAccessWithExpressionKey (
          _baseValue_: an ECMAScript language value,
          _expression_: an |Expression| Parse Node,
          _strict_: a Boolean,
        ): 정상 완료 시 Reference Record 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _propertyNameReference_ 를 _expression_ 의 Evaluation 결과 (?) 로 둔다.
        1. _propertyNameValue_ 를 ? GetValue(_propertyNameReference_) 로 둔다.
        1. NOTE: 대부분 경우 이 단계 직후 _propertyNameValue_ 에 대해 ToPropertyKey 가 수행된다. 그러나 `a[b] = c` 의 경우 `c` 평가 이후에 수행된다.
        1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameValue_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-identifier-key" type="abstract operation" oldids="sec-evaluate-identifier-key-property-access">
      <h1>
        EvaluatePropertyAccessWithIdentifierKey (
          _baseValue_: an ECMAScript language value,
          _identifierName_: an |IdentifierName| Parse Node,
          _strict_: a Boolean,
        ): Reference Record
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _propertyNameString_ 을 _identifierName_ 의 StringValue 로 둔다.
        1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-new-operator">
      <h1>`new` 연산자(The `new` Operator)</h1>

      <emu-clause id="sec-new-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateNew(|NewExpression|, ~empty~) 를 반환한다.
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. ? EvaluateNew(|MemberExpression|, |Arguments|) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-evaluatenew" type="abstract operation">
          <h1>
            EvaluateNew (
              _constructExpr_: a |NewExpression| Parse Node or a |MemberExpression| Parse Node,
              _arguments_: ~empty~ or an |Arguments| Parse Node,
            ): 정상 완료 시 ECMAScript 언어 값 또는 abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _ref_ 를 _constructExpr_ 의 Evaluation 결과 (?) 로 둔다.
            1. _constructor_ 를 ? GetValue(_ref_) 로 둔다.
            1. _arguments_ 가 ~empty~ 이면
              1. _argList_ 를 새 빈 List 로 둔다.
            1. Else,
              1. _argList_ 를 ? ArgumentListEvaluation(_arguments_) 로 둔다.
            1. IsConstructor(_constructor_) 가 *false* 이면 *TypeError* 예외를 throw.
            1. ? Construct(_constructor_, _argList_) 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-calls">
      <h1>함수 호출(Function Calls)</h1>

      <emu-clause id="sec-function-calls-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. _expr_ 을 |CoverCallExpressionAndAsyncArrowHead| 가 커버하는 |CallMemberExpression| 으로 둔다.
          1. _memberExpr_ 을 _expr_ 의 |MemberExpression| 으로 둔다.
          1. _arguments_ 를 _expr_ 의 |Arguments| 로 둔다.
          1. _ref_ 를 ? Evaluation(_memberExpr_) 로 둔다.
          1. _func_ 을 ? GetValue(_ref_) 로 둔다.
          1. _ref_ 가 Reference Record 이고 IsPropertyReference(_ref_) 가 *false* 이며 _ref_.[[ReferencedName]] 가 *"eval"* 이면
            1. SameValue(_func_, %eval%) 이 *true* 이면
              1. _argList_ 를 ? ArgumentListEvaluation(_arguments_) 로 둔다.
              1. _argList_ 에 요소가 없으면 *undefined* 반환.
              1. _evalArg_ 를 _argList_ 의 첫 요소로 둔다.
              1. IsStrict(this |CallExpression|) 이 *true* 이면 _strictCaller_ = *true*, 아니면 *false*.
              1. [id="step-callexpression-evaluation-direct-eval"] ? PerformEval(_evalArg_, _strictCaller_, *true*) 를 반환한다.
          1. _thisCall_ 을 this |CallExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_) 를 반환한다.
        </emu-alg>
        <p>단계 <emu-xref href="#step-callexpression-evaluation-direct-eval"></emu-xref> 를 수행한 |CallExpression| 평가는 <dfn variants="direct evals">직접 eval(direct eval)</dfn> 이다.</p>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. _ref_ 를 ? Evaluation(|CallExpression|) 로 둔다.
          1. _func_ 를 ? GetValue(_ref_) 로 둔다.
          1. _thisCall_ 을 this |CallExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluatecall" type="abstract operation" oldids="sec-evaluatedirectcall">
        <h1>
          EvaluateCall (
            _func_: an ECMAScript language value,
            _ref_: an ECMAScript language value or a Reference Record,
            _arguments_: a Parse Node,
            _tailPosition_: a Boolean,
          ): 정상 완료 시 ECMAScript 언어 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _ref_ 가 Reference Record 이면
            1. IsPropertyReference(_ref_) 가 *true* 이면
              1. _thisValue_ 를 GetThisValue(_ref_) 로 둔다.
            1. Else,
              1. _refEnv_ 를 _ref_.[[Base]] 로 둔다.
              1. 단언: _refEnv_ 는 Environment Record.
              1. _thisValue_ 를 _refEnv_.WithBaseObject() 로 둔다.
          1. Else,
            1. _thisValue_ 를 *undefined* 로 둔다.
          1. _argList_ 를 ? ArgumentListEvaluation(_arguments_) 로 둔다.
          1. _func_ 가 Object 가 아니면 *TypeError* 예외 throw.
          1. IsCallable(_func_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _tailPosition_ 이 *true* 이면 PrepareForTailCall() 수행.
          1. ? Call(_func_, _thisValue_, _argList_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-super-keyword">
      <h1>`super` 키워드(The `super` Keyword)</h1>

      <emu-clause id="sec-super-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>SuperProperty : `super` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _env_ 를 GetThisEnvironment() 로 둔다.
          1. _actualThis_ 를 ? _env_.GetThisBinding() 로 둔다.
          1. _propertyNameReference_ 를 ? Evaluation(|Expression|) 로 둔다.
          1. _propertyNameValue_ 를 ? GetValue(_propertyNameReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |SuperProperty|) 로 둔다.
          1. NOTE: 대부분 경우 이 단계 직후 _propertyNameValue_ 에 대해 ToPropertyKey 가 수행된다. 하지만 `super[b] = c` 의 경우 `c` 평가 이후 수행된다.
          1. MakeSuperPropertyReference(_actualThis_, _propertyNameValue_, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _env_ 를 GetThisEnvironment() 로 둔다.
          1. _actualThis_ 를 ? _env_.GetThisBinding() 로 둔다.
          1. _propertyKey_ 를 |IdentifierName| 의 StringValue 로 둔다.
          1. _strict_ 를 IsStrict(this |SuperProperty|) 로 둔다.
          1. MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. _newTarget_ 을 GetNewTarget() 로 둔다.
          1. 단언: _newTarget_ 은 constructor.
          1. _func_ 을 GetSuperConstructor() 로 둔다.
          1. _argList_ 를 ? ArgumentListEvaluation(|Arguments|) 로 둔다.
          1. IsConstructor(_func_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _result_ 를 ? Construct(_func_, _argList_, _newTarget_) 로 둔다.
          1. _thisER_ 를 GetThisEnvironment() 로 둔다.
          1. 단언: _thisER_ 는 Function Environment Record.
          1. ? BindThisValue(_thisER_, _result_) 수행.
          1. _F_ 를 _thisER_.[[FunctionObject]] 로 둔다.
          1. 단언: _F_ 는 ECMAScript 함수 객체.
          1. ? InitializeInstanceElements(_result_, _F_) 수행.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getsuperconstructor" type="abstract operation">
        <h1>GetSuperConstructor ( ): ECMAScript 언어 값</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _envRec_ 를 GetThisEnvironment() 로 둔다.
          1. 단언: _envRec_ 는 Function Environment Record.
          1. _activeFunction_ 을 _envRec_.[[FunctionObject]] 로 둔다.
          1. 단언: _activeFunction_ 은 ECMAScript 함수 객체.
          1. _superConstructor_ 를 ! _activeFunction_.[[GetPrototypeOf]]() 로 둔다.
          1. _superConstructor_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makesuperpropertyreference" type="abstract operation">
        <h1>
          MakeSuperPropertyReference (
            _actualThis_: an ECMAScript language value,
            _propertyKey_: an ECMAScript language value,
            _strict_: a Boolean,
          ): Super Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _env_ 를 GetThisEnvironment() 로 둔다.
          1. 단언: _env_.HasSuperBinding() 은 *true*.
          1. 단언: _env_ 는 Function Environment Record.
          1. _baseValue_ 를 GetSuperBase(_env_) 로 둔다.
          1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ } 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-argument-lists">
      <h1>인자 목록(Argument Lists)</h1>
      <emu-note>
        <p>인자 목록의 평가 결과는 값들의 List 를 생성한다.</p>
      </emu-note>

      <emu-clause id="sec-runtime-semantics-argumentlistevaluation" oldids="sec-template-literals-runtime-semantics-argumentlistevaluation,sec-argument-lists-runtime-semantics-argumentlistevaluation" type="sdo">
        <h1>런타임 의미론: ArgumentListEvaluation ( ): 정상 완료 시 ECMAScript 언어 값들의 List 또는 abrupt completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Arguments : `(` `)`</emu-grammar>
        <emu-alg>
          1. 새 빈 List 반환.
        </emu-alg>
        <emu-grammar>ArgumentList : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _ref_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _arg_ 를 ? GetValue(_ref_) 로 둔다.
          1. « _arg_ » 반환.
        </emu-alg>
        <emu-grammar>ArgumentList : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _list_ 를 새 빈 List 로 둔다.
          1. _spreadRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _spreadObj_ 를 ? GetValue(_spreadRef_) 로 둔다.
          1. _iteratorRecord_ 를 ? GetIterator(_spreadObj_, ~sync~) 로 둔다.
          1. 반복,
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이면 _list_ 반환.
            1. _list_ 에 _next_ 추가.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _precedingArgs_ 를 ? ArgumentListEvaluation(|ArgumentList|) 로 둔다.
          1. _ref_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _arg_ 를 ? GetValue(_ref_) 로 둔다.
          1. _precedingArgs_ 와 « _arg_ » 의 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _precedingArgs_ 를 ? ArgumentListEvaluation(|ArgumentList|) 로 둔다.
          1. _spreadRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _iteratorRecord_ 를 ? GetIterator(? GetValue(_spreadRef_), ~sync~) 로 둔다.
          1. 반복,
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이면 _precedingArgs_ 반환.
            1. _precedingArgs_ 에 _next_ 추가.
        </emu-alg>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. _templateLiteral_ 을 this |TemplateLiteral| 로 둔다.
          1. _siteObj_ 를 GetTemplateObject(_templateLiteral_) 로 둔다.
          1. « _siteObj_ » 반환.
        </emu-alg>
        <emu-grammar>TemplateLiteral : SubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. _templateLiteral_ 을 this |TemplateLiteral| 로 둔다.
          1. _siteObj_ 를 GetTemplateObject(_templateLiteral_) 로 둔다.
          1. _remaining_ 을 ? ArgumentListEvaluation(|SubstitutionTemplate|) 로 둔다.
          1. « _siteObj_ » 와 _remaining_ 의 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _firstSubRef_ 를 ? Evaluation(|Expression|) 로 둔다.
          1. _firstSub_ 를 ? GetValue(_firstSubRef_) 로 둔다.
          1. _restSub_ 를 ? SubstitutionEvaluation(|TemplateSpans|) 로 둔다.
          1. 단언: _restSub_ 는 (비어있을 수도 있는) List.
          1. « _firstSub_ » 와 _restSub_ 의 리스트 연결 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-optional-chains">
      <h1>옵셔널 체인(Optional Chains)</h1>
      <emu-note>옵셔널 체인은 하나 이상의 프로퍼티 접근과 함수 호출이 연속된 것으로, 첫 부분이 `?.` 토큰으로 시작한다.</emu-note>

      <emu-clause id="sec-optional-chaining-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>
          OptionalExpression :
            MemberExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 ? Evaluation(|MemberExpression|) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _baseValue_ 가 *undefined* 또는 *null* 이면
            1. *undefined* 반환.
          1. ? ChainEvaluation(|OptionalChain|, 인수 _baseValue_, _baseReference_) 를 반환.
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            CallExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 ? Evaluation(|CallExpression|) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _baseValue_ 가 *undefined* 또는 *null* 이면
            1. *undefined* 반환.
          1. ? ChainEvaluation(|OptionalChain|, 인수 _baseValue_, _baseReference_) 반환.
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            OptionalExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 ? Evaluation(|OptionalExpression|) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _baseValue_ 가 *undefined* 또는 *null* 이면
            1. *undefined* 반환.
          1. ? ChainEvaluation(|OptionalChain|, 인수 _baseValue_, _baseReference_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-optional-chaining-chain-evaluation" type="sdo">
        <h1>
          런타임 의미론: ChainEvaluation (
          _baseValue_: an ECMAScript language value,
          _baseReference_: an ECMAScript language value or a Reference Record,
          ): 정상 완료 시 ECMAScript 언어 값 또는 Reference Record, 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>
        <emu-alg>
          1. _thisChain_ 을 this |OptionalChain| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisChain_) 로 둔다.
          1. ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_baseValue_, _fieldNameString_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _thisChain_ 을 this |OptionalChain| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisChain_) 로 둔다.
          1. ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_newValue_, _fieldNameString_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>import 호출(Import Calls)</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. ? EvaluateImportCall(|AssignmentExpression|) 반환.
        </emu-alg>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. ? EvaluateImportCall(첫 번째 |AssignmentExpression|, 두 번째 |AssignmentExpression|) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          EvaluateImportCall (
            _specifierExpression_: a Parse Node,
            optional _optionsExpression_: a Parse Node,
          ): 정상 완료 시 Promise 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _referrer_ 를 GetActiveScriptOrModule() 로 둔다.
          1. _referrer_ 가 *null* 이면 현재 Realm Record 로 설정.
          1. _specifierRef_ 를 ? Evaluation(_specifierExpression_) 로 둔다.
          1. _specifier_ 를 ? GetValue(_specifierRef_) 로 둔다.
          1. _optionsExpression_ 이 존재하면
            1. _optionsRef_ 를 ? Evaluation(_optionsExpression_) 로 둔다.
            1. _options_ 를 ? GetValue(_optionsRef_) 로 둔다.
          1. Else,
            1. _options_ = *undefined*.
          1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
          1. _specifierString_ 을 Completion(ToString(_specifier_)) 로 둔다.
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. _attributes_ 를 새 빈 List 로 둔다.
          1. _options_ 가 *undefined* 가 아니면
            1. _options_ 가 Object 가 아니면
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
              1. _promiseCapability_.[[Promise]] 반환.
            1. _attributesObj_ 를 Completion(Get(_options_, *"with"*)).
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_).
            1. _attributesObj_ 가 *undefined* 가 아니면
              1. _attributesObj_ 가 Object 가 아니면
                1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
                1. _promiseCapability_.[[Promise]] 반환.
              1. _entries_ 를 Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~)).
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_).
              1. _entries_ 의 각 _entry_ 에 대해
                1. _key_ = ! Get(_entry_, *"0"*).
                1. _value_ = ! Get(_entry_, *"1"*).
                1. _key_ 가 String 이면
                  1. _value_ 가 String 이 아니면
                    1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
                    1. _promiseCapability_.[[Promise]] 반환.
                  1. ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } 를 _attributes_ 에 추가.
            1. AllImportAttributesSupported(_attributes_) 가 *false* 이면
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
              1. _promiseCapability_.[[Promise]] 반환.
            1. _attributes_ 를 각 [[Key]] 필드의 UTF-16 코드 유닛 시퀀스 사전식 순서로 정렬. (NOTE: 정렬은 호스트가 열거 순서를 기반으로 동작을 바꾸는 것을 금지하는 방식으로만 관찰 가능)
          1. _moduleRequest_ 를 새 ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_ } 로 둔다.
          1. HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_) 수행.
          1. _promiseCapability_.[[Promise]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            _promiseCapability_: a PromiseCapability Record,
            _moduleCompletion_: Module Record 를 담는 정상 completion 또는 throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd><emu-xref href="#sec-import-calls">`import()`</emu-xref> 호출로 시작된 동적 import 과정을 마무리하여, 해당 호출이 반환한 promise 를 적절히 이행(resolve) 또는 거부(reject)한다.</dd>
        </dl>
        <emu-alg>
          1. _moduleCompletion_ 이 abrupt completion 이면
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] ») 수행.
            1. ~unused~ 반환.
          1. _module_ 을 _moduleCompletion_.[[Value]] 로 둔다.
            1. _loadPromise_ 를 _module_.LoadRequestedModules() 로 둔다.
          1. _rejectedClosure_ 를 (_reason_) 매개변수를 가지며 _promiseCapability_ 를 캡처하고 호출 시:
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ ») 수행.
            1. NormalCompletion(*undefined*) 반환.
          1. _onRejected_ 를 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « ») 로 둔다.
          1. _linkAndEvaluateClosure_ 를 매개변수 없고 _module_, _promiseCapability_, _onRejected_ 를 캡처하며 호출 시:
            1. _link_ = Completion(_module_.Link()).
            1. _link_ 가 abrupt completion 이면
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] ») 수행.
              1. NormalCompletion(*undefined*) 반환.
            1. _evaluatePromise_ 를 _module_.Evaluate() 로 둔다.
            1. _fulfilledClosure_ 를 매개변수 없고 _module_, _promiseCapability_ 캡처하며 호출 시:
              1. _namespace_ = GetModuleNamespace(_module_).
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ ») 수행.
              1. NormalCompletion(*undefined*) 반환.
            1. _onFulfilled_ = CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »).
            1. PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_) 수행.
            1. ~unused~ 반환.
          1. _linkAndEvaluate_ = CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *""*, « »).
          1. PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tagged-templates">
      <h1>태그드 템플릿(Tagged Templates)</h1>
      <emu-note>
        <p>태그드 템플릿은 호출 인자가 |TemplateLiteral| (<emu-xref href="#sec-template-literals"></emu-xref>) 로부터 파생되는 함수 호출이다. 실제 인자에는 템플릿 객체(<emu-xref href="#sec-gettemplateobject"></emu-xref>)와 |TemplateLiteral| 안에 포함된 표현식들을 평가하여 얻은 값들이 포함된다.</p>
      </emu-note>

      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. _tagRef_ 를 ? Evaluation(|MemberExpression|) 로 둔다.
          1. _tagFunc_ 를 ? GetValue(_tagRef_) 로 둔다.
          1. _thisCall_ 을 this |MemberExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_) 반환.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. _tagRef_ 를 ? Evaluation(|CallExpression|) 로 둔다.
          1. _tagFunc_ 를 ? GetValue(_tagRef_) 로 둔다.
          1. _thisCall_ 을 this |CallExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-meta-properties">
      <h1>메타 프로퍼티(Meta Properties)</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. GetNewTarget() 반환.
        </emu-alg>

        <emu-grammar>ImportMeta : `import` `.` `meta`</emu-grammar>
        <emu-alg>
          1. _module_ 을 GetActiveScriptOrModule() 로 둔다.
          1. 단언: _module_ 은 Source Text Module Record.
          1. _importMeta_ 를 _module_.[[ImportMeta]] 로 둔다.
          1. _importMeta_ 가 ~empty~ 이면
            1. _importMeta_ 를 OrdinaryObjectCreate(*null*) 로 설정.
            1. _importMetaValues_ 를 HostGetImportMetaProperties(_module_) 로 둔다.
            1. 각 Record { [[Key]], [[Value]] } _p_ 에 대해
              1. ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]) 수행.
            1. HostFinalizeImportMeta(_importMeta_, _module_) 수행.
            1. _module_.[[ImportMeta]] 에 _importMeta_ 설정.
            1. _importMeta_ 반환.
          1. Else,
            1. 단언: _importMeta_ 는 Object.
            1. _importMeta_ 반환.
        </emu-alg>

        <emu-clause id="sec-hostgetimportmetaproperties" type="host-defined abstract operation">
          <h1>
            HostGetImportMetaProperties (
              _moduleRecord_: a Module Record,
            ): [[Key]] (property key), [[Value]] (ECMAScript 언어 값) 필드를 가진 Record 들의 List
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>호스트가 `import.meta` 로부터 반환되는 객체에 대한 프로퍼티 키와 값을 제공할 수 있게 한다.</dd>
          </dl>

          <p>HostGetImportMetaProperties 의 기본 구현은 새 빈 List 를 반환한다.</p>
        </emu-clause>

        <emu-clause id="sec-hostfinalizeimportmeta" type="host-defined abstract operation">
          <h1>
            HostFinalizeImportMeta (
              _importMeta_: an Object,
              _moduleRecord_: a Module Record,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>호스트가 `import.meta` 로부터 반환되는 객체를 ECMAScript 코드에 노출하기 전에 추가 작업을 수행할 수 있게 한다.</dd>
          </dl>

          <p>대부분 호스트는 HostGetImportMetaProperties 를 정의하고 HostFinalizeImportMeta 는 기본 동작을 그대로 둘 수 있다. 그러나 HostFinalizeImportMeta 는 노출 전에 객체를 직접 조작해야 하는 호스트를 위한 “escape hatch” 를 제공한다.</p>

          <p>HostFinalizeImportMeta 의 기본 구현은 ~unused~ 를 반환한다.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-update-expressions">
    <h1>갱신 표현식(Update Expressions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
        `++` UnaryExpression[?Yield, ?Await]
        `--` UnaryExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-update-expressions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 초기(early) Syntax Error 이다.
        </li>
      </ul>

      <emu-grammar>
        UpdateExpression :
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <ul>
        <li>
          |UnaryExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 초기(early) Syntax Error 이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-postfix-increment-operator">
      <h1>후위 증가 연산자(Postfix Increment Operator)</h1>

      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_lhs_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::add(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::add(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_lhs_, _newValue_) 수행.
          1. _oldValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-postfix-decrement-operator">
      <h1>후위 감소 연산자(Postfix Decrement Operator)</h1>

      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_lhs_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::subtract(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_lhs_, _newValue_) 수행.
          1. _oldValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-increment-operator">
      <h1>전위 증가 연산자(Prefix Increment Operator)</h1>

      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |UnaryExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::add(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::add(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_expr_, _newValue_) 수행.
          1. _newValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-decrement-operator">
      <h1>전위 감소 연산자(Prefix Decrement Operator)</h1>

      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |UnaryExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::subtract(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_expr_, _newValue_) 수행.
          1. _newValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unary-operators">
    <h1>단항 연산자(Unary Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-delete-operator">
      <h1>`delete` 연산자(The `delete` Operator)</h1>

      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            IsStrict(the |UnaryExpression|) 가 *true* 이고 파생된 |UnaryExpression| 이 <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>, <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>, 또는 <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar> 이면 Syntax Error 이다.
          </li>
          <li>
            <p>
              파생된 |UnaryExpression| 이<br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar><br>
              이고 |CoverParenthesizedExpressionAndArrowParameterList| 가 궁극적으로, 그것을 |UnaryExpression| 대신 사용했을 때 이 규칙에 따라 Syntax Error 를 일으킬 구문을 도출한다면 Syntax Error 이다. 이 규칙은 재귀적으로 적용된다.
            </p>
          </li>
        </ul>
        <emu-note>
          <p>마지막 규칙은 `delete (((foo)))` 같은 표현식이 첫 번째 규칙의 재귀 적용으로 인해 조기 오류를 발생함을 의미한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _ref_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _ref_ 가 Reference Record 가 아니면 *true* 반환.
          1. IsUnresolvableReference(_ref_) 가 *true* 이면
            1. 단언: _ref_.[[Strict]] 는 *false*.
            1. *true* 반환.
          1. IsPropertyReference(_ref_) 가 *true* 이면
            1. 단언: IsPrivateReference(_ref_) 는 *false*.
            1. IsSuperReference(_ref_) 가 *true* 이면 *ReferenceError* 예외 throw.
            1. [id="step-delete-operator-toobject"] _baseObj_ 를 ? ToObject(_ref_.[[Base]]) 로 둔다.
            1. _ref_.[[ReferencedName]] 가 property key 가 아니면
              1. _ref_.[[ReferencedName]] 를 ? ToPropertyKey(_ref_.[[ReferencedName]]) 로 설정.
            1. _deleteStatus_ 를 ? <emu-meta effects="user-code">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]]) 로 둔다.
            1. _deleteStatus_ 가 *false* 이고 _ref_.[[Strict]] 가 *true* 이면 *TypeError* 예외 throw.
            1. _deleteStatus_ 반환.
          1. 그렇지 않으면
            1. _base_ 를 _ref_.[[Base]] 로 둔다.
            1. 단언: _base_ 는 Environment Record.
            1. ? <emu-meta effects="user-code">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]]) 반환.
        </emu-alg>
        <emu-note>
          <p>`delete` 연산자가 strict 모드 코드 안에 나타나고 그 |UnaryExpression| 이 변수, 함수 인자, 함수 이름에 대한 직접 참조이면 *SyntaxError* 예외가 발생한다. 또한 strict 모드 코드에서 `delete` 가 발생하고 삭제하려는 프로퍼티가 { [[Configurable]]: *false* } 속성을 가지거나(또는 삭제 불가) 하면 *TypeError* 예외가 발생한다.</p>
        </emu-note>
        <emu-note>
          <p><emu-xref href="#step-delete-operator-toobject"></emu-xref> 단계에서 생성될 수 있는 객체는 위 추상 연산 및 보통 객체 [[Delete]] 내부 메서드 외부에서는 접근할 수 없다. 구현은 실제 객체 생성을 회피할 수도 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-void-operator">
      <h1>`void` 연산자(The `void` Operator)</h1>

      <emu-clause id="sec-void-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `void` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_expr_) 수행.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>값을 사용하지 않더라도 관찰 가능한 부수효과가 있을 수 있으므로 GetValue 는 호출되어야 한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>`typeof` 연산자(The `typeof` Operator)</h1>

      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation" oldids="table-typeof-operator-results,sec-IsHTMLDDA-internal-slot-typeof" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _val_ 을 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _val_ 이 Reference Record 이면
            1. IsUnresolvableReference(_val_) 가 *true* 이면 *"undefined"* 반환.
          1. _val_ 을 ? GetValue(_val_) 로 설정.
          1. _val_ 이 *undefined* 이면 *"undefined"* 반환.
          1. _val_ 이 *null* 이면 *"object"* 반환.
          1. _val_ 이 String 이면 *"string"* 반환.
          1. _val_ 이 Symbol 이면 *"symbol"* 반환.
          1. _val_ 이 Boolean 이면 *"boolean"* 반환.
          1. _val_ 이 Number 이면 *"number"* 반환.
          1. _val_ 이 BigInt 이면 *"bigint"* 반환.
          1. 단언: _val_ 은 Object.
          1. [id="step-typeof-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref> 를 지원한다면
            1. _val_ 이 [[IsHTMLDDA]] 내부 슬롯을 가지면 *"undefined"* 반환.
          1. _val_ 이 [[Call]] 내부 메서드를 가지면 *"function"* 반환.
          1. *"object"* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-plus-operator">
      <h1>단항 `+` 연산자(Unary `+` Operator)</h1>
      <emu-note>
        <p>단항 + 연산자는 피연산자를 Number 타입으로 변환한다.</p>
      </emu-note>

      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? ToNumber(? GetValue(_expr_)) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-minus-operator">
      <h1>단항 `-` 연산자(Unary `-` Operator)</h1>
      <emu-note>
        <p>단항 `-` 연산자는 피연산자를 수치 값으로 변환한 뒤 부호를 반전한다. *+0*<sub>𝔽</sub> 을 부정하면 *-0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 을 부정하면 *+0*<sub>𝔽</sub> 이 된다.</p>
      </emu-note>

      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. Number::unaryMinus(_oldValue_) 반환.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. BigInt::unaryMinus(_oldValue_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-bitwise-not-operator">
      <h1>비트 NOT 연산자(Bitwise NOT Operator) ( `~` )</h1>

      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. Number::bitwiseNOT(_oldValue_) 반환.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. BigInt::bitwiseNOT(_oldValue_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-logical-not-operator">
      <h1>논리 NOT 연산자(Logical NOT Operator) ( `!` )</h1>

      <emu-clause id="sec-logical-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `!` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _oldValue_ 를 ToBoolean(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 *true* 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>거듭제곱 연산자(Exponentiation Operator)</h1>
    <h2>Syntax</h2>

    <emu-grammar type="definition">
      ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-multiplicative-operators">
    <h1>곱셈 연산자(Multiplicative Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MultiplicativeExpression[Yield, Await] :
        ExponentiationExpression[?Yield, ?Await]
        MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

      MultiplicativeOperator : one of
        `*` `/` `%`
    </emu-grammar>
    <emu-note>
      <ul>
        <li>`*` 연산자는 피연산자의 곱(product)을 생성하는 곱셈을 수행한다.</li>
        <li>`/` 연산자는 피연산자의 몫(quotient)을 생성하는 나눗셈을 수행한다.</li>
        <li>`%` 연산자는 암묵적 나눗셈에서 피연산자의 나머지(remainder)를 구한다.</li>
      </ul>
    </emu-note>

    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. _opText_ 를 |MultiplicativeOperator| 가 매칭한 source text 로 둔다.
        1. ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-additive-operators">
    <h1>덧셈/뺄셈 연산자(Additive Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-addition-operator-plus">
      <h1>덧셈 연산자 ( `+` ) (The Addition Operator)</h1>
      <emu-note>
        <p>덧셈 연산자는 문자열 결합 또는 수치 덧셈을 수행한다.</p>
      </emu-note>

      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-subtraction-operator-minus">
      <h1>뺄셈 연산자 ( `-` ) (The Subtraction Operator)</h1>
      <emu-note>
        <p>`-` 연산자는 피연산자의 차(difference)를 생성하는 뺄셈을 수행한다.</p>
      </emu-note>

      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bitwise-shift-operators">
    <h1>비트 시프트 연산자(Bitwise Shift Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ShiftExpression[Yield, Await] :
        AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-left-shift-operator">
      <h1>왼쪽 시프트 연산자 ( `&lt;&lt;` ) (The Left Shift Operator)</h1>
      <emu-note>
        <p>왼쪽 피연산자를 오른쪽 피연산자가 지정한 비트 수만큼 비트 왼쪽 시프트한다.</p>
      </emu-note>

      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `&lt;&lt;`, |AdditiveExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-signed-right-shift-operator">
      <h1>부호 있는 오른쪽 시프트 연산자 ( `>>` ) (The Signed Right Shift Operator)</h1>
      <emu-note>
        <p>왼쪽 피연산자를 오른쪽 피연산자가 지정한 비트 수만큼 부호 확장(bit sign-filling)하며 오른쪽 시프트한다.</p>
      </emu-note>

      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>부호 없는 오른쪽 시프트 연산자 ( `>>>` ) (The Unsigned Right Shift Operator)</h1>
      <emu-note>
        <p>왼쪽 피연산자를 오른쪽 피연산자가 지정한 비트 수만큼 0 으로 채우며 오른쪽 시프트한다.</p>
      </emu-note>

      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relational-operators">
    <h1>관계 연산자(Relational Operators)</h1>
    <emu-note>
      <p>관계 연산자 평가 결과는 항상 Boolean 타입이며, 연산자가 명명한 관계가 두 피연산자 사이에서 성립하는지를 반영한다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      RelationalExpression[In, Yield, Await] :
        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
        [+In] PrivateIdentifier `in` ShiftExpression[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p><sub>[In]</sub> 문법 매개변수는 관계 표현식에서의 `in` 연산자를 `for` 문의 `in` 연산자와 혼동하지 않도록 필요하다.</p>
    </emu-note>

    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |RelationalExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 |ShiftExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _r_ 를 ? IsLessThan(_lVal_, _rVal_, *true*) 로 둔다.
        1. _r_ 가 *undefined* 이면 *false* 반환; 그렇지 않으면 _r_ 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 위와 같이 얻는다.
        1. _r_ 를 ? IsLessThan(_rVal_, _lVal_, *false*) 로 둔다.
        1. _r_ 가 *undefined* 이면 *false* 반환; 그렇지 않으면 _r_ 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 ? IsLessThan(_rVal_, _lVal_, *false*) 로 둔다.
        1. _r_ 가 *true* 또는 *undefined* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 ? IsLessThan(_lVal_, _rVal_, *true*) 로 둔다.
        1. _r_ 가 *true* 또는 *undefined* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `instanceof` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. ? InstanceofOperator(_lVal_, _rVal_) 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _rVal_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. ? HasProperty(_rVal_, ? ToPropertyKey(_lVal_)) 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _privateIdentifier_ 를 |PrivateIdentifier| 의 StringValue 로 둔다.
        1. _rRef_ 를 |ShiftExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _rVal_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. _privateEnv_ 를 실행 중인 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. 단언: _privateEnv_ 는 *null* 이 아님.
        1. _privateName_ 을 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_) 로 둔다.
        1. PrivateElementFind(_rVal_, _privateName_) 이 ~empty~ 가 아니면 *true* 반환.
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-instanceofoperator" type="abstract operation">
      <h1>
        InstanceofOperator (
          _V_: an ECMAScript language value,
          _target_: an ECMAScript language value,
        ): Boolean 을 담는 정상 완료 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_target_ 의 %Symbol.hasInstance% 메서드를 조회하거나, 없다면 _target_ 의 *"prototype"* 프로퍼티 값이 _V_ 의 프로토타입 체인에 존재하는지 확인하여 _V_ 가 _target_ 의 인스턴스인지 결정하는 일반 알고리즘을 구현한다.</dd>
      </dl>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외 throw.
        1. _instOfHandler_ 를 ? GetMethod(_target_, %Symbol.hasInstance%) 로 둔다.
        1. _instOfHandler_ 가 *undefined* 가 아니면
          1. ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)) 반환.
        1. [id="step-instanceof-check-function"] IsCallable(_target_) 이 *false* 이면 *TypeError* 예외 throw.
        1. [id="step-instanceof-fallback"] ? OrdinaryHasInstance(_target_, _V_) 반환.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-instanceof-check-function"></emu-xref> 및 <emu-xref href="#step-instanceof-fallback"></emu-xref> 단계는 %Symbol.hasInstance% 를 사용하지 않던 이전 ECMAScript 판과의 호환성을 제공한다. 객체가 %Symbol.hasInstance% 를 정의하거나 상속하지 않으면 기본 `instanceof` 의미론을 사용한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-equality-operators">
    <h1>동등 연산자(Equality Operators)</h1>
    <emu-note>
      <p>동등 연산자 평가 결과는 항상 Boolean 타입이며, 연산자가 명명한 관계가 두 피연산자 사이에서 성립하는지를 반영한다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-equality-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>EqualityExpression : EqualityExpression `==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |EqualityExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 |RelationalExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. ? IsLooselyEqual(_rVal_, _lVal_) 반환.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!=` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 ? IsLooselyEqual(_rVal_, _lVal_) 로 둔다.
        1. _r_ 가 *true* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `===` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. IsStrictlyEqual(_rVal_, _lVal_) 반환.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 IsStrictlyEqual(_rVal_, _lVal_) 로 둔다.
        1. _r_ 가 *true* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-note>
        <p>위 동등성 정의에 따라:</p>
        <ul>
          <li>
            문자열 비교를 강제하려면: <code>\`${a}\` == \`${b}\`</code>.
          </li>
          <li>
            수치 비교를 강제하려면: <code>+a == +b</code>.
          </li>
          <li>
            Boolean 비교를 강제하려면: <code>!a == !b</code>.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>동등 연산자는 다음 불변식을 유지한다:</p>
        <ul>
          <li>
            <code>A != B</code> 는 <code>!(A == B)</code> 와 동등하다.
          </li>
          <li>
            <code>A == B</code> 는 (평가 순서 제외) <code>B == A</code> 와 동등하다.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>동등 연산자는 항상 추이적(transitive)이지는 않다. 예를 들어 동일한 String 값을 나타내는 서로 다른 두 String 객체가 있을 수 있고, 각 객체는 `==` 연산자에 의해 그 String 값과는 같지만 서로는 같지 않을 수 있다. 예:</p>
        <ul>
          <li>
            <code>new String("a") == "a"</code> 및 <code>"a" == new String("a")</code> 는 둘 다 *true*.
          </li>
          <li>
            <code>new String("a") == new String("a")</code> 는 *false*.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>문자열 비교는 코드 유닛 값 시퀀스의 단순 동등성 검사만을 사용한다. 유니코드 명세에 정의된 더 복잡하고 의미 지향적인 문자/문자열 동등성 또는 정렬 순서를 사용하지 않는다. 따라서 유니코드 표준에 따라 정규적으로 동등한 String 값이라도 서로 다르다고 나올 수 있다. 사실상 이 알고리즘은 두 String 이 이미 정규화(normalized)되어 있다고 가정한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-bitwise-operators">
    <h1>이진 비트 연산자(Binary Bitwise Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]

      BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]

      BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&amp;`, |EqualityExpression|) 반환.
      </emu-alg>
      <emu-grammar>BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|) 반환.
      </emu-alg>
      <emu-grammar>BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-logical-operators">
    <h1>이진 논리 연산자(Binary Logical Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]

      LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]

      CoalesceExpression[In, Yield, Await] :
        CoalesceExpressionHead[?In, ?Yield, ?Await] `??` BitwiseORExpression[?In, ?Yield, ?Await]

      CoalesceExpressionHead[In, Yield, Await] :
        CoalesceExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await]

      ShortCircuitExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        CoalesceExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`&amp;&amp;` 또는 `||` 연산자가 생성하는 값은 반드시 Boolean 타입일 필요가 없다. 결과 값은 항상 두 피연산자 표현식 중 하나의 값이다.</p>
    </emu-note>

    <emu-clause id="sec-binary-logical-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LogicalANDExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 이 *false* 이면 _lVal_ 반환.
        1. _rRef_ 를 |BitwiseORExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_rRef_) 반환.
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LogicalORExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 이 *true* 이면 _lVal_ 반환.
        1. _rRef_ 를 |LogicalANDExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_rRef_) 반환.
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |CoalesceExpressionHead| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _lVal_ 이 *undefined* 또는 *null* 이면
          1. _rRef_ 를 |BitwiseORExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_rRef_) 반환.
        1. 그렇지 않으면
          1. _lVal_ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-conditional-operator">
    <h1>조건부 연산자(Conditional Operator) ( `? :` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ConditionalExpression[In, Yield, Await] :
        ShortCircuitExpression[?In, ?Yield, ?Await]
        ShortCircuitExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>ECMAScript 의 |ConditionalExpression| 문법은 C 및 Java 와 약간 다르다. C 와 Java 는 두 번째 부분식을 |Expression| 으로 허용하지만 세 번째 부분식을 |ConditionalExpression| 으로 제한한다. ECMAScript 에서 이러한 차이를 둔 동기는 (1) 조건부의 어느 한 쪽 (arm) 에서도 할당 표현식을 다룰 수 있게 하고 (2) 가운데 표현식이 쉼표 표현식인 혼란스럽고 거의 쓸모없는 경우를 제거하기 위함이다.</p>
    </emu-note>

    <emu-clause id="sec-conditional-operator-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |ShortCircuitExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ToBoolean(? GetValue(_lRef_)) 로 둔다.
        1. _lVal_ 이 *true* 이면
          1. _trueRef_ 를 첫 번째 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_trueRef_) 반환.
        1. 그렇지 않으면
          1. _falseRef_ 를 두 번째 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_falseRef_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-assignment-operators">
    <h1>할당 연산자(Assignment Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `&amp;&amp;=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `||=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `??=` AssignmentExpression[?In, ?Yield, ?Await]

      // emu-format ignore
      AssignmentOperator : one of
        `*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`
    </emu-grammar>

    <emu-clause id="sec-assignment-operators-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면 |LeftHandSideExpression| 은 |AssignmentPattern| 을 커버해야 한다.
        </li>
        <li>
          |LeftHandSideExpression| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면, |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 Syntax Error 이다.
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 Syntax Error 이다.
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 의 AssignmentTargetType 이 ~simple~ 이 아니면 Syntax Error 이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. |LeftHandSideExpression| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면,
          1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw.
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
            1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
            1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
          1. 그렇지 않으면
            1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
            1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
          1. [id="step-assignmentexpression-evaluation-simple-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
          1. _rVal_ 반환.
        1. _assignmentPattern_ 을 |LeftHandSideExpression| 이 커버하는 |AssignmentPattern| 으로 둔다.
        1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _assignmentPattern_ 의 DestructuringAssignmentEvaluation(_rVal_) 를 ? 로 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외 throw.
        1. [id="step-assignmentexpression-evaluation-compound-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _assignmentOpText_ 를 |AssignmentOperator| 가 매칭한 소스 텍스트로 둔다.
        1. _opText_ 를 아래 표에서 _assignmentOpText_ 에 연관된 유니코드 코드 포인트 시퀀스로 둔다.
          <figure>
            <!-- emu-format ignore -->
            <table class="lightweight-table">
              <thead>
                <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>
              </thead>
              <tr><td> `**=`              </td><td> `**`           </td></tr>
              <tr><td> `*=`               </td><td> `*`            </td></tr>
              <tr><td> `/=`               </td><td> `/`            </td></tr>
              <tr><td> `%=`               </td><td> `%`            </td></tr>
              <tr><td> `+=`               </td><td> `+`            </td></tr>
              <tr><td> `-=`               </td><td> `-`            </td></tr>
              <tr><td> `&lt;&lt;=`        </td><td> `&lt;&lt;`     </td></tr>
              <tr><td> `&gt;&gt;=`        </td><td> `&gt;&gt;`     </td></tr>
              <tr><td> `&gt;&gt;&gt;=`    </td><td> `&gt;&gt;&gt;` </td></tr>
              <tr><td> `&amp;=`           </td><td> `&amp;`        </td></tr>
              <tr><td> `^=`               </td><td> `^`            </td></tr>
              <tr><td> `|=`               </td><td> `|`            </td></tr>
            </table>
          </figure>
        1. _r_ 를 ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-compound-putvalue"] ? PutValue(_lRef_, _r_) 수행.
        1. _r_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `&amp;&amp;=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-and-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 가 *false* 이면 _lVal_ 반환.
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
          1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
          1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
        1. 그렇지 않으면
          1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-and-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `||=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-or-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 가 *true* 이면 _lVal_ 반환.
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
          1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
          1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
        1. 그렇지 않으면
          1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-or-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `??=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _lVal_ 이 *undefined* 도 *null* 도 아니면 _lVal_ 반환.
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
          1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
          1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
        1. 그렇지 않으면
          1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-note>
        <p>이 표현식이 strict 모드 코드 내에 나타날 때 단계 <emu-xref href="#step-assignmentexpression-evaluation-simple-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-compound-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-getvalue"></emu-xref> 의 _lRef_ 가 해석 불가능한(unresolvable) reference 이면 런타임 오류이며 *ReferenceError* 예외가 발생한다. 또한 단계 <emu-xref href="#step-assignmentexpression-evaluation-compound-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-putvalue"></emu-xref> 의 _lRef_ 가 { [[Writable]]: *false* } 특성을 가진 데이터 프로퍼티, { [[Set]]: *undefined* } 특성을 가진 접근자 프로퍼티, 또는 IsExtensible 가 *false* 를 반환하는 객체의 존재하지 않는 프로퍼티라면 *TypeError* 예외가 발생한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-applystringornumericbinaryoperator" type="abstract operation">
      <h1>
        ApplyStringOrNumericBinaryOperator (
          _lVal_: an ECMAScript language value,
          _opText_: `**`, `*`, `/`, `%`, `+`, `-`, `&lt;&lt;`, `&gt;&gt;`, `&gt;&gt;&gt;`, `&amp;`, `^`, or `|`,
          _rVal_: an ECMAScript language value,
        ): 정상 완료 시 String, BigInt 또는 Number 중 하나 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _opText_ 가 `+` 이면
          1. [id="step-binary-op-toprimitive-lval"] _lPrim_ 을 ? ToPrimitive(_lVal_) 로 둔다.
          1. [id="step-binary-op-toprimitive-rval"] _rPrim_ 을 ? ToPrimitive(_rVal_) 로 둔다.
          1. [id="step-binary-op-string-check"] _lPrim_ 이 String 이거나 _rPrim_ 이 String 이면
            1. _lStr_ 을 ? ToString(_lPrim_) 로 둔다.
            1. _rStr_ 을 ? ToString(_rPrim_) 로 둔다.
            1. _lStr_ 와 _rStr_ 의 문자열 연결을 반환.
          1. _lVal_ 를 _lPrim_ 으로 설정.
          1. _rVal_ 를 _rPrim_ 으로 설정.
        1. NOTE: 이 시점부터는 수치 연산이어야 한다.
        1. _lNum_ 을 ? ToNumeric(_lVal_) 로 둔다.
        1. _rNum_ 을 ? ToNumeric(_rVal_) 로 둔다.
        1. SameType(_lNum_, _rNum_) 이 *false* 이면 *TypeError* 예외 throw.
        1. _lNum_ 이 BigInt 이면
          1. _opText_ 가 `**` 이면 ? BigInt::exponentiate(_lNum_, _rNum_) 반환.
          1. _opText_ 가 `/` 이면 ? BigInt::divide(_lNum_, _rNum_) 반환.
          1. _opText_ 가 `%` 이면 ? BigInt::remainder(_lNum_, _rNum_) 반환.
          1. _opText_ 가 `>>>` 이면 ? BigInt::unsignedRightShift(_lNum_, _rNum_) 반환.
          1. _operation_ 을 아래 표에서 _opText_ 에 연관된 추상 연산으로 둔다.
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_   </th><th> _operation_              </th></tr>
                </thead>
                <tbody>
                  <tr><td> `*`        </td><td> BigInt::multiply         </td></tr>
                  <tr><td> `+`        </td><td> BigInt::add              </td></tr>
                  <tr><td> `-`        </td><td> BigInt::subtract         </td></tr>
                  <tr><td> `&lt;&lt;` </td><td> BigInt::leftShift        </td></tr>
                  <tr><td> `&gt;&gt;` </td><td> BigInt::signedRightShift </td></tr>
                  <tr><td> `&amp;`    </td><td> BigInt::bitwiseAND       </td></tr>
                  <tr><td> `^`        </td><td> BigInt::bitwiseXOR       </td></tr>
                  <tr><td> `|`        </td><td> BigInt::bitwiseOR        </td></tr>
                </tbody>
              </table>
            </figure>
        1. 그렇지 않으면
          1. 단언: _lNum_ 은 Number.
          1. _operation_ 을 아래 표에서 _opText_ 에 연관된 추상 연산으로 둔다.
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_       </th><th> _operation_                </th></tr>
                </thead>
                <tbody>
                  <tr><td> `**`           </td><td> Number::exponentiate       </td></tr>
                  <tr><td> `*`            </td><td> Number::multiply           </td></tr>
                  <tr><td> `/`            </td><td> Number::divide             </td></tr>
                  <tr><td> `%`            </td><td> Number::remainder          </td></tr>
                  <tr><td> `+`            </td><td> Number::add                </td></tr>
                  <tr><td> `-`            </td><td> Number::subtract           </td></tr>
                  <tr><td> `&lt;&lt;`     </td><td> Number::leftShift          </td></tr>
                  <tr><td> `&gt;&gt;`     </td><td> Number::signedRightShift   </td></tr>
                  <tr><td> `&gt;&gt;&gt;` </td><td> Number::unsignedRightShift </td></tr>
                  <tr><td> `&amp;`        </td><td> Number::bitwiseAND         </td></tr>
                  <tr><td> `^`            </td><td> Number::bitwiseXOR         </td></tr>
                  <tr><td> `|`            </td><td> Number::bitwiseOR          </td></tr>
                </tbody>
              </table>
            </figure>
        1. _operation_(_lNum_, _rNum_) 반환.
      </emu-alg>
      <emu-note>
        <p>단계 <emu-xref href="#step-binary-op-toprimitive-lval"></emu-xref>, <emu-xref href="#step-binary-op-toprimitive-rval"></emu-xref> 의 ToPrimitive 호출에는 hint 가 제공되지 않는다. 표준 객체 중 Date 를 제외한 모든 객체는 hint 부재를 ~number~ 가 주어진 것처럼 처리하고 Date 는 ~string~ 처럼 처리한다. 특수(exotic) 객체는 다른 방식으로 처리할 수 있다.</p>
      </emu-note>
      <emu-note>
        <p>단계 <emu-xref href="#step-binary-op-string-check"></emu-xref> 는 IsLessThan 알고리즘의 단계 <emu-xref href="#step-arc-string-check"></emu-xref> 와 달리 논리 AND 대신 논리 OR 를 사용한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-evaluatestringornumericbinaryexpression" type="abstract operation">
      <h1>
        EvaluateStringOrNumericBinaryExpression (
          _leftOperand_: a Parse Node,
          _opText_: a sequence of Unicode code points,
          _rightOperand_: a Parse Node,
        ): 정상 완료 시 String, BigInt 또는 Number 중 하나 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _lRef_ 를 _leftOperand_ 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 _rightOperand_ 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-destructuring-assignment">
      <h1>구조 분해 할당(Destructuring Assignment)</h1>
      <h2>보충 문법(Supplemental Syntax)</h2>
      <p>
        특정 상황에서 다음 생성물 인스턴스를 처리할 때<br>
        <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar><br>
        |LeftHandSideExpression| 의 해석은 아래 문법을 사용해 정밀화된다:
      </p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-assignment-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <ul>
          <li>
            |IdentifierReference| 의 AssignmentTargetType 이 ~simple~ 이 아니면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <ul>
          <li>
            |DestructuringAssignmentTarget| 이 |ArrayLiteral| 이거나 |ObjectLiteral| 이면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>DestructuringAssignmentTarget : LeftHandSideExpression</emu-grammar>
        <ul>
          <li>
            |LeftHandSideExpression| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면 |LeftHandSideExpression| 은 |AssignmentPattern| 을 커버해야 한다.
          </li>
          <li>
            |LeftHandSideExpression| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면 AssignmentTargetType 이 ~simple~ 이 아니면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-destructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: DestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ObjectAssignmentPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>
          ObjectAssignmentPattern :
            `{` AssignmentPropertyList `}`
            `{` AssignmentPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. |AssignmentPropertyList| 의 PropertyDestructuringAssignmentEvaluation(_value_) 를 ? 로 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. _excludedNames_ 를 새 빈 List 로 둔다.
          1. |AssignmentRestProperty| 의 RestDestructuringAssignmentEvaluation(_value_, _excludedNames_) 를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentPropertyList `,` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. _excludedNames_ 를 |AssignmentPropertyList| 의 PropertyDestructuringAssignmentEvaluation(_value_) 결과 (?) 로 둔다.
          1. |AssignmentRestProperty| 의 RestDestructuringAssignmentEvaluation(_value_, _excludedNames_) 를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)) 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. _result_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_)) 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _result_) 반환.
          1. _result_ 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. |Elision| 이 존재하면
            1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_)) 로 둔다.
            1. _status_ 가 abrupt completion 이면
              1. 단언: _iteratorRecord_.[[Done]] 는 *true*.
              1. ? _status_ 반환.
          1. _result_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentRestElement|, _iteratorRecord_)) 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _result_) 반환.
          1. _result_ 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. _result_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentElementList|, _iteratorRecord_)) 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _result_) 반환.
          1. _result_ 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision? AssignmentRestElement? `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentElementList|, _iteratorRecord_)) 로 둔다.
          1. _status_ 가 abrupt completion 이면
            1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _status_) 반환.
            1. ? _status_ 반환.
          1. |Elision| 이 존재하면
            1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_)) 로 설정.
            1. _status_ 가 abrupt completion 이면
              1. 단언: _iteratorRecord_.[[Done]] 는 *true*.
              1. ? _status_ 반환.
          1. |AssignmentRestElement| 가 존재하면
            1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentRestElement|, _iteratorRecord_)) 로 설정.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _status_) 반환.
          1. ? _status_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: PropertyDestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          ): 정상 완료 시 프로퍼티 키 List 또는 abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>모든 구조 분해된 프로퍼티 키의 목록을 수집한다.</dd>
        </dl>
        <emu-grammar>AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty</emu-grammar>
        <emu-alg>
          1. _propertyNames_ 를 |AssignmentPropertyList| 의 PropertyDestructuringAssignmentEvaluation(_value_) 결과 (?) 로 둔다.
          1. _nextNames_ 를 |AssignmentProperty| 의 PropertyDestructuringAssignmentEvaluation(_value_) 결과 (?) 로 둔다.
          1. _propertyNames_ 와 _nextNames_ 의 리스트 연결 반환.
        </emu-alg>

        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <emu-alg>
          1. _P_ 를 |IdentifierReference| 의 StringValue 로 둔다.
          1. _lRef_ 를 ? ResolveBinding(_P_) 로 둔다.
          1. _v_ 를 ? GetV(_value_, _P_) 로 둔다.
          1. |Initializer| 가 존재하고 _v_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
              1. _v_ 를 |Initializer| 의 NamedEvaluation(_P_) 결과 (?) 로 설정.
            1. 그렇지 않으면
              1. _defaultValue_ 를 |Initializer| 의 Evaluation 결과 (?) 로 둔다.
              1. _v_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. ? PutValue(_lRef_, _v_) 수행.
          1. « _P_ » 반환.
        </emu-alg>

        <emu-grammar>AssignmentProperty : PropertyName `:` AssignmentElement</emu-grammar>
        <emu-alg>
          1. _name_ 을 |PropertyName| 의 Evaluation 결과 (?) 로 둔다.
          1. |AssignmentElement| 의 KeyedDestructuringAssignmentEvaluation(_value_, _name_) 를 ? 로 수행.
          1. « _name_ » 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-restdestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: RestDestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          _excludedNames_: a List of property keys,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _restObj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ? CopyDataProperties(_restObj_, _value_, _excludedNames_) 수행.
          1. ? PutValue(_lRef_, _restObj_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: IteratorDestructuringAssignmentEvaluation (
          _iteratorRecord_: an Iterator Record,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElisionElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElementList|, _iteratorRecord_) 수행.
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElisionElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_) 수행.
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_.[[Done]] 가 *false* 이면
            1. ? IteratorStep(_iteratorRecord_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_) 수행.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면
            1. ? IteratorStep(_iteratorRecord_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _value_ 를 *undefined* 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이 아니면
              1. _value_ 를 _next_ 로 설정.
          1. |Initializer| 가 존재하고 _value_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이고 IsIdentifierRef(|DestructuringAssignmentTarget|) 가 *true* 이면
              1. _target_ 을 |DestructuringAssignmentTarget| 의 StringValue 로 둔다.
              1. _v_ 를 |Initializer| 의 NamedEvaluation(_target_) 결과 (?) 로 둔다.
            1. 그렇지 않으면
              1. _defaultValue_ 를 |Initializer| 의 Evaluation 결과 (?) 로 둔다.
              1. _v_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. 그렇지 않으면
            1. _v_ 를 _value_ 로 둔다.
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면
            1. _nestedAssignmentPattern_ 을 |DestructuringAssignmentTarget| 이 커버하는 |AssignmentPattern| 으로 둔다.
            1. ? DestructuringAssignmentEvaluation(_nestedAssignmentPattern_, _v_) 반환.
          1. ? PutValue(_lRef_, _v_) 반환.
        </emu-alg>
        <emu-note>
          <p>|DestructuringAssignmentTarget| 이 구조 분해 패턴이 아닌 경우 그것을 먼저 평가한 뒤 iterator 접근이나 |Initializer| 평가가 수행되어 좌→우 평가 순서가 유지된다.</p>
        </emu-note>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _A_ 를 ! ArrayCreate(0) 로 둔다.
          1. _n_ = 0.
          1. _iteratorRecord_.[[Done]] 가 *false* 인 동안 반복
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이 아니면
              1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_) 수행.
              1. _n_ = _n_ + 1.
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. ? PutValue(_lRef_, _A_) 반환.
          1. _nestedAssignmentPattern_ 을 |DestructuringAssignmentTarget| 이 커버하는 |AssignmentPattern| 으로 둔다.
          1. ? DestructuringAssignmentEvaluation(_nestedAssignmentPattern_, _A_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: KeyedDestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          _propertyName_: a property key,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _v_ 를 ? GetV(_value_, _propertyName_) 로 둔다.
          1. |Initializer| 가 존재하고 _v_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이고 IsIdentifierRef(|DestructuringAssignmentTarget|) 가 *true* 이면
              1. _target_ 을 |DestructuringAssignmentTarget| 의 StringValue 로 둔다.
              1. _rhsValue_ 를 |Initializer| 의 NamedEvaluation(_target_) 결과 (?) 로 둔다.
            1. 그렇지 않으면
              1. _defaultValue_ 를 |Initializer| 의 Evaluation 결과 (?) 로 둔다.
              1. _rhsValue_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. 그렇지 않으면
            1. _rhsValue_ 를 _v_ 로 둔다.
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면
            1. _assignmentPattern_ 을 |DestructuringAssignmentTarget| 이 커버하는 |AssignmentPattern| 으로 둔다.
            1. ? DestructuringAssignmentEvaluation(_assignmentPattern_, _rhsValue_) 반환.
          1. ? PutValue(_lRef_, _rhsValue_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-comma-operator">
    <h1>콤마 연산자(Comma Operator) ( `,` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-comma-operator-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |Expression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_lRef_) 수행.
        1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_rRef_) 반환.
      </emu-alg>
      <emu-note>
        <p>값을 사용하지 않더라도 관찰 가능한 부수 효과가 있을 수 있으므로 GetValue 는 호출되어야 한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript 언어: 문(Statements)과 선언(Declarations)</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    Statement[Yield, Await, Return] :
      BlockStatement[?Yield, ?Await, ?Return]
      VariableStatement[?Yield, ?Await]
      EmptyStatement
      ExpressionStatement[?Yield, ?Await]
      IfStatement[?Yield, ?Await, ?Return]
      BreakableStatement[?Yield, ?Await, ?Return]
      ContinueStatement[?Yield, ?Await]
      BreakStatement[?Yield, ?Await]
      [+Return] ReturnStatement[?Yield, ?Await]
      WithStatement[?Yield, ?Await, ?Return]
      LabelledStatement[?Yield, ?Await, ?Return]
      ThrowStatement[?Yield, ?Await]
      TryStatement[?Yield, ?Await, ?Return]
      DebuggerStatement

    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] :
      FunctionDeclaration[?Yield, ?Await, ?Default]
      GeneratorDeclaration[?Yield, ?Await, ?Default]
      AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
      AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] :
      IterationStatement[?Yield, ?Await, ?Return]
      SwitchStatement[?Yield, ?Await, ?Return]
  </emu-grammar>

  <emu-clause id="sec-statement-semantics">
    <h1>Statement 의미론</h1>

    <emu-clause id="sec-statement-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>
        HoistableDeclaration :
          GeneratorDeclaration
          AsyncFunctionDeclaration
          AsyncGeneratorDeclaration
      </emu-grammar>
      <emu-alg>
        1. ~empty~ 를 반환한다.
      </emu-alg>
      <emu-grammar>
        HoistableDeclaration : FunctionDeclaration
      </emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| 의 Evaluation 결과를 ? 로 반환한다.
      </emu-alg>
      <emu-grammar>
        BreakableStatement :
          IterationStatement
          SwitchStatement
      </emu-grammar>
      <emu-alg>
        1. _newLabelSet_ 을 새 빈 List 로 둔다.
        1. 이 |BreakableStatement| 의 LabelledEvaluation(_newLabelSet_) 결과를 ? 로 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BlockStatement[Yield, Await, Return] :
        Block[?Yield, ?Await, ?Return]

      Block[Yield, Await, Return] :
        `{` StatementList[?Yield, ?Await, ?Return]? `}`

      StatementList[Yield, Await, Return] :
        StatementListItem[?Yield, ?Await, ?Return]
        StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

      StatementListItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        Declaration[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-block-static-semantics-early-errors" oldids="sec-block-duplicates-allowed-static-semantics">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <ul>
        <li>
          <p>|StatementList| 의 LexicallyDeclaredNames 에 중복 항목이 존재하면 Syntax Error<span normative-optional> — 단, 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하고 다음 두 조건이 모두 참이면 예외:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) 이 *false*.</li>
            <li>중복 항목이 모두 FunctionDeclaration 에 의해 바인딩된다.</li>
          </ul>
        </li>
        <li>
          |StatementList| 의 LexicallyDeclaredNames 요소 중 어느 하나라도 |StatementList| 의 VarDeclaredNames 에도 나타나면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-block-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ 를 반환한다.
      </emu-alg>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. _oldEnv_ 를 실행 중인 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _blockEnv_ 를 NewDeclarativeEnvironment(_oldEnv_) 로 둔다.
        1. BlockDeclarationInstantiation(|StatementList|, _blockEnv_) 수행.
        1. 실행 컨텍스트의 LexicalEnvironment 를 _blockEnv_ 로 설정.
        1. _blockValue_ 를 Completion(|StatementList| 평가) 로 둔다.
        1. 실행 컨텍스트의 LexicalEnvironment 를 _oldEnv_ 로 되돌린다.
        1. ? _blockValue_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|Block| 을 어떻게 빠져나오든 LexicalEnvironment 는 항상 이전 상태로 복구된다.</p>
      </emu-note>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _sl_ 을 |StatementList| 의 Evaluation 결과 (?) 로 둔다.
        1. _s_ 를 |StatementListItem| 평가의 Completion 으로 둔다.
        1. ? UpdateEmpty(_s_, _sl_) 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|StatementList| 의 값은 그 안에서 마지막으로 값을 생산한 항목의 값이다. 예를 들어 아래 `eval` 호출은 모두 1을 반환한다:</p>
        <pre><code class="javascript">
          eval("1;;;;;")
          eval("1;{}")
          eval("1;var a;")
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-blockdeclarationinstantiation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ 는 블록 본문에 대응하는 Parse Node 이며, _env_ 는 바인딩이 생성될 Environment Record 이다.</dd>
      </dl>
      <emu-note>
        <p>|Block| 또는 |CaseBlock| 이 평가될 때 새 Declarative Environment Record 가 생성되고 블록 안에 선언된 블록 스코프 변수/상수/함수/클래스에 대한 바인딩이 그 Environment Record 안에서 생성된다.</p>
      </emu-note>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _declarations_ 를 _code_ 의 LexicallyScopedDeclarations 로 둔다.
        1. _privateEnv_ 를 실행 중인 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _declarations_ 의 각 요소 _d_ 에 대해
          1. _d_ 의 BoundNames 각 요소 _dn_ 에 대해
            1. IsConstantDeclaration(_d_) 가 *true* 이면
              1. ! _env_.CreateImmutableBinding(_dn_, *true*) 수행.
            1. 그렇지 않으면
              1. [id="step-blockdeclarationinstantiation-createmutablebinding", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
                1. ! _env_.HasBinding(_dn_) 이 *false* 이면
                  1. ! _env_.CreateMutableBinding(_dn_, *false*) 수행.
              1. 그렇지 않으면
                1. ! _env_.CreateMutableBinding(_dn_, *false*) 수행.
          1. _d_ 가 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| 중 하나라면
            1. _fn_ 을 _d_ 의 BoundNames 의 유일한 요소로 둔다.
            1. _fo_ 를 InstantiateFunctionObject(_d_, 인수 _env_, _privateEnv_) 로 둔다.
            1. [id="step-blockdeclarationinstantiation-initializebinding", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
              1. _env_ 에서 _fn_ 바인딩이 초기화되지 않았다면
                1. ! _env_.InitializeBinding(_fn_, _fo_) 수행.
              1. 그렇지 않으면
                1. 단언: _d_ 는 |FunctionDeclaration|.
                1. ! _env_.SetMutableBinding(_fn_, _fo_, *false*) 수행.
            1. 그렇지 않으면
              1. ! _env_.InitializeBinding(_fn_, _fo_) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>선언과 변수 문(Variable Statement)</h1>

    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let 및 Const 선언</h1>
      <emu-note>
        <p>`let` 과 `const` 선언은 실행 중인 실행 컨텍스트의 LexicalEnvironment 에 스코프를 가지는 변수를 정의한다. 변수는 포함 Environment Record 가 초기화될 때 생성되지만 해당 변수의 |LexicalBinding| 이 평가되기 전에는 어떤 방식으로도 접근할 수 없다. |Initializer| 를 가진 |LexicalBinding| 으로 정의된 변수는 그 |LexicalBinding| 이 평가될 때 |Initializer| 의 |AssignmentExpression| 결과 값이 할당되며, 생성 시점이 아니다. `let` 선언에서 |Initializer| 가 없는 |LexicalBinding| 은 평가 시 *undefined* 가 할당된다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await] `;`

        LetOrConst :
          `let`
          `const`

        BindingList[In, Yield, Await] :
          LexicalBinding[?In, ?Yield, ?Await]
          BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]

        LexicalBinding[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <ul>
          <li>
            |BindingList| 의 BoundNames 목록에 *"let"* 이 포함되면 Syntax Error.
          </li>
          <li>
            |BindingList| 의 BoundNames 목록에 중복 항목이 있으면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <ul>
          <li>
            |Initializer| 가 없고 이 |LexicalBinding| 을 포함하는 |LexicalDeclaration| 의 IsConstantDeclaration 이 *true* 이면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. |BindingList| 평가를 ? 로 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. |BindingList| 평가를 ? 로 수행.
          1. |LexicalBinding| 평가 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 ! ResolveBinding(StringValue of |BindingIdentifier|) 로 둔다.
          1. ! InitializeReferencedBinding(_lhs_, *undefined*) 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-note>
          <p>정적 의미론 규칙은 이 형태의 |LexicalBinding| 이 `const` 선언에서는 발생하지 않음을 보장한다.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. _lhs_ 를 ! ResolveBinding(_bindingId_) 로 둔다.
          1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
            1. _value_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 결과 (?) 로 둔다.
          1. 그렇지 않으면
            1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
            1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. ! InitializeReferencedBinding(_lhs_, _value_) 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
          1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
          1. |BindingPattern| 의 BindingInitialization(_value_, _env_) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-variable-statement">
      <h1>Variable Statement</h1>
      <emu-note>
        <p>`var` 문은 실행 중인 실행 컨텍스트의 VariableEnvironment 에 스코프를 가지는 변수를 선언한다. Var 변수는 Environment Record 가 인스턴스화될 때 생성되며 생성과 동시에 *undefined* 로 초기화된다. 하나의 VariableEnvironment 스코프 내에서는 동일 |BindingIdentifier| 가 여러 |VariableDeclaration| 에 나타날 수 있으나 그것들은 하나의 변수만을 정의한다. |Initializer| 를 가진 |VariableDeclaration| 으로 정의된 변수는 선언이 실행될 때 |Initializer| 의 |AssignmentExpression| 결과 값이 할당되며, 생성 시점이 아니다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        VariableStatement[Yield, Await] :
          `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`

        VariableDeclarationList[In, Yield, Await] :
          VariableDeclaration[?In, ?Yield, ?Await]
          VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]

        VariableDeclaration[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-variable-statement-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| 평가를 ? 로 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| 평가를 ? 로 수행.
          1. |VariableDeclaration| 평가 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. _lhs_ 를 ? ResolveBinding(_bindingId_) 로 둔다.
          1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
            1. _value_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 결과 (?) 로 둔다.
          1. 그렇지 않으면
            1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
            1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. [id="step-vardecllist-evaluation-putvalue"] ? PutValue(_lhs_, _value_) 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-note>
          <p>|VariableDeclaration| 이 with 문 내부에 중첩되어 있고 그 |BindingIdentifier| 가 with 문 Object Environment Record 의 바인딩 객체의 프로퍼티 이름과 같다면, 단계 <emu-xref href="#step-vardecllist-evaluation-putvalue"></emu-xref> 는 식별자의 VariableEnvironment 바인딩 대신 그 프로퍼티에 _value_ 를 할당한다.</p>
        </emu-note>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rhs_) 로 둔다.
          1. |BindingPattern| 의 BindingInitialization(_rVal_, *undefined*) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>구조 분해 바인딩 패턴(Destructuring Binding Patterns)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization" type="sdo">
        <h1>
          런타임 의미론: PropertyBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          ): 정상 완료 시 프로퍼티 키 List 또는 abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>바인딩된 모든 프로퍼티 이름 목록을 수집한다.</dd>
        </dl>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. _boundNames_ 를 |BindingPropertyList| 의 PropertyBindingInitialization(_value_, _environment_) 결과 (?) 로 둔다.
          1. _nextNames_ 를 |BindingProperty| 의 PropertyBindingInitialization(_value_, _environment_) 결과 (?) 로 둔다.
          1. _boundNames_ 와 _nextNames_ 의 리스트 연결을 반환.
        </emu-alg>

        <emu-grammar>BindingProperty : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. _name_ 을 |SingleNameBinding| 의 BoundNames 유일 요소로 둔다.
          1. |SingleNameBinding| 의 KeyedBindingInitialization(_value_, _environment_, _name_) 를 ? 로 수행.
          1. « _name_ » 반환.
        </emu-alg>

        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. _P_ 를 |PropertyName| 평가 결과 (?) 로 둔다.
          1. |BindingElement| 의 KeyedBindingInitialization(_value_, _environment_, _P_) 를 ? 로 수행.
          1. « _P_ » 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          런타임 의미론: RestBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          _excludedNames_: a List of property keys,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_) 로 둔다.
          1. _restObj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ? CopyDataProperties(_restObj_, _value_, _excludedNames_) 수행.
          1. _environment_ 가 *undefined* 이면 ? PutValue(_lhs_, _restObj_) 반환.
          1. ? InitializeReferencedBinding(_lhs_, _restObj_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          런타임 의미론: KeyedBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          _propertyName_: a property key,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>_environment_ 에 *undefined* 를 전달하면 값 할당에 PutValue 연산을 사용해야 함을 의미한다. 이는 비엄격 함수의 형식 매개변수 리스트 등의 경우이며, 그때는 동일 이름 매개변수 가능성 때문에 사전 초기화된다.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. _v_ 를 ? GetV(_value_, _propertyName_) 로 둔다.
          1. |Initializer| 존재하고 _v_ 가 *undefined* 이면
            1. _defaultValue_ 를 |Initializer| 평가 결과 (?) 로 둔다.
            1. _v_ 를 ? GetValue(_defaultValue_) 로 설정.
          1. |BindingPattern| 의 BindingInitialization(_v_, _environment_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. _lhs_ 를 ? ResolveBinding(_bindingId_, _environment_) 로 둔다.
          1. _v_ 를 ? GetV(_value_, _propertyName_) 로 둔다.
          1. |Initializer| 존재하고 _v_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) *true* 이면
              1. _v_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 결과 (?) 로 둔다.
            1. 아니면
              1. _defaultValue_ 를 |Initializer| 평가 결과 (?) 로 둔다.
              1. _v_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. _environment_ 가 *undefined* 이면 ? PutValue(_lhs_, _v_) 반환.
          1. ? InitializeReferencedBinding(_lhs_, _v_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-empty-statement">
    <h1>Empty Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EmptyStatement :
        `;`
    </emu-grammar>

    <emu-clause id="sec-empty-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>EmptyStatement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-expression-statement">
    <h1>Expression Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ExpressionStatement[Yield, Await] :
        [lookahead &notin; { `{`, `function`, `async` [no LineTerminator here] `function`, `class`, `let` `[` }] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>|ExpressionStatement| 는 U+007B (LEFT CURLY BRACKET) 으로 시작할 수 없는데, 이는 |Block| 과의 모호성을 피하기 위해서이다. 또한 `function` 또는 `class` 로 시작할 수 없는데 그러면 |FunctionDeclaration|, |GeneratorDeclaration|, |ClassDeclaration| 과 모호하기 때문이다. `async function` 으로 시작할 수 없는 이유는 |AsyncFunctionDeclaration| 또는 |AsyncGeneratorDeclaration| 과 모호하기 때문이다. `let [` 두 토큰 시퀀스로 시작할 수 없는 이유는 첫 |LexicalBinding| 이 |ArrayBindingPattern| 인 `let` |LexicalDeclaration| 과 모호하기 때문이다.</p>
    </emu-note>

    <emu-clause id="sec-expression-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ExpressionStatement : Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
        1. ? GetValue(_exprRef_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-if-statement">
    <h1>`if` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IfStatement[Yield, Await, Return] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] [lookahead != `else`]
    </emu-grammar>
    <emu-note>lookahead 제한 [lookahead ≠ `else`] 는 고전적인 “dangling else” 문제를 통상 방식으로 해결한다. 즉 어떤 `else` 가 어느 `if` 와 연관될지 모호할 때 가장 안쪽(가장 가까운)의 `if` 와 결합된다.</emu-note>

    <emu-clause id="sec-if-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <ul>
        <li>
          첫 번째 |Statement| 에 대해 IsLabelledFunction(...) 이 *true* 이면 Syntax Error.
        </li>
        <li>
          두 번째 |Statement| 에 대해 IsLabelledFunction(...) 이 *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          |Statement| 에 대해 IsLabelledFunction(...) 이 *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-note>
        <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 에 명시된 확장이 구현된 경우에만 이 규칙을 적용하면 된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-if-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
        1. _exprValue_ 를 ToBoolean(? GetValue(_exprRef_)) 로 둔다.
        1. _exprValue_ 가 *true* 이면
          1. _stmtCompletion_ 를 첫 번째 |Statement| 평가의 Completion 으로 둔다.
        1. 그렇지 않으면
          1. _stmtCompletion_ 를 두 번째 |Statement| 평가의 Completion 으로 둔다.
        1. ? UpdateEmpty(_stmtCompletion_, *undefined*) 반환.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
        1. _exprValue_ 를 ToBoolean(? GetValue(_exprRef_)) 로 둔다.
        1. _exprValue_ 가 *false* 이면
          1. *undefined* 반환.
        1. 그렇지 않으면
          1. _stmtCompletion_ 를 |Statement| 평가의 Completion 으로 둔다.
          1. ? UpdateEmpty(_stmtCompletion_, *undefined*) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>Iteration Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IterationStatement[Yield, Await, Return] :
        DoWhileStatement[?Yield, ?Await, ?Return]
        WhileStatement[?Yield, ?Await, ?Return]
        ForStatement[?Yield, ?Await, ?Return]
        ForInOfStatement[?Yield, ?Await, ?Return]
    </emu-grammar>

    <emu-clause id="sec-iteration-statements-semantics">
      <h1>의미론</h1>

      <emu-clause id="sec-loopcontinues" type="abstract operation">
        <h1>
          LoopContinues (
            _completion_: a Completion Record,
            _labelSet_: a List of Strings,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _completion_ 이 정상 completion 이면 *true* 반환.
          1. _completion_ 이 continue completion 이 아니면 *false* 반환.
          1. _completion_.[[Target]] 이 ~empty~ 이면 *true* 반환.
          1. _labelSet_ 이 _completion_.[[Target]] 을 포함하면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>|IterationStatement| 의 |Statement| 부분 내부에서는 |ContinueStatement| 로 새 반복을 시작할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-loopevaluation" type="sdo">
        <h1>
          런타임 의미론: LoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 언어 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>IterationStatement : DoWhileStatement</emu-grammar>
        <emu-alg>
          1. |DoWhileStatement| 의 DoWhileLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>IterationStatement : WhileStatement</emu-grammar>
        <emu-alg>
          1. |WhileStatement| 의 WhileLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>IterationStatement : ForStatement</emu-grammar>
        <emu-alg>
          1. |ForStatement| 의 ForLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>IterationStatement : ForInOfStatement</emu-grammar>
        <emu-alg>
          1. |ForInOfStatement| 의 ForIn/OfLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-do-while-statement">
      <h1>`do`-`while` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        DoWhileStatement[Yield, Await, Return] :
          `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
      </emu-grammar>

      <emu-clause id="sec-do-while-statement-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-dowhileloopevaluation" oldids="sec-do-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: DoWhileLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. _V_ 를 *undefined* 로 둔다.
          1. 반복,
            1. _stmtResult_ 를 |Statement| 평가 Completion 으로 둔다.
            1. LoopContinues(_stmtResult_, _labelSet_) 가 *false* 이면 ? UpdateEmpty(_stmtResult_, _V_) 반환.
            1. _stmtResult_.[[Value]] 가 ~empty~ 가 아니면 _V_ 를 그 값으로 설정.
            1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
            1. _exprValue_ 를 ? GetValue(_exprRef_) 로 둔다.
            1. ToBoolean(_exprValue_) 가 *false* 이면 _V_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-while-statement">
      <h1>`while` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        WhileStatement[Yield, Await, Return] :
          `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-while-statement-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-whileloopevaluation" oldids="sec-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: WhileLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _V_ 를 *undefined* 로 둔다.
          1. 반복,
            1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
            1. _exprValue_ 를 ? GetValue(_exprRef_) 로 둔다.
            1. ToBoolean(_exprValue_) 가 *false* 이면 _V_ 반환.
            1. _stmtResult_ 를 |Statement| 평가 Completion 으로 둔다.
            1. LoopContinues(_stmtResult_, _labelSet_) 가 *false* 이면 ? UpdateEmpty(_stmtResult_, _V_) 반환.
            1. _stmtResult_.[[Value]] 가 ~empty~ 가 아니면 _V_ 갱신.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-statement">
      <h1>`for` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-for-statement-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>
          ForStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <ul>
          <li>
            |LexicalDeclaration| 의 BoundNames 요소 중 하나라도 |Statement| 의 VarDeclaredNames 에 나타나면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: ForLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. 첫 번째 |Expression| 존재하면
            1. _exprRef_ 를 그 평가 결과 (?) 로 둔다.
            1. ? GetValue(_exprRef_) 수행.
          1. 두 번째 |Expression| 존재하면 _test_ 를 그 |Expression| 으로, 아니면 ~empty~.
          1. 세 번째 |Expression| 존재하면 _increment_ 를 그 |Expression| 으로, 아니면 ~empty~.
          1. ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| 평가를 ? 로 수행.
          1. 첫 번째 |Expression| 존재하면 _test_ 를 그 |Expression|, 아니면 ~empty~.
          1. 두 번째 |Expression| 존재하면 _increment_ 를 그 |Expression|, 아니면 ~empty~.
          1. ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. _oldEnv_ 를 실행 컨텍스트 LexicalEnvironment 로 둔다.
          1. _loopEnv_ 를 NewDeclarativeEnvironment(_oldEnv_) 로 둔다.
          1. _isConst_ 를 |LexicalDeclaration| 의 IsConstantDeclaration 으로 둔다.
          1. _boundNames_ 를 |LexicalDeclaration| 의 BoundNames 로 둔다.
          1. 각 _dn_ ∈ _boundNames_ 에 대해
            1. _isConst_ 가 *true* 이면 ! _loopEnv_.CreateImmutableBinding(_dn_, *true*)
            1. 아니면 ! _loopEnv_.CreateMutableBinding(_dn_, *false*)
          1. 실행 컨텍스트 LexicalEnvironment 를 _loopEnv_ 로 설정.
          1. _forDcl_ 를 |LexicalDeclaration| 평가 Completion 으로 둔다.
          1. _forDcl_ 이 abrupt 면
            1. LexicalEnvironment 를 _oldEnv_ 로 복구.
            1. ? _forDcl_ 반환.
          1. _isConst_ 가 *false* 이면 _perIterationLets_ = _boundNames_; 아니면 새 빈 List.
          1. 첫 번째 |Expression| 존재하면 _test_ 그 |Expression|; 아니면 ~empty~.
          1. 두 번째 |Expression| 존재하면 _increment_ 그 |Expression|; 아니면 ~empty~.
          1. _bodyResult_ 를 Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)) 로 둔다.
          1. LexicalEnvironment 를 _oldEnv_ 로 복구.
          1. ? _bodyResult_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" type="abstract operation">
        <h1>
          ForBodyEvaluation (
            _test_: an |Expression| Parse Node or ~empty~,
            _increment_: an |Expression| Parse Node or ~empty~,
            _stmt_: a |Statement| Parse Node,
            _perIterationBindings_: a List of Strings,
            _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_ = *undefined*.
          1. ? CreatePerIterationEnvironment(_perIterationBindings_) 수행.
          1. 반복,
            1. _test_ 가 ~empty~ 이 아니면
              1. _testRef_ = ? _test_ 평가
              1. _testValue_ = ? GetValue(_testRef_)
              1. ToBoolean(_testValue_) 가 *false* 면 _V_ 반환.
            1. _result_ = _stmt_ 평가 Completion
            1. LoopContinues(_result_, _labelSet_) 가 *false* 면 ? UpdateEmpty(_result_, _V_) 반환.
            1. _result_.[[Value]] 가 ~empty~ 아니면 _V_ 갱신.
            1. ? CreatePerIterationEnvironment(_perIterationBindings_) 수행.
            1. _increment_ 가 ~empty~ 아니면
              1. _incRef_ = ? _increment_ 평가
              1. ? GetValue(_incRef_) 수행.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" type="abstract operation">
        <h1>
          CreatePerIterationEnvironment (
            _perIterationBindings_: a List of Strings,
          ): 정상 완료 시 ~unused~ 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _perIterationBindings_ 에 요소가 있으면
            1. _lastIterationEnv_ = 실행 컨텍스트 LexicalEnvironment
            1. _outer_ = _lastIterationEnv_.[[OuterEnv]]
            1. 단언: _outer_ != *null*
            1. _thisIterationEnv_ = NewDeclarativeEnvironment(_outer_)
            1. 각 _bn_ ∈ _perIterationBindings_ 에 대해
              1. ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*)
              1. _lastValue_ = ? _lastIterationEnv_.GetBindingValue(_bn_, *true*)
              1. ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_)
            1. 실행 컨텍스트 LexicalEnvironment = _thisIterationEnv_
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>`for`-`in`, `for`-`of`, `for`-`await`-`of` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; { `let`, `async` `of` }] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await] :
          LetOrConst ForBinding[?Yield, ?Await]

        ForBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await]
          BindingPattern[?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>이 절은 부록 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 의해 확장된다.</p>
      </emu-note>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |LeftHandSideExpression| 이 |ObjectLiteral| 또는 |ArrayLiteral| 이면 |AssignmentPattern| 을 커버해야 한다.
          </li>
          <li>
            그렇지 않으면 |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |ForDeclaration| 의 BoundNames 에 *"let"* 포함 시 Syntax Error.
          </li>
          <li>|ForDeclaration| 의 BoundNames 요소가 |Statement| 의 VarDeclaredNames 에도 나타나면 Syntax Error.</li>
          <li>|ForDeclaration| 의 BoundNames 에 중복 항목이 있으면 Syntax Error.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-isdestructuring" oldids="sec-static-semantics-static-semantics-isdestructuring,sec-for-in-and-for-of-statements-static-semantics-isdestructuring" type="sdo">
        <h1>정적 의미론: IsDestructuring ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. |PrimaryExpression| 이 |ObjectLiteral| 또는 |ArrayLiteral| 이면 *true* 반환.
          1. 그 외 *false* 반환.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            MemberExpression `.` PrivateIdentifier

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
            OptionalExpression
        </emu-grammar>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| 의 IsDestructuring 반환.
        </emu-alg>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
        <emu-grammar>ForBinding : BindingPattern</emu-grammar>
        <emu-alg>
          1. *true* 반환.
        </emu-alg>
        <emu-note>
          <p>이 절은 부록 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 의해 확장된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginitialization" oldids="sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization" type="sdo">
        <h1>
          런타임 의미론: ForDeclarationBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>_environment_ 로 *undefined* 가 전달되면 PutValue 로 초기화해야 함을 의미한다. 이는 `var` 문 및 일부 비엄격 함수의 매개변수 리스트 경우 ( <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref> 참조 )에 해당한다. 그 경우 렉시컬 바인딩이 초기화자 평가 전 호이스팅·사전 초기화된다.</p>
        </emu-note>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| 의 BindingInitialization(_value_, _environment_) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          런타임 의미론: ForDeclarationBindingInstantiation (
          _environment_: a Declarative Environment Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| 의 BoundNames 각 _name_ 에 대해
            1. IsConstantDeclaration(|LetOrConst|) 이 *true* 이면 ! _environment_.CreateImmutableBinding(_name_, *true*)
            1. 아니면 ! _environment_.CreateMutableBinding(_name_, *false*)
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofloopevaluation" oldids="sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: ForInOfLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~)
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~)
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~)
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~) 반환.
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~) 반환.
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~) 반환.
        </emu-alg>
        <emu-note>
          <p>이 절은 부록 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 의해 확장된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofheadevaluation" type="abstract operation" oldids="sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">
        <h1>
          ForIn/OfHeadEvaluation (
            _uninitializedBoundNames_: a List of Strings,
            _expr_: an |Expression| Parse Node or an |AssignmentExpression| Parse Node,
            _iterationKind_: ~enumerate~, ~iterate~, or ~async-iterate~,
          ): 정상 완료 시 Iterator Record 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _oldEnv_ = 실행 컨텍스트 LexicalEnvironment
          1. _uninitializedBoundNames_ 가 비어있지 않다면
            1. 단언: 중복 없음
            1. _newEnv_ = NewDeclarativeEnvironment(_oldEnv_)
            1. 각 _name_ ∈ _uninitializedBoundNames_ 에 대해
              1. ! _newEnv_.CreateMutableBinding(_name_, *false*)
            1. LexicalEnvironment = _newEnv_
          1. _exprRef_ = _expr_ 평가 Completion
          1. LexicalEnvironment = _oldEnv_
          1. _exprValue_ = ? GetValue(? _exprRef_)
          1. _iterationKind_ 가 ~enumerate~ 이면
            1. _exprValue_ 가 *undefined* 또는 *null* 이면
              1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ } 반환.
            1. _obj_ = ! ToObject(_exprValue_)
            1. _iterator_ = EnumerateObjectProperties(_obj_)
            1. _nextMethod_ = ! GetV(_iterator_, *"next"*)
            1. Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* } 반환.
          1. 그렇지 않으면
            1. 단언: ~iterate~ 또는 ~async-iterate~
            1. _iteratorKind_ = (_iterationKind_ 이 ~async-iterate~ 이면 ~async~ 아니면 ~sync~)
            1. ? GetIterator(_exprValue_, _iteratorKind_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
            _lhs_: a Parse Node,
            _stmt_: a |Statement| Parse Node,
            _iteratorRecord_: an Iterator Record,
            _iterationKind_: ~enumerate~ or ~iterate~,
            _lhsKind_: ~assignment~, ~var-binding~, or ~lexical-binding~,
            _labelSet_: a List of Strings,
            optional _iteratorKind_: ~sync~ or ~async~,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _iteratorKind_가 존재하지 않으면, _iteratorKind_에 ~sync~를 설정한다.
          1. _oldEnv_에 현재 실행 컨텍스트의 LexicalEnvironment를 할당한다.
          1. _V_에 *undefined*를 할당한다.
          1. _destructuring_에 _lhs_의 IsDestructuring 결과를 할당한다.
          1. _destructuring_이 *true*이고 _lhsKind_가 ~assignment~이면,
            1. 단언: _lhs_는 |LeftHandSideExpression|이다.
            1. _assignmentPattern_에 _lhs_가 포함하는 |AssignmentPattern|을 할당한다.
          1. 반복한다,
            1. _nextResult_에 ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]])를 할당한다.
            1. _iteratorKind_가 ~async~이면, _nextResult_에 ? Await(_nextResult_)를 할당한다.
            1. _nextResult_가 Object가 아니면, *TypeError* 예외를 throw한다.
            1. _done_에 ? IteratorComplete(_nextResult_)를 할당한다.
            1. _done_이 *true*라면, _V_를 반환한다.
            1. _nextValue_에 ? IteratorValue(_nextResult_)를 할당한다.
            1. _lhsKind_가 ~assignment~ 또는 ~var-binding~이면,
              1. _destructuring_이 *true*라면,
                1. _lhsKind_가 ~assignment~이면,
                  1. _status_에 Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_)를 할당한다.
                1. 아니면,
                  1. 단언: _lhsKind_는 ~var-binding~이다.
                  1. 단언: _lhs_는 |ForBinding|이다.
                  1. _status_에 Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*)를 할당한다.
              1. 아니면,
                1. _lhsRef_에 Completion(Evaluation of _lhs_)를 할당한다. (반복적으로 평가될 수 있다.)
                1. _lhsKind_가 ~assignment~이고 AssignmentTargetType of _lhs_가 ~web-compat~이면, *ReferenceError* 예외를 throw한다.
                1. _lhsRef_가 abrupt completion이면,
                  1. _status_에 _lhsRef_를 할당한다.
                1. 아니면,
                  1. _status_에 Completion(PutValue(_lhsRef_.[[Value]], _nextValue_))를 할당한다.
            1. 아니면,
              1. 단언: _lhsKind_는 ~lexical-binding~이다.
              1. 단언: _lhs_는 |ForDeclaration|이다.
              1. _iterationEnv_에 NewDeclarativeEnvironment(_oldEnv_)를 할당한다.
              1. ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_를 수행한다.
              1. 현재 실행 컨텍스트의 LexicalEnvironment를 _iterationEnv_로 설정한다.
              1. _destructuring_이 *true*라면,
                1. _status_에 Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_)를 할당한다.
              1. 아니면,
                1. 단언: _lhs_는 단일 이름만을 바인딩한다.
                1. _lhsName_에 _lhs_의 BoundNames의 유일한 요소를 할당한다.
                1. _lhsRef_에 ! ResolveBinding(_lhsName_)을 할당한다.
                1. _status_에 Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_))를 할당한다.
            1. _status_가 abrupt completion이면,
              1. 현재 실행 컨텍스트의 LexicalEnvironment를 _oldEnv_로 설정한다.
              1. _iterationKind_가 ~enumerate~라면,
                1. ? _status_를 반환한다.
              1. 아니면,
                1. 단언: _iterationKind_는 ~iterate~이다.
                1. _iteratorKind_가 ~async~이면, ? AsyncIteratorClose(_iteratorRecord_, _status_)를 반환한다.
                1. ? IteratorClose(_iteratorRecord_, _status_)를 반환한다.
            1. _result_에 Completion(Evaluation of _stmt_)을 할당한다.
            1. 현재 실행 컨텍스트의 LexicalEnvironment를 _oldEnv_로 설정한다.
            1. LoopContinues(_result_, _labelSet_)가 *false*라면,
              1. _status_에 Completion(UpdateEmpty(_result_, _V_))를 할당한다.
              1. _iterationKind_가 ~enumerate~라면,
                1. ? _status_를 반환한다.
              1. 아니면,
                1. 단언: _iterationKind_는 ~iterate~이다.
                1. _iteratorKind_가 ~async~이면, ? AsyncIteratorClose(_iteratorRecord_, _status_)를 반환한다.
                1. ? IteratorClose(_iteratorRecord_, _status_)를 반환한다.
            1. _result_.[[Value]]가 ~empty~가 아니면, _V_에 _result_.[[Value]]를 설정한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>
          BindingIdentifier :
            Identifier
            `yield`
            `await`
        </emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. ? ResolveBinding(_bindingId_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-enumerate-object-properties" type="abstract operation">
        <h1>
          EnumerateObjectProperties (
            _O_: an Object,
          ): iterator 객체
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_ 의 열거 가능한 프로퍼티 중 String 키를 순회하는 `next` 메서드를 가진 iterator 객체를 반환한다. 이 객체는 ECMAScript 코드에서 직접 접근 불가하다. 순서 및 메커니즘은 아래 규칙을 준수해야 한다.
        </emu-alg>
        <p>이 iterator 의 `throw`, `return` 메서드는 *null* 이며 호출되지 않는다. `next` 메서드는 프로퍼티 키 반환 여부를 결정한다. 반환 키에는 Symbol 키 미포함. 대상 객체의 프로퍼티는 열거 중 삭제될 수 있으며 삭제된 프로퍼티는 무시된다. 열거 중 추가된 프로퍼티는 반드시 처리된다고 보장되지 않는다. 한 프로퍼티 이름은 하나의 열거에서 최대 한 번만 반환된다.</p>
        <p>대상 객체 프로퍼티 열거에는 프로토타입 사슬의 프로퍼티도 재귀적으로 포함되지만, 이미 반환된 이름과 동일한 프로토타입 프로퍼티는 무시된다. [[Enumerable]] 값 비교는 중복 판단에 사용되지 않는다. 프로토타입 객체의 열거 가능한 이름은 그 프로토타입을 인수로 EnumerateObjectProperties 를 호출하여 얻어야 한다. 대상 객체의 own keys 는 [[OwnPropertyKeys]] 내부 메서드, 속성 서술자는 [[GetOwnProperty]] 내부 메서드를 통해 얻는다.</p>
        <p>또한 _O_ 나 그 프로토타입 체인 어느 객체도 Proxy/TypedArray/module namespace/exotic (구현 정의) 객체가 아니라면, 다음 사건 중 하나가 발생할 때까지 iterator 는 CreateForInIterator(_O_) 가 준 iterator 처럼 동작해야 한다:</p>
        <ul>
          <li>_O_ 또는 프로토타입 체인 객체의 [[Prototype]] 값 변경</li>
          <li>_O_ 또는 프로토타입 체인 객체에서 프로퍼티 제거</li>
          <li>프로토타입 체인 객체에 프로퍼티 추가</li>
          <li>_O_ 또는 체인 객체 프로퍼티의 [[Enumerable]] 값 변경</li>
        </ul>

        <emu-note>
          <p>구현은 <emu-xref href="#sec-%foriniteratorprototype%.next"></emu-xref> 알고리즘을 직접 구현할 필요는 없다. 위 제약 위반 전까지 동등 동작을 유지하는 임의 구현 가능.</p>
          <p>다음은 이러한 규칙을 만족하는 ECMAScript generator 함수의 예시(정보적):</p>
          <pre><code class="javascript">
            function* EnumerateObjectProperties(obj) {
              const visited = new Set();
              for (const key of Reflect.ownKeys(obj)) {
                if (typeof key === "symbol") continue;
                const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                if (desc) {
                  visited.add(key);
                  if (desc.enumerable) yield key;
                }
              }
              const proto = Reflect.getPrototypeOf(obj);
              if (proto === null) return;
              for (const protoKey of EnumerateObjectProperties(proto)) {
                if (!visited.has(protoKey)) yield protoKey;
              }
            }
          </code></pre>
        </emu-note>
        <emu-note>
          구현이 CreateForInIterator 와 일치할 필요가 없는 exotic 객체 목록은 역사적으로 구현별 차이가 있었던 경우이며 그 외에는 합의된 경우이다.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-iterator-objects">
        <h1>For-In Iterator 객체</h1>
        <p><dfn variants="For-In Iterator object,For-In Iterator objects">For-In Iterator</dfn> 는 특정 객체에 대한 특정 반복을 나타내는 객체이다. ECMAScript 코드에서 직접 접근할 수 없으며 EnumerateObjectProperties 동작 설명용이다.</p>

        <emu-clause id="sec-createforiniterator" type="abstract operation">
          <h1>
            CreateForInIterator (
              _object_: an Object,
            ): For-In Iterator
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_object_ 의 own 및 상속된 열거 가능한 문자열 프로퍼티를 특정 순서로 순회하는 For-In Iterator 를 생성한다.</dd>
          </dl>
          <emu-alg>
            1. _iterator_ = OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »)
            1. _iterator_.[[Object]] = _object_
            1. _iterator_.[[ObjectWasVisited]] = *false*
            1. _iterator_.[[VisitedKeys]] = 새 빈 List
            1. _iterator_.[[RemainingKeys]] = 새 빈 List
            1. _iterator_ 반환
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%foriniteratorprototype%-object">
          <h1>%ForInIteratorPrototype% 객체</h1>
          <p><dfn>%ForInIteratorPrototype%</dfn> 객체:</p>
          <ul>
            <li>모든 For-In Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
            <li>ordinary object 이다.</li>
            <li>[[Prototype]] 슬롯 값은 %Iterator.prototype%.</li>
            <li>ECMAScript 코드에서 직접 접근할 수 없다.</li>
            <li>다음 프로퍼티를 가진다:</li>
          </ul>

          <emu-clause id="sec-%foriniteratorprototype%.next">
            <h1>%ForInIteratorPrototype%.next ( )</h1>
            <emu-alg>
              1. _O_ 를 *this* 값으로 둔다.
              1. 단언: _O_ 는 Object.
              1. 단언: _O_ 는 For-In Iterator 인스턴스 내부 슬롯을 모두 가진다 (<emu-xref href="#sec-properties-of-for-in-iterator-instances"></emu-xref>).
              1. _object_ = _O_.[[Object]]
              1. 반복,
                1. _O_.[[ObjectWasVisited]] *false* 이면
                  1. _keys_ = ? <emu-meta effects="user-code">_object_.[[OwnPropertyKeys]]()</emu-meta>
                  1. 각 _key_ ∈ _keys_ 에 대해
                    1. _key_ 가 String 이면 _O_.[[RemainingKeys]] 에 추가
                  1. _O_.[[ObjectWasVisited]] = *true*
                1. _O_.[[RemainingKeys]] 비어있지 않은 동안 반복
                  1. _r_ = 첫 요소
                  1. 첫 요소 제거
                  1. _O_.[[VisitedKeys]] 에 _r_ 없으면
                    1. _desc_ = ? <emu-meta effects="user-code">_object_.[[GetOwnProperty]]</emu-meta>(_r_)
                    1. _desc_ != *undefined* 이면
                      1. _r_ 를 _O_.[[VisitedKeys]] 에 추가
                      1. _desc_.[[Enumerable]] *true* 이면 CreateIteratorResultObject(_r_, *false*) 반환
                1. _object_ = ? <emu-meta effects="user-code">_object_.[[GetPrototypeOf]]()</emu-meta>
                1. _O_.[[Object]] = _object_
                1. _O_.[[ObjectWasVisited]] = *false*
                1. _object_ 가 *null* 이면 CreateIteratorResultObject(*undefined*, *true*) 반환
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-properties-of-for-in-iterator-instances">
          <h1>For-In Iterator 인스턴스의 프로퍼티</h1>
          <p>For-In Iterator 인스턴스는 %ForInIteratorPrototype% 을 상속하는 ordinary 객체이다. 인스턴스는 <emu-xref href="#table-for-in-iterator-instance-slots"></emu-xref> 의 내부 슬롯을 가진다.</p>
          <emu-table id="table-for-in-iterator-instance-slots" caption="For-In Iterator 인스턴스의 내부 슬롯">
            <table>
              <thead>
                <tr>
                  <th>
                    Internal Slot
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    설명
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  [[Object]]
                </td>
                <td>
                  an Object
                </td>
                <td>
                  현재 프로퍼티를 열거 중인 객체.
                </td>
              </tr>
              <tr>
                <td>
                  [[ObjectWasVisited]]
                </td>
                <td>
                  a Boolean
                </td>
                <td>
                  iterator 가 [[OwnPropertyKeys]] 를 호출했으면 *true*, 아니면 *false*.
                </td>
              </tr>
              <tr>
                <td>
                  [[VisitedKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  지금까지 방출된 값들.
                </td>
              </tr>
              <tr>
                <td>
                  [[RemainingKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  현재 객체에서 아직 방출되지 않은 값들 (프로토타입 열거 전).
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-continue-statement">
    <h1>`continue` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ContinueStatement[Yield, Await] :
        `continue` `;`
        `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-continue-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>
        ContinueStatement :
          `continue` `;`
          `continue` LabelIdentifier `;`
      </emu-grammar>
      <ul>
        <li>
          이 |ContinueStatement| 가 (함수나 `static` 초기화 블록 경계를 넘지 않고) 직접 또는 간접적으로 |IterationStatement| 내에 중첩되지 않았다면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-continue-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ } 반환.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _label_ = |LabelIdentifier| 의 StringValue
        1. Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ } 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-break-statement">
    <h1>`break` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BreakStatement[Yield, Await] :
        `break` `;`
        `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-break-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <ul>
        <li>
          이 |BreakStatement| 가 (함수나 `static` 초기화 블록 경계를 넘지 않고) 직접 또는 간접적으로 |IterationStatement| 또는 |SwitchStatement| 안에 중첩되지 않았다면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-break-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ } 반환.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _label_ = |LabelIdentifier| 의 StringValue
        1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ } 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-return-statement">
    <h1>`return` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ReturnStatement[Yield, Await] :
        `return` `;`
        `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>`return` 문은 함수를 종료하고(대부분 경우) 호출자에게 값을 반환한다. |Expression| 이 없으면 반환 값은 *undefined*. 있으면 그 표현식의 값. `return` 문이 주변 컨텍스트에 따라 실제로 호출자에게 값을 반환하지 않을 수도 있다. 예: `try` 블록 내 `return` 의 Completion Record 는 `finally` 블록 평가 중 다른 Completion Record 로 대체될 수 있다.</p>
    </emu-note>

    <emu-clause id="sec-return-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>ReturnStatement : `return` `;`</emu-grammar>
      <emu-alg>
        1. ReturnCompletion(*undefined*) 반환.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ = |Expression| 평가 결과 (?)
        1. _exprValue_ = ? GetValue(_exprRef_)
        1. GetGeneratorKind() 가 ~async~ 이면 _exprValue_ = ? Await(_exprValue_)
        1. ReturnCompletion(_exprValue_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-with-statement" legacy>
    <h1>`with` 문</h1>
    <emu-note>
      <p>레거시 `with` 문 사용은 새로운 ECMAScript 코드에서 권장되지 않는다. 엄격/비엄격 모두 허용되는 <emu-xref href="#sec-destructuring-assignment">구조 분해 할당</emu-xref> 등의 대안을 고려하라.</p>
    </emu-note>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WithStatement[Yield, Await, Return] :
        `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <emu-note>
      <p>`with` 문은 계산된 객체에 대한 Object Environment Record 를 실행 컨텍스트의 렉시컬 환경에 추가한 후 그 확장된 환경으로 문을 실행하고 마지막에 원래 환경을 복구한다.</p>
    </emu-note>

    <emu-clause id="sec-with-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          IsStrict(this production) *true* 이면 Syntax Error.
        </li>
        <li>
          IsLabelledFunction(|Statement|) *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-note>
        <p>두 번째 규칙은 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-with-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _val_ = |Expression| 평가 결과 (?)
        1. _obj_ = ? ToObject(? GetValue(_val_))
        1. _oldEnv_ = 현재 LexicalEnvironment
        1. _newEnv_ = NewObjectEnvironment(_obj_, *true*, _oldEnv_)
        1. LexicalEnvironment = _newEnv_
        1. _C_ = |Statement| 평가 Completion
        1. LexicalEnvironment = _oldEnv_
        1. ? UpdateEmpty(_C_, *undefined*) 반환
      </emu-alg>
      <emu-note>
        <p>임의의 경로로 embedded |Statement| 를 빠져나와도(정상/abrupt) LexicalEnvironment 는 항상 복원된다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>`switch` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SwitchStatement[Yield, Await, Return] :
        `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]

      CaseBlock[Yield, Await, Return] :
        `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
        `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`

      CaseClauses[Yield, Await, Return] :
        CaseClause[?Yield, ?Await, ?Return]
        CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

      CaseClause[Yield, Await, Return] :
        `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?

      DefaultClause[Yield, Await, Return] :
        `default` `:` StatementList[?Yield, ?Await, ?Return]?
    </emu-grammar>

    <emu-clause id="sec-switch-statement-static-semantics-early-errors" oldids="sec-switch-duplicates-allowed-static-semantics">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <ul>
        <li>
          <p>|CaseBlock| 의 LexicallyDeclaredNames 에 중복 항목이 있으면 Syntax Error<span normative-optional> — 단, 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하고 두 조건이 모두 참이면 예외:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) *false*</li>
            <li>중복 항목이 FunctionDeclaration 에 의해서만 바인딩</li>
          </ul>
        </li>
        <li>
          |CaseBlock| 의 LexicallyDeclaredNames 요소가 |CaseBlock| 의 VarDeclaredNames 에도 나타나면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseblockevaluation" type="sdo">
      <h1>
        런타임 의미론: CaseBlockEvaluation (
        _input_: an ECMAScript language value,
        ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *undefined* 반환.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses `}`</emu-grammar>
      <emu-alg>
        1. _V_ = *undefined*
        1. _A_ = |CaseClauses| 내 |CaseClause| 리스트 (소스 순서)
        1. _found_ = *false*
        1. 각 _C_ ∈ _A_ 에 대해
          1. _found_ *false* 이면 _found_ = ? CaseClauseIsSelected(_C_, _input_)
          1. _found_ *true* 이면
            1. _R_ = _C_ 평가 Completion
            1. _R_.[[Value]] 가 ~empty~ 아니면 _V_ 갱신
            1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _V_ 반환.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _V_ = *undefined*
        1. 첫 |CaseClauses| 존재하면 _A_ = 그 |CaseClause| 리스트; 아니면 새 빈 List
        1. _found_ = *false*
        1. 각 _C_ ∈ _A_ 에 대해
          1. _found_ *false* 이면 _found_ = ? CaseClauseIsSelected(_C_, _input_)
          1. _found_ *true* 이면
            1. _R_ = _C_ 평가 Completion
            1. _R_.[[Value]] ~empty~ 아니면 _V_ 갱신
            1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _foundInB_ = *false*
        1. 두 번째 |CaseClauses| 존재하면 _B_ = 그 리스트; 아니면 빈 List
        1. _found_ *false* 이면
          1. 각 _C_ ∈ _B_ 에 대해
            1. _foundInB_ *false* 이면 _foundInB_ = ? CaseClauseIsSelected(_C_, _input_)
            1. _foundInB_ *true* 이면
              1. _R_ = _C_ 평가 Completion
              1. _R_.[[Value]] ~empty~ 아니면 _V_ 갱신
              1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _foundInB_ *true* 이면 _V_ 반환
        1. _defaultR_ = |DefaultClause| 평가 Completion
        1. _defaultR_.[[Value]] ~empty~ 아니면 _V_ 갱신
        1. _defaultR_ abrupt 이면 ? UpdateEmpty(_defaultR_, _V_) 반환
        1. (두 번째 |CaseClauses| 전체 재순회)
        1. 각 _C_ ∈ _B_ 에 대해
          1. _R_ = _C_ 평가 Completion
          1. _R_.[[Value]] ~empty~ 아니면 _V_ 갱신
          1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _V_ 반환
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseclauseisselected" type="abstract operation" oldids="sec-runtime-semantics-caseselectorevaluation">
      <h1>
        CaseClauseIsSelected (
          _C_: a |CaseClause| Parse Node,
          _input_: an ECMAScript language value,
        ): 정상 완료 시 Boolean 또는 abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_C_ 가 _input_ 과 일치하는지 결정한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _C_ 는 <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar> 인스턴스.
        1. _exprRef_ = _C_ 의 |Expression| 평가 결과 (?)
        1. _clauseSelector_ = ? GetValue(_exprRef_)
        1. IsStrictlyEqual(_input_, _clauseSelector_) 반환.
      </emu-alg>
      <emu-note>
        <p>이 연산은 _C_ 의 |StatementList| (있다면)를 실행하지 않는다. |CaseBlock| 알고리즘은 반환값을 사용해 어느 |StatementList| 부터 실행할지 결정한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. _exprRef_ = |Expression| 평가 결과 (?)
        1. _switchValue_ = ? GetValue(_exprRef_)
        1. _oldEnv_ = 현재 LexicalEnvironment
        1. _blockEnv_ = NewDeclarativeEnvironment(_oldEnv_)
        1. BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_) 수행
        1. LexicalEnvironment = _blockEnv_
        1. _R_ = CaseBlockEvaluation(|CaseBlock|, _switchValue_) 의 Completion
        1. LexicalEnvironment = _oldEnv_
        1. _R_ 반환
      </emu-alg>
      <emu-note>
        <p>|SwitchStatement| 를 어떻게 빠져나오든 LexicalEnvironment 는 복구된다.</p>
      </emu-note>
      <emu-grammar>CaseClause : `case` Expression `:`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| 평가 결과를 ? 로 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-labelled-statements">
    <h1>Labelled Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LabelledStatement[Yield, Await, Return] :
        LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]

      LabelledItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        FunctionDeclaration[?Yield, ?Await, ~Default]
    </emu-grammar>
    <emu-note>
      <p>|Statement| 는 레이블로 접두될 수 있다. 레이블 문은 레이블된 `break`/`continue` 와 함께 사용된다. ECMAScript 에는 `goto` 가 없다. |Statement| 는 |LabelledStatement| 의 일부가 될 수 있고 이것이 또 다른 |LabelledStatement| 의 일부가 되는 식으로 중첩될 수 있다. 이렇게 도입된 레이블 집합을 개별 문 의미론에서 “current label set” 이라 부른다.</p>
    </emu-note>

    <emu-clause id="sec-labelled-statements-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>
          이 생성물에 매칭되는 소스 텍스트가 있다면 Syntax Error<span normative-optional> — 단, 그 소스가 비엄격 코드이고 호스트가 <emu-xref href="#sec-labelled-function-declarations" title></emu-xref> 를 지원하면 예외.</span>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-islabelledfunction" type="abstract operation">
      <h1>
        정적 의미론: IsLabelledFunction (
        _stmt_: a |Statement| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _stmt_ 가 |LabelledStatement| 아니면 *false* 반환.
        1. _item_ = _stmt_ 의 |LabelledItem|
        1. _item_ 이 <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar> 이면 *true* 반환.
        1. _subStmt_ = _item_ 의 |Statement|
        1. IsLabelledFunction(_subStmt_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 이 |LabelledStatement| 의 LabelledEvaluation(« ») 결과를 ? 로 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-labelledevaluation" oldids="sec-statement-semantics-runtime-semantics-labelledevaluation,sec-labelled-statements-runtime-semantics-labelledevaluation" type="sdo">
      <h1>
        런타임 의미론: LabelledEvaluation (
        _labelSet_: a List of Strings,
        ): 정상 완료 시 ECMAScript 값 또는 ~empty~, 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ = Completion(LoopEvaluation(|IterationStatement|, _labelSet_))
        1. _stmtResult_ 가 break completion 이고 _stmtResult_.[[Target]] 이 ~empty~ 이면
          1. _stmtResult_.[[Value]] 가 ~empty~ 이면 _stmtResult_ = NormalCompletion(*undefined*)
          1. 아니면 _stmtResult_ = NormalCompletion(_stmtResult_.[[Value]])
        1. ? _stmtResult_ 반환
      </emu-alg>
      <emu-grammar>BreakableStatement : SwitchStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ = Completion(Evaluation(|SwitchStatement|))
        1. _stmtResult_ 가 break completion 이고 _stmtResult_.[[Target]] 이 ~empty~ 이면
          1. _stmtResult_.[[Value]] ~empty~ 이면 _stmtResult_ = NormalCompletion(*undefined*) 아니면 NormalCompletion(_stmtResult_.[[Value]])
        1. ? _stmtResult_ 반환
      </emu-alg>
      <emu-note>
        <p>|BreakableStatement| 는 레이블 없는 |BreakStatement| 로 빠져나올 수 있는 문이다.</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ = |LabelIdentifier| 의 StringValue
        1. _newLabelSet_ = _labelSet_ ⧺ « _label_ »
        1. _stmtResult_ = Completion(LabelledEvaluation(|LabelledItem|, _newLabelSet_))
        1. _stmtResult_ 가 break completion 이고 _stmtResult_.[[Target]] = _label_ 이면
          1. _stmtResult_ = NormalCompletion(_stmtResult_.[[Value]])
        1. ? _stmtResult_ 반환
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-grammar>
        Statement :
          BlockStatement
          VariableStatement
          EmptyStatement
          ExpressionStatement
          IfStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          WithStatement
          ThrowStatement
          TryStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. |Statement| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-note>
        <p>|Statement| 의 production 중 LabelledEvaluation 에 특별한 의미론을 갖는 것은 |BreakableStatement| 와 |LabelledStatement| 두 가지뿐이다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-throw-statement">
    <h1>`throw` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ThrowStatement[Yield, Await] :
        `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-throw-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>ThrowStatement : `throw` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ = |Expression| 평가 결과 (?)
        1. _exprValue_ = ? GetValue(_exprRef_)
        1. ThrowCompletion(_exprValue_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-try-statement">
    <h1>`try` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      TryStatement[Yield, Await, Return] :
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

      Catch[Yield, Await, Return] :
        `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
        `catch` Block[?Yield, ?Await, ?Return]

      Finally[Yield, Await, Return] :
        `finally` Block[?Yield, ?Await, ?Return]

      CatchParameter[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`try` 문은 런타임 오류나 `throw` 등 예외 상황이 발생할 수 있는 코드 블록을 감싼다. `catch` 절은 예외 처리 코드를 제공한다. catch 절이 예외를 잡으면 |CatchParameter| 에 그 예외 값이 바인딩된다.</p>
    </emu-note>

    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>|CatchParameter| 의 BoundNames 에 중복 요소가 있으면 Syntax Error.</li>
        <li>|CatchParameter| 의 BoundNames 요소가 |Block| 의 LexicallyDeclaredNames 에도 있으면 Syntax Error.</li>
        <li>|CatchParameter| 의 BoundNames 요소가 |Block| 의 VarDeclaredNames 에도 있으면 Syntax Error<span normative-optional> — 단, |CatchParameter| 가 <emu-grammar>CatchParameter : BindingIdentifier</emu-grammar> 이고 호스트가 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> 를 지원하면 예외.</span></li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-catchclauseevaluation" type="sdo">
      <h1>
        런타임 의미론: CatchClauseEvaluation (
        _thrownValue_: an ECMAScript language value,
        ): 정상 완료 시 ECMAScript 값 또는 ~empty~, 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. _oldEnv_ = 현재 LexicalEnvironment
        1. _catchEnv_ = NewDeclarativeEnvironment(_oldEnv_)
        1. |CatchParameter| 의 BoundNames 각 _argName_ 에 대해
          1. ! _catchEnv_.CreateMutableBinding(_argName_, *false*)
        1. LexicalEnvironment = _catchEnv_
        1. _status_ = Completion(BindingInitialization(|CatchParameter|, _thrownValue_, _catchEnv_))
        1. _status_ abrupt 이면
          1. LexicalEnvironment = _oldEnv_
          1. ? _status_ 반환
        1. _B_ = |Block| 평가 Completion
        1. LexicalEnvironment = _oldEnv_
        1. ? _B_ 반환
      </emu-alg>
      <emu-grammar>Catch : `catch` Block</emu-grammar>
      <emu-alg>
        1. |Block| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-note>
        <p>|Block| 을 어떻게 빠져나오든 LexicalEnvironment 는 복구된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _B_ = |Block| 평가 Completion
        1. _B_ 가 throw completion 이면 _C_ = Completion(CatchClauseEvaluation(|Catch|, _B_.[[Value]])); 아니면 _C_ = _B_
        1. ? UpdateEmpty(_C_, *undefined*) 반환
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _B_ = |Block| 평가 Completion
        1. _F_ = |Finally| 평가 Completion
        1. _F_ 가 normal completion 이면 _F_ = _B_
        1. ? UpdateEmpty(_F_, *undefined*) 반환
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _B_ = |Block| 평가 Completion
        1. _B_ 가 throw completion 이면 _C_ = Completion(CatchClauseEvaluation(|Catch|, _B_.[[Value]])); 아니면 _C_ = _B_
        1. _F_ = |Finally| 평가 Completion
        1. _F_ 가 normal completion 이면 _F_ = _C_
        1. ? UpdateEmpty(_F_, *undefined*) 반환
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-debugger-statement">
    <h1>`debugger` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      DebuggerStatement :
        `debugger` `;`
    </emu-grammar>

    <emu-clause id="sec-debugger-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-note>
        <p>|DebuggerStatement| 를 평가하면 구현이 디버거 실행 시 중단점을 걸 수 있게 할 수 있다. 디버거가 없거나 비활성화된 경우 관찰 가능한 효과가 없다.</p>
      </emu-note>
      <emu-grammar>DebuggerStatement : `debugger` `;`</emu-grammar>
      <emu-alg>
        1. 구현 정의 디버깅 기능이 활성화되어 있으면
          1. 구현 정의 디버깅 동작 수행.
          1. 새 구현 정의 Completion Record 반환.
        1. 그렇지 않으면
          1. ~empty~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript 언어: 함수와 클래스(Functions and Classes)</h1>
  <emu-note>
    <p>다양한 ECMAScript 언어 요소는 ECMAScript 함수 객체(<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>)를 생성한다. 그러한 함수들의 평가(evaluation)는 그들의 [[Call]] 내부 메서드(<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>) 실행으로 시작한다.</p>
  </emu-note>

  <emu-clause id="sec-parameter-lists">
    <h1>매개변수 목록(Parameter Lists)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UniqueFormalParameters[Yield, Await] :
        FormalParameters[?Yield, ?Await]

      FormalParameters[Yield, Await] :
        [empty]
        FunctionRestParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,`
        FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]

      FormalParameterList[Yield, Await] :
        FormalParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]

      FunctionRestParameter[Yield, Await] :
        BindingRestElement[?Yield, ?Await]

      FormalParameter[Yield, Await] :
        BindingElement[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-parameter-lists-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
      <ul>
        <li>|FormalParameters| 의 BoundNames 에 중복 요소가 있으면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>FormalParameters : FormalParameterList</emu-grammar>
      <ul>
        <li>IsSimpleParameterList(|FormalParameterList|) 가 *false* 이고 BoundNames(|FormalParameterList|) 에 중복 요소가 있으면 Syntax Error 이다.</li>
      </ul>
      <emu-note>
        <p>같은 |BindingIdentifier| 의 다중 출현은 간단한(simple) 매개변수 리스트를 가지며 엄격 모드 코드에서 정의되지 않은 함수에 대해서만 허용된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsexpression" oldids="sec-destructuring-binding-patterns-static-semantics-containsexpression,sec-function-definitions-static-semantics-containsexpression,sec-arrow-function-definitions-static-semantics-containsexpression,sec-async-arrow-function-definitions-static-semantics-ContainsExpression" type="sdo">
      <h1>정적 의미론: ContainsExpression ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectBindingPattern :
          `{` `}`
          `{` BindingRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. |BindingPropertyList| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingRestElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. _has_ 를 |BindingElementList| 의 ContainsExpression 결과로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingRestElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. _has_ 를 |BindingPropertyList| 의 ContainsExpression 결과로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingProperty| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. _has_ 를 |BindingElementList| 의 ContainsExpression 결과로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingElisionElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. _has_ 를 IsComputedPropertyKey(|PropertyName|) 로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. |BindingPattern| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| 의 ContainsExpression 이 *true* 이면 *true* 반환.
        1. |FunctionRestParameter| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| 의 ContainsExpression 이 *true* 이면 *true* 반환.
        1. |FormalParameter| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ArrowFormalParameters| 로 둔다.
        1. _formals_ 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-issimpleparameterlist" oldids="sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist,sec-function-definitions-static-semantics-issimpleparameterlist,sec-arrow-function-definitions-static-semantics-issimpleparameterlist,sec-async-arrow-function-definitions-static-semantics-IsSimpleParameterList" type="sdo">
      <h1>정적 의미론: IsSimpleParameterList ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. IsSimpleParameterList(|FormalParameterList|) 가 *false* 이면 *false* 반환.
        1. IsSimpleParameterList(|FormalParameter|) 반환.
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. IsSimpleParameterList(|BindingElement|) 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ArrowFormalParameters| 로 둔다.
        1. IsSimpleParameterList(_formals_) 반환.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. _head_ 를 |CoverCallExpressionAndAsyncArrowHead| 가 커버하는 |AsyncArrowHead| 로 둔다.
        1. IsSimpleParameterList(_head_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasinitializer" oldids="sec-destructuring-binding-patterns-static-semantics-hasinitializer,sec-function-definitions-static-semantics-hasinitializer" type="sdo">
      <h1>정적 의미론: HasInitializer ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. HasInitializer(|FormalParameterList|) 가 *true* 이면 *true* 반환.
        1. HasInitializer(|FormalParameter|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-expectedargumentcount" oldids="sec-function-definitions-static-semantics-expectedargumentcount,sec-arrow-function-definitions-static-semantics-expectedargumentcount,sec-method-definitions-static-semantics-expectedargumentcount,sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount" type="sdo">
      <h1>정적 의미론: ExpectedArgumentCount ( ): 음이 아닌 정수</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FormalParameters :
          [empty]
          FunctionRestParameter
      </emu-grammar>
      <emu-alg>
        1. 0 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| 의 ExpectedArgumentCount 반환.
      </emu-alg>
      <emu-note>
        <p>|FormalParameterList| 의 ExpectedArgumentCount 는 나머지(rest) 매개변수 또는 Initializer 를 가진 첫 번째 |FormalParameter| 의 왼쪽에 있는 |FormalParameters| 의 개수이다. 초기화자가 있는 첫 매개변수 뒤에 초기화자 없는 매개변수가 올 수 있지만 그러한 매개변수들은 *undefined* 를 기본값으로 갖는 선택(optional) 매개변수로 간주된다.</p>
      </emu-note>
      <emu-grammar>FormalParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. HasInitializer(|FormalParameter|) 가 *true* 이면 0 반환.
        1. 1 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. _count_ 를 |FormalParameterList| 의 ExpectedArgumentCount 로 둔다.
        1. HasInitializer(|FormalParameterList|) 가 *true* 이거나 HasInitializer(|FormalParameter|) 가 *true* 이면 _count_ 반환.
        1. _count_ + 1 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 1 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ArrowFormalParameters| 로 둔다.
        1. _formals_ 의 ExpectedArgumentCount 반환.
      </emu-alg>
      <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. HasInitializer(|FormalParameter|) 가 *true* 이면 0 반환.
        1. 1 반환.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 1 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-definitions">
    <h1>함수 정의(Function Definitions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      FunctionDeclaration[Yield, Await, Default] :
        `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionExpression :
        `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionBody[Yield, Await] :
        FunctionStatementList[?Yield, ?Await]

      FunctionStatementList[Yield, Await] :
        StatementList[?Yield, ?Await, +Return]?
    </emu-grammar>

    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(|FormalParameters|) 가 *true* 이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 의 조기 오류 규칙을 적용한다.
        </li>
        <li>
          |BindingIdentifier| 가 존재하고 IsStrict(|BindingIdentifier|) 가 *true* 이면 |BindingIdentifier| 의 StringValue 가 *"eval"* 이거나 *"arguments"* 인 경우 Syntax Error 이다.
        </li>
        <li>
          FunctionBodyContainsUseStrict(|FunctionBody|) 가 *true* 이고 IsSimpleParameterList(|FormalParameters|) 가 *false* 이면 Syntax Error 이다.
        </li>
        <li>
          |FormalParameters| 의 BoundNames 요소 중 어떤 것도 |FunctionBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.
        </li>
        <li>
          |FormalParameters| Contains |SuperProperty| 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          |FunctionBody| Contains |SuperProperty| 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          |FormalParameters| Contains |SuperCall| 이 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          |FunctionBody| Contains |SuperCall| 이 *true* 이면 Syntax Error 이다.
        </li>
      </ul>
      <emu-note>
        <p>|FunctionBody| 의 LexicallyDeclaredNames 는 var 혹은 function 선언으로 바인딩된 식별자를 포함하지 않는다.</p>
      </emu-note>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <ul>
        <li>
          |FunctionStatementList| 의 LexicallyDeclaredNames 에 중복 항목이 있으면 Syntax Error 이다.
        </li>
        <li>
          |FunctionStatementList| 의 LexicallyDeclaredNames 요소 중 어떤 것도 |FunctionStatementList| 의 VarDeclaredNames 에 존재하면 Syntax Error 이다.
        </li>
        <li>
          ContainsDuplicateLabels(|FunctionStatementList|, « ») 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          ContainsUndefinedBreakTarget(|FunctionStatementList|, « ») 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          ContainsUndefinedContinueTarget(|FunctionStatementList|, « », « ») 가 *true* 이면 Syntax Error 이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-functionbodycontainsusestrict" oldids="sec-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>정적 의미론: FunctionBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. |FunctionBody| 의 Directive Prologue 에 Use Strict Directive 가 포함되어 있으면 *true* 반환; 그렇지 않으면 *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluatefunctionbody" oldids="sec-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateFunctionBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): return completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. ? |FunctionStatementList| 의 Evaluation 수행.
        1. NOTE: 이전 단계가 정상 completion 을 반환했다면 |FunctionStatementList| 끝을 통과하여 평가가 종료된 것이다.
        1. ReturnCompletion(*undefined*) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionobject" oldids="sec-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateOrdinaryFunctionObject (
        _env_: an Environment Record,
        _privateEnv_: a PrivateEnvironment Record 또는 *null*,
        ): ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _sourceText_ 를 |FunctionDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, _name_) 수행.
        1. MakeConstructor(_F_) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _sourceText_ 를 |FunctionDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, *"default"*) 수행.
        1. MakeConstructor(_F_) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-note>
        <p>익명 |FunctionDeclaration| 은 오직 `export default` 선언의 일부로만 나타날 수 있으며 그 함수 코드는 항상 strict mode 코드이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateOrdinaryFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""*.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |FunctionExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. MakeConstructor(_closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 단언: _name_ 은 존재하지 않는다.
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _outerEnv_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _funcEnv_ 를 NewDeclarativeEnvironment(_outerEnv_) 로 둔다.
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) 수행.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |FunctionExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. MakeConstructor(_closure_) 수행.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|FunctionExpression| 의 |BindingIdentifier| 는 그 |FunctionExpression| 의 |FunctionBody| 내부에서 참조되어 재귀 호출을 가능하게 한다. 그러나 |FunctionDeclaration| 과 달리 |FunctionExpression| 의 |BindingIdentifier| 는 |FunctionExpression| 을 둘러싼 외부 스코프에서 참조할 수 없고 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-note>
        <p>대체 의미론은 FunctionDeclarationInstantiation 의 단계 <emu-xref href="#step-functiondeclarationinstantiation-alt-funcdecl-eval"></emu-xref>, GlobalDeclarationInstantiation 의 단계 <emu-xref href="#step-globaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref>, EvalDeclarationInstantiation 의 단계 <emu-xref href="#step-evaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> 에서 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 에 의해 제공된다.</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>
        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |FunctionExpression| 의 InstantiateOrdinaryFunctionExpression 반환.
      </emu-alg>
      <emu-note>
        <p>|FunctionDeclaration| 또는 |FunctionExpression| 으로 정의된 모든 함수에 대해 *"prototype"* 프로퍼티가 자동으로 생성되어 그 함수가 생성자로 사용될 가능성을 허용한다.</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined* 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>화살표 함수 정의(Arrow Function Definitions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ArrowFunction[In, Yield, Await] :
        ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

      ArrowParameters[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      ConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, ~Await]
        `{` FunctionBody[~Yield, ~Await] `}`

      ExpressionBody[In, Await] :
        AssignmentExpression[?In, ~Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>
      생성물 인스턴스<br>
      <emu-grammar>ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      를 처리할 때 |CoverParenthesizedExpressionAndArrowParameterList| 의 해석은 다음 문법을 사용해 정밀화된다:
    </p>
    <emu-grammar type="definition">
      ArrowFormalParameters[Yield, Await] :
        `(` UniqueFormalParameters[?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <ul>
        <li>
          |ArrowParameters| Contains |YieldExpression| 이 *true* 이면 Syntax Error.
        </li>
        <li>
          |ArrowParameters| Contains |AwaitExpression| 이 *true* 이면 Syntax Error.
        </li>
        <li>
          ConciseBodyContainsUseStrict(|ConciseBody|) 가 *true* 이고 IsSimpleParameterList(|ArrowParameters|) 가 *false* 이면 Syntax Error.
        </li>
        <li>
          |ArrowParameters| 의 BoundNames 요소 중 어떤 것도 |ConciseBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <ul>
        <li>
          |CoverParenthesizedExpressionAndArrowParameterList| 는 |ArrowFormalParameters| 를 커버해야 한다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-concisebodycontainsusestrict" oldids="sec-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>정적 의미론: ConciseBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ConciseBody : `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. FunctionBodyContainsUseStrict(|FunctionBody|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateconcisebody" oldids="sec-arrow-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateConciseBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): return completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. |ExpressionBody| 의 Evaluation 결과를 ? 로 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiatearrowfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateArrowFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""*.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |ArrowFunction| 이 매칭한 소스 텍스트로 둔다.
        1. [id="step-arrowfunction-evaluation-functioncreate"] _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|ArrowFunction| 은 `arguments`, `super`, `this`, `new.target` 에 대한 지역 바인딩을 정의하지 않는다. |ArrowFunction| 내부의 이러한 식별자 참조는 렉시컬 외부 환경의 바인딩으로 해석되어야 한다. 일반적으로 이는 바로 둘러싼 함수의 Function Environment 가 된다. 비록 |ArrowFunction| 이 `super` 를 포함할 수 있지만 단계 <emu-xref href="#step-arrowfunction-evaluation-functioncreate"></emu-xref> 에서 생성된 함수 객체는 MakeMethod 를 수행하여 메서드로 만들지 않는다. `super` 를 참조하는 |ArrowFunction| 은 항상 비-|ArrowFunction| 안에 포함되며, `super` 구현에 필요한 상태는 캡처된 _env_ 를 통해 접근 가능하다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. |ArrowFunction| 의 InstantiateArrowFunctionExpression 반환.
      </emu-alg>
      <emu-grammar>ExpressionBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |AssignmentExpression| 평가 결과 (?) 로 둔다.
        1. _exprValue_ 를 ? GetValue(_exprRef_) 로 둔다.
        1. ReturnCompletion(_exprValue_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>메서드 정의(Method Definitions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MethodDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        GeneratorMethod[?Yield, ?Await]
        AsyncMethod[?Yield, ?Await]
        AsyncGeneratorMethod[?Yield, ?Await]
        `get` ClassElementName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
        `set` ClassElementName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

      PropertySetParameterList :
        FormalParameter[~Yield, ~Await]
    </emu-grammar>

    <emu-clause id="sec-method-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          FunctionBodyContainsUseStrict(|FunctionBody|) 가 *true* 이고 IsSimpleParameterList(|UniqueFormalParameters|) 가 *false* 이면 Syntax Error.
        </li>
        <li>
          |UniqueFormalParameters| 의 BoundNames 요소 중 어떤 것도 |FunctionBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          |PropertySetParameterList| 의 BoundNames 에 중복 요소가 있으면 Syntax Error.
        </li>
        <li>
          FunctionBodyContainsUseStrict(|FunctionBody|) 가 *true* 이고 IsSimpleParameterList(|PropertySetParameterList|) 가 *false* 이면 Syntax Error.
        </li>
        <li>
          |PropertySetParameterList| 의 BoundNames 요소 중 어떤 것도 |FunctionBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasdirectsuper" oldids="sec-method-definitions-static-semantics-hasdirectsuper,sec-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-function-definitions-static-semantics-HasDirectSuper" type="sdo">
      <h1>정적 의미론: HasDirectSuper ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |FunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |FunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |PropertySetParameterList| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |FunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |GeneratorBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |AsyncGeneratorBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |AsyncFunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-specialmethod" type="sdo">
      <h1>정적 의미론: SpecialMethod ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          GeneratorMethod
          AsyncMethod
          AsyncGeneratorMethod
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-definemethod" type="sdo">
      <h1>
        런타임 의미론: DefineMethod (
        _object_: an Object,
        optional _functionPrototype_: an Object,
        ): 정상 completion (필드 [[Key]](property key), [[Closure]](ECMAScript function object)) 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _functionPrototype_ 이 존재하면
          1. _prototype_ = _functionPrototype_
        1. 그렇지 않으면
          1. _prototype_ = %Function.prototype%
        1. _sourceText_ 를 |MethodDefinition| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. Record { [[Key]]: _propKey_, [[Closure]]: _closure_ } 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-methoddefinitionevaluation" oldids="sec-method-definitions-runtime-semantics-propertydefinitionevaluation,sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation,sec-asyncgenerator-definitions-propertydefinitionevaluation,sec-async-function-definitions-PropertyDefinitionEvaluation" type="sdo">
      <h1>
        런타임 의미론: MethodDefinitionEvaluation (
        _object_: an Object,
        _enumerable_: a Boolean,
        ): 정상 completion (PrivateElement 또는 ~unused~) 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _methodDef_ 를 |MethodDefinition| 의 DefineMethod(_object_) 결과 (?) 로 둔다.
        1. SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]) 수행.
        1. ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_) 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |MethodDefinition| 이 매칭한 소스 텍스트로 둔다.
        1. _formalParameterList_ 를 <emu-grammar>FormalParameters : [empty]</emu-grammar> 생성물 인스턴스로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_, *"get"*) 수행.
        1. _propKey_ 가 Private Name 이면
          1. PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* } 반환.
        1. 그렇지 않으면
          1. _desc_ = PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
          1. ? DefinePropertyOrThrow(_object_, _propKey_, _desc_) 수행.
          1. ~unused~ 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |MethodDefinition| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_, *"set"*) 수행.
        1. _propKey_ 가 Private Name 이면
          1. PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ } 반환.
        1. 그렇지 않으면
          1. _desc_ = PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
          1. ? DefinePropertyOrThrow(_object_, _propKey_, _desc_) 수행.
          1. ~unused~ 반환.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |GeneratorMethod| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) 반환.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |AsyncGeneratorMethod| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) 반환.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |AsyncMethod| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_) 수행.
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>제너레이터 함수 정의 (Generator Function Definitions)</h1>
    <h2>구문 (Syntax)</h2>
    <emu-grammar type="definition">
      GeneratorDeclaration[Yield, Await, Default] :
        `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
        [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorExpression :
        `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorMethod[Yield, Await] :
        `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorBody :
        FunctionBody[+Yield, ~Await]

      YieldExpression[In, Await] :
        `yield`
        `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`yield` 바로 뒤의 문맥은 |InputElementRegExpOrTemplateTail| 어휘 목표(lexical goal)를 사용해야 한다.</p>
    </emu-note>
    <emu-note>
      <p>|YieldExpression| 은 제너레이터 함수의 |FormalParameters| 안에서 사용할 수 없다. 그 이유는 |FormalParameters| 에 속하는 모든 표현식이, 생성된 Generator 가 재개(resumable) 가능한 상태가 되기 이전에 평가되기 때문이다.</p>
    </emu-note>
    <emu-note>
      <p>Generator 와 관련된 추상 연산은 <emu-xref href="#sec-generator-abstract-operations"></emu-xref> 에 정의되어 있다.</p>
    </emu-note>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류 (Static Semantics: Early Errors)</h1>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <ul>
        <li>|GeneratorMethod| 의 HasDirectSuper 가 *true* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|GeneratorBody|) 가 *true* 이고 IsSimpleParameterList(|UniqueFormalParameters|) 가 *false* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 의 BoundNames 요소 중 하나라도 |GeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>IsStrict(|FormalParameters|) 가 *true* 이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 에 대한 조기 오류 규칙을 적용한다.</li>
        <li>|BindingIdentifier| 가 존재하고 IsStrict(|BindingIdentifier|) 가 *true* 이면 그 StringValue 가 *"eval"* 또는 *"arguments"* 인 경우 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|GeneratorBody|) 가 *true* 이고 IsSimpleParameterList(|FormalParameters|) 가 *false* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 의 BoundNames 요소 중 하나라도 |GeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|GeneratorBody| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|GeneratorBody| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateGeneratorBody (
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값들의 List,
        ): throw completion 또는 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. _G_ 를 ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorPrototype%"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ») 로 둔다.
        1. _G_.[[GeneratorBrand]] 를 ~empty~ 로 설정한다.
        1. _G_.[[GeneratorState]] 를 ~suspended-start~ 로 설정한다.
        1. GeneratorStart(_G_, |FunctionBody|) 수행.
        1. ReturnCompletion(_G_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionobject" oldids="sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateGeneratorFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _sourceText_ 를 |GeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _sourceText_ 를 |GeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, *"default"*) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-note>
        <p>익명 |GeneratorDeclaration| 은 `export default` 선언의 일부로만 등장할 수 있으며 그 함수 코드는 항상 strict mode 코드이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateGeneratorFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""* 로 설정한다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |GeneratorExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 단언: _name_ 은 존재하지 않는다.
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 설정한다.
        1. _outerEnv_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _funcEnv_ 를 NewDeclarativeEnvironment(_outerEnv_) 로 둔다.
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) 수행.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |GeneratorExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|GeneratorExpression| 의 |BindingIdentifier| 는 그 |FunctionBody| 내부에서 참조되어 제너레이터 코드가 재귀 호출될 수 있게 한다. 그러나 |GeneratorDeclaration| 과 달리, 해당 |BindingIdentifier| 는 둘러싼 스코프에서 참조할 수 없고 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. |GeneratorExpression| 의 InstantiateGeneratorFunctionExpression 결과를 반환한다.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield`</emu-grammar>
      <emu-alg>
        1. ? Yield(*undefined*) 를 반환한다.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |AssignmentExpression| 평가 결과 (?) 로 둔다.
        1. _value_ 를 ? GetValue(_exprRef_) 로 둔다.
        1. ? Yield(_value_) 반환.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` `*` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _generatorKind_에 GetGeneratorKind()의 결과를 할당한다.
        1. 단언: _generatorKind_는 ~sync~ 또는 ~async~이다.
        1. _exprRef_에 ? |AssignmentExpression|의 평가 결과를 할당한다.
        1. _value_에 ? GetValue(_exprRef_)를 할당한다.
        1. _iteratorRecord_에 ? GetIterator(_value_, _generatorKind_)를 할당한다.
        1. _iterator_에 _iteratorRecord_.[[Iterator]]를 할당한다.
        1. _received_에 NormalCompletion(*undefined*)를 할당한다.
        1. 반복한다,
          1. _received_가 normal completion이면,
            1. _innerResult_에 ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »)를 할당한다.
            1. _generatorKind_가 ~async~이면, _innerResult_에 ? Await(_innerResult_)를 할당한다.
            1. _innerResult_가 Object가 아니면, *TypeError* 예외를 throw한다.
            1. _done_에 ? IteratorComplete(_innerResult_)를 할당한다.
            1. _done_이 *true*이면,
              1. ? IteratorValue(_innerResult_)를 반환한다.
            1. _generatorKind_가 ~async~이면, _received_에 Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_)))를 할당한다.
            1. 아니면, _received_에 Completion(GeneratorYield(_innerResult_))를 할당한다.
          1. 아니고 _received_가 throw completion이면,
            1. _throw_에 ? GetMethod(_iterator_, *"throw"*)를 할당한다.
            1. _throw_가 *undefined*가 아니면,
              1. _innerResult_에 ? Call(_throw_, _iterator_, « _received_.[[Value]] »)를 할당한다.
              1. _generatorKind_가 ~async~이면, _innerResult_에 ? Await(_innerResult_)를 할당한다.
              1. 참고: 내부 반복자의 `throw` 메서드에서 발생한 예외는 전파된다. 내부 `throw` 메서드의 normal completion은 내부 `next`와 유사하게 처리된다.
              1. _innerResult_가 Object가 아니면, *TypeError* 예외를 throw한다.
              1. _done_에 ? IteratorComplete(_innerResult_)를 할당한다.
              1. _done_이 *true*이면,
                1. ? IteratorValue(_innerResult_)를 반환한다.
              1. _generatorKind_가 ~async~이면, _received_에 Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_)))를 할당한다.
              1. 아니면, _received_에 Completion(GeneratorYield(_innerResult_))를 할당한다.
            1. 아니면,
              1. 참고: _iterator_에 `throw` 메서드가 없는 경우, 이 throw는 `yield*` 루프를 종료시킨다. 다만 먼저 _iterator_에 정리(clean-up)할 기회를 준다.
              1. _closeCompletion_에 NormalCompletion(~empty~)을 할당한다.
              1. _generatorKind_가 ~async~면, ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_)을 수행한다.
              1. 아니면, ? IteratorClose(_iteratorRecord_, _closeCompletion_)을 수행한다.
              1. 참고: 다음 단계는 *TypeError*를 throw하여 `yield*` 프로토콜 위반: _iterator_에 `throw` 메서드가 없음을 나타낸다.
              1. *TypeError* 예외를 throw한다.
          1. 아니면,
            1. 단언: _received_는 return completion이다.
            1. _return_에 ? GetMethod(_iterator_, *"return"*)을 할당한다.
            1. _return_이 *undefined*이면,
              1. _receivedValue_에 _received_.[[Value]]를 할당한다.
              1. _generatorKind_가 ~async~이면,
                1. _receivedValue_에 ? Await(_receivedValue_)를 할당한다.
              1. ReturnCompletion(_receivedValue_)를 반환한다.
            1. _innerReturnResult_에 ? Call(_return_, _iterator_, « _received_.[[Value]] »)를 할당한다.
            1. _generatorKind_가 ~async~이면, _innerReturnResult_에 ? Await(_innerReturnResult_)를 할당한다.
            1. _innerReturnResult_가 Object가 아니면, *TypeError* 예외를 throw한다.
            1. _done_에 ? IteratorComplete(_innerReturnResult_)를 할당한다.
            1. _done_이 *true*이면,
              1. _returnedValue_에 ? IteratorValue(_innerReturnResult_)를 할당한다.
              1. ReturnCompletion(_returnedValue_)를 반환한다.
            1. _generatorKind_가 ~async~이면, _received_에 Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_)))를 할당한다.
            1. 아니면, _received_에 Completion(GeneratorYield(_innerReturnResult_))를 할당한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>비동기 제너레이터 함수 정의 (Async Generator Function Definitions)</h1>
    <h2>구문 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncGeneratorDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
        [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorExpression :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorMethod[Yield, Await] :
        `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorBody :
        FunctionBody[+Yield, +Await]
    </emu-grammar>
    <emu-note>
      <p>|YieldExpression| 과 |AwaitExpression| 은 async generator 함수의 |FormalParameters| 내부에서 사용할 수 없다. 이는 해당 표현식들이 AsyncGenerator 가 재개 가능한 상태가 되기 전에 평가되기 때문이다.</p>
    </emu-note>
    <emu-note>
      <p>AsyncGenerator 관련 추상 연산은 <emu-xref href="#sec-asyncgenerator-abstract-operations"></emu-xref> 에 정의되어 있다.</p>
    </emu-note>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류 (Static Semantics: Early Errors)</h1>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <ul>
        <li>|AsyncGeneratorMethod| 의 HasDirectSuper 가 *true* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 가 |AwaitExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|AsyncGeneratorBody|) 가 *true* 이고 IsSimpleParameterList(|UniqueFormalParameters|) 가 *false* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 의 BoundNames 요소 중 하나라도 |AsyncGeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>IsStrict(|FormalParameters|) 가 *true* 이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 조기 오류 규칙을 적용한다.</li>
        <li>|BindingIdentifier| 존재 &amp; IsStrict(|BindingIdentifier|) *true* 이면 StringValue 가 *"eval"* 또는 *"arguments"* 인 경우 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|AsyncGeneratorBody|) *true* 이고 IsSimpleParameterList(|FormalParameters|) *false* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 의 BoundNames 요소 중 하나라도 |AsyncGeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |AwaitExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|AsyncGeneratorBody| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|AsyncGeneratorBody| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateAsyncGeneratorBody (
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값들의 List,
        ): throw completion 또는 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. _generator_ 를 ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorPrototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ») 로 둔다.
        1. _generator_.[[GeneratorBrand]] 를 ~empty~ 로 설정한다.
        1. _generator_.[[AsyncGeneratorState]] 를 ~suspended-start~ 로 설정한다.
        1. AsyncGeneratorStart(_generator_, |FunctionBody|) 수행.
        1. ReturnCompletion(_generator_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionobject" oldids="sec-asyncgenerator-definitions-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncGeneratorFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _sourceText_ 를 |AsyncGeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _sourceText_ 를 |AsyncGeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, *"default"*) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-note>
        <p>익명 |AsyncGeneratorDeclaration| 은 `export default` 선언에서만 나타날 수 있다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncGeneratorFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""* 로 설정한다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |AsyncGeneratorExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 단언: _name_ 은 존재하지 않는다.
        1. _name_ = |BindingIdentifier| 의 StringValue.
        1. _outerEnv_ = 실행 중 실행 컨텍스트의 LexicalEnvironment.
        1. _funcEnv_ = NewDeclarativeEnvironment(_outerEnv_).
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) 수행.
        1. _privateEnv_ = 실행 중 실행 컨텍스트의 PrivateEnvironment.
        1. _sourceText_ = |AsyncGeneratorExpression| 이 매칭한 소스 텍스트.
        1. _closure_ = OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ = OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|AsyncGeneratorExpression| 의 |BindingIdentifier| 는 해당 |AsyncGeneratorBody| 내부에서 재귀 호출을 위해 참조될 수 있으나 |AsyncGeneratorDeclaration| 과 달리 둘러싼 스코프에는 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluation" type="sdo">
      <h1>런타임 의미론: 평가 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. |AsyncGeneratorExpression| 의 InstantiateAsyncGeneratorFunctionExpression 결과를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>클래스 정의 (Class Definitions)</h1>
    <h2>구문 (Syntax)</h2>
    <emu-grammar type="definition">
      ClassDeclaration[Yield, Await, Default] :
        `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ClassTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

      ClassHeritage[Yield, Await] :
        `extends` LeftHandSideExpression[?Yield, ?Await]

      ClassBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]

      ClassElementList[Yield, Await] :
        ClassElement[?Yield, ?Await]
        ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        FieldDefinition[?Yield, ?Await] `;`
        `static` FieldDefinition[?Yield, ?Await] `;`
        ClassStaticBlock
        `;`

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateIdentifier

      ClassStaticBlock :
        `static` `{` ClassStaticBlockBody `}`

      ClassStaticBlockBody :
        ClassStaticBlockStatementList

      ClassStaticBlockStatementList :
        StatementList[~Yield, +Await, ~Return]?
    </emu-grammar>
    <emu-note>
      <p>클래스 정의는 항상 strict mode 코드이다.</p>
    </emu-note>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류 (Static Semantics: Early Errors)</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>|ClassHeritage| 가 존재하지 않고 아래 알고리즘이 *true* 를 반환하면 Syntax Error 이다:</p>
          <emu-alg>
            1. _constructor_ 를 |ClassBody| 의 ConstructorMethod 로 둔다.
            1. _constructor_ 가 ~empty~ 이면 *false* 반환.
            1. HasDirectSuper(_constructor_) 반환.
          </emu-alg>
        </li>
      </ul>
      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <ul>
        <li>|ClassElementList| 의 PrototypePropertyNameList 에 *"constructor"* 가 두 번 이상 나타나면 Syntax Error 이다.</li>
        <li>|ClassElementList| 의 PrivateBoundIdentifiers 에 중복 항목이 있으면 (단, 동일 이름이 getter 1회와 setter 1회만, 그리고 둘 다 static 이거나 둘 다 non-static 인 경우를 제외) Syntax Error 이다.</li>
      </ul>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <ul>
        <li>|MethodDefinition| 의 PropName 이 *"constructor"* 가 아니면서 HasDirectSuper(|MethodDefinition|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>|MethodDefinition| 의 PropName 이 *"constructor"* 이고 SpecialMethod(|MethodDefinition|) 가 *true* 이면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <ul>
        <li>HasDirectSuper(|MethodDefinition|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>PropName(|MethodDefinition|) 이 *"prototype"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <ul>
        <li>PropName(|FieldDefinition|) 이 *"constructor"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <ul>
        <li>PropName(|FieldDefinition|) 이 *"prototype"* 또는 *"constructor"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>
        FieldDefinition :
          ClassElementName Initializer?
      </emu-grammar>
      <ul>
        <li>|Initializer| 가 존재하고 ContainsArguments(|Initializer|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>|Initializer| 가 존재하고 |Initializer| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <ul>
        <li>|PrivateIdentifier| 의 StringValue 가 *"#constructor"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <ul>
        <li>|ClassStaticBlockStatementList| 의 LexicallyDeclaredNames 에 중복 항목이 있으면 Syntax Error 이다.</li>
        <li>LexicallyDeclaredNames 요소 중 하나라도 VarDeclaredNames 에 존재하면 Syntax Error 이다.</li>
        <li>ContainsDuplicateLabels(|ClassStaticBlockStatementList|, « ») 가 *true* 이면 Syntax Error 이다.</li>
        <li>ContainsUndefinedBreakTarget(|ClassStaticBlockStatementList|, « ») 가 *true* 이면 Syntax Error 이다.</li>
        <li>ContainsUndefinedContinueTarget(|ClassStaticBlockStatementList|, « », « ») 가 *true* 이면 Syntax Error 이다.</li>
        <li>ContainsArguments(|ClassStaticBlockStatementList|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>|ClassStaticBlockStatementList| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|ClassStaticBlockStatementList| 가 `await` 를 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementkind" type="sdo">
      <h1>정적 의미론: ClassElementKind ( ): ~constructor-method~, ~non-constructor-method~, 또는 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. |MethodDefinition| 의 PropName 이 *"constructor"* 이면 ~constructor-method~ 반환.
        1. ~non-constructor-method~ 반환.
      </emu-alg>
      <emu-grammar>
        ClassElement :
          `static` MethodDefinition
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. ~non-constructor-method~ 반환.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ~non-constructor-method~ 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-constructormethod" type="sdo">
      <h1>정적 의미론: ConstructorMethod ( ): |ClassElement| Parse Node 또는 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. |ClassElement| 의 ClassElementKind 가 ~constructor-method~ 이면 |ClassElement| 반환.
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _head_ 를 |ClassElementList| 의 ConstructorMethod 로 둔다.
        1. _head_ ≠ ~empty~ 이면 _head_ 반환.
        1. |ClassElement| 의 ClassElementKind 가 ~constructor-method~ 이면 |ClassElement| 반환.
        1. ~empty~ 반환.
      </emu-alg>
      <emu-note>
        <p>조기 오류 규칙은 이름이 *"constructor"* 인 메서드 정의가 하나뿐이며 accessor 나 generator 정의가 아님을 보장한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstatic" type="sdo">
      <h1>정적 의미론: IsStatic ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructorelements" oldids="sec-static-semantics-nonconstructormethoddefinitions" type="sdo">
      <h1>정적 의미론: NonConstructorElements ( ): |ClassElement| Parse Node 들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. |ClassElement| 의 ClassElementKind 가 ~non-constructor-method~ 이면
          1. « |ClassElement| » 반환.
        1. 새 빈 List 반환.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _list_ 를 |ClassElementList| 의 NonConstructorElements 로 둔다.
        1. |ClassElement| 의 ClassElementKind 가 ~non-constructor-method~ 이면
          1. _list_ 끝에 |ClassElement| 추가.
        1. _list_ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-prototypepropertynamelist" type="sdo">
      <h1>정적 의미론: PrototypePropertyNameList ( ): property key 들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. _propName_ 을 |ClassElement| 의 PropName 으로 둔다.
        1. _propName_ 이 ~empty~ 이면 새 빈 List 반환.
        1. IsStatic(|ClassElement|) 가 *true* 이면 새 빈 List 반환.
        1. « _propName_ » 반환.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _list_ 를 |ClassElementList| 의 PrototypePropertyNameList 로 둔다.
        1. _propName_ 을 |ClassElement| 의 PropName 으로 둔다.
        1. _propName_ 이 ~empty~ 이면 _list_ 반환.
        1. IsStatic(|ClassElement|) 가 *true* 이면 _list_ 반환.
        1. _list_ 와 « _propName_ » 의 리스트 연결을 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-allprivateidentifiersvalid" type="sdo">
      <h1>
        정적 의미론: AllPrivateIdentifiersValid (
        _names_: String 들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>아래에 명시되지 않은 모든 생성물 대안은 다음 기본 정의를 암묵적으로 갖는다:</p>
      <emu-alg>
        1. 이 Parse Node 의 각 자식 노드 _child_ 에 대해
          1. _child_ 가 비단말(nonterminal) 인스턴스이면
            1. AllPrivateIdentifiersValid(_child_, _names_) 가 *false* 이면 *false* 반환.
        1. *true* 반환.
      </emu-alg>

      <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|MemberExpression|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|CallExpression|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면 *true* 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|OptionalChain|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <emu-alg>
        1. _newNames_ 를 _names_ 와 |ClassBody| 의 PrivateBoundIdentifiers 의 리스트 연결로 둔다.
        1. AllPrivateIdentifiersValid(|ClassElementList|, _newNames_) 반환.
      </emu-alg>

      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|ShiftExpression|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-privateboundidentifiers" type="sdo">
      <h1>정적 의미론: PrivateBoundIdentifiers ( ): String 들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. PrivateBoundIdentifiers(|ClassElementName|) 반환.
      </emu-alg>

      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. |PrivateIdentifier| 의 StringValue 하나만을 요소로 갖는 List 반환.
      </emu-alg>

      <emu-grammar>
        ClassElementName :
          PropertyName

        ClassElement :
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List 반환.
      </emu-alg>

      <emu-grammar>
        ClassElementList : ClassElementList ClassElement
      </emu-grammar>
      <emu-alg>
        1. _names1_ = PrivateBoundIdentifiers(|ClassElementList|).
        1. _names2_ = PrivateBoundIdentifiers(|ClassElement|).
        1. 리스트 연결(_names1_, _names2_) 반환.
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. PrivateBoundIdentifiers(|ClassElementName|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsarguments" type="sdo">
      <h1>정적 의미론: ContainsArguments ( ): Boolean</h1>
      <dl class="header">
      </dl>

      <p>아래에 나열되지 않은 모든 생성물 대안은 다음 기본 정의를 갖는다:</p>
      <emu-alg>
        1. 이 Parse Node 의 각 자식 _child_ 에 대해
          1. _child_ 가 비단말 인스턴스이면
            1. ContainsArguments(_child_) 가 *true* 이면 *true* 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>
        IdentifierReference : Identifier
      </emu-grammar>
      <emu-alg>
        1. |Identifier| 의 StringValue 가 *"arguments"* 이면 *true* 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. ContainsArguments(|ClassElementName|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classfielddefinitionevaluation" type="sdo">
      <h1>
        런타임 의미론: ClassFieldDefinitionEvaluation (
        _homeObject_: Object,
        ): ClassFieldDefinition Record 를 담은 정상 completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. _name_ 을 ? Evaluation(|ClassElementName|) 로 둔다.
        1. |Initializer| 가 존재하면
          1. _formalParameterList_ 를 <emu-grammar>FormalParameters : [empty]</emu-grammar> 의 인스턴스로 둔다.
          1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
          1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
          1. _sourceText_ 를 빈 Unicode 코드 포인트 시퀀스로 둔다.
          1. _initializer_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
          1. MakeMethod(_initializer_, _homeObject_) 수행.
          1. _initializer_.[[ClassFieldInitializerName]] = _name_ 으로 설정.
        1. 그렇지 않으면
          1. _initializer_ = ~empty~.
        1. ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ } 반환.
      </emu-alg>
      <emu-note>
        _initializer_ 를 위해 생성된 함수는 ECMAScript 코드에서 직접 접근할 수 없다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classstaticblockdefinitionevaluation" type="sdo">
      <h1>
        런타임 의미론: ClassStaticBlockDefinitionEvaluation (
        _homeObject_: Object,
        ): ClassStaticBlockDefinition Record
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. _lex_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 빈 Unicode 코드 포인트 시퀀스로 둔다.
        1. _formalParameters_ 를 <emu-grammar>FormalParameters : [empty]</emu-grammar> 인스턴스로 둔다.
        1. [id="step-synthetic-class-static-block-fn"] _bodyFunction_ 을 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_) 로 둔다.
        1. MakeMethod(_bodyFunction_, _homeObject_) 수행.
        1. ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ } 반환.
      </emu-alg>
      <emu-note>_bodyFunction_ 함수는 ECMAScript 코드에서 직접 접근할 수 없다.</emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        런타임 의미론: EvaluateClassStaticBlockBody (
        _functionObject_: ECMAScript 함수 객체,
        ): return completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. 단언: _functionObject_ 는 ClassStaticBlockDefinitionEvaluation 단계 <emu-xref href="#step-synthetic-class-static-block-fn"></emu-xref> 에서 생성된 합성(synthetic) 함수이다.
        1. ! FunctionDeclarationInstantiation(_functionObject_, « ») 수행.
        1. ? Evaluation(|ClassStaticBlockStatementList|) 수행.
        1. ReturnCompletion(*undefined*) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementevaluation" type="sdo">
      <h1>
        런타임 의미론: ClassElementEvaluation(
        _object_: 객체,
        ): 정상 완료(ClassFieldDefinition 레코드, ClassStaticBlockDefinition 레코드, PrivateElement, ~unused~ 중 하나 포함) 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ClassElement :
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. |FieldDefinition|에 대해 _object_를 인수로 하여 ClassFieldDefinitionEvaluation을 ? 반환한다.
      </emu-alg>

      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. |MethodDefinition|에 대해 _object_와 *false*를 인수로 하여 MethodDefinitionEvaluation을 ? 반환한다.
      </emu-alg>

      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. |ClassStaticBlock|에 대해 _object_를 인수로 하여 ClassStaticBlockDefinitionEvaluation을 반환한다.
      </emu-alg>

      <emu-grammar>
        ClassElement : `;`
      </emu-grammar>
      <emu-alg>
        1. ~unused~을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        런타임 의미론: ClassDefinitionEvaluation(
        _classBinding_: String 또는 *undefined*,
        _className_: 속성 키 또는 Private Name,
        _sourceText_: ECMAScript 소스 텍스트,
        ): 함수 객체를 포함하는 정상 완료 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>명세를 쉽게 하기 위해 private 메서드와 접근자는 클래스 인스턴스의 [[PrivateElements]] 슬롯에 private 필드와 함께 포함된다. 그러나 어떤 객체든 특정 클래스가 정의한 private 메서드와 접근자를 모두 가지거나 전혀 가지지 않는다. 이 기능은 구현에서 각 메서드나 접근자를 개별적으로 추적하지 않는 전략을 선택할 수 있도록 설계되었다.</p>
        <p>예를 들어, 구현은 인스턴스 private 메서드를 해당 Private Name과 직접 연결하고, 각 객체에 대해 어떤 클래스 생성자가 그 객체를 `this` 값으로 실행했는지 추적할 수 있다. 객체에서 인스턴스 private 메서드를 조회하는 것은 해당 클래스 생성자가 객체 초기화에 사용되었는지 확인한 다음, Private Name에 연결된 메서드를 반환하는 것으로 구성된다.</p>
        <p>이는 private 필드와는 다르다. 필드 초기화자가 클래스 인스턴스화 중에 throw될 수 있으므로, 개별 객체는 해당 클래스의 일부 private 필드만을 가질 수 있으며, private 필드는 일반적으로 개별적으로 추적되어야 한다.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. _env_를 실행 중인 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _classEnv_를 NewDeclarativeEnvironment(_env_)로 둔다.
        1. _classBinding_이 *undefined*가 아니면,
          1. ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*)를 수행한다.
        1. _outerPrivateEnvironment_를 실행 중인 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _classPrivateEnvironment_를 NewPrivateEnvironment(_outerPrivateEnvironment_)로 둔다.
        1. |ClassBody|가 존재하면,
          1. |ClassBody|의 PrivateBoundIdentifiers의 각 String _dn_에 대해 다음을 수행한다:
            1. _classPrivateEnvironment_.[[Names]]가 [[Description]]이 _dn_인 Private Name _pn_을 포함하면,
              1. 단언: 이는 getter/setter 쌍에 대해서만 가능하다.
            1. 그렇지 않으면,
              1. _name_을 [[Description]]이 _dn_인 새 Private Name으로 둔다.
              1. _name_을 _classPrivateEnvironment_.[[Names]]에 추가한다.
        1. |ClassHeritage|가 존재하지 않으면,
          1. _protoParent_를 %Object.prototype%로 둔다.
          1. _constructorParent_를 %Function.prototype%로 둔다.
        1. 그렇지 않으면,
          1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _classEnv_로 설정한다.
          1. 참고: |ClassHeritage|를 평가할 때 실행 중인 실행 컨텍스트의 PrivateEnvironment는 _outerPrivateEnvironment_이다.
          1. _superclassRef_를 Completion(Evaluation of |ClassHeritage|)로 둔다.
          1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _env_로 설정한다.
          1. _superclass_를 ? GetValue(? _superclassRef_)로 둔다.
          1. _superclass_가 *null*이면,
            1. _protoParent_를 *null*로 둔다.
            1. _constructorParent_를 %Function.prototype%로 둔다.
          1. 그렇지 않고 IsConstructor(_superclass_)가 *false*이면,
            1. *TypeError* 예외를 던진다.
          1. 그렇지 않으면,
            1. _protoParent_를 ? Get(_superclass_, *"prototype"*)로 둔다.
            1. _protoParent_가 Object가 아니고 *null*도 아니면, *TypeError* 예외를 던진다.
            1. _constructorParent_를 _superclass_로 둔다.
        1. _proto_를 OrdinaryObjectCreate(_protoParent_)로 둔다.
        1. |ClassBody|가 존재하지 않으면, _constructor_를 ~empty~로 둔다.
        1. 그렇지 않으면, _constructor_를 |ClassBody|의 ConstructorMethod로 둔다.
        1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _classEnv_로 설정한다.
        1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _classPrivateEnvironment_로 설정한다.
        1. _constructor_가 ~empty~이면,
          1. _defaultConstructor_를 매개변수가 없고 아무것도 캡처하지 않는 새 Abstract Closure로 두고, 호출될 때 다음 단계를 수행하도록 한다:
            1. _args_를 [[Call]] 또는 [[Construct]]에 의해 이 함수에 전달된 인수의 List로 둔다.
            1. NewTarget이 *undefined*이면, *TypeError* 예외를 던진다.
            1. _F_를 활성 함수 객체로 둔다.
            1. _F_.[[ConstructorKind]]가 ~derived~이면,
              1. 참고: 이 분기는 `constructor(...args) { super(...args); }`와 유사하게 동작한다. 가장 주목할 만한 차이점은 앞서 언급한 ECMAScript 소스 텍스트가 `%Array.prototype%`의 %Symbol.iterator% 메서드를 관찰 가능하게 호출하는 반면, 이 함수는 그렇지 않는다는 것이다.
              1. _func_를 ! _F_.[[GetPrototypeOf]]()로 둔다.
              1. IsConstructor(_func_)가 *false*이면, *TypeError* 예외를 던진다.
              1. _result_를 ? Construct(_func_, _args_, NewTarget)로 둔다.
            1. 그렇지 않으면,
              1. 참고: 이 분기는 `constructor() {}`와 유사하게 동작한다.
              1. _result_를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*)로 둔다.
            1. ? InitializeInstanceElements(_result_, _F_)를 수행한다.
            1. NormalCompletion(_result_)를 반환한다.
          1. _F_를 CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]], [[PrivateMethods]], [[Fields]] », the current Realm Record, _constructorParent_)로 둔다.
        1. 그렇지 않으면,
          1. _constructorInfo_를 ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_로 둔다.
          1. _F_를 _constructorInfo_.[[Closure]]로 둔다.
          1. MakeClassConstructor(_F_)를 수행한다.
          1. SetFunctionName(_F_, _className_)을 수행한다.
        1. _F_.[[SourceText]]를 _sourceText_로 설정한다.
        1. MakeConstructor(_F_, *false*, _proto_)를 수행한다.
        1. |ClassHeritage|가 존재하면, _F_.[[ConstructorKind]]를 ~derived~로 설정한다.
        1. ! DefineMethodProperty(_proto_, *"constructor"*, _F_, *false*)를 수행한다.
        1. |ClassBody|가 존재하지 않으면, _elements_를 새 빈 List로 둔다.
        1. 그렇지 않으면, _elements_를 |ClassBody|의 NonConstructorElements로 둔다.
        1. _instancePrivateMethods_를 새 빈 List로 둔다.
        1. _staticPrivateMethods_를 새 빈 List로 둔다.
        1. _instanceFields_를 새 빈 List로 둔다.
        1. _staticElements_를 새 빈 List로 둔다.
        1. _elements_의 각 |ClassElement| _e_에 대해 다음을 수행한다:
          1. _e_의 IsStatic이 *false*이면,
            1. _element_를 Completion(ClassElementEvaluation of _e_ with argument _proto_)로 둔다.
          1. 그렇지 않으면,
            1. _element_를 Completion(ClassElementEvaluation of _e_ with argument _F_)로 둔다.
          1. _element_가 abrupt completion이면,
            1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _env_로 설정한다.
            1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _outerPrivateEnvironment_로 설정한다.
            1. ? _element_를 반환한다.
          1. _element_를 ! _element_로 설정한다.
          1. _element_가 PrivateElement이면,
            1. 단언: _element_.[[Kind]]는 ~method~ 또는 ~accessor~ 중 하나이다.
            1. _e_의 IsStatic이 *false*이면, _container_를 _instancePrivateMethods_로 둔다; 그렇지 않으면, _container_를 _staticPrivateMethods_로 둔다.
            1. _container_가 [[Key]]가 _element_.[[Key]]인 PrivateElement _pe_를 포함하면,
              1. 단언: _element_.[[Kind]]와 _pe_.[[Kind]]는 모두 ~accessor~이다.
              1. _element_.[[Get]]이 *undefined*이면,
                1. _combined_를 PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }로 둔다.
              1. 그렇지 않으면,
                1. _combined_를 PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }로 둔다.
              1. _container_에서 _pe_를 _combined_로 대체한다.
            1. 그렇지 않으면,
              1. _element_를 _container_에 추가한다.
          1. 그렇지 않고 _element_가 ClassFieldDefinition Record이면,
            1. _e_의 IsStatic이 *false*이면, _element_를 _instanceFields_에 추가한다.
            1. 그렇지 않으면, _element_를 _staticElements_에 추가한다.
          1. 그렇지 않고 _element_가 ClassStaticBlockDefinition Record이면,
            1. _element_를 _staticElements_에 추가한다.
        1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _env_로 설정한다.
        1. _classBinding_이 *undefined*가 아니면,
          1. ! _classEnv_.InitializeBinding(_classBinding_, _F_)를 수행한다.
        1. _F_.[[PrivateMethods]]를 _instancePrivateMethods_로 설정한다.
        1. _F_.[[Fields]]를 _instanceFields_로 설정한다.
        1. _staticPrivateMethods_의 각 PrivateElement _method_에 대해,
          1. ! PrivateMethodOrAccessorAdd(_F_, _method_)를 수행한다.
        1. _staticElements_의 각 요소 _elementRecord_에 대해,
          1. _elementRecord_가 ClassFieldDefinition Record이면,
            1. _result_를 Completion(DefineField(_F_, _elementRecord_))로 둔다.
          1. 그렇지 않으면,
            1. 단언: _elementRecord_는 ClassStaticBlockDefinition Record이다.
            1. _result_를 Completion(Call(_elementRecord_.[[BodyFunction]], _F_))로 둔다.
          1. _result_가 abrupt completion이면,
            1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _outerPrivateEnvironment_로 설정한다.
            1. ? _result_를 반환한다.
        1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _outerPrivateEnvironment_로 설정한다.
        1. _F_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation" type="sdo">
      <h1>런타임 의미론: BindingClassDeclarationEvaluation ( ): 함수 객체를 포함하는 정상 완료 또는 abrupt completion</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 StringValue를 _className_으로 둔다.
        1. |ClassDeclaration|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 _className_, _className_, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 _value_로 둔다.
        1. 실행 컨텍스트의 LexicalEnvironment를 _env_로 둔다.
        1. ? InitializeBoundName(_className_, _value_, _env_)를 수행한다.
        1. _value_를 반환한다.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 *undefined*, *"default"*, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>는 |ExportDeclaration|의 일부로만 나타나며, 바인딩 생성은 해당 생성물의 평가 동작에서 처리된다. <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref> 참고.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: Evaluation</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 이 |ClassDeclaration|에 대해 ? BindingClassDeclarationEvaluation을 수행한다.
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>는 |ExportDeclaration|의 일부로만 나타나며 직접 평가되지 않는다.</p>
      </emu-note>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. |ClassExpression|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 *undefined*, *""*, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassExpression : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 StringValue를 _className_으로 둔다.
        1. |ClassExpression|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 _className_, _className_, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. |PrivateIdentifier|의 StringValue를 _privateIdentifier_로 둔다.
        1. 실행 컨텍스트의 PrivateEnvironment를 _privateEnvRec_로 둔다.
        1. _privateEnvRec_.[[Names]]를 _names_로 둔다.
        1. 단언: _names_의 정확히 하나의 요소가 [[Description]]이 _privateIdentifier_인 Private Name임.
        1. _privateName_을 _names_ 중 [[Description]]이 _privateIdentifier_인 Private Name으로 둔다.
        1. _privateName_을 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined*를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async 함수 정의</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      AsyncFunctionDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionExpression :
        `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncMethod[Yield, Await] :
        `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionBody :
        FunctionBody[~Yield, +Await]

      AwaitExpression[Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>

    <emu-note>
      <p>`await`는 <sub>[Await]</sub> 파라미터가 있을 때 |AwaitExpression|의 키워드로 파싱된다. <sub>[Await]</sub> 파라미터는 아래 문맥의 최상위에 있지만, |FunctionBody| 같은 비단말에 따라 부재할 수 있다:</p>
      <ul>
        <li>|AsyncFunctionBody| 내부</li>
        <li>|AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|의 |FormalParameters| 내부. 이 위치의 |AwaitExpression|은 정적 의미론에 의해 문법 오류이다.</li>
        <li>|Module| 내부</li>
      </ul>
      <p>|Script|가 구문 목표 기호일 때, <sub>[Await]</sub> 파라미터가 없으면 `await`는 식별자로 파싱될 수 있다. 해당 문맥은 다음과 같다:</p>
      <ul>
        <li>|AsyncFunctionBody| 또는 |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|의 |FormalParameters| 외부의 모든 위치</li>
        <li>|FunctionExpression|, |GeneratorExpression|, |AsyncGeneratorExpression|의 |BindingIdentifier| 내부</li>
      </ul>
    </emu-note>

    <emu-note>
      <p>|YieldExpression|과 달리 |AwaitExpression|의 피연산자를 생략하면 문법 오류이다. 반드시 await할 대상이 있어야 한다.</p>
    </emu-note>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>|AsyncFunctionBody|의 FunctionBodyContainsUseStrict가 *true*이고 |UniqueFormalParameters|의 IsSimpleParameterList가 *false*이면 문법 오류이다.</li>
        <li>|AsyncMethod|의 HasDirectSuper가 *true*이면 문법 오류이다.</li>
        <li>|UniqueFormalParameters|이 |AwaitExpression|을 포함하면 문법 오류이다.</li>
        <li>|UniqueFormalParameters|의 BoundNames 중 어떤 요소라도 |AsyncFunctionBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
      </ul>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>|AsyncFunctionBody|의 FunctionBodyContainsUseStrict가 *true*이고 |FormalParameters|의 IsSimpleParameterList가 *false*이면 문법 오류이다.</li>
        <li>|FormalParameters|이 |AwaitExpression|을 포함하면 문법 오류이다.</li>
        <li>|FormalParameters|의 IsStrict가 *true*이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>에 대한 조기 오류 규칙을 적용한다.</li>
        <li>|BindingIdentifier|가 존재하고 IsStrict(|BindingIdentifier|)가 *true*이면, 그 StringValue가 *"eval"* 또는 *"arguments"*인 경우 문법 오류이다.</li>
        <li>|FormalParameters|의 BoundNames 중 어떤 요소라도 |AsyncFunctionBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
        <li>|FormalParameters|이 |SuperProperty|을 포함하면 문법 오류이다.</li>
        <li>|AsyncFunctionBody|이 |SuperProperty|을 포함하면 문법 오류이다.</li>
        <li>|FormalParameters|이 |SuperCall|을 포함하면 문법 오류이다.</li>
        <li>|AsyncFunctionBody|이 |SuperCall|을 포함하면 문법 오류이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionobject" oldids="sec-async-function-definitions-InstantiateFunctionObject" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncFunctionObject(
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_을 |BindingIdentifier|의 StringValue로 둔다.
        1. _sourceText_를 |AsyncFunctionDeclaration|이 매칭한 소스 텍스트로 둔다.
        1. _F_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_F_, _name_)을 수행한다.
        1. _F_를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _sourceText_를 |AsyncFunctionDeclaration|이 매칭한 소스 텍스트로 둔다.
        1. _F_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_F_, *"default"*)를 수행한다.
        1. _F_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncFunctionExpression(
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_이 없다면 _name_ = *""*로 설정한다.
        1. _env_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncFunctionExpression|이 매칭한 소스 텍스트로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 단언: _name_은 없다.
        1. _name_을 |BindingIdentifier|의 StringValue로 둔다.
        1. _outerEnv_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _funcEnv_를 NewDeclarativeEnvironment(_outerEnv_)로 둔다.
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*)를 수행한다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncFunctionExpression|이 매칭한 소스 텍스트로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_)를 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|AsyncFunctionExpression|의 |BindingIdentifier|는 그 |AsyncFunctionBody| 내부에서 참조되어 함수가 재귀적으로 자신을 호출할 수 있게 한다. 하지만 |FunctionDeclaration|과 달리 |AsyncFunctionExpression|의 |BindingIdentifier|는 외부 스코프에서 참조할 수 없고 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncfunctionbody" oldids="sec-async-function-definitions-EvaluateBody" type="sdo">
      <h1>
        런타임 의미론: EvaluateAsyncFunctionBody(
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값 리스트,
        ): return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. _promiseCapability_를 ! NewPromiseCapability(%Promise%)로 둔다.
        1. _completion_을 Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_))로 둔다.
        1. _completion_이 abrupt completion이면
          1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »)를 수행한다.
        1. 그렇지 않으면
          1. AsyncFunctionStart(_promiseCapability_, |FunctionBody|)를 수행한다.
        1. ReturnCompletion(_promiseCapability_.[[Promise]])를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>
        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |AsyncFunctionExpression|의 InstantiateAsyncFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AwaitExpression : `await` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. _exprRef_를 |UnaryExpression| 평가 결과(?)로 둔다.
        1. _value_를 ? GetValue(_exprRef_)로 둔다.
        1. ? Await(_value_)를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-arrow-function-definitions">
    <h1>Async 화살표 함수 정의</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      AsyncArrowFunction[In, Yield, Await] :
        `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

      AsyncConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, +Await]
        `{` AsyncFunctionBody `}`

      AsyncArrowBindingIdentifier[Yield] :
        BindingIdentifier[?Yield, +Await]

      CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>
    <h2>보충 구문</h2>
    <p>
      생성물 인스턴스<br>
      <emu-grammar>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody</emu-grammar><br>
      를 처리할 때 |CoverCallExpressionAndAsyncArrowHead|의 해석은 다음 구문을 사용해 정밀화된다:
    </p>

    <emu-grammar type="definition">
      AsyncArrowHead :
        `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|AsyncArrowBindingIdentifier|의 BoundNames 중 어떤 요소라도 |AsyncConciseBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
      </ul>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|CoverCallExpressionAndAsyncArrowHead|는 반드시 |AsyncArrowHead|를 커버해야 한다.</li>
        <li>|CoverCallExpressionAndAsyncArrowHead|이 |YieldExpression|을 포함하면 문법 오류이다.</li>
        <li>|CoverCallExpressionAndAsyncArrowHead|이 |AwaitExpression|을 포함하면 문법 오류이다.</li>
        <li>|CoverCallExpressionAndAsyncArrowHead|의 BoundNames 중 어떤 요소라도 |AsyncConciseBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
        <li>AsyncConciseBodyContainsUseStrict(|AsyncConciseBody|)가 *true*이고 IsSimpleParameterList(|CoverCallExpressionAndAsyncArrowHead|)가 *false*이면 문법 오류이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-asyncconcisebodycontainsusestrict" oldids="sec-async-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>정적 의미론: AsyncConciseBodyContainsUseStrict(): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncConciseBody : `{` AsyncFunctionBody `}`</emu-grammar>
      <emu-alg>
        1. FunctionBodyContainsUseStrict(|AsyncFunctionBody|)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncconcisebody" oldids="sec-async-arrow-function-definitions-EvaluateBody" type="sdo">
      <h1>
        런타임 의미론: EvaluateAsyncConciseBody(
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값 리스트,
        ): return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. _promiseCapability_를 ! NewPromiseCapability(%Promise%)로 둔다.
        1. _completion_을 Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_))로 둔다.
        1. _completion_이 abrupt completion이면
          1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »)를 수행한다.
        1. 그렇지 않으면
          1. AsyncFunctionStart(_promiseCapability_, |ExpressionBody|)를 수행한다.
        1. ReturnCompletion(_promiseCapability_.[[Promise]])를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncarrowfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncArrowFunctionExpression(
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_이 없으면 _name_ = *""*로 설정한다.
        1. _env_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncArrowFunction|이 매칭한 소스 텍스트로 둔다.
        1. _parameters_를 |AsyncArrowBindingIdentifier|로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_이 없으면 _name_ = *""*로 설정한다.
        1. _env_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncArrowFunction|이 매칭한 소스 텍스트로 둔다.
        1. _head_를 |CoverCallExpressionAndAsyncArrowHead|가 커버하는 |AsyncArrowHead|로 둔다.
        1. _parameters_를 _head_의 |ArrowFormalParameters|로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. |AsyncArrowFunction|의 InstantiateAsyncArrowFunctionExpression을 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>꼬리 위치 호출</h1>

    <emu-clause id="sec-isintailposition" type="abstract operation">
      <h1>
        정적 의미론: IsInTailPosition(
        _call_: |CallExpression| Parse Node 또는 |MemberExpression| Parse Node 또는 |OptionalChain| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. IsStrict(_call_)이 *false*이면 *false*를 반환한다.
        1. _call_이 |FunctionBody|, |ConciseBody|, |AsyncConciseBody| 중 어느 것에도 포함되어 있지 않으면 *false*를 반환한다.
        1. _body_를 _call_을 가장 가까이 포함하는 |FunctionBody|, |ConciseBody|, |AsyncConciseBody|로 둔다.
        1. _body_가 |GeneratorBody|의 |FunctionBody|이면 *false*를 반환한다.
        1. _body_가 |AsyncFunctionBody|의 |FunctionBody|이면 *false*를 반환한다.
        1. _body_가 |AsyncGeneratorBody|의 |FunctionBody|이면 *false*를 반환한다.
        1. _body_가 |AsyncConciseBody|이면 *false*를 반환한다.
        1. _body_의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-note>
        <p>꼬리 위치 호출은 엄격 모드 코드에서만 정의된다. 이는 비표준 언어 확장( <emu-xref href="#sec-addrestrictedfunctionproperties"></emu-xref> 참조 )으로 인해 호출자 컨텍스트 체인을 관찰할 수 있게 되기 때문이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo" oldids="sec-statement-rules,sec-expression-rules">
      <h1>
        정적 의미론: HasCallInTailPosition(
        _call_: |CallExpression| Parse Node 또는 |MemberExpression| Parse Node 또는 |OptionalChain| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_은 소스 텍스트의 특정 범위를 나타내는 Parse Node이다. 아래 알고리즘에서 _call_을 다른 Parse Node와 비교할 때는 둘이 동일한 소스 텍스트를 나타내는지 여부를 검사한다.</p>
      </emu-note>
      <emu-note>
        <p>return GetValue로 바로 이어지는 잠재적 꼬리 위치 호출도 꼬리 위치 호출이 될 수 있다. 함수 호출은 Reference Record를 반환할 수 없으므로, 이런 GetValue 연산은 항상 실제 함수 호출 결과와 동일한 값을 반환한다.</p>
      </emu-note>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. |StatementList|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionStatementList :
          [empty]

        StatementListItem :
          Declaration

        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        ReturnStatement :
          `return` `;`

        LabelledItem :
          FunctionDeclaration

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        CaseBlock :
          `{` `}`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 첫 번째 |Statement|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement

        DoWhileStatement :
          `do` Statement `while` `(` Expression `)` `;`

        WhileStatement :
          `while` `(` Expression `)` Statement

        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement

        WithStatement :
          `with` `(` Expression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        LabelledStatement :
          LabelIdentifier `:` LabelledItem
      </emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. |Expression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _has_를 *false*로 둔다.
        1. 첫 번째 |CaseClauses|가 있으면, 그 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 있으면, 그 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. |CaseClauses|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        CaseClause : `case` Expression `:` StatementList?

        DefaultClause : `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. |StatementList|가 있으면 그 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. |Catch|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        TryStatement :
          `try` Block Finally
          `try` Block Catch Finally
      </emu-grammar>
      <emu-alg>
        1. |Finally|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>

      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        CallExpression :
          SuperCall
          ImportCall
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        Expression :
          AssignmentExpression
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. |AssignmentExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 첫 번째 |AssignmentExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |AssignmentExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. |BitwiseORExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. |LogicalANDExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. |BitwiseORExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 이 |CallExpression|이 _call_이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        OptionalExpression :
          MemberExpression OptionalChain
          CallExpression OptionalChain
          OptionalExpression OptionalChain
      </emu-grammar>
      <emu-alg>
        1. |OptionalChain|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` `[` Expression `]`
          `?.` IdentifierName
          `?.` PrivateIdentifier
          OptionalChain `[` Expression `]`
          OptionalChain `.` IdentifierName
          OptionalChain `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` Arguments
          OptionalChain Arguments
      </emu-grammar>
      <emu-alg>
        1. 이 |OptionalChain|이 _call_이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        MemberExpression :
          MemberExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 이 |MemberExpression|이 _call_이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. _expr_의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        ParenthesizedExpression :
          `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. |Expression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-preparefortailcall" type="abstract operation">
      <h1>PrepareForTailCall ( ): ~unused~</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 현재 실행 컨텍스트는 이후 ECMAScript 코드 또는 내장 함수의 평가에 사용되지 않을 것임을 단언한다. 이 추상 연산 이후 Call을 호출하면 해당 평가 전에 새 실행 컨텍스트가 생성되고 push된다.
        1. 현재 실행 컨텍스트와 관련된 모든 리소스를 폐기한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <p>꼬리 위치 호출은 현재 실행 중인 함수 실행 컨텍스트와 관련된 임시 내부 리소스를 호출 대상 함수 전에 해제하거나, 해당 함수에 재사용해야 한다.</p>
      <emu-note>
        <p>예를 들어, 꼬리 위치 호출은 대상 함수의 activation record가 호출 함수의 activation record보다 커지는 만큼만 스택 크기를 증가시켜야 한다. 대상 함수의 activation record가 더 작다면, 전체 스택 크기는 줄어들어야 한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript 언어: 스크립트와 모듈</h1>

  <emu-clause id="sec-scripts">
    <h1>스크립트</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        StatementList[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          |ScriptBody|의 LexicallyDeclaredNames가 중복 항목을 포함하면 구문 오류이다.
        </li>
        <li>
          |ScriptBody|의 LexicallyDeclaredNames의 어떤 요소가 |ScriptBody|의 VarDeclaredNames에도 나타나면 구문 오류이다.
        </li>
      </ul>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <ul>
        <li>
          `super`를 포함한 소스 텍스트가 직접 eval에 의해 처리되는 eval 코드가 아닌 한, |StatementList|가 `super`를 포함하면 구문 오류이다. 직접 eval 내의 `super`에 대한 추가 조기 오류 규칙은 <emu-xref href="#sec-performeval"></emu-xref>에 정의되어 있다.
        </li>
        <li>
          |NewTarget|을 포함한 소스 텍스트가 직접 eval에 의해 처리되는 eval 코드가 아닌 한, |StatementList|가 |NewTarget|을 포함하면 구문 오류이다. 직접 eval에서 |NewTarget|에 대한 추가 조기 오류 규칙은 <emu-xref href="#sec-performeval"></emu-xref>에 정의되어 있다.
        </li>
        <li>
          인수 « »를 사용한 |StatementList|의 ContainsDuplicateLabels가 *true*이면 구문 오류이다.
        </li>
        <li>
          인수 « »를 사용한 |StatementList|의 ContainsUndefinedBreakTarget이 *true*이면 구문 오류이다.
        </li>
        <li>
          인수 « »와 « »를 사용한 |StatementList|의 ContainsUndefinedContinueTarget이 *true*이면 구문 오류이다.
        </li>
        <li>
          |ScriptBody|를 포함한 소스 텍스트가 직접 eval에 의해 처리되는 eval 코드가 아닌 한, 인수 « »를 사용한 |StatementList|의 AllPrivateIdentifiersValid가 *false*이면 구문 오류이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-scriptisstrict" oldids="sec-static-semantics-isstrict" type="sdo">
      <h1>정적 의미론: ScriptIsStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Script : ScriptBody?</emu-grammar>
      <emu-alg>
        1. |ScriptBody|가 존재하고 |ScriptBody|의 Directive Prologue가 Use Strict Directive를 포함하면 *true*를 반환하고, 그렇지 않으면 *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-records">
      <h1>스크립트 레코드</h1>

      <p><dfn id="script-record" variants="Script Records">스크립트 레코드</dfn>는 평가되는 스크립트에 대한 정보를 캡슐화한다. 각 스크립트 레코드는 <emu-xref href="#table-script-records"></emu-xref>에 나열된 필드를 포함한다.</p>

      <emu-table id="table-script-records" caption="스크립트 레코드 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              Realm Record
            </td>
            <td>
              이 스크립트가 생성된 영역.
            </td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              |Script| Parse Node
            </td>
            <td>
              이 스크립트의 소스 텍스트를 파싱한 결과.
            </td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              LoadedModuleRequest Records의 리스트
            </td>
            <td>
              이 스크립트가 가져온 지정자 문자열에서 해결된 Module Record로의 맵. 리스트는 ModuleRequestsEqual(_r1_, _r2_)이 *true*인 서로 다른 Records _r1_과 _r2_를 두 개 포함하지 않는다.
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (기본값은 ~empty~)
            </td>
            <td>
              스크립트와 추가 정보를 연결해야 하는 호스트 환경에서 사용하기 위해 예약된 필드.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript 소스 텍스트,
          _realm_: Realm Record,
          _hostDefined_: anything,
        ): Script Record 또는 *SyntaxError* 객체의 비어있지 않은 리스트
      </h1>
      <dl class="header">
        <dt>설명</dt>
        <dd>_sourceText_를 |Script|로 파싱한 결과를 기반으로 Script Record를 생성한다.</dd>
      </dl>

      <emu-alg>
        1. _script_를 ParseText(_sourceText_, |Script|)로 둔다.
        1. _script_가 오류의 리스트이면 _script_를 반환한다.
        1. Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }를 반환한다.
      </emu-alg>
      <emu-note>
        <p>구현은 해당 스크립트 소스 텍스트에 대해 ParseScript를 평가하기 전에 스크립트 소스 텍스트를 파싱하고 조기 오류 조건을 분석할 수 있다. 그러나 오류 보고는 이 명세가 실제로 해당 소스 텍스트에 대해 ParseScript를 수행하는 시점까지 연기되어야 한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-scriptevaluation" type="abstract operation">
      <h1>
        ScriptEvaluation (
          _scriptRecord_: Script Record,
        ): ECMAScript 언어 값을 포함하는 정상 완료 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-alg>
        1. _globalEnv_를 _scriptRecord_.[[Realm]].[[GlobalEnv]]로 둔다.
        1. _scriptContext_를 새로운 ECMAScript 코드 실행 컨텍스트로 둔다.
        1. _scriptContext_의 Function을 *null*로 설정한다.
        1. _scriptContext_의 Realm을 _scriptRecord_.[[Realm]]으로 설정한다.
        1. _scriptContext_의 ScriptOrModule을 _scriptRecord_로 설정한다.
        1. _scriptContext_의 VariableEnvironment를 _globalEnv_로 설정한다.
        1. _scriptContext_의 LexicalEnvironment를 _globalEnv_로 설정한다.
        1. _scriptContext_의 PrivateEnvironment를 *null*로 설정한다.
        1. 실행 중인 실행 컨텍스트를 일시 중단한다.
        1. _scriptContext_를 실행 컨텍스트 스택에 푸시한다; _scriptContext_가 이제 실행 중인 실행 컨텍스트이다.
        1. _script_를 _scriptRecord_.[[ECMAScriptCode]]로 둔다.
        1. _result_를 Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_))로 둔다.
        1. _result_가 정상 완료이면
          1. _result_를 Completion(Evaluation of _script_)로 설정한다.
          1. _result_가 정상 완료이고 _result_.[[Value]]가 ~empty~이면
            1. _result_를 NormalCompletion(*undefined*)로 설정한다.
        1. _scriptContext_를 일시 중단하고 실행 컨텍스트 스택에서 제거한다.
        1. 단언: 실행 컨텍스트 스택이 비어있지 않다.
        1. 이제 실행 컨텍스트 스택의 맨 위에 있는 컨텍스트를 실행 중인 실행 컨텍스트로 재개한다.
        1. ? _result_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-globaldeclarationinstantiation">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: |Script| Parse Node,
          _env_: Global Environment Record,
        ): ~unused~를 포함하는 정상 완료 또는 throw completion
      </h1>
      <dl class="header">
        <dt>설명</dt>
        <dd>_script_는 실행 컨텍스트가 설정되는 |Script|이다. _env_는 바인딩이 생성될 전역 환경이다.</dd>
      </dl>
      <emu-note>
        <p>스크립트 평가를 위한 실행 컨텍스트가 설정될 때, 선언은 현재 전역 환경에서 인스턴스화된다. 코드에서 선언된 각 전역 바인딩이 인스턴스화된다.</p>
      </emu-note>
      <p>호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _lexNames_를 _script_의 LexicallyDeclaredNames로 둔다.
        1. _varNames_를 _script_의 VarDeclaredNames로 둔다.
        1. _lexNames_의 각 요소 _name_에 대해
          1. HasLexicalDeclaration(_env_, _name_)이 *true*이면 *SyntaxError* 예외를 던진다.
          1. _hasRestrictedGlobal_을 ? HasRestrictedGlobalProperty(_env_, _name_)로 둔다.
          1. 참고: 전역 `var`와 `function` 바인딩(비-strict 직접 eval에 의해 도입된 것들을 제외하고)은 non-configurable이므로 제한된 전역 속성이다.
          1. _hasRestrictedGlobal_이 *true*이면 *SyntaxError* 예외를 던진다.
        1. _varNames_의 각 요소 _name_에 대해
          1. HasLexicalDeclaration(_env_, _name_)이 *true*이면 *SyntaxError* 예외를 던진다.
        1. _varDeclarations_를 _script_의 VarScopedDeclarations로 둔다.
        1. _functionsToInitialize_를 새로운 빈 리스트로 둔다.
        1. _declaredFunctionNames_를 새로운 빈 리스트로 둔다.
        1. _varDeclarations_의 각 요소 _d_에 대해 역순으로
          1. _d_가 |VariableDeclaration|, |ForBinding|, 또는 |BindingIdentifier|가 아니면
            1. 단언: _d_는 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, 또는 |AsyncGeneratorDeclaration| 중 하나이다.
            1. 참고: 같은 이름에 대해 여러 함수 선언이 있으면 마지막 선언이 사용된다.
            1. _fn_을 _d_의 BoundNames의 유일한 요소로 둔다.
            1. _declaredFunctionNames_가 _fn_을 포함하지 않으면
              1. _fnDefinable_을 ? CanDeclareGlobalFunction(_env_, _fn_)로 둔다.
              1. _fnDefinable_이 *false*이면 *TypeError* 예외를 던진다.
              1. _fn_을 _declaredFunctionNames_에 추가한다.
              1. _d_를 _functionsToInitialize_의 첫 번째 요소로 삽입한다.
        1. _declaredVarNames_를 새로운 빈 리스트로 둔다.
        1. _varDeclarations_의 각 요소 _d_에 대해
          1. _d_가 |VariableDeclaration|, |ForBinding|, 또는 |BindingIdentifier|이면
            1. _d_의 BoundNames의 각 String _vn_에 대해
              1. _declaredFunctionNames_가 _vn_을 포함하지 않으면
                1. _vnDefinable_을 ? CanDeclareGlobalVar(_env_, _vn_)로 둔다.
                1. _vnDefinable_이 *false*이면 *TypeError* 예외를 던진다.
                1. _declaredVarNames_가 _vn_을 포함하지 않으면
                  1. _vn_을 _declaredVarNames_에 추가한다.
        1. 참고: 전역 객체가 일반 객체인 경우 이 알고리즘 단계 이후에는 비정상적인 종료가 발생하지 않는다. 그러나 전역 객체가 Proxy exotic 객체인 경우 다음 단계 중 일부에서 비정상적인 종료를 유발하는 동작을 보일 수 있다.
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 그렇지 않으면 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>를 지원하면
          1. _strict_를 _script_의 ScriptIsStrict로 둔다.
          1. _strict_가 *false*이면
            1. _declaredFunctionOrVarNames_를 _declaredFunctionNames_와 _declaredVarNames_의 리스트 연결로 둔다.
            1. _script_가 _x_를 포함하는 것이 *true*인 |Block|, |CaseClause|, 또는 |DefaultClause| _x_의 |StatementList|에 직접 포함된 각 |FunctionDeclaration| _f_에 대해
              1. _F_를 _f_의 |BindingIdentifier|의 StringValue로 둔다.
              1. |FunctionDeclaration| _f_를 _F_를 |BindingIdentifier|로 가진 |VariableStatement|로 대체하는 것이 _script_에 대해 조기 오류를 생성하지 않으면
                1. HasLexicalDeclaration(_env_, _F_)가 *false*이면
                  1. _fnDefinable_을 ? CanDeclareGlobalVar(_env_, _F_)로 둔다.
                  1. _fnDefinable_이 *true*이면
                    1. 참고: _F_에 대한 var 바인딩은 VarDeclaredName도 아니고 다른 |FunctionDeclaration|의 이름도 아닌 경우에만 여기서 인스턴스화된다.
                    1. _declaredFunctionOrVarNames_가 _F_를 포함하지 않으면
                      1. ? CreateGlobalVarBinding(_env_, _F_, *false*)를 수행한다.
                      1. _F_를 _declaredFunctionOrVarNames_에 추가한다.
                    1. [id="step-globaldeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_가 평가될 때, <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>에서 제공하는 |FunctionDeclaration| Evaluation 알고리즘 대신 다음 단계를 수행한다:
                      1. _gEnv_를 실행 중인 실행 컨텍스트의 VariableEnvironment로 둔다.
                      1. _bEnv_를 실행 중인 실행 컨텍스트의 LexicalEnvironment로 둔다.
                      1. _fObj_를 ! _bEnv_.GetBindingValue(_F_, *false*)로 둔다.
                      1. ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*)를 수행한다.
                      1. ~unused~를 반환한다.
        1. _lexDeclarations_를 _script_의 LexicallyScopedDeclarations로 둔다.
        1. _privateEnv_를 *null*로 둔다.
        1. _lexDeclarations_의 각 요소 _d_에 대해
          1. 참고: 어휘적으로 선언된 이름은 여기서만 인스턴스화되고 초기화되지 않는다.
          1. _d_의 BoundNames의 각 요소 _dn_에 대해
            1. _d_의 IsConstantDeclaration이 *true*이면
              1. ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*)를 수행한다.
            1. 그렇지 않으면
              1. ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*)를 수행한다.
        1. _functionsToInitialize_의 각 Parse Node _f_에 대해
          1. _fn_을 _f_의 BoundNames의 유일한 요소로 둔다.
          1. _fo_를 인수 _env_와 _privateEnv_를 사용한 _f_의 InstantiateFunctionObject로 둔다.
          1. ? <emu-meta effects="user-code">CreateGlobalFunctionBinding</emu-meta>(_env_, _fn_, _fo_, *false*)를 수행한다.
        1. _declaredVarNames_의 각 String _vn_에 대해
          1. ? <emu-meta effects="user-code">CreateGlobalVarBinding</emu-meta>(_env_, _vn_, *false*)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref>에 명시된 조기 오류는 function/var 선언과 let/const/class 선언 간의 이름 충돌뿐만 아니라 단일 |Script| 내에 포함된 선언에 대한 let/const/class 바인딩의 재선언을 방지한다. 그러나 둘 이상의 |Script|에 걸친 이러한 충돌과 재선언은 GlobalDeclarationInstantiation 중에 런타임 오류로 감지된다. 이러한 오류가 감지되면 스크립트에 대해 바인딩이 인스턴스화되지 않는다. 그러나 전역 객체가 Proxy exotic 객체를 사용하여 정의된 경우 충돌하는 선언에 대한 런타임 테스트가 신뢰할 수 없어 abrupt completion과 일부 전역 선언이 인스턴스화되지 않을 수 있다. 이런 경우 |Script|의 코드는 평가되지 않는다.</p>
        <p>명시적인 var 또는 function 선언과 달리, 전역 객체에서 직접 생성된 속성은 let/const/class 선언에 의해 가려질 수 있는 전역 바인딩을 만든다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>모듈</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>모듈 의미론</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            |ModuleItemList|의 LexicallyDeclaredNames가 중복 항목을 포함하면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|의 LexicallyDeclaredNames의 어떤 요소가 |ModuleItemList|의 VarDeclaredNames에도 나타나면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|의 ExportedNames가 중복 항목을 포함하면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|의 ExportedBindings의 어떤 요소가 |ModuleItemList|의 VarDeclaredNames 또는 LexicallyDeclaredNames에 나타나지 않으면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|가 `super`를 포함하면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|가 |NewTarget|을 포함하면 구문 오류이다.
          </li>
          <li>
            인수 « »를 사용한 |ModuleItemList|의 ContainsDuplicateLabels가 *true*이면 구문 오류이다.
          </li>
          <li>
            인수 « »를 사용한 |ModuleItemList|의 ContainsUndefinedBreakTarget이 *true*이면 구문 오류이다.
          </li>
          <li>
            인수 « »와 « »를 사용한 |ModuleItemList|의 ContainsUndefinedContinueTarget이 *true*이면 구문 오류이다.
          </li>
          <li>
            인수 « »를 사용한 |ModuleItemList|의 AllPrivateIdentifiersValid가 *false*이면 구문 오류이다.
          </li>
        </ul>
        <emu-note>
          <p>중복된 ExportedNames 규칙은 |ModuleBody| 내에서 여러 `export default` |ExportDeclaration| 항목이 구문 오류임을 의미한다. 충돌하거나 중복된 선언과 관련된 추가 오류 조건은 |Module| 평가 전에 모듈 링킹 중에 확인된다. 이러한 오류가 감지되면 |Module|은 평가되지 않는다.</p>
        </emu-note>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <ul>
          <li>IsStringWellFormedUnicode(SV of |StringLiteral|)이 *false*이면 구문 오류이다.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-importedlocalnames" type="abstract operation">
        <h1>
          정적 의미론: ImportedLocalNames (
          _importEntries_: ImportEntry Records의 리스트,
          ): 문자열의 리스트
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_importEntries_에 의해 정의된 모든 로컬 이름 바인딩의 리스트를 생성한다.</dd>
        </dl>
        <emu-alg>
          1. _localNames_를 새로운 빈 리스트로 둔다.
          1. _importEntries_의 각 ImportEntry Record _i_에 대해
            1. _i_.[[LocalName]]을 _localNames_에 추가한다.
          1. _localNames_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulerequest-record">
        <h1>ModuleRequest 레코드</h1>

        <p><dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest 레코드</dfn>는 주어진 가져오기 속성을 가진 모듈을 가져오는 요청을 나타낸다. 다음 필드들로 구성된다:</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest 레코드 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                문자열
              </td>
              <td>
                모듈 지정자
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Records의 리스트
              </td>
              <td>
                가져오기 속성
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="loadedmodulerequest-record" variants="LoadedModuleRequest Records">LoadedModuleRequest 레코드</dfn>는 모듈을 가져오는 요청과 결과 Module Record를 함께 나타낸다. 표 <emu-xref href="#table-modulerequest-fields"></emu-xref>에 정의된 동일한 필드들과 [[Module]] 필드의 추가로 구성된다:</p>
        <emu-table id="table-loadedmodulerequest-fields" caption="LoadedModuleRequest 레코드 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                문자열
              </td>
              <td>
                모듈 지정자
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Records의 리스트
              </td>
              <td>
                가져오기 속성
              </td>
            </tr>
            <tr>
              <td>
                [[Module]]
              </td>
              <td>
                Module Record
              </td>
              <td>
                이 모듈 요청에 해당하는 로드된 모듈
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="importattribute-record" variants="ImportAttribute Records">ImportAttribute 레코드</dfn>는 다음 필드들로 구성된다:</p>
        <emu-table id="table-importattribute-fields" caption="ImportAttribute 레코드 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                문자열
              </td>
              <td>
                속성 키
              </td>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                문자열
              </td>
              <td>
                속성 값
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ModuleRequestsEqual" type="abstract operation">
          <h1>
            ModuleRequestsEqual (
              _left_: ModuleRequest Record 또는 LoadedModuleRequest Record,
              _right_: ModuleRequest Record 또는 LoadedModuleRequest Record,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. _left_.[[Specifier]]가 _right_.[[Specifier]]와 같지 않으면 *false*를 반환한다.
            1. _leftAttrs_를 _left_.[[Attributes]]로 둔다.
            1. _rightAttrs_를 _right_.[[Attributes]]로 둔다.
            1. _leftAttrsCount_를 _leftAttrs_의 요소 개수로 둔다.
            1. _rightAttrsCount_를 _rightAttrs_의 요소 개수로 둔다.
            1. _leftAttrsCount_ ≠ _rightAttrsCount_이면 *false*를 반환한다.
            1. _leftAttrs_의 각 ImportAttribute Record _l_에 대해
              1. _rightAttrs_가 _l_.[[Key]]가 _r_.[[Key]]이고 _l_.[[Value]]가 _r_.[[Value]]인 ImportAttribute Record _r_을 포함하지 않으면 *false*를 반환한다.
            1. *true*를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo">
        <h1>정적 의미론: ModuleRequests ( ): ModuleRequest Records의 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 새로운 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. |ModuleItem|의 ModuleRequests를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _requests_를 |ModuleItemList|의 ModuleRequests로 둔다.
          1. _additionalRequests_를 |ModuleItem|의 ModuleRequests로 둔다.
          1. _additionalRequests_의 각 ModuleRequest Record _mr_에 대해
            1. _requests_가 ModuleRequestsEqual(_mr_, _mr2_)이 *true*인 ModuleRequest Record _mr2_를 포함하지 않으면
              1. _mr_을 _requests_에 추가한다.
          1. _requests_를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. 새로운 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. _attributes_를 |WithClause|의 WithClauseToAttributes로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |ModuleSpecifier|의 SV로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |ModuleSpecifier|의 SV로 둔다.
          1. _attributes_를 |WithClause|의 WithClauseToAttributes로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause WithClause `;`
        </emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. _attributes_를 |WithClause|의 WithClauseToAttributes로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 새로운 빈 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>추상 모듈 레코드</h1>
        <p><dfn variants="Module Records">모듈 레코드</dfn>는 단일 모듈의 가져오기와 내보내기에 대한 구조적 정보를 캡슐화한다. 이 정보는 연결된 모듈 집합의 가져오기와 내보내기를 링크하는 데 사용된다. 모듈 레코드는 모듈을 평가할 때만 사용되는 네 개의 필드를 포함한다.</p>
        <p>명세 목적상 Module Record 값은 Record 명세 타입의 값이며, Module Record가 추상 클래스이고 추상 및 구체적 하위 클래스를 모두 가진 간단한 객체 지향 계층 구조에 존재하는 것으로 생각할 수 있다. 이 명세는 Cyclic Module Record라는 추상 하위 클래스와 그 구체적 하위 클래스인 Source Text Module Record를 정의한다. 다른 명세와 구현은 그들이 정의한 대안적인 모듈 정의 기능에 해당하는 추가적인 Module Record 하위 클래스를 정의할 수 있다.</p>
        <p>Module Record는 <emu-xref href="#table-module-record-fields"></emu-xref>에 나열된 필드들을 정의한다. 모든 Module Definition 하위 클래스는 적어도 이러한 필드들을 포함한다. Module Record는 또한 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>의 추상 메서드 리스트를 정의한다. 모든 Module definition 하위 클래스는 이러한 추상 메서드들의 구체적인 구현을 제공해야 한다.</p>
        <emu-table id="table-module-record-fields" caption="모듈 레코드 필드" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                Realm Record
              </td>
              <td>
                이 모듈이 생성된 Realm.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                Module Environment Record 또는 ~empty~
              </td>
              <td>
                이 모듈의 최상위 바인딩을 포함하는 Environment Record. 이 필드는 모듈이 링크될 때 설정된다.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                Object 또는 ~empty~
              </td>
              <td>
                이 모듈에 대해 생성된 Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>).
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (기본값은 *undefined*)
              </td>
              <td>
                모듈과 추가 정보를 연결해야 하는 호스트 환경에서 사용하기 위해 예약된 필드.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="모듈 레코드의 추상 메서드" oldids="table-37">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                LoadRequestedModules([_hostDefined_])
              </td>
              <td>
                <p>모든 의존성을 재귀적으로 로드하여 모듈을 링킹을 위해 준비하고 프로미스를 반환한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>이 모듈에서 직접 또는 간접적으로 내보내지는 모든 이름의 리스트를 반환한다.</p>
                <p>이 메서드를 호출하기 전에 LoadRequestedModules가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>이 모듈에서 내보낸 이름의 바인딩을 반환한다. 바인딩은 { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ } 형태의 <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn>로 표현된다. 내보내기가 어떤 모듈에서도 직접 바인딩이 없는 Module Namespace Object인 경우 [[BindingName]]은 ~namespace~로 설정된다. 이름을 해결할 수 없으면 *null*을, 여러 바인딩이 발견되면 ~ambiguous~를 반환한다.</p>
                <p>특정 _exportName_, _resolveSet_ 쌍을 인수로 이 연산을 호출할 때마다 동일한 결과를 반환해야 한다.</p>
                <p>이 메서드를 호출하기 전에 LoadRequestedModules가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>모든 모듈 의존성을 전이적으로 해결하고 Module Environment Record를 생성하여 모듈을 평가를 위해 준비한다.</p>
                <p>이 메서드를 호출하기 전에 LoadRequestedModules가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>이 모듈과 그 의존성의 평가에 대한 프로미스를 반환하며, 성공적인 평가 시 또는 이미 성공적으로 평가된 경우 해결되고, 평가 오류 시 또는 이미 성공적이지 않게 평가된 경우 거부된다. 프로미스가 거부되면 호스트는 프로미스 거부를 처리하고 평가 오류를 다시 던질 것으로 예상된다.</p>
                <p>이 메서드를 호출하기 전에 Link가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-EvaluateModuleSync" type="abstract operation">
          <h1>
            EvaluateModuleSync (
              _module_: Module Record,
            ): ~unused~를 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd>호출자가 _module_의 평가가 이미 정착된 프로미스를 반환할 것임을 보장하는 경우 _module_을 동기적으로 평가한다.</dd>
          </dl>

          <emu-alg>
            1. 단언: _module_은 Cyclic Module Record가 아니다.
            1. _promise_를 _module_.Evaluate()로 둔다.
            1. 단언: _promise_.[[PromiseState]]는 ~fulfilled~ 또는 ~rejected~ 중 하나이다.
            1. _promise_.[[PromiseState]]가 ~rejected~이면
              1. _promise_.[[PromiseIsHandled]]이 *false*이면 HostPromiseRejectionTracker(_promise_, *"handle"*)를 수행한다.
              1. _promise_.[[PromiseIsHandled]]을 *true*로 설정한다.
              1. ThrowCompletion(_promise_.[[PromiseResult]])를 반환한다.
            1. ~unused~를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>순환 모듈 레코드</h1>
        <p><dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn>는 Cyclic Module Record 타입의 하위 클래스인 다른 모듈들과 의존성 순환(dependency cycle)에 참여할 수 있는 모듈에 대한 정보를 표현하는 데 사용된다. Cyclic Module Record 타입의 하위 클래스가 아닌 Module Record 는 Source Text Module Record 와의 의존성 순환에 참여해서는 안 된다.</p>
        <p><emu-xref href="#table-module-record-fields"></emu-xref>에 정의된 필드들에 더해, Cyclic Module Record 는 <emu-xref href="#table-cyclic-module-fields"></emu-xref>에 나열된 추가 필드를 가진다.</p>
        <emu-table id="table-cyclic-module-fields" caption="Cyclic Module Record 의 추가 필드">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, 또는 ~evaluated~
              </td>
              <td>
                초기 값은 ~new~. 모듈 생명주기 진행에 따라 순서대로 ~unlinked~, ~linking~, ~linked~, ~evaluating~, 필요 시 ~evaluating-async~, ~evaluated~ 로 전이한다. ~evaluating-async~ 는 이 모듈이 비동기 의존성 완료 후 실행 대기열에 들어 있거나, [[HasTLA]] 필드가 *true* 이어서 실행되었고 최상위 완료를 대기 중임을 나타낸다.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                throw completion 또는 ~empty~
              </td>
              <td>
                평가 중 발생한 예외를 나타내는 throw completion. 예외가 없었거나 [[Status]]가 ~evaluated~ 가 아니면 *undefined*.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                정수 또는 ~empty~
              </td>
              <td>
                Link 및 Evaluate 동안에만 사용하는 보조 필드. [[Status]]가 ~linking~ 또는 ~evaluating~ 이면, 모듈 자신의 DFS(깊이 우선 탐색) 인덱스이거나 동일 SCC(강한 연결 요소) 내 “더 이른” 모듈의 인덱스이다.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                ModuleRequest Record 리스트
              </td>
              <td>
                이 모듈의 import 들에 연관된 ModuleRequest Record 리스트. 소스 텍스트상의 등장 순서를 따른다.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                LoadedModuleRequest Record 리스트
              </td>
              <td>
                이 Record가 표현하는 모듈이 사용한 지정자 문자열을 (상대 import 속성 집합과 함께) 해석된 Module Record 로 매핑하는 맵. ModuleRequestsEqual(_r1_, _r2_)가 *true* 인 서로 다른 Record _r1_, _r2_ 를 두 개 포함하지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                Cyclic Module Record 또는 ~empty~
              </td>
              <td>
                순환의 최초 방문 모듈, 즉 SCC 의 루트 DFS 선조. 순환에 속하지 않는 모듈이면 자기 자신. Evaluate 완료 후 모듈의 [[DFSAncestorIndex]] 는 그 [[CycleRoot]] 의 DFS 인덱스가 된다.
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                이 모듈이 개별적으로 비동기인지 여부(예: top-level await 를 포함하는 Source Text Module Record). 비동기 의존성이 있다는 사실만으로 *true* 는 아니다. 파싱 후 이 필드는 변하지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluationOrder]]
              </td>
              <td>
                ~unset~, 정수, 또는 ~done~
              </td>
              <td>
                초기 ~unset~ 이며 완전 동기 모듈은 계속 ~unset~. 자체가 비동기이거나 비동기 의존성을 가지는 모듈은 <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref> 에 의해 대기 모듈 실행이 큐잉되는 순서를 결정하는 정수로 설정된다. 대기 모듈이 실행되면 ~done~ 으로 설정.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                PromiseCapability Record 또는 ~empty~
              </td>
              <td>
                이 모듈이 어떤 순환의 [[CycleRoot]] 이고 그 순환 내 어떤 모듈에 Evaluate() 가 호출되었다면, 그 전체 평가에 대한 PromiseCapability Record. Evaluate() 추상 메서드가 반환한 Promise 객체 해결에 사용된다. 해당 순환의 의존 모듈들은 최상위 Evaluate() 가 그들에 대해 개시되지 않았다면 ~empty~.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                Cyclic Module Record 리스트
              </td>
              <td>
                이 모듈 또는 그 의존성이 [[HasTLA]] *true* 인 상태로 실행 진행 중이면, 최상위 실행 작업에 대해 이 모듈의 상위 importer 들을 추적한다. 이 부모 모듈들은 이 모듈이 성공적으로 실행 완료하기 전에는 실행을 시작하지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                정수 또는 ~empty~
              </td>
              <td>
                비동기 의존성이 하나라도 있으면 남은 비동기 의존 모듈 수를 추적한다. 이 값이 0 이고 실행 오류가 없을 때 모듈이 실행된다.
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 메서드들에 더해 Cyclic Module Record 는 <emu-xref href="#table-cyclic-module-methods"></emu-xref> 에 나열된 추가 메서드를 가진다.</p>
        <emu-table id="table-cyclic-module-methods" caption="Cyclic Module Record 의 추가 추상 메서드">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                모든 import 된 바인딩을 해석하고 모듈의 Environment Record 를 초기화하며 실행 컨텍스트를 생성한다.
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule([_promiseCapability_])
              </td>
              <td>
                모듈의 실행 컨텍스트 내에서 코드 평가. 이 모듈이 [[HasTLA]] 가 *true* 이면 PromiseCapability Record 가 인수로 전달되며 메서드는 해당 capability 를 resolve 또는 reject 해야 한다. 이 경우 예외를 throw 하지 말고 필요 시 PromiseCapability Record 를 reject 해야 한다.
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> 는 모듈 그래프 로딩 과정에 대한 정보를 담는 Record 이다. HostLoadImportedModule 호출 이후 로딩을 계속하기 위해 사용된다. 각 GraphLoadingState Record 는 <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref> 에 정의된 필드를 가진다:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record 필드">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                PromiseCapability Record
              </td>
              <td>
                로딩 프로세스 완료 시 resolve 해야 하는 Promise.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                로딩이 아직 성공/오류 어떤 형태로도 완료되지 않았으면 *true*.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                음이 아닌 정수
              </td>
              <td>
                대기 중인 HostLoadImportedModule 호출 수를 추적.
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                Cyclic Module Record 리스트
              </td>
              <td>
                현재 로딩 과정에서 이미 로드된 Cyclic Module Record 리스트(순환 의존 무한 루프 방지).
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (기본값 ~empty~)
              </td>
              <td>
                LoadRequestedModules 호출자에서 HostLoadImportedModule 로 전달할 호스트 정의 데이터.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-cyclic-module-record-module-record-methods">
          <h1>Module Record 추상 메서드 구현</h1>

          <p>다음은 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 Module Record 추상 메서드를 구현하는 Cyclic Module Record 의 구체 메서드이다.</p>

          <emu-clause id="sec-LoadRequestedModules" type="concrete method">
            <h1>
              LoadRequestedModules (
                optional _hostDefined_: anything,
              ): Promise
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>_module_ 의 의존성 그래프 내 모든 Module Record 의 [[LoadedModules]] 를 채운다(주요 작업은 보조 함수 InnerModuleLoading 이 수행). 선택적 _hostDefined_ 는 HostLoadImportedModule 훅에 전달된다.</dd>
            </dl>

            <emu-alg>
              1. _hostDefined_ 가 없으면 _hostDefined_ 를 ~empty~ 로 둔다.
              1. _pc_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
              1. _state_ 를 GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ } 로 둔다.
              1. InnerModuleLoading(_state_, _module_) 를 수행한다.
              1. _pc_.[[Promise]] 를 반환한다.
            </emu-alg>

            <emu-note>
              _hostDefined_ 매개변수는 import 된 모듈을 가져오는 데 필요한 추가 정보를 전달하는 데 사용할 수 있다. 예를 들어 HTML 은 <code>&lt;link rel="preload" as="..."&gt;</code> 태그에 대한 올바른 fetch destination 설정에 사용한다.
              <code>import()</code> 표현식은 _hostDefined_ 를 설정하지 않는다.
            </emu-note>

            <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
              <h1>
                InnerModuleLoading (
                  _state_: GraphLoadingState Record,
                  _module_: Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>LoadRequestedModules 가 _module_ 의 의존성 그래프에 대해 실제 로딩을 재귀적으로 수행할 때 사용된다.</dd>
              </dl>

              <emu-alg>
                1. 단언: _state_.[[IsLoading]] 은 *true*.
                1. _module_ 이 Cyclic Module Record 이고, _module_.[[Status]] 가 ~new~, 그리고 _state_.[[Visited]] 가 _module_ 을 포함하지 않으면
                  1. _module_ 을 _state_.[[Visited]] 에 추가한다.
                  1. _requestedModulesCount_ 를 _module_.[[RequestedModules]] 요소 수로 둔다.
                  1. _state_.[[PendingModulesCount]] 를 _state_.[[PendingModulesCount]] + _requestedModulesCount_ 로 설정.
                  1. _module_.[[RequestedModules]] 의 각 ModuleRequest Record _request_ 에 대해
                    1. AllImportAttributesSupported(_request_.[[Attributes]]) 가 *false* 이면
                      1. _error_ 를 ThrowCompletion(새로 생성된 *SyntaxError* 객체) 로 둔다.
                      1. ContinueModuleLoading(_state_, _error_) 수행.
                    1. Else if _module_.[[LoadedModules]] 가 ModuleRequestsEqual(_record_, _request_) 가 *true* 인 LoadedModuleRequest Record _record_ 를 포함하면
                      1. InnerModuleLoading(_state_, _record_.[[Module]]) 수행.
                    1. Else,
                      1. HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_) 수행.
                      1. 참고: HostLoadImportedModule 은 FinishLoadingImportedModule 를 호출하고 이는 ContinueModuleLoading 을 통해 그래프 로딩 과정에 재진입한다.
                    1. _state_.[[IsLoading]] 이 *false* 이면 ~unused~ 반환.
                1. 단언: _state_.[[PendingModulesCount]] ≥ 1.
                1. _state_.[[PendingModulesCount]] 를 _state_.[[PendingModulesCount]] - 1 로 설정.
                1. _state_.[[PendingModulesCount]] = 0 이면
                  1. _state_.[[IsLoading]] 를 *false* 로 둔다.
                  1. _state_.[[Visited]] 의 각 Cyclic Module Record _loaded_ 에 대해
                    1. _loaded_.[[Status]] 가 ~new~ 이면 ~unlinked~ 로 설정.
                  1. ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
              <h1>
                ContinueModuleLoading (
                  _state_: GraphLoadingState Record,
                  _moduleCompletion_: Module Record 를 담은 정상 completion 또는 throw completion,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>HostLoadImportedModule 호출 후 로딩 과정에 재진입할 때 사용된다.</dd>
              </dl>

              <emu-alg>
                1. _state_.[[IsLoading]] 이 *false* 이면 ~unused~ 반환.
                1. _moduleCompletion_ 이 정상 completion 이면
                  1. InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]) 수행.
                1. Else,
                  1. _state_.[[IsLoading]] 를 *false* 로 둔다.
                  1. ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
            <h1>Link ( ): ~unused~ 를 담은 정상 completion 또는 throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>성공 시 이 모듈의 [[Status]] 를 ~unlinked~ 에서 ~linked~ 로 전이. 실패 시 예외를 던지고 [[Status]] 는 ~unlinked~ 유지. (주요 작업은 보조 함수 InnerModuleLinking 수행)</dd>
            </dl>

            <emu-alg>
              1. 단언: _module_.[[Status]] 는 ~unlinked~, ~linked~, ~evaluating-async~, ~evaluated~ 중 하나.
              1. _stack_ 을 새 빈 리스트로 둔다.
              1. _result_ 를 Completion(InnerModuleLinking(_module_, _stack_, 0)) 로 둔다.
              1. _result_ 가 abrupt completion 이면
                1. _stack_ 의 각 Cyclic Module Record _m_ 에 대해
                  1. 단언: _m_.[[Status]] 는 ~linking~.
                  1. _m_.[[Status]] 를 ~unlinked~ 로 설정.
                1. 단언: _module_.[[Status]] 는 ~unlinked~.
                1. ? _result_ 반환.
              1. 단언: _module_.[[Status]] 는 ~linked~, ~evaluating-async~, 또는 ~evaluated~ 중 하나.
              1. 단언: _stack_ 은 비어 있음.
              1. ~unused~ 반환.
            </emu-alg>

            <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
              <h1>
                InnerModuleLinking (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record 리스트,
                  _index_: 음이 아닌 정수,
                ): 음이 아닌 정수를 담은 정상 completion 또는 throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Link 가 _module_ 및 의존성 그래프의 다른 모듈들에 대해 실제 링크 과정을 수행. _stack_ 과 _index_, 그리고 모듈의 [[DFSAncestorIndex]] 는 DFS 탐색 추적에 사용. 특히 [[DFSAncestorIndex]] 로 SCC 를 발견하여 SCC 내 모든 모듈이 함께 ~linked~ 로 전이되도록 한다.</dd>
              </dl>

              <emu-alg>
                1. _module_ 이 Cyclic Module Record 가 아니면
                  1. ? _module_.Link() 수행.
                  1. _index_ 반환.
                1. _module_.[[Status]] 가 ~linking~, ~linked~, ~evaluating-async~, ~evaluated~ 중 하나이면
                  1. _index_ 반환.
                1. 단언: _module_.[[Status]] 는 ~unlinked~.
                1. _module_.[[Status]] 를 ~linking~ 으로 둔다.
                1. _moduleIndex_ 를 _index_ 로 둔다.
                1. _module_.[[DFSAncestorIndex]] 를 _index_ 로 둔다.
                1. _index_ 를 _index_ + 1 로 설정.
                1. _module_ 을 _stack_ 에 추가.
                1. _module_.[[RequestedModules]] 의 각 ModuleRequest Record _request_ 에 대해
                  1. _requiredModule_ 를 GetImportedModule(_module_, _request_) 로 둔다.
                  1. _index_ 를 ? InnerModuleLinking(_requiredModule_, _stack_, _index_) 로 설정.
                  1. _requiredModule_ 이 Cyclic Module Record 이면
                    1. 단언: _requiredModule_.[[Status]] 는 ~linking~, ~linked~, ~evaluating-async~, ~evaluated~ 중 하나.
                    1. 단언: _requiredModule_.[[Status]] 가 ~linking~ 인 것은 _stack_ 이 _requiredModule_ 을 포함함과 동치.
                    1. _requiredModule_.[[Status]] 가 ~linking~ 이면
                      1. _module_.[[DFSAncestorIndex]] 를 min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]) 로 설정.
                1. ? _module_.InitializeEnvironment() 수행.
                1. 단언: _module_ 은 _stack_ 에 정확히 한 번 등장.
                1. 단언: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
                1. _module_.[[DFSAncestorIndex]] = _moduleIndex_ 이면
                  1. _done_ 을 *false* 로 둔다.
                  1. 반복: _done_ 이 *false* 인 동안
                    1. _requiredModule_ 를 _stack_ 마지막 요소로 둔다.
                    1. 마지막 요소 제거.
                    1. 단언: _requiredModule_ 은 Cyclic Module Record.
                    1. _requiredModule_.[[Status]] 를 ~linked~ 로 설정.
                    1. _requiredModule_ 와 _module_ 이 동일 Module Record 이면 _done_ = *true*.
                1. _index_ 반환.
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduleevaluation" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>Evaluate 는 이 모듈의 [[Status]] 를 ~linked~ 에서 ~evaluating-async~ 또는 ~evaluated~ 로 전이. 동일 SCC 내에서 처음 호출될 때 Promise 를 생성해 모듈 평가 완료 시 resolve. 이 Promise 는 구성 요소 [[CycleRoot]] 의 [[TopLevelCapability]] 에 저장. 이후 SCC 내 어떤 모듈에 대한 Evaluate 호출도 동일 Promise 반환. (주요 작업은 보조 함수 InnerModuleEvaluation 수행)</dd>
            </dl>

            <emu-alg>
              1. 단언: 이번 Evaluate 호출은 주변 에이전트 내에서 다른 Evaluate 호출과 동시에 발생하지 않는다.
              1. 단언: _module_.[[Status]]는 ~linked~, ~evaluating-async~, ~evaluated~ 중 하나이다.
              1. _module_.[[Status]]가 ~evaluating-async~ 또는 ~evaluated~인 경우, _module_에 _module_.[[CycleRoot]]를 할당한다.
              1. _module_.[[TopLevelCapability]]가 ~empty~가 아니면,
                1. _module_.[[TopLevelCapability]].[[Promise]]를 반환한다.
              1. _stack_에 새로운 빈 리스트를 할당한다.
              1. _capability_에 ! NewPromiseCapability(%Promise%)를 할당한다.
              1. _module_.[[TopLevelCapability]]에 _capability_를 설정한다.
              1. _result_에 Completion(InnerModuleEvaluation(_module_, _stack_, 0))을 할당한다.
              1. _result_가 abrupt completion이면,
                1. _stack_의 각 Cyclic Module Record _m_에 대해,
                  1. 단언: _m_.[[Status]]는 ~evaluating~이다.
                  1. 단언: _m_.[[AsyncEvaluationOrder]]는 ~unset~이다.
                  1. _m_.[[Status]]를 ~evaluated~로 설정한다.
                  1. _m_.[[EvaluationError]]에 _result_를 설정한다.
                1. 단언: _module_.[[Status]]는 ~evaluated~이다.
                1. 단언: _module_.[[EvaluationError]]와 _result_는 동일한 Completion Record이다.
                1. ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »)를 수행한다.
              1. 그렇지 않으면,
                1. 단언: _module_.[[Status]]는 ~evaluating-async~ 또는 ~evaluated~이다.
                1. 단언: _module_.[[EvaluationError]]는 ~empty~이다.
                1. _module_.[[Status]]가 ~evaluated~이면,
                  1. 단언: _module_.[[AsyncEvaluationOrder]]는 ~unset~ 또는 ~done~이다.
                  1. 참고: _module_.[[AsyncEvaluationOrder]]가 ~done~인 경우는 오직 _module_이 이미 평가되었고 그 평가가 비동기였을 때뿐이다.
                  1. ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »)를 수행한다.
                1. 단언: _stack_은 비어 있다.
              1. _capability_.[[Promise]]를 반환한다.
            </emu-alg>

            <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
              <h1>
                InnerModuleEvaluation (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record 리스트,
                  _index_: 음이 아닌 정수,
                ): 음이 아닌 정수를 담은 정상 completion 또는 throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Evaluate 가 _module_ 및 의존성 그래프의 다른 모듈에 대해 실제 평가 과정을 수행. _stack_, _index_, 그리고 _module_ 의 [[DFSAncestorIndex]] 사용 방식은 InnerModuleLinking 과 동일.</dd>
              </dl>

              <emu-alg>
                1. _module_ 이 Cyclic Module Record 가 아니면
                  1. ? EvaluateModuleSync(_module_) 수행.
                  1. _index_ 반환.
                1. _module_.[[Status]] 가 ~evaluating-async~ 또는 ~evaluated~ 이면
                  1. _module_.[[EvaluationError]] 가 ~empty~ 이면 _index_ 반환.
                  1. 아니면 ? _module_.[[EvaluationError]] 반환.
                1. _module_.[[Status]] 가 ~evaluating~ 이면 _index_ 반환.
                1. 단언: _module_.[[Status]] 는 ~linked~.
                1. _module_.[[Status]] 를 ~evaluating~ 으로.
                1. _moduleIndex_ = _index_.
                1. _module_.[[DFSAncestorIndex]] = _index_.
                1. _module_.[[PendingAsyncDependencies]] = 0.
                1. _index_ = _index_ + 1.
                1. _module_ 을 _stack_ 에 추가.
                1. _module_.[[RequestedModules]] 의 각 ModuleRequest Record _request_ 에 대해
                  1. _requiredModule_ = GetImportedModule(_module_, _request_).
                  1. _index_ = ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                  1. _requiredModule_ 이 Cyclic Module Record 이면
                    1. 단언: _requiredModule_.[[Status]] 는 ~evaluating~, ~evaluating-async~, ~evaluated~ 중 하나.
                    1. 단언: _requiredModule_.[[Status]] 가 ~evaluating~ 인 것은 _stack_ 이 _requiredModule_ 포함과 동치.
                    1. _requiredModule_.[[Status]] 가 ~evaluating~ 이면
                      1. _module_.[[DFSAncestorIndex]] = min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                    1. Else,
                      1. _requiredModule_ = _requiredModule_.[[CycleRoot]].
                      1. 단언: _requiredModule_.[[Status]] 는 ~evaluating-async~ 또는 ~evaluated~.
                      1. _requiredModule_.[[EvaluationError]] 가 ~empty~ 가 아니면 ? _requiredModule_.[[EvaluationError]] 반환.
                    1. _requiredModule_.[[AsyncEvaluationOrder]] 가 정수이면
                      1. _module_.[[PendingAsyncDependencies]] += 1.
                      1. _module_ 을 _requiredModule_.[[AsyncParentModules]] 에 추가.
                1. _module_.[[PendingAsyncDependencies]] > 0 또는 _module_.[[HasTLA]] 가 *true* 이면
                  1. 단언: _module_.[[AsyncEvaluationOrder]] 는 ~unset~.
                  1. _module_.[[AsyncEvaluationOrder]] = IncrementModuleAsyncEvaluationCount().
                  1. _module_.[[PendingAsyncDependencies]] = 0 이면 ExecuteAsyncModule(_module_) 수행.
                1. Else,
                  1. ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta> 수행.
                1. 단언: _module_ 은 _stack_ 에 정확히 한 번 등장.
                1. 단언: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
                1. _module_.[[DFSAncestorIndex]] = _moduleIndex_ 이면
                  1. _done_ = *false*.
                  1. 반복 (_done_ 이 *false* 인 동안)
                    1. _requiredModule_ = _stack_ 마지막 요소.
                    1. 마지막 요소 제거.
                    1. 단언: _requiredModule_ 은 Cyclic Module Record.
                    1. 단언: _requiredModule_.[[AsyncEvaluationOrder]] 는 정수 또는 ~unset~.
                    1. _requiredModule_.[[AsyncEvaluationOrder]] 가 ~unset~ 이면 _requiredModule_.[[Status]] = ~evaluated~.
                    1. 아니면 _requiredModule_.[[Status]] = ~evaluating-async~.
                    1. _requiredModule_ 와 _module_ 이 같으면 _done_ = *true*.
                    1. _requiredModule_.[[CycleRoot]] = _module_.
                1. _index_ 반환.
              </emu-alg>
              <emu-note>
                <p>모듈은 InnerModuleEvaluation 이 순회 중이면 ~evaluating~ 상태. [[HasTLA]] 가 *true* 이거나 비동기 의존성이 있으면 실행 중 ~evaluating-async~, 완료 시 ~evaluated~.</p>
              </emu-note>
              <emu-note>
                <p>비동기 순환의 모듈에 의존하는 모듈은 순환이 ~evaluating~ 이 아닐 때 [[CycleRoot]] 를 통해 루트 실행에 의존하도록 하여 순환 상태를 단일 SCC 로 취급 가능하게 한다.</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-execute-async-module" type="abstract operation">
              <h1>
                ExecuteAsyncModule (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>

              <emu-alg>
                1. 단언: _module_.[[Status]] 는 ~evaluating~ 또는 ~evaluating-async~.
                1. 단언: _module_.[[HasTLA]] 는 *true*.
                1. _capability_ = ! NewPromiseCapability(%Promise%).
                1. _fulfilledClosure_ 를 _module_ 을 캡처하고 호출 시:
                  1. AsyncModuleExecutionFulfilled(_module_) 수행.
                  1. NormalCompletion(*undefined*) 반환.
                1. _onFulfilled_ = CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »).
                1. _rejectedClosure_ 를 (_error_) 매개변수, _module_ 캡처하고 호출 시:
                  1. AsyncModuleExecutionRejected(_module_, _error_) 수행.
                  1. NormalCompletion(*undefined*) 반환.
                1. _onRejected_ = CreateBuiltinFunction(_rejectedClosure_, 0, *""*, « »).
                1. PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_) 수행.
                1. ! <emu-meta effects="user-code">_module_.ExecuteModule</emu-meta>(_capability_) 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-gather-available-ancestors" type="abstract operation">
              <h1>
                GatherAvailableAncestors (
                  _module_: Cyclic Module Record,
                  _execList_: Cyclic Module Record 리스트,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[AsyncParentModules]] 의 각 Cyclic Module Record _m_ 에 대해
                  1. _execList_ 가 _m_ 을 포함하지 않고 _m_.[[CycleRoot]].[[EvaluationError]] 가 ~empty~ 이면
                    1. 단언: _m_.[[Status]] 는 ~evaluating-async~.
                    1. 단언: _m_.[[EvaluationError]] 는 ~empty~.
                    1. 단언: _m_.[[AsyncEvaluationOrder]] 는 정수.
                    1. 단언: _m_.[[PendingAsyncDependencies]] > 0.
                    1. _m_.[[PendingAsyncDependencies]] -= 1.
                    1. _m_.[[PendingAsyncDependencies]] = 0 이면
                      1. _m_ 을 _execList_ 에 추가.
                      1. _m_.[[HasTLA]] 가 *false* 이면 GatherAvailableAncestors(_m_, _execList_) 수행.
                1. ~unused~ 반환.
              </emu-alg>
              <emu-note>
                <p>루트 _module_ 의 비동기 실행이 fulfill 될 때, 이 함수는 동시에 동기 실행 가능한 모듈 목록을 결정하여 _execList_ 에 채운다.</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-fulfilled" type="abstract operation">
              <h1>
                AsyncModuleExecutionFulfilled (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[Status]] 가 ~evaluated~ 이면
                  1. 단언: _module_.[[EvaluationError]] 는 ~empty~ 가 아님.
                  1. ~unused~ 반환.
                1. 단언: _module_.[[Status]] 는 ~evaluating-async~.
                1. 단언: _module_.[[AsyncEvaluationOrder]] 는 정수.
                1. 단언: _module_.[[EvaluationError]] 는 ~empty~.
                1. _module_.[[AsyncEvaluationOrder]] 를 ~done~ 으로.
                1. _module_.[[Status]] 를 ~evaluated~ 로.
                1. _module_.[[TopLevelCapability]] 가 ~empty~ 가 아니면
                  1. 단언: _module_.[[CycleRoot]] 와 _module_ 은 동일.
                  1. ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. _execList_ 를 새 빈 리스트로 둔다.
                1. GatherAvailableAncestors(_module_, _execList_) 수행.
                1. 단언: _execList_ 모든 요소는 [[AsyncEvaluationOrder]] 가 정수, [[PendingAsyncDependencies]] = 0, [[EvaluationError]] = ~empty~.
                1. _sortedExecList_ 를 [[AsyncEvaluationOrder]] 오름차순으로 정렬한 리스트로 둔다.
                1. _sortedExecList_ 의 각 Cyclic Module Record _m_ 에 대해
                  1. _m_.[[Status]] 가 ~evaluated~ 이면
                    1. 단언: _m_.[[EvaluationError]] 는 ~empty~ 아님.
                  1. Else if _m_.[[HasTLA]] 가 *true* 이면
                    1. ExecuteAsyncModule(_m_) 수행.
                  1. Else
                    1. _result_ = <emu-meta effects="user-code">_m_.ExecuteModule()</emu-meta>.
                    1. _result_ 가 abrupt completion 이면
                      1. AsyncModuleExecutionRejected(_m_, _result_.[[Value]]) 수행.
                    1. Else
                      1. _m_.[[AsyncEvaluationOrder]] = ~done~.
                      1. _m_.[[Status]] = ~evaluated~.
                      1. _m_.[[TopLevelCapability]] 가 ~empty~ 아니면
                        1. 단언: _m_.[[CycleRoot]] 와 _m_ 동일.
                        1. ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-rejected" type="abstract operation">
              <h1>
                AsyncModuleExecutionRejected (
                  _module_: Cyclic Module Record,
                  _error_: ECMAScript 언어 값,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[Status]] 가 ~evaluated~ 이면
                  1. 단언: _module_.[[EvaluationError]] 는 ~empty~ 가 아님.
                  1. ~unused~ 반환.
                1. 단언: _module_.[[Status]] 는 ~evaluating-async~.
                1. 단언: _module_.[[AsyncEvaluationOrder]] 는 정수.
                1. 단언: _module_.[[EvaluationError]] 는 ~empty~.
                1. _module_.[[EvaluationError]] = ThrowCompletion(_error_).
                1. _module_.[[Status]] = ~evaluated~.
                1. _module_.[[AsyncEvaluationOrder]] = ~done~.
                1. 참고: _module_.[[EvaluationError]] 가 ~empty~ 가 아닐 때 InnerModuleEvaluation 에서 [[AsyncEvaluationOrder]] 값은 사용되지 않는다.
                1. _module_.[[AsyncParentModules]] 의 각 Cyclic Module Record _m_ 에 대해
                  1. AsyncModuleExecutionRejected(_m_, _error_) 수행.
                1. _module_.[[TopLevelCapability]] 가 ~empty~ 아니면
                  1. 단언: _module_.[[CycleRoot]] 와 _module_ 동일.
                  1. ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-example-cyclic-module-record-graphs">
          <h1>순환 모듈 레코드 그래프 예시</h1>

          <p>비규범 섹션: 몇 가지 공통 모듈 그래프의 링크 및 평가 예시와 오류 발생 양상에 초점을 둔다.</p>

          <p>먼저 다음 단순 모듈 그래프를 보자:</p>

          <emu-figure id="figure-module-graph-simple" caption="단순 모듈 그래프">
            <img alt="모듈 A 가 모듈 B 에 의존하고, 모듈 B 가 모듈 C 에 의존하는 그래프" width="60" height="198" src="https://tc39.es/ecma262/img/module-graph-simple.svg">
          </emu-figure>

          <p>우선 오류 조건이 없다고 가정. 호스트가 처음 _A_.LoadRequestedModules() 를 호출하면 (가정에 따라) 성공적으로 완료하면서 _B_, _C_ 의 의존성도 재귀적으로 로드(각각 _C_ 와 없음)하고 _A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = ~unlinked~ 로 설정. 이후 _A_.Link() 호출도 성공(가정)하여 세 모듈 모두 ~linked~. 이러한 준비 단계는 언제든 수행 가능. 나중에 호스트가 모듈의 부작용 실행 시점이 되면 _A_.Evaluate() 호출 → 성공적으로 완료, *undefined* 로 resolve 되는 Promise 반환(가정), 먼저 _C_ 그다음 _B_ 를 평가. 이 시점에 각 모듈 [[Status]] 는 ~evaluated~.</p>

          <p>다음으로 링크 오류 사례: _A_.LoadRequestedModules() 성공 후 InnerModuleLinking(_C_) 는 성공하지만 그 뒤 _B_ 에서 실패(예: _C_ 가 제공하지 않는 것을 import). 그러면 원래 _A_.Link() 가 실패하고 _A_ 와 _B_ 의 [[Status]] 는 ~unlinked~ 유지. _C_ 는 ~linked~ 로 전이되어 있음.</p>

          <p>마지막으로 링크 성공 후 평가 오류: InnerModuleEvaluation(_C_) 는 성공하지만 그 뒤 _B_ 가 실패(예: _B_ 코드에서 예외). 원래 _A_.Evaluate() 는 reject 된 Promise 반환으로 실패. 예외는 _A_, _B_ 의 [[EvaluationError]] 에 기록되고 두 모듈 [[Status]] 는 ~evaluated~. _C_ 도 ~evaluated~ 되지만 예외 없이 성공 평가. 예외 저장을 통해 이후 Evaluate() 재호출 시 동일 예외 일관 제공. (호스트는 Cyclic Module Record 재사용 의무 없음; 예외 객체 노출 의무도 없음. 명세는 가능성만 제공.)</p>

          <p>이제 다른 오류 조건 유형:</p>

          <emu-figure id="figure-module-graph-missing" caption="해결 불가 모듈을 가진 그래프">
            <img alt="모듈 A 가 ??? 로 표시된 존재하지 않는 모듈에 의존" width="60" height="121" src="https://tc39.es/ecma262/img/module-graph-missing.svg">
          </emu-figure>

          <p>이 시나리오에서 _A_ 는 다른 모듈을 선언적 의존하지만 해당 Module Record 가 없음 (HostLoadImportedModule 가 FinishLoadingImportedModule 호출 시 예외 전달). 리소스 부재, 혹은 존재하지만 ParseModule 이 오류 반환 등 다양한 이유. 호스트는 실패 원인을 FinishLoadingImportedModule 에 전달하는 completion 을 통해 노출 선택 가능. 이 예외로 로딩 실패 → _A_.[[Status]] 는 ~new~ 유지.</p>

          <p>로딩 / 링크 / 평가 오류 차이는 다음 특징 때문:</p>
          <ul>
            <li>평가는 부작용이 있을 수 있어 한 번만 수행해야 하므로(비성공 포함) 이미 수행 여부 기억 필요. (오류 시에도 이후 Evaluate() 마다 새로운 예외 합성 대신 기존 예외 기억이 합리적)</li>
            <li>링크는 부작용이 없으므로 실패해도 나중에 재시도 가능</li>
            <li>로딩은 호스트와 긴밀히 상호작용하므로 일부 호스트는 실패한 로드 재시도 허용이 바람직(예: 일시적 네트워크 문제)</li>
          </ul>

          <p>이제 순환이 있는 그래프:</p>

          <emu-figure id="figure-module-graph-cycle" caption="순환 모듈 그래프">
            <img alt="모듈 A 가 B, C 에 의존하고 B 가 A 에도 의존" width="181" height="121" src="https://tc39.es/ecma262/img/module-graph-cycle.svg">
          </emu-figure>

          <p>엔트리 포인트가 _A_ 라 가정하고 호스트가 _A_.LoadRequestedModules() 호출 → _A_ 에 대해 InnerModuleLoading 수행. 이는 _B_, _C_ 에 대해 InnerModuleLoading 호출. 순환 때문에 다시 _A_ 에 대해 InnerModuleLoading 트리거되지만 이미 로딩 트리거 되었으므로 no-op. 그래프 모든 모듈 로딩 성공 시 [[Status]] 는 동시에 ~new~ → ~unlinked~.</p>

          <p>그 후 _A_.Link() → _A_ 에 대해 InnerModuleLinking → _B_ → 순환으로 다시 _A_ (이미 ~linking~ 이므로 no-op). _B_ 는 여전히 ~linking~ 상태에서 제어가 _A_ 로 돌아와 _C_ 에 대해 InnerModuleLinking. _C_ 가 ~linked~ 후 _A_, _B_ 가 함께 ~linking~ → ~linked~ 전이; 이는 SCC 단위 동시 전이를 설계한 것. DFS 로 그래프 순회하므로 가능.</p>

          <p>성공 사례에서 평가 단계도 유사.</p>

          <p>_A_ 에 링크 오류(예: _C_ 에 존재하지 않는 바인딩 import) 인 경우 위 단계 진행 중 두 번째 InnerModuleLinking(_A_) 조기 반환 포함. 하지만 원래 InnerModuleLinking(_A_) 로 되돌아왔을 때 InitializeEnvironment 중 (_C_.ResolveExport() 직후) 실패, *SyntaxError* 전파 → _A_.Link 에서 현재 _stack_ 에 있는(~linking~) 모듈 상태를 재설정. 따라서 _A_, _B_ 는 ~unlinked~, _C_ 는 ~linked~ 유지.</p>

          <p>유사하게 _A_ 평가 오류(예: 코드 예외) 인 경우에도 평가 시퀀스는 비슷. 두 번째 InnerModuleEvaluation(_A_) 조기 반환 후 원래 InnerModuleEvaluation(_A_) 로 돌아와 실패. 예외가 _A_.Evaluate() 로 전파되어 현재 _stack_ (여전히 ~evaluating~) 및 [[AsyncParentModules]] 체인을 따라(상위 top-level `await` 를 가진 모듈 경유) AsyncModuleExecutionRejected 알고리즘으로 전파. 결과로 _A_, _B_ 는 ~evaluated~ & 예외 기록, _C_ 는 예외 없이 ~evaluated~.</p>

          <p>마지막으로 모든 모듈이 비동기 완료하는 순환 그래프:</p>
          <emu-figure id="figure-module-graph-cycle-async" caption="비동기 순환 모듈 그래프">
            <img alt="모듈 A 가 B, C 에 의존, B 는 D, C 는 D, E 에 의존, D 는 A 에 의존" width="241" height="211" src="https://tc39.es/ecma262/img/module-graph-cycle-async.svg">
          </emu-figure>
          <p>로딩과 링크는 이전과 같고 모두 [[Status]] = ~linked~.</p>

          <p>_A_.Evaluate() 는 _A_, _B_, _D_ 에 대해 InnerModuleEvaluation 수행 → 모두 ~evaluating~. 다시 _A_ 호출은 no-op. 이때 _D_.[[PendingAsyncDependencies]] = 0 → ExecuteAsyncModule(_D_) 호출 → _D_.ExecuteModule 새 PromiseCapability. _B_ 로 unwind: _B_.[[PendingAsyncDependencies]] = 1, [[AsyncEvaluationOrder]] = 1. 다시 _A_ 로: _A_.[[PendingAsyncDependencies]] = 1. 다음 _A_ 의 의존 반복에서 _C_ 평가 → _D_(no-op), _E_. _E_ 는 의존 없고 순환 아님 → ExecuteAsyncModule(_E_) 즉시 호출 & stack 에서 제거. 다시 _C_ 로 unwind: _C_.[[AsyncEvaluationOrder]] = 3. _A_ 의 의존 루프 종료 후 _A_.[[AsyncEvaluationOrder]] = 4, SCC 전체 stack 제거하며 모두 ~evaluating-async~. 이 시점 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-1"></emu-xref> 참조.</p>

          <emu-table id="table-module-graph-cycle-async-fields-1" caption="초기 Evaluate() 후 모듈 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
                <td>3</td>
                <td>0</td>
                <td>2</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>2 (_B_, _C_)</td>
                <td>1 (_D_)</td>
                <td>2 (_D_, _E_)</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>_E_ 가 먼저 실행 완료한다고 가정. AsyncModuleExecutionFulfilled 호출 → _E_.[[Status]] = ~evaluated~, _C_.[[PendingAsyncDependencies]] = 1. 업데이트 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-2"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-2" caption="_E_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_C_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_D_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>다음으로 _D_ 완료. AsyncModuleExecutionFulfilled 호출 → _D_.[[Status]] = ~evaluated~. 실행 가능한 조상은 [[AsyncEvaluationOrder]] 1 의 _B_, 3 의 _C_ → 순서상 _B_ 먼저 처리: _B_.[[PendingAsyncDependencies]] = 0 → ExecuteAsyncModule(_B_) → 실행 시작. _C_.[[PendingAsyncDependencies]] 도 0 → _C_ 실행 시작( _B_ 에 await 있다면 병렬 가능). 업데이트 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-3"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-3" caption="_D_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>1</td>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>_C_ 가 다음으로 완료. AsyncModuleExecutionFulfilled → _C_.[[Status]] = ~evaluated~, _A_.[[PendingAsyncDependencies]] = 1. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-4"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-4" caption="_C_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>그 후 _B_ 완료. AsyncModuleExecutionFulfilled → _B_.[[Status]] = ~evaluated~, _A_.[[PendingAsyncDependencies]] = 0 → ExecuteAsyncModule 호출 → 실행 시작. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-5"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-5" caption="_B_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>마지막으로 _A_ 완료. AsyncModuleExecutionFulfilled → _A_.[[Status]] = ~evaluated~, _A_.[[TopLevelCapability]] 의 Promise(resolve) → 그래프 처리 종료. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-6"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-6" caption="_A_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>대안: _C_ 가 _B_ 완료 전 오류로 실패. AsyncModuleExecutionRejected 호출 → _C_.[[Status]] = ~evaluated~, _C_.[[EvaluationError]] = 오류. 그런 다음 AsyncParentModules 전파. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-7"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-7" caption="_C_ 오류 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>~empty~</td>
                <td>_C_ 의 평가 오류</td>
              </tr>
            </table>
          </emu-table>

          <p>_C_ 가 _A_ 에 대해 AsyncModuleExecutionRejected 호출하므로 _A_ 는 동일 오류로 reject. _A_.[[Status]] = ~evaluated~. _A_.[[TopLevelCapability]] Promise 는 reject. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-8"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-8" caption="_A_ 가 reject 된 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>

                <td>_C_ 의 Evaluation Error</td>
              </tr>
            </table>
          </emu-table>

          <p>이후 _B_ 가 오류 없이 완료. AsyncModuleExecutionFulfilled → _B_.[[Status]] = ~evaluated~. GatherAvailableAncestors(_B_) 호출. 그러나 _A_.[[CycleRoot]] = _A_, 그리고 평가 오류 존재 → _sortedExecList_ 에 추가되지 않고 추가 처리 없이 반환. 이후 _B_ 의 importer 는 cycle root _A_ 의 [[EvaluationError]] 를 통해 reject 를 해석. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-9"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-9" caption="오류 그래프에서 _B_ 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>_C_ 의 Evaluation Error</td>
                <td>~empty~</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>소스 텍스트 모듈 레코드</h1>

        <p><dfn id="sourctextmodule-record" variants="Source Text Module Records">Source Text Module Record</dfn> 는 |Module| 목표 기호로 파싱된 ECMAScript 소스 텍스트 (<emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) 로 정의된 모듈 정보를 나타내는 데 사용된다. 필드는 모듈이 import/export 하는 이름에 대한 요약 정보를 포함하고, 구체 메서드는 이 요약을 사용해 링크 및 평가를 수행한다.</p>

        <p>Source Text Module Record 는 추상 Module Record 타입의 다른 하위 클래스들과 같은 그래프에 존재할 수 있으며 Cyclic Module Record 타입의 다른 하위 클래스들과 순환에 참여할 수 있다.</p>

        <p><emu-xref href="#table-cyclic-module-fields"></emu-xref> 에 정의된 필드들 외에, Source Text Module Record 는 <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref> 에 있는 추가 필드를 가진다. 각 필드는 ParseModule 에서 초기화된다.</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="Source Text Module Record 의 추가 필드" oldids="table-38">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                Parse Node
              </td>
              <td>
                |Module| 을 목표 기호로 사용해 이 모듈 소스 텍스트를 파싱한 결과.
              </td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                ECMAScript 코드 실행 컨텍스트 또는 ~empty~
              </td>
              <td>
                이 모듈에 연결된 실행 컨텍스트. 환경 초기화 전까지 ~empty~.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                Object 또는 ~empty~
              </td>
              <td>
                `import.meta` 메타 프로퍼티로 노출되는 객체. ECMAScript 코드에서 접근 전까지 ~empty~.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                ImportEntry Record 리스트
              </td>
              <td>
                이 모듈 코드에서 도출된 ImportEntry 리스트.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                ExportEntry Record 리스트
              </td>
              <td>
                모듈 내 선언에 해당하는 export 에 대한 ExportEntry 리스트.
              </td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                ExportEntry Record 리스트
              </td>
              <td>
                모듈 내 재export(import 재export 또는 `export * as namespace`) 에 해당하는 ExportEntry 리스트.
              </td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                ExportEntry Record 리스트
              </td>
              <td>
                모듈 내 `export *` 선언(단, `export * as namespace` 제외)에 해당하는 ExportEntry 리스트.
              </td>
            </tr>
          </table>
        </emu-table>
        <p><dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> 는 단일 선언적 import 에 대한 정보를 요약한 Record. 각 ImportEntry Record 는 <emu-xref href="#table-importentry-record-fields"></emu-xref> 필드를 가진다:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record 필드" oldids="table-39">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record
              </td>
              <td>
                |ImportDeclaration| 의 |ModuleSpecifier| 및 import 속성.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String 또는 ~namespace-object~
              </td>
              <td>
                [[ModuleRequest]] 로 식별된 모듈이 해당 바인딩을 export 하는 이름. ~namespace-object~ 는 대상 모듈 네임스페이스 객체 import 요청을 의미.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String
              </td>
              <td>
                import 하는 모듈 내부에서 값에 접근할 때 사용하는 로컬 이름.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> 는 구문 import 형태를 표현하는 ImportEntry 필드 예시:</p>
          <emu-table id="table-import-forms-mapping-to-importentry-records" caption="Import 문 형태와 ImportEntry 매핑" informative oldids="table-40">
            <table>
              <thead>
                <tr>
                  <th>
                    Import 문 형태
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~namespace-object~
                </td>
                <td>
                  *"ns"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  ImportEntry Record 생성 안 됨.
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p><dfn id="exportentry-record" variants="ExportEntry Records">ExportEntry Record</dfn> 는 단일 선언적 export 정보를 요약한 Record. 각 ExportEntry Record 는 <emu-xref href="#table-exportentry-records"></emu-xref> 필드 보유:</p>
        <emu-table id="table-exportentry-records" caption="ExportEntry Record 필드" oldids="table-41">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                String 또는 *null*
              </td>
              <td>
                모듈이 이 바인딩을 export 하는 이름.
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record 또는 *null*
              </td>
              <td>
                |ExportDeclaration| 의 |ModuleSpecifier| 및 import 속성을 나타내는 ModuleRequest Record. |ModuleSpecifier| 없으면 *null*.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String, *null*, ~all~, 또는 ~all-but-default~
              </td>
              <td>
                [[ModuleRequest]] 로 식별된 모듈이 해당 바인딩을 export 하는 이름. |ModuleSpecifier| 없으면 *null*. `export * as ns from "mod"` 는 ~all~, `export * from "mod"` 는 ~all-but-default~ 사용.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String 또는 *null*
              </td>
              <td>
                importer 모듈 내부에서 export 값 접근 시 사용 로컬 이름. 로컬 접근 불가면 *null*.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-export-forms-mapping-to-exportentry-records"></emu-xref> 는 구문 export 형태를 표현하는 ExportEntry 필드 예시:</p>
          <emu-table id="table-export-forms-mapping-to-exportentry-records" caption="Export 문 형태와 ExportEntry 매핑" informative oldids="table-42">
            <table>
              <thead>
                <tr>
                  <th>
                    Export 문 형태
                  </th>
                  <th>
                    [[ExportName]]
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f() {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"f"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function () {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all-but-default~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * as ns from "mod";`
                </td>
                <td>
                  *"ns"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all~
                </td>
                <td>
                  *null*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>다음 정의는 Source Text Module Record 에 필요한 구체 메서드와 기타 추상 연산을 명세한다.</p>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript 소스 텍스트,
              _realm_: Realm Record,
              _hostDefined_: anything,
            ): Source Text Module Record 또는 *SyntaxError* 객체 비어있지 않은 리스트
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_sourceText_ 를 |Module| 로 파싱한 결과에 기반하여 Source Text Module Record 생성.</dd>
          </dl>
          <emu-alg>
            1. _body_ = ParseText(_sourceText_, |Module|).
            1. _body_ 가 오류 리스트이면 _body_ 반환.
            1. _requestedModules_ = ModuleRequests(_body_).
            1. _importEntries_ = ImportEntries(_body_).
            1. _importedBoundNames_ = ImportedLocalNames(_importEntries_).
            1. _indirectExportEntries_ = 새 빈 리스트.
            1. _localExportEntries_ = 새 빈 리스트.
            1. _starExportEntries_ = 새 빈 리스트.
            1. _exportEntries_ = ExportEntries(_body_).
            1. 각 ExportEntry Record _ee_ ∈ _exportEntries_ 에 대해
              1. _ee_.[[ModuleRequest]] 가 *null* 이면
                1. _importedBoundNames_ 가 _ee_.[[LocalName]] 포함하지 않으면
                  1. _ee_ 를 _localExportEntries_ 에 추가.
                1. Else
                  1. _ie_ = [[LocalName]] 가 _ee_.[[LocalName]] 인 _importEntries_ 요소.
                  1. _ie_.[[ImportName]] 가 ~namespace-object~ 이면
                    1. 참고: import 된 모듈 네임스페이스 객체 재export.
                    1. _ee_ 를 _localExportEntries_ 에 추가.
                  1. Else
                    1. 참고: 단일 이름 재export.
                    1. ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } 를 _indirectExportEntries_ 에 추가.
              1. Else if _ee_.[[ImportName]] 가 ~all-but-default~ 이면
                1. 단언: _ee_.[[ExportName]] 는 *null*.
                1. _ee_ 를 _starExportEntries_ 에 추가.
              1. Else
                1. _ee_ 를 _indirectExportEntries_ 에 추가.
            1. _async_ = _body_ Contains `await`.
            1. Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSAncestorIndex]]: ~empty~ } 반환.
          </emu-alg>
          <emu-note>
            <p>구현은 ParseModule 평가 이전에 소스 텍스트를 파싱하고 Early Error 분석을 수행할 수 있으나 오류 보고는 실제 ParseModule 수행 시점까지 지연해야 한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-module-record-methods">
          <h1>Module Record 추상 메서드 구현</h1>

          <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 Module Record 추상 메서드 구현을 위한 Source Text Module Record 의 구체 메서드.</p>

          <emu-clause id="sec-getexportednames" type="concrete method">
            <h1>
              GetExportedNames (
                optional _exportStarSet_: Source Text Module Record 리스트,
              ): 문자열 리스트
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>
            <emu-alg>
              1. 단언: _module_.[[Status]] 는 ~new~ 아님.
              1. _exportStarSet_ 없으면 새 빈 리스트로 설정.
              1. _exportStarSet_ 이 _module_ 포함하면
                1. 단언: `export *` 순환의 시작점 도달.
                1. 새 빈 리스트 반환.
              1. _module_ 을 _exportStarSet_ 에 추가.
              1. _exportedNames_ = 새 빈 리스트.
              1. _module_.[[LocalExportEntries]] 각 ExportEntry Record _e_ 에 대해
                1. 단언: _module_ 이 직접 바인딩 제공.
                1. 단언: _e_.[[ExportName]] 는 *null* 아님.
                1. _e_.[[ExportName]] 를 _exportedNames_ 에 추가.
              1. _module_.[[IndirectExportEntries]] 각 _e_ 에 대해
                1. 단언: _module_ 이 특정 바인딩 import 후 재export.
                1. 단언: _e_.[[ExportName]] 는 *null* 아님.
                1. _e_.[[ExportName]] 을 _exportedNames_ 에 추가.
              1. _module_.[[StarExportEntries]] 각 _e_ 에 대해
                1. 단언: _e_.[[ModuleRequest]] 는 *null* 아님.
                1. _requestedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. _starNames_ = _requestedModule_.GetExportedNames(_exportStarSet_).
                1. 각 _n_ ∈ _starNames_ 에 대해
                  1. _n_ ≠ *"default"* 이면
                    1. _exportedNames_ 가 _n_ 포함하지 않으면 추가.
              1. _exportedNames_ 반환.
            </emu-alg>
            <emu-note>
              <p>GetExportedNames 는 모호한 star export 바인딩 이름을 필터링하거나 예외를 던지지 않는다.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: String,
                optional _resolveSet_: Record 리스트 (필드 [[Module]]: Module Record, [[ExportName]]: String),
              ): ResolvedBinding Record, *null*, 또는 ~ambiguous~
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>

              <dt>description</dt>
              <dd>
                <p>ResolveExport 는 import 된 바인딩을 실제 정의 모듈과 로컬 바인딩 이름으로 해석. 정의 모듈은 자신 또는 import 된 다른 모듈일 수 있음. _resolveSet_ 은 순환 import/export 경로 탐지를 위해 사용. 동일 Module Record 와 _exportName_ 쌍이 이미 _resolveSet_ 에 있으면 순환. 재귀 호출 전 { _module_, _exportName_ } 쌍을 추가.</p>
                <p>정의 모듈 발견 시 ResolvedBinding Record { [[Module]], [[BindingName]] } 반환(네임스페이스 export 만 있는 경우 [[BindingName]] = ~namespace~). 정의 없거나 순환이면 *null*, 모호하면 ~ambiguous~.</p>
              </dd>
            </dl>

            <emu-alg>
              1. 단언: _module_.[[Status]] 는 ~new~ 아님.
              1. _resolveSet_ 없으면 새 빈 리스트.
              1. _resolveSet_ 의 각 Record { [[Module]], [[ExportName]] } _r_ 에 대해
                1. _module_ 과 _r_.[[Module]] 동일이고 _exportName_ = _r_.[[ExportName]] 이면
                  1. 단언: 순환 import 요청.
                  1. *null* 반환.
              1. Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } 를 _resolveSet_ 에 추가.
              1. _module_.[[LocalExportEntries]] 각 ExportEntry Record _e_ 에 대해
                1. _e_.[[ExportName]] = _exportName_ 이면
                  1. 단언: 직접 바인딩 제공.
                  1. ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] } 반환.
              1. _module_.[[IndirectExportEntries]] 각 _e_ 에 대해
                1. _e_.[[ExportName]] = _exportName_ 이면
                  1. 단언: _e_.[[ModuleRequest]] ≠ *null*.
                  1. _importedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                  1. _e_.[[ImportName]] 가 ~all~ 이면
                    1. 단언: 직접 바인딩 제공 안 함.
                    1. ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ } 반환.
                  1. Else
                    1. 단언: 특정 바인딩 import 후 재export.
                    1. 단언: _e_.[[ImportName]] 는 String.
                    1. _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_) 반환.
              1. _exportName_ = *"default"* 이면
                1. 단언: 명시적 `default` export 없음.
                1. *null* 반환.
                1. NOTE: `export * from "mod"` 는 `default` export 제공 불가.
              1. _starResolution_ = *null*.
              1. _module_.[[StarExportEntries]] 각 _e_ 에 대해
                1. 단언: _e_.[[ModuleRequest]] ≠ *null*.
                1. _importedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. _resolution_ = _importedModule_.ResolveExport(_exportName_, _resolveSet_).
                1. _resolution_ = ~ambiguous~ 이면 ~ambiguous~ 반환.
                1. _resolution_ ≠ *null* 이면
                  1. 단언: _resolution_ 은 ResolvedBinding Record.
                  1. _starResolution_ 이 *null* 이면
                    1. _starResolution_ = _resolution_.
                  1. Else
                    1. 단언: 요청 이름을 포함하는 `*` import 가 하나 이상.
                    1. _resolution_.[[Module]] ≠ _starResolution_.[[Module]] 이면 ~ambiguous~ 반환.
                    1. _resolution_.[[BindingName]] ≠ _starResolution_.[[BindingName]] 이고 둘 중 하나가 ~namespace~ 이면 ~ambiguous~.
                    1. 두 [[BindingName]] 이 모두 String 이고 다르면 ~ambiguous~.
              1. _starResolution_ 반환.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-cyclic-module-record-methods">
          <h1>Cyclic Module Record 추상 메서드 구현</h1>

          <p><emu-xref href="#table-cyclic-module-methods"></emu-xref> 에 정의된 Cyclic Module Record 추상 메서드를 구현하는 Source Text Module Record 의 구체 메서드.</p>

          <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
            <h1>InitializeEnvironment ( ): ~unused~ 를 담은 정상 completion 또는 throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[IndirectExportEntries]] 의 각 ExportEntry Record _e_ 에 대해
                1. 단언: _e_.[[ExportName]] ≠ *null*.
                1. _resolution_ = _module_.ResolveExport(_e_.[[ExportName]]).
                1. _resolution_ 이 *null* 또는 ~ambiguous~ 이면 *SyntaxError* throw.
                1. 단언: _resolution_ 은 ResolvedBinding Record.
              1. 단언: _module_ 의 모든 named export 는 해석 가능.
              1. _realm_ = _module_.[[Realm]].
              1. 단언: _realm_ ≠ *undefined*.
              1. _env_ = NewModuleEnvironment(_realm_.[[GlobalEnv]]).
              1. _module_.[[Environment]] = _env_.
              1. _module_.[[ImportEntries]] 각 ImportEntry Record _in_ 에 대해
                1. _importedModule_ = GetImportedModule(_module_, _in_.[[ModuleRequest]]).
                1. _in_.[[ImportName]] 가 ~namespace-object~ 이면
                  1. _namespace_ = GetModuleNamespace(_importedModule_).
                  1. ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*) 수행.
                  1. ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_) 수행.
                1. Else
                  1. _resolution_ = _importedModule_.ResolveExport(_in_.[[ImportName]]).
                  1. _resolution_ 이 *null* 또는 ~ambiguous~ 이면 *SyntaxError* throw.
                  1. _resolution_.[[BindingName]] = ~namespace~ 이면
                    1. _namespace_ = GetModuleNamespace(_resolution_.[[Module]]).
                    1. ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                    1. ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                  1. Else
                    1. CreateImportBinding(_env_, _in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]) 수행.
              1. _moduleContext_ = 새 ECMAScript 코드 실행 컨텍스트.
              1. _moduleContext_.Function = *null*.
              1. 단언: _module_.[[Realm]] ≠ *undefined*.
              1. _moduleContext_.Realm = _module_.[[Realm]].
              1. _moduleContext_.ScriptOrModule = _module_.
              1. _moduleContext_.VariableEnvironment = _module_.[[Environment]].
              1. _moduleContext_.LexicalEnvironment = _module_.[[Environment]].
              1. _moduleContext_.PrivateEnvironment = *null*.
              1. _module_.[[Context]] = _moduleContext_.
              1. _moduleContext_ 를 실행 컨텍스트 스택에 push; 실행 중 컨텍스트.
              1. _code_ = _module_.[[ECMAScriptCode]].
              1. _varDeclarations_ = VarScopedDeclarations(_code_).
              1. _declaredVarNames_ = 새 빈 리스트.
              1. 각 _d_ ∈ _varDeclarations_ 에 대해
                1. BoundNames(_d_) 의 각 _dn_ 에 대해
                  1. _declaredVarNames_ 가 _dn_ 포함하지 않으면
                    1. ! _env_.CreateMutableBinding(_dn_, *false*).
                    1. ! _env_.InitializeBinding(_dn_, *undefined*).
                    1. _dn_ 을 _declaredVarNames_ 에 추가.
              1. _lexDeclarations_ = LexicallyScopedDeclarations(_code_).
              1. _privateEnv_ = *null*.
              1. 각 _d_ ∈ _lexDeclarations_ 에 대해
                1. BoundNames(_d_) 의 각 _dn_ 에 대해
                  1. IsConstantDeclaration(_d_) 가 *true* 이면
                    1. ! _env_.CreateImmutableBinding(_dn_, *true*).
                  1. Else
                    1. ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. _d_ 가 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| 중 하나이면
                    1. _fo_ = InstantiateFunctionObject(_d_, _env_, _privateEnv_).
                    1. ! _env_.InitializeBinding(_dn_, _fo_).
              1. _moduleContext_ 를 실행 컨텍스트 스택에서 제거.
              1. ~unused~ 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
            <h1>
              ExecuteModule (
                optional _capability_: PromiseCapability Record,
              ): ~unused~ 를 담은 정상 completion 또는 throw completion
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _moduleContext_ = 새 ECMAScript 코드 실행 컨텍스트.
              1. _moduleContext_.Function = *null*.
              1. _moduleContext_.Realm = _module_.[[Realm]].
              1. _moduleContext_.ScriptOrModule = _module_.
              1. 단언: 모듈이 링크되었고 환경 선언 인스턴스화 완료.
              1. _moduleContext_.VariableEnvironment = _module_.[[Environment]].
              1. _moduleContext_.LexicalEnvironment = _module_.[[Environment]].
              1. 실행 중 컨텍스트 suspend.
              1. _module_.[[HasTLA]] = *false* 이면
                1. 단언: _capability_ 없음.
                1. _moduleContext_ push → 실행 중 컨텍스트.
                1. _result_ = Completion(Evaluation(_module_.[[ECMAScriptCode]]) ).
                1. _moduleContext_ suspend 및 스택에서 제거.
                1. 최상위 컨텍스트 resume.
                1. _result_ 가 abrupt completion 이면
                  1. ? _result_ 반환.
              1. Else
                1. 단언: _capability_ 는 PromiseCapability Record.
                1. AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_) 수행.
              1. ~unused~ 반환.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-synthetic-module-records">
        <h1>합성(Synthetic) 모듈 레코드</h1>

        <p><dfn variants="Synthetic Module Records">Synthetic Module Record</dfn> 는 명세가 정의하는 모듈 정보를 나타내며 export 이름은 생성 시 정적으로 정의되고 값은 SetSyntheticModuleExport 로 시간에 따라 변경될 수 있다. import 또는 의존성이 없다.</p>

        <emu-note>Synthetic Module Record 는 JSON 모듈, CSS 모듈 등 다양한 모듈 타입 정의에 사용 가능.</emu-note>

        <p><emu-xref href="#table-module-record-fields"></emu-xref> 의 필드 외에 Synthetic Module Record 는 <emu-xref href="#table-synthetic-module-record-fields"></emu-xref> 의 추가 필드를 가진다.</p>

        <emu-table id="table-synthetic-module-record-fields" caption="Synthetic Module Record 의 추가 필드">
          <table>
            <thead>
              <tr>
                <th>필드 이름</th>
                <th>값 타입</th>
                <th>의미</th>
              </tr>
            </thead>
            <tr>
              <td>[[ExportNames]]</td>
              <td>문자열 리스트</td>
              <td>모듈의 export 이름. 중복 없음.</td>
            </tr>
            <tr>
              <td>[[EvaluationSteps]]</td>
              <td>Abstract Closure</td>
              <td>모듈 평가 시 수행할 초기화 로직 (Synthetic Module Record 를 단일 인수). [[ExportNames]] 수정 금지. abrupt completion 반환 가능.</td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-create-default-export-synthetic-module" type="abstract operation">
          <h1>
            CreateDefaultExportSyntheticModule (
              _defaultExport_: ECMAScript 언어 값,
            ): Synthetic Module Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_defaultExport_ 를 기본 export 로 하는 Synthetic Module Record 생성.</dd>
          </dl>
          <emu-alg>
            1. _realm_ = 현재 Realm Record.
            1. _setDefaultExport_ = (_module_) 매개변수, _defaultExport_ 캡처하는 Abstract Closure:
              1. SetSyntheticModuleExport(_module_, *"default"*, _defaultExport_) 수행.
              1. NormalCompletion(~unused~) 반환.
            1. Synthetic Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[HostDefined]]: *undefined*, [[ExportNames]]: « *"default"* », [[EvaluationSteps]]: _setDefaultExport_ } 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parse-json-module" type="abstract operation">
          <h1>
            ParseJSONModule (
              _source_: String,
            ): Synthetic Module Record 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. _json_ = ? ParseJSON(_source_).
            1. CreateDefaultExportSyntheticModule(_json_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-setsyntheticmoduleexport" type="abstract operation">
          <h1>
            SetSyntheticModuleExport (
              _module_: Synthetic Module Record,
              _exportName_: String,
              _exportValue_: ECMAScript 언어 값,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Synthetic Module Record 의 기존 export 값 설정/변경.</dd>
          </dl>

          <emu-alg>
            1. 단언: _module_.[[ExportNames]] 가 _exportName_ 포함.
            1. _envRec_ = _module_.[[Environment]].
            1. 단언: _envRec_ ≠ ~empty~.
            1. _envRec_.SetMutableBinding(_exportName_, _exportValue_, *true*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-smr-module-record-methods">
          <h1>Module Record 추상 메서드 구현</h1>

          <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 Module Record 추상 메서드를 구현하는 Synthetic Module Record 의 구체 메서드.</p>

          <emu-clause id="sec-smr-LoadRequestedModules" type="concrete method">
            <h1>LoadRequestedModules ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. ! PromiseResolve(%Promise%, *undefined*) 반환.
            </emu-alg>

            <emu-note>
              Synthetic Module Record 는 의존성이 없다.
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-smr-getexportednames" type="concrete method">
            <h1>GetExportedNames ( ): 문자열 리스트</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[ExportNames]] 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: String,
              ): ResolvedBinding Record 또는 *null*
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[ExportNames]] 가 _exportName_ 포함하지 않으면 *null* 반환.
              1. ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _exportName_ } 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Link" type="concrete method">
            <h1>Link ( ): ~unused~ 를 담은 정상 completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _realm_ = _module_.[[Realm]].
              1. _env_ = NewModuleEnvironment(_realm_.[[GlobalEnv]]).
              1. _module_.[[Environment]] = _env_.
              1. _module_.[[ExportNames]] 의 각 String _exportName_ 에 대해
                1. ! _env_.CreateMutableBinding(_exportName_, *false*).
                1. ! _env_.InitializeBinding(_exportName_, *undefined*).
              1. NormalCompletion(~unused~) 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Evaluate" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _moduleContext_ = 새 ECMAScript 코드 실행 컨텍스트.
              1. _moduleContext_.Function = *null*.
              1. _moduleContext_.Realm = _module_.[[Realm]].
              1. _moduleContext_.ScriptOrModule = _module_.
              1. _moduleContext_.VariableEnvironment = _module_.[[Environment]].
              1. _moduleContext_.LexicalEnvironment = _module_.[[Environment]].
              1. 실행 중 컨텍스트 suspend.
              1. _moduleContext_ push → 실행 중 컨텍스트.
              1. _steps_ = _module_.[[EvaluationSteps]].
              1. _result_ = Completion(_steps_(_module_)).
              1. _moduleContext_ suspend 및 스택에서 제거.
              1. 최상위 컨텍스트 resume.
              1. _pc_ = ! NewPromiseCapability(%Promise%).
              1. IfAbruptRejectPromise(_result_, _pc_).
              1. ! Call(_pc_.[[Resolve]], *undefined*, « *undefined* ») 수행.
              1. _pc_.[[Promise]] 반환.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetImportedModule" type="abstract operation">
        <h1>
          GetImportedModule (
            _referrer_: Cyclic Module Record,
            _request_: ModuleRequest Record,
          ): Module Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. [declared="r"] _records_ 를 _referrer_.[[LoadedModules]] 의 각 LoadedModuleRequest Record _r_ 중 ModuleRequestsEqual(_r_, _request_) 이 *true* 인 것들의 리스트로 둔다.
          1. 단언: LoadRequestedModules 가 사전에 성공했으므로 _records_ 는 정확히 한 요소.
          1. _record_ = _records_ 의 유일 요소.
          1. _record_.[[Module]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation" oldids="sec-hostresolveimportedmodule,sec-hostimportmoduledynamically">
        <h1>
          HostLoadImportedModule (
            _referrer_: Script Record, Cyclic Module Record, 또는 Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _hostDefined_: anything,
            _payload_: GraphLoadingState Record 또는 PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>웹 브라우저 호스트 예: 사용자가 아래 컨트롤을 클릭할 때</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>`import()` 표현식 실행 시 활성 스크립트나 모듈이 없을 수 있다. 더 일반적으로 호스트가 ScriptOrModule 이 *null* 인 실행 컨텍스트를 스택에 푸시하는 상황이면 Realm Record 가 _referrer_ 가 될 수 있다.</p>
        </emu-note>

        <p>HostLoadImportedModule 구현은 다음 요구사항을 따른다:</p>
        <ul>
          <li>
            호스트는 FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_) 수행해야 하며 _result_ 는 로드된 Module Record 를 담은 정상 completion 또는 throw completion (동기 또는 비동기).
          </li>
          <li>
            <p>이 연산이 동일 _referrer_ 와 ModuleRequestsEqual 가 *true* 인 두 (_referrer_, _moduleRequest_) 쌍에 대해 여러 번 호출되고, _result_ 가 정상 completion 인 FinishLoadingImportedModule 을 수행한다면, 매번 동일 _result_ 로 FinishLoadingImportedModule 을 수행해야 한다.</p>
          </li>
          <li>
            <p>_moduleRequest_.[[Attributes]] 에 _entry_.[[Key]] = *"type"*, _entry_.[[Value]] = *"json"* 인 항목이 있으면 FinishLoadingImportedModule 호출 시 _result_ 는 ParseJSONModule 호출이 반환한 Completion Record 또는 throw completion 이어야 한다.</p>
          </li>
          <li>
            연산은 _payload_ 를 FinishLoadingImportedModule 로 전달할 불투명 값으로 취급해야 한다.
          </li>
        </ul>

        <p>실제 과정은 호스트 정의이며 보통 적절한 Module Record 로드에 필요한 I/O 수행. 서로 다른 여러 (_referrer_, _moduleRequest_.[[Specifier]], _moduleRequest_.[[Attributes]]) 삼중 조합이 동일 Module Record 인스턴스에 매핑될 수 있음. 매핑 의미론은 호스트 정의이나 일반적으로 _specifier_ 정규화 포함 (상대/축약 경로 확장 등).</p>

        <emu-note>
          <p>위 텍스트는 `type: "json"` 으로 import 하면 (그리고 HostLoadImportedModule 이 정상 완료) 호스트가 JSON 모듈 지원을 요구하지만 `type: "json"` 없이 import 할 때 JSON 모듈 지원을 금지하지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" oldids="sec-finishdynamicimport">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: Script Record, Cyclic Module Record, 또는 Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _payload_: GraphLoadingState Record 또는 PromiseCapability Record,
            _result_: Module Record 를 담은 정상 completion 또는 throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. _result_가 정상 completion이면
            1. _referrer_.[[LoadedModules]]에 ModuleRequestsEqual(_record_, _moduleRequest_)가 *true*인 LoadedModuleRequest Record _record_가 있으면
              1. 단언: _record_.[[Module]]과 _result_.[[Value]]는 동일한 Module Record이다.
            1. 그렇지 않으면
              1. LoadedModuleRequest Record { [[Specifier]]: _moduleRequest_.[[Specifier]], [[Attributes]]: _moduleRequest_.[[Attributes]], [[Module]]: _result_.[[Value]] }를 _referrer_.[[LoadedModules]]에 추가한다.
          1. _payload_가 GraphLoadingState Record이면
            1. ContinueModuleLoading(_payload_, _result_)를 수행한다.
          1. 그렇지 않으면
            1. ContinueDynamicImport(_payload_, _result_)를 수행한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-AllImportAttributesSupported" type="abstract operation">
        <h1>
          AllImportAttributesSupported (
            _attributes_: ImportAttribute Records 리스트,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. _supported_를 HostGetSupportedImportAttributes()로 둔다.
          1. _attributes_의 각 ImportAttribute Record _attribute_에 대해
            1. _supported_가 _attribute_.[[Key]]를 포함하지 않으면 *false*를 반환한다.
          1. *true*를 반환한다.
        </emu-alg>

        <emu-clause id="sec-hostgetsupportedimportattributes" type="host-defined abstract operation">
          <h1>HostGetSupportedImportAttributes ( ): 문자열 리스트</h1>
          <dl class="header">
            <dt>description</dt>
            <dd>호스트 환경이 지원하는 import attribute를 지정할 수 있게 한다. 지원되는 키를 가진 attribute만 호스트에 제공된다.</dd>
          </dl>

          <p>HostGetSupportedImportAttributes의 구현은 다음 요구사항을 따라야 한다:</p>

          <ul>
            <li>지원되는 각 attribute를 나타내는 문자열의 리스트를 반환해야 한다.</li>

            <li>이 연산이 호출될 때마다 동일한 순서와 내용의 동일한 리스트를 반환해야 한다.</li>
          </ul>

          <p>HostGetSupportedImportAttributes의 기본 구현은 새 빈 리스트를 반환하는 것이다.</p>

          <emu-note>호스트가 처리할 attribute를 선택하도록 모든 attribute를 전달하는 대신 지원되는 attribute만 명시하게 하는 목적은 지원되지 않는 attribute가 서로 다른 호스트 간에도 일관되게 처리되도록 하기 위함이다.</emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-getmodulenamespace" type="abstract operation">
        <h1>
          GetModuleNamespace (
            _module_: Module Record의 구체 하위 클래스 인스턴스,
          ): Module Namespace Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_module_의 export를 나타내는 Module Namespace Object를 가져온다. 처음 요청될 때 지연 생성하여 _module_.[[Namespace]]에 저장하고 이후 재사용한다.</dd>
        </dl>

        <emu-alg>
          1. 단언: _module_이 Cyclic Module Record라면 _module_.[[Status]]는 ~new~ 또는 ~unlinked~가 아니다.
          1. _namespace_를 _module_.[[Namespace]]로 둔다.
          1. _namespace_가 ~empty~이면
            1. _exportedNames_를 _module_.GetExportedNames()로 둔다.
            1. _unambiguousNames_를 새 빈 리스트로 둔다.
            1. _exportedNames_의 각 요소 _name_에 대해
              1. _resolution_을 _module_.ResolveExport(_name_)로 둔다.
              1. _resolution_이 ResolvedBinding Record이면 _name_을 _unambiguousNames_에 추가한다.
            1. _namespace_를 ModuleNamespaceCreate(_module_, _unambiguousNames_)로 설정한다.
          1. _namespace_를 반환한다.
        </emu-alg>
        <emu-note>
          <p>GetModuleNamespace는 예외를 던지지 않는다. 대신 이 시점에서 해결할 수 없는 이름은 네임스페이스에서 제외된다. 그러한 이름들은 어딘가에서 명시적으로 요청되지 않은 모호한 star export 전부가 아닌 한 이후 실제 링크 오류로 이어진다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. *undefined*를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <emu-alg>
          1. _result_를 Completion(Evaluation of |ModuleItemList|)로 둔다.
          1. _result_가 정상 completion이고 _result_.[[Value]]가 ~empty~이면
            1. *undefined*를 반환한다.
          1. ? _result_를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _sl_을 ? Evaluation of |ModuleItemList|로 둔다.
          1. _s_를 Completion(Evaluation of |ModuleItem|)로 둔다.
          1. ? UpdateEmpty(_s_, _sl_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>|ModuleItemList|의 값은 그 |ModuleItemList| 안에서 마지막으로 값을 생성한 항목의 값이다.</p>
        </emu-note>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. ~empty~를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>가져오기(Imports)</h1>
      <h2>구문</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause WithClause? `;`
          `import` ModuleSpecifier WithClause? `;`

        ImportClause :
          ImportedDefaultBinding
          NameSpaceImport
          NamedImports
          ImportedDefaultBinding `,` NameSpaceImport
          ImportedDefaultBinding `,` NamedImports

        ImportedDefaultBinding :
          ImportedBinding

        NameSpaceImport :
          `*` `as` ImportedBinding

        NamedImports :
          `{` `}`
          `{` ImportsList `}`
          `{` ImportsList `,` `}`

        FromClause :
          `from` ModuleSpecifier

        ImportsList :
          ImportSpecifier
          ImportsList `,` ImportSpecifier

        ImportSpecifier :
          ImportedBinding
          ModuleExportName `as` ImportedBinding

        ModuleSpecifier :
          StringLiteral

        ImportedBinding :
          BindingIdentifier[~Yield, +Await]

        WithClause :
          `with` `{` `}`
          `with` `{` WithEntries `,`? `}`

        WithEntries :
          AttributeKey `:` StringLiteral
          AttributeKey `:` StringLiteral `,` WithEntries

        AttributeKey :
          IdentifierName
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <ul>
          <li>
            |ImportDeclaration| 의 BoundNames 에 중복 항목이 있으면 문법 오류이다.
          </li>
        </ul>

        <emu-grammar>WithClause : `with` `{` WithEntries `,`? `}`</emu-grammar>
        <ul>
          <li>
            |WithClause| 의 WithClauseToAttributes 결과에 _a_.[[Key]] 가 _b_.[[Key]] 와 같은 서로 다른 항목 _a_, _b_ 두 개가 있으면 문법 오류이다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="sdo">
        <h1>정적 의미론: ImportEntries ( ): ImportEntry Record 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _entries1_ 을 |ModuleItemList| 의 ImportEntries 로 둔다.
          1. _entries2_ 를 |ModuleItem| 의 ImportEntries 로 둔다.
          1. _entries1_ 와 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ExportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. _module_ 을 |ImportDeclaration| 의 ModuleRequests 의 유일한 요소로 둔다.
          1. |ImportClause| 의 ImportEntriesForModule(_module_) 를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo">
        <h1>
          정적 의미론: ImportEntriesForModule (
          _module_: ModuleRequest Record,
          ): ImportEntry Record 리스트
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. _entries1_ 를 |ImportedDefaultBinding| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries2_ 를 |NameSpaceImport| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries1_ 와 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. _entries1_ 를 |ImportedDefaultBinding| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries2_ 를 |NamedImports| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries1_ 와 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ 을 |ImportedBinding| 의 BoundNames 의 유일한 요소로 둔다.
          1. _defaultEntry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *"default"*, [[LocalName]]: _localName_ } 로 둔다.
          1. « _defaultEntry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ 을 |ImportedBinding| 의 StringValue 로 둔다.
          1. _entry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. _specs1_ 을 |ImportsList| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _specs2_ 를 |ImportSpecifier| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _specs1_ 와 _specs2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ 을 |ImportedBinding| 의 BoundNames 의 유일한 요소로 둔다.
          1. _entry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. _importName_ 을 |ModuleExportName| 의 StringValue 로 둔다.
          1. _localName_ 을 |ImportedBinding| 의 StringValue 로 둔다.
          1. _entry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-withclausetoattributes" type="sdo">
        <h1>정적 의미론: WithClauseToAttributes ( ): ImportAttribute Record 리스트</h1>
        <dl class="header">
        </dl>

        <emu-grammar>
          WithClause : `with` `{` `}`
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>

        <emu-grammar>
          WithClause : `with` `{` WithEntries `,`? `}`
        </emu-grammar>
        <emu-alg>
          1. _attributes_ 를 |WithEntries| 의 WithClauseToAttributes 로 둔다.
          1. _attributes_ 의 [[Key]] 필드 값을 UTF-16 코드 유닛 시퀀스로 간주한 사전식 순서에 따라 정렬한다. 참고: 이 정렬은 호스트가 열거 순서에 따라 동작을 바꾸지 못하도록 강제한다는 점에서만 관측 가능하다.
          1. _attributes_ 를 반환한다.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral</emu-grammar>
        <emu-alg>
          1. _key_ 를 |AttributeKey| 의 PropName 으로 둔다.
          1. _entry_ 를 ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| 의 SV } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral `,` WithEntries</emu-grammar>
        <emu-alg>
          1. _key_ 를 |AttributeKey| 의 PropName 으로 둔다.
          1. _entry_ 를 ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| 의 SV } 로 둔다.
          1. _rest_ 를 |WithEntries| 의 WithClauseToAttributes 로 둔다.
          1. « _entry_ » 와 _rest_ 의 리스트 연결을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>내보내기(Exports)</h1>
      <h2>구문</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          `*` `as` ModuleExportName
          NamedExports

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            |NamedExports| 의 ReferencedBindings 에 |StringLiteral| 이 있으면 문법 오류이다.
          </li>
          <li>
            |NamedExports| 의 ReferencedBindings 에 있는 각 |IdentifierName| _n_ 에 대해: _n_ 의 StringValue 가 |ReservedWord| 이거나 *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"* 중 하나이면 문법 오류이다.
          </li>
        </ul>
        <emu-note>
          <p>위 규칙은 |NamedExports| 의 ReferencedBindings 각각이 |IdentifierReference| 로 취급됨을 의미한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportedbindings" oldids="sec-module-semantics-static-semantics-exportedbindings,sec-exports-static-semantics-exportedbindings" type="sdo">
        <h1>정적 의미론: ExportedBindings ( ): 문자열 리스트</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedBindings 는 |Module| 의 ExportedNames 와 명시적으로 연결된 로컬 바인딩 이름들이다.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ModuleItemList| 의 ExportedBindings 로 둔다.
          1. _names2_ 를 |ModuleItem| 의 ExportedBindings 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. |NamedExports| 의 ExportedBindings 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 이 |ExportDeclaration| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ExportsList| 의 ExportedBindings 로 둔다.
          1. _names2_ 를 |ExportSpecifier| 의 ExportedBindings 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 첫 번째 |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" oldids="sec-module-semantics-static-semantics-exportednames,sec-exports-static-semantics-exportednames" type="sdo">
        <h1>정적 의미론: ExportedNames ( ): 문자열 리스트</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames 는 |Module| 이 로컬 바인딩 이름 중 하나에 명시적으로 매핑하는 외부로 보이는 이름들이다.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ModuleItemList| 의 ExportedNames 로 둔다.
          1. _names2_ 를 |ModuleItem| 의 ExportedNames 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. |ExportDeclaration| 의 ExportedNames 를 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. |ExportFromClause| 의 ExportedNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. |NamedExports| 의 ExportedNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. « *"default"* » 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ExportsList| 의 ExportedNames 로 둔다.
          1. _names2_ 를 |ExportSpecifier| 의 ExportedNames 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 두 번째 |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" oldids="sec-module-semantics-static-semantics-exportentries,sec-exports-static-semantics-exportentries" type="sdo">
        <h1>정적 의미론: ExportEntries ( ): ExportEntry Record 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _entries1_ 을 |ModuleItemList| 의 ExportEntries 로 둔다.
          1. _entries2_ 를 |ModuleItem| 의 ExportEntries 로 둔다.
          1. _entries1_ 과 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. _module_ 을 |ExportDeclaration| 의 ModuleRequests 의 유일한 요소로 둔다.
          1. |ExportFromClause| 의 ExportEntriesForModule(_module_) 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. |NamedExports| 의 ExportEntriesForModule(*null*) 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. _entries_ 를 새 빈 리스트로 둔다.
          1. _names_ 를 |VariableStatement| 의 BoundNames 로 둔다.
          1. 각 _name_ ∈ _names_ 에 대해
            1. ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } 를 _entries_ 에 추가한다.
          1. _entries_ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. _entries_ 를 새 빈 리스트로 둔다.
          1. _names_ 를 |Declaration| 의 BoundNames 로 둔다.
          1. 각 _name_ ∈ _names_ 에 대해
            1. ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } 를 _entries_ 에 추가한다.
          1. _entries_ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. _names_ 를 |HoistableDeclaration| 의 BoundNames 로 둔다.
          1. _localName_ 을 _names_ 의 유일한 요소로 둔다.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. _names_ 를 |ClassDeclaration| 의 BoundNames 로 둔다.
          1. _localName_ 을 그 유일한 요소로 둔다.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. _entry_ 를 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* 는 익명 default export 값을 위한 명세 내부의 합성 이름이다. 더 자세한 내용은 <emu-xref href="#note-star-default-star">이 노트</emu-xref> 를 참조.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentriesformodule" type="sdo">
        <h1>
          정적 의미론: ExportEntriesForModule (
          _module_: ModuleRequest Record 또는 *null*,
          ): ExportEntry Record 리스트
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. _entry_ 를 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. _exportName_ 을 |ModuleExportName| 의 StringValue 로 둔다.
          1. _entry_ 를 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _specs1_ 을 |ExportsList| 의 ExportEntriesForModule(_module_) 로 둔다.
          1. _specs2_ 를 |ExportSpecifier| 의 ExportEntriesForModule(_module_) 로 둔다.
          1. _specs1_ 과 _specs2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. _sourceName_ 을 |ModuleExportName| 의 StringValue 로 둔다.
          1. _module_ 이 *null* 이면
            1. _localName_ = _sourceName_.
            1. _importName_ = *null*.
          1. 그렇지 않으면
            1. _localName_ = *null*.
            1. _importName_ = _sourceName_.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ } 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. _sourceName_ 을 첫 번째 |ModuleExportName| 의 StringValue 로 둔다.
          1. _exportName_ 을 두 번째 |ModuleExportName| 의 StringValue 로 둔다.
          1. _module_ 이 *null* 이면
            1. _localName_ = _sourceName_.
            1. _importName_ = *null*.
          1. 그렇지 않으면
            1. _localName_ = *null*.
            1. _importName_ = _sourceName_.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ } 인 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-referencedbindings" type="sdo">
        <h1>정적 의미론: ReferencedBindings ( ): Parse Node 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ExportsList| 의 ReferencedBindings 로 둔다.
          1. _names2_ 를 |ExportSpecifier| 의 ReferencedBindings 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 첫 번째 |ModuleExportName| 의 ReferencedBindings 를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleExportName : IdentifierName</emu-grammar>
        <emu-alg>
          1. 유일한 요소가 그 |IdentifierName| 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <emu-alg>
          1. 유일한 요소가 그 |StringLiteral| 인 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>
          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
        </emu-grammar>
        <emu-alg>
          1. ~empty~ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| 의 Evaluation 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| 의 Evaluation 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. |HoistableDeclaration| 의 Evaluation 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. _value_ 를 |ClassDeclaration| 의 BindingClassDeclarationEvaluation 결과(? )로 둔다.
          1. _className_ 을 |ClassDeclaration| 의 BoundNames 의 유일한 요소로 둔다.
          1. _className_ 이 *"\*default\*"* 이면
            1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
            1. ? InitializeBoundName(*"\*default\*"*, _value_, _env_) 를 수행한다.
          1. ~empty~ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이면
            1. _value_ 를 ? NamedEvaluation(|AssignmentExpression|, *"default"*) 로 둔다.
          1. 그렇지 않으면
            1. _rhs_ 를 ? Evaluation(|AssignmentExpression|) 로 둔다.
            1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
          1. ? InitializeBoundName(*"\*default\*"*, _value_, _env_) 를 수행한다.
          1. ~empty~ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-error-handling-and-language-extensions">
  <h1>오류 처리 및 언어 확장</h1>
  <p>구현은 관련 ECMAScript 언어 구성요소가 평가될 때 대부분의 오류를 보고해야 한다. <dfn id="early-error" variants="early errors">early error(조기 오류)</dfn> 는 그 오류를 포함하는 |Script| 안의 어떤 구성요소도 평가되기 전에 검출·보고될 수 있는 오류이다. 조기 오류가 존재하면 그 구성요소의 평가가 차단된다. 구현은 ParseScript 과정에서 해당 |Script| 를 파싱하는 일부로 |Script| 의 조기 오류를 보고해야 한다. |Module| 의 조기 오류는 그 |Module| 이 평가될 지점에서 보고되며 그 |Module| 은 결코 초기화되지 않는다. <b>eval</b> 코드의 조기 오류는 `eval` 이 호출되는 시점에 보고되며 해당 <b>eval</b> 코드의 평가를 막는다. 조기 오류가 아닌 모든 오류는 런타임 오류이다.</p>
  <p>구현은 이 명세의 “Static Semantics: Early Errors” 하위 절에 열거된 조건이 발생하면 반드시 그것을 조기 오류로 보고해야 한다.</p>
  <p>구현은 (컴파일러가 어떤 구성요소가 어떤 상황에서도 오류 없이 실행될 수 없음을 입증할 수 있더라도) 다른 종류의 오류를 조기 오류로 취급해서는 안 된다. 그런 경우 구현이 조기 경고를 낼 수는 있지만, 관련 구성요소가 실제로 실행될 때까지 오류를 보고해서는 안 된다.</p>
  <p>구현은 다음과 같은 경우를 제외하고 명세된 대로 모든 오류를 보고해야 한다:</p>
  <ul>
    <li>
      <emu-xref href="#sec-forbidden-extensions"></emu-xref> 에서 제한된 경우를 제외하고 호스트 또는 구현은 |Script| 구문, |Module| 구문, 그리고 정규 표현식 패턴 또는 플래그 구문을 확장할 수 있다. 이를 허용하기 위해 *SyntaxError* 를 던질 수 있는(예: `eval` 호출, 정규 표현식 리터럴 사용, Function 또는 RegExp 생성자 사용) 모든 연산은 스크립트 구문이나 정규 표현식 패턴/플래그 구문에 대한 호스트 정의 확장을 만나면 *SyntaxError* 를 던지는 대신 호스트 정의 동작을 보일 수 있다.
    </li>
    <li>
      <emu-xref href="#sec-forbidden-extensions"></emu-xref> 에서 제한된 경우를 제외하고 호스트 또는 구현은 이 명세에 기술된 것 이외의 추가적인 타입, 값, 객체, 프로퍼티, 함수를 제공할 수 있다. 이는 (예: 전역 스코프에서 변수 조회 같은) 구성요소가 오류(예: *ReferenceError*) 를 던지는 대신 호스트 정의 동작을 갖도록 만들 수 있다.
    </li>
  </ul>

  <emu-clause id="sec-forbidden-extensions">
    <h1>금지된 확장</h1>
    <p>구현은 다음과 같은 방식으로 이 명세를 확장해서는 안 된다:</p>
    <ul>
      <li>
        strict 모드 코드에서 구문 생성자를 사용해 정의된 ECMAScript 함수 객체는 자체(own) 프로퍼티로 *"caller"*, *"arguments"* 라는 이름을 갖도록 생성되어서는 안 된다. 또한 |ArrowFunction|, |MethodDefinition|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |ClassDeclaration|, |ClassExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncArrowFunction| 으로 정의된 함수 객체 역시 정의가 strict 모드 코드 안에 있든 없든 그러한 own 프로퍼티를 가져서는 안 된다. 내장 함수, Function 생성자로 생성된 strict 함수, Generator 생성자로 생성된 generator 함수, AsyncFunction 생성자로 생성된 async 함수, `bind` 메서드로 생성된 함수 역시 그러한 own 프로퍼티를 가져서는 안 된다.
      </li>
      <li>
        구현이 어떤 함수 객체를 *"caller"* 라는 own 프로퍼티로 확장하는 경우 [[Get]] 또는 [[GetOwnProperty]] 로 관찰되는 그 프로퍼티의 값은 strict 함수 객체가 되어서는 안 된다. 그것이 접근자 프로퍼티라면 [[Get]] 특성의 값인 함수는 호출 시 strict 함수를 반환해서는 안 된다.
      </li>
      <li>
        매핑되었거나 매핑되지 않은 arguments 객체 모두 *"caller"* 라는 own 프로퍼티로 생성되어서는 안 된다.
      </li>
      <li>
        ECMA-402 에 명세된(예: `toLocaleString` 라는 이름을 가진) 내장 메서드의 동작은 ECMA-402 에서 명시된 것 이외로 확장되어서는 안 된다.
      </li>
      <li>
        <emu-xref href="#sec-patterns"></emu-xref> 및 <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> 의 RegExp 패턴 문법은 <sub>[UnicodeMode]</sub> 문법 매개변수가 존재할 때 A-Z 또는 a-z 소스 문자를 |IdentityEscape[+UnicodeMode]| 로 인식하도록 확장되어서는 안 된다.
      </li>
      <li>
        어휘 비단말 기호 |BindingIdentifier| 로 매치되는 소스 텍스트 바로 뒤에 토큰 `:` 이 올 수 있게 하는 방식으로 구문 문법을 확장해서는 안 된다.
      </li>
      <li>
        strict 모드 코드를 처리할 때 구현은 <emu-xref href="#sec-numeric-literals-early-errors"></emu-xref> 의 조기 오류 규칙을 완화해서는 안 된다.
      </li>
      <li>
        |TemplateEscapeSequence| 는 <emu-xref href="#sec-literals-string-literals"></emu-xref> 에 정의된 |LegacyOctalEscapeSequence| 또는 |NonOctalDecimalEscapeSequence| 를 포함하도록 확장되어서는 안 된다.
      </li>
      <li>
        strict 모드 코드를 처리할 때 <emu-xref href="#sec-labelled-function-declarations"></emu-xref>, <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>, <emu-xref href="#sec-functiondeclarations-in-ifstatement-statement-clauses"></emu-xref>, <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 정의된 확장은 지원되어서는 안 된다.
      </li>
      <li>
        |Module| 목표 심볼을 파싱할 때 <emu-xref href="#sec-html-like-comments"></emu-xref> 에 정의된 어휘(grammar) 확장은 지원되어서는 안 된다.
      </li>
      <!-- The following is so that in the future we can potentially add new arguments or support ArgumentList. -->
      <li>
        |ImportCall| 은 확장되어서는 안 된다.
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-standard-built-in-objects">
  <h1>ECMAScript 표준 내장 객체</h1>
  <p>ECMAScript |Script| 또는 |Module| 이 실행을 시작할 때 항상 이용 가능한 특정 내장 객체들이 있다. 그중 전역 객체는 실행 중인 프로그램의 전역 환경 일부이다. 다른 것들은 전역 객체의 초기 프로퍼티로서 또는 접근 가능한 내장 객체의 프로퍼티를 통해 간접적으로 접근할 수 있다.</p>
  <p>별도로 명시되지 않는 한 함수로 호출 가능한 내장 객체는 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 에 기술된 특성을 가진 내장 함수 객체이다. 별도로 명시되지 않는 한 내장 객체의 [[Extensible]] 내부 슬롯의 초기 값은 *true* 이다. 모든 내장 함수 객체는 자신이 처음 생성된 Realm 의 Realm Record 값을 가지는 [[Realm]] 내부 슬롯을 가진다.</p>
  <p>많은 내장 객체는 함수이며, 인수를 전달받아 호출될 수 있다. 그중 일부는 생성자이기도 하여 `new` 연산자와 함께 사용하도록 의도된 함수이다. 각 내장 함수에 대해 이 명세는 그 함수가 요구하는 인수와 함수 객체의 프로퍼티를 기술한다. 각 내장 생성자에 대해서는 추가로 그 생성자의 프로토타입 객체 프로퍼티 및 그 생성자를 호출하는 `new` 표현식이 반환하는 특정 객체 인스턴스의 프로퍼티를 기술한다.</p>
  <p>특정 함수의 설명에서 달리 명시되지 않는 한, 내장 함수나 생성자가 지정된 것보다 적은 인수를 받으면, 부족한 인수들을 *undefined* 값으로 채워 받은 것과 정확히 동일하게 동작해야 한다. 이러한 누락된 인수들은 “존재하지 않음” 으로 간주되며 명세 알고리즘에서 그렇게 식별될 수 있다. 특정 함수 설명에서 “*this* value” 와 “NewTarget” 용어는 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 에서 부여된 의미를 가진다.</p>
  <p>특정 함수 설명에서 달리 명시되지 않는 한, 내장 함수나 생성자가 허용된 것보다 많은 인수를 받으면 추가 인수는 평가되지만 함수는 이를 무시한다. 단, 구현은 그러한 인수에 대해 *TypeError* 예외를 단지 “추가 인수가 존재한다” 는 이유만으로 던지지 않는 한 구현 정의 동작을 규정할 수 있다.</p>
  <emu-note>
    <p>내장 함수 집합에 추가 기능을 덧붙이는 구현은 기존 함수에 새 매개변수를 추가하기보다 새 함수를 추가하는 방식으로 하는 것이 권장된다.</p>
  </emu-note>
  <p>별도로 명시되지 않는 한 모든 내장 함수 및 내장 생성자는 자신의 [[Prototype]] 내부 슬롯 값으로 Function 프로토타입 객체(표현식 `Function.prototype` 의 초기 값, <emu-xref href="#sec-properties-of-the-function-prototype-object"></emu-xref>) 를 가진다.</p>
  <p>별도로 명시되지 않는 한 모든 내장 프로토타입 객체는 (자기 자신인 Object 프로토타입 객체를 제외하고) 자신의 [[Prototype]] 내부 슬롯 값으로 Object 프로토타입 객체(표현식 `Object.prototype` 의 초기 값, <emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>) 를 가진다.</p>
  <p>이 명세가 내장 생성자의 동작을 알고리즘 단계로 정의했다면, 그것이 [[Call]] 과 [[Construct]] 양쪽 목적의 동작이다. 해당 알고리즘이 두 경우를 구분할 필요가 있으면 NewTarget 이 *undefined* 인지 검사하는데, 이는 [[Call]] 호출을 의미한다.</p>
  <p>생성자로 식별되지 않은 내장 함수 객체는 특정 함수 설명에서 별도로 명시되지 않는 한 [[Construct]] 내부 메서드를 구현하지 않는다.</p>
  <p>생성자가 아닌 내장 함수 객체는 특정 함수 설명에서 별도로 명시되지 않는 한 *"prototype"* 프로퍼티를 갖지 않는다.</p>
  <p>이 명세에 정의된 각 내장 함수는 CreateBuiltinFunction 추상 연산(<emu-xref href="#sec-createbuiltinfunction"></emu-xref>) 호출로 생성된다. _length_ 및 _name_ 매개변수의 값은 아래에서 논의되는 *"length"* 및 *"name"* 프로퍼티의 초기 값이다. _prefix_ 매개변수의 값도 유사하게 아래에서 논의된다.</p>
  <p>생성자를 포함한 모든 내장 함수 객체는 *"length"* 프로퍼티를 가지며 그 값은 0 이상의 정수 Number 이다. 별도로 명시되지 않는 한 이 값은 함수 설명 하위 절 제목에 나타난 필수 매개변수의 수이다. 선택적 매개변수와 rest 매개변수는 개수에 포함되지 않는다.</p>
  <emu-note>
    <p>예: Array 프로토타입 객체의 *"map"* 프로퍼티 초기 값인 함수 객체는 «Array.prototype.map (callback [ , thisArg])» 라는 제목 아래에 기술되며, 이름 있는 두 인수 callback 과 선택적인 thisArg 를 보여준다. 따라서 그 함수 객체의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub> 이다.</p>
  </emu-note>
  <p>별도로 명시되지 않는 한 내장 함수 객체의 *"length"* 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
  <p>생성자를 포함한 모든 내장 함수 객체는 *"name"* 프로퍼티를 가지며 그 값은 String 이다. 별도로 명시되지 않는 한 이 값은 명세에서 그 함수에 부여된 이름이다. 익명 함수로 식별된 함수들은 빈 문자열을 *"name"* 프로퍼티 값으로 사용한다. 객체의 프로퍼티로 명세된 함수의 경우 이름 값은 그 함수를 접근하는 데 쓰이는 프로퍼티 이름 문자열이다. 내장 프로퍼티의 get 또는 set 접근자 함수로 명세된 함수는 CreateBuiltinFunction 을 호출할 때 _prefix_ 매개변수로 각각 *"get"* 또는 *"set"* 을 전달한다.</p>
  <p>프로퍼티 키가 Symbol 값인 각 내장 함수에 대해 *"name"* 프로퍼티 값은 명시적으로 지정된다. 그러한 명시적 값이 접두사 *"get "* 또는 *"set "* 로 시작하고 그 함수가 내장 프로퍼티의 get 또는 set 접근자 함수라면, 접두사를 제거한 값이 _name_ 매개변수로 전달되고 *"get"* 또는 *"set"* 값이 _prefix_ 매개변수로 전달된다.</p>
  <p>별도로 명시되지 않는 한 내장 함수 객체의 *"name"* 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> 부터 <emu-xref href="#sec-reflection"></emu-xref> 절 및 부록 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> 에 기술된 다른 모든 데이터 프로퍼티는 명시적으로 달리 지정되지 않는 한 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 갖는다.</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> 부터 <emu-xref href="#sec-reflection"></emu-xref> 절 및 부록 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> 에 기술된 모든 접근자 프로퍼티는 명시적으로 달리 지정되지 않는 한 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 갖는다. get 접근자 함수만 기술된 경우 set 접근자 함수의 기본값은 *undefined* 이다. set 접근자만 기술된 경우 get 접근자의 기본값은 *undefined* 이다.</p>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>전역 객체(The Global Object)</h1>
  <p><dfn variants="global objects">전역 객체</dfn>:</p>
  <ul>
    <li>어떤 실행 컨텍스트에 제어가 진입하기 전에 생성된다.</li>
    <li>[[Construct]] 내부 메서드를 가지지 않는다; `new` 연산자로 생성자로 사용할 수 없다.</li>
    <li>[[Call]] 내부 메서드를 가지지 않는다; 함수로 호출될 수 없다.</li>
    <li>값이 호스트 정의인 [[Prototype]] 내부 슬롯을 가진다.</li>
    <li>명세에 정의된 프로퍼티 외에 호스트 정의 프로퍼티를 가질 수 있다. 여기에는 값이 전역 객체 자신인 프로퍼티가 포함될 수 있다.</li>
  </ul>

  <emu-clause id="sec-value-properties-of-the-global-object">
    <h1>전역 객체의 값(Value) 프로퍼티</h1>

    <emu-clause id="sec-globalthis">
      <h1>globalThis</h1>
      <p>Realm Record _realm_ 에서 전역 객체의 *"globalThis"* 프로퍼티 초기 값은 _realm_.[[GlobalEnv]].[[GlobalThisValue]] 이다.</p>
      <p>이 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 갖는다.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-infinity">
      <h1>Infinity</h1>
      <p>`Infinity` 의 값은 *+∞*<sub>𝔽</sub> 이다(<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 참조). 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 갖는다.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-nan">
      <h1>NaN</h1>
      <p>`NaN` 의 값은 *NaN* 이다(<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 참조). 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 갖는다.</p>
    </emu-clause>

    <emu-clause id="sec-undefined">
      <h1>undefined</h1>
      <p>`undefined` 의 값은 *undefined* 이다(<emu-xref href="#sec-ecmascript-language-types-undefined-type"></emu-xref> 참조). 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 갖는다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>전역 객체의 함수(Function) 프로퍼티</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <p>이 함수는 <dfn>%eval%</dfn> 고유(intrinsic) 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. Return ? PerformEval(_x_, *false*, *false*).
      </emu-alg>

      <emu-clause id="sec-performeval" type="abstract operation" oldids="sec-performeval-rules-outside-functions,sec-performeval-rules-outside-methods,sec-performeval-rules-outside-constructors">
        <h1>
          PerformEval (
            _x_: ECMAScript 언어 값,
            _strictCaller_: Boolean,
            _direct_: Boolean,
          ): ECMAScript 언어 값을 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: _direct_ 가 *false* 이면 _strictCaller_ 도 *false*.
          1. _x_ 가 String 이 아니면 _x_ 를 반환.
          1. _evalRealm_ 을 현재 Realm Record 로 둔다.
          1. 참고: direct eval 의 경우 _evalRealm_ 은 `eval` 호출자와 `eval` 함수 자체의 realm 이다.
          1. ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_) 수행.
          1. _inFunction_ = *false*.
          1. _inMethod_ = *false*.
          1. _inDerivedConstructor_ = *false*.
          1. _inClassFieldInitializer_ = *false*.
          1. _direct_ 가 *true* 이면
            1. _thisEnvRec_ = GetThisEnvironment().
            1. _thisEnvRec_ 가 Function Environment Record 이면
              1. _F_ = _thisEnvRec_.[[FunctionObject]].
              1. _inFunction_ = *true* 로.
              1. _inMethod_ = _thisEnvRec_.HasSuperBinding().
              1. _F_.[[ConstructorKind]] 가 ~derived~ 이면 _inDerivedConstructor_ = *true*.
              1. _classFieldInitializerName_ = _F_.[[ClassFieldInitializerName]].
              1. _classFieldInitializerName_ 이 ~empty~ 가 아니면 _inClassFieldInitializer_ = *true*.
          1. 구현 정의 순서(파싱과 오류 검출을 교차 실행 가능)로 다음 하위 단계 수행:
            1. _script_ = ParseText(_x_, |Script|).
            1. _script_ 가 오류 리스트면 *SyntaxError* 예외 throw.
            1. _script_ Contains |ScriptBody| 가 *false* 이면 *undefined* 반환.
            1. _body_ = _script_ 의 |ScriptBody|.
            1. _inFunction_ 이 *false* 이고 _body_ Contains |NewTarget| 이면 *SyntaxError* throw.
            1. _inMethod_ 이 *false* 이고 _body_ Contains |SuperProperty| 이면 *SyntaxError* throw.
            1. _inDerivedConstructor_ 가 *false* 이고 _body_ Contains |SuperCall| 이면 *SyntaxError* throw.
            1. _inClassFieldInitializer_ 가 *true* 이고 ContainsArguments(_body_) 가 *true* 이면 *SyntaxError* throw.
          1. _strictCaller_ 가 *true* 이면 _strictEval_ = *true*.
          1. Else _strictEval_ = ScriptIsStrict(_script_).
          1. _runningContext_ = 실행 중 실행 컨텍스트.
          1. 참고: _direct_ *true* 이면 호출한 컨텍스트; *false* 이면 `eval` 호출 실행 컨텍스트.
          1. _direct_ 가 *true* 이면
            1. _lexEnv_ = NewDeclarativeEnvironment(_runningContext_.LexicalEnvironment).
            1. _varEnv_ = _runningContext_.VariableEnvironment.
            1. _privateEnv_ = _runningContext_.PrivateEnvironment.
          1. Else
            1. _lexEnv_ = NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).
            1. _varEnv_ = _evalRealm_.[[GlobalEnv]].
            1. _privateEnv_ = *null*.
          1. _strictEval_ 이 *true* 이면 _varEnv_ = _lexEnv_.
          1. _runningContext_ 가 아직 suspend 상태가 아니면 suspend.
          1. _evalContext_ = 새 ECMAScript 코드 실행 컨텍스트.
          1. _evalContext_.Function = *null*.
          1. _evalContext_.Realm = _evalRealm_.
          1. _evalContext_.ScriptOrModule = _runningContext_.ScriptOrModule.
          1. _evalContext_.VariableEnvironment = _varEnv_.
          1. _evalContext_.LexicalEnvironment = _lexEnv_.
          1. _evalContext_.PrivateEnvironment = _privateEnv_.
          1. _evalContext_ 를 실행 컨텍스트 스택에 push; 현재 실행 컨텍스트.
          1. _result_ = Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)).
          1. _result_ 가 normal 이면
            1. _result_ = Completion(Evaluation(_body_)).
          1. _result_ 가 normal 이고 _result_.[[Value]] 가 ~empty~ 이면
            1. _result_ = NormalCompletion(*undefined*).
          1. _evalContext_ suspend 후 스택에서 제거.
          1. 스택 맨 위 컨텍스트 resume.
          1. Return ? _result_.
        </emu-alg>
        <emu-note>
          <p>eval 코드는 호출 컨텍스트나 eval 코드 둘 중 하나라도 strict 모드이면 호출자 변수 환경에 var/function 바인딩을 인스턴스화할 수 없다. 대신 새 VariableEnvironment 에 인스턴스화된다. `let`, `const`, `class` 선언이 도입하는 바인딩은 항상 새 LexicalEnvironment 에 인스턴스화된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostensurecancompilestrings" type="host-defined abstract operation">
        <h1>
          HostEnsureCanCompileStrings (
            _calleeRealm_: Realm Record,
            _parameterStrings_: 문자열 리스트,
            _bodyString_: String,
            _direct_: Boolean,
          ): ~unused~ 를 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>문자열을 ECMAScript 코드로 해석·평가할 수 있게 하는 특정 ECMAScript 함수를 호스트 환경이 차단할 수 있도록 한다.</dd>
        </dl>
        <p>
          _parameterStrings_ 는 함수 생성자 중 하나를 사용할 때 파라미터 목록을 구성하기 위해 연결될 문자열들을 나타낸다. _bodyString_ 은 함수 본문 또는 `eval` 에 전달된 문자열을 나타낸다.
          _direct_ 는 평가가 direct eval 인지 여부를 나타낸다.
        </p>
        <p>기본 구현은 NormalCompletion(~unused~) 을 반환한다.</p>
      </emu-clause>

      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-evaldeclarationinstantiation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: |ScriptBody| Parse Node,
            _varEnv_: Environment Record,
            _lexEnv_: Declarative Environment Record,
            _privateEnv_: PrivateEnvironment Record 또는 *null*,
            _strict_: Boolean,
          ): ~unused~ 를 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _varNames_ = VarDeclaredNames(_body_).
          1. _varDeclarations_ = VarScopedDeclarations(_body_).
          1. _strict_ 이 *false* 이면
            1. _varEnv_ 가 Global Environment Record 이면
              1. 각 _name_ ∈ _varNames_ 에 대해
                1. HasLexicalDeclaration(_varEnv_, _name_) 가 *true* 이면 *SyntaxError* throw.
                1. 참고: `eval` 은 전역 lexical 선언에 의해 shadow 되는 전역 var 선언을 만들지 않는다.
            1. _thisEnv_ = _lexEnv_.
            1. 단언: 다음 루프는 종료한다.
            1. 반복 (_thisEnv_ 및 _varEnv_ 가 동일 Environment Record 가 아닐 동안)
              1. _thisEnv_ 가 Object Environment Record 가 아니면
                1. 참고: with 문의 환경은 lexical 선언을 포함할 수 없으므로 var/let hoisting 충돌 점검 불필요.
                1. 각 _name_ ∈ _varNames_ 에 대해
                  1. ! _thisEnv_.HasBinding(_name_) 가 *true* 이면
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> 를 지원하면
                      1. _thisEnv_ 가 |Catch| 절의 Environment Record 가 아니면 *SyntaxError* throw.
                    1. Else
                      1. *SyntaxError* throw.
                  1. 참고: direct eval 은 같은 이름의 lexical 선언 위로 var 를 hoist 하지 않는다.
              1. _thisEnv_ = _thisEnv_.[[OuterEnv]].
          1. _privateIdentifiers_ = 새 빈 리스트.
          1. _pointer_ = _privateEnv_.
          1. 반복 (_pointer_ ≠ *null*)
            1. _pointer_.[[Names]] 의 각 Private Name _binding_ 에 대해
              1. _privateIdentifiers_ 가 _binding_.[[Description]] 포함하지 않으면 append.
            1. _pointer_ = _pointer_.[[OuterPrivateEnvironment]].
          1. AllPrivateIdentifiersValid(_body_, _privateIdentifiers_) 가 *false* 이면 *SyntaxError* throw.
          1. _functionsToInitialize_ = 새 빈 리스트.
          1. _declaredFunctionNames_ = 새 빈 리스트.
          1. _varDeclarations_ 을 역순으로 순회하며 각 _d_ 에 대해
            1. _d_ 가 |VariableDeclaration|, |ForBinding|, |BindingIdentifier| 가 아니면
              1. 단언: _d_ 는 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|.
              1. 참고: 같은 이름의 다수 함수 선언이 있으면 마지막 것이 사용됨.
              1. _fn_ = BoundNames(_d_) 의 유일한 요소.
              1. _declaredFunctionNames_ 가 _fn_ 포함하지 않으면
                1. _varEnv_ 가 Global Environment Record 이면
                  1. _fnDefinable_ = ? CanDeclareGlobalFunction(_varEnv_, _fn_).
                  1. _fnDefinable_ 가 *false* 이면 *TypeError* throw.
                1. _fn_ 을 _declaredFunctionNames_ 에 추가.
                1. _d_ 를 _functionsToInitialize_ 의 첫 요소로 삽입.
          1. _declaredVarNames_ = 새 빈 리스트.
          1. _varDeclarations_ 의 각 _d_ 에 대해
            1. _d_ 가 |VariableDeclaration|, |ForBinding|, |BindingIdentifier| 이면
              1. BoundNames(_d_) 의 각 String _vn_ 에 대해
                1. _declaredFunctionNames_ 가 _vn_ 포함하지 않으면
                  1. _varEnv_ 가 Global Environment Record 이면
                    1. _vnDefinable_ = ? CanDeclareGlobalVar(_varEnv_, _vn_).
                    1. _vnDefinable_ *false* 이면 *TypeError* throw.
                  1. _declaredVarNames_ 가 _vn_ 포함하지 않으면 append.
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point", normative-optional] _strict_ 이 *false* 이고 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
            1. _declaredFunctionOrVarNames_ = _declaredFunctionNames_ ⋃ _declaredVarNames_ (리스트 연결).
            1. _body_ Contains _x_ 가 *true* 인 모든 |Block|, |CaseClause|, |DefaultClause| _x_ 의 |StatementList| 에 직접 포함된 각 |FunctionDeclaration| _f_ 에 대해
              1. _F_ = _f_ 의 |BindingIdentifier| StringValue.
              1. _f_ 를 _F_ 를 |BindingIdentifier| 로 하는 |VariableStatement| 로 치환해도 _body_ 에 Early Error 가 발생하지 않으면
                1. _bindingExists_ = *false*.
                1. _thisEnv_ = _lexEnv_.
                1. 단언: 루프 종료 보장.
                1. 반복 (_thisEnv_ ≠ _varEnv_)
                  1. _thisEnv_ 가 Object Environment Record 가 아니면
                    1. ! _thisEnv_.HasBinding(_F_) 가 *true* 이면
                      1. [id="step-evaldeclarationinstantiation-web-compat-bindingexists", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> 를 지원하면
                        1. _thisEnv_ 가 |Catch| 절 Environment Record 가 아니면 _bindingExists_ = *true*.
                      1. Else
                        1. _bindingExists_ = *true*.
                  1. _thisEnv_ = _thisEnv_.[[OuterEnv]].
                1. _bindingExists_ 가 *false* 이고 _varEnv_ 가 Global Environment Record 이면
                  1. HasLexicalDeclaration(_varEnv_, _F_) 가 *false* 이면
                    1. _fnDefinable_ = ? CanDeclareGlobalVar(_varEnv_, _F_).
                  1. Else
                    1. _fnDefinable_ = *false*.
                1. Else
                  1. _fnDefinable_ = *true*.
                1. _bindingExists_ *false* 이고 _fnDefinable_ *true* 이면
                  1. _declaredFunctionOrVarNames_ 가 _F_ 포함하지 않으면
                    1. _varEnv_ 가 Global Environment Record 이면
                      1. ? CreateGlobalVarBinding(_varEnv_, _F_, *true*).
                    1. Else
                      1. _bindingExists_ = ! _varEnv_.HasBinding(_F_).
                      1. _bindingExists_ *false* 이면
                        1. ! _varEnv_.CreateMutableBinding(_F_, *true*).
                        1. ! _varEnv_.InitializeBinding(_F_, *undefined*).
                    1. _F_ 를 _declaredFunctionOrVarNames_ 에 추가.
                  1. [id="step-evaldeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ 평가 시 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 의 기본 알고리즘 대신:
                    1. _gEnv_ = 실행 중 컨텍스트 VariableEnvironment.
                    1. _bEnv_ = 실행 중 컨텍스트 LexicalEnvironment.
                    1. _fObj_ = ! _bEnv_.GetBindingValue(_F_, *false*).
                    1. ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*).
                    1. ~unused~ 반환.
          1. [id="step-evaldeclarationinstantiation-post-validation"] 참고: _varEnv_ 가 Global Environment Record 이고 전역 객체가 Proxy exotic object 인 경우가 아니면 이 단계 이후 비정상 종료 없음.
          1. _lexDeclarations_ = LexicallyScopedDeclarations(_body_).
          1. 각 _d_ ∈ _lexDeclarations_ 에 대해
            1. 참고: 어휘 선언된 이름은 여기서 인스턴스화만 하고 초기화하지 않음.
            1. BoundNames(_d_) 의 각 _dn_ 에 대해
              1. IsConstantDeclaration(_d_) *true* 이면
                1. ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).
              1. Else
                1. ? _lexEnv_.CreateMutableBinding(_dn_, *false*).
          1. _functionsToInitialize_ 의 각 Parse Node _f_ 에 대해
            1. _fn_ = BoundNames(_f_) 의 유일한 요소.
            1. _fo_ = InstantiateFunctionObject(_f_, _lexEnv_, _privateEnv_).
            1. _varEnv_ 가 Global Environment Record 이면
              1. ? CreateGlobalFunctionBinding(_varEnv_, _fn_, _fo_, *true*).
            1. Else
              1. _bindingExists_ = ! _varEnv_.HasBinding(_fn_).
              1. _bindingExists_ *false* 이면
                1. 참고: 앞선 검증 때문에 abrupt 발생 불가.
                1. ! _varEnv_.CreateMutableBinding(_fn_, *true*).
                1. ! _varEnv_.InitializeBinding(_fn_, _fo_).
              1. Else
                1. ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
          1. 각 String _vn_ ∈ _declaredVarNames_ 에 대해
            1. _varEnv_ 가 Global Environment Record 이면
              1. ? CreateGlobalVarBinding(_varEnv_, _vn_, *true*).
            1. Else
              1. _bindingExists_ = ! _varEnv_.HasBinding(_vn_).
              1. _bindingExists_ *false* 이면
                1. 참고: 앞선 검증으로 abrupt 불가.
                1. ! _varEnv_.CreateMutableBinding(_vn_, *true*).
                1. ! _varEnv_.InitializeBinding(_vn_, *undefined*).
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-isfinite-number">
      <h1>isFinite ( _number_ )</h1>
      <p>이 함수는 <dfn>%isFinite%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _num_ = ? ToNumber(_number_).
        1. _num_ 이 finite 가 아니면 *false* 반환.
        1. 그렇지 않으면 *true* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isnan-number">
      <h1>isNaN ( _number_ )</h1>
      <p>이 함수는 <dfn>%isNaN%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _num_ = ? ToNumber(_number_).
        1. _num_ 이 *NaN* 이면 *true* 반환.
        1. 그렇지 않으면 *false* 반환.
      </emu-alg>
      <emu-note>
        <p>값 `X` 가 *NaN* 인지 신뢰성 있게 시험하는 ECMAScript 표현은 `X !== X` 형태이다. 결과가 *true* 이면 그리고 오직 그때만 `X` 는 *NaN* 이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parsefloat-string">
      <h1>parseFloat ( _string_ )</h1>
      <p>이 함수는 _string_ 인수를 10진 리터럴로 해석한 결과에 따라 Number 값을 생성한다.</p>
      <p><dfn>%parseFloat%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _inputString_ = ? ToString(_string_).
        1. _trimmedString_ = ! TrimString(_inputString_, ~start~).
        1. _trimmed_ = StringToCodePoints(_trimmedString_).
        1. _trimmedPrefix_ = |StrDecimalLiteral| 문법을 만족하는(없으면 없음) 가장 긴 접두사. 없다면 *NaN* 반환.
        1. _parsedNumber_ = ParseText(_trimmedPrefix_, |StrDecimalLiteral|).
        1. 단언: _parsedNumber_ 는 Parse Node.
        1. _parsedNumber_ 의 StringNumericValue 반환.
      </emu-alg>
      <emu-note>
        <p>이 함수는 _string_ 의 선두 일부만 Number 로 해석할 수 있고, 10진 표기 일부가 될 수 없는 코드 유닛은 무시하며 무시되었다는 표시를 제공하지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parseint-string-radix">
      <h1>parseInt ( _string_, _radix_ )</h1>
      <p>이 함수는 _radix_ 에 따라 _string_ 내용을 해석하여 정수 Number 값을 생성한다. _string_ 의 선행 공백은 무시된다. _radix_ 가 0 으로 강제될 경우(예: *undefined*) 표현이 *"0x"* 또는 *"0X"* 로 시작하지 않으면 10, 그렇다면 16 으로 간주한다. _radix_ 가 16 이면 표현은 *"0x"* / *"0X"* 로 시작할 수도 있다.</p>
      <p><dfn>%parseInt%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _inputString_ = ? ToString(_string_).
        1. _S_ = ! TrimString(_inputString_, ~start~).
        1. _sign_ = 1.
        1. _S_ 가 비어 있지 않고 첫 코드 유닛이 0x002D 이면 _sign_ = -1.
        1. _S_ 가 비어 있지 않고 첫 코드 유닛이 0x002B 또는 0x002D 이면 _S_ = 인덱스 1 부터.
        1. _R_ = ℝ(? ToInt32(_radix_)).
        1. _stripPrefix_ = *true*.
        1. _R_ ≠ 0 이면
          1. _R_ &lt; 2 또는 _R_ > 36 이면 *NaN* 반환.
          1. _R_ ≠ 16 이면 _stripPrefix_ = *false*.
        1. Else
          1. _R_ = 10.
        1. _stripPrefix_ *true* 이면
          1. _S_ 길이 ≥ 2 이고 첫 두 코드 유닛이 *"0x"* 또는 *"0X"* 이면
            1. _S_ = 인덱스 2 부터.
            1. _R_ = 16.
        1. _S_ 가 radix-_R_ 숫자가 아닌 코드 유닛을 포함하면 _end_ = 그 첫 위치, 아니면 길이.
        1. _Z_ = _S_[0.._end_).
        1. _Z_ 가 비어 있으면 *NaN* 반환.
        1. _mathInt_ = _Z_ 가 radix-_R_ 표기에서 나타내는 정수 (규정된 근사 허용).
        1. _mathInt_ = 0 이면
          1. _sign_ = -1 이면 *-0*<sub>𝔽</sub> 반환.
          1. *+0*<sub>𝔽</sub> 반환.
        1. 𝔽(_sign_ × _mathInt_) 반환.
      </emu-alg>
      <emu-note>
        <p>이 함수는 _string_ 의 선두 일부만 정수로 해석할 수 있으며 나머지는 무시되고 무시 사실은 표시되지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-uri-handling-functions" oldids="sec-uri-syntax-and-semantics">
      <h1>URI 처리 함수</h1>
      <p>Uniform Resource Identifier(URI)는 자원(웹 페이지, 파일 등)과 Internet 상에서 그것에 접근할 전송 프로토콜(HTTP, FTP 등)을 식별하는 String 이다. ECMAScript 자체는 이 절에 기술된 URI 인코딩·디코딩 함수 외에는 URI 사용 지원을 제공하지 않는다. `encodeURI`, `decodeURI` 는 전체 URI 에 사용하도록 의도되며 예약 문자는 특별한 의미(구분자 등)를 가정하므로 인코딩하지 않는다. `encodeURIComponent`, `decodeURIComponent` 는 URI 개별 구성 요소에 사용하도록 의도되며, 예약 문자가 텍스트를 나타낸다고 가정하고 전체 URI 의 일부가 될 때 특별한 의미를 피하기 위해 인코딩해야 한다.</p>
      <emu-note>
        <p>예약 문자 집합은 RFC 2396 에 기반하며 최신 RFC 3986 의 변경을 반영하지 않는다.</p>
      </emu-note>
      <emu-note>
        <p>많은 ECMAScript 구현은 웹 페이지를 조작하는 추가 함수·메서드를 제공하는데, 이는 표준 범위를 벗어난다.</p>
      </emu-note>

      <emu-clause id="sec-decodeuri-encodeduri">
        <h1>decodeURI ( _encodedURI_ )</h1>
        <p>이 함수는 `encodeURI` 가 도입할 수 있는 종류의 각 escape 시퀀스 및 UTF-8 인코딩을 해당 코드 포인트의 UTF-16 인코딩으로 치환한 URI 새 버전을 계산한다. `encodeURI` 가 도입할 수 없었던 escape 시퀀스는 치환하지 않는다.</p>
        <p><dfn>%decodeURI%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _uriString_ = ? ToString(_encodedURI_).
          1. _preserveEscapeSet_ = *";/?:@&=+$,#"*.
          1. Return ? Decode(_uriString_, _preserveEscapeSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodeuricomponent-encodeduricomponent">
        <h1>decodeURIComponent ( _encodedURIComponent_ )</h1>
        <p>이 함수는 `encodeURIComponent` 가 도입할 수 있는 종류의 각 escape 시퀀스 및 UTF-8 인코딩을 해당 코드 포인트의 UTF-16 인코딩으로 치환한 새 버전을 계산한다.</p>
        <p><dfn>%decodeURIComponent%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _componentString_ = ? ToString(_encodedURIComponent_).
          1. _preserveEscapeSet_ = 빈 문자열.
          1. Return ? Decode(_componentString_, _preserveEscapeSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuri-uri">
        <h1>encodeURI ( _uri_ )</h1>
        <p>이 함수는 UTF-16 인코딩(<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) 된 URI 에서 특정 코드 포인트의 각 출현을 그 코드 포인트의 UTF-8 인코딩을 나타내는 1~4개의 escape 시퀀스로 대체한 새 버전을 계산한다.</p>
        <p><dfn>%encodeURI%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _uriString_ = ? ToString(_uri_).
          1. _extraUnescaped_ = *";/?:@&=+$,#"*.
          1. Return ? Encode(_uriString_, _extraUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuricomponent-uricomponent">
        <h1>encodeURIComponent ( _uriComponent_ )</h1>
        <p>이 함수는 UTF-16 인코딩된 URI 구성 요소에서 특정 코드 포인트의 각 출현을 그 코드 포인트의 UTF-8 인코딩을 나타내는 1~4개의 escape 시퀀스로 대체한 새 버전을 계산한다.</p>
        <p><dfn>%encodeURIComponent%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _componentString_ = ? ToString(_uriComponent_).
          1. _extraUnescaped_ = 빈 문자열.
          1. Return ? Encode(_componentString_, _extraUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encode" type="abstract operation">
        <h1>
          Encode (
            _string_: String,
            _extraUnescaped_: String,
          ): String 을 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_string_ 을 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 기술된 대로 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하여 URI 인코딩·escape 를 수행한다. RFC 2396 에서 unreserved 로 식별되었거나 _extraUnescaped_ 에 등장하는 문자는 escape 하지 않는다.</dd>
        </dl>
        <emu-alg>
          1. _len_ = _string_ 길이.
          1. _R_ = 빈 문자열.
          1. _alwaysUnescaped_ = ASCII 단어 문자들과 *"-.!~\*'()"* 의 문자열 연결.
          1. _unescapedSet_ = _alwaysUnescaped_ + _extraUnescaped_.
          1. _k_ = 0.
          1. 반복 (_k_ &lt; _len_)
            1. _C_ = _string_[_k_] 코드 유닛.
            1. _unescapedSet_ 이 _C_ 포함하면
              1. _k_ = _k_ + 1.
              1. _R_ = _R_ + _C_.
            1. Else
              1. _cp_ = CodePointAt(_string_, _k_).
              1. _cp_.[[IsUnpairedSurrogate]] *true* 이면 *URIError* throw.
              1. _k_ = _k_ + _cp_.[[CodeUnitCount]].
              1. _Octets_ = _cp_.[[CodePoint]] 에 UTF-8 변환 적용한 octet 리스트.
              1. 각 _octet_ ∈ _Octets_ 에 대해
                1. _hex_ = _octet_ 의 대문자 16진 문자열.
                1. _R_ = _R_ + *"%"* + StringPad(_hex_, 2, *"0"*, ~start~).
          1. _R_ 반환.
        </emu-alg>
        <emu-note>
          <p>퍼센트 인코딩은 개별 octet 을 표현하므로 하나의 코드 포인트가 여러 연속 escape 시퀀스(각각 하나의 8비트 UTF-8 코드 유닛)에 의해 표현될 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-decode" type="abstract operation">
        <h1>
          Decode (
            _string_: String,
            _preserveEscapeSet_: String,
          ): String 을 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_preserveEscapeSet_ 에 포함된 Basic Latin 문자에 대응하는 escape 시퀀스를 보존하면서 URI unescape 및 디코딩을 수행한다.</dd>
        </dl>
        <emu-alg>
          1. _len_ = _string_ 길이.
          1. _R_ = 빈 문자열.
          1. _k_ = 0.
          1. 반복 (_k_ &lt; _len_)
            1. _C_ = _string_[_k_] 코드 유닛.
            1. _S_ = _C_.
            1. _C_ = 0x0025 ( %) 이면
              1. _k_ + 3 > _len_ 이면 *URIError* throw.
              1. _escape_ = _string_[_k_ .. _k_+3).
              1. _B_ = ParseHexOctet(_string_, _k_ + 1).
              1. _B_ 가 정수가 아니면 *URIError* throw.
              1. _k_ = _k_ + 2.
              1. _n_ = _B_ 의 선행 1 비트 개수.
              1. _n_ = 0 이면
                1. _asciiChar_ = 값이 _B_ 인 코드 유닛.
                1. _preserveEscapeSet_ 이 _asciiChar_ 포함하면 _S_ = _escape_, 아니면 _S_ = _asciiChar_.
              1. Else
                1. _n_ = 1 또는 _n_ > 4 이면 *URIError* throw.
                1. _Octets_ = « _B_ ».
                1. _j_ = 1.
                1. 반복 (_j_ &lt; _n_)
                  1. _k_ = _k_ + 1.
                  1. _k_ + 3 > _len_ 이면 *URIError* throw.
                  1. _string_[_k_] ≠ 0x0025 이면 *URIError* throw.
                  1. _continuationByte_ = ParseHexOctet(_string_, _k_ + 1).
                  1. _continuationByte_ 가 정수가 아니면 *URIError* throw.
                  1. _Octets_ 에 append(_continuationByte_).
                  1. _k_ = _k_ + 2.
                  1. _j_ = _j_ + 1.
                1. 단언: |Octets| 길이 = _n_.
                1. _Octets_ 가 유효한 UTF-8 코드 포인트 인코딩이 아니면 *URIError* throw.
                1. _V_ = UTF-8 변환을 적용해 얻은 코드 포인트.
                1. _S_ = UTF16EncodeCodePoint(_V_).
            1. _R_ = _R_ + _S_.
            1. _k_ = _k_ + 1.
          1. _R_ 반환.
        </emu-alg>
        <emu-note>
          <p>RFC 3629 는 잘못된 UTF-8 옥텟 시퀀스 디코딩을 금지한다. 예: 잘못된 시퀀스 0xC0 0x80 은 0x0000 으로 디코딩되어서는 안 된다. 구현은 그러한 시퀀스를 만나면 *URIError* 를 던져야 한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-parsehexoctet" type="abstract operation">
        <h1>
          ParseHexOctet (
            _string_: String,
            _position_: 음이 아닌 정수,
          ): 음이 아닌 정수 또는 비어있지 않은 *SyntaxError* 객체 리스트
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_string_ 의 _position_ 위치에 있는 두 개 16진 문자를 부호 없는 8비트 정수로 파싱한다.</dd>
        </dl>
        <emu-alg>
          1. _len_ = _string_ 길이.
          1. 단언: _position_ + 2 ≤ _len_.
          1. _hexDigits_ = _string_[_position_ .. _position_+2).
          1. _parseResult_ = ParseText(_hexDigits_, |HexDigits[~Sep]|).
          1. _parseResult_ 가 Parse Node 가 아니면 _parseResult_ 반환.
          1. _n_ = _parseResult_ 의 MV.
          1. 단언: 0 ≤ _n_ ≤ 255.
          1. _n_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>전역 객체의 생성자(Constructor) 프로퍼티</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-aggregate-error">
      <h1>AggregateError ( . . . )</h1>
      <p><emu-xref href="#sec-aggregate-error-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-array">
      <h1>Array ( . . . )</h1>
      <p><emu-xref href="#sec-array-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-arraybuffer">
      <h1>ArrayBuffer ( . . . )</h1>
      <p><emu-xref href="#sec-arraybuffer-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint">
      <h1>BigInt ( . . . )</h1>
      <p><emu-xref href="#sec-bigint-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint64array">
      <h1>BigInt64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-biguint64array">
      <h1>BigUint64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-boolean">
      <h1>Boolean ( . . . )</h1>
      <p><emu-xref href="#sec-boolean-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-dataview">
      <h1>DataView ( . . . )</h1>
      <p><emu-xref href="#sec-dataview-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-date">
      <h1>Date ( . . . )</h1>
      <p><emu-xref href="#sec-date-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-error">
      <h1>Error ( . . . )</h1>
      <p><emu-xref href="#sec-error-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-evalerror">
      <h1>EvalError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-finalization-registry" oldids="sec-constructor-properties-of-the-global-object-finnalization-registry">
      <h1>FinalizationRegistry ( . . . )</h1>
      <p><emu-xref href="#sec-finalization-registry-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-float16array">
      <h1>Float16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-float32array">
      <h1>Float32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-float64array">
      <h1>Float64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-function">
      <h1>Function ( . . . )</h1>
      <p><emu-xref href="#sec-function-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-int8array">
      <h1>Int8Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-int16array">
      <h1>Int16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-int32array">
      <h1>Int32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-iterator">
      <h1>Iterator ( . . . )</h1>
      <p><emu-xref href="#sec-iterator-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-map">
      <h1>Map ( . . . )</h1>
      <p><emu-xref href="#sec-map-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-number">
      <h1>Number ( . . . )</h1>
      <p><emu-xref href="#sec-number-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-object">
      <h1>Object ( . . . )</h1>
      <p><emu-xref href="#sec-object-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-promise">
      <h1>Promise ( . . . )</h1>
      <p><emu-xref href="#sec-promise-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-proxy">
      <h1>Proxy ( . . . )</h1>
      <p><emu-xref href="#sec-proxy-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-rangeerror">
      <h1>RangeError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-referenceerror">
      <h1>ReferenceError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-regexp">
      <h1>RegExp ( . . . )</h1>
      <p><emu-xref href="#sec-regexp-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-set">
      <h1>Set ( . . . )</h1>
      <p><emu-xref href="#sec-set-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-sharedarraybuffer">
      <h1>SharedArrayBuffer ( . . . )</h1>
      <p><emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-string">
      <h1>String ( . . . )</h1>
      <p><emu-xref href="#sec-string-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-symbol">
      <h1>Symbol ( . . . )</h1>
      <p><emu-xref href="#sec-symbol-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-syntaxerror">
      <h1>SyntaxError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-typeerror">
      <h1>TypeError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-uint8array">
      <h1>Uint8Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint8clampedarray">
      <h1>Uint8ClampedArray ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint16array">
      <h1>Uint16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint32array">
      <h1>Uint32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-urierror">
      <h1>URIError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakmap">
      <h1>WeakMap ( . . . )</h1>
      <p><emu-xref href="#sec-weakmap-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakref">
      <h1>WeakRef ( . . . )</h1>
      <p><emu-xref href="#sec-weak-ref-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakset">
      <h1>WeakSet ( . . . )</h1>
      <p><emu-xref href="#sec-weakset-objects"></emu-xref> 참조.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-other-properties-of-the-global-object">
    <h1>전역 객체의 기타 프로퍼티</h1>

    <emu-clause id="sec-atomics">
      <h1>Atomics</h1>
      <p><emu-xref href="#sec-atomics-object"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-json">
      <h1>JSON</h1>
      <p><emu-xref href="#sec-json-object"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-math">
      <h1>Math</h1>
      <p><emu-xref href="#sec-math-object"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-reflect">
      <h1>Reflect</h1>
      <p><emu-xref href="#sec-reflect-object"></emu-xref> 참조.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>기본 객체 (Fundamental Objects)</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object 객체</h1>

    <emu-clause id="sec-object-constructor">
      <h1>Object 생성자</h1>
      <p>Object 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Object%</dfn> 이다.</li>
        <li>전역 객체 *"Object"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 일반(ordinary) 객체를 생성한다.</li>
        <li>생성자가 아니라 함수로 호출될 때 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다.</li>
      </ul>

      <emu-clause id="sec-object-value">
        <h1>Object ( [ _value_ ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 도 아니고 활성 함수 객체도 아니면
            1. ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*) 를 반환한다.
          1. _value_ 가 *undefined* 또는 *null* 이면 OrdinaryObjectCreate(%Object.prototype%) 를 반환한다.
          1. ! ToObject(_value_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Object 생성자의 프로퍼티</h1>
      <p>Object 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 갖는다.</li>
        <li>값이 *1*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 갖는다.</li>
        <li>다음 추가 프로퍼티들을 갖는다:</li>
      </ul>

      <emu-clause id="sec-object.assign">
        <h1>Object.assign ( _target_, ..._sources_ )</h1>
        <p>이 함수는 하나 이상의 소스 객체의 열거 가능하고 자체(own)인 모든 프로퍼티 값을 _target_ 객체로 복사한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _to_ 를 ? ToObject(_target_) 로 둔다.
          1. 인수가 하나만 전달되었다면 _to_ 를 반환한다.
          1. _sources_ 의 각 요소 _nextSource_ 에 대해
            1. _nextSource_ 가 *undefined* 도 *null* 도 아니면
              1. _from_ 을 ! ToObject(_nextSource_) 로 둔다.
              1. _keys_ 를 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
              1. _keys_ 의 각 요소 _nextKey_ 에 대해
                1. _desc_ 를 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_) 로 둔다.
                1. _desc_ 가 *undefined* 가 아니고 _desc_.[[Enumerable]] 가 *true* 이면
                  1. _propValue_ 를 ? Get(_from_, _nextKey_) 로 둔다.
                  1. ? Set(_to_, _nextKey_, _propValue_, *true*) 를 수행한다.
          1. _to_ 를 반환한다.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-object.create">
        <h1>Object.create ( _O_, _Properties_ )</h1>
        <p>이 함수는 지정된 프로토타입을 가진 새 객체를 생성한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니고 *null* 도 아니면 *TypeError* 예외를 throw 한다.
          1. _obj_ 를 OrdinaryObjectCreate(_O_) 로 둔다.
          1. _Properties_ 가 *undefined* 가 아니면
            1. ? ObjectDefineProperties(_obj_, _Properties_) 를 반환한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.defineproperties">
        <h1>Object.defineProperties ( _O_, _Properties_ )</h1>
        <p>이 함수는 객체에 자체 프로퍼티를 추가하고/또는 기존 자체 프로퍼티의 특성을 갱신한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *TypeError* 예외를 throw 한다.
          1. ? ObjectDefineProperties(_O_, _Properties_) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-objectdefineproperties" type="abstract operation">
          <h1>
            ObjectDefineProperties (
              _O_: Object,
              _Properties_: ECMAScript 언어 값,
            ): Object 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _props_ 를 ? ToObject(_Properties_) 로 둔다.
            1. _keys_ 를 ? <emu-meta effects="user-code">_props_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
            1. _descriptors_ 를 새 빈 리스트로 둔다.
            1. _keys_ 의 각 요소 _nextKey_ 에 대해
              1. _propDesc_ 를 ? <emu-meta effects="user-code">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_) 로 둔다.
              1. _propDesc_ 가 *undefined* 가 아니고 _propDesc_.[[Enumerable]] 가 *true* 이면
                1. _descObj_ 를 ? Get(_props_, _nextKey_) 로 둔다.
                1. _desc_ 를 ? ToPropertyDescriptor(_descObj_) 로 둔다.
                1. Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } 를 _descriptors_ 에 추가한다.
            1. _descriptors_ 의 각 요소 _property_ 에 대해
              1. ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]) 를 수행한다.
            1. _O_ 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.defineproperty">
        <h1>Object.defineProperty ( _O_, _P_, _Attributes_ )</h1>
        <p>이 함수는 객체에 자체 프로퍼티를 추가하고/또는 기존 자체 프로퍼티의 특성을 갱신한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *TypeError* 예외를 throw 한다.
          1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
          1. _desc_ 를 ? ToPropertyDescriptor(_Attributes_) 로 둔다.
          1. ? DefinePropertyOrThrow(_O_, _key_, _desc_) 를 수행한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.entries">
        <h1>Object.entries ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _entryList_ 를 ? EnumerableOwnProperties(_obj_, ~key+value~) 로 둔다.
          1. CreateArrayFromList(_entryList_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.freeze">
        <h1>Object.freeze ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? SetIntegrityLevel(_O_, ~frozen~) 으로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.fromentries" oldids="sec-create-data-property-on-object-functions">
        <h1>Object.fromEntries ( _iterable_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_iterable_) 를 수행한다.
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. 단언: _obj_ 는 확장 가능하고 자체 프로퍼티가 없는 ordinary 객체.
          1. _closure_ 를 (_key_, _value_) 매개변수로 하고 _obj_ 를 캡처하며 호출 시 다음 단계를 수행하는 새 Abstract Closure 로 둔다:
            1. _propertyKey_ 를 ? ToPropertyKey(_key_) 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_) 를 수행한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _adder_ 를 CreateBuiltinFunction(_closure_, 2, *""*, « ») 로 둔다.
          1. ? AddEntriesFromIterable(_obj_, _iterable_, _adder_) 를 반환한다.
        </emu-alg>
        <emu-note>
          _adder_ 용으로 생성된 함수는 ECMAScript 코드에서 직접 접근할 수 없다.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptor">
        <h1>Object.getOwnPropertyDescriptor ( _O_, _P_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
          1. _desc_ 를 ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
          1. FromPropertyDescriptor(_desc_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptors">
        <h1>Object.getOwnPropertyDescriptors ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _ownKeys_ 를 ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
          1. _descriptors_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. _ownKeys_ 의 각 요소 _key_ 에 대해
            1. _desc_ 를 ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
            1. _descriptor_ 를 FromPropertyDescriptor(_desc_) 로 둔다.
            1. _descriptor_ 가 *undefined* 가 아니면 ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_) 를 수행한다.
          1. _descriptors_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertynames">
        <h1>Object.getOwnPropertyNames ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertysymbols">
        <h1>Object.getOwnPropertySymbols ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-getownpropertykeys" type="abstract operation">
          <h1>
            GetOwnPropertyKeys (
              _O_: ECMAScript 언어 값,
              _type_: ~string~ 또는 ~symbol~,
            ): 프로퍼티 키 리스트를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _obj_ 를 ? ToObject(_O_) 로 둔다.
            1. _keys_ 를 ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
            1. _nameList_ 를 새 빈 리스트로 둔다.
            1. _keys_ 의 각 요소 _nextKey_ 에 대해
              1. _nextKey_ 가 Symbol 이고 _type_ 이 ~symbol~ 이거나, _nextKey_ 가 String 이고 _type_ 이 ~string~ 이면
                1. _nextKey_ 를 _nameList_ 에 추가한다.
            1. _nameList_ 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getprototypeof">
        <h1>Object.getPrototypeOf ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. ? <emu-meta effects="user-code">_obj_.[[GetPrototypeOf]]()</emu-meta> 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.groupby">
        <h1>Object.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ 은 두 개의 인수를 받는 함수여야 한다. `groupBy` 는 _items_ 의 각 요소에 대해 (오름차순으로) _callback_ 을 한 번 호출하고 새 객체를 구성한다. _callback_ 이 반환한 각 값은 프로퍼티 키로 강제 변환된다. 그러한 각 프로퍼티 키에 대해 결과 객체는 그 키를 프로퍼티 키로 가지며 값은 해당 키로 강제 변환된 _callback_ 반환 값을 가진 모든 요소를 담은 배열이다.</p>
          <p>_callback_ 은 (요소의 값, 요소의 인덱스) 두 인수로 호출된다.</p>
          <p>`groupBy` 의 반환 값은 %Object.prototype% 을 상속하지 않는 객체이다.</p>
        </emu-note>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _groups_ 를 ? GroupBy(_items_, _callback_, ~property~) 로 둔다.
          1. _obj_ 를 OrdinaryObjectCreate(*null*) 로 둔다.
          1. 각 Record { [[Key]], [[Elements]] } _g_ ∈ _groups_ 에 대해
            1. _elements_ 를 CreateArrayFromList(_g_.[[Elements]]) 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_) 를 수행한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.hasown">
        <h1>Object.hasOwn ( _O_, _P_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
          1. ? HasOwnProperty(_obj_, _key_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.is">
        <h1>Object.is ( _value1_, _value2_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. SameValue(_value1_, _value2_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isextensible">
        <h1>Object.isExtensible ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *false* 를 반환한다.
          1. ? IsExtensible(_O_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isfrozen">
        <h1>Object.isFrozen ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *true* 를 반환한다.
          1. ? TestIntegrityLevel(_O_, ~frozen~) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.issealed">
        <h1>Object.isSealed ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *true* 를 반환한다.
          1. ? TestIntegrityLevel(_O_, ~sealed~) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.keys">
        <h1>Object.keys ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _keyList_ 를 ? EnumerableOwnProperties(_obj_, ~key~) 로 둔다.
          1. CreateArrayFromList(_keyList_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.preventextensions">
        <h1>Object.preventExtensions ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? <emu-meta effects="user-code">_O_.[[PreventExtensions]]()</emu-meta> 로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype">
        <h1>Object.prototype</h1>
        <p>`Object.prototype` 의 초기 값은 Object 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-object.seal">
        <h1>Object.seal ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? SetIntegrityLevel(_O_, ~sealed~) 로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.setprototypeof">
        <h1>Object.setPrototypeOf ( _O_, _proto_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_O_) 를 수행한다.
          1. _proto_ 가 Object 가 아니고 *null* 도 아니면 *TypeError* 예외를 throw 한다.
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_) 로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.values">
        <h1>Object.values ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _valueList_ 를 ? EnumerableOwnProperties(_obj_, ~value~) 로 둔다.
          1. CreateArrayFromList(_valueList_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-prototype-object" oldids="sec-additional-properties-of-the-object.prototype-object">
      <h1>Object 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Object 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Object.prototype%</dfn> 이다.</li>
        <li>값이 *true* 인 [[Extensible]] 내부 슬롯을 가진다.</li>
        <li>일반 객체에 대해 정의된 내부 메서드를 갖되 [[SetPrototypeOf]] 메서드는 <emu-xref href="#sec-immutable-prototype-exotic-objects-setprototypeof-v"></emu-xref> 에 정의된 대로이다. (즉, 변경 불가능한 프로토타입 특수 객체이다.)</li>
        <li>값이 *null* 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-object.prototype.constructor">
        <h1>Object.prototype.constructor</h1>
        <p>`Object.prototype.constructor` 의 초기 값은 %Object% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-object.prototype.hasownproperty">
        <h1>Object.prototype.hasOwnProperty ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. [id="step-hasownproperty-topropertykey"] _P_ 를 ? ToPropertyKey(_V_) 로 둔다.
          1. [id="step-hasownproperty-toobject"] _O_ 를 ? ToObject(*this* value) 로 둔다.
          1. ? HasOwnProperty(_O_, _P_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이전 판에서 step <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> 가 던졌을 예외가 *this* 값이 *undefined* 또는 *null* 이어도 계속 던져지도록 step 순서를 선택하였다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.isprototypeof">
        <h1>Object.prototype.isPrototypeOf ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. [id="step-isprototypeof-check-object"] _V_ 가 Object 가 아니면 *false* 반환.
          1. [id="step-isprototypeof-toobject"] _O_ 를 ? ToObject(*this* value) 로 둔다.
          1. 반복,
            1. _V_ 를 ? <emu-meta effects="user-code">_V_.[[GetPrototypeOf]]()</emu-meta> 로 둔다.
            1. _V_ 가 *null* 이면 *false* 반환.
            1. SameValue(_O_, _V_) 가 *true* 이면 *true* 반환.
        </emu-alg>
        <emu-note>
          <p>step <emu-xref href="#step-isprototypeof-check-object"></emu-xref> 와 <emu-xref href="#step-isprototypeof-toobject"></emu-xref> 순서는 _V_ 가 객체가 아니고 *this* 값이 *undefined* 또는 *null* 인 경우 이전 판 행동을 보존한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.propertyisenumerable">
        <h1>Object.prototype.propertyIsEnumerable ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. [id="step-propertyisenumerable-topropertykey"] _P_ 를 ? ToPropertyKey(_V_) 로 둔다.
          1. [id="step-propertyisenumerable-toobject"] _O_ 를 ? ToObject(*this* value) 로 둔다.
          1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면 *false* 반환.
          1. _desc_.[[Enumerable]] 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 프로토타입 체인 상의 객체를 고려하지 않는다.</p>
        </emu-note>
        <emu-note>
          <p>이전 판에서 step <emu-xref href="#step-propertyisenumerable-topropertykey"></emu-xref> 가 던졌을 예외가 *this* 값이 *undefined* 또는 *null* 이어도 계속 던져지도록 순서를 선택하였다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tolocalestring">
        <h1>Object.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. ? Invoke(_O_, *"toString"*) 를 반환한다.
        </emu-alg>
        <p>이 메서드의 선택적 매개변수들은 사용되지 않지만 ECMA-402 `toLocaleString` 메서드의 매개변수 패턴과 대응하도록 의도되었다. ECMA-402 지원이 없는 구현은 그 매개변수 위치를 다른 목적으로 사용해서는 안 된다.</p>
        <emu-note>
          <p>이 메서드는 locale 에 민감한 `toString` 동작이 없는 객체를 위한 일반 `toLocaleString` 구현을 제공한다. `Array`, `Number`, `Date`, %TypedArray% 는 자체 locale 의존 `toLocaleString` 을 제공한다.</p>
        </emu-note>
        <emu-note>
          <p>ECMA-402 는 의도적으로 이 기본 구현의 대안을 제공하지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tostring">
        <h1>Object.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *this* 값이 *undefined* 이면 *"[object Undefined]"* 를 반환한다.
          1. *this* 값이 *null* 이면 *"[object Null]"* 를 반환한다.
          1. _O_ 를 ! ToObject(*this* value) 로 둔다.
          1. _isArray_ 를 ? IsArray(_O_) 로 둔다.
          1. _isArray_ 가 *true* 이면 _builtinTag_ = *"Array"*.
          1. Else _O_ 가 [[ParameterMap]] 내부 슬롯을 가지면 _builtinTag_ = *"Arguments"*.
          1. Else _O_ 가 [[Call]] 내부 메서드를 가지면 _builtinTag_ = *"Function"*.
          1. Else _O_ 가 [[ErrorData]] 내부 슬롯을 가지면 _builtinTag_ = *"Error"*.
          1. Else _O_ 가 [[BooleanData]] 내부 슬롯을 가지면 _builtinTag_ = *"Boolean"*.
          1. Else _O_ 가 [[NumberData]] 내부 슬롯을 가지면 _builtinTag_ = *"Number"*.
          1. Else _O_ 가 [[StringData]] 내부 슬롯을 가지면 _builtinTag_ = *"String"*.
          1. Else _O_ 가 [[DateValue]] 내부 슬롯을 가지면 _builtinTag_ = *"Date"*.
          1. Else _O_ 가 [[RegExpMatcher]] 내부 슬롯을 가지면 _builtinTag_ = *"RegExp"*.
          1. Else _builtinTag_ = *"Object"*.
          1. _tag_ 를 ? Get(_O_, %Symbol.toStringTag%) 로 둔다.
          1. _tag_ 가 String 이 아니면 _tag_ = _builtinTag_.
          1. *"[object "*, _tag_, *"]"* 의 문자열 연결을 반환한다.
        </emu-alg>
        <emu-note>
          <p>과거 이 메서드는 이전 판에서 다양한 내장 객체의 공칭 타입 태그로 사용된 [[Class]] 내부 슬롯의 String 값을 얻기 위해 사용되기도 했다. 위 정의는 그러한 특정 종류의 내장 객체를 테스트하기 위해 `toString` 을 사용하는 레거시 코드와의 호환성을 유지한다. 이는 다른 종류의 내장 혹은 프로그램 정의 객체에 대해 신뢰할 수 있는 타입 테스트 메커니즘을 제공하지 않는다. 또한 프로그램은 %Symbol.toStringTag% 를 이용하여 이러한 레거시 타입 테스트의 신뢰성을 깨뜨릴 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.valueof">
        <h1>Object.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ToObject(*this* value) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype.__proto__" legacy normative-optional>
        <h1>Object.prototype.__proto__</h1>
        <p>`Object.prototype.__proto__` 는 특성 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 를 가진 접근자 프로퍼티이다. [[Get]] 과 [[Set]] 특성은 다음과 같이 정의된다:</p>

        <emu-clause id="sec-get-object.prototype.__proto__">
          <h1>get Object.prototype.__proto__</h1>
          <p>[[Get]] 특성의 값은 인수를 요구하지 않는 내장 함수이다. 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-object.prototype.__proto__">
          <h1>set Object.prototype.__proto__</h1>
          <p>[[Set]] 특성의 값은 인수 _proto_ 를 받는 내장 함수이다. 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. ? RequireObjectCoercible(_O_) 를 수행한다.
            1. _proto_ 가 Object 가 아니고 *null* 도 아니면 *undefined* 를 반환한다.
            1. _O_ 가 Object 가 아니면 *undefined* 를 반환한다.
            1. _status_ 를 ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_) 로 둔다.
            1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.prototype-legacy-accessor-methods" legacy normative-optional>
        <h1>레거시 Object.prototype 접근자 메서드</h1>

        <emu-clause id="sec-object.prototype.__defineGetter__">
          <h1>Object.prototype.__defineGetter__ ( _P_, _getter_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. IsCallable(_getter_) 가 *false* 이면 *TypeError* 예외를 throw 한다.
            1. _desc_ 를 PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* } 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. ? DefinePropertyOrThrow(_O_, _key_, _desc_) 를 수행한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__defineSetter__">
          <h1>Object.prototype.__defineSetter__ ( _P_, _setter_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. IsCallable(_setter_) 가 *false* 이면 *TypeError* 예외를 throw 한다.
            1. _desc_ 를 PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* } 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. ? DefinePropertyOrThrow(_O_, _key_, _desc_) 를 수행한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupGetter__">
          <h1>Object.prototype.__lookupGetter__ ( _P_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. 반복,
              1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
              1. _desc_ 가 *undefined* 가 아니면
                1. IsAccessorDescriptor(_desc_) 가 *true* 이면 _desc_.[[Get]] 를 반환한다.
                1. *undefined* 를 반환한다.
              1. _O_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> 로 둔다.
              1. _O_ 가 *null* 이면 *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupSetter__">
          <h1>Object.prototype.__lookupSetter__ ( _P_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. 반복,
              1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
              1. _desc_ 가 *undefined* 가 아니면
                1. IsAccessorDescriptor(_desc_) 가 *true* 이면 _desc_.[[Set]] 를 반환한다.
                1. *undefined* 를 반환한다.
              1. _O_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> 로 둔다.
              1. _O_ 가 *null* 이면 *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-object-instances">
      <h1>Object 인스턴스의 프로퍼티</h1>
      <p>Object 인스턴스는 Object 프로토타입 객체로부터 상속된 것 외의 특별한 프로퍼티를 가지지 않는다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function 객체</h1>

    <emu-clause id="sec-function-constructor">
      <h1>Function 생성자</h1>
      <p>Function 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Function%</dfn> 이다.</li>
        <li>전역 객체 *"Function"* 프로퍼티의 초기 값이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 함수 객체를 생성·초기화한다. 따라서 `Function(…)` 호출은 동일 인수를 가진 `new Function(…)` 표현식과 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 특정 Function 동작을 상속하려는 서브클래스 생성자는 내장 함수 동작에 필요한 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 Function 생성자에 `super` 호출을 포함해야 한다. 함수 객체를 정의하는 모든 ECMAScript 구문 형태는 Function 인스턴스를 생성한다. built-in GeneratorFunction, AsyncFunction, AsyncGeneratorFunction 서브클래스를 제외하고 Function 서브클래스 인스턴스를 만들 문법적 수단은 없다.</li>
      </ul>

      <emu-clause id="sec-function-p1-p2-pn-body">
        <h1>Function ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>마지막 인수(있다면)는 함수 본문(실행 코드)을 지정하며 그 앞의 인수들은 형식 매개변수를 지정한다.</p>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 활성 함수 객체로 둔다.
          1. _bodyArg_ 가 존재하지 않으면 빈 문자열로 설정한다.
          1. ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>각 형식 매개변수마다 하나의 인수를 두는 것은 허용되지만 필수는 아니다. 예를 들어 다음 세 표현식은 모두 동일 결과를 생성한다:</p>
          <pre><code class="javascript">
            new Function("a", "b", "c", "return a+b+c")
            new Function("a, b, c", "return a+b+c")
            new Function("a,b", "c", "return a+b+c")
          </code></pre>
        </emu-note>

        <emu-clause id="sec-createdynamicfunction" type="abstract operation" oldids="table-dynamic-function-sourcetext-prefixes">
          <h1>
            CreateDynamicFunction (
              _constructor_: 생성자,
              _newTarget_: 생성자 또는 *undefined*,
              _kind_: ~normal~, ~generator~, ~async~, 또는 ~async-generator~,
              _parameterArgs_: ECMAScript 언어 값 리스트,
              _bodyArg_: ECMAScript 언어 값,
            ): ECMAScript 함수 객체를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_constructor_ 는 이 동작을 수행 중인 생성자 함수. _newTarget_ 은 처음에 `new` 가 적용된 생성자. _parameterArgs_ 와 _bodyArg_ 는 _constructor_ 에 전달된 인수 값.</dd>
          </dl>
          <emu-alg>
            1. _newTarget_ 이 *undefined* 이면 _newTarget_ = _constructor_.
            1. _kind_ 가 ~normal~ 이면
              1. _prefix_ = *"function"*.
              1. _exprSym_ = |FunctionExpression|.
              1. _bodySym_ = |FunctionBody[~Yield, ~Await]|.
              1. _parameterSym_ = |FormalParameters[~Yield, ~Await]|.
              1. _fallbackProto_ = *"%Function.prototype%"*.
            1. Else if _kind_ = ~generator~ 이면
              1. _prefix_ = *"function\*"*.
              1. _exprSym_ = |GeneratorExpression|.
              1. _bodySym_ = |GeneratorBody|.
              1. _parameterSym_ = |FormalParameters[+Yield, ~Await]|.
              1. _fallbackProto_ = *"%GeneratorFunction.prototype%"*.
            1. Else if _kind_ = ~async~ 이면
              1. _prefix_ = *"async function"*.
              1. _exprSym_ = |AsyncFunctionExpression|.
              1. _bodySym_ = |AsyncFunctionBody|.
              1. _parameterSym_ = |FormalParameters[~Yield, +Await]|.
              1. _fallbackProto_ = *"%AsyncFunction.prototype%"*.
            1. Else
              1. 단언: _kind_ = ~async-generator~.
              1. _prefix_ = *"async function\*"*.
              1. _exprSym_ = |AsyncGeneratorExpression|.
              1. _bodySym_ = |AsyncGeneratorBody|.
              1. _parameterSym_ = |FormalParameters[+Yield, +Await]|.
              1. _fallbackProto_ = *"%AsyncGeneratorFunction.prototype%"*.
            1. _argCount_ = _parameterArgs_ 요소 수.
            1. _parameterStrings_ 를 새 빈 리스트로 둔다.
            1. _parameterArgs_ 의 각 요소 _arg_ 에 대해
              1. ? ToString(_arg_) 를 _parameterStrings_ 에 추가한다.
            1. _bodyString_ = ? ToString(_bodyArg_).
            1. _currentRealm_ = 현재 Realm Record.
            1. ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*) 수행.
            1. _P_ = 빈 문자열.
            1. _argCount_ > 0 이면
              1. _P_ = _parameterStrings_[0].
              1. _k_ = 1.
              1. 반복 (_k_ &lt; _argCount_)
                1. _nextArgString_ = _parameterStrings_[_k_].
                1. _P_ = _P_ + *","* + _nextArgString_.
                1. _k_ = _k_ + 1.
            1. _bodyParseString_ = 0x000A, _bodyString_, 0x000A 의 문자열 연결.
            1. _sourceString_ = _prefix_, *" anonymous("*, _P_, 0x000A, *") {"*, _bodyParseString_, *"}"* 의 문자열 연결.
            1. _sourceText_ = StringToCodePoints(_sourceString_).
            1. _parameters_ = ParseText(_P_, _parameterSym_).
            1. _parameters_ 가 오류 리스트이면 *SyntaxError* throw.
            1. _body_ = ParseText(_bodyParseString_, _bodySym_).
            1. _body_ 가 오류 리스트이면 *SyntaxError* throw.
            1. NOTE: 매개변수와 본문을 개별적으로 파싱하여 각각 단독으로 유효함을 보장.
            1. NOTE: 이 단계에 도달했다면 _sourceText_ 는 _exprSym_ 문법을 가져야 한다.
            1. _expr_ = ParseText(_sourceText_, _exprSym_).
            1. _expr_ 이 오류 리스트이면 *SyntaxError* throw.
            1. _proto_ = ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).
            1. _env_ = _currentRealm_.[[GlobalEnv]].
            1. _privateEnv_ = *null*.
            1. _F_ = OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_).
            1. SetFunctionName(_F_, *"anonymous"*).
            1. _kind_ = ~generator~ 이면
              1. _prototype_ = OrdinaryObjectCreate(%GeneratorPrototype%).
              1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ = ~async-generator~ 이면
              1. _prototype_ = OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
              1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ = ~normal~ 이면
              1. MakeConstructor(_F_) 수행.
            1. NOTE: _kind_ 이 ~async~ 인 함수는 constructable 하지 않다.
            1. _F_ 를 반환한다.
          </emu-alg>
          <emu-note>
            <p>CreateDynamicFunction 은 _kind_ 가 ~async~ 가 아닌 함수에 대해 생성자를 위해 사용할 가능성을 제공하기 위해 *"prototype"* 프로퍼티를 정의한다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Function 생성자의 프로퍼티</h1>
      <p>Function 생성자는:</p>
      <ul>
        <li>자체가 내장 함수 객체이다.</li>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li oldids="sec-function.length">값이 *1*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-function.prototype">
        <h1>Function.prototype</h1>
        <p>`Function.prototype` 의 값은 Function 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Function 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Function 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Function.prototype%</dfn> 이다.</li>
        <li>자체가 내장 함수 객체이다.</li>
        <li>임의의 인수를 받아 호출되면 *undefined* 를 반환한다.</li>
        <li>[[Construct]] 내부 메서드를 가지지 않아 `new` 와 함께 생성자로 사용할 수 없다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>*"prototype"* 프로퍼티를 가지지 않는다.</li>
        <li>값이 *+0*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 가진다.</li>
        <li>값이 빈 문자열인 *"name"* 프로퍼티를 가진다.</li>
      </ul>
      <emu-note>
        <p>Function 프로토타입 객체를 함수 객체로 지정한 것은 ECMAScript 2015 이전 코드와의 호환성을 보장하기 위함이다.</p>
      </emu-note>

      <emu-clause id="sec-function.prototype.apply">
        <h1>Function.prototype.apply ( _thisArg_, _argArray_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _func_ 을 *this* 값으로 둔다.
          1. IsCallable(_func_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _argArray_ 가 *undefined* 또는 *null* 이면
            1. PrepareForTailCall() 수행.
            1. ? Call(_func_, _thisArg_) 반환.
          1. _argList_ 를 ? CreateListFromArrayLike(_argArray_) 로 둔다.
          1. PrepareForTailCall() 수행.
          1. [id="step-function-proto-apply-call"] ? Call(_func_, _thisArg_, _argList_) 반환.
        </emu-alg>
        <emu-note>
          <p>_thisArg_ 값은 수정 없이 *this* 값으로 전달된다. 이는 3판과의 차이로, 그때는 *undefined* 또는 *null* _thisArg_ 가 전역 객체로 대체되고 다른 값에는 ToObject 가 적용되었다. 비엄격 함수는 진입 시 여전히 이러한 변환을 수행한다.</p>
        </emu-note>
        <emu-note>
          <p>_func_ 이 화살표 함수나 bound 함수 특수 객체라면 step <emu-xref href="#step-function-proto-apply-call"></emu-xref> 의 [[Call]] 에서 _thisArg_ 는 무시된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.bind">
        <h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _Target_ 을 *this* 값으로 둔다.
          1. IsCallable(_Target_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _F_ 를 ? BoundFunctionCreate(_Target_, _thisArg_, _args_) 로 둔다.
          1. _L_ = 0.
          1. _targetHasLength_ = ? HasOwnProperty(_Target_, *"length"*).
          1. _targetHasLength_ *true* 이면
            1. _targetLen_ = ? Get(_Target_, *"length"*).
            1. _targetLen_ 이 Number 이면
              1. _targetLen_ = *+∞*<sub>𝔽</sub> 이면 _L_ = +∞.
              1. Else if _targetLen_ = *-∞*<sub>𝔽</sub> 이면 _L_ = 0.
              1. Else
                1. _targetLenAsInt_ = ! ToIntegerOrInfinity(_targetLen_).
                1. 단언: _targetLenAsInt_ 는 finite.
                1. _argCount_ = _args_ 요소 수.
                1. _L_ = max(_targetLenAsInt_ - _argCount_, 0).
          1. SetFunctionLength(_F_, _L_) 수행.
          1. _targetName_ = ? Get(_Target_, *"name"*).
          1. _targetName_ 이 String 이 아니면 빈 문자열로 설정.
          1. SetFunctionName(_F_, _targetName_, *"bound"*) 수행.
          1. _F_ 반환.
        </emu-alg>
        <emu-note>
          <p>`Function.prototype.bind` 로 생성된 함수 객체는 특수(exotic) 객체이며 *"prototype"* 프로퍼티를 가지지 않는다.</p>
        </emu-note>
        <emu-note>
          <p>_Target_ 이 화살표 함수나 bound 함수 특수 객체이면 이 메서드에 전달된 _thisArg_ 는 이후 _F_ 호출에서 사용되지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.call">
        <h1>Function.prototype.call ( _thisArg_, ..._args_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _func_ 을 *this* 값으로 둔다.
          1. IsCallable(_func_) *false* 이면 *TypeError* 예외 throw.
          1. PrepareForTailCall() 수행.
          1. [id="step-function-proto-call-call"] ? Call(_func_, _thisArg_, _args_) 반환.
        </emu-alg>
        <emu-note>
          <p>_thisArg_ 는 수정 없이 전달된다(3판과의 차이). 비엄격 함수는 진입 시 변환 수행.</p>
        </emu-note>
        <emu-note>
          <p>_func_ 이 화살표 또는 bound 함수 특수 객체이면 step <emu-xref href="#step-function-proto-call-call"></emu-xref> 의 [[Call]] 에서 _thisArg_ 는 무시된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.constructor">
        <h1>Function.prototype.constructor</h1>
        <p>`Function.prototype.constructor` 의 초기 값은 %Function%.</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype.tostring">
        <h1>Function.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _func_ 을 *this* 값으로 둔다.
          1. _func_ 이 Object 이고 [[SourceText]] 내부 슬롯을 가지며 _func_.[[SourceText]] 가 유니코드 코드 포인트 시퀀스이고 HostHasSourceTextAvailable(_func_) 이 *true* 이면
            1. CodePointsToString(_func_.[[SourceText]]) 반환.
          1. _func_ 이 <emu-xref href="#sec-built-in-function-objects">내장 함수 객체</emu-xref> 이면 구현 정의 String 소스 표현을 반환한다. 표현은 |NativeFunction| 문법을 가져야 한다. 또한 _func_ 이 [[InitialName]] 내부 슬롯을 가지고 그것이 String 이면 반환된 String 중 |NativeFunctionAccessor?| |PropertyName| 에 매치될 부분은 그 값이어야 한다.
          1. _func_ 이 Object 이고 IsCallable(_func_) *true* 이면 구현 정의 String 소스 표현을 반환하며 문법은 |NativeFunction|.
          1. *TypeError* 예외 throw.
        </emu-alg>

        <emu-grammar type="definition">
          NativeFunction :
            `function` NativeFunctionAccessor? PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`

          NativeFunctionAccessor :
            `get`
            `set`
        </emu-grammar>
      </emu-clause>

      <emu-clause oldids="sec-function.prototype-@@hasinstance" id="sec-function.prototype-%symbol.hasinstance%">
        <h1>Function.prototype [ %Symbol.hasInstance% ] ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _F_ 를 *this* 값으로 둔다.
          1. ? OrdinaryHasInstance(_F_, _V_) 를 반환한다.
        </emu-alg>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>이것은 대부분의 함수가 상속하는 기본 `%Symbol.hasInstance%` 구현이다. `%Symbol.hasInstance%` 는 `instanceof` 연산자가 값이 특정 생성자의 인스턴스인지 판정하기 위해 호출한다. 다음 표현식은</p>
          <pre><code class="javascript">
            v instanceof F
          </code></pre>
          <p>다음과 같이 평가된다</p>
          <pre><code class="javascript">
            F[%Symbol.hasInstance%](v)
          </code></pre>
          <p>생성자 함수는 함수에 다른 `%Symbol.hasInstance%` 메서드를 노출하여 어떤 객체를 자신의 인스턴스로 인식할지 제어할 수 있다.</p>
        </emu-note>
        <p>이 프로퍼티는 bound 함수의 대상 함수를 전역적으로 노출할 수 있는 변조를 막기 위해 writable / configurable 이 아니다.</p>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.hasInstance]"* 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-instances">
      <h1>Function 인스턴스</h1>
      <p>모든 Function 인스턴스는 ECMAScript 함수 객체이며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 나열된 내부 슬롯을 가진다. `Function.prototype.bind` (<emu-xref href="#sec-function.prototype.bind"></emu-xref>) 로 생성된 함수 객체는 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 에 있는 내부 슬롯을 가진다.</p>
      <p>Function 인스턴스는 다음 프로퍼티를 가진다:</p>

      <emu-clause id="sec-function-instances-length">
        <h1>length</h1>
        <p>*"length"* 프로퍼티 값은 함수가 일반적으로 기대하는 인수 수를 나타내는 정수 Number 이다. 언어는 다른 수의 인수로 호출하는 것을 허용한다. 지정된 *"length"* 와 다른 인수 수로 호출될 때의 동작은 함수에 따라 다르다. 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-name">
        <h1>name</h1>
        <p>*"name"* 프로퍼티 값은 함수를 서술하는 String 이다. 이름은 의미론적 중요성을 갖지 않고 보통 ECMAScript 소스에서 정의 지점에서 그 함수를 참조하는 변수 또는 프로퍼티 이름이다. 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        <p>명세에 의해 문맥적 이름이 연관되지 않은 익명 함수 객체는 빈 문자열을 *"name"* 값으로 사용한다.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-prototype">
        <h1>prototype</h1>
        <p>생성자로 사용할 수 있는 Function 인스턴스는 *"prototype"* 프로퍼티를 가진다. 그러한 Function 인스턴스가 생성될 때마다 또 다른 ordinary 객체가 생성되어 함수의 *"prototype"* 프로퍼티 초기 값이 된다. 달리 명시되지 않는 한 생성자로 그 함수가 호출될 때 생성되는 객체의 [[Prototype]] 내부 슬롯을 초기화하는 데 이 값이 사용된다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Function.prototype.bind` 로 생성되거나 |MethodDefinition| (|GeneratorMethod| 또는 |AsyncGeneratorMethod| 아님) 평가 또는 |ArrowFunction| 으로 생성된 함수 객체는 *"prototype"* 프로퍼티를 가지지 않는다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-hosthassourcetextavailable" type="host-defined abstract operation">
      <h1>
        HostHasSourceTextAvailable (
          _func_: 함수 객체,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>호스트 환경이 _func_ 의 소스 텍스트 제공을 차단할 수 있도록 한다.</dd>
      </dl>
      <p>HostHasSourceTextAvailable 구현은 다음 요구사항을 따른다:</p>
      <ul>
        <li>매개변수에 대해 결정적이어야 한다. 특정 _func_ 로 호출될 때마다 동일 결과를 반환해야 한다.</li>
      </ul>
      <p>기본 구현은 *true* 를 반환한다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean 객체</h1>

    <emu-clause id="sec-boolean-constructor">
      <h1>Boolean 생성자</h1>
      <p>Boolean 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Boolean%</dfn> 이다.</li>
        <li>전역 객체 *"Boolean"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 Boolean 객체를 생성·초기화한다.</li>
        <li>생성자가 아니라 함수로 호출되면 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Boolean 동작을 상속하려는 서브클래스 생성자는 [[BooleanData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 Boolean 생성자에 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-boolean-constructor-boolean-value">
        <h1>Boolean ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _b_ 를 ToBoolean(_value_) 로 둔다.
          1. NewTarget 이 *undefined* 이면 _b_ 를 반환한다.
          1. _O_ 를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Boolean.prototype%"*, « [[BooleanData]] ») 로 둔다.
          1. _O_.[[BooleanData]] = _b_ 로 설정한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Boolean 생성자의 프로퍼티</h1>
      <p>Boolean 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-boolean.prototype">
        <h1>Boolean.prototype</h1>
        <p>`Boolean.prototype` 의 초기 값은 Boolean 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Boolean 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Boolean 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Boolean.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>자체가 Boolean 객체이며 값이 *false* 인 [[BooleanData]] 내부 슬롯을 가진다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-boolean.prototype.constructor">
        <h1>Boolean.prototype.constructor</h1>
        <p>`Boolean.prototype.constructor` 의 초기 값은 %Boolean%.</p>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.tostring">
        <h1>Boolean.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _b_ 를 ? ThisBooleanValue(*this* value) 로 둔다.
          1. _b_ 가 *true* 이면 *"true"* 반환; 아니면 *"false"* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.valueof">
        <h1>Boolean.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisBooleanValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisbooleanvalue" type="abstract operation" oldids="thisbooleanvalue">
          <h1>
            ThisBooleanValue (
              _value_: ECMAScript 언어 값,
            ): Boolean 을 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 Boolean 이면 _value_ 반환.
            1. _value_ 가 Object 이고 [[BooleanData]] 내부 슬롯을 가지면
              1. _b_ 를 _value_.[[BooleanData]] 로 둔다.
              1. 단언: _b_ 는 Boolean.
              1. _b_ 반환.
            1. *TypeError* 예외 throw.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-boolean-instances">
      <h1>Boolean 인스턴스의 프로퍼티</h1>
      <p>Boolean 인스턴스는 Boolean 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. Boolean 인스턴스는 [[BooleanData]] 내부 슬롯을 가진다. [[BooleanData]] 내부 슬롯은 이 Boolean 객체가 나타내는 Boolean 값이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol 객체</h1>

    <emu-clause id="sec-symbol-constructor">
      <h1>Symbol 생성자</h1>
      <p>Symbol 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Symbol%</dfn> 이다.</li>
        <li>전역 객체 *"Symbol"* 프로퍼티의 초기 값이다.</li>
        <li>함수로 호출되면 새로운 Symbol 값을 반환한다.</li>
        <li>`new` 연산자와 함께 사용하도록 의도되지 않았다.</li>
        <li>서브클래싱을 의도하지 않는다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있으나 그에 대한 `super` 호출은 예외를 유발한다.</li>
      </ul>

      <emu-clause id="sec-symbol-description">
        <h1>Symbol ( [ _description_ ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 가 *undefined* 가 아니면 *TypeError* 예외를 throw 한다.
          1. _description_ 이 *undefined* 이면 _descString_ 을 *undefined* 로 둔다.
          1. 그렇지 않으면 _descString_ 을 ? ToString(_description_) 로 둔다.
          1. &#8288;[[Description]] 가 _descString_ 인 새 Symbol 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Symbol 생성자의 프로퍼티</h1>
      <p>Symbol 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-symbol.asynciterator">
        <h1>Symbol.asyncIterator</h1>
        <p>`Symbol.asyncIterator` 의 초기 값은 well-known symbol %Symbol.asyncIterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.for">
        <h1>Symbol.for ( _key_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. Let _stringKey_ be ? ToString(_key_).
          1. For each element _e_ of the GlobalSymbolRegistry List, do
            1. If _e_.[[Key]] is _stringKey_, return _e_.[[Symbol]].
          1. Assert: The GlobalSymbolRegistry List does not currently contain an entry for _stringKey_.
          1. Let _newSymbol_ be a new Symbol whose [[Description]] is _stringKey_.
          1. Append the GlobalSymbolRegistry Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.
          1. Return _newSymbol_.
        </emu-alg>
        <p><dfn>GlobalSymbolRegistry List</dfn> 는 전역적으로 이용 가능한 append-only 리스트이다. 모든 realm 이 공유한다. 어떤 ECMAScript 코드도 평가되기 전에 새 빈 리스트로 초기화된다. 요소는 <emu-xref href="#table-globalsymbolregistry-record-fields"></emu-xref> 에 정의된 구조의 Record 이다.</p>
        <emu-table id="table-globalsymbolregistry-record-fields" caption="GlobalSymbolRegistry Record 필드" oldids="table-44">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Usage
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                a String
              </td>
              <td>
                전역적으로 Symbol 을 식별하는 문자열 키.
              </td>
            </tr>
            <tr>
              <td>
                [[Symbol]]
              </td>
              <td>
                a Symbol
              </td>
              <td>
                어떤 realm 에서든 조회 가능한 symbol.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-symbol.hasinstance">
        <h1>Symbol.hasInstance</h1>
        <p>`Symbol.hasInstance` 의 초기 값은 well-known symbol %Symbol.hasInstance% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.isconcatspreadable">
        <h1>Symbol.isConcatSpreadable</h1>
        <p>`Symbol.isConcatSpreadable` 의 초기 값은 well-known symbol %Symbol.isConcatSpreadable% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.iterator">
        <h1>Symbol.iterator</h1>
        <p>`Symbol.iterator` 의 초기 값은 well-known symbol %Symbol.iterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.keyfor">
        <h1>Symbol.keyFor ( _sym_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _sym_ 이 Symbol 이 아니면 *TypeError* 예외 throw.
          1. KeyForSymbol(_sym_) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.match">
        <h1>Symbol.match</h1>
        <p>`Symbol.match` 의 초기 값은 well-known symbol %Symbol.match% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.matchall">
        <h1>Symbol.matchAll</h1>
        <p>`Symbol.matchAll` 의 초기 값은 well-known symbol %Symbol.matchAll% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype">
        <h1>Symbol.prototype</h1>
        <p>`Symbol.prototype` 의 초기 값은 Symbol 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.replace">
        <h1>Symbol.replace</h1>
        <p>`Symbol.replace` 의 초기 값은 well-known symbol %Symbol.replace% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.search">
        <h1>Symbol.search</h1>
        <p>`Symbol.search` 의 초기 값은 well-known symbol %Symbol.search% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.species">
        <h1>Symbol.species</h1>
        <p>`Symbol.species` 의 초기 값은 well-known symbol %Symbol.species% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.split">
        <h1>Symbol.split</h1>
        <p>`Symbol.split` 의 초기 값은 well-known symbol %Symbol.split% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.toprimitive">
        <h1>Symbol.toPrimitive</h1>
        <p>`Symbol.toPrimitive` 의 초기 값은 well-known symbol %Symbol.toPrimitive% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.tostringtag">
        <h1>Symbol.toStringTag</h1>
        <p>`Symbol.toStringTag` 의 초기 값은 well-known symbol %Symbol.toStringTag% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.unscopables">
        <h1>Symbol.unscopables</h1>
        <p>`Symbol.unscopables` 의 초기 값은 well-known symbol %Symbol.unscopables% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Symbol 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Symbol 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Symbol.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>Symbol 인스턴스가 아니며 [[SymbolData]] 내부 슬롯을 갖지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-symbol.prototype.constructor">
        <h1>Symbol.prototype.constructor</h1>
        <p>`Symbol.prototype.constructor` 의 초기 값은 %Symbol%.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.description">
        <h1>get Symbol.prototype.description</h1>
        <p>`Symbol.prototype.description` 은 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _s_ 를 *this* 값으로 둔다.
          1. _sym_ 을 ? ThisSymbolValue(_s_) 로 둔다.
          1. _sym_.[[Description]] 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.tostring">
        <h1>Symbol.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _sym_ 을 ? ThisSymbolValue(*this* value) 로 둔다.
          1. SymbolDescriptiveString(_sym_) 을 반환한다.
        </emu-alg>

        <emu-clause id="sec-symboldescriptivestring" type="abstract operation">
          <h1>
            SymbolDescriptiveString (
              _sym_: Symbol,
            ): String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _desc_ = _sym_.[[Description]].
            1. _desc_ 가 *undefined* 이면 빈 문자열로 설정.
            1. 단언: _desc_ 는 String.
            1. *"Symbol("*, _desc_, *")"* 의 문자열 연결을 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.valueof">
        <h1>Symbol.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisSymbolValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thissymbolvalue" type="abstract operation" oldids="thissymbolvalue">
          <h1>
            ThisSymbolValue (
              _value_: ECMAScript 언어 값,
            ): Symbol 을 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 Symbol 이면 _value_ 반환.
            1. _value_ 가 Object 이고 [[SymbolData]] 내부 슬롯을 가지면
              1. _s_ 를 _value_.[[SymbolData]] 로 둔다.
              1. 단언: _s_ 는 Symbol.
              1. _s_ 반환.
            1. *TypeError* 예외 throw.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@toprimitive" id="sec-symbol.prototype-%symbol.toprimitive%">
        <h1>Symbol.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>이 메서드는 ECMAScript 언어 연산자가 Symbol 객체를 원시 값으로 변환할 때 호출된다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisSymbolValue(*this* value) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>인수는 무시된다.</p>
        </emu-note>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.toPrimitive]"* 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@tostringtag" id="sec-symbol.prototype-%symbol.tostringtag%">
        <h1>Symbol.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 *"Symbol"* String 값이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-symbol-instances">
      <h1>Symbol 인스턴스의 프로퍼티</h1>
      <p>Symbol 인스턴스는 Symbol 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. Symbol 인스턴스는 [[SymbolData]] 내부 슬롯을 가진다. [[SymbolData]] 내부 슬롯은 이 Symbol 객체가 나타내는 Symbol 값이다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-symbols">
      <h1>Symbol 을 위한 추상 연산</h1>

      <emu-clause id="sec-keyforsymbol" type="abstract operation">
        <h1>
          KeyForSymbol (
            _sym_: Symbol,
          ): String 또는 *undefined*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_sym_ 이 GlobalSymbolRegistry List 에 있으면 _sym_ 을 등록하는 데 사용된 String 이 반환된다.</dd>
        </dl>
        <emu-alg>
          1. GlobalSymbolRegistry List 의 각 요소 _e_ 에 대해
            1. SameValue(_e_.[[Symbol]], _sym_) 가 *true* 이면 _e_.[[Key]] 반환.
          1. 단언: GlobalSymbolRegistry List 에 현재 _sym_ 항목 없음.
          1. *undefined* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error 객체</h1>
    <p>Error 객체 인스턴스는 런타임 오류 발생 시 예외로 throw 된다. Error 객체는 사용자 정의 예외 클래스의 기반 객체로도 사용될 수 있다.</p>
    <p>ECMAScript 구현이 런타임 오류를 감지하면 <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> 에 정의된 _NativeError_ 객체 중 하나의 새 인스턴스나 <emu-xref href="#sec-aggregate-error-objects"></emu-xref> 에 정의된 AggregateError 객체의 새 인스턴스를 throw 한다.</p>

    <emu-clause id="sec-error-constructor">
      <h1>Error 생성자</h1>
      <p>Error 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Error%</dfn> 이다.</li>
        <li>전역 객체 *"Error"* 프로퍼티의 초기 값이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 Error 객체를 생성·초기화한다. 따라서 `Error(…)` 호출은 동일 인수를 가진 `new Error(…)` 와 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Error 동작을 상속하려는 서브클래스 생성자는 [[ErrorData]] 내부 슬롯을 가진 서브클래스 인스턴스를 만들기 위해 Error 생성자에 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ [ , _options_ ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 _newTarget_ = 활성 함수 객체; 아니면 _newTarget_ = NewTarget.
          1. _O_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Error.prototype%"*, « [[ErrorData]] ») 로 둔다.
          1. _message_ 가 *undefined* 가 아니면
            1. _msg_ = ? ToString(_message_).
            1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_) 수행.
          1. ? InstallErrorCause(_O_, _options_) 수행.
          1. _O_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Error 생성자의 프로퍼티</h1>
      <p>Error 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-error.iserror">
        <h1>Error.isError ( _arg_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _arg_ 가 Object 가 아니면 *false* 반환.
          1. _arg_ 가 [[ErrorData]] 내부 슬롯을 가지지 않으면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-error.prototype">
        <h1>Error.prototype</h1>
        <p>`Error.prototype` 의 초기 값은 Error 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-prototype-object">
      <h1>Error 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Error 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Error.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>Error 인스턴스가 아니며 [[ErrorData]] 내부 슬롯을 갖지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-error.prototype.constructor">
        <h1>Error.prototype.constructor</h1>
        <p>`Error.prototype.constructor` 의 초기 값은 %Error%.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.message">
        <h1>Error.prototype.message</h1>
        <p>`Error.prototype.message` 의 초기 값은 빈 문자열이다.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.name">
        <h1>Error.prototype.name</h1>
        <p>`Error.prototype.name` 의 초기 값은 *"Error"*.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.tostring">
        <h1>Error.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. _O_ 가 Object 가 아니면 *TypeError* 예외 throw.
          1. _name_ = ? Get(_O_, *"name"*).
          1. _name_ 이 *undefined* 이면 _name_ = *"Error"*; 아니면 _name_ = ? ToString(_name_).
          1. _msg_ = ? Get(_O_, *"message"*).
          1. _msg_ 가 *undefined* 이면 _msg_ = 빈 문자열; 아니면 _msg_ = ? ToString(_msg_).
          1. _name_ 이 빈 문자열이면 _msg_ 반환.
          1. _msg_ 가 빈 문자열이면 _name_ 반환.
          1. _name_, 0x003A, 0x0020, _msg_ 의 문자열 연결을 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Error 인스턴스의 프로퍼티</h1>
      <p>Error 인스턴스는 Error 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이며 값이 *undefined* 인 [[ErrorData]] 내부 슬롯을 가진다. [[ErrorData]] 의 유일한 지정 용도는 `Object.prototype.toString` 과 `Error.isError` 에서 Error, AggregateError, _NativeError_ 인스턴스를 식별하는 것이다.</p>
    </emu-clause>

    <emu-clause id="sec-native-error-types-used-in-this-standard">
      <h1>이 표준에서 사용되는 Native Error 타입</h1>
      <p>런타임 오류가 감지되면 아래 _NativeError_ 객체 중 하나 또는 AggregateError 객체의 새 인스턴스가 throw 된다. 모든 _NativeError_ 객체는 <emu-xref href="#sec-nativeerror-object-structure"></emu-xref> 에 설명된 동일 구조를 공유한다.</p>

      <emu-clause id="sec-native-error-types-used-in-this-standard-evalerror">
        <h1>EvalError</h1>
        <p>EvalError 생성자는 <dfn>%EvalError%</dfn> 이다.</p>
        <p>이 예외는 현재 이 명세 내부에서는 사용되지 않는다. 이전 판과의 호환성을 위해 남아 있다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-rangeerror">
        <h1>RangeError</h1>
        <p>RangeError 생성자는 <dfn>%RangeError%</dfn> 이다.</p>
        <p>허용 가능한 값의 집합 또는 범위에 속하지 않는 값을 나타낸다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-referenceerror">
        <h1>ReferenceError</h1>
        <p>ReferenceError 생성자는 <dfn>%ReferenceError%</dfn> 이다.</p>
        <p>잘못된 참조가 감지되었음을 나타낸다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-syntaxerror">
        <h1>SyntaxError</h1>
        <p>SyntaxError 생성자는 <dfn>%SyntaxError%</dfn> 이다.</p>
        <p>파싱 오류가 발생했음을 나타낸다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-typeerror">
        <h1>TypeError</h1>
        <p>TypeError 생성자는 <dfn>%TypeError%</dfn> 이다.</p>
        <p>다른 _NativeError_ 객체 어느 것도 실패 원인을 적절히 나타내지 못할 때 실패한 연산을 나타내는 데 사용된다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-urierror">
        <h1>URIError</h1>
        <p>URIError 생성자는 <dfn>%URIError%</dfn> 이다.</p>
        <p>글로벌 URI 처리 함수 중 하나가 그 정의와 호환되지 않는 방식으로 사용되었음을 나타낸다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ 객체 구조</h1>
      <p>이 객체 각각은 아래에 설명된 구조를 가지며, 생성자 이름과 프로토타입 객체의 *"name"* 프로퍼티만 다르다.</p>
      <p>각 error 객체에 대해 정의 내 _NativeError_ 참조는 <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> 의 해당 error 객체 이름으로 대체되어야 한다.</p>

      <emu-clause id="sec-nativeerror-constructors">
        <h1>_NativeError_ 생성자</h1>
        <p>각 _NativeError_ 생성자는:</p>
        <ul>
          <li>생성자가 아니라 함수로 호출될 때 새 _NativeError_ 객체를 생성·초기화한다. 함수 호출 <code><var>NativeError</var>(&hellip;)</code> 는 동일 인수를 가진 <code>new <var>NativeError</var>(&hellip;)</code> 와 동등하다.</li>
          <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 _NativeError_ 동작을 상속하려는 서브클래스 생성자는 [[ErrorData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 _NativeError_ 생성자에 `super` 호출을 포함해야 한다.</li>
        </ul>

        <emu-clause id="sec-nativeerror">
          <h1>_NativeError_ ( _message_ [ , _options_ ] )</h1>
          <p>각 _NativeError_ 함수는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. NewTarget 이 *undefined* 이면 _newTarget_ = 활성 함수 객체; 아니면 _newTarget_ = NewTarget.
            1. [id="step-nativeerror-ordinarycreatefromconstructor"] _O_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>.prototype%"</code>, « [[ErrorData]] ») 로 둔다.
            1. _message_ 가 *undefined* 가 아니면
              1. _msg_ = ? ToString(_message_).
              1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_) 수행.
            1. ? InstallErrorCause(_O_, _options_) 수행.
            1. _O_ 반환.
          </emu-alg>
          <p>step <emu-xref href="#step-nativeerror-ordinarycreatefromconstructor"></emu-xref> 에 전달되는 문자열의 실제 값은 정의 중인 _NativeError_ 생성자에 따라 *"%EvalError.prototype%"*, *"%RangeError.prototype%"*, *"%ReferenceError.prototype%"*, *"%SyntaxError.prototype%"*, *"%TypeError.prototype%"*, *"%URIError.prototype%"* 중 하나이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>_NativeError_ 생성자의 프로퍼티</h1>
        <p>각 _NativeError_ 생성자는:</p>
        <ul>
          <li>값이 %Error% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>값이 String <emu-val>"<var>NativeError</var>"</emu-val> 인 *"name"* 프로퍼티를 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype">
          <h1>_NativeError_.prototype</h1>
          <p><code><var>NativeError</var>.prototype</code> 의 초기 값은 _NativeError_ 프로토타입 객체 (<emu-xref href="#sec-properties-of-the-nativeerror-prototype-objects"></emu-xref>). 각 _NativeError_ 생성자는 서로 다른 프로토타입 객체를 가진다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-prototype-objects">
        <h1>_NativeError_ 프로토타입 객체의 프로퍼티</h1>
        <p>각 <dfn>_NativeError_ 프로토타입 객체</dfn>는:</p>
        <ul>
          <li>ordinary 객체이다.</li>
          <li>Error 인스턴스가 아니며 [[ErrorData]] 내부 슬롯을 갖지 않는다.</li>
          <li>값이 %Error.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype.constructor">
          <h1>_NativeError_.prototype.constructor</h1>
          <p>특정 _NativeError_ 생성자에 대한 프로토타입의 *"constructor"* 프로퍼티 초기 값은 그 생성자 자체이다.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.message">
          <h1>_NativeError_.prototype.message</h1>
          <p>특정 _NativeError_ 생성자 프로토타입의 *"message"* 프로퍼티 초기 값은 빈 문자열이다.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.name">
          <h1>_NativeError_.prototype.name</h1>
          <p>특정 _NativeError_ 생성자 프로토타입의 *"name"* 프로퍼티 초기 값은 ( _NativeError_ 대신 사용되는 ) 생성자의 이름으로 이루어진 String 값이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>_NativeError_ 인스턴스의 프로퍼티</h1>
        <p>_NativeError_ 인스턴스는 해당 _NativeError_ 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이며 값이 *undefined* 인 [[ErrorData]] 내부 슬롯을 가진다. [[ErrorData]] 의 유일한 지정 용도는 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 과 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 에서 Error, AggregateError 또는 _NativeError_ 인스턴스를 식별하는 것이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError 객체</h1>

      <emu-clause id="sec-aggregate-error-constructor">
        <h1>AggregateError 생성자</h1>
        <p>AggregateError 생성자는 다음과 같다:</p>
        <ul>
          <li><dfn>%AggregateError%</dfn> 이다.</li>
          <li>전역 객체 *"AggregateError"* 프로퍼티의 초기 값이다.</li>
          <li>생성자가 아니라 함수로 호출될 때 새 AggregateError 객체를 생성·초기화한다. 따라서 `AggregateError(…)` 호출은 동일 인수를 가진 `new AggregateError(…)` 와 동등하다.</li>
          <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 AggregateError 동작을 상속하려는 서브클래스 생성자는 [[ErrorData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 AggregateError 생성자에 `super` 호출을 포함해야 한다.</li>
        </ul>

        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. NewTarget 이 *undefined* 이면 _newTarget_ = 활성 함수 객체; 아니면 _newTarget_ = NewTarget.
            1. _O_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, « [[ErrorData]] ») 로 둔다.
            1. _message_ 가 *undefined* 가 아니면
              1. _msg_ = ? ToString(_message_).
              1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_) 수행.
            1. ? InstallErrorCause(_O_, _options_) 수행.
            1. _errorsList_ 를 ? IteratorToList(? GetIterator(_errors_, ~sync~)) 로 둔다.
            1. ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }) 수행.
            1. _O_ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructors">
        <h1>AggregateError 생성자의 프로퍼티</h1>
        <p>AggregateError 생성자는:</p>
        <ul>
          <li>값이 %Error% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype">
          <h1>AggregateError.prototype</h1>
          <p>`AggregateError.prototype` 의 초기 값은 %AggregateError.prototype% 이다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-prototype-objects">
        <h1>AggregateError 프로토타입 객체의 프로퍼티</h1>
        <p><dfn>AggregateError 프로토타입 객체</dfn>는:</p>
        <ul>
          <li><dfn>%AggregateError.prototype%</dfn> 이다.</li>
          <li>ordinary 객체이다.</li>
          <li>Error 인스턴스나 AggregateError 인스턴스가 아니며 [[ErrorData]] 내부 슬롯을 갖지 않는다.</li>
          <li>값이 %Error.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype.constructor">
          <h1>AggregateError.prototype.constructor</h1>
          <p>`AggregateError.prototype.constructor` 의 초기 값은 %AggregateError%.</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.message">
          <h1>AggregateError.prototype.message</h1>
          <p>`AggregateError.prototype.message` 의 초기 값은 빈 문자열이다.</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.name">
          <h1>AggregateError.prototype.name</h1>
          <p>`AggregateError.prototype.name` 의 초기 값은 *"AggregateError"*.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-aggregate-error-instances">
        <h1>AggregateError 인스턴스의 프로퍼티</h1>
        <p>AggregateError 인스턴스는 해당 AggregateError 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이며 값이 *undefined* 인 [[ErrorData]] 내부 슬롯을 가진다. [[ErrorData]] 의 유일한 지정 용도는 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 과 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 에서 Error, AggregateError, _NativeError_ 인스턴스를 식별하는 것이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-error-objects">
      <h1>Error 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-installerrorcause" type="abstract operation">
        <h1>
          InstallErrorCause (
            _O_: Object,
            _options_: ECMAScript 언어 값,
          ): ~unused~ 를 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_options_ 에 *"cause"* 프로퍼티가 존재할 때 _O_ 에 *"cause"* 프로퍼티를 생성하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _options_ 가 Object 이고 ? HasProperty(_options_, *"cause"*) 가 *true* 이면
            1. _cause_ 를 ? Get(_options_, *"cause"*) 로 둔다.
            1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"cause"*, _cause_) 수행.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>숫자와 날짜 (Numbers and Dates)</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number 객체 (Number Objects)</h1>

    <emu-clause id="sec-number-constructor">
      <h1>Number 생성자 (The Number Constructor)</h1>
      <p>Number 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Number%</dfn> 이다.</li>
        <li>전역 객체 *"Number"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 Number 객체를 생성하고 초기화한다.</li>
        <li>생성자가 아니라 함수로 호출될 때 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Number 동작을 상속하려는 서브클래스 생성자는 [[NumberData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 Number 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _value_ 가 존재하면
            1. _prim_ 을 ? ToNumeric(_value_) 로 둔다.
            1. _prim_ 이 BigInt 이면 _n_ 을 𝔽(ℝ(_prim_)) 로 둔다.
            1. 그렇지 않으면 _n_ 을 _prim_ 으로 둔다.
          1. 그렇지 않으면,
            1. _n_ 을 *+0*<sub>𝔽</sub> 로 둔다.
          1. NewTarget 이 *undefined* 이면 _n_ 을 반환한다.
          1. _O_ 를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] ») 로 둔다.
          1. _O_.[[NumberData]] 를 _n_ 으로 설정한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Number 생성자의 프로퍼티 (Properties of the Number Constructor)</h1>
      <p>Number 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-number.epsilon">
        <h1>Number.EPSILON</h1>
        <p>`Number.EPSILON` 의 값은 1과, Number 값으로 표현 가능한 1보다 큰 가장 작은 값 사이의 차이의 크기(Number 값)이며, 약 2.2204460492503130808472633361816 × 10<sup>-16</sup>이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.isfinite">
        <h1>Number.isFinite ( _number_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 Number 가 아니면 *false* 반환.
          1. _number_ 가 finite 가 아니면 *false* 반환.
          1. 그렇지 않으면 *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isinteger">
        <h1>Number.isInteger ( _number_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 정수(Number) 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isnan">
        <h1>Number.isNaN ( _number_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 Number 가 아니면 *false* 반환.
          1. _number_ 가 *NaN* 이면 *true* 반환.
          1. 그렇지 않으면 *false* 반환.
        </emu-alg>
        <emu-note>
          <p>이 함수는 인수를 *NaN* 인지 판정하기 전에 Number 로 변환한다는 점에서 전역 isNaN 함수(<emu-xref href="#sec-isnan-number"></emu-xref>)와 다르다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.issafeinteger">
        <h1>Number.isSafeInteger ( _number_ )</h1>
        <emu-note>
          <p>정수 _n_ 이 "<dfn id="safe-integer">안전한 정수(safe integer)</dfn>" 이려면, 그리고 그럴 때에 한해 _n_ 의 Number 값이 다른 어떤 정수의 Number 값과 같지 않아야 한다.</p>
        </emu-note>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 정수(Number) 이면
            1. abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.max_safe_integer">
        <h1>Number.MAX_SAFE_INTEGER</h1>
        <emu-note>
          <p>IEEE 754-2019의 정밀도 한계로 인한 반올림 동작 때문에 `Number.MAX_SAFE_INTEGER` 보다 큰 모든 정수의 Number 값은 최소 하나 이상의 다른 정수와 공유된다. 그러한 큰 크기의 정수들은 <emu-xref href="#safe-integer">안전</emu-xref>하지 않으며 Number 값으로 정확히 표현되거나 서로 구별될 수 있음을 보장하지 않는다. 예를 들어 `9007199254740992` 와 `9007199254740993` 은 모두 Number 값 *9007199254740992*<sub>𝔽</sub> 로 평가된다.</p>
        </emu-note>
        <p>`Number.MAX_SAFE_INTEGER` 의 값은 *9007199254740991*<sub>𝔽</sub> (𝔽(2<sup>53</sup> - 1)) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.max_value">
        <h1>Number.MAX_VALUE</h1>
        <p>`Number.MAX_VALUE` 의 값은 Number 타입의 가장 큰 양의 유한 값이며, 이는 대략 <emu-eqn>1.7976931348623157 × 10<sup>308</sup></emu-eqn> 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_safe_integer">
        <h1>Number.MIN_SAFE_INTEGER</h1>
        <emu-note>
          <p>IEEE 754-2019의 정밀도 한계로 인한 반올림 동작 때문에 `Number.MIN_SAFE_INTEGER` 보다 작은 모든 정수의 Number 값은 최소 하나 이상의 다른 정수와 공유된다. 그러한 큰 크기의(절대값이 큰) 정수들은 <emu-xref href="#safe-integer">안전</emu-xref>하지 않으며 Number 값으로 정확히 표현되거나 서로 구별될 수 있음을 보장하지 않는다. 예를 들어 `-9007199254740992` 와 `-9007199254740993` 은 모두 Number 값 *-9007199254740992*<sub>𝔽</sub> 로 평가된다.</p>
        </emu-note>
        <p>`Number.MIN_SAFE_INTEGER` 의 값은 *-9007199254740991*<sub>𝔽</sub> (𝔽(-(2<sup>53</sup> - 1))) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_value">
        <h1>Number.MIN_VALUE</h1>
        <p>`Number.MIN_VALUE` 의 값은 Number 타입의 가장 작은 양의 값이며, 이는 대략 <emu-eqn>5 × 10<sup>-324</sup></emu-eqn> 이다.</p>
        <p>IEEE 754-2019 배정밀도 이진 표현에서 가장 작은 가능한 값은 비정규(denormalized) 수이다. 구현이 비정규 값을 지원하지 않는다면 `Number.MIN_VALUE` 의 값은 구현이 실제로 표현할 수 있는 가장 작은 0이 아닌 양의 값이어야 한다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.nan">
        <h1>Number.NaN</h1>
        <p>`Number.NaN` 의 값은 *NaN* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.negative_infinity">
        <h1>Number.NEGATIVE_INFINITY</h1>
        <p>`Number.NEGATIVE_INFINITY` 의 값은 *-∞*<sub>𝔽</sub> 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.parsefloat">
        <h1>Number.parseFloat ( _string_ )</h1>
        <p>*"parseFloat"* 프로퍼티의 초기 값은 %parseFloat% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.parseint">
        <h1>Number.parseInt ( _string_, _radix_ )</h1>
        <p>*"parseInt"* 프로퍼티의 초기 값은 %parseInt% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.positive_infinity">
        <h1>Number.POSITIVE_INFINITY</h1>
        <p>`Number.POSITIVE_INFINITY` 의 값은 *+∞*<sub>𝔽</sub> 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype">
        <h1>Number.prototype</h1>
        <p>`Number.prototype` 의 초기 값은 Number 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Number 프로토타입 객체의 프로퍼티 (Properties of the Number Prototype Object)</h1>
      <p><dfn>Number 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Number.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>자체가 Number 객체이며 값이 *+0*<sub>𝔽</sub> 인 [[NumberData]] 내부 슬롯을 가진다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <p>명시적으로 달리 언급되지 않는 한 아래 정의된 Number 프로토타입 객체의 메서드는 generic 하지 않으며, 그들에게 전달된 *this* 값은 Number 값이거나 Number 값으로 초기화된 [[NumberData]] 내부 슬롯을 가진 객체여야 한다.</p>
      <p>메서드 명세 안의 “this Number value” 라는 문구는 해당 메서드 호출의 *this* 값을 인수로 하여 추상 연산 ThisNumberValue 를 호출한 결과를 의미한다.</p>

      <emu-clause id="sec-number.prototype.constructor">
        <h1>Number.prototype.constructor</h1>
        <p>`Number.prototype.constructor` 의 초기 값은 %Number% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toexponential">
        <h1>Number.prototype.toExponential ( _fractionDigits_ )</h1>
        <p>이 메서드는 이 Number 값을 십진 지수 표기(유효숫자 부분의 소수점 앞에 한 자리, 소수점 뒤에 _fractionDigits_ 자리)로 표현한 String 을 반환한다. _fractionDigits_ 가 *undefined* 이면, (항상 지수 표기로 출력된다는 점을 제외하면 ToString 과 같이) Number 를 유일하게 지정하는 데 필요한 만큼의 유효숫자 자릿수를 포함한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _f_ 를 ? ToIntegerOrInfinity(_fractionDigits_) 로 둔다.
          1. 단언: _fractionDigits_ 가 *undefined* 이면 _f_ 는 0.
          1. _x_ 가 finite 가 아니면 Number::toString(_x_, 10) 반환.
          1. _f_ &lt; 0 또는 _f_ > 100 이면 *RangeError* 예외 throw.
          1. _x_ 를 ℝ(_x_) 로 설정.
          1. _s_ 를 빈 문자열로 둔다.
          1. _x_ &lt; 0 이면
            1. _s_ = *"-"*.
            1. _x_ = -_x_.
          1. _x_ = 0 이면
            1. _m_ 을 _f_ + 1 번의 코드 유닛 0x0030 (DIGIT ZERO) 로 구성된 String 값으로 둔다.
            1. _e_ = 0.
          1. 그렇지 않으면,
            1. _fractionDigits_ 가 *undefined* 가 아니면
              1. 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup> 이고 _n_ × 10<sup>_e_ - _f_</sup> - _x_ 가 0 에 가장 가깝도록 하는 정수 _e_, _n_ 을 둔다. 그러한 ( _e_, _n_ ) 이 두 개 있으면 _n_ × 10<sup>_e_ - _f_</sup> 가 더 큰 것을 고른다.
            1. 그렇지 않으면,
              1. [id="step-number-proto-toexponential-intermediate-values"] _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ &lt; 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) 가 𝔽(_x_), 그리고 _ff_ 가 가능한 한 작은 정수인 _e_, _n_, _ff_ 를 둔다. 이때 _n_ 의 십진 표현은 _ff_ + 1 자리이며, _n_ 은 10 으로 나누어떨어지지 않고, _n_ 의 최하위 자리는 유일하게 결정되지 않을 수 있다.
              1. _f_ = _ff_.
            1. _m_ 을 _n_ 의 십진 표현의 자릿수들(선행 0 없이 순서대로)로 구성된 String 값으로 둔다.
          1. _f_ ≠ 0 이면
            1. _a_ = _m_ 의 첫 코드 유닛.
            1. _b_ = 나머지 _f_ 개의 코드 유닛.
            1. _m_ = _a_, *"."*, _b_ 의 문자열 연결.
          1. _e_ = 0 이면
            1. _c_ = *"+"*.
            1. _d_ = *"0"*.
          1. 그렇지 않으면,
            1. _e_ > 0 이면
              1. _c_ = *"+"*.
            1. 그렇지 않으면
              1. 단언: _e_ &lt; 0.
              1. _c_ = *"-"*.
              1. _e_ = -_e_.
            1. _d_ = _e_ 의 십진 표현 자릿수들(선행 0 없이)로 구성된 String 값.
          1. _m_ = _m_, *"e"*, _c_, _d_ 의 문자열 연결.
          1. _s_ 와 _m_ 의 문자열 연결을 반환한다.
        </emu-alg>
        <emu-note>
          <p>위 규칙이 요구하는 것보다 더 정확한 변환을 제공하는 구현은 step <emu-xref href="#step-number-proto-toexponential-intermediate-values"></emu-xref> 의 다음 대안 버전을 지침으로 사용하는 것이 권장된다:</p>
          <emu-alg replaces-step="step-number-proto-toexponential-intermediate-values">
            1. _e_, _n_, _ff_를 다음 조건을 만족하는 정수로 둔다: _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ &lt; 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>)가 𝔽(_x_)와 같으며, _ff_는 가능한 한 작아야 한다. _n_에 여러 가능한 값이 있다면, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>)가 𝔽(_x_)와 가장 가까운 값을 선택한다. 만약 가능한 _n_이 두 개이며 모두 조건을 만족한다면, 짝수인 _n_을 선택한다.
          </emu-alg>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tofixed">
        <h1>Number.prototype.toFixed ( _fractionDigits_ )</h1>
        <emu-note>
          <p>이 메서드는 이 Number 값을 십진 고정 소수점 표기로 표시한 String 을 반환하며 소수점 이하 자리수는 _fractionDigits_ 이다. _fractionDigits_ 가 *undefined* 이면 0 으로 간주한다.</p>
        </emu-note>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _f_ 를 ? ToIntegerOrInfinity(_fractionDigits_) 로 둔다.
          1. 단언: _fractionDigits_ 가 *undefined* 이면 _f_ = 0.
          1. _f_ 가 finite 가 아니면 *RangeError* 예외 throw.
          1. _f_ &lt; 0 또는 _f_ > 100 이면 *RangeError* 예외 throw.
          1. _x_ 가 finite 가 아니면 Number::toString(_x_, 10) 반환.
          1. _x_ = ℝ(_x_).
          1. _s_ = 빈 문자열.
          1. _x_ &lt; 0 이면
            1. _s_ = *"-"*.
            1. _x_ = -_x_.
          1. _x_ ≥ 10<sup>21</sup> 이면
            1. _m_ = ! ToString(𝔽(_x_)).
          1. 그렇지 않으면
            1. _n_ 을 _n_ / 10<sup>_f_</sup> - _x_ 가 0 에 가장 가깝도록 하는 정수로 둔다. 그런 _n_ 이 두 개면 더 큰 _n_ 선택.
            1. _n_ = 0 이면 _m_ = *"0"*; 아니면 _m_ = _n_ 의 십진 표현 자릿수(선행 0 없이).
            1. _f_ ≠ 0 이면
              1. _k_ = _m_ 의 길이.
              1. _k_ ≤ _f_ 이면
                1. _z_ = _f_ + 1 - _k_ 번의 코드 유닛 0x0030 (DIGIT ZERO) 로 구성된 String.
                1. _m_ = _z_ 와 _m_ 의 문자열 연결.
                1. _k_ = _f_ + 1.
              1. _a_ = _m_ 의 처음 _k_ - _f_ 코드 유닛.
              1. _b_ = 나머지 _f_ 코드 유닛.
              1. _m_ = _a_, *"."*, _b_ 의 문자열 연결.
          1. _s_ 와 _m_ 의 문자열 연결을 반환한다.
        </emu-alg>
        <emu-note>
          <p>`toFixed` 의 출력은 어떤 값들에 대해 `toString` 보다 더 정밀할 수 있다. 이는 toString 이 인접한 Number 값들과 구별하기 위한 충분한 유효숫자만을 출력하기 때문이다. 예를 들어,</p>
          <p>
            `(1000000000000000128).toString()` 은 *"1000000000000000100"* 을 반환하고,<br>
            `(1000000000000000128).toFixed(0)` 은 *"1000000000000000128"* 을 반환한다.
          </p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tolocalestring">
        <h1>Number.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API 를 포함하는 ECMAScript 구현은 이 메서드를 ECMA-402 명세에 따라 구현해야 한다. 구현이 ECMA-402 API 를 포함하지 않는 경우 다음 명세가 사용된다:</p>
        <p>이 메서드는 호스트 환경의 현재 로케일 관례에 따라 포맷된 이 Number 값을 나타내는 String 값을 생성한다. 이 메서드는 구현 정의이며 `toString` 과 같은 결과를 반환하는 것이 허용되나 권장되지는 않는다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의된다; ECMA-402 를 지원하지 않는 구현은 그 매개변수 위치를 다른 용도로 사용해서는 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toprecision">
        <h1>Number.prototype.toPrecision ( _precision_ )</h1>
        <p>이 메서드는 이 Number 값을 (유효숫자 부분 소수점 앞에 한 자리, 소수점 뒤에 <emu-eqn>_precision_ - 1</emu-eqn> 자리)인 십진 지수 표기 또는 _precision_ 개의 유효숫자를 갖는 십진 고정 표기 중 하나로 표현한 String 을 반환한다. _precision_ 이 *undefined* 이면 대신 ToString 을 호출한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _precision_ 이 *undefined* 이면 ! ToString(_x_) 반환.
          1. _p_ 를 ? ToIntegerOrInfinity(_precision_) 로 둔다.
          1. _x_ 가 finite 가 아니면 Number::toString(_x_, 10) 반환.
          1. _p_ &lt; 1 또는 _p_ > 100 이면 *RangeError* 예외 throw.
          1. _x_ = ℝ(_x_).
          1. _s_ = 빈 문자열.
          1. _x_ &lt; 0 이면
            1. _s_ = 코드 유닛 0x002D (HYPHEN-MINUS).
            1. _x_ = -_x_.
          1. _x_ = 0 이면
            1. _m_ = _p_ 번의 코드 유닛 0x0030 (DIGIT ZERO) 로 구성된 String.
            1. _e_ = 0.
          1. 그렇지 않으면
            1. 10<sup>_p_ - 1</sup> ≤ _n_ &lt; 10<sup>_p_</sup> 이고 _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ 가 0 에 가장 가깝도록 하는 정수 _e_, _n_ 을 둔다. 그러한 ( _e_, _n_ ) 이 두 개면 _n_ × 10<sup>_e_ - _p_ + 1</sup> 이 더 큰 것을 선택.
            1. _m_ 을 _n_ 의 십진 표현 자릿수들(선행 0 없이)로 구성된 String 값으로 둔다.
            1. _e_ &lt; -6 또는 _e_ ≥ _p_ 이면
              1. 단언: _e_ ≠ 0.
              1. _p_ ≠ 1 이면
                1. _a_ = _m_ 의 첫 코드 유닛.
                1. _b_ = 나머지 _p_ - 1 코드 유닛.
                1. _m_ = _a_, *"."*, _b_ 의 문자열 연결.
              1. _e_ > 0 이면
                1. _c_ = 코드 유닛 0x002B (PLUS SIGN).
              1. 그렇지 않으면
                1. 단언: _e_ &lt; 0.
                1. _c_ = 코드 유닛 0x002D (HYPHEN-MINUS).
                1. _e_ = -_e_.
              1. _d_ = _e_ 의 십진 표현 자릿수들(선행 0 없이)로 구성된 String.
              1. _s_, _m_, 코드 유닛 0x0065 (e), _c_, _d_ 의 문자열 연결을 반환.
          1. _e_ = _p_ - 1 이면 _s_ 와 _m_ 의 문자열 연결 반환.
          1. _e_ ≥ 0 이면
            1. _m_ = 처음 _e_ + 1 코드 유닛, 코드 유닛 0x002E (FULL STOP), 그리고 남은 _p_ - (_e_ + 1) 코드 유닛의 문자열 연결.
          1. 그렇지 않으면
            1. _m_ = 코드 유닛 0x0030 (DIGIT ZERO), 코드 유닛 0x002E (FULL STOP), -(_e_ + 1) 번의 코드 유닛 0x0030 (DIGIT ZERO), 그리고 String _m_ 의 문자열 연결.
          1. _s_ 와 _m_ 의 문자열 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tostring">
        <h1>Number.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>선택적 _radix_ 는 *2*<sub>𝔽</sub> 에서 *36*<sub>𝔽</sub> 사이(포함)의 정수 Number 값이어야 한다. _radix_ 가 *undefined* 이면 *10*<sub>𝔽</sub> 이 _radix_ 값으로 사용된다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _radix_ 가 *undefined* 이면 _radixMV_ = 10.
          1. 그렇지 않으면 _radixMV_ = ? ToIntegerOrInfinity(_radix_).
          1. _radixMV_ 가 2 이상 36 이하 구간에 없으면 *RangeError* 예외 throw.
          1. Number::toString(_x_, _radixMV_) 반환.
        </emu-alg>
        <p>이 메서드는 generic 하지 않으며, *this* 값이 Number 또는 Number 객체가 아니면 *TypeError* 예외를 던진다. 따라서 다른 종류의 객체로 이전하여 메서드로 사용할 수 없다.</p>
        <p>이 메서드의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.valueof">
        <h1>Number.prototype.valueOf ( )</h1>
        <emu-alg>
          1. ? ThisNumberValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisnumbervalue" type="abstract operation" oldids="thisnumbervalue">
          <h1>
            ThisNumberValue (
              _value_: ECMAScript 언어 값,
            ): Number 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 Number 이면 _value_ 반환.
            1. _value_ 가 Object 이고 [[NumberData]] 내부 슬롯을 가지면
              1. _n_ = _value_.[[NumberData]].
              1. 단언: _n_ 은 Number.
              1. _n_ 반환.
            1. *TypeError* 예외 throw.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-number-instances">
      <h1>Number 인스턴스의 프로퍼티 (Properties of Number Instances)</h1>
      <p>Number 인스턴스는 Number 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. Number 인스턴스는 또한 [[NumberData]] 내부 슬롯을 가진다. [[NumberData]] 내부 슬롯은 이 Number 객체가 나타내는 Number 값이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt 객체 (BigInt Objects)</h1>

    <emu-clause id="sec-bigint-constructor">
      <h1>BigInt 생성자 (The BigInt Constructor)</h1>
      <p>BigInt 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%BigInt%</dfn> 이다.</li>
        <li>전역 객체의 *"BigInt"* 프로퍼티 초기 값이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 타입 변환을 수행한다.</li>
        <li>`new` 연산자와 함께 사용하거나 서브클래싱하도록 의도되지 않았다. 클래스 정의의 `extends` 절 값으로 사용할 수는 있으나 BigInt 생성자에 대한 `super` 호출은 예외를 발생시킨다.</li>
      </ul>

      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 가 아니면 *TypeError* 예외를 throw 한다.
          1. _prim_ 을 ? ToPrimitive(_value_, ~number~) 로 둔다.
          1. _prim_ 이 Number 이면 ? NumberToBigInt(_prim_) 를 반환한다.
          1. 그렇지 않으면 ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta> 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            NumberToBigInt (
              _number_: a Number,
            ): BigInt 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _number_ 가 정수(Number)가 아니면 *RangeError* 예외를 throw 한다.
            1. ℤ(ℝ(_number_)) 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>BigInt 생성자의 프로퍼티 (Properties of the BigInt Constructor)</h1>
      <p>BigInt 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-bigint.asintn">
        <h1>BigInt.asIntN ( _bits_, _bigint_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _bits_ 를 ? ToIndex(_bits_) 로 설정한다.
          1. _bigint_ 를 ? ToBigInt(_bigint_) 로 설정한다.
          1. _mod_ 를 ℝ(_bigint_) mod 2<sup>_bits_</sup> 로 둔다.
          1. _mod_ ≥ 2<sup>_bits_ - 1</sup> 이면 ℤ(_mod_ - 2<sup>_bits_</sup>) 를 반환; 그렇지 않으면 ℤ(_mod_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.asuintn">
        <h1>BigInt.asUintN ( _bits_, _bigint_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _bits_ 를 ? ToIndex(_bits_) 로 설정한다.
          1. _bigint_ 를 ? ToBigInt(_bigint_) 로 설정한다.
          1. ℤ(ℝ(_bigint_) mod 2<sup>_bits_</sup>) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype">
        <h1>BigInt.prototype</h1>
        <p>`BigInt.prototype` 의 초기 값은 BigInt 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>BigInt 프로토타입 객체의 프로퍼티 (Properties of the BigInt Prototype Object)</h1>
      <p><dfn>BigInt 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%BigInt.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>BigInt 객체가 아니며 [[BigIntData]] 내부 슬롯을 갖지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <p>메서드 명세 내 “this BigInt value” 라는 표현은 그 메서드 호출의 *this* 값을 인수로 하여 추상 연산 ThisBigIntValue 를 호출한 결과를 가리킨다.</p>

      <emu-clause id="sec-bigint.prototype.constructor">
        <h1>BigInt.prototype.constructor</h1>
        <p>`BigInt.prototype.constructor` 의 초기 값은 %BigInt% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tolocalestring">
        <h1>BigInt.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API 를 포함하는 ECMAScript 구현은 이 메서드를 ECMA-402 명세에 따라 구현해야 한다. 구현이 ECMA-402 API 를 포함하지 않는 경우 아래 명세가 사용된다:</p>
        <p>이 메서드는 호스트 환경의 현재 로케일 관례에 따라 포맷된 이 BigInt 값을 나타내는 String 값을 생성한다. 이 메서드는 구현 정의이며 `toString` 과 동일한 결과를 반환하는 것이 허용되나 권장되지는 않는다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의되며, ECMA-402 지원이 없는 구현은 해당 매개변수 위치를 다른 목적으로 사용해서는 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tostring">
        <h1>BigInt.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>선택적 _radix_ 는 *2*<sub>𝔽</sub> 이상 *36*<sub>𝔽</sub> 이하(포함)의 정수 Number 값이어야 한다. _radix_ 가 *undefined* 이면 *10*<sub>𝔽</sub> 이 _radix_ 값으로 사용된다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisBigIntValue(*this* value) 로 둔다.
          1. _radix_ 가 *undefined* 이면 _radixMV_ = 10.
          1. 그렇지 않으면 _radixMV_ = ? ToIntegerOrInfinity(_radix_).
          1. _radixMV_ 가 2 이상 36 이하 구간에 없으면 *RangeError* 예외를 throw 한다.
          1. BigInt::toString(_x_, _radixMV_) 를 반환한다.
        </emu-alg>
        <p>이 메서드는 generic 하지 않으며 *this* 값이 BigInt 또는 BigInt 객체가 아니면 *TypeError* 예외를 던진다. 따라서 다른 종류의 객체로 이전하여 메서드로 사용할 수 없다.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.valueof">
        <h1>BigInt.prototype.valueOf ( )</h1>
        <emu-alg>
          1. ? ThisBigIntValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisbigintvalue" type="abstract operation" oldids="thisbigintvalue">
          <h1>
            ThisBigIntValue (
              _value_: an ECMAScript language value,
            ): BigInt 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 BigInt 이면 _value_ 를 반환한다.
            1. _value_ 가 Object 이고 [[BigIntData]] 내부 슬롯을 가진다면
              1. 단언: _value_.[[BigIntData]] 는 BigInt 이다.
              1. _value_.[[BigIntData]] 를 반환한다.
            1. *TypeError* 예외를 throw 한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-bigint.prototype-@@tostringtag" id="sec-bigint.prototype-%symbol.tostringtag%">
        <h1>BigInt.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 String 값 *"BigInt"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-bigint-instances">
      <h1>BigInt 인스턴스의 프로퍼티 (Properties of BigInt Instances)</h1>
      <p>BigInt 인스턴스는 BigInt 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. BigInt 인스턴스는 또한 [[BigIntData]] 내부 슬롯을 가진다. [[BigIntData]] 내부 슬롯은 해당 BigInt 객체가 나타내는 BigInt 값이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-math-object">
    <h1>Math 객체 (The Math Object)</h1>
    <p>Math 객체는 다음과 같다:</p>
    <ul>
      <li><dfn>%Math%</dfn> 이다.</li>
      <li>전역 객체 *"Math"* 프로퍼티의 초기 값이다.</li>
      <li>ordinary 객체이다.</li>
      <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      <li>함수 객체가 아니다.</li>
      <li>[[Construct]] 내부 메서드를 가지지 않아 `new` 연산자로 생성자로 사용할 수 없다.</li>
      <li>[[Call]] 내부 메서드를 가지지 않아 함수로 호출될 수 없다.</li>
    </ul>
    <emu-note>
      <p>이 명세에서 “the Number value for _x_” 라는 구문은 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 에 정의된 기술적 의미를 가진다.</p>
    </emu-note>

    <emu-clause id="sec-value-properties-of-the-math-object">
      <h1>Math 객체의 값 프로퍼티 (Value Properties of the Math Object)</h1>

      <emu-clause id="sec-math.e">
        <h1>Math.E</h1>
        <p>자연로그의 밑 <i>e</i> 에 대한 Number 값. 대략 2.7182818284590452354.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln10">
        <h1>Math.LN10</h1>
        <p>10 의 자연로그에 대한 Number 값. 대략 2.302585092994046.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln2">
        <h1>Math.LN2</h1>
        <p>2 의 자연로그에 대한 Number 값. 대략 0.6931471805599453.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.log10e">
        <h1>Math.LOG10E</h1>
        <p>자연로그의 밑 <i>e</i> 의 밑-10 로그(Number 값). 대략 0.4342944819032518.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Math.LOG10E` 값은 `Math.LN10` 값의 역수에 가까운 값이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log2e">
        <h1>Math.LOG2E</h1>
        <p>자연로그의 밑 <i>e</i> 의 밑-2 로그(Number 값). 대략 1.4426950408889634.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Math.LOG2E` 값은 `Math.LN2` 값의 역수에 가까운 값이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.pi">
        <h1>Math.PI</h1>
        <p>원주율 π (원둘레/지름) 에 대한 Number 값. 대략 3.1415926535897932.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.sqrt1_2">
        <h1>Math.SQRT1_2</h1>
        <p>½ 의 제곱근(Number 값). 대략 0.7071067811865476.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Math.SQRT1_2` 값은 `Math.SQRT2` 값의 역수에 가까운 값이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt2">
        <h1>Math.SQRT2</h1>
        <p>2 의 제곱근(Number 값). 대략 1.4142135623730951.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-math-@@tostringtag" id="sec-math-%symbol.tostringtag%">
        <h1>Math [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 String 값 *"Math"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Math 객체의 함수 프로퍼티 (Function Properties of the Math Object)</h1>
      <emu-note>
        <p>`acos`, `acosh`, `asin`, `asinh`, `atan`, `atanh`, `atan2`, `cbrt`, `cos`, `cosh`, `exp`, `expm1`, `hypot`, `log`, `log1p`, `log2`, `log10`, `pow`, `random`, `sin`, `sinh`, `tan`, `tanh` 함수의 동작은 경계 사례에 대해 특정 결과를 요구하는 것 외에는 여기서 정확히 규정되지 않는다. 다른 인수 값에 대해서는 익숙한 수학 함수의 결과를 근사하도록 의도되며, 근사 알고리즘 선택에 다소 재량이 허용된다. 일반적인 의도는 구현자가 해당 하드웨어 플랫폼에서 C 프로그래머가 사용할 수 있는 동일한 수학 라이브러리를 ECMAScript 에도 사용할 수 있도록 하는 것이다.</p>
        <p>알고리즘 선택은 구현에 맡기지만(표준에서 강제하지 않음) IEEE 754-2019 산술 근사 알고리즘을 포함하는 Sun Microsystems 의 자유 배포 수학 라이브러리 `fdlibm` 사용이 권장된다 (<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>).</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>_x_ 의 절대값을 반환한다; 결과는 부호만 양수이고 크기는 _x_ 와 동일하다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 *-0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 -_n_ 반환.
          1. _n_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acos">
        <h1>Math.acos ( _x_ )</h1>
        <p>_x_ 의 아크코사인(역코사인)을 반환한다. 결과는 라디안으로 표현되며 *+0*<sub>𝔽</sub> 이상 𝔽(π) 이하 구간에 있다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN* 이거나 _n_ > *1*<sub>𝔽</sub> 이거나 _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. _n_ 이 *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 역코사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>_x_ 의 역쌍곡코사인(acosh)을 반환한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN* 이거나 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ 이 *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 역쌍곡코사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asin">
        <h1>Math.asin ( _x_ )</h1>
        <p>_x_ 의 아크사인(역사인)을 반환한다. 결과는 라디안이며 𝔽(-π / 2) 이상 𝔽(π / 2) 이하 구간에 있다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ > *1*<sub>𝔽</sub> 또는 _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 역사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>_x_ 의 역쌍곡사인(asinh)을 반환한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 finite 가 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 _n_ 반환.
          1. ℝ(_n_) 의 역쌍곡사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan">
        <h1>Math.atan ( _x_ )</h1>
        <p>_x_ 의 아크탄젠트(역탄젠트)를 반환한다. 결과는 라디안이며 𝔽(-π / 2) 이상 𝔽(π / 2) 이하 구간.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ 이 *+∞*<sub>𝔽</sub> 이면 π / 2 를 나타내는 구현 근사 Number 값 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 -π / 2 를 나타내는 구현 근사 Number 값 반환.
          1. ℝ(_n_) 의 역탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>_x_ 의 역쌍곡탄젠트(atanh)를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ > *1*<sub>𝔽</sub> 또는 _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. _n_ 이 *1*<sub>𝔽</sub> 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _n_ 이 *-1*<sub>𝔽</sub> 이면 *-∞*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 역쌍곡탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan2">
        <h1>Math.atan2 ( _y_, _x_ )</h1>
        <p>두 인수 _y_, _x_ 의 몫 <emu-eqn>_y_ / _x_</emu-eqn> 에 대한 역탄젠트를 반환하며, _y_ 와 _x_ 의 부호를 사용해 사분면을 결정한다. 2인수 역탄젠트에서 _y_ 가 첫 번째, _x_ 가 두 번째 인수인 것은 의도적이며 전통이다. 결과는 라디안으로 -π 이상 +π 이하 구간.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _ny_ = ? ToNumber(_y_).
          1. _nx_ = ? ToNumber(_x_).
          1. _ny_ 또는 _nx_ 가 *NaN* 이면 *NaN* 반환.
          1. _ny_ = *+∞*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 π / 4 근사값 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 3π / 4 근사값 반환.
            1. 그렇지 않으면 π / 2 근사값 반환.
          1. _ny_ = *-∞*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 -π / 4 근사값 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 -3π / 4 근사값 반환.
            1. 그렇지 않으면 -π / 2 근사값 반환.
          1. _ny_ = *+0*<sub>𝔽</sub> 이면
            1. _nx_ > *+0*<sub>𝔽</sub> 또는 _nx_ = *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
            1. 그렇지 않으면 π 근사값 반환.
          1. _ny_ = *-0*<sub>𝔽</sub> 이면
            1. _nx_ > *+0*<sub>𝔽</sub> 또는 _nx_ = *+0*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
            1. 그렇지 않으면 -π 근사값 반환.
          1. 단언: _ny_ 는 finite 이고 ±0 아님.
          1. _ny_ > *+0*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 π 근사값 반환.
            1. _nx_ 가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 π / 2 근사값 반환.
          1. _ny_ &lt; *-0*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 -π 근사값 반환.
            1. _nx_ 가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 -π / 2 근사값 반환.
          1. 단언: _nx_ 는 finite 이고 ±0 아님.
          1. _r_ 를 abs(ℝ(_ny_)/ℝ(_nx_)) 의 역탄젠트로 둔다.
          1. _nx_ &lt; *-0*<sub>𝔽</sub> 이면
            1. _ny_ > *+0*<sub>𝔽</sub> 이면 _r_ = π - _r_.
            1. 그렇지 않으면 _r_ = -π + _r_.
          1. 그렇지 않으면
            1. _ny_ &lt; *-0*<sub>𝔽</sub> 이면 _r_ = -_r_.
          1. _r_ 를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>_x_ 의 세제곱근을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 _n_ 반환.
          1. ℝ(_n_) 의 세제곱근을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>_x_ 보다 작지 않은 가장 작은( -∞ 에 가장 가까운 ) 정수 Number 값을 반환한다. _x_ 가 이미 정수이면 결과는 _x_.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이고 _n_ > *-1*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
          1. _n_ 이 정수이면 _n_ 반환.
          1. _n_ 보다 작지 않은 가장 작은 정수 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.ceil(x)` 값은 `-Math.floor(-x)` 값과 같다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.clz32">
        <h1>Math.clz32 ( _x_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ = ? ToUint32(_x_).
          1. _p_ 를 _n_ 의 부호 없는 32비트 이진 표현에서 선행 0 비트 개수로 둔다.
          1. 𝔽(_p_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_n_ 이 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 *32*<sub>𝔽</sub> 반환. 최상위 비트가 1 이면 *+0*<sub>𝔽</sub> 반환.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cos">
        <h1>Math.cos ( _x_ )</h1>
        <p>라디안 인수 _x_ 의 코사인을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니면 *NaN* 반환.
          1. _n_ 이 ±0 이면 *1*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 코사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>_x_ 의 쌍곡코사인을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 ±∞ 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *1*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 쌍곡코사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.cosh(x)` = `(Math.exp(x) + Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>_x_ 의 지수 함수(_e_^_x_) 값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ 이 ±0 이면 *1*<sub>𝔽</sub> 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 지수 함수를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>_e_^_x_ - 1 값을, _x_ 가 0 에 가까운 경우에도 정확하게 계산해 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. _exp_ 를 ℝ(_n_) 의 지수 함수 값으로 둔다.
          1. _exp_ - 1 을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>_x_ 보다 크지 않은 가장 큰( +∞ 에 가장 가까운 ) 정수 Number 값을 반환. 이미 정수이면 _x_.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. _n_ &lt; *1*<sub>𝔽</sub> 그리고 _n_ > *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 정수이면 _n_ 반환.
          1. _n_ 보다 크지 않은 가장 큰 정수 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.floor(x)` = `-Math.ceil(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.fround">
        <h1>Math.fround ( _x_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 ±0, ±∞ 중 하나이면 _n_ 반환.
          1. _n32_ = _n_ 을 roundTiesToEven 모드로 IEEE 754-2019 binary32 로 변환한 결과.
          1. _n64_ = _n32_ 를 IEEE 754-2019 binary64 로 변환한 결과.
          1. _n64_ 에 대응하는 ECMAScript Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.f16round">
        <h1>Math.f16round ( _x_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 ±0, ±∞ 중 하나이면 _n_ 반환.
          1. _n16_ = _n_ 을 roundTiesToEven 모드로 IEEE 754-2019 binary16 으로 변환한 결과.
          1. _n64_ = _n16_ 을 IEEE 754-2019 binary64 로 변환한 결과.
          1. _n64_ 에 대응하는 ECMAScript Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>이 연산은 먼저 binary32 로 변환 후 binary16 으로 변환하는 것과 다르다(이중 반올림 가능성). 예: _k_ = *1.00048828125000022204*<sub>𝔽</sub> 에 대해 Math.f16round(_k_) 는 *1.0009765625*<sub>𝔽</sub> 이지만 Math.f16round(Math.fround(_k_)) 는 *1*<sub>𝔽</sub> 이다.</p>
          <p>모든 플랫폼이 binary64→binary16 캐스팅을 네이티브 지원하지는 않는다. MIT 라이선스 <a href="https://half.sourceforge.net/">half</a> 라이브러리 등 사용 가능. 또는 binary64→binary32 (roundTiesToEven) 후 잘못된 이중 반올림 가능성 검사, 해당 경우 mantissa 조정(odd 라운드에 해당) 후 최종 binary16 캐스팅 등으로 구현 가능.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( ..._args_ )</h1>
        <p>0개 이상의 인수에 대해 제곱들의 합의 제곱근을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _coerced_ = 새 빈 리스트.
          1. _args_ 각 _arg_ 에 대해
            1. _n_ = ? ToNumber(_arg_).
            1. _coerced_ 에 _n_ 추가.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 ±∞ 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _onlyZero_ = *true*.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 *NaN* 이면 *NaN* 반환.
            1. _number_ 가 *+0*<sub>𝔽</sub> 도 *-0*<sub>𝔽</sub> 도 아니면 _onlyZero_ = *false*.
          1. _onlyZero_ 가 *true* 이면 *+0*<sub>𝔽</sub> 반환.
          1. _coerced_ 요소들의 수학적 값 각각 제곱 합의 제곱근을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
        <emu-note>
          <p>두 개 이상 인수 시 단순 구현에서 발생하기 쉬운 overflow/underflow 로 인한 정밀도 손실을 피해야 한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.imul">
        <h1>Math.imul ( _x_, _y_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _a_ = ℝ(? ToUint32(_x_)).
          1. _b_ = ℝ(? ToUint32(_y_)).
          1. _product_ = (_a_ × _b_) mod 2<sup>32</sup>.
          1. _product_ ≥ 2<sup>31</sup> 이면 𝔽(_product_ - 2<sup>32</sup>) 반환; 아니면 𝔽(_product_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>_x_ 의 자연로그를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ = *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 자연로그를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>1 + _x_ 의 자연로그를 반환하며 _x_ 가 0 에 매우 가까울 때도 정확하도록 계산된다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ = *-1*<sub>𝔽</sub> 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. 1 + ℝ(_n_) 의 자연로그를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>_x_ 의 밑 10 로그를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ = *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 밑 10 로그 구현 근사 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>_x_ 의 밑 2 로그를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ = *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 밑 2 로그 구현 근사 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( ..._args_ )</h1>
        <p>0개 이상의 인수에 대해 각 인수에 ToNumber 를 적용한 결과 중 최댓값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _coerced_ = 새 빈 리스트.
          1. _args_ 각 _arg_ 에 대해
            1. _n_ = ? ToNumber(_arg_).
            1. _coerced_ 에 _n_ 추가.
          1. _highest_ = *-∞*<sub>𝔽</sub>.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 *NaN* 이면 *NaN* 반환.
            1. _number_ = *+0*<sub>𝔽</sub> 이고 _highest_ = *-0*<sub>𝔽</sub> 이면 _highest_ = *+0*<sub>𝔽</sub>.
            1. _number_ > _highest_ 이면 _highest_ = _number_.
          1. _highest_ 반환.
        </emu-alg>
        <emu-note>
          <p>최댓값 비교는 IsLessThan 알고리즘을 사용하되 *+0*<sub>𝔽</sub> 를 *-0*<sub>𝔽</sub> 보다 큰 것으로 간주한다.</p>
        </emu-note>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( ..._args_ )</h1>
        <p>0개 이상의 인수에 대해 각 인수에 ToNumber 를 적용한 결과 중 최솟값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _coerced_ = 새 빈 리스트.
          1. _args_ 각 _arg_ 에 대해
            1. _n_ = ? ToNumber(_arg_).
            1. _coerced_ 에 _n_ 추가.
          1. _lowest_ = *+∞*<sub>𝔽</sub>.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 *NaN* 이면 *NaN* 반환.
            1. _number_ = *-0*<sub>𝔽</sub> 이고 _lowest_ = *+0*<sub>𝔽</sub> 이면 _lowest_ = *-0*<sub>𝔽</sub>.
            1. _number_ &lt; _lowest_ 이면 _lowest_ = _number_.
          1. _lowest_ 반환.
        </emu-alg>
        <emu-note>
          <p>최솟값 결정 비교도 IsLessThan 을 사용하되 *+0*<sub>𝔽</sub> 를 *-0*<sub>𝔽</sub> 보다 큰 것으로 취급한다.</p>
        </emu-note>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _base_ = ? ToNumber(_base_).
          1. _exponent_ = ? ToNumber(_exponent_).
          1. Number::exponentiate(_base_, _exponent_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.random">
        <h1>Math.random ( )</h1>
        <p>*+0*<sub>𝔽</sub> 이상 *1*<sub>𝔽</sub> 미만 구간에서 양의 부호를 가지는 Number 값을 (구현 정의 알고리즘/전략으로) 균등 분포에 가깝게 무작위 또는 의사난수로 반환한다.</p>
        <p>서로 다른 realm 에 대해 생성된 각 `Math.random` 함수는 연속 호출에서 서로 다른 수열을 생성해야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>_x_ 에 가장 가까운 정수 Number 값을 반환한다. 두 정수가 동일하게 가깝다면 +∞ 에 더 가까운 값을 반환. _x_ 가 이미 정수면 _x_ 반환.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 정수이면 _n_ 반환.
          1. _n_ &lt; *0.5*<sub>𝔽</sub> 그리고 _n_ > *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 그리고 _n_ ≥ *-0.5*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
          1. _n_ 과 가장 가까운 정수 Number 값을 반환(동일 거리면 +∞ 쪽 선택).
        </emu-alg>
        <emu-note>
          <p>`Math.round(3.5)` 는 4, `Math.round(-3.5)` 는 -3.</p>
        </emu-note>
        <emu-note>
          <p>`Math.round(x)` 는 항상 `Math.floor(x + 0.5)` 와 같지 않다. 예를 들어 _x_ 가 *-0*<sub>𝔽</sub> 이거나 *-0*<sub>𝔽</sub> 보다 작고 *-0.5*<sub>𝔽</sub> 이상이면 `Math.round(x)` 는 *-0*<sub>𝔽</sub> 반환하지만 `Math.floor(x + 0.5)` 는 *+0*<sub>𝔽</sub> 를 반환. 또한 내부 반올림으로 인해 차이날 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>_x_ 의 부호(양수/음수/0)를 나타내는 값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. *1*<sub>𝔽</sub> 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sin">
        <h1>Math.sin ( _x_ )</h1>
        <p>라디안 인수 _x_ 의 사인 값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ 이 ±∞ 이면 *NaN* 반환.
          1. ℝ(_n_) 의 사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>_x_ 의 쌍곡사인을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. ℝ(_n_) 의 쌍곡사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.sinh(x)` = `(Math.exp(x) - Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>_x_ 의 제곱근을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. 𝔽(ℝ(_n_) 의 제곱근) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sumprecise">
        <h1>Math.sumPrecise ( _items_ )</h1>
        <p>Number 들로 이루어진 iterable 을 받아 모든 값을 더해 합을 반환한다. 어떤 값이 Number 가 아니면 *TypeError* 예외를 던진다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_items_) 수행.
          1. _iteratorRecord_ = ? GetIterator(_items_, ~sync~).
          1. _state_ = ~minus-zero~.
          1. _sum_ = 0.
          1. _count_ = 0.
          1. _next_ = ~not-started~.
          1. _next_ 가 ~done~ 이 아닐 동안 반복
            1. _next_ = ? IteratorStepValue(_iteratorRecord_).
            1. _next_ 가 ~done~ 이 아니면
              1. _count_ ≥ 2<sup>53</sup> - 1 이면
                1. NOTE: 현실적으로 도달하지 않는 단계이며 입력이 “적당한 크기” 임을 가정 가능하게 하기 위한 것.
                1. _error_ = ThrowCompletion(새 *RangeError* 객체).
                1. ? IteratorClose(_iteratorRecord_, _error_) 반환.
              1. _next_ 가 Number 가 아니면
                1. _error_ = ThrowCompletion(새 *TypeError* 객체).
                1. ? IteratorClose(_iteratorRecord_, _error_) 반환.
              1. _n_ = _next_.
              1. _state_ ≠ ~not-a-number~ 이면
                1. _n_ 이 *NaN* 이면
                  1. _state_ = ~not-a-number~.
                1. Else if _n_ = *+∞*<sub>𝔽</sub>
                  1. _state_ = ~minus-infinity~ 이면 ~not-a-number~, 아니면 ~plus-infinity~.
                1. Else if _n_ = *-∞*<sub>𝔽</sub>
                  1. _state_ = ~plus-infinity~ 이면 ~not-a-number~, 아니면 ~minus-infinity~.
                1. Else if _n_ 이 *-0*<sub>𝔽</sub> 가 아니고 _state_ 가 ~minus-zero~ 또는 ~finite~ 이면
                  1. _state_ = ~finite~.
                  1. _sum_ = _sum_ + ℝ(_n_).
              1. _count_ = _count_ + 1.
          1. _state_ = ~not-a-number~ 이면 *NaN* 반환.
          1. _state_ = ~plus-infinity~ 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _state_ = ~minus-infinity~ 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _state_ = ~minus-zero~ 이면 *-0*<sub>𝔽</sub> 반환.
          1. 𝔽(_sum_) 반환.
        </emu-alg>
        <emu-note>
          <p>_sum_ 은 임의 정밀도 산술 없이 여러 알고리즘으로 계산 가능. 예: Jonathan Richard Shewchuk 의 <i>Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates</i> 에 나오는 "Grow-Expansion" 알고리즘. 또는 "<a href="https://arxiv.org/abs/1505.05571">Fast exact summation using small and large superaccumulators</a>" (코드: <a href="https://gitlab.com/radfordneal/xsum">https://gitlab.com/radfordneal/xsum</a>).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.tan">
        <h1>Math.tan ( _x_ )</h1>
        <p>라디안 인수 _x_ 의 탄젠트를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ 이 ±∞ 이면 *NaN* 반환.
          1. ℝ(_n_) 의 탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>_x_ 의 쌍곡탄젠트를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ = *+∞*<sub>𝔽</sub> 이면 *1*<sub>𝔽</sub> 반환.
          1. _n_ = *-∞*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 쌍곡탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.tanh(x)` = `(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>_x_ 의 정수 부분(소수부 제거)을 반환. _x_ 가 이미 정수이면 _x_ 반환.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. _n_ &lt; *1*<sub>𝔽</sub> 그리고 _n_ > *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 그리고 _n_ > *-1*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
          1. *+0*<sub>𝔽</sub> 방향으로 _n_ 에 가장 가까운 정수 Number 값 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date 객체</h1>

    <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
      <h1>Date 객체 개요 및 추상 연산 정의</h1>
      <p>다음의 추상 연산들은 시간 값(<emu-xref href="#sec-time-values-and-time-range"></emu-xref>에서 정의됨)에 대해 동작합니다. 모든 경우에 이 함수들에 인수로 *NaN*이 들어오면 결과도 *NaN*이 됨을 유의하세요.</p>

      <emu-clause id="sec-time-values-and-time-range">
        <h1>시간 값과 시간 범위</h1>
        <p>ECMAScript의 시간 측정은 POSIX의 시간 측정과 유사하며, 특히 전환 그레고리력(proleptic Gregorian calendar), 1970년 1월 1일 0시 UTC의 <dfn id="epoch">기점(epoch)</dfn>, 그리고 하루가 정확히 86,400초(각 초는 1000밀리초)로 구성된다는 정의를 공유합니다.</p>
        <p>ECMAScript의 <dfn variants="time values">시간 값</dfn>은 Number로, 밀리초 단위의 한 순간을 나타내는 유한 정수 Number이거나 특정 순간을 나타내지 않는 *NaN*일 수 있습니다. <emu-eqn>24 × 60 × 60 × 1000 = 86,400,000</emu-eqn>의 배수(즉, 정수 _d_에 대해 86,400,000 × _d_)인 시간 값은 기점 이후 _d_일이 지난 UTC 일의 시작 순간(음수 _d_라면 기점 이전)을 나타냅니다. 그 외의 유한 시간 값 _t_는 그와 가장 가까운 이전 배수 시간 값 _s_를 기준으로 정의되며, _s_와 동일한 UTC 일 내에서 (_t_ - _s_) 밀리초가 지난 순간을 나타냅니다.</p>
        <p>시간 값은 UTC 윤초(leap seconds)를 고려하지 않습니다—양의 윤초 내의 순간을 나타내는 시간 값은 없으며, 음의 윤초로 인해 UTC 타임라인에서 제거된 순간을 나타내는 시간 값은 있습니다. 그럼에도 불구하고 시간 값의 정의는 윤초 경계에서만 불연속이 있고 그 외에는 UTC와 부분적으로 일치함을 보장합니다.</p>
        <p>Number는 -9,007,199,254,740,992에서 9,007,199,254,740,992(<emu-xref href="#sec-number.min_safe_integer"></emu-xref> 및 <emu-xref href="#sec-number.max_safe_integer"></emu-xref> 참고)까지의 모든 정수를 정확하게 표현할 수 있습니다. 시간 값은 -8,640,000,000,000,000에서 8,640,000,000,000,000 밀리초까지의 약간 더 작은 범위를 지원합니다. 이는 1970년 1월 1일 0시 UTC 기준으로 -100,000,000일부터 100,000,000일까지의 시간 값 범위를 제공합니다.</p>
        <p>1970년 1월 1일 0시 UTC의 정확한 순간은 시간 값 *+0*<sub>𝔽</sub>으로 표현됩니다.</p>
        <emu-note>
          <p>전환 그레고리력에서는 윤년이 4로 나누어떨어지고, 400으로 나누어떨어지거나 100으로 나누어떨어지지 않는 해입니다.</p>
          <p>전환 그레고리력의 400년 주기에는 97번의 윤년이 있습니다. 평균적으로 연간 365.2425일, 즉 31,556,952,000 밀리초가 됩니다. 따라서 Number가 밀리초 단위로 정확하게 표현할 수 있는 최대 범위는 1970년 기준으로 약 -285,426년에서 285,426년입니다. 이 절에서 명시된 시간 값의 더 작은 범위는 약 -273,790년에서 273,790년(1970년 기준)입니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-related-constants">
        <h1>시간 관련 상수</h1>
        <p>이 상수들은 다음 섹션의 알고리즘에서 참조됩니다.</p>
        <emu-eqn id="eqn-HoursPerDay" aoid="HoursPerDay">HoursPerDay = 24</emu-eqn>
        <emu-eqn id="eqn-MinutesPerHour" aoid="MinutesPerHour">MinutesPerHour = 60</emu-eqn>
        <emu-eqn id="eqn-SecondsPerMinute" aoid="SecondsPerMinute">SecondsPerMinute = 60</emu-eqn>
        <emu-eqn id="eqn-msPerSecond" aoid="msPerSecond">msPerSecond = *1000*<sub>𝔽</sub></emu-eqn>
        <emu-eqn id="eqn-msPerMinute" aoid="msPerMinute">msPerMinute = *60000*<sub>𝔽</sub> = msPerSecond × 𝔽(SecondsPerMinute)</emu-eqn>
        <emu-eqn id="eqn-msPerHour" aoid="msPerHour">msPerHour = *3600000*<sub>𝔽</sub> = msPerMinute × 𝔽(MinutesPerHour)</emu-eqn>
        <emu-eqn id="eqn-msPerDay" aoid="msPerDay">msPerDay = *86400000*<sub>𝔽</sub> = msPerHour × 𝔽(HoursPerDay)</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-day" type="abstract operation" oldids="eqn-Day,sec-day-number-and-time-within-day">
        <h1>
          Day (
            _t_: 유한한 시간 값,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 날짜의 일 번호(day number)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerDay)))를 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timewithinday" type="abstract operation" oldids="eqn-TimeWithinDay">
        <h1>
          TimeWithinDay (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub> (포함)부터 msPerDay (제외)까지의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 날짜의 시작부터 지난 밀리초 수를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(_t_) modulo ℝ(msPerDay))를 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daysinyear" type="abstract operation" oldids="eqn-DaysInYear,sec-year-number">
        <h1>
          DaysInYear (
            _y_: 정수 Number,
          ): *365*<sub>𝔽</sub> 또는 *366*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_y_년의 일(day) 수를 반환합니다. 윤년은 366일, 그 외는 365일입니다.</dd>
        </dl>
        <emu-alg>
          1. _ry_를 ℝ(_y_)로 합니다.
          1. (_ry_ modulo 400) = 0이면 *366*<sub>𝔽</sub>을 반환합니다.
          1. (_ry_ modulo 100) = 0이면 *365*<sub>𝔽</sub>을 반환합니다.
          1. (_ry_ modulo 4) = 0이면 *366*<sub>𝔽</sub>을 반환합니다.
          1. *365*<sub>𝔽</sub>을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dayfromyear" type="abstract operation" oldids="eqn-DaysFromYear">
        <h1>
          DayFromYear (
            _y_: 정수 Number,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_y_년의 첫날의 일 번호(day number)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. _ry_를 ℝ(_y_)로 합니다.
          1. [declared="numYears1,numYears4,numYears100,numYears400"] 다음 단계에서 _numYears1_, _numYears4_, _numYears100_, _numYears400_은 기점 이후 _y_년 시작까지 1, 4, 100, 400으로 나누어떨어지는 연도 수를 나타냅니다. _y_가 기점 이전이면 음수입니다.
          1. _numYears1_에 (_ry_ - 1970)을 할당합니다.
          1. _numYears4_에 floor((_ry_ - 1969) / 4)을 할당합니다.
          1. _numYears100_에 floor((_ry_ - 1901) / 100)을 할당합니다.
          1. _numYears400_에 floor((_ry_ - 1601) / 400)을 할당합니다.
          1. 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timefromyear" type="abstract operation" oldids="eqn-TimeFromYear">
        <h1>
          TimeFromYear (
            _y_: 정수 Number,
          ): 시간 값
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_y_년의 시작 순간의 시간 값을 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. msPerDay × DayFromYear(_y_)를 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yearfromtime" type="abstract operation" oldids="eqn-YearFromTime">
        <h1>
          YearFromTime (
            _t_: 유한한 시간 값,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 연도를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. [declared="y"] TimeFromYear(_y_) ≤ _t_를 만족하는 가장 큰 정수 _y_를 반환합니다 (+∞에 가장 가까움).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daywithinyear" type="abstract operation" oldids="eqn-DayWithinYear">
        <h1>
          DayWithinYear (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *365*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Day(_t_) - DayFromYear(YearFromTime(_t_))을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-inleapyear" type="abstract operation" oldids="eqn-InLeapYear">
        <h1>
          InLeapYear (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub> 또는 *1*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 윤년 내에 있으면 *1*<sub>𝔽</sub>, 아니면 *+0*<sub>𝔽</sub>을 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. DaysInYear(YearFromTime(_t_))이 *366*<sub>𝔽</sub>이면 *1*<sub>𝔽</sub>을, 아니면 *+0*<sub>𝔽</sub>을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-monthfromtime" type="abstract operation" oldids="eqn-MonthFromTime,sec-month-number">
        <h1>
          MonthFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *11*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 월(month)을 식별하는 Number를 반환합니다. *+0*<sub>𝔽</sub>은 1월, *1*<sub>𝔽</sub>은 2월, … *11*<sub>𝔽</sub>은 12월을 의미합니다. <emu-eqn>MonthFromTime(*+0*<sub>𝔽</sub>) = *+0*<sub>𝔽</sub></emu-eqn>은 1970년 1월 1일 목요일에 해당합니다.</dd>
        </dl>
        <emu-alg>
          1. _inLeapYear_에 InLeapYear(_t_)를 할당합니다.
          1. _dayWithinYear_에 DayWithinYear(_t_)를 할당합니다.
          1. _dayWithinYear_ &lt; *31*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *59*<sub>𝔽</sub> + _inLeapYear_이면 *1*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *90*<sub>𝔽</sub> + _inLeapYear_이면 *2*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *120*<sub>𝔽</sub> + _inLeapYear_이면 *3*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *151*<sub>𝔽</sub> + _inLeapYear_이면 *4*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *181*<sub>𝔽</sub> + _inLeapYear_이면 *5*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *212*<sub>𝔽</sub> + _inLeapYear_이면 *6*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *243*<sub>𝔽</sub> + _inLeapYear_이면 *7*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *273*<sub>𝔽</sub> + _inLeapYear_이면 *8*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *304*<sub>𝔽</sub> + _inLeapYear_이면 *9*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *334*<sub>𝔽</sub> + _inLeapYear_이면 *10*<sub>𝔽</sub>을 반환합니다.
          1. Assert: _dayWithinYear_ &lt; *365*<sub>𝔽</sub> + _inLeapYear_.
          1. *11*<sub>𝔽</sub>을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-datefromtime" type="abstract operation" oldids="sec-date-number">
        <h1>
          DateFromTime (
            _t_: 유한한 시간 값,
          ): *1*<sub>𝔽</sub>부터 *31*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 월의 날짜(day of month)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. _inLeapYear_에 InLeapYear(_t_)를 할당합니다.
          1. _dayWithinYear_에 DayWithinYear(_t_)를 할당합니다.
          1. _month_에 MonthFromTime(_t_)를 할당합니다.
          1. _month_가 *+0*<sub>𝔽</sub>이면 _dayWithinYear_ + *1*<sub>𝔽</sub>을 반환합니다.
          1. _month_가 *1*<sub>𝔽</sub>이면 _dayWithinYear_ - *30*<sub>𝔽</sub>을 반환합니다.
          1. _month_가 *2*<sub>𝔽</sub>이면 _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *3*<sub>𝔽</sub>이면 _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *4*<sub>𝔽</sub>이면 _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *5*<sub>𝔽</sub>이면 _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *6*<sub>𝔽</sub>이면 _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *7*<sub>𝔽</sub>이면 _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *8*<sub>𝔽</sub>이면 _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *9*<sub>𝔽</sub>이면 _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *10*<sub>𝔽</sub>이면 _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. Assert: _month_가 *11*<sub>𝔽</sub>임을 보장합니다.
          1. _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weekday" type="abstract operation" oldids="sec-week-day">
        <h1>
          WeekDay (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *6*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 요일(week day)을 식별하는 Number를 반환합니다. *+0*<sub>𝔽</sub>은 일요일, *1*<sub>𝔽</sub>은 월요일, … *6*<sub>𝔽</sub>은 토요일을 의미합니다. <emu-eqn>WeekDay(*+0*<sub>𝔽</sub>) = *4*<sub>𝔽</sub></emu-eqn>은 1970년 1월 1일 목요일에 해당합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hourfromtime" type="abstract operation" oldids="eqn-HourFromTime,sec-hours-minutes-second-and-milliseconds">
        <h1>
          HourFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *23*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 시(hour)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-minfromtime" type="abstract operation" oldids="eqn-MinFromTime">
        <h1>
          MinFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *59*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 분(minute)을 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-secfromtime" type="abstract operation" oldids="eqn-SecFromTime">
        <h1>
          SecFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *59*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_t_가 속한 분(minute)의 초(second)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-msfromtime" type="abstract operation" oldids="eqn-msFromTime">
        <h1>
          msFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *999*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_t_가 속한 초(second)의 밀리초(millisecond)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(_t_) modulo ℝ(msPerSecond))를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getutcepochnanoseconds" type="abstract operation">
        <h1>
          GetUTCEpochNanoseconds (
            _year_: 정수,
            _month_: 1~12의 정수,
            _day_: 1~31의 정수,
            _hour_: 0~23의 정수,
            _minute_: 0~59의 정수,
            _second_: 0~59의 정수,
            _millisecond_: 0~999의 정수,
            _microsecond_: 0~999의 정수,
            _nanosecond_: 0~999의 정수,
          ): BigInt
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>반환 값은 주어진 ISO 8601 달력 날짜와 UTC 벽시계 시간에 해당하는 기점(epoch) 이후의 나노초 수를 나타냅니다.</dd>
        </dl>
        <emu-alg>
          1. _date_를 MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_))로 한다.
          1. _time_을 MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_))로 한다.
          1. _ms_를 MakeDate(_date_, _time_)로 한다.
          1. Assert: _ms_는 정수 Number이다.
          1. ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifiers">
        <h1>시간대 식별자</h1>

        <p>
          ECMAScript에서 시간대는 <dfn variants="time zone identifier">시간대 식별자</dfn>로 표현되며, 이는 0x0000~0x007F의 코드 유닛으로만 구성된 문자열입니다.
          ECMAScript 구현이 지원하는 시간대는 <dfn variants="available named time zone">사용 가능한 명명된 시간대</dfn>일 수 있고, 이는 AvailableNamedTimeZoneIdentifiers가 반환하는 시간대 식별자 레코드의 [[Identifier]] 필드로 표현됩니다. 또는 <dfn variants="offset time zone">오프셋 시간대</dfn>일 수 있고, 이는 IsTimeZoneOffsetString이 *true*를 반환하는 문자열로 표현됩니다.
        </p>
        <p>
          <dfn variants="primary time zone identifiers">기본 시간대 식별자</dfn>는 사용 가능한 명명된 시간대의 대표 식별자입니다.
          <dfn variants="non-primary time zone identifiers">비기본 시간대 식별자</dfn>는 명명된 시간대를 나타내지만 기본 식별자가 아닌 식별자입니다.
          <dfn variants="available named time zone identifiers">사용 가능한 명명된 시간대 식별자</dfn>는 기본 또는 비기본 식별자입니다.
          각 사용 가능한 명명된 시간대 식별자는 정확히 하나의 명명된 시간대와 연결됩니다.
          각 명명된 시간대는 정확히 하나의 기본 시간대 식별자와 0개 이상의 비기본 식별자와 연결됩니다.
        </p>
        <p>
          ECMAScript 구현은 *"UTC"* 식별자를 가진 명명된 시간대를 지원해야 하며, 이는 UTC 시간대의 기본 식별자여야 합니다.
          추가로, 구현은 다른 명명된 시간대를 임의로 지원할 수 있습니다.
        </p>
        <p>
          ECMA-402 국제화 API 명세의 시간대 요구 사항을 따르는 구현은 <dfn>시간대 지원 구현(time zone aware)</dfn>이라고 합니다.
          시간대 지원 구현은 IANA Time Zone Database의 Zone 및 Link 이름에 해당하는 명명된 시간대를 지원해야 하며, 오직 그러한 이름만 지원해야 합니다.
          시간대 지원 구현에서는 기본 식별자가 Zone 이름, 비기본 식별자가 Link 이름에 해당합니다(ECMA-402에서 특별히 재정의한 경우 제외).
          전체 IANA Time Zone Database를 지원하지 않더라도 IANA 이름을 식별자로 사용하는 것이 권장됩니다.
        </p>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneepochnanoseconds" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneEpochNanoseconds (
            _timeZoneIdentifier_: 문자열,
            _year_: 정수,
            _month_: 1~12의 정수,
            _day_: 1~31의 정수,
            _hour_: 0~23의 정수,
            _minute_: 0~59의 정수,
            _second_: 0~59의 정수,
            _millisecond_: 0~999의 정수,
            _microsecond_: 0~999의 정수,
            _nanosecond_: 0~999의 정수,
          ): BigInt 리스트
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            반환되는 리스트의 각 값은 _timeZoneIdentifier_로 지정된 명명된 시간대에서 주어진 ISO 8601 달력 날짜와 벽시계 시간에 해당하는 기점(epoch) 이후의 나노초 수를 나타냅니다.
          </dd>
        </dl>
        <p>
          입력값이 음의 시간대 전환(예: 서머타임 종료나 시간대 오프셋 감소) 때문에 지역 시간이 두 번 발생하면, 반환 리스트에 두 개 이상의 요소가 들어가고 오름차순으로 정렬됩니다.
          입력값이 양의 시간대 전환(예: 서머타임 시작이나 시간대 오프셋 증가) 때문에 지역 시간이 건너뛰어진 경우, 반환 리스트는 비어 있습니다.
          그 외에는 반환 리스트에 하나의 요소가 들어갑니다.
        </p>
        <p>지역 정치적 규칙이 없는 ECMAScript 구현에서 사용하는 GetNamedTimeZoneEpochNanoseconds 기본 구현은 다음과 같은 단계로 동작합니다:</p>
        <emu-alg>
          1. Assert: _timeZoneIdentifier_가 *"UTC"*임을 보장한다.
          1. _epochNanoseconds_를 GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_)로 한다.
          1. « _epochNanoseconds_ »를 반환한다.
        </emu-alg>
        <emu-note>
          <p>시간대 지원 구현(및 모든 구현에 권장됨)은 IANA Time Zone Database의 시간대 정보를 사용해야 합니다 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>2017년 11월 5일 America/New_York의 오전 1:30은 두 번 반복되므로, GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 11, 5, 1, 30, 0, 0, 0, 0)은 길이 2인 리스트를 반환하며 첫 번째 요소는 05:30 UTC(미국 동부 일광절약시 UTC-04:00의 01:30)에, 두 번째 요소는 06:30 UTC(미국 동부 표준시 UTC-05:00의 01:30)에 해당합니다.</p>
          <p>2017년 3월 12일 America/New_York의 오전 2:30은 존재하지 않으므로, GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 3, 12, 2, 30, 0, 0, 0, 0)은 빈 리스트를 반환합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneoffsetnanoseconds" oldids="sec-local-time-zone-adjustment" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneOffsetNanoseconds (
            _timeZoneIdentifier_: 문자열,
            _epochNanoseconds_: BigInt,
          ): 정수
        </h1>
        <dl class="header">
        </dl>
        <p>반환되는 정수는 _timeZoneIdentifier_로 지정된 명명된 시간대에서, _epochNanoseconds_에 해당하는 순간의 UTC로부터의 오프셋(나노초 단위)을 나타냅니다.</p>
        <p>지역 정치적 규칙이 없는 ECMAScript 구현에서 사용하는 기본 구현은 다음과 같이 동작합니다:</p>
        <emu-alg>
          1. Assert: _timeZoneIdentifier_가 *"UTC"*임을 보장한다.
          1. 0을 반환한다.
        </emu-alg>
        <emu-note>
          <p>시간대 오프셋 값은 양수일 수도 음수일 수도 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifier-record">
        <h1>시간대 식별자 레코드</h1>
        <p><dfn variants="Time Zone Identifier Records">시간대 식별자 레코드</dfn>는 사용 가능한 명명된 시간대 식별자와 해당 기본 시간대 식별자를 설명하는 데 사용되는 레코드입니다.</p>
        <p>시간대 식별자 레코드는 <emu-xref href="#table-time-zone-identifier-record-fields"></emu-xref>에 나열된 필드를 가집니다.</p>
        <emu-table id="table-time-zone-identifier-record-fields" caption="시간대 식별자 레코드 필드">
          <table>
            <thead>
              <tr>
                <th>필드 이름</th>
                <th>값</th>
                <th>의미</th>
              </tr>
            </thead>
            <tr>
              <td>[[Identifier]]</td>
              <td>문자열</td>
              <td>구현에서 지원하는 사용 가능한 명명된 시간대 식별자입니다.</td>
            </tr>
            <tr>
              <td>[[PrimaryIdentifier]]</td>
              <td>문자열</td>
              <td>[[Identifier]]가 resolve되는 기본 시간대 식별자입니다.</td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>[[Identifier]]가 기본 시간대 식별자라면, [[Identifier]]는 [[PrimaryIdentifier]]입니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-availablenamedtimezoneidentifiers" type="implementation-defined abstract operation">
        <h1>AvailableNamedTimeZoneIdentifiers ( ): 시간대 식별자 레코드 리스트</h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            결과는 이 구현에서 사용 가능한 모든 명명된 시간대 식별자와, 각 명명된 시간대 식별자에 해당하는 기본 시간대 식별자를 설명합니다.
            리스트는 각 시간대 식별자 레코드의 [[Identifier]] 필드 기준으로 정렬됩니다.
          </dd>
        </dl>
        <p>
          ECMA-402 국제화 API를 구현하는 모든 시간대 지원 구현은 ECMA-402 명세에 따라 AvailableNamedTimeZoneIdentifiers 추상 연산을 구현해야 합니다.
          시간대 지원하지 않는 구현에서는 다음과 같이 동작합니다:
        </p>
        <emu-alg>
          1. 구현에 지역 정치적 규칙이 없으면,
            1. « 시간대 식별자 레코드 { [[Identifier]]: *"UTC"*, [[PrimaryIdentifier]]: *"UTC"* } »를 반환한다.
          1. _identifiers_를 고유한 사용 가능한 명명된 시간대 식별자 리스트(코드 유닛 사전순으로 정렬)로 한다.
          1. _result_를 새로운 빈 리스트로 한다.
          1. 각 _identifiers_의 요소 _identifier_에 대해,
            1. _primary_를 _identifier_로 한다.
            1. _identifier_가 이 구현에서 비기본 시간대 식별자이고 *"UTC"*가 아니면,
              1. _primary_를 _identifier_와 연결된 기본 시간대 식별자로 설정한다.
              1. NOTE: 기본 식별자를 얻기 위해 _identifier_를 반복적으로 resolve해야 할 수도 있다.
            1. _record_를 시간대 식별자 레코드 { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }로 한다.
            1. _result_에 _record_를 추가한다.
          1. Assert: _result_에 [[Identifier]]가 *"UTC"*이고 [[PrimaryIdentifier]]도 *"UTC"*인 레코드 _r_가 포함됨을 보장한다.
          1. _result_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-systemtimezoneidentifier" oldids="sec-defaulttimezone" type="implementation-defined abstract operation">
        <h1>SystemTimeZoneIdentifier ( ): 문자열</h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            호스트 환경의 현재 시간대를 나타내는 문자열을 반환합니다. 이 문자열은 IsTimeZoneOffsetString이 *true*를 반환하는 UTC 오프셋을 나타내거나, 기본 시간대 식별자일 수 있습니다.
          </dd>
        </dl>

        <emu-alg>
          1. 구현이 UTC 시간대만 지원하면 *"UTC"*를 반환한다.
          1. _systemTimeZoneString_을 호스트 환경의 현재 시간대를 나타내는 문자열(기본 시간대 식별자 또는 오프셋 시간대 식별자)로 한다.
          1. _systemTimeZoneString_을 반환한다.
        </emu-alg>

        <emu-note>
          <p>
            Date 객체의 메서드가 일반적으로 제공하는 기능 수준을 보장하려면, SystemTimeZoneIdentifier가 호스트 환경의 시간대 설정에 대응하는 IANA 시간대 이름을 반환하는 것이 권장됩니다(존재한다면).
            GetNamedTimeZoneEpochNanoseconds와 GetNamedTimeZoneOffsetNanoseconds는 해당 시간대의 표준시 및 서머타임에 대한 지역 정치적 규칙을 반영해야 합니다(존재한다면).
          </p>
          <p>예를 들어, 호스트 환경이 미국 동부 시간대로 설정된 브라우저라면 SystemTimeZoneIdentifier는 *"America/New_York"*을 반환합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-localtime" type="abstract operation">
        <h1>
          LocalTime (
            _t_: 유한한 시간 값,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            _t_를 UTC에서 지역 시간으로 변환합니다.
            _t_ 시점에서 적용되는 표준시 및 서머타임에 대한 지역 정치적 규칙을 적용하여 결과를 결정해야 합니다.
          </dd>
        </dl>
        <emu-alg>
          1. _systemTimeZoneIdentifier_를 SystemTimeZoneIdentifier()로 한다.
          1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_)이 *true*이면
            1. _offsetNs_를 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)로 한다.
          1. 그렇지 않으면,
            1. _offsetNs_를 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>))로 한다.
          1. _offsetMs_를 truncate(_offsetNs_ / 10<sup>6</sup>)로 한다.
          1. _t_ + 𝔽(_offsetMs_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>구현에 지역 시간 _t_에 대한 정치적 규칙이 없으면, 결과는 _t_입니다. SystemTimeZoneIdentifier가 *"UTC"*이고 GetNamedTimeZoneOffsetNanoseconds가 0을 반환하기 때문입니다.</p>
        </emu-note>
        <emu-note>
          <p>시간대 지원 구현(및 모든 구현에 권장됨)은 IANA Time Zone Database의 시간대 정보를 사용해야 합니다 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
        </emu-note>
        <emu-note>
          <p>음의 시간대 전환(예: 서머타임 종료나 시간대 조정 감소)으로 인해 지역 시간이 반복될 때 서로 다른 입력 시간 값 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>이 동일한 지역 시간 <emu-eqn>t<sub>local</sub></emu-eqn>으로 변환될 수 있습니다.</p>
          <p><emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn>이 항상 <emu-eqn>_t_<sub>local</sub></emu-eqn>과 같지 않을 수 있습니다. 이에 대응하여 <emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> 또한 항상 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>과 같지 않을 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" type="abstract operation">
        <h1>
          UTC (
            _t_: Number,
          ): 시간 값
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            _t_를 지역 시간에서 UTC 시간 값으로 변환합니다.
            _t_ 시점에서 적용되는 표준시 및 서머타임에 대한 지역 정치적 규칙을 적용하여 결과를 결정해야 합니다.
          </dd>
        </dl>
        <emu-alg>
          1. _t_가 유한하지 않으면 *NaN*을 반환한다.
          1. _systemTimeZoneIdentifier_를 SystemTimeZoneIdentifier()로 한다.
          1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_)이 *true*이면
            1. _offsetNs_를 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)로 한다.
          1. 그렇지 않으면,
            1. _possibleInstants_를 GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0)로 한다.
            1. NOTE: 다음 단계는 _t_가 음의 시간대 전환(예: 서머타임 종료나 시간대 오프셋 감소)에서 지역 시간이 여러 번 반복되거나, 양의 시간대 전환(예: 서머타임 시작이나 시간대 오프셋 증가)에서 지역 시간이 건너뛰어진 경우에, 전환 직전의 시간대 오프셋을 사용해 _t_를 해석할 수 있도록 한다.
            1. _possibleInstants_가 비어 있지 않으면
              1. _disambiguatedInstant_를 _possibleInstants_[0]로 한다.
            1. 그렇지 않으면,
              1. NOTE: _t_가 양의 시간대 전환에서 건너뛰어진 지역 시간을 나타낸다(예: 서머타임 시작이나 시간대 오프셋 증가).
              1. [declared="tBefore"] _possibleInstantsBefore_를 GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0)로 한다. 여기서 _tBefore_는 _possibleInstantsBefore_가 비어 있지 않은 가장 큰 정수(< _t_)이다(즉, _tBefore_는 전환 직전의 마지막 지역 시간을 나타낸다).
              1. _disambiguatedInstant_를 _possibleInstantsBefore_의 마지막 요소로 한다.
            1. _offsetNs_를 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_)로 한다.
          1. _offsetMs_를 truncate(_offsetNs_ / 10<sup>6</sup>)로 한다.
          1. _t_ - 𝔽(_offsetMs_)를 반환한다.
        </emu-alg>
        <p>
          입력 _t_는 명목상 시간 값이지만, 어떤 Number 값도 될 수 있습니다.
          알고리즘은 _t_를 시간 값 범위로 제한해서는 안 되며, 지역 UTC 오프셋에 관계없이 경계값에 해당하는 입력도 지원할 수 있어야 합니다.
          예를 들어, 최대 시간 값은 8.64 × 10<sup>15</sup>으로 *"+275760-09-13T00:00:00Z"*에 대응합니다.
          해당 순간의 지역 시간대 오프셋이 UTC보다 1시간 빠른 환경에서는, 입력값이 8.64 × 10<sup>15</sup> + 3.6 × 10<sup>6</sup>이 되고 이는 *"+275760-09-13T01:00:00+01:00"*에 해당합니다.
        </p>
        <p>구현에 지역 시간 _t_에 대한 정치적 규칙이 없으면, 결과는 _t_입니다. SystemTimeZoneIdentifier가 *"UTC"*이고 GetNamedTimeZoneOffsetNanoseconds가 0을 반환하기 때문입니다.</p>
        <emu-note>
          <p>시간대 지원 구현(및 모든 구현에 권장됨)은 IANA Time Zone Database의 시간대 정보를 사용해야 합니다 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>
            2017년 11월 5일 America/New_York의 오전 1:30은 두 번 반복되지만, 반드시 1:30 AM UTC-04로 해석되어야 하며 1:30 AM UTC-05로 해석되어서는 안 됩니다.
            UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))))에서 _offsetMs_ 값은 <emu-eqn>-4 × msPerHour</emu-eqn>입니다.
          </p>
          <p>
            2017년 3월 12일 America/New_York의 오전 2:30은 존재하지 않지만, 반드시 2:30 AM UTC-05(동일한 3:30 AM UTC-04와 동일)로 해석되어야 합니다.
            UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))))에서 _offsetMs_ 값은 <emu-eqn>-5 × msPerHour</emu-eqn>입니다.
          </p>
        </emu-note>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn>이 항상 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>과 같지 않을 수 있습니다. 이에 대응하여 <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> 또한 항상 <emu-eqn>_t_<sub>local</sub></emu-eqn>과 같지 않을 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-maketime" type="abstract operation">
        <h1>
          MakeTime (
            _hour_: Number,
            _min_: Number,
            _sec_: Number,
            _ms_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>밀리초 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _hour_, _min_, _sec_, _ms_가 유한하지 않으면 *NaN*을 반환한다.
          1. _h_를 𝔽(! ToIntegerOrInfinity(_hour_))로 한다.
          1. _m_을 𝔽(! ToIntegerOrInfinity(_min_))로 한다.
          1. _s_를 𝔽(! ToIntegerOrInfinity(_sec_))로 한다.
          1. _milli_를 𝔽(! ToIntegerOrInfinity(_ms_))로 한다.
          1. ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_를 반환한다.
        </emu-alg>
        <emu-note>
          <p>MakeTime의 연산은 부동소수점 연산(floating-point arithmetic)으로, 결합법칙이 성립하지 않으므로 반드시 올바른 순서로 연산해야 합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-makeday" type="abstract operation">
        <h1>
          MakeDay (
            _year_: Number,
            _month_: Number,
            _date_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>일(day) 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _year_, _month_, _date_가 유한하지 않으면 *NaN*을 반환한다.
          1. _y_를 𝔽(! ToIntegerOrInfinity(_year_))로 한다.
          1. _m_을 𝔽(! ToIntegerOrInfinity(_month_))로 한다.
          1. _dt_를 𝔽(! ToIntegerOrInfinity(_date_))로 한다.
          1. _ym_을 _y_ + 𝔽(floor(ℝ(_m_) / 12))로 한다.
          1. _ym_이 유한하지 않으면 *NaN*을 반환한다.
          1. _mn_을 𝔽(ℝ(_m_) modulo 12)로 한다.
          1. YearFromTime(_t_)가 _ym_, MonthFromTime(_t_)가 _mn_, DateFromTime(_t_)가 *1*<sub>𝔽</sub>인 유한한 시간 값 _t_를 찾는다. 단, 찾을 수 없다면(인수가 범위 밖인 경우 등) *NaN*을 반환한다.
          1. Day(_t_) + _dt_ - *1*<sub>𝔽</sub>를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makedate" type="abstract operation">
        <h1>
          MakeDate (
            _day_: Number,
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>밀리초 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _day_, _time_이 유한하지 않으면 *NaN*을 반환한다.
          1. _tv_를 _day_ × msPerDay + _time_으로 한다.
          1. _tv_가 유한하지 않으면 *NaN*을 반환한다.
          1. _tv_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makefullyear" type="abstract operation">
        <h1>
          MakeFullYear (
            _year_: Number,
          ): 정수 Number 또는 *NaN*
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_year_의 정수 부분에 해당하는 전체 연도를 반환합니다. 0~99 구간의 값은 1900년부터의 연도 수로 해석합니다. 전환 그레고리력과 일치시키기 위해, "전체 연도(full year)"는 0년(기원전 1년)부터의 부호 있는 연도 수로 정의됩니다.</dd>
        </dl>
        <emu-alg>
          1. _year_가 *NaN*이면 *NaN*을 반환한다.
          1. _truncated_를 ! ToIntegerOrInfinity(_year_)로 한다.
          1. _truncated_가 0~99 구간에 있으면 *1900*<sub>𝔽</sub> + 𝔽(_truncated_)를 반환한다.
          1. 𝔽(_truncated_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timeclip" type="abstract operation">
        <h1>
          TimeClip (
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>밀리초 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _time_이 유한하지 않으면 *NaN*을 반환한다.
          1. abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>이면 *NaN*을 반환한다.
          1. 𝔽(! ToIntegerOrInfinity(_time_))를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-time-string-format">
        <h1>날짜-시간 문자열 형식</h1>
        <p>ECMAScript는 ISO 8601 달력 날짜 확장 형식을 단순화한 날짜-시간 문자열 교환 형식을 정의합니다. 형식은 다음과 같습니다: `YYYY-MM-DDTHH:mm:ss.sssZ`</p>
        <p>각 요소의 의미는 다음과 같습니다:</p>
        <figure>
          <table class="lightweight-table">
            <tr>
              <td>
                `YYYY`
              </td>
              <td>
                전환 그레고리력의 연도. 0000~9999의 4자리 십진수, 또는 <emu-xref href="#sec-expanded-years">확장 연도(expanded year)</emu-xref>로서 *"+"* 또는 *"-"* 뒤에 6자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `-`
              </td>
              <td>
                *"-"* (하이픈)은 문자열에 두 번 그대로 나타납니다.
              </td>
            </tr>
            <tr>
              <td>
                `MM`
              </td>
              <td>
                연도의 월(month). 01(1월)~12(12월)까지 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `DD`
              </td>
              <td>
                월의 날짜(day). 01~31의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `T`
              </td>
              <td>
                *"T"*는 문자열에 그대로 나타나며, 시간 요소의 시작임을 나타냅니다.
              </td>
            </tr>
            <tr>
              <td>
                `HH`
              </td>
              <td>
                자정 이후 지난 전체 시간(hour) 수. 00~24의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `:`
              </td>
              <td>
                *":"* (콜론)은 문자열에 두 번 그대로 나타납니다.
              </td>
            </tr>
            <tr>
              <td>
                `mm`
              </td>
              <td>
                시간(hour) 시작 이후 지난 전체 분(minute) 수. 00~59의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `ss`
              </td>
              <td>
                분(minute) 시작 이후 지난 전체 초(second) 수. 00~59의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `.`
              </td>
              <td>
                *"."* (점)은 문자열에 그대로 나타납니다.
              </td>
            </tr>
            <tr>
              <td>
                `sss`
              </td>
              <td>
                초(second) 시작 이후 지난 전체 밀리초(millisecond) 수. 세 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `Z`
              </td>
              <td>
                UTC 오프셋 표현. *"Z"* (오프셋 없는 UTC), 혹은 *"+"* 또는 *"-"* 뒤에 시간 표현 `HH:mm` (UTC 앞 또는 뒤의 지역 시간을 나타내는 <emu-xref href="#sec-time-zone-offset-strings">시간대 오프셋 문자열 형식</emu-xref>의 부분집합)
              </td>
            </tr>
          </table>
        </figure>
        <p>이 형식은 날짜만을 포함하는 형태도 지원합니다:</p>
        <pre>
YYYY
YYYY-MM
YYYY-MM-DD
        </pre>
        <p>또한 위의 날짜만 형식 뒤에 다음 시간 형식이 바로 붙고 선택적 UTC 오프셋 표현이 뒤따르는 “날짜-시간” 형식도 지원합니다:</p>
        <pre>
THH:mm
THH:mm:ss
THH:mm:ss.sss
        </pre>
        <p>형식에 맞지 않거나 범위를 벗어난 요소를 포함한 문자열은 이 형식의 유효한 인스턴스가 아닙니다.</p>
        <emu-note>
          <p>모든 날짜는 자정으로 시작하고 자정으로 끝나므로, `00:00`과 `24:00` 표기법 모두 한 날짜에 연관된 두 자정을 구분할 수 있습니다. 즉, `1995-02-04T24:00`과 `1995-02-05T00:00`은 정확히 같은 시점을 의미합니다. 후자의 형식을 “달력 날짜의 끝”으로 해석하는 것은 ISO 8601과 일치합니다(이 명세는 시간 구간을 설명할 때만 이 표기를 허용하며 단일 시점 표현에는 허용하지 않음).</p>
        </emu-note>
        <emu-note>
          <p>CET, EST 등과 같은 민간 시간대 약어에 대한 국제 표준은 없으며, 약어가 서로 다른 두 시간대를 동시에 나타낼 수도 있습니다. 이런 이유로 ISO 8601과 이 형식 모두 시간대 오프셋을 숫자 표현으로 지정합니다.</p>
        </emu-note>

        <emu-clause id="sec-expanded-years" oldids="sec-extended-years">
          <h1>확장 연도</h1>
          <p>1970년 1월 1일 기준 약 273,790년 전후의 전체 시간 값 범위를 나타내려면 0년 이전 또는 9999년 이후의 연도 표현이 필요합니다(<emu-xref href="#sec-time-values-and-time-range"></emu-xref>). ISO 8601은 연도 표현의 확장을 허용하지만, 정보 교환 당사자 간의 합의가 있을 때만 허용합니다. ECMAScript 단순화 형식에서는 확장 연도 표현이 6자리 숫자로 되어야 하며 항상 + 또는 - 기호가 붙습니다. 0년은 양수로 간주하고 반드시 + 기호를 붙여야 합니다. -000000 형식의 0년 표현은 유효하지 않습니다. 확장 연도가 시간 값 범위를 벗어나는 경우, <emu-xref href="#sec-date-time-string-format">날짜-시간 문자열 형식</emu-xref>과 일치하는 문자열이라도 <emu-xref href="#sec-date.parse">`Date.parse`</emu-xref>에서 인식되지 않으며, 해당 함수는 구현별 동작이나 휴리스틱 없이 *NaN*을 반환합니다.</p>
          <emu-note>
            <p>확장 연도가 포함된 날짜-<emu-not-ref>시간 값</emu-not-ref> 예시:</p>
            <figure>
              <table class="lightweight-table">
                <tr>
                  <td>-271821-04-20T00:00:00Z</td>
                  <td>기원전 271822년</td>
                </tr>
                <tr>
                  <td>-000001-01-01T00:00:00Z</td>
                  <td>기원전 2년</td>
                </tr>
                <tr>
                  <td>+000000-01-01T00:00:00Z</td>
                  <td>기원전 1년</td>
                </tr>
                <tr>
                  <td>+000001-01-01T00:00:00Z</td>
                  <td>서기 1년</td>
                </tr>
                <tr>
                  <td>+001970-01-01T00:00:00Z</td>
                  <td>서기 1970년</td>
                </tr>
                <tr>
                  <td>+002009-12-15T00:00:00Z</td>
                  <td>서기 2009년</td>
                </tr>
                <tr>
                  <td>+275760-09-13T00:00:00Z</td>
                  <td>서기 275760년</td>
                </tr>
              </table>
            </figure>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-time-zone-offset-strings">
        <h1>시간대 오프셋 문자열 형식</h1>

        <p>
          ECMAScript는 ISO 8601에서 파생된 UTC 오프셋의 문자열 교환 형식을 정의합니다.
          이 형식은 다음 문법으로 설명됩니다.
        </p>

        <h2>문법</h2>
        <emu-grammar type="definition">
          UTCOffset :::
            ASCIISign Hour
            ASCIISign Hour HourSubcomponents[+Extended]
            ASCIISign Hour HourSubcomponents[~Extended]

          ASCIISign ::: one of
            `+` `-`

          Hour :::
            `0` DecimalDigit
            `1` DecimalDigit
            `20`
            `21`
            `22`
            `23`

          HourSubcomponents[Extended] :::
            TimeSeparator[?Extended] MinuteSecond
            TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction?

          TimeSeparator[Extended] :::
            [+Extended] `:`
            [~Extended] [empty]

          MinuteSecond :::
            `0` DecimalDigit
            `1` DecimalDigit
            `2` DecimalDigit
            `3` DecimalDigit
            `4` DecimalDigit
            `5` DecimalDigit

          TemporalDecimalFraction :::
            TemporalDecimalSeparator DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

          TemporalDecimalSeparator ::: one of
            `.` `,`
        </emu-grammar>

        <emu-clause id="sec-istimezoneoffsetstring" type="abstract operation">
          <h1>
            IsTimeZoneOffsetString (
              _offsetString_: 문자열,
            ): 불리언(Boolean)
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd>반환 값은 _offsetString_이 |UTCOffset| 문법에 맞는지 여부를 나타냅니다.</dd>
          </dl>
          <emu-alg>
            1. _parseResult_를 ParseText(_offsetString_, |UTCOffset|)로 한다.
            1. _parseResult_가 오류 목록이면 *false*를 반환한다.
            1. *true*를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parsetimezoneoffsetstring" type="abstract operation">
          <h1>
            ParseTimeZoneOffsetString (
              _offsetString_: 문자열,
            ): 정수
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd>반환 값은 _offsetString_에 해당하는 UTC 오프셋(나노초 단위)입니다.</dd>
          </dl>
          <emu-alg>
            1. _parseResult_를 ParseText(_offsetString_, |UTCOffset|)로 한다.
            1. Assert: _parseResult_가 오류 목록이 아님을 보장한다.
            1. Assert: _parseResult_에 |ASCIISign| Parse Node가 포함됨을 보장한다.
            1. _parsedSign_을 _parseResult_에 포함된 |ASCIISign| Parse Node가 일치시킨 소스 텍스트로 한다.
            1. _parsedSign_이 U+002D(하이픈) 단일 코드 포인트면
              1. _sign_을 -1로 한다.
            1. 그렇지 않으면
              1. _sign_을 1로 한다.
            1. NOTE: 아래 StringToNumber 이용 시 정밀도 손실 없음(파싱된 값은 충분히 짧은 십진수 문자열임이 보장됨).
            1. Assert: _parseResult_에 |Hour| Parse Node가 포함됨을 보장한다.
            1. _parsedHours_를 _parseResult_에 포함된 |Hour| Parse Node가 일치시킨 소스 텍스트로 한다.
            1. _hours_를 ℝ(StringToNumber(CodePointsToString(_parsedHours_)))로 한다.
            1. _parseResult_에 |MinuteSecond| Parse Node가 없으면
              1. _minutes_를 0으로 한다.
            1. 그렇지 않으면
              1. _parsedMinutes_를 _parseResult_에 포함된 첫 |MinuteSecond| Parse Node가 일치시킨 소스 텍스트로 한다.
              1. _minutes_를 ℝ(StringToNumber(CodePointsToString(_parsedMinutes_)))로 한다.
            1. _parseResult_에 두 번째 |MinuteSecond| Parse Node가 없으면
              1. _seconds_를 0으로 한다.
            1. 그렇지 않으면
              1. _parsedSeconds_를 _parseResult_에 포함된 두 번째 |MinuteSecond| Parse Node가 일치시킨 소스 텍스트로 한다.
              1. _seconds_를 ℝ(StringToNumber(CodePointsToString(_parsedSeconds_)))로 한다.
            1. _parseResult_에 |TemporalDecimalFraction| Parse Node가 없으면
              1. _nanoseconds_를 0으로 한다.
            1. 그렇지 않으면
              1. _parsedFraction_을 _parseResult_에 포함된 |TemporalDecimalFraction| Parse Node가 일치시킨 소스 텍스트로 한다.
              1. _fraction_을 CodePointsToString(_parsedFraction_)과 *"000000000"*을 이어붙인 문자열로 한다.
              1. _nanosecondsString_을 _fraction_의 1~10번째 부분 문자열로 한다.
              1. _nanoseconds_를 ℝ(StringToNumber(_nanosecondsString_))로 한다.
            1. _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_)를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-date-constructor" oldids="this-time-value,sec-thistimevalue,thistimevalue,this-Date-object">
      <h1>Date 생성자</h1>
      <p>Date 생성자:</p>
      <ul>
        <li><dfn>%Date%</dfn>이다.</li>
        <li>전역 객체의 *"Date"* 프로퍼티의 초기값이다.</li>
        <li>생성자로 호출될 때 새로운 Date를 생성하고 초기화한다.</li>
        <li>생성자가 아닌 함수로 호출될 때 현재 시간(UTC)을 나타내는 문자열을 반환한다.</li>
        <li>인수의 개수와 타입에 따라 동작이 달라지는 함수이다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Date 동작을 상속하려는 서브클래스 생성자는 [[DateValue]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성 및 초기화하기 위해 반드시 Date 생성자로의 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-date" oldids="sec-date-constructor-date,sec-date-value,sec-date-year-month-date-hours-minutes-seconds-ms">
        <h1>Date ( ..._values_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget이 *undefined*이면
            1. _now_를 현재 시간(UTC)을 식별하는 시간 값으로 설정한다.
            1. ToDateString(_now_)을 반환한다.
          1. _numberOfArgs_를 _values_의 요소 개수로 설정한다.
          1. _numberOfArgs_ = 0이면
            1. _dv_를 현재 시간(UTC)을 식별하는 시간 값으로 설정한다.
          1. 그렇지 않고 _numberOfArgs_ = 1이면
            1. _value_를 _values_[0]으로 설정한다.
            1. _value_가 객체이고 [[DateValue]] 내부 슬롯이 있으면
              1. _tv_를 _value_.[[DateValue]]로 설정한다.
            1. 그렇지 않으면
              1. _v_를 ? ToPrimitive(_value_)로 설정한다.
              1. _v_가 문자열이면
                1. 다음 단계에서 갑작스런 완료가 발생하지 않음을 단언한다(_v_는 문자열이므로).
                1. _tv_를 `parse` 메서드(<emu-xref href="#sec-date.parse"></emu-xref>)와 동일한 방식으로 _v_를 날짜로 파싱한 결과로 설정한다.
              1. 그렇지 않으면
                1. _tv_를 ? ToNumber(_v_)로 설정한다.
            1. _dv_를 TimeClip(_tv_)로 설정한다.
          1. 그렇지 않으면
            1. 단언: _numberOfArgs_ ≥ 2.
            1. _y_를 ? ToNumber(_values_[0])로 설정한다.
            1. _m_를 ? ToNumber(_values_[1])로 설정한다.
            1. _numberOfArgs_ > 2이면 _dt_를 ? ToNumber(_values_[2])로, 아니면 _dt_를 *1*<sub>𝔽</sub>로 설정한다.
            1. _numberOfArgs_ > 3이면 _h_를 ? ToNumber(_values_[3])로, 아니면 _h_를 *+0*<sub>𝔽</sub>로 설정한다.
            1. _numberOfArgs_ > 4이면 _min_을 ? ToNumber(_values_[4])로, 아니면 _min_을 *+0*<sub>𝔽</sub>로 설정한다.
            1. _numberOfArgs_ > 5이면 _s_를 ? ToNumber(_values_[5])로, 아니면 _s_를 *+0*<sub>𝔽</sub>로 설정한다.
            1. _numberOfArgs_ > 6이면 _milli_를 ? ToNumber(_values_[6])로, 아니면 _milli_를 *+0*<sub>𝔽</sub>로 설정한다.
            1. _yr_를 MakeFullYear(_y_)로 설정한다.
            1. _finalDate_를 MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))로 설정한다.
            1. _dv_를 TimeClip(UTC(_finalDate_))로 설정한다.
          1. _O_를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Date.prototype%"*, « [[DateValue]] »)로 설정한다.
          1. _O_.[[DateValue]]에 _dv_를 설정한다.
          1. _O_를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Date 생성자의 프로퍼티</h1>
      <p>Date 생성자:</p>
      <ul>
        <li>[[Prototype]] 내부 슬롯의 값이 %Function.prototype%이다.</li>
        <li>*"length"* 프로퍼티의 값이 *7*<sub>𝔽</sub>이다.</li>
        <li>다음과 같은 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-date.now">
        <h1>Date.now ( )</h1>
        <p>이 함수는 호출 시점의 UTC 날짜와 시간을 나타내는 시간 값을 반환한다.</p>
      </emu-clause>

      <emu-clause id="sec-date.parse">
        <h1>Date.parse ( _string_ )</h1>
        <p>이 함수는 인수에 ToString 연산자를 적용한다. ToString 결과가 갑작스런 완료라면 즉시 Completion Record를 반환한다. 그렇지 않으면, 이 함수는 결과 문자열을 날짜와 시간으로 해석하여 해당 날짜와 시간에 해당하는 UTC 시간 값을 Number로 반환한다. 문자열의 내용에 따라 지역 시간, UTC 시간, 또는 다른 시간대의 시간으로 해석될 수 있다. 함수는 먼저 Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>)에 설명된 형식(확장된 연도 포함)에 따라 문자열을 파싱하려 시도한다. 문자열이 해당 형식에 맞지 않으면 구현별 휴리스틱 또는 구현별 날짜 형식으로 대체할 수 있다. 인식 불가하거나 형식 요소 값이 범위를 벗어난 문자열은 이 함수가 *NaN*을 반환하게 한다.</p>
        <p>문자열이 <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>에 맞는 경우, 대체 값이 없는 형식 요소에는 대체 값이 사용된다. `MM` 또는 `DD` 요소가 없으면 *"01"*이 사용된다. `HH`, `mm`, `ss` 요소가 없으면 *"00"*이 사용된다. `sss` 요소가 없으면 *"000"*이 사용된다. UTC 오프셋 표현이 없으면 날짜만 있는 형식은 UTC로, 날짜-시간 형식은 지역 시간으로 해석된다.</p>
        <p>어떤 ECMAScript 구현에서 밀리초가 0인 Date `x`에 대해 다음 모든 표현식은 모든 관련 프로퍼티가 초기값일 때 동일한 숫자 값을 반환해야 한다:</p>
        <pre><code class="javascript">
          x.valueOf()
          Date.parse(x.toString())
          Date.parse(x.toUTCString())
          Date.parse(x.toISOString())
        </code></pre>
        <p>그러나 다음 표현식은</p>
        <pre><code class="javascript">
          Date.parse(x.toLocaleString())
        </code></pre>
        <p>앞의 세 표현식과 동일한 Number 값을 반환할 필요는 없으며, 일반적으로 이 함수가 Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>)에 맞지 않고 해당 구현에서 `toString` 또는 `toUTCString` 메서드로 생성할 수 없는 문자열 값을 받으면 반환 값은 구현에 따라 달라진다.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype">
        <h1>Date.prototype</h1>
        <p>`Date.prototype`의 초기값은 Date 프로토타입 객체이다.</p>
        <p>이 프로퍼티의 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }이다.</p>
      </emu-clause>

      <emu-clause id="sec-date.utc">
        <h1>Date.UTC ( _year_ [ , _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _y_를 ? ToNumber(_year_)로 설정한다.
          1. _month_가 있으면 _m_를 ? ToNumber(_month_)로, 아니면 _m_를 *+0*<sub>𝔽</sub>로 설정한다.
          1. _date_가 있으면 _dt_를 ? ToNumber(_date_)로, 아니면 _dt_를 *1*<sub>𝔽</sub>로 설정한다.
          1. _hours_가 있으면 _h_를 ? ToNumber(_hours_)로, 아니면 _h_를 *+0*<sub>𝔽</sub>로 설정한다.
          1. _minutes_가 있으면 _min_을 ? ToNumber(_minutes_)로, 아니면 _min_을 *+0*<sub>𝔽</sub>로 설정한다.
          1. _seconds_가 있으면 _s_를 ? ToNumber(_seconds_)로, 아니면 _s_를 *+0*<sub>𝔽</sub>로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로, 아니면 _milli_를 *+0*<sub>𝔽</sub>로 설정한다.
          1. _yr_를 MakeFullYear(_y_)로 설정한다.
          1. TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)))를 반환한다.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티 값은 *7*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>이 함수는 Date 생성자와 두 가지 차이가 있다: Date를 생성하는 대신 시간 값을 Number로 반환하며, 인수를 지역 시간 대신 UTC로 해석한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-prototype-object">
      <h1>Date 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Date 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%Date.prototype%</dfn>이다.</li>
        <li>자체적으로 일반 객체이다.</li>
        <li>Date 인스턴스가 아니며 [[DateValue]] 내부 슬롯을 가지지 않는다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Object.prototype%이다.</li>
      </ul>
      <p>명시적으로 정의된 경우를 제외하고, 아래에 정의된 Date 프로토타입 객체의 메서드는 제네릭하지 않으며, *this* 값은 반드시 시간 값으로 초기화된 [[DateValue]] 내부 슬롯을 가진 객체여야 한다.</p>

      <emu-clause id="sec-date.prototype.constructor">
        <h1>Date.prototype.constructor</h1>
        <p>`Date.prototype.constructor`의 초기값은 %Date%이다.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getdate">
        <h1>Date.prototype.getDate ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. DateFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getday">
        <h1>Date.prototype.getDay ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. WeekDay(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getfullyear">
        <h1>Date.prototype.getFullYear ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. YearFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gethours">
        <h1>Date.prototype.getHours ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. HourFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmilliseconds">
        <h1>Date.prototype.getMilliseconds ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. msFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getminutes">
        <h1>Date.prototype.getMinutes ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. MinFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmonth">
        <h1>Date.prototype.getMonth ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. MonthFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getseconds">
        <h1>Date.prototype.getSeconds ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. SecFromTime(LocalTime(_t_))을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettime">
        <h1>Date.prototype.getTime ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _dateObject_.[[DateValue]]를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettimezoneoffset">
        <h1>Date.prototype.getTimezoneOffset ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. (_t_ - LocalTime(_t_)) / msPerMinute를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcdate">
        <h1>Date.prototype.getUTCDate ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. DateFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcday">
        <h1>Date.prototype.getUTCDay ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. WeekDay(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcfullyear">
        <h1>Date.prototype.getUTCFullYear ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. YearFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutchours">
        <h1>Date.prototype.getUTCHours ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. HourFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmilliseconds">
        <h1>Date.prototype.getUTCMilliseconds ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. msFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcminutes">
        <h1>Date.prototype.getUTCMinutes ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. MinFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmonth">
        <h1>Date.prototype.getUTCMonth ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. MonthFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcseconds">
        <h1>Date.prototype.getUTCSeconds ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. SecFromTime(_t_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setdate">
        <h1>Date.prototype.setDate ( _date_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _dt_를 ? ToNumber(_date_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _t_를 LocalTime(_t_)로 설정한다.
          1. _newDate_를 MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_))로 설정한다.
          1. _u_를 TimeClip(UTC(_newDate_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setfullyear">
        <h1>Date.prototype.setFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _y_를 ? ToNumber(_year_)로 설정한다.
          1. _t_가 *NaN*이면 _t_를 *+0*<sub>𝔽</sub>로 설정하고; 아니면 _t_를 LocalTime(_t_)로 설정한다.
          1. _month_가 없으면 _m_를 MonthFromTime(_t_)로 설정하고; 있으면 _m_를 ? ToNumber(_month_)로 설정한다.
          1. _date_가 없으면 _dt_를 DateFromTime(_t_)로 설정하고; 있으면 _dt_를 ? ToNumber(_date_)로 설정한다.
          1. _newDate_를 MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_))로 설정한다.
          1. _u_를 TimeClip(UTC(_newDate_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *3*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_month_가 없으면 이 메서드는 `getMonth()` 값이 있는 것처럼 동작한다. _date_가 없으면 `getDate()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.sethours">
        <h1>Date.prototype.setHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _h_를 ? ToNumber(_hour_)로 설정한다.
          1. _min_이 있으면 _m_를 ? ToNumber(_min_)로 설정한다.
          1. _sec_이 있으면 _s_를 ? ToNumber(_sec_)로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _t_를 LocalTime(_t_)로 설정한다.
          1. _min_이 없으면 _m_를 MinFromTime(_t_)로 설정한다.
          1. _sec_이 없으면 _s_를 SecFromTime(_t_)로 설정한다.
          1. _ms_가 없으면 _milli_를 msFromTime(_t_)로 설정한다.
          1. _date_를 MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_))로 설정한다.
          1. _u_를 TimeClip(UTC(_date_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *4*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_min_이 없으면 `getMinutes()` 값이 있는 것처럼 동작한다. _sec_이 없으면 `getSeconds()` 값이 있는 것처럼, _ms_가 없으면 `getMilliseconds()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmilliseconds">
        <h1>Date.prototype.setMilliseconds ( _ms_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _ms_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _t_를 LocalTime(_t_)로 설정한다.
          1. _time_을 MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_)로 설정한다.
          1. _u_를 TimeClip(UTC(MakeDate(Day(_t_), _time_)))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setminutes">
        <h1>Date.prototype.setMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _m_를 ? ToNumber(_min_)로 설정한다.
          1. _sec_이 있으면 _s_를 ? ToNumber(_sec_)로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _t_를 LocalTime(_t_)로 설정한다.
          1. _sec_이 없으면 _s_를 SecFromTime(_t_)로 설정한다.
          1. _ms_가 없으면 _milli_를 msFromTime(_t_)로 설정한다.
          1. _date_를 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_))로 설정한다.
          1. _u_를 TimeClip(UTC(_date_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *3*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_sec_이 없으면 `getSeconds()` 값이 있는 것처럼, _ms_가 없으면 `getMilliseconds()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmonth">
        <h1>Date.prototype.setMonth ( _month_ [ , _date_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _m_를 ? ToNumber(_month_)로 설정한다.
          1. _date_가 있으면 _dt_를 ? ToNumber(_date_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _t_를 LocalTime(_t_)로 설정한다.
          1. _date_가 없으면 _dt_를 DateFromTime(_t_)로 설정한다.
          1. _newDate_를 MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_))로 설정한다.
          1. _u_를 TimeClip(UTC(_newDate_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_date_가 없으면 `getDate()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setseconds">
        <h1>Date.prototype.setSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _s_를 ? ToNumber(_sec_)로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _t_를 LocalTime(_t_)로 설정한다.
          1. _ms_가 없으면 _milli_를 msFromTime(_t_)로 설정한다.
          1. _date_를 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_))로 설정한다.
          1. _u_를 TimeClip(UTC(_date_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _u_를 설정한다.
          1. _u_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_ms_가 없으면 `getMilliseconds()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.settime">
        <h1>Date.prototype.setTime ( _time_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 ? ToNumber(_time_)로 설정한다.
          1. _v_를 TimeClip(_t_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcdate">
        <h1>Date.prototype.setUTCDate ( _date_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _dt_를 ? ToNumber(_date_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _newDate_를 MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_))로 설정한다.
          1. _v_를 TimeClip(_newDate_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcfullyear">
        <h1>Date.prototype.setUTCFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _t_가 *NaN*이면 _t_를 *+0*<sub>𝔽</sub>로 설정한다.
          1. _y_를 ? ToNumber(_year_)로 설정한다.
          1. _month_가 없으면 _m_를 MonthFromTime(_t_)로 설정하고; 있으면 _m_를 ? ToNumber(_month_)로 설정한다.
          1. _date_가 없으면 _dt_를 DateFromTime(_t_)로 설정하고; 있으면 _dt_를 ? ToNumber(_date_)로 설정한다.
          1. _newDate_를 MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_))로 설정한다.
          1. _v_를 TimeClip(_newDate_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *3*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_month_가 없으면 `getUTCMonth()` 값이 있는 것처럼, _date_가 없으면 `getUTCDate()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutchours">
        <h1>Date.prototype.setUTCHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _h_를 ? ToNumber(_hour_)로 설정한다.
          1. _min_이 있으면 _m_를 ? ToNumber(_min_)로 설정한다.
          1. _sec_이 있으면 _s_를 ? ToNumber(_sec_)로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _min_이 없으면 _m_를 MinFromTime(_t_)로 설정한다.
          1. _sec_이 없으면 _s_를 SecFromTime(_t_)로 설정한다.
          1. _ms_가 없으면 _milli_를 msFromTime(_t_)로 설정한다.
          1. _date_를 MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_))로 설정한다.
          1. _v_를 TimeClip(_date_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *4*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_min_이 없으면 `getUTCMinutes()` 값이 있는 것처럼, _sec_이 없으면 `getUTCSeconds()` 값이 있는 것처럼, _ms_가 없으면 `getUTCMilliseconds()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmilliseconds">
        <h1>Date.prototype.setUTCMilliseconds ( _ms_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _ms_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _time_을 MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_)로 설정한다.
          1. _v_를 TimeClip(MakeDate(Day(_t_), _time_))로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcminutes">
        <h1>Date.prototype.setUTCMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _m_를 ? ToNumber(_min_)로 설정한다.
          1. _sec_이 있으면 _s_를 ? ToNumber(_sec_)로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _sec_이 없으면 _s_를 SecFromTime(_t_)로 설정한다.
          1. _ms_가 없으면 _milli_를 msFromTime(_t_)로 설정한다.
          1. _date_를 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_))로 설정한다.
          1. _v_를 TimeClip(_date_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *3*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_sec_이 없으면 `getUTCSeconds()` 값이 있는 것처럼, _ms_가 없으면 `getUTCMilliseconds()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmonth">
        <h1>Date.prototype.setUTCMonth ( _month_ [ , _date_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _m_를 ? ToNumber(_month_)로 설정한다.
          1. _date_가 있으면 _dt_를 ? ToNumber(_date_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _date_가 없으면 _dt_를 DateFromTime(_t_)로 설정한다.
          1. _newDate_를 MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_))로 설정한다.
          1. _v_를 TimeClip(_newDate_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_date_가 없으면 `getUTCDate()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcseconds">
        <h1>Date.prototype.setUTCSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _t_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _s_를 ? ToNumber(_sec_)로 설정한다.
          1. _ms_가 있으면 _milli_를 ? ToNumber(_ms_)로 설정한다.
          1. _t_가 *NaN*이면 *NaN*을 반환한다.
          1. _ms_가 없으면 _milli_를 msFromTime(_t_)로 설정한다.
          1. _date_를 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_))로 설정한다.
          1. _v_를 TimeClip(_date_)로 설정한다.
          1. _dateObject_.[[DateValue]]에 _v_를 설정한다.
          1. _v_를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>_ms_가 없으면 `getUTCMilliseconds()` 값이 있는 것처럼 동작한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.todatestring">
        <h1>Date.prototype.toDateString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _tv_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _tv_가 *NaN*이면 *"Invalid Date"*를 반환한다.
          1. _t_를 LocalTime(_tv_)로 설정한다.
          1. DateString(_t_)을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toisostring">
        <h1>Date.prototype.toISOString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _tv_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _tv_가 *NaN*이면 *RangeError* 예외를 throw 한다.
          1. 단언: _tv_는 정수 Number이다.
          1. _tv_가 <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>에서 표현할 수 없는 연도라면 *RangeError* 예외를 throw 한다.
          1. _tv_를 <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>의 UTC 타임스케일로 모든 형식 요소와 UTC 오프셋 표현 *"Z"*를 포함한 문자열로 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tojson">
        <h1>Date.prototype.toJSON ( _key_ )</h1>
        <p>이 메서드는 `JSON.stringify`(<emu-xref href="#sec-json.stringify"></emu-xref>)에서 사용할 Date의 문자열 표현을 제공한다.</p>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 ? ToObject(*this* 값)으로 설정한다.
          1. _tv_를 ? ToPrimitive(_O_, ~number~)로 설정한다.
          1. _tv_가 Number이고 유한하지 않으면 *null*을 반환한다.
          1. ? Invoke(_O_, *"toISOString"*)을 반환한다.
        </emu-alg>
        <emu-note>
          <p>인수는 무시된다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 일부러 제네릭이다; *this* 값이 Date일 필요는 없다. 따라서 다른 종류의 객체로 이전해 메서드로 사용할 수 있다. 단, 해당 객체는 반드시 `toISOString` 메서드를 가지고 있어야 한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaledatestring">
        <h1>Date.prototype.toLocaleDateString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API를 포함하는 ECMAScript 구현은 ECMA-402 명세에 따라 이 메서드를 구현해야 한다. ECMA-402 API를 포함하지 않는 ECMAScript 구현에서는 다음 명세에 따른다:</p>
        <p>이 메서드는 문자열 값을 반환한다. 문자열 내용은 구현 정의이지만, 현재 시간대의 Date의 “날짜” 부분을 편리하고 사람이 읽기 쉬운 형태로, 호스트 환경의 현재 로캘 관습에 맞게 나타내야 한다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의되어 있다. ECMA-402를 지원하지 않는 구현에서는 해당 위치에 다른 용도를 사용하면 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocalestring">
        <h1>Date.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API를 포함하는 ECMAScript 구현은 ECMA-402 명세에 따라 이 메서드를 구현해야 한다. ECMA-402 API를 포함하지 않는 ECMAScript 구현에서는 다음 명세에 따른다:</p>
        <p>이 메서드는 문자열 값을 반환한다. 문자열 내용은 구현 정의이지만, 현재 시간대의 Date를 편리하고 사람이 읽기 쉬운 형태로, 호스트 환경의 현재 로캘 관습에 맞게 나타내야 한다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의되어 있다. ECMA-402를 지원하지 않는 구현에서는 해당 위치에 다른 용도를 사용하면 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaletimestring">
        <h1>Date.prototype.toLocaleTimeString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API를 포함하는 ECMAScript 구현은 ECMA-402 명세에 따라 이 메서드를 구현해야 한다. ECMA-402 API를 포함하지 않는 ECMAScript 구현에서는 다음 명세에 따른다:</p>
        <p>이 메서드는 문자열 값을 반환한다. 문자열 내용은 구현 정의이지만, 현재 시간대의 Date의 “시간” 부분을 편리하고 사람이 읽기 쉬운 형태로, 호스트 환경의 현재 로캘 관습에 맞게 나타내야 한다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의되어 있다. ECMA-402를 지원하지 않는 구현에서는 해당 위치에 다른 용도를 사용하면 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _tv_를 _dateObject_.[[DateValue]]로 설정한다.
          1. ToDateString(_tv_)을 반환한다.
        </emu-alg>
        <emu-note>
          <p>어떤 Date `d`에서 `d.[[DateValue]]`가 1000으로 나누어 떨어진다면, `Date.parse(d.toString())`의 결과는 `d.valueOf()`와 같다. <emu-xref href="#sec-date.parse"></emu-xref> 참조.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 제네릭하지 않다; *this* 값이 Date가 아니면 *TypeError* 예외를 throw 한다. 따라서 다른 객체로 이전해 메서드로 사용할 수 없다.</p>
        </emu-note>

        <emu-clause id="sec-timestring" type="abstract operation">
          <h1>
            TimeString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _hour_를 ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2)로 설정한다.
            1. _minute_을 ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2)로 설정한다.
            1. _second_를 ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2)로 설정한다.
            1. _hour_, *":"*, _minute_, *":"*, _second_, 코드 유닛 0x0020(공백), *"GMT"*를 차례로 연결한 문자열을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-datestring" type="abstract operation">
          <h1>
            DateString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _weekday_를 <emu-xref href="#sec-todatestring-day-names"></emu-xref>에서 Number WeekDay(_tv_)에 해당하는 Name으로 설정한다.
            1. _month_를 <emu-xref href="#sec-todatestring-month-names"></emu-xref>에서 Number MonthFromTime(_tv_)에 해당하는 Name으로 설정한다.
            1. _day_를 ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2)로 설정한다.
            1. _yv_를 YearFromTime(_tv_)로 설정한다.
            1. _yv_가 *+0*<sub>𝔽</sub>이거나 _yv_ > *+0*<sub>𝔽</sub>이면 _yearSign_을 빈 문자열로, 아니면 _yearSign_을 *"-"*로 설정한다.
            1. _paddedYear_를 ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4)로 설정한다.
            1. _weekday_, 코드 유닛 0x0020(공백), _month_, 코드 유닛 0x0020(공백), _day_, 코드 유닛 0x0020(공백), _yearSign_, _paddedYear_를 차례로 연결한 문자열을 반환한다.
          </emu-alg>
          <emu-table id="sec-todatestring-day-names" caption="Names of days of the week">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sun"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mon"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Tue"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Wed"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"Thu"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Fri"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sat"*
                </td>
              </tr>
            </table>
          </emu-table>
          <emu-table id="sec-todatestring-month-names" caption="Names of months of the year">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jan"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Feb"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mar"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Apr"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"May"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jun"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jul"*
                </td>
              </tr>
              <tr>
                <td>
                  *7*<sub>𝔽</sub>
                </td>
                <td>
                  *"Aug"*
                </td>
              </tr>
              <tr>
                <td>
                  *8*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sep"*
                </td>
              </tr>
              <tr>
                <td>
                  *9*<sub>𝔽</sub>
                </td>
                <td>
                  *"Oct"*
                </td>
              </tr>
              <tr>
                <td>
                  *10*<sub>𝔽</sub>
                </td>
                <td>
                  *"Nov"*
                </td>
              </tr>
              <tr>
                <td>
                  *11*<sub>𝔽</sub>
                </td>
                <td>
                  *"Dec"*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>

        <emu-clause id="sec-timezoneestring" type="abstract operation">
          <h1>
            TimeZoneString (
              _tv_: an integral Number,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _systemTimeZoneIdentifier_를 SystemTimeZoneIdentifier()로 설정한다.
            1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_)이 *true*이면
              1. _offsetNs_를 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)로 설정한다.
            1. 아니면,
              1. _offsetNs_를 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>))로 설정한다.
            1. _offset_를 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>))로 설정한다.
            1. _offset_가 *+0*<sub>𝔽</sub>이거나 _offset_ > *+0*<sub>𝔽</sub>이면
              1. _offsetSign_을 *"+"*로 설정한다.
              1. _absOffset_을 _offset_로 설정한다.
            1. 아니면
              1. _offsetSign_을 *"-"*로 설정한다.
              1. _absOffset_을 -_offset_로 설정한다.
            1. _offsetMin_을 ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2)로 설정한다.
            1. _offsetHour_를 ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2)로 설정한다.
            1. _tzName_을 구현 정의 문자열(빈 문자열 또는 코드 유닛 0x0020(공백), 0x0028(왼쪽 괄호), 구현 정의 타임존 이름, 0x0029(오른쪽 괄호) 연결)로 설정한다.
            1. _offsetSign_, _offsetHour_, _offsetMin_, _tzName_을 차례로 연결한 문자열을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-todatestring" type="abstract operation">
          <h1>
            ToDateString (
              _tv_: an integral Number or *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _tv_가 *NaN*이면 *"Invalid Date"*를 반환한다.
            1. _t_를 LocalTime(_tv_)로 설정한다.
            1. DateString(_t_), 코드 유닛 0x0020(공백), TimeString(_t_), TimeZoneString(_tv_)를 차례로 연결한 문자열을 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-date.prototype.totimestring">
        <h1>Date.prototype.toTimeString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _tv_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _tv_가 *NaN*이면 *"Invalid Date"*를 반환한다.
          1. _t_를 LocalTime(_tv_)로 설정한다.
          1. TimeString(_t_), TimeZoneString(_tv_)를 차례로 연결한 문자열을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toutcstring">
        <h1>Date.prototype.toUTCString ( )</h1>
        <p>이 메서드는 *this* 값에 해당하는 순간을 나타내는 문자열 값을 반환한다. 문자열 형식은 RFC 7231의 "HTTP-date"를 기반으로 ECMAScript Date가 지원하는 전체 시간 범위에 맞게 일반화된 것이다.</p>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _tv_를 _dateObject_.[[DateValue]]로 설정한다.
          1. _tv_가 *NaN*이면 *"Invalid Date"*를 반환한다.
          1. _weekday_를 <emu-xref href="#sec-todatestring-day-names"></emu-xref>에서 Number WeekDay(_tv_)에 해당하는 Name으로 설정한다.
          1. _month_를 <emu-xref href="#sec-todatestring-month-names"></emu-xref>에서 Number MonthFromTime(_tv_)에 해당하는 Name으로 설정한다.
          1. _day_를 ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2)로 설정한다.
          1. _yv_를 YearFromTime(_tv_)로 설정한다.
          1. _yv_가 *+0*<sub>𝔽</sub>이거나 _yv_ > *+0*<sub>𝔽</sub>이면 _yearSign_을 빈 문자열로, 아니면 _yearSign_을 *"-"*로 설정한다.
          1. _paddedYear_를 ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4)로 설정한다.
          1. _weekday_, *","*, 코드 유닛 0x0020(공백), _day_, 코드 유닛 0x0020(공백), _month_, 코드 유닛 0x0020(공백), _yearSign_, _paddedYear_, 코드 유닛 0x0020(공백), TimeString(_tv_)를 차례로 연결한 문자열을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.valueof">
        <h1>Date.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_를 *this* 값으로 설정한다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]])를 수행한다.
          1. _dateObject_.[[DateValue]]를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-date.prototype-@@toprimitive" id="sec-date.prototype-%symbol.toprimitive%">
        <h1>Date.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>이 메서드는 ECMAScript 언어 연산자가 Date를 원시 값으로 변환할 때 호출된다. _hint_에 허용되는 값은 *"default"*, *"number"*, *"string"*이다. Date는 내장 ECMAScript 객체 중 유일하게 *"default"*를 *"string"*과 동등하게 취급한다. 다른 내장 객체는 *"default"*를 *"number"*와 동등하게 취급한다.</p>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 설정한다.
          1. _O_가 객체가 아니면 *TypeError* 예외를 throw 한다.
          1. _hint_가 *"string"* 또는 *"default"*이면
            1. _tryFirst_를 ~string~으로 설정한다.
          1. 아니고 _hint_가 *"number"*이면
            1. _tryFirst_를 ~number~로 설정한다.
          1. 아니면
            1. *TypeError* 예외를 throw 한다.
          1. ? OrdinaryToPrimitive(_O_, _tryFirst_)를 반환한다.
        </emu-alg>
        <p>이 프로퍼티의 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }이다.</p>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.toPrimitive]"*이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-date-instances">
      <h1>Date 인스턴스의 프로퍼티</h1>
      <p>Date 인스턴스는 Date 프로토타입 객체에서 속성을 상속받는 일반 객체이다. Date 인스턴스는 또한 [[DateValue]] 내부 슬롯을 가진다. [[DateValue]] 내부 슬롯은 해당 Date가 나타내는 시간 값이다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>텍스트 처리</h1>

  <emu-clause id="sec-string-objects">
    <h1>String 객체</h1>

    <emu-clause id="sec-string-constructor">
      <h1>String 생성자</h1>
      <p>String 생성자:</p>
      <ul>
        <li><dfn>%String%</dfn>이다.</li>
        <li>전역 객체의 *"String"* 프로퍼티 초기값이다.</li>
        <li>생성자로 호출될 때 새로운 String 객체를 생성하고 초기화한다.</li>
        <li>생성자가 아니라 함수로 호출되면 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 String 동작을 상속하려는 서브클래스 생성자는 [[StringData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성 및 초기화하기 위해 반드시 String 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-string-constructor-string-value">
        <h1>String ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _value_가 존재하지 않으면
            1. _s_를 빈 문자열로 둔다.
          1. 그렇지 않으면,
            1. NewTarget이 *undefined* 이고 _value_ 가 Symbol 이면 SymbolDescriptiveString(_value_)를 반환한다.
            1. _s_를 ? ToString(_value_)로 둔다.
          1. NewTarget이 *undefined*이면 _s_를 반환한다.
          1. StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *"%String.prototype%"*))를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>String 생성자의 프로퍼티</h1>
      <p>String 생성자:</p>
      <ul>
        <li>값이 %Function.prototype%인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-string.fromcharcode">
        <h1>String.fromCharCode ( ..._codeUnits_ )</h1>
        <p>이 함수는 나머지 매개변수 _codeUnits_ 를 형성하는 임의 개수의 인수와 함께 호출될 수 있다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _result_를 빈 문자열로 둔다.
          1. _codeUnits_ 의 각 요소 _next_ 에 대해
            1. _nextCU_를 ℝ(? ToUint16(_next_))의 숫자 값을 갖는 코드 유닛으로 둔다.
            1. _result_를 _result_와 _nextCU_의 문자열 결합으로 설정한다.
          1. _result_를 반환한다.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub>이다.</p>
      </emu-clause>

      <emu-clause id="sec-string.fromcodepoint">
        <h1>String.fromCodePoint ( ..._codePoints_ )</h1>
        <p>이 함수는 나머지 매개변수 _codePoints_ 를 형성하는 임의 개수의 인수와 함께 호출될 수 있다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _result_를 빈 문자열로 둔다.
          1. _codePoints_ 의 각 요소 _next_ 에 대해
            1. _nextCP_를 ? ToNumber(_next_)로 둔다.
            1. _nextCP_가 정수 Number가 아니면 *RangeError* 예외를 던진다.
            1. ℝ(_nextCP_) &lt; 0 또는 ℝ(_nextCP_) > 0x10FFFF 이면 *RangeError* 예외를 던진다.
            1. _result_를 _result_와 UTF16EncodeCodePoint(ℝ(_nextCP_))의 문자열 결합으로 설정한다.
          1. 단언: _codePoints_ 가 비어 있다면 _result_ 는 빈 문자열이다.
          1. _result_를 반환한다.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub>이다.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype">
        <h1>String.prototype</h1>
        <p>`String.prototype`의 초기값은 String 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 속성 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }를 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-string.raw">
        <h1>String.raw ( _template_, ..._substitutions_ )</h1>
        <p>이 함수는 가변 개수의 인수와 함께 호출될 수 있다. 첫 번째 인수는 _template_ 이고 나머지는 리스트 _substitutions_ 를 이룬다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _substitutionCount_를 _substitutions_의 요소 개수로 둔다.
          1. _cooked_를 ? ToObject(_template_)로 둔다.
          1. _literals_를 ? ToObject(? Get(_cooked_, *"raw"*)))로 둔다.
          1. _literalCount_를 ? LengthOfArrayLike(_literals_)로 둔다.
          1. _literalCount_ ≤ 0 이면 빈 문자열을 반환한다.
          1. _R_을 빈 문자열로 둔다.
          1. _nextIndex_를 0으로 둔다.
          1. 반복,
            1. _nextLiteralVal_을 ? Get(_literals_, ! ToString(𝔽(_nextIndex_)))로 둔다.
            1. _nextLiteral_을 ? ToString(_nextLiteralVal_)로 둔다.
            1. _R_을 _R_과 _nextLiteral_의 문자열 결합으로 설정한다.
            1. _nextIndex_ + 1 = _literalCount_ 이면 _R_을 반환한다.
            1. _nextIndex_ &lt; _substitutionCount_ 이면
              1. _nextSubVal_을 _substitutions_[_nextIndex_]로 둔다.
              1. _nextSub_를 ? ToString(_nextSubVal_)로 둔다.
              1. _R_을 _R_과 _nextSub_의 문자열 결합으로 설정한다.
            1. _nextIndex_를 _nextIndex_ + 1로 둔다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 태그드 템플릿(<emu-xref href="#sec-tagged-templates"></emu-xref>)의 태그 함수로 사용하도록 의도되었다. 그렇게 호출될 때 첫 번째 인수는 올바른 템플릿 객체이고 나머지 매개변수는 치환 값들을 담는다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>String 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>String 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%String.prototype%</dfn>이다.</li>
        <li>String 특수(exotic) 객체이며 그러한 객체에 지정된 내부 메서드를 가진다.</li>
        <li>값이 빈 문자열인 [[StringData]] 내부 슬롯을 가진다.</li>
        <li>초기값이 *+0*<sub>𝔽</sub>이고 속성이 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }인 *"length"* 프로퍼티를 가진다.</li>
        <li>값이 %Object.prototype%인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <p>명시적으로 달리 기술되지 않는 한, 아래에 정의된 String 프로토타입 객체의 메서드는 제네릭하지 않으며, 그들에게 전달되는 *this* 값은 String 값이거나 String 값으로 초기화된 [[StringData]] 내부 슬롯을 가진 객체여야 한다.</p>

      <emu-clause id="sec-string.prototype.at">
        <h1>String.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _len_을 _S_의 길이로 둔다.
          1. _relativeIndex_를 ? ToIntegerOrInfinity(_index_)로 둔다.
          1. _relativeIndex_ ≥ 0이면
            1. _k_를 _relativeIndex_로 둔다.
          1. 아니면
            1. _k_를 _len_ + _relativeIndex_로 둔다.
          1. _k_ &lt; 0 또는 _k_ ≥ _len_이면 *undefined*를 반환한다.
          1. _S_의 _k_부터 _k_ + 1 전까지 부분 문자열을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charat">
        <h1>String.prototype.charAt ( _pos_ )</h1>
        <emu-note>
          <p>이 메서드는 이 객체를 String으로 변환한 값 내에서 인덱스 _pos_ 위치의 코드 유닛을 포함하는 단일 요소 String을 반환한다. 해당 인덱스에 요소가 없으면 결과는 빈 문자열이다. 결과는 String 객체가 아닌 String 값이다.</p>
          <p>`pos`가 정수 Number이면 `x.charAt(pos)`의 결과는 `x.substring(pos, pos + 1)` 결과와 동일하다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _position_을 ? ToIntegerOrInfinity(_pos_)로 둔다.
          1. _size_를 _S_의 길이로 둔다.
          1. _position_ &lt; 0 또는 _position_ ≥ _size_이면 빈 문자열을 반환한다.
          1. _S_의 _position_부터 _position_ + 1 전까지 부분 문자열을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다; *this* 값이 String 객체일 필요가 없다. 따라서 다른 종류의 객체에 이전하여 메서드로 사용할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charcodeat">
        <h1>String.prototype.charCodeAt ( _pos_ )</h1>
        <emu-note>
          <p>이 메서드는 이 객체를 String으로 변환한 값 내에서 인덱스 _pos_ 위치 코드 유닛의 숫자 값을 나타내는 Number (0 이상 2<sup>16</sup> 미만의 음이 아닌 정수 Number)를 반환한다. 해당 인덱스에 요소가 없으면 결과는 *NaN*이다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _position_을 ? ToIntegerOrInfinity(_pos_)로 둔다.
          1. _size_를 _S_의 길이로 둔다.
          1. _position_ &lt; 0 또는 _position_ ≥ _size_이면 *NaN*을 반환한다.
          1. _S_ 내 인덱스 _position_ 코드 유닛의 숫자 값에 대한 Number 값을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다; *this* 값이 String 객체일 필요가 없다. 따라서 다른 종류의 객체에 이전하여 메서드로 사용할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.codepointat">
        <h1>String.prototype.codePointAt ( _pos_ )</h1>
        <emu-note>
          <p>이 메서드는 이 객체를 String으로 변환한 결과에서 인덱스 _pos_ 위치의 문자열 요소에서 시작하는 UTF-16 인코딩 코드 포인트(<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>)의 숫자 값을 나타내는 *0x10FFFF*<sub>𝔽</sub> 이하의 음이 아닌 정수 Number를 반환한다. 그 위치에 요소가 없으면 *undefined*를 반환한다. _pos_에서 유효한 UTF-16 서로게이트 쌍이 시작하지 않으면 결과는 _pos_의 코드 유닛이다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _position_을 ? ToIntegerOrInfinity(_pos_)로 둔다.
          1. _size_를 _S_의 길이로 둔다.
          1. _position_ &lt; 0 또는 _position_ ≥ _size_이면 *undefined*를 반환한다.
          1. _cp_를 CodePointAt(_S_, _position_)로 둔다.
          1. 𝔽(_cp_.[[CodePoint]])를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다; *this* 값이 String 객체일 필요가 없다. 따라서 다른 종류의 객체에 이전하여 메서드로 사용할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.concat">
        <h1>String.prototype.concat ( ..._args_ )</h1>
        <emu-note>
          <p>이 메서드는 *this* 값(문자열로 변환)의 코드 유닛 뒤에 각 인수를 문자열로 변환한 코드 유닛을 이어붙인 String 값을 반환한다. 결과는 String 객체가 아닌 String 값이다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _R_을 _S_로 둔다.
          1. _args_의 각 요소 _next_ 에 대해
            1. _nextString_을 ? ToString(_next_)로 둔다.
            1. _R_을 _R_과 _nextString_의 문자열 결합으로 설정한다.
          1. _R_을 반환한다.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub>이다.</p>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다; *this* 값이 String 객체일 필요가 없다. 따라서 다른 종류의 객체에 이전하여 메서드로 사용할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.constructor">
        <h1>String.prototype.constructor</h1>
        <p>`String.prototype.constructor`의 초기값은 %String%이다.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype.endswith">
        <h1>String.prototype.endsWith ( _searchString_ [ , _endPosition_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _isRegExp_를 ? IsRegExp(_searchString_)로 둔다.
          1. _isRegExp_가 *true*이면 *TypeError* 예외를 던진다.
          1. _searchStr_를 ? ToString(_searchString_)로 둔다.
          1. _len_을 _S_의 길이로 둔다.
          1. _endPosition_이 *undefined*이면 _pos_를 _len_으로, 아니면 _pos_를 ? ToIntegerOrInfinity(_endPosition_)로 둔다.
          1. _end_를 _pos_를 0과 _len_ 사이로 클램프한 결과로 둔다.
          1. _searchLength_를 _searchStr_의 길이로 둔다.
          1. _searchLength_ = 0이면 *true*를 반환한다.
          1. _start_를 _end_ - _searchLength_로 둔다.
          1. _start_ &lt; 0이면 *false*를 반환한다.
          1. _substring_을 _S_의 _start_부터 _end_ 전까지 부분 문자열로 둔다.
          1. _substring_이 _searchStr_이면 *true*를 반환한다.
          1. *false*를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 _searchString_의 코드 유닛 시퀀스(문자열로 변환)가 이 객체(문자열로 변환)의 해당 코드 유닛과 _endPosition_ - length(this) 지점부터 일치하면 *true*를 반환한다. 그렇지 않으면 *false*를 반환한다.</p>
        </emu-note>
        <emu-note>
          <p>첫 번째 인수가 RegExp이면 예외를 던지는 것은 향후 버전에서 그러한 인수 값을 허용하는 확장을 정의할 수 있도록 하기 위한 것이다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다; *this* 값이 String 객체일 필요가 없다. 따라서 다른 객체로 이전하여 사용할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.includes">
        <h1>String.prototype.includes ( _searchString_ [ , _position_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _isRegExp_를 ? IsRegExp(_searchString_)로 둔다.
          1. _isRegExp_가 *true*이면 *TypeError* 예외를 던진다.
          1. _searchStr_를 ? ToString(_searchString_)로 둔다.
          1. _pos_를 ? ToIntegerOrInfinity(_position_)로 둔다.
          1. 단언: _position_이 *undefined*이면 _pos_는 0이다.
          1. _len_을 _S_의 길이로 둔다.
          1. _start_를 _pos_를 0과 _len_ 사이로 클램프한 결과로 둔다.
          1. _index_를 StringIndexOf(_S_, _searchStr_, _start_)로 둔다.
          1. _index_가 ~not-found~이면 *false*를 반환한다.
          1. *true*를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_searchString_이 이 객체를 String으로 변환한 결과의 _position_ 이상 인덱스들에서 하나 이상 <emu-not-ref>substring</emu-not-ref>으로 나타나면 *true*를 반환하고, 아니면 *false*를 반환한다. _position_이 *undefined*이면 0을 가정하여 전체 문자열을 검색한다.</p>
        </emu-note>
        <emu-note>
          <p>첫 번째 인수가 RegExp이면 예외를 던지는 것은 향후 버전 확장을 위해서이다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다; *this* 값이 String 객체일 필요가 없다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.indexof">
        <h1>String.prototype.indexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>_searchString_이 이 객체를 String으로 변환한 결과의 _position_ 이상 인덱스 중 하나 이상에서 <emu-not-ref>substring</emu-not-ref>으로 나타나면 그중 가장 작은 인덱스를 반환하고, 아니면 *-1*<sub>𝔽</sub>을 반환한다. _position_이 *undefined*이면 *+0*<sub>𝔽</sub>을 가정하여 전체 문자열을 검색한다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _searchStr_를 ? ToString(_searchString_)로 둔다.
          1. _pos_를 ? ToIntegerOrInfinity(_position_)로 둔다.
          1. 단언: _position_이 *undefined*이면 _pos_는 0이다.
          1. _len_을 _S_의 길이로 둔다.
          1. _start_를 _pos_를 0과 _len_ 사이로 클램프한 결과로 둔다.
          1. _result_를 StringIndexOf(_S_, _searchStr_, _start_)로 둔다.
          1. _result_가 ~not-found~이면 *-1*<sub>𝔽</sub>을 반환한다.
          1. 𝔽(_result_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.iswellformed">
        <h1>String.prototype.isWellFormed ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. IsStringWellFormedUnicode(_S_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.lastindexof">
        <h1>String.prototype.lastIndexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>_searchString_이 이 객체를 String으로 변환한 결과에서 _position_ 이하 인덱스 하나 이상에서 <emu-not-ref>substring</emu-not-ref>으로 나타나면 그중 가장 큰 인덱스를 반환하고 아니면 *-1*<sub>𝔽</sub>을 반환한다. _position_이 *undefined*이면 문자열 길이를 가정하여 전체를 검색한다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)으로 둔다.
          1. _searchStr_을 ? ToString(_searchString_)으로 둔다.
          1. _numPos_를 ? ToNumber(_position_)으로 둔다.
          1. Assert: _position_이 *undefined*이면, _numPos_는 *NaN*이다.
          1. _numPos_가 *NaN*이면 _pos_를 +∞로, 아니면 _pos_를 ! ToIntegerOrInfinity(_numPos_)로 둔다.
          1. _len_을 _S_의 길이로 둔다.
          1. _searchLen_을 _searchStr_의 길이로 둔다.
          1. _len_ &lt; _searchLen_이면, *-1*<sub>𝔽</sub>을 반환한다.
          1. _start_를 _pos_를 0과 _len_ - _searchLen_ 사이로 클램프한 결과로 둔다.
          1. _result_를 StringLastIndexOf(_S_, _searchStr_, _start_)로 둔다.
          1. _result_가 ~not-found~이면, *-1*<sub>𝔽</sub>을 반환한다.
          1. 𝔽(_result_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.localecompare">
        <h1>String.prototype.localeCompare ( _that_ [ , _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API를 포함하는 구현은 ECMA-402 명세에 따라 이 메서드를 구현해야 한다. 포함하지 않는 구현은 다음 명세를 사용한다:</p>
        <p>이 메서드는 *this* 값(문자열로 변환된 _S_)과 _that_(문자열로 변환된 _thatValue_)의 구현 정의 로케일 민감 문자열 비교 결과를 나타내는 *NaN*이 아닌 Number를 반환한다. 결과는 호스트 환경 현재 로케일 관례에 따른 정렬 순서를 반영하며, _S_가 _thatValue_ 앞이면 음수, 뒤면 양수, 그 외 경우(상대적 순서 없음) 0을 반환한다.</p>
        <p>비교 수행 전 다음 준비 단계를 거친다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _thatValue_를 ? ToString(_that_)로 둔다.
        </emu-alg>
        <p>두 번째와 세 번째 선택적 매개변수 의미는 ECMA-402 명세에 정의된다; 이를 포함하지 않는 구현은 다른 해석을 부여해서는 안 된다.</p>
        <p>실제 반환 값은 추가 정보를 인코딩할 수 있도록 구현 정의이지만, 두 인수 메서드로 간주될 때 모든 문자열에 대해 총순서를 정의하는 일관된 비교자여야 한다. 또한 이 메서드는 Unicode 표준에 따른 정규( canonical ) 등가성을 인지하고 존중하여 구분 가능하지만 정규 등가인 문자열 비교 시 *+0*<sub>𝔽</sub>을 반환해야 한다.</p>
        <emu-note>
          <p>이 메서드 자체는 `Array.prototype.sort`에 직접 넘기기 적합하지 않다. 후자는 두 인수 함수를 요구한다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 호스트 환경이 제공하는 언어/로케일 민감 비교 기능을 사용할 수 있으며, 현재 로케일 규칙에 따라 비교하도록 의도되었다. 그러나 어떤 비교 능력이든 Unicode 표준의 정규 등가성은 반드시 존중해야 한다 — 예: 아래 모든 비교는 *+0*<sub>𝔽</sub>을 반환해야 한다:</p>
          <pre><code class="javascript">
            // &#x212B; ANGSTROM SIGN vs.
            // A&#x030A; LATIN CAPITAL LETTER A + COMBINING RING ABOVE
            "\u212B".localeCompare("A\u030A")

            // &#x2126; OHM SIGN vs.
            // &#x03A9; GREEK CAPITAL LETTER OMEGA
            "\u2126".localeCompare("\u03A9")

            // &#x1E69; LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
            // s&#x0307;&#x0323; LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
            "\u1E69".localeCompare("s\u0307\u0323")

            // &#x1E0B;&#x0323; LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
            // &#x1E0D;&#x0307; LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
            "\u1E0B\u0323".localeCompare("\u1E0D\u0307")

            // &#x1100;&#x1161; HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
            // &#xAC00; HANGUL SYLLABLE GA
            "\u1100\u1161".localeCompare("\uAC00")
          </code></pre>
          <p>정규 등가성 정의와 논의는 Unicode 표준 2, 3장 및 <a href="https://unicode.org/reports/tr15/">UAX #15</a>, <a href="https://unicode.org/notes/tn5/">Unicode Technical Note #5</a>, <a href="https://unicode.org/reports/tr10/">UTS #10</a>를 참조.</p>
          <p>Unicode 호환 등가 또는 호환 분해는 존중하지 않는 것이 권장된다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.match">
        <h1>String.prototype.match ( _regexp_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _regexp_가 *undefined*도 *null*도 아니면
            1. _matcher_를 ? GetMethod(_regexp_, %Symbol.match%)로 둔다.
            1. _matcher_가 *undefined*가 아니면
              1. ? Call(_matcher_, _regexp_, « _O_ »)를 반환한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _rx_를 ? RegExpCreate(_regexp_, *undefined*)로 둔다.
          1. ? Invoke(_rx_, %Symbol.match%, « _S_ »)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.matchall">
        <h1>String.prototype.matchAll ( _regexp_ )</h1>
        <p>이 메서드는 *this* 값이 나타내는 문자열에 대해 정규 표현식 매칭을 수행하고 매치 결과를 내는 이터레이터를 반환한다. 각 매치 결과는 첫 요소가 매치된 부분 문자열이고 이후 캡처 그룹에 매치된 부분을 담는 배열이다. 정규 표현식이 전혀 매치되지 않으면 이터레이터는 아무것도 산출하지 않는다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>

        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _regexp_가 *undefined*도 *null*도 아니면
            1. _isRegExp_를 ? IsRegExp(_regexp_)로 둔다.
            1. _isRegExp_가 *true*이면
              1. _flags_를 ? Get(_regexp_, *"flags"*)로 둔다.
              1. ? RequireObjectCoercible(_flags_)를 수행한다.
              1. ? ToString(_flags_)에 *"g"*가 없으면 *TypeError* 예외를 던진다.
            1. _matcher_를 ? GetMethod(_regexp_, %Symbol.matchAll%)로 둔다.
            1. _matcher_가 *undefined*가 아니면
              1. ? Call(_matcher_, _regexp_, « _O_ »)를 반환한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _rx_를 ? RegExpCreate(_regexp_, *"g"*)로 둔다.
          1. ? Invoke(_rx_, %Symbol.matchAll%, « _S_ »)를 반환한다.
        </emu-alg>
        <emu-note>이 메서드는 의도적으로 제네릭이며 *this* 값이 String 객체일 필요가 없다.</emu-note>
        <emu-note>`String.prototype.split`과 유사하게 일반적으로 입력을 변형하지 않도록 설계되었다.</emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.normalize">
        <h1>String.prototype.normalize ( [ _form_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _form_이 *undefined*이면 _f_를 *"NFC"*로 둔다.
          1. 아니면 _f_를 ? ToString(_form_)으로 둔다.
          1. _f_가 *"NFC"*, *"NFD"*, *"NFKC"*, *"NFKD"* 중 하나가 아니면 *RangeError* 예외를 던진다.
          1. _ns_를 최신 Unicode Standard 의 Normalization Forms 에 지정된 대로 _S_를 _f_가 명명하는 정규화 형식으로 정규화한 결과 String 값으로 둔다.
          1. _ns_를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padend">
        <h1>String.prototype.padEnd ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padstart">
        <h1>String.prototype.padStart ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~)를 반환한다.
        </emu-alg>

        <emu-clause id="sec-stringpaddingbuiltinsimpl" type="abstract operation">
          <h1>
            StringPaddingBuiltinsImpl (
              _O_: ECMAScript 언어 값,
              _maxLength_: ECMAScript 언어 값,
              _fillString_: ECMAScript 언어 값,
              _placement_: ~start~ 또는 ~end~,
            ): 정상 완료(문자열) 또는 throw 완료
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _S_를 ? ToString(_O_)로 둔다.
            1. _intMaxLength_를 ℝ(? ToLength(_maxLength_))로 둔다.
            1. _stringLength_를 _S_의 길이로 둔다.
            1. _intMaxLength_ ≤ _stringLength_이면 _S_를 반환한다.
            1. _fillString_이 *undefined*이면 _fillString_을 코드 유닛 0x0020 (SPACE) 하나로 이루어진 문자열 값으로 둔다.
            1. 아니면 _fillString_을 ? ToString(_fillString_)으로 둔다.
            1. StringPad(_S_, _intMaxLength_, _fillString_, _placement_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-stringpad" type="abstract operation">
          <h1>
            StringPad (
              _S_: 문자열,
              _maxLength_: 음이 아닌 정수,
              _fillString_: 문자열,
              _placement_: ~start~ 또는 ~end~,
            ): 문자열
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _stringLength_를 _S_의 길이로 둔다.
            1. _maxLength_ ≤ _stringLength_이면 _S_를 반환한다.
            1. _fillString_이 빈 문자열이면 _S_를 반환한다.
            1. _fillLen_을 _maxLength_ - _stringLength_로 둔다.
            1. _truncatedStringFiller_를 _fillString_을 반복 결합한 뒤 길이 _fillLen_으로 자른 문자열 값으로 둔다.
            1. _placement_가 ~start~이면 _truncatedStringFiller_와 _S_의 문자열 결합을 반환한다.
            1. 그렇지 않으면 _S_와 _truncatedStringFiller_의 문자열 결합을 반환한다.
          </emu-alg>
          <emu-note>
            <p>인수 _maxLength_는 _S_의 길이보다 작아질 수 없도록 클램프된다.</p>
          </emu-note>
          <emu-note>
            <p>인수 _fillString_의 기본값은 *" "* (코드 유닛 0x0020 SPACE 하나)이다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-tozeropaddeddecimalstring" type="abstract operation">
          <h1>
            ToZeroPaddedDecimalString (
              _n_: 음이 아닌 정수,
              _minLength_: 음이 아닌 정수,
            ): 문자열
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _S_를 _n_의 10진수 형식 문자열 표현으로 둔다.
            1. StringPad(_S_, _minLength_, *"0"*, ~start~)를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.repeat">
        <h1>String.prototype.repeat ( _count_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _n_을 ? ToIntegerOrInfinity(_count_)로 둔다.
          1. _n_ &lt; 0 또는 _n_ = +∞이면 *RangeError* 예외를 던진다.
          1. _n_ = 0이면 빈 문자열을 반환한다.
          1. _S_를 _n_번 이어붙여 만든 문자열 값을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 *this* 값을 문자열로 변환한 것의 코드 유닛을 _count_ 번 반복한 String 값을 만든다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replace">
        <h1>String.prototype.replace ( _searchValue_, _replaceValue_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _searchValue_가 *undefined*도 *null*도 아니면
            1. _replacer_를 ? GetMethod(_searchValue_, %Symbol.replace%)로 둔다.
            1. _replacer_가 *undefined*가 아니면
              1. ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »)를 반환한다.
          1. _string_을 ? ToString(_O_)로 둔다.
          1. _searchString_을 ? ToString(_searchValue_)로 둔다.
          1. _functionalReplace_를 IsCallable(_replaceValue_)로 둔다.
          1. _functionalReplace_가 *false*이면
            1. _replaceValue_를 ? ToString(_replaceValue_)로 둔다.
          1. _searchLength_를 _searchString_의 길이로 둔다.
          1. _position_을 StringIndexOf(_string_, _searchString_, 0)으로 둔다.
          1. _position_이 ~not-found~이면 _string_을 반환한다.
          1. _preceding_을 _string_의 0부터 _position_ 전까지 부분 문자열로 둔다.
          1. _following_을 _string_의 _position_ + _searchLength_부터 끝까지 부분 문자열로 둔다.
          1. _functionalReplace_가 *true*이면
            1. _replacement_를 ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »))로 둔다.
          1. 아니면
            1. 단언: _replaceValue_는 문자열이다.
            1. _captures_를 새 빈 리스트로 둔다.
            1. _replacement_를 ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_)로 둔다.
          1. _preceding_, _replacement_, _following_의 문자열 결합을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>

        <emu-clause id="sec-getsubstitution" type="abstract operation" oldids="table-replacement-text-symbol-substitutions,table-45">
          <h1>
            GetSubstitution (
              _matched_: 문자열,
              _str_: 문자열,
              _position_: 음이 아닌 정수,
              _captures_: 문자열 또는 *undefined* 요소를 갖는 리스트,
              _namedCaptures_: 객체 또는 *undefined*,
              _replacementTemplate_: 문자열,
            ): 정상 완료(문자열) 또는 throw 완료
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>이 추상 연산에서 <em>10진 숫자(digital digit)</em>는 0x0030 (DIGIT ZERO)부터 0x0039 (DIGIT NINE)까지 포함 구간의 코드 유닛이다.</dd>
          </dl>
          <emu-alg>
            1. _stringLength_를 _str_의 길이로 둔다.
            1. 단언: _position_ ≤ _stringLength_.
            1. _result_를 빈 문자열로 둔다.
            1. _templateRemainder_를 _replacementTemplate_로 둔다.
            1. _templateRemainder_가 빈 문자열이 아닐 동안 반복,
              1. [declared="ref,refReplacement"] 주: 다음 단계들은 _ref_ ( _templateRemainder_의 접두사 )를 분리하고 _refReplacement_ (그 치환)를 결정한 뒤 _result_에 추가한다.
              1. _templateRemainder_가 *"$$"*로 시작하면
                1. _ref_를 *"$$"*로.
                1. _refReplacement_를 *"$"*로.
              1. 아니고 *"$`"*로 시작하면
                1. _ref_를 *"$`"*로.
                1. _refReplacement_를 _str_의 0부터 _position_ 전까지 부분 문자열로.
              1. 아니고 *"$&amp;"*로 시작하면
                1. _ref_를 *"$&amp;"*로.
                1. _refReplacement_를 _matched_로.
              1. 아니고 *"$'"* (0x0024 DOLLAR SIGN + 0x0027 APOSTROPHE)로 시작하면
                1. _ref_를 *"$'"*로.
                1. _matchLength_를 _matched_의 길이로.
                1. _tailPos_를 _position_ + _matchLength_로.
                1. _refReplacement_를 _str_의 min(_tailPos_, _stringLength_)부터 끝까지 부분 문자열로.
                1. 참고: _tailPos_가 _stringLength_를 넘을 수 있는 경우는 이 추상 연산이 본래 내장 %RegExp.prototype.exec%가 아닌 *"exec"* 프로퍼티를 가진 객체에서 %RegExp.prototype%의 본래 %Symbol.replace% 호출로 유래했을 때뿐이다.
              1. 아니고 *"$"* 뒤에 1개 이상의 10진 숫자로 시작하면
                1. *"$"* 뒤에 두 자리 이상 숫자로 시작하면 _digitCount_를 2로, 아니면 1로 둔다.
                1. _digits_를 _templateRemainder_의 1부터 1 + _digitCount_ 전까지 부분 문자열로.
                1. _index_를 ℝ(StringToNumber(_digits_))로.
                1. 단언: 0 ≤ _index_ ≤ 99.
                1. _captureLen_을 _captures_의 요소 개수로.
                1. _index_ > _captureLen_ 이고 _digitCount_ = 2 이면
                  1. 주: 두 자리 패턴이 캡처 개수를 넘는 인덱스를 지정하면 한 자리 패턴 + 리터럴 숫자로 취급된다.
                  1. _digitCount_를 1로.
                  1. _digits_를 _digits_의 0부터 1 전까지 부분 문자열로.
                  1. _index_를 ℝ(StringToNumber(_digits_))로.
                1. _ref_를 _templateRemainder_의 0부터 1 + _digitCount_ 전까지 부분 문자열로.
                1. 1 ≤ _index_ ≤ _captureLen_ 이면
                  1. _capture_를 _captures_[_index_ - 1]로.
                  1. _capture_가 *undefined*이면
                    1. _refReplacement_를 빈 문자열로.
                  1. 아니면
                    1. _refReplacement_를 _capture_로.
                1. 아니면
                  1. _refReplacement_를 _ref_로.
              1. 아니고 *"$&lt;"*로 시작하면
                1. _gtPos_를 StringIndexOf(_templateRemainder_, *">"*, 0)으로.
                1. _gtPos_가 ~not-found~ 이거나 _namedCaptures_가 *undefined*이면
                  1. _ref_를 *"$&lt;"*로.
                  1. _refReplacement_를 _ref_로.
                1. 아니면
                  1. _ref_를 _templateRemainder_의 0부터 _gtPos_ + 1 전까지 부분 문자열로.
                  1. _groupName_을 _templateRemainder_의 2부터 _gtPos_ 전까지 부분 문자열로.
                  1. 단언: _namedCaptures_는 객체이다.
                  1. _capture_를 ? Get(_namedCaptures_, _groupName_)으로.
                  1. _capture_가 *undefined*이면
                    1. _refReplacement_를 빈 문자열로.
                  1. 아니면
                    1. _refReplacement_를 ? ToString(_capture_)로.
              1. 아니면
                1. _ref_를 _templateRemainder_의 0부터 1 전까지 부분 문자열로.
                1. _refReplacement_를 _ref_로.
              1. _refLength_를 _ref_의 길이로.
              1. _templateRemainder_를 _templateRemainder_의 _refLength_부터 끝까지 부분 문자열로 둔다.
              1. _result_를 _result_와 _refReplacement_의 문자열 결합으로 설정한다.
            1. _result_를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replaceall">
        <h1>String.prototype.replaceAll ( _searchValue_, _replaceValue_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _searchValue_가 *undefined*도 *null*도 아니면
            1. _isRegExp_를 ? IsRegExp(_searchValue_)로 둔다.
            1. _isRegExp_가 *true*이면
              1. _flags_를 ? Get(_searchValue_, *"flags"*)로 둔다.
              1. ? RequireObjectCoercible(_flags_)를 수행한다.
              1. ? ToString(_flags_)에 *"g"*가 없으면 *TypeError* 예외를 던진다.
            1. _replacer_를 ? GetMethod(_searchValue_, %Symbol.replace%)로 둔다.
            1. _replacer_가 *undefined*가 아니면
              1. ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »)를 반환한다.
          1. _string_을 ? ToString(_O_)로 둔다.
          1. _searchString_을 ? ToString(_searchValue_)로 둔다.
          1. _functionalReplace_를 IsCallable(_replaceValue_)로 둔다.
          1. _functionalReplace_가 *false*이면
            1. _replaceValue_를 ? ToString(_replaceValue_)로 둔다.
          1. _searchLength_를 _searchString_의 길이로 둔다.
          1. _advanceBy_를 max(1, _searchLength_)로 둔다.
          1. _matchPositions_를 새 빈 리스트로 둔다.
          1. _position_을 StringIndexOf(_string_, _searchString_, 0)으로 둔다.
          1. _position_이 ~not-found~가 아닐 동안 반복,
            1. _matchPositions_에 _position_을 추가한다.
            1. _position_을 StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_)로 둔다.
          1. _endOfLastMatch_를 0으로 둔다.
          1. _result_를 빈 문자열로 둔다.
          1. _matchPositions_의 각 요소 _p_ 에 대해
            1. _preserved_를 _string_의 _endOfLastMatch_부터 _p_ 전까지 부분 문자열로 둔다.
            1. _functionalReplace_가 *true*이면
              1. _replacement_를 ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »))로 둔다.
            1. 아니면
              1. 단언: _replaceValue_는 문자열이다.
              1. _captures_를 새 빈 리스트로 둔다.
              1. _replacement_를 ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_)로 둔다.
            1. _result_를 _result_, _preserved_, _replacement_의 문자열 결합으로 설정한다.
            1. _endOfLastMatch_를 _p_ + _searchLength_로 둔다.
          1. _endOfLastMatch_ &lt; _string_ 길이면
            1. _result_를 _result_와 _string_의 _endOfLastMatch_부터 끝까지 부분 문자열 결합으로 설정한다.
          1. _result_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.search">
        <h1>String.prototype.search ( _regexp_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _regexp_가 *undefined*도 *null*도 아니면
            1. _searcher_를 ? GetMethod(_regexp_, %Symbol.search%)로 둔다.
            1. _searcher_가 *undefined*가 아니면
              1. ? Call(_searcher_, _regexp_, « _O_ »)를 반환한다.
          1. _string_을 ? ToString(_O_)로 둔다.
          1. _rx_를 ? RegExpCreate(_regexp_, *undefined*)로 둔다.
          1. ? Invoke(_rx_, %Symbol.search%, « _string_ »)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.slice">
        <h1>String.prototype.slice ( _start_, _end_ )</h1>
        <p>이 메서드는 이 객체를 문자열로 변환한 결과에서 인덱스 _start_부터 _end_ (포함하지 않음) 전까지(<em>_end_가 *undefined*이면 끝까지</em>) <emu-not-ref>substring</emu-not-ref>을 반환한다. _start_가 음수면 _sourceLength_ + _start_로 처리하고, _end_가 음수면 _sourceLength_ + _end_로 처리한다 (_sourceLength_는 문자열 길이). 결과는 String 객체가 아닌 String 값이다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _len_을 _S_의 길이로 둔다.
          1. _intStart_를 ? ToIntegerOrInfinity(_start_)로 둔다.
          1. _intStart_ = -∞이면 _from_을 0으로.
          1. 아니고 _intStart_ &lt; 0이면 _from_을 max(_len_ + _intStart_, 0)으로.
          1. 아니면 _from_을 min(_intStart_, _len_)으로.
          1. _end_가 *undefined*이면 _intEnd_를 _len_으로, 아니면 _intEnd_를 ? ToIntegerOrInfinity(_end_)로.
          1. _intEnd_ = -∞이면 _to_를 0으로.
          1. 아니고 _intEnd_ &lt; 0이면 _to_를 max(_len_ + _intEnd_, 0)으로.
          1. 아니면 _to_를 min(_intEnd_, _len_)으로.
          1. _from_ ≥ _to_이면 빈 문자열을 반환한다.
          1. _S_의 _from_부터 _to_ 전까지 부분 문자열을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.split">
        <h1>String.prototype.split ( _separator_, _limit_ )</h1>
        <p>이 메서드는 이 객체를 문자열로 변환한 결과를 분할해 그 부분 문자열들을 담은 배열을 반환한다. 왼쪽에서 오른쪽으로 _separator_ 발생 지점을 찾으며, 이 지점들은 결과 배열 문자열 일부가 아니고 경계를 나눈다. _separator_ 값은 임의 길이의 문자열이거나 %Symbol.split% 메서드를 가진 객체(예: RegExp)일 수 있다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _separator_가 *undefined*도 *null*도 아니면
            1. _splitter_를 ? GetMethod(_separator_, %Symbol.split%)로 둔다.
            1. _splitter_가 *undefined*가 아니면
              1. ? Call(_splitter_, _separator_, « _O_, _limit_ »)를 반환한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _limit_이 *undefined*이면 _lim_을 2<sup>32</sup> - 1로, 아니면 _lim_을 ℝ(? ToUint32(_limit_))로.
          1. _R_을 ? ToString(_separator_)로 둔다.
          1. _lim_ = 0이면
            1. CreateArrayFromList(« »)를 반환한다.
          1. _separator_가 *undefined*이면
            1. CreateArrayFromList(« _S_ »)를 반환한다.
          1. _separatorLength_를 _R_의 길이로 둔다.
          1. _separatorLength_ = 0이면
            1. _strLen_을 _S_의 길이로.
            1. _outLen_을 _lim_을 0과 _strLen_ 사이로 클램프한 결과로.
            1. _head_를 _S_의 0부터 _outLen_ 전까지 부분 문자열로.
            1. _codeUnits_를 _head_ 요소 코드 유닛 시퀀스로 이루어진 리스트로.
            1. CreateArrayFromList(_codeUnits_)를 반환한다.
          1. _S_가 빈 문자열이면 CreateArrayFromList(« _S_ »)를 반환한다.
          1. _substrings_를 새 빈 리스트로 둔다.
          1. _i_를 0으로 둔다.
          1. _j_를 StringIndexOf(_S_, _R_, 0)으로 둔다.
          1. _j_가 ~not-found~가 아닐 동안 반복,
            1. _T_를 _S_의 _i_부터 _j_ 전까지 부분 문자열로 둔다.
            1. _substrings_에 _T_를 추가한다.
            1. _substrings_ 요소 수가 _lim_이면 CreateArrayFromList(_substrings_)를 반환한다.
            1. _i_를 _j_ + _separatorLength_로 둔다.
            1. _j_를 StringIndexOf(_S_, _R_, _i_)로 둔다.
          1. _T_를 _S_의 _i_부터 끝까지 부분 문자열로 둔다.
          1. _substrings_에 _T_를 추가한다.
          1. CreateArrayFromList(_substrings_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_separator_ 값은 빈 문자열일 수 있다. 이 경우 _separator_는 시작/끝의 빈 <emu-not-ref>substring</emu-not-ref>이나 직전 매치 후의 빈 <emu-not-ref>substring</emu-not-ref>와 매치하지 않는다. _separator_가 빈 문자열이면 문자열은 개별 코드 유닛 요소로 분리되며 결과 배열 길이는 문자열 길이와 같고 각 <emu-not-ref>substring</emu-not-ref>은 한 코드 유닛을 포함한다.</p>
          <p>*this* 값이(또는 변환 결과가) 빈 문자열이면 _separator_가 빈 문자열과 매치 가능한지 여부에 따라 결과가 달라진다. 매치 가능하면 결과 배열은 비어 있다. 아니면 빈 문자열 하나를 요소로 가진다.</p>
          <p>_separator_가 *undefined*이면 결과 배열은 *this* 값(문자열로 변환) 하나만 가진다. _limit_이 *undefined*가 아니면 결과 배열은 _limit_ 요소를 넘지 않도록 잘린다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.startswith">
        <h1>String.prototype.startsWith ( _searchString_ [ , _position_ ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _isRegExp_를 ? IsRegExp(_searchString_)로 둔다.
          1. _isRegExp_가 *true*이면 *TypeError* 예외를 던진다.
          1. _searchStr_를 ? ToString(_searchString_)로 둔다.
          1. _len_을 _S_의 길이로 둔다.
          1. _position_이 *undefined*이면 _pos_를 0으로, 아니면 _pos_를 ? ToIntegerOrInfinity(_position_)로 둔다.
          1. _start_를 _pos_를 0과 _len_ 사이로 클램프한 결과로 둔다.
          1. _searchLength_를 _searchStr_의 길이로 둔다.
          1. _searchLength_ = 0이면 *true*를 반환한다.
          1. _end_를 _start_ + _searchLength_로 둔다.
          1. _end_ > _len_이면 *false*를 반환한다.
          1. _substring_을 _S_의 _start_부터 _end_ 전까지 부분 문자열로 둔다.
          1. _substring_이 _searchStr_이면 *true*를 반환한다.
          1. *false*를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 _searchString_이 문자열로 변환된 코드 유닛 시퀀스가 _position_ 인덱스에서 시작하는 이 객체(문자열 변환)의 대응 코드 유닛과 같으면 *true*를 반환한다.</p>
        </emu-note>
        <emu-note>
          <p>첫 번째 인수가 RegExp이면 예외를 던지는 것은 향후 확장을 위해서이다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.substring">
        <h1>String.prototype.substring ( _start_, _end_ )</h1>
        <p>이 메서드는 이 객체를 String으로 변환한 결과에서 인덱스 _start_부터 _end_ (포함하지 않음) 전까지(<em>_end_가 *undefined*이면 끝까지</em>) <emu-not-ref>substring</emu-not-ref>을 반환한다. 결과는 String 객체가 아닌 String 값이다.</p>
        <p>어느 인수라도 *NaN* 또는 음수면 0으로 대체되고, 어느 인수가 문자열 길이를 초과하면 그 길이로 대체된다.</p>
        <p>_start_ > _end_이면 둘을 교환한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _len_을 _S_의 길이로 둔다.
          1. _intStart_를 ? ToIntegerOrInfinity(_start_)로 둔다.
          1. _end_가 *undefined*이면 _intEnd_를 _len_으로, 아니면 _intEnd_를 ? ToIntegerOrInfinity(_end_)로 둔다.
          1. _finalStart_를 _intStart_를 0과 _len_ 사이로 클램프한 결과로 둔다.
          1. _finalEnd_를 _intEnd_를 0과 _len_ 사이로 클램프한 결과로 둔다.
          1. _from_을 min(_finalStart_, _finalEnd_)로 둔다.
          1. _to_를 max(_finalStart_, _finalEnd_)로 둔다.
          1. _S_의 _from_부터 _to_ 전까지 부분 문자열을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocalelowercase">
        <h1>String.prototype.toLocaleLowerCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API를 포함한 구현은 ECMA-402 명세에 따라 구현해야 한다. 포함하지 않으면 다음 명세를 따른다:</p>
        <p>이 메서드는 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>에 설명된 대로 문자열 값을 UTF-16 인코딩 코드 포인트 시퀀스로 해석한다.</p>
        <p>`toLowerCase`와 동일하게 동작하지만 로케일에 민감한 결과(예: 터키어의 특수 규칙)를 낸다.</p>
        <p>선택적 매개변수 의미는 ECMA-402 명세에 정의되며, 이를 지원하지 않는 구현은 다른 의미를 부여해서는 안 된다.</p>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocaleuppercase">
        <h1>String.prototype.toLocaleUpperCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API를 포함한 구현은 ECMA-402 명세에 따라 구현해야 한다. 포함하지 않으면 다음 명세를 따른다:</p>
        <p>이 메서드는 문자열 값을 UTF-16 인코딩 코드 포인트 시퀀스로 해석한다.</p>
        <p>`toUpperCase`와 동일하게 동작하지만 로케일 민감한 결과를 낸다.</p>
        <p>선택적 매개변수 의미는 ECMA-402 명세에 정의되며, 비지원 구현은 다른 의미를 부여할 수 없다.</p>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolowercase">
        <h1>String.prototype.toLowerCase ( )</h1>
        <p>이 메서드는 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>에 설명된 대로 문자열 값을 UTF-16 코드 포인트 시퀀스로 해석한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _sText_를 StringToCodePoints(_S_)로 둔다.
          1. _lowerText_를 Unicode 기본 대소문자 변환 알고리즘에 따라 toLowercase(_sText_)로 둔다.
          1. _L_을 CodePointsToString(_lowerText_)로 둔다.
          1. _L_을 반환한다.
        </emu-alg>
        <p>결과는 Unicode Character Database의 로케일 비의존 매핑( <a href="https://unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"><code>UnicodeData.txt</code></a> 및 그것과 동반하는 <a href="https://unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt"><code>SpecialCasing.txt</code></a> 의 로케일 비의존 매핑 )을 따라 파생되어야 한다.</p>
        <emu-note>
          <p>몇몇 코드 포인트의 대소문자 매핑은 여러 코드 포인트를 생성할 수 있다. 이 경우 결과 문자열 길이는 원본과 다를 수 있다. `toUpperCase`와 `toLowerCase`는 문맥 민감하므로 대칭이 아니다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tostring">
        <h1>String.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisStringValue(*this* value)을 반환한다.
        </emu-alg>
        <emu-note>
          <p>String 객체의 경우 이 메서드는 `valueOf`와 동일한 것을 반환한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.touppercase">
        <h1>String.prototype.toUpperCase ( )</h1>
        <p>이 메서드는 문자열 값을 UTF-16 코드 포인트 시퀀스로 해석한다.</p>
        <p>Unicode 기본 대소문자 변환의 toUppercase 알고리즘을 사용한다는 점만 제외하고 `String.prototype.toLowerCase`와 동일하게 동작한다.</p>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.towellformed">
        <h1>String.prototype.toWellFormed ( )</h1>
        <p>이 메서드는 고립된 선행 또는 후행 서로게이트(서로게이트 쌍을 이루지 않는)를 U+FFFD (REPLACEMENT CHARACTER)로 치환한 이 객체의 문자열 표현을 반환한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _S_를 ? ToString(_O_)로 둔다.
          1. _strLen_을 _S_의 길이로 둔다.
          1. _k_를 0으로 둔다.
          1. _result_를 빈 문자열로 둔다.
          1. _k_ &lt; _strLen_ 동안 반복,
            1. _cp_를 CodePointAt(_S_, _k_)로 둔다.
            1. _cp_.[[IsUnpairedSurrogate]]가 *true*이면
              1. _result_를 _result_와 0xFFFD (REPLACEMENT CHARACTER) 결합으로 둔다.
            1. 아니면
              1. _result_를 _result_와 UTF16EncodeCodePoint(_cp_.[[CodePoint]]) 결합으로 둔다.
            1. _k_를 _k_ + _cp_.[[CodeUnitCount]]로 둔다.
          1. _result_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trim">
        <h1>String.prototype.trim ( )</h1>
        <p>이 메서드는 문자열 값을 UTF-16 코드 포인트 시퀀스로 해석한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_를 *this* 값으로 둔다.
          1. ? TrimString(_S_, ~start+end~)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>

        <emu-clause id="sec-trimstring" type="abstract operation">
          <h1>
            TrimString (
              _string_: ECMAScript 언어 값,
              _where_: ~start~, ~end~, 또는 ~start+end~,
            ): 정상 완료(문자열) 또는 throw 완료
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_string_을 UTF-16 인코딩 코드 포인트 시퀀스로 해석한다.</dd>
          </dl>
          <emu-alg>
            1. ? RequireObjectCoercible(_string_)를 수행한다.
            1. _S_를 ? ToString(_string_)으로 둔다.
            1. _where_가 ~start~이면
              1. _T_를 _S_의 선행 공백을 제거한 복사본으로 둔다.
            1. 아니고 _where_가 ~end~이면
              1. _T_를 _S_의 후행 공백을 제거한 복사본으로 둔다.
            1. 아니면
              1. 단언: _where_는 ~start+end~이다.
              1. _T_를 _S_의 선행 및 후행 공백을 제거한 복사본으로 둔다.
            1. _T_를 반환한다.
          </emu-alg>
          <p>공백 정의는 |WhiteSpace|와 |LineTerminator|의 합집합이다. Unicode 일반 카테고리 “Space_Separator”(“Zs”) 판별 시 코드 유닛 시퀀스는 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>에 규정된 UTF-16 인코딩 코드 포인트 시퀀스로 해석된다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimend">
        <h1>String.prototype.trimEnd ( )</h1>
        <p>이 메서드는 문자열 값을 UTF-16 코드 포인트 시퀀스로 해석한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_를 *this* 값으로 둔다.
          1. ? TrimString(_S_, ~end~)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimstart">
        <h1>String.prototype.trimStart ( )</h1>
        <p>이 메서드는 문자열 값을 UTF-16 코드 포인트 시퀀스로 해석한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_를 *this* 값으로 둔다.
          1. ? TrimString(_S_, ~start~)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.valueof">
        <h1>String.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisStringValue(*this* value)을 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisstringvalue" type="abstract operation" oldids="thisstringvalue">
          <h1>
            ThisStringValue (
              _value_: ECMAScript 언어 값,
            ): 정상 완료(문자열) 또는 throw 완료
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_가 문자열이면 _value_를 반환한다.
            1. _value_가 객체이고 [[StringData]] 내부 슬롯을 가지면
              1. _s_를 _value_.[[StringData]]로 둔다.
              1. 단언: _s_는 문자열이다.
              1. _s_를 반환한다.
            1. *TypeError* 예외를 던진다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype-%symbol.iterator%" oldids="sec-string.prototype-@@iterator,sec-createstringiterator,sec-properties-of-string-iterator-instances,table-46,table-internal-slots-of-string-iterator-instances">
        <h1>String.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>이 메서드는 문자열 값의 코드 포인트를 순회하며 각 코드 포인트를 문자열 값으로 반환하는 이터레이터 객체를 반환한다.</p>
        <p>호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_)를 수행한다.
          1. _s_를 ? ToString(_O_)로 둔다.
          1. _closure_를 _s_를 캡처하는 파라미터 없는 새 추상 클로저로 두고 호출 시 다음 단계를 수행하게 한다:
            1. _len_을 _s_의 길이로 둔다.
            1. _position_을 0으로 둔다.
            1. _position_ &lt; _len_ 동안 반복,
              1. _cp_를 CodePointAt(_s_, _position_)로 둔다.
              1. _nextIndex_를 _position_ + _cp_.[[CodeUnitCount]]로 둔다.
              1. _resultString_을 _s_의 _position_부터 _nextIndex_ 전까지 부분 문자열로 둔다.
              1. _position_을 _nextIndex_로 둔다.
              1. ? GeneratorYield(CreateIteratorResultObject(_resultString_, *false*))를 수행한다.
            1. NormalCompletion(~unused~)을 반환한다.
          1. CreateIteratorFromClosure(_closure_, *"%StringIteratorPrototype%"*, %StringIteratorPrototype%)를 반환한다.
        </emu-alg>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.iterator]"*이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-string-instances">
      <h1>String 인스턴스의 프로퍼티</h1>
      <p>String 인스턴스는 String 특수(exotic) 객체이며 해당 객체에 지정된 내부 메서드를 가진다. String 인스턴스는 String 프로토타입 객체로부터 프로퍼티를 상속한다. 또한 [[StringData]] 내부 슬롯을 가지며, 이는 이 String 객체가 표현하는 문자열 값이다.</p>
      <p>String 인스턴스는 *"length"* 프로퍼티와 정수 인덱스 이름을 가진 열거 가능한 프로퍼티 집합을 가진다.</p>

      <emu-clause id="sec-properties-of-string-instances-length">
        <h1>length</h1>
        <p>이 String 객체가 표현하는 문자열 값의 요소 개수.</p>
        <p>String 객체가 초기화된 후 이 프로퍼티는 변하지 않는다. 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-iterator-objects">
      <h1>String 이터레이터 객체</h1>
      <p><dfn variants="String Iterators,String Iterator object,String Iterator objects">String Iterator</dfn>는 특정 String 인스턴스 객체에 대한 특정 순회를 나타내는 객체이다. String Iterator 객체에 대한 명명된 생성자는 없다. 대신 특정 String 인스턴스의 메서드를 호출하여 생성된다.</p>

      <emu-clause id="sec-%stringiteratorprototype%-object">
        <h1>%StringIteratorPrototype% 객체</h1>
        <p><dfn>%StringIteratorPrototype%</dfn> 객체:</p>
        <ul>
          <li>모든 String Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
          <li>일반 객체이다.</li>
          <li>[[Prototype]] 내부 슬롯 값이 %Iterator.prototype%이다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%stringiteratorprototype%.next">
          <h1>%StringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%StringIteratorPrototype%"*)</emu-meta>를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%stringiteratorprototype%-@@tostringtag" id="sec-%stringiteratorprototype%-%symbol.tostringtag%">
          <h1>%StringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 프로퍼티 초기값은 문자열 *"String Iterator"*이다.</p>
          <p>이 프로퍼티는 속성 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }를 가진다.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (정규 표현식) 객체</h1>
    <p>RegExp 객체는 하나의 정규 표현식과 그에 연관된 플래그들을 포함한다.</p>
    <emu-note>
      <p>정규 표현식의 형식과 기능은 Perl 5 프로그래밍 언어의 정규 표현식 기능을 본뜬 것이다.</p>
    </emu-note>

    <emu-clause id="sec-patterns">
      <h1>패턴 (Patterns)</h1>
      <p>RegExp 생성자는 입력 패턴 문자열에 아래의 문법을 적용한다. 해당 문법이 그 문자열을 |Pattern| 의 전개로 해석할 수 없으면 오류가 발생한다.</p>
      <h2>구문 (Syntax)</h2>
      <emu-grammar type="definition">
        Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `|` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [empty]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          `(?=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        Quantifier ::
          QuantifierPrefix
          QuantifierPrefix `?`

        QuantifierPrefix ::
          `*`
          `+`
          `?`
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          PatternCharacter
          `.`
          `\` AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
          CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
          `(` GroupSpecifier[?UnicodeMode]? Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        RegularExpressionModifiers ::
          [empty]
          RegularExpressionModifiers RegularExpressionModifier

        RegularExpressionModifier :: one of
          `i` `m` `s`

        SyntaxCharacter :: one of
          `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

        PatternCharacter ::
          SourceCharacter but not SyntaxCharacter

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          DecimalEscape
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          IdentityEscape[?UnicodeMode]

        ControlEscape :: one of
          `f` `n` `r` `t` `v`

        GroupSpecifier[UnicodeMode] ::
          `?` GroupName[?UnicodeMode]

        GroupName[UnicodeMode] ::
          `&lt;` RegExpIdentifierName[?UnicodeMode] `&gt;`

        RegExpIdentifierName[UnicodeMode] ::
          RegExpIdentifierStart[?UnicodeMode]
          RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]

        RegExpIdentifierStart[UnicodeMode] ::
          IdentifierStartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpIdentifierPart[UnicodeMode] ::
          IdentifierPartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpUnicodeEscapeSequence[UnicodeMode] ::
          [+UnicodeMode] `u` HexLeadSurrogate `\u` HexTrailSurrogate
          [+UnicodeMode] `u` HexLeadSurrogate
          [+UnicodeMode] `u` HexTrailSurrogate
          [+UnicodeMode] `u` HexNonSurrogate
          [~UnicodeMode] `u` Hex4Digits
          [+UnicodeMode] `u{` CodePoint `}`

        UnicodeLeadSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+D800 to U+DBFF

        UnicodeTrailSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
      </emu-grammar>
      <p>연결될 수 있는 `\\u` |HexLeadSurrogate| 의 선택이 모호한 각 `\\u` |HexTrailSurrogate| 는, 그렇지 않으면 해당하는 `\\u` |HexTrailSurrogate| 를 갖지 않게 될 가장 가까운 가능한 `u` |HexLeadSurrogate| 와 연결되어야 한다.</p>
      <emu-grammar type="definition">
        HexLeadSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xD800 to 0xDBFF]

        HexTrailSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xDC00 to 0xDFFF]

        HexNonSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is not in the inclusive interval from 0xD800 to 0xDFFF]

        IdentityEscape[UnicodeMode] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacter but not UnicodeIDContinue

        DecimalEscape ::
          NonZeroDigit DecimalDigits[~Sep]? [lookahead &notin; DecimalDigit]

        CharacterClassEscape[UnicodeMode] ::
          `d`
          `D`
          `s`
          `S`
          `w`
          `W`
          [+UnicodeMode] `p{` UnicodePropertyValueExpression `}`
          [+UnicodeMode] `P{` UnicodePropertyValueExpression `}`

        UnicodePropertyValueExpression ::
          UnicodePropertyName `=` UnicodePropertyValue
          LoneUnicodePropertyNameOrValue

        UnicodePropertyName ::
          UnicodePropertyNameCharacters

        UnicodePropertyNameCharacters ::
          UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

        UnicodePropertyValue ::
          UnicodePropertyValueCharacters

        LoneUnicodePropertyNameOrValue ::
          UnicodePropertyValueCharacters

        UnicodePropertyValueCharacters ::
          UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

        UnicodePropertyValueCharacter ::
          UnicodePropertyNameCharacter
          DecimalDigit

        UnicodePropertyNameCharacter ::
          AsciiLetter
          `_`

        CharacterClass[UnicodeMode, UnicodeSetsMode] ::
          `[` [lookahead != `^`] ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`
          `[^` ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`

        ClassContents[UnicodeMode, UnicodeSetsMode] ::
          [empty]
          [~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
          [+UnicodeSetsMode] ClassSetExpression

        NonemptyClassRanges[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtom[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        NonemptyClassRangesNoDash[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        ClassAtom[UnicodeMode] ::
          `-`
          ClassAtomNoDash[?UnicodeMode]

        ClassAtomNoDash[UnicodeMode] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode]

        ClassEscape[UnicodeMode] ::
          `b`
          [+UnicodeMode] `-`
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]

        ClassSetExpression ::
          ClassUnion
          ClassIntersection
          ClassSubtraction

        ClassUnion ::
          ClassSetRange ClassUnion?
          ClassSetOperand ClassUnion?

        ClassIntersection ::
          ClassSetOperand `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand
          ClassIntersection `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand

        ClassSubtraction ::
          ClassSetOperand `--` ClassSetOperand
          ClassSubtraction `--` ClassSetOperand

        ClassSetRange ::
          ClassSetCharacter `-` ClassSetCharacter

        ClassSetOperand ::
          NestedClass
          ClassStringDisjunction
          ClassSetCharacter

        NestedClass ::
          `[` [lookahead != `^`] ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `[^` ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `\` CharacterClassEscape[+UnicodeMode]
      </emu-grammar>
      <emu-note>
        <p>여기 처음 두 줄은 CharacterClass 와 동등하다.</p>
      </emu-note>
      <emu-grammar type="definition">
        ClassStringDisjunction ::
          `\q{` ClassStringDisjunctionContents `}`

        ClassStringDisjunctionContents ::
          ClassString
          ClassString `|` ClassStringDisjunctionContents

        ClassString ::
          [empty]
          NonEmptyClassString

        NonEmptyClassString ::
          ClassSetCharacter NonEmptyClassString?

        ClassSetCharacter ::
          [lookahead &notin; ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
          `\` CharacterEscape[+UnicodeMode]
          `\` ClassSetReservedPunctuator
          `\b`

        ClassSetReservedDoublePunctuator :: one of
          `&amp;&amp;` `!!` `##` `$$`
          `%%` `**` `++` `,,`
          `..` `::` `;;` `&lt;&lt;`
          `==` `&gt;&gt;` `??` `@@`
          `^^` `` `` `~~`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetSyntaxCharacter :: one of
          `(` `)` `[` `]` `{` `}` `/` `-` `\` `|`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetReservedPunctuator :: one of
          `&amp;` `-` `!` `#` `%` `,` `:` `;`
          `&lt;` `=` `&gt;` `@` `` ` ` ``
      </emu-grammar>
      <emu-note>
        <p>이 절의 여러 생성 규칙들은 <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> 절에서 대체 정의를 가진다.</p>
      </emu-note>

      <emu-clause id="sec-patterns-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류 (Early Errors)</h1>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <ul>
          <li>
            CountLeftCapturingParensWithin(|Pattern|) ≥ 2<sup>32</sup> - 1 이면 구문 오류이다.
          </li>
          <li>
            |Pattern| 이 서로 다른 두 |GroupSpecifier| _x_ 와 _y_ 를 포함하고, _x_ 의 CapturingGroupName 이 _y_ 의 CapturingGroupName 과 같으며 MightBothParticipate(_x_, _y_) 가 *true* 이면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <ul>
          <li>
            첫 번째 |DecimalDigits| 의 MV 가 두 번째 |DecimalDigits| 의 MV 보다 엄격히 크면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            |RegularExpressionModifiers| 가 매치한 소스 텍스트에 동일한 코드 포인트가 두 번 이상 나타나면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            첫 번째 |RegularExpressionModifiers| 와 두 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트가 모두 비어 있으면 구문 오류이다.
          </li>
          <li>
            첫 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트에 동일한 코드 포인트가 두 번 이상 나타나면 구문 오류이다.
          </li>
          <li>
            두 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트에 동일한 코드 포인트가 두 번 이상 나타나면 구문 오류이다.
          </li>
          <li>
            첫 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트의 임의의 코드 포인트가 두 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트에도 포함되면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <ul>
          <li>
            GroupSpecifiersThatMatch(|GroupName|) 이 비어 있으면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <ul>
          <li>
            |DecimalEscape| 의 CapturingGroupNumber 가 |AtomEscape| 를 포함하는 |Pattern| 내의 CountLeftCapturingParensWithin 값보다 엄격히 크면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            첫 번째 |ClassAtom| 의 IsCharacterClass 가 *true* 이거나 두 번째 |ClassAtom| 의 IsCharacterClass 가 *true* 이면 구문 오류이다.
          </li>
          <li>
            첫 번째 |ClassAtom| 의 IsCharacterClass 가 *false*, 두 번째 |ClassAtom| 의 IsCharacterClass 가 *false* 이고 첫 번째 |ClassAtom| 의 CharacterValue 가 두 번째 |ClassAtom| 의 CharacterValue 보다 엄격히 크면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            |ClassAtomNoDash| 의 IsCharacterClass 가 *true* 이거나 |ClassAtom| 의 IsCharacterClass 가 *true* 이면 구문 오류이다.
          </li>
          <li>
            |ClassAtomNoDash| 의 IsCharacterClass 가 *false*, |ClassAtom| 의 IsCharacterClass 가 *false* 이고 |ClassAtomNoDash| 의 CharacterValue 가 |ClassAtom| 의 CharacterValue 보다 엄격히 크면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            |RegExpUnicodeEscapeSequence| 의 CharacterValue 가 |IdentifierStartChar| 어휘 문법 생성 규칙에 의해 매치되는 어떤 코드 포인트의 수치 값이 아니면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            |RegExpIdentifierStart| 의 RegExpIdentifierCodePoint 가 |UnicodeIDStart| 어휘 문법 생성 규칙에 의해 매치되지 않으면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            |RegExpUnicodeEscapeSequence| 의 CharacterValue 가 |IdentifierPartChar| 어휘 문법 생성 규칙에 의해 매치되는 어떤 코드 포인트의 수치 값이 아니면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            |RegExpIdentifierPart| 의 RegExpIdentifierCodePoint 가 |UnicodeIDContinue| 어휘 문법 생성 규칙에 의해 매치되지 않으면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <ul>
          <li>
            |UnicodePropertyName|에 의해 매치된 소스 텍스트가 <emu-not-ref>Unicode property name</emu-not-ref> 또는 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>의 “<emu-not-ref>Property name and aliases</emu-not-ref>” 열에 나열된 속성 별칭이 아닌 경우, 이는 구문 오류입니다.
          </li>
          <li>
            |UnicodePropertyValue|에 의해 매치된 소스 텍스트가 |UnicodePropertyName|에 의해 제공된 유니코드 속성 또는 속성 별칭에 대한 속성 값이나 속성 값 별칭이 아니고, <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>에 나열되어 있지 않은 경우, 이는 구문 오류입니다.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <ul>
          <li>
            |LoneUnicodePropertyNameOrValue|에 의해 매치된 소스 텍스트가 General_Category (gc) 속성의 유니코드 속성 값 또는 속성 값 별칭이 아니거나 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>에 나열되어 있지 않고, “<emu-not-ref>Property name and aliases</emu-not-ref>” 열의 <emu-xref href="#table-binary-unicode-properties"></emu-xref>에 나열된 바이너리 속성 또는 바이너리 속성 별칭도 아니며, “<emu-not-ref>Property name</emu-not-ref>” 열의 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>에 나열된 문자열의 바이너리 속성도 아닌 경우, 이는 구문 오류입니다.
          </li>
          <li>
            포함하는 |Pattern|에 <sub>[UnicodeSetsMode]</sub> 매개변수가 없고, |LoneUnicodePropertyNameOrValue|에 의해 매치된 소스 텍스트가 “<emu-not-ref>Property name</emu-not-ref>” 열의 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>에 나열된 문자열의 바이너리 속성인 경우, 이는 구문 오류입니다.
          </li>
        </ul>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <ul>
          <li>
            |UnicodePropertyValueExpression| 의 MayContainStrings 가 *true* 이면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            |ClassContents| 의 MayContainStrings 가 *true* 이면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            |ClassContents| 의 MayContainStrings 가 *true* 이면 구문 오류이다.
          </li>
        </ul>
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <ul>
          <li>
            첫 번째 |ClassSetCharacter| 의 CharacterValue 가 두 번째 |ClassSetCharacter| 의 CharacterValue 보다 엄격히 크면 구문 오류이다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparenswithin" type="abstract operation">
        <h1>
          정적 의미론: CountLeftCapturingParensWithin (
          _node_: 구문 노드,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_node_ 에 있는 좌측 캡처 괄호(left-capturing parentheses)의 개수를 반환한다. <dfn variants="left-capturing parentheses">좌측 캡처 괄호</dfn> 는 <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 생성 규칙의 `(` 단말 기호에 의해 매치되는 모든 `(` 패턴 문자이다.</dd>
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-alg>
          1. Assert: _node_ 는 <emu-xref href="#sec-patterns">RegExp 패턴 문법</emu-xref> 의 어떤 생성 규칙 인스턴스이다.
          1. _node_ 에 포함된 <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 구문 노드들의 개수를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparensbefore" type="abstract operation">
        <h1>
          정적 의미론: CountLeftCapturingParensBefore (
          _node_: 구문 노드,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>포함하는 패턴 내에서 _node_ 의 왼쪽에 나타나는 좌측 캡처 괄호의 개수를 반환한다.</dd>
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-alg>
          1. Assert: _node_ 는 <emu-xref href="#sec-patterns">RegExp 패턴 문법</emu-xref> 의 어떤 생성 규칙 인스턴스이다.
          1. _pattern_ 을 _node_ 를 포함하는 |Pattern| 으로 둔다.
          1. _pattern_ 내에서 _node_ 앞에 나타나거나 _node_ 를 포함하는 <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 구문 노드의 개수를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mightbothparticipate" type="abstract operation">
        <h1>
          정적 의미론: MightBothParticipate (
          _x_: 구문 노드,
          _y_: 구문 노드,
          ): 불리언
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _x_ 와 _y_ 는 동일한 둘러싼 |Pattern| 을 가진다.
          1. 둘러싼 |Pattern| 이 <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar> 구문 노드를 포함하고 _x_ 가 |Alternative| 내에, _y_ 가 파생된 |Disjunction| 내에 있거나 그 반대라면 *false* 를 반환한다.
          1. *true* 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-capturing-group-number" type="sdo">
        <h1>정적 의미론: CapturingGroupNumber ( ): 양의 정수</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-grammar>DecimalEscape :: NonZeroDigit</emu-grammar>
        <emu-alg>
          1. |NonZeroDigit| 의 MV 를 반환한다.
        </emu-alg>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits</emu-grammar>
        <emu-alg>
          1. _n_ 을 |DecimalDigits| 의 코드 포인트 개수로 둔다.
          1. (|NonZeroDigit| 의 MV × 10<sup>_n_</sup> + |DecimalDigits| 의 MV) 를 반환한다.
        </emu-alg>
        <p>“|NonZeroDigit| 의 MV”, “|DecimalDigits| 의 MV” 정의는 <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 에 있다.</p>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-is-character-class" type="sdo">
        <h1>정적 의미론: IsCharacterClass ( ): 불리언</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-patterns-static-semantics-is-character-class-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-grammar>
          ClassAtom ::
            `-`

          ClassAtomNoDash ::
            SourceCharacter but not one of `\` or `]` or `-`

          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. *false* 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. *true* 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-character-value" type="sdo">
        <h1>정적 의미론: CharacterValue ( ): 음이 아닌 정수</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-patterns-static-semantics-character-value-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-grammar>
          ClassAtom :: `-`
        </emu-grammar>
        <emu-alg>
          1. U+002D (HYPHEN-MINUS) 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>
          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`
        </emu-grammar>
        <emu-alg>
          1. _ch_ 를 |SourceCharacter| 가 매치한 코드 포인트로 둔다.
          1. _ch_ 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `b`
        </emu-grammar>
        <emu-alg>
          1. U+0008 (BACKSPACE) 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `-`
        </emu-grammar>
        <emu-alg>
          1. U+002D (HYPHEN-MINUS) 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>CharacterEscape :: ControlEscape</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#table-controlescape-code-point-values"></emu-xref> 에 따라 수치 값을 반환한다.
        </emu-alg>
        <emu-table id="table-controlescape-code-point-values" caption="ControlEscape 코드 포인트 값" oldids="table-47">
          <table>
            <thead>
              <tr>
                <th>
                  ControlEscape
                </th>
                <th>
                  수치 값
                </th>
                <th>
                  코드 포인트
                </th>
                <th>
                  유니코드 이름
                </th>
                <th>
                  기호
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `t`
              </td>
              <td>
                9
              </td>
              <td>
                `U+0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `n`
              </td>
              <td>
                10
              </td>
              <td>
                `U+000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `v`
              </td>
              <td>
                11
              </td>
              <td>
                `U+000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `f`
              </td>
              <td>
                12
              </td>
              <td>
                `U+000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `r`
              </td>
              <td>
                13
              </td>
              <td>
                `U+000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-grammar>CharacterEscape :: `c` AsciiLetter</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |AsciiLetter| 가 매치한 코드 포인트로 둔다.
          1. _i_ 를 _ch_ 의 수치 값으로 둔다.
          1. _i_ 를 32 로 나눈 나머지를 반환한다.
        </emu-alg>
        <emu-grammar>CharacterEscape :: `0` [lookahead &notin; DecimalDigit]</emu-grammar>
        <emu-alg>
          1. U+0000 (NULL) 의 수치 값을 반환한다.
        </emu-alg>
        <emu-note>
          <p>`\\0` 은 &lt;NUL> 문자를 나타내며 10진 숫자가 뒤따를 수 없다.</p>
        </emu-note>
        <emu-grammar>CharacterEscape :: HexEscapeSequence</emu-grammar>
        <emu-alg>
          1. |HexEscapeSequence| 의 MV 를 반환한다.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` HexLeadSurrogate `\u` HexTrailSurrogate</emu-grammar>
        <emu-alg>
          1. _lead_ 를 |HexLeadSurrogate| 의 CharacterValue 로 둔다.
          1. _trail_ 을 |HexTrailSurrogate| 의 CharacterValue 로 둔다.
          1. _cp_ 를 UTF16SurrogatePairToCodePoint(_lead_, _trail_) 로 둔다.
          1. _cp_ 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. |Hex4Digits| 의 MV 를 반환한다.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. |CodePoint| 의 MV 를 반환한다.
        </emu-alg>
        <emu-grammar>
          HexLeadSurrogate :: Hex4Digits

          HexTrailSurrogate :: Hex4Digits

          HexNonSurrogate :: Hex4Digits
        </emu-grammar>
        <emu-alg>
          1. |Hex4Digits| 의 MV 를 반환한다.
        </emu-alg>
        <emu-grammar>CharacterEscape :: IdentityEscape</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |IdentityEscape| 가 매치한 코드 포인트로 둔다.
          1. _ch_ 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: SourceCharacter but not ClassSetSyntaxCharacter</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |SourceCharacter| 가 매치한 코드 포인트로 둔다.
          1. _ch_ 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\` ClassSetReservedPunctuator</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |ClassSetReservedPunctuator| 가 매치한 코드 포인트로 둔다.
          1. _ch_ 의 수치 값을 반환한다.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. U+0008 (BACKSPACE) 의 수치 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-maycontainstrings" type="sdo">
        <h1>정적 의미론: MayContainStrings ( ): 불리언</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          CharacterClassEscape ::
            `d`
            `D`
            `s`
            `S`
            `w`
            `W`
            `P{` UnicodePropertyValueExpression `}`

          UnicodePropertyValueExpression ::
            UnicodePropertyName `=` UnicodePropertyValue

          NestedClass ::
            `[^` ClassContents `]`

          ClassContents ::
            [empty]
            NonemptyClassRanges

          ClassSetOperand ::
            ClassSetCharacter
        </emu-grammar>
        <emu-alg>
          1. *false* 를 반환한다.
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. |LoneUnicodePropertyNameOrValue|에 의해 매치된 소스 텍스트가 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>의 “<emu-not-ref>Property name</emu-not-ref>” 열에 나열된 문자열의 바이너리 속성인 경우, *true*를 반환한다.
          1. *false*를 반환한다.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. |ClassUnion| 이 존재하면 그 |ClassUnion| 의 MayContainStrings 를 반환한다.
          1. *false* 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. |ClassSetOperand| 의 MayContainStrings 가 *true* 이면 *true* 를 반환한다.
          1. |ClassUnion| 이 존재하면 그 |ClassUnion| 의 MayContainStrings 를 반환한다.
          1. *false* 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 첫 번째 |ClassSetOperand| 의 MayContainStrings 가 *false* 이면 *false* 를 반환한다.
          1. 두 번째 |ClassSetOperand| 의 MayContainStrings 가 *false* 이면 *false* 를 반환한다.
          1. *true* 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. |ClassIntersection| 의 MayContainStrings 가 *false* 이면 *false* 를 반환한다.
          1. |ClassSetOperand| 의 MayContainStrings 가 *false* 이면 *false* 를 반환한다.
          1. *true* 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 첫 번째 |ClassSetOperand| 의 MayContainStrings 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. |ClassSubtraction| 의 MayContainStrings 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. |ClassString| 의 MayContainStrings 가 *true* 이면 *true* 를 반환한다.
          1. |ClassStringDisjunctionContents| 의 MayContainStrings 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. *true* 를 반환한다.
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. |NonEmptyClassString| 의 MayContainStrings 를 반환한다.
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. |NonEmptyClassString| 이 존재하면 *true* 를 반환한다.
          1. *false* 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-groupspecifiersthatmatch" type="abstract operation">
        <h1>
          정적 의미론: GroupSpecifiersThatMatch (
          _thisGroupName_: |GroupName| 구문 노드,
          ): |GroupSpecifier| 구문 노드들의 리스트
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _name_ 을 _thisGroupName_ 의 CapturingGroupName 으로 둔다.
          1. _pattern_ 을 _thisGroupName_ 을 포함하는 |Pattern| 으로 둔다.
          1. _result_ 를 새 빈 리스트로 둔다.
          1. _pattern_ 이 포함하는 각 |GroupSpecifier| _gs_ 에 대해,
            1. _gs_ 의 CapturingGroupName 이 _name_ 과 같다면
              1. _gs_ 를 _result_ 에 추가한다.
          1. _result_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-capturinggroupname" oldids="sec-regexp-identifier-names-static-semantics-stringvalue" type="sdo">
        <h1>정적 의미론: CapturingGroupName ( ): 문자열</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          GroupName :: `&lt;` RegExpIdentifierName `&gt;`
        </emu-grammar>
        <emu-alg>
          1. _idTextUnescaped_ 를 |RegExpIdentifierName| 의 RegExpIdentifierCodePoints 로 둔다.
          1. CodePointsToString(_idTextUnescaped_) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoints" type="sdo">
        <h1>정적 의미론: RegExpIdentifierCodePoints ( ): 코드 포인트들의 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierStart</emu-grammar>
        <emu-alg>
          1. _cp_ 를 |RegExpIdentifierStart| 의 RegExpIdentifierCodePoint 로 둔다.
          1. « _cp_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierName RegExpIdentifierPart</emu-grammar>
        <emu-alg>
          1. _cps_ 를 파생된 |RegExpIdentifierName| 의 RegExpIdentifierCodePoints 로 둔다.
          1. _cp_ 를 |RegExpIdentifierPart| 의 RegExpIdentifierCodePoint 로 둔다.
          1. _cps_ 와 « _cp_ » 의 리스트 연결(list-concatenation)을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoint" type="sdo">
        <h1>정적 의미론: RegExpIdentifierCodePoint ( ): 코드 포인트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierStartChar| 가 매치한 코드 포인트를 반환한다.
        </emu-alg>
        <emu-grammar>RegExpIdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierPartChar| 가 매치한 코드 포인트를 반환한다.
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence

          RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence
        </emu-grammar>
        <emu-alg>
          1. 수치 값이 |RegExpUnicodeEscapeSequence| 의 CharacterValue 인 코드 포인트를 반환한다.
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

          RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
        </emu-grammar>
        <emu-alg>
          1. _lead_ 를 |UnicodeLeadSurrogate| 가 매치한 코드 포인트의 수치 값과 동일한 수치 값을 가진 코드 유닛으로 둔다.
          1. _trail_ 을 |UnicodeTrailSurrogate| 가 매치한 코드 포인트의 수치 값과 동일한 수치 값을 가진 코드 유닛으로 둔다.
          1. UTF16SurrogatePairToCodePoint(_lead_, _trail_) 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-pattern-semantics">
      <h1>패턴 의미론 (Pattern Semantics)</h1>
      <p>정규 표현식 패턴은 아래에 서술된 과정을 통해 추상 클로저(Abstract Closure)로 변환된다. 구현체는 결과가 동일한 한, 아래에 열거된 것보다 더 효율적인 알고리즘을 사용하는 것이 권장된다. 이렇게 생성된 추상 클로저는 RegExp 객체의 [[RegExpMatcher]] 내부 슬롯 값으로 사용된다.</p>
      <p>|Pattern| 은 관련 플래그에 `u` 와 `v` 둘 다 포함되지 않으면 BMP 패턴이고, 그렇지 않으면 유니코드 패턴이다. BMP 패턴은 입력 문자열을 BMP(기본 다국어 평면) 범위의 유니코드 코드 포인트들로 구성된 16비트 값 시퀀스로 해석하여 매칭한다. 유니코드 패턴은 입력 문자열을 UTF-16 으로 인코딩된 유니코드 코드 포인트 시퀀스로 해석하여 매칭한다. BMP 패턴의 동작을 설명하는 문맥에서 “문자(character)”는 단일 16비트 유니코드 BMP 코드 포인트를 의미한다. 유니코드 패턴의 동작을 설명하는 문맥에서 “문자”는 UTF-16 으로 인코딩된 하나의 코드 포인트를 의미한다 (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). 두 문맥 모두에서 “문자 값(character value)”은 해당 (인코딩되지 않은) 코드 포인트의 수치 값을 의미한다.</p>
      <p>|Pattern| 의 구문 및 의미는 |Pattern| 의 소스 텍스트가 각 |SourceCharacter| 가 하나의 유니코드 코드 포인트에 대응하는 |SourceCharacter| 값들의 리스트인 것처럼 정의된다. 만약 BMP 패턴이 BMP가 아닌 |SourceCharacter| 를 포함한다면 전체 패턴은 UTF-16 으로 인코딩되고, 그 인코딩을 이루는 개별 코드 유닛들이 리스트의 요소로 사용된다.</p>
      <emu-note>
        <p>예를 들어, 소스 텍스트에서 하나의 비-BMP 문자 U+1D11E (MUSICAL SYMBOL G CLEF) 로 표현된 패턴을 생각하자. 유니코드 패턴으로 해석하면 단일 코드 포인트 U+1D11E 를 포함하는 (문자 1개짜리) 단일 요소 리스트가 된다. 그러나 BMP 패턴으로 해석하면 먼저 UTF-16 으로 인코딩되어 코드 유닛 0xD834 와 0xDD1E 두 요소로 이루어진 리스트가 된다.</p>
        <p>패턴은 RegExp 생성자에 비-BMP 문자가 UTF-16 으로 인코딩된 ECMAScript 문자열 값으로 전달된다. 예를 들어, 단일 문자 MUSICAL SYMBOL G CLEF 패턴은 길이 2의 문자열로서 그 요소가 코드 유닛 0xD834 와 0xDD1E 이다. 따라서 이를 두 개의 패턴 문자로 이루어진 BMP 패턴으로 처리하기 위해 추가 변환이 필요하지 않다. 그러나 이를 유니코드 패턴으로 처리하려면 UTF16SurrogatePairToCodePoint 를 사용하여 하나의 패턴 문자(코드 포인트 U+1D11E)만을 요소로 갖는 리스트를 생성해야 한다.</p>
        <p>구현체는 실제로 UTF-16 으로의 변환이나 역변환을 수행하지 않을 수 있으나, 이 명세의 의미론은 패턴 매칭 결과가 마치 그러한 변환이 수행된 것과 동일해야 한다고 요구한다.</p>
      </emu-note>

      <emu-clause id="sec-pattern-notation" oldids="sec-notation">
        <h1>표기법 (Notation)</h1>
        <p>아래 설명에서는 다음의 내부 데이터 구조를 사용한다:</p>
        <ul>
          <li>
            <dfn>CharSetElement</dfn> 는 다음 두 가지 중 하나이다:
            <ul>
              <li>
                _rer_.[[UnicodeSets]] 가 *false* 이면 CharSetElement 는 위 패턴 의미론의 문맥에서 “문자” 하나이다.
              </li>
              <li>
                _rer_.[[UnicodeSets]] 가 *true* 이면 CharSetElement 는 위 패턴 의미론의 문맥에서 “문자”들로 이루어진 시퀀스이다. 여기에는 빈 시퀀스, 한 문자 시퀀스, 두 문자 이상 시퀀스가 모두 포함된다. 편의를 위해 이런 종류의 CharSetElement 를 다룰 때 개별 문자는 한 문자로 이루어진 시퀀스와 상호 교환적으로 취급된다.
              </li>
            </ul>
          </li>
          <li>
            <dfn id="pattern-charset" variants="CharSets">CharSet</dfn> 은 CharSetElement 들의 수학적 집합이다.
          </li>
          <li>
            <dfn id="pattern-capturerange" variants="CaptureRanges">CaptureRange</dfn> 는 { [[StartIndex]], [[EndIndex]] } 형태의 레코드로, 캡처에 포함된 문자 범위를 나타낸다. [[StartIndex]] 는 _Input_ 내에서 범위 시작(포함)의 정수 인덱스, [[EndIndex]] 는 범위 끝(배타)의 정수 인덱스이다. 모든 CaptureRange 에 대해 [[StartIndex]] ≤ [[EndIndex]] 조건(불변식)을 만족해야 한다.
          </li>
          <li>
            <dfn id="pattern-matchstate" variants="MatchStates" oldids="pattern-matchresult">MatchState</dfn> 는 { [[Input]], [[EndIndex]], [[Captures]] } 형태의 레코드이며, [[Input]] 은 매칭 중인 문자열을 나타내는 문자들의 리스트, [[EndIndex]] 는 정수, [[Captures]] 는 패턴 안의 각 좌측 캡처 괄호에 대응하는 값들의 리스트이다. MatchState 는 정규 표현식 매칭 알고리즘에서 부분 매칭 상태를 표현한다. [[EndIndex]] 는 지금까지 패턴이 매치한 마지막 입력 문자의 인덱스보다 1 큰 값이며, [[Captures]] 는 캡처 괄호의 결과를 담는다. [[Captures]] 의 _n_<sup>번째</sup> 요소는 _n_<sup>번째</sup> 캡처 괄호가 캡처한 문자 범위를 나타내는 CaptureRange 이거나, 해당 캡처 괄호에 아직 도달하지 않았다면 *undefined* 이다. 백트래킹 때문에 매칭 과정 중 언제든 다수의 MatchState 가 사용될 수 있다.
          </li>
          <li>
            <dfn id="pattern-matchercontinuation" variants="MatcherContinuations">MatcherContinuation</dfn> 은 하나의 MatchState 인수를 받아 MatchState 또는 ~failure~ 를 반환하는 추상 클로저이다. MatcherContinuation 은 (클로저의 캡처된 값들에 의해 지정되는) 패턴의 남은 부분을 _Input_ 에 대해, 인수로 전달된 MatchState 가 나타내는 중간 상태부터 매칭하려 시도한다. 매칭이 성공하면 도달한 최종 MatchState 를 반환하고, 실패하면 ~failure~ 를 반환한다.
          </li>
          <li>
            <dfn id="pattern-matcher" variants="Matchers">Matcher</dfn> 는 두 인수(하나는 MatchState, 다른 하나는 MatcherContinuation)를 받아 MatchState 또는 ~failure~ 를 반환하는 추상 클로저이다. Matcher 는 (클로저의 캡처된 값들에 의해 지정되는) 패턴의 중간 부분(subpattern)을 MatchState 의 [[Input]] 에 대해, 인수 MatchState 가 나타내는 중간 상태부터 매칭하려 시도한다. MatcherContinuation 인수는 패턴의 나머지를 매칭하는 클로저여야 한다. 서브패턴을 매칭해 새 MatchState 를 얻은 뒤, Matcher 는 그 새 MatchState 로 MatcherContinuation 을 호출하여 패턴의 나머지 부분도 매칭 가능한지 시험한다. 가능하면 Matcher 는 MatcherContinuation 이 반환한 MatchState 를 반환하며, 그렇지 않으면 가능한 선택 지점(choice point)에서 다른 선택을 시도하고, 성공하거나 모든 가능성이 소진될 때까지 MatcherContinuation 을 반복 호출할 수 있다.
          </li>
        </ul>

        <emu-clause id="sec-regexp-records">
          <h1>RegExp 레코드 (RegExp Records)</h1>
          <p><dfn variants="RegExp Records">RegExp Record</dfn> 는 컴파일 과정 및 (필요하다면) 매칭 과정에서 필요한 RegExp 관련 정보를 저장하기 위해 사용되는 레코드 값이다.</p>
          <p>다음 필드들을 가진다:</p>
          <emu-table id="table-regexp-record-fields" caption="RegExp Record 필드">
            <table>
              <thead>
                <tr>
                  <th>필드 이름</th>
                  <th>값</th>
                  <th>의미</th>
                </tr>
              </thead>
              <tr>
                <td>[[IgnoreCase]]</td>
                <td>Boolean</td>
                <td>RegExp 플래그에 *"i"* 가 나타나는지 여부</td>
              </tr>
              <tr>
                <td>[[Multiline]]</td>
                <td>Boolean</td>
                <td>RegExp 플래그에 *"m"* 가 나타나는지 여부</td>
              </tr>
              <tr>
                <td>[[DotAll]]</td>
                <td>Boolean</td>
                <td>RegExp 플래그에 *"s"* 가 나타나는지 여부</td>
              </tr>
              <tr>
                <td>[[Unicode]]</td>
                <td>Boolean</td>
                <td>RegExp 플래그에 *"u"* 가 나타나는지 여부</td>
              </tr>
              <tr>
                <td>[[UnicodeSets]]</td>
                <td>Boolean</td>
                <td>RegExp 플래그에 *"v"* 가 나타나는지 여부</td>
              </tr>
              <tr>
                <td>[[CapturingGroupsCount]]</td>
                <td>음이 아닌 정수</td>
                <td>패턴 내 좌측 캡처 괄호의 개수</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilepattern" type="sdo" oldids="sec-pattern">
        <h1>
          런타임 의미론: CompilePattern (
          _rer_: RegExp Record,
          ): 문자 리스트와 음이 아닌 정수를 받아 MatchState 또는 ~failure~ 를 반환하는 추상 클로저
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Disjunction| 에 대해 인수 _rer_, ~forward~ 로 CompileSubpattern 한 결과로 둔다.
          1. _rer_ 와 _m_ 을 캡처하고, 매개변수 (_Input_, _index_) 를 가지며 호출 시 다음 단계를 수행하는 새 추상 클로저를 반환한다:
            1. Assert: _Input_ 은 문자들의 리스트이다.
            1. Assert: 0 ≤ _index_ ≤ _Input_ 의 요소 개수.
            1. _c_ 를 매개변수 (_y_) 를 가지며 아무것도 캡처하지 않고 호출 시 다음 단계를 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. _y_ 를 반환한다.
            1. _cap_ 을 _rer_.[[CapturingGroupsCount]] 개의 *undefined* 값(인덱스 1.._rer_.[[CapturingGroupsCount]])을 가진 리스트로 둔다.
            1. _x_ 를 MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ } 로 둔다.
            1. _m_(_x_, _c_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>Pattern 은 추상 클로저 값으로 컴파일된다. RegExpBuiltinExec 는 그런 절차를 문자 리스트와 그 안의 오프셋에 적용하여, 패턴이 정확히 그 오프셋에서 매칭되는지, 그리고 매칭된다면 캡처 괄호 값이 무엇인지 결정할 수 있다. <emu-xref href="#sec-pattern-semantics"></emu-xref> 의 알고리즘들은 패턴 컴파일이 *SyntaxError* 예외를 던질 수 있도록 설계되어 있다; 반면 패턴이 성공적으로 컴파일된 후에는 (메모리 부족 등 구현 정의 예외를 제외하고) 결과 추상 클로저를 적용하여 문자 리스트에서 매칭을 찾는 동작이 예외를 던지지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-compilesubpattern" type="sdo" oldids="sec-disjunction,sec-alternative,sec-term">
        <h1>
          런타임 의미론: CompileSubpattern (
          _rer_: RegExp Record,
          _direction_: ~forward~ 또는 ~backward~,
          ): Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-compilesubpattern-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>

        <!-- Disjunction -->
        <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar>
        <emu-alg>
          1. _m1_ 을 |Alternative| 에 대해 인수 _rer_, _direction_ 으로 CompileSubpattern 한 결과로 둔다.
          1. _m2_ 를 |Disjunction| 에 대해 인수 _rer_, _direction_ 으로 CompileSubpattern 한 결과로 둔다.
          1. MatchTwoAlternatives(_m1_, _m2_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>`|` 연산자는 두 개의 대안을 구분한다. 패턴은 먼저 왼쪽 |Alternative| (및 뒤따르는 정규 표현식 나머지)를 매칭 시도하고, 실패하면 오른쪽 |Disjunction| (및 나머지)를 매칭 시도한다. 왼쪽 |Alternative|, 오른쪽 |Disjunction|, 그리고 나머지가 모두 선택 지점(choice point)을 가진다면, 왼쪽 |Alternative| 의 다음 선택으로 진행하기 전에 나머지의 모든 선택을 시도한다. 왼쪽 |Alternative| 의 선택이 다 소진되면 왼쪽 대신 오른쪽 |Disjunction| 을 시도한다. `|` 로 건너뛰어진 패턴 부분 내의 캡처 괄호는 문자열이 아니라 *undefined* 값을 생성한다. 예:</p>
          <pre><code class="javascript">/a|ab/.exec("abc")</code></pre>
          <p>는 결과 *"a"* 를 반환하며 *"ab"* 가 아니다. 또한,</p>
          <pre><code class="javascript">/((a)|(ab))((c)|(bc))/.exec("abc")</code></pre>
          <p>는 배열</p>
          <pre><code class="javascript">["abc", "a", "a", undefined, "bc", undefined, "bc"]</code></pre>
          <p>를 반환하고,</p>
          <pre><code class="javascript">["abc", "ab", undefined, "ab", "c", "c", undefined]</code></pre>
          <p>는 아니다. 두 대안을 시도하는 순서는 _direction_ 값과 무관하다.</p>
        </emu-note>

        <!-- Alternative -->
        <emu-grammar>Alternative :: [empty]</emu-grammar>
        <emu-alg>
          1. EmptyMatcher() 를 반환한다.
        </emu-alg>
        <emu-grammar>Alternative :: Alternative Term</emu-grammar>
        <emu-alg>
          1. _m1_ 을 |Alternative| 에 대해 인수 _rer_, _direction_ 으로 CompileSubpattern 한 결과로 둔다.
          1. _m2_ 를 |Term| 에 대해 인수 _rer_, _direction_ 으로 CompileSubpattern 한 결과로 둔다.
          1. MatchSequence(_m1_, _m2_, _direction_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>연속된 |Term| 들은 _Input_ 의 연속된 부분들을 동시에 매칭하려 시도한다. _direction_ 이 ~forward~ 일 때, 왼쪽 |Alternative|, 오른쪽 |Term|, 그리고 나머지에 모두 선택 지점이 있다면 오른쪽 |Term| 의 다음 선택으로 가기 전에 나머지의 모든 선택을 시도하고, 왼쪽 |Alternative| 의 다음 선택으로 가기 전에 오른쪽 |Term| 의 모든 선택을 시도한다. _direction_ 이 ~backward~ 이면 |Alternative| 와 |Term| 의 평가 순서가 반전된다.</p>
        </emu-note>

        <!-- Term -->
        <emu-grammar>Term :: Assertion</emu-grammar>
        <emu-alg>
          1. |Assertion| 에 대해 인수 _rer_ 로 CompileAssertion 한 결과를 반환한다.
        </emu-alg>
        <emu-note>
          <p>결과 Matcher 는 _direction_ 과 무관하다.</p>
        </emu-note>
        <emu-grammar>Term :: Atom</emu-grammar>
        <emu-alg>
          1. |Atom| 에 대해 인수 _rer_, _direction_ 으로 CompileAtom 한 결과를 반환한다.
        </emu-alg>
        <emu-grammar>Term :: Atom Quantifier</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Atom| 에 대해 인수 _rer_, _direction_ 으로 CompileAtom 한 결과로 둔다.
          1. _q_ 를 |Quantifier| 에 대해 CompileQuantifier 한 결과로 둔다.
          1. Assert: _q_.[[Min]] ≤ _q_.[[Max]].
          1. _parenIndex_ 를 CountLeftCapturingParensBefore(|Term|) 로 둔다.
          1. _parenCount_ 를 CountLeftCapturingParensWithin(|Atom|) 으로 둔다.
          1. _m_, _q_, _parenIndex_, _parenCount_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-repeatmatcher-abstract-operation" type="abstract operation">
          <h1>
            RepeatMatcher (
              _m_: Matcher,
              _min_: 음이 아닌 정수,
              _max_: 음이 아닌 정수 또는 +&infin;,
              _greedy_: Boolean,
              _x_: MatchState,
              _c_: MatcherContinuation,
              _parenIndex_: 음이 아닌 정수,
              _parenCount_: 음이 아닌 정수,
            ): MatchState 또는 ~failure~
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _max_ = 0 이면 _c_(_x_) 를 반환한다.
            1. _d_ 를 매개변수 (_y_) 를 가지며 _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, _parenCount_ 를 캡처하고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. [id="step-repeatmatcher-done"] _min_ = 0 이고 _y_.[[EndIndex]] = _x_.[[EndIndex]] 이면 ~failure~ 를 반환한다.
              1. _min_ = 0 이면 _min2_ = 0, 그렇지 않으면 _min2_ = _min_ - 1 로 둔다.
              1. _max_ = +∞ 이면 _max2_ = +∞, 아니면 _max2_ = _max_ - 1 로 둔다.
              1. RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_) 를 반환한다.
            1. _cap_ 을 _x_.[[Captures]] 의 복사본으로 둔다.
            1. [id="step-repeatmatcher-clear-captures"] _parenIndex_ + 1 부터 _parenIndex_ + _parenCount_ 까지 (포함) 정수 _k_ 각각에 대해 _cap_[_k_] = *undefined* 로 설정한다.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _xr_ 을 MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ } 로 둔다.
            1. _min_ ≠ 0 이면 _m_(_xr_, _d_) 를 반환한다.
            1. _greedy_ 가 *false* 이면
              1. _z_ 를 _c_(_x_) 로 둔다.
              1. _z_ 가 ~failure~ 가 아니면 _z_ 반환.
              1. _m_(_xr_, _d_) 를 반환한다.
            1. _z_ 를 _m_(_xr_, _d_) 로 둔다.
            1. _z_ 가 ~failure~ 가 아니면 _z_ 반환.
            1. _c_(_x_) 를 반환한다.
          </emu-alg>
          <emu-note>
            <p>|Atom| 뒤에 |Quantifier| 가 오면 |Quantifier| 가 지정한 횟수만큼 |Atom| 이 반복된다. |Quantifier| 는 비탐욕적(non-greedy)일 수 있으며, 이 경우 |Atom| 패턴은 나머지를 매칭 가능하게 유지하는 최소 횟수만 반복된다. 탐욕적(greedy)이면 가능한 한 많이 반복된다. 반복되는 것은 입력 문자 시퀀스가 아니라 |Atom| 패턴이므로 각 반복은 서로 다른 입력 부분 문자열을 매칭할 수 있다.</p>
          </emu-note>
          <emu-note>
            <p>|Atom| 과 정규 표현식의 나머지가 모두 선택 지점을 가진다면, |Atom| 은 먼저 가능한 많이(또는 비탐욕적이면 가능한 적게) 매칭된다. 나머지 부분의 모든 선택이 소진되기 전까지 |Atom| 의 마지막 반복의 다음 선택으로 이동하지 않는다. 마지막 (n<sup>번째</sup>) 반복의 모든 선택이 소진되기 전까지 (n - 1)<sup>번째</sup> 반복의 다음 선택으로 이동하지 않는다. 그 시점에서 |Atom| 을 더 많이 또는 더 적게 반복할 수 있게 될 수도 있으며, (다시 최소 또는 최대부터 시작하여) 이것들을 소진한 뒤 (n - 1)<sup>번째</sup> 반복의 다음 선택으로 이동한다.</p>
            <p>비교:</p>
            <pre><code class="javascript">/a[a-z]{2,4}/.exec("abcdefghi")</code></pre>
            <p>는 *"abcde"* 를 반환하고,</p>
            <pre><code class="javascript">/a[a-z]{2,4}?/.exec("abcdefghi")</code></pre>
            <p>는 *"abc"* 를 반환한다.</p>
            <p>또한,</p>
            <pre><code class="javascript">/(aa|aabaac|ba|b|c)*/.exec("aabaac")</code></pre>
            <p>는 위 선택 지점 순서에 따라 배열</p>
            <pre><code class="javascript">["aaba", "ba"]</code></pre>
            <p>를 반환하며, 아래 어느 것도 아니다:</p>
            <pre><code class="javascript">
              ["aabaac", "aabaac"]
              ["aabaac", "c"]
            </code></pre>
            <p>위 선택 지점 순서는 (단항 표기) 두 수의 최대공약수를 계산하는 정규 표현식을 작성하는 데 사용될 수 있다. 다음 예는 10 과 15 의 gcd 를 계산한다:</p>
            <pre><code class="javascript">"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")</code></pre>
            <p>이는 단항 표기 gcd *"aaaaa"* 를 반환한다.</p>
          </emu-note>
          <emu-note>
            <p>RepeatMatcher 의 단계 <emu-xref href="#step-repeatmatcher-clear-captures"></emu-xref> 는 |Atom| 이 반복될 때마다 해당 |Atom| 의 캡처를 지운다. 이는 다음 정규 표현식을 통해 확인할 수 있다:</p>
            <pre><code class="javascript">/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</code></pre>
            <p>이 표현식은 배열</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", undefined, "c"]</code></pre>
            <p>를 반환하고,</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</code></pre>
            <p>를 반환하지 않는다. 이는 가장 바깥 `*` 의 각 반복이 수량자 적용 대상 |Atom| 에 포함된 모든 캡처 문자열(여기서는 2, 3, 4, 5 번 캡처)을 비우기 때문이다.</p>
          </emu-note>
          <emu-note>
            <p>RepeatMatcher 의 단계 <emu-xref href="#step-repeatmatcher-done"></emu-xref> 는 최소 반복 횟수를 만족한 후, 빈 문자 시퀀스를 매칭하는 |Atom| 의 추가 확장은 더 이상 고려하지 않는다고 명시한다. 이는 다음과 같은 패턴에서 엔진이 무한 루프에 빠지는 것을 방지한다:</p>
            <pre><code class="javascript">/(a*)*/.exec("b")</code></pre>
            <p>혹은 조금 더 복잡한 패턴:</p>
            <pre><code class="javascript">/(a*)b\1+/.exec("baaaac")</code></pre>
            <p>이는 배열</p>
            <pre><code class="javascript">["b", ""]</code></pre>
            <p>를 반환한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-emptymatcher" type="abstract operation">
          <h1>EmptyMatcher ( ): Matcher</h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 아무것도 캡처하지 않고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
              1. Assert: _x_ 는 MatchState.
              1. Assert: _c_ 는 MatcherContinuation.
              1. _c_(_x_) 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchtwoalternatives" type="abstract operation">
          <h1>
            MatchTwoAlternatives (
              _m1_: Matcher,
              _m2_: Matcher,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _m1_, _m2_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
              1. Assert: _x_ 는 MatchState.
              1. Assert: _c_ 는 MatcherContinuation.
              1. _r_ 를 _m1_(_x_, _c_) 로 둔다.
              1. _r_ 가 ~failure~ 가 아니면 _r_ 반환.
              1. _m2_(_x_, _c_) 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchsequence" type="abstract operation">
          <h1>
            MatchSequence (
              _m1_: Matcher,
              _m2_: Matcher,
              _direction_: ~forward~ 또는 ~backward~,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _direction_ 이 ~forward~ 이면
              1. _m1_, _m2_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
                1. Assert: _x_ 는 MatchState.
                1. Assert: _c_ 는 MatcherContinuation.
                1. _d_ 를 매개변수 (_y_) 를 가지며 _c_, _m2_ 를 캡처하고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
                  1. Assert: _y_ 는 MatchState.
                  1. _m2_(_y_, _c_) 를 반환한다.
                1. _m1_(_x_, _d_) 를 반환한다.
            1. 그렇지 않으면,
              1. Assert: _direction_ 은 ~backward~.
              1. _m1_, _m2_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
                1. Assert: _x_ 는 MatchState.
                1. Assert: _c_ 는 MatcherContinuation.
                1. _d_ 를 매개변수 (_y_) 를 가지며 _c_, _m1_ 을 캡처하고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
                  1. Assert: _y_ 는 MatchState.
                  1. _m1_(_y_, _c_) 를 반환한다.
                1. _m2_(_x_, _d_) 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileassertion" type="sdo" oldids="sec-assertion">
        <h1>
          런타임 의미론: CompileAssertion (
          _rer_: RegExp Record,
          ): Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-compileassertion-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-grammar>Assertion :: `^`</emu-grammar>
        <emu-alg>
          1. _rer_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _e_ = 0 이거나 (_rer_.[[Multiline]] 이 *true* 이고 문자 _Input_[_e_ - 1] 이 |LineTerminator| 에 매치되면)
              1. _c_(_x_) 를 반환한다.
            1. ~failure~ 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>`y` 플래그를 사용해도 `^` 는 항상 _Input_ 의 시작(또는 _rer_.[[Multiline]] 이 *true* 이면 줄의 시작)에서만 매치된다.</p>
        </emu-note>
        <emu-grammar>Assertion :: `$`</emu-grammar>
        <emu-alg>
          1. _rer_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _InputLength_ 를 _Input_ 의 요소 개수로 둔다.
            1. _e_ = _InputLength_ 이거나 (_rer_.[[Multiline]] 이 *true* 이고 문자 _Input_[_e_] 가 |LineTerminator| 에 매치되면)
              1. _c_(_x_) 를 반환한다.
            1. ~failure~ 를 반환한다.
        </emu-alg>
        <emu-grammar>Assertion :: `\b`</emu-grammar>
        <emu-alg>
          1. _rer_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _a_ 를 IsWordChar(_rer_, _Input_, _e_ - 1) 로 둔다.
            1. _b_ 를 IsWordChar(_rer_, _Input_, _e_) 로 둔다.
            1. (_a_ 가 *true* 이고 _b_ 가 *false*) 또는 (_a_ 가 *false* 이고 _b_ 가 *true*) 이면 _c_(_x_) 반환.
            1. ~failure~ 반환.
        </emu-alg>
        <emu-grammar>Assertion :: `\B`</emu-grammar>
        <emu-alg>
          1. _rer_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _a_ 를 IsWordChar(_rer_, _Input_, _e_ - 1) 로 둔다.
            1. _b_ 를 IsWordChar(_rer_, _Input_, _e_) 로 둔다.
            1. (_a_ 와 _b_ 가 모두 *true*) 또는 (_a_ 와 _b_ 가 모두 *false*) 이면 _c_(_x_) 반환.
            1. ~failure~ 반환.
        </emu-alg>
        <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Disjunction| 에 대해 인수 _rer_, ~forward~ 로 CompileSubpattern 한 결과로 둔다.
          1. _m_ 을 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _d_ 를 매개변수 (_y_) 를 가지며 아무것도 캡처하지 않고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. _y_ 반환.
            1. _r_ 를 _m_(_x_, _d_) 로 둔다.
            1. _r_ 가 ~failure~ 이면 ~failure~ 반환.
            1. Assert: _r_ 는 MatchState.
            1. _cap_ 을 _r_.[[Captures]] 로 둔다.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _xe_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _z_ 를 MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ } 로 둔다.
            1. _c_(_z_) 반환.
        </emu-alg>
        <emu-note>
          <p>`(?=` |Disjunction| `)` 형식은 폭 0 양수 전방 탐색(positive lookahead)을 지정한다. 성공하려면 |Disjunction| 내부 패턴이 현재 위치에서 매치되어야 하지만, 나머지를 매칭하기 전에 현재 위치는 전진하지 않는다. |Disjunction| 이 현재 위치에서 여러 방식으로 매치 가능하면 첫 번째 방식만 시도된다. 다른 정규 표현식 연산자와 달리 `(?=` 형식 안으로의 백트래킹은 없다(이 비정상적 동작은 Perl 에서 유래). 이는 |Disjunction| 이 캡처 괄호를 포함하고 패턴의 나머지 부분이 그 캡처에 대한 역참조를 포함할 때에만 중요하다.</p>
          <p>예:</p>
          <pre><code class="javascript">/(?=(a+))/.exec("baaabac")</code></pre>
          <p>는 첫 번째 `b` 직후 빈 문자열을 매치하므로 배열:</p>
          <pre><code class="javascript">["", "aaa"]</code></pre>
          <p>를 반환한다.</p>
          <p>전방 탐색 내부로의 백트래킹 부재를 보여주기 위해:</p>
          <pre><code class="javascript">/(?=(a+))a*b\1/.exec("baaabac")</code></pre>
          <p>이 표현식은</p>
          <pre><code class="javascript">["aba", "a"]</code></pre>
          <p>를 반환하며,</p>
          <pre><code class="javascript">["aaaba", "a"]</code></pre>
          <p>는 아니다.</p>
        </emu-note>
        <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Disjunction| 에 대해 인수 _rer_, ~forward~ 로 CompileSubpattern 한 결과로 둔다.
          1. _m_ 을 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _d_ 를 매개변수 (_y_) 를 가지며 아무것도 캡처하지 않고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. _y_ 반환.
            1. _r_ 를 _m_(_x_, _d_) 로 둔다.
            1. _r_ 가 ~failure~ 가 아니면 ~failure~ 반환.
            1. _c_(_x_) 반환.
        </emu-alg>
        <emu-note>
          <p>`(?!` |Disjunction| `)` 형식은 폭 0 음수 전방 탐색(negative lookahead)을 지정한다. 성공하려면 |Disjunction| 내부 패턴이 현재 위치에서 매치에 실패해야 한다. 현재 위치는 나머지를 매칭하기 전에 전진하지 않는다. |Disjunction| 은 캡처 괄호를 포함할 수 있지만, 그 캡처에 대한 역참조는 |Disjunction| 내부에서만 의미가 있다. 패턴의 다른 부분에서 이 캡처에 대한 역참조는 항상 *undefined* 를 반환하는데, 음수 전방 탐색은 실패해야 전체 패턴이 성공하기 때문이다. 예:</p>
          <pre><code class="javascript">/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</code></pre>
          <p>이 표현식은 `a` 뒤에 즉시 n 개의 `a`, 하나의 `b`, 다시 n 개의 `a`(첫 번째 `\2` 로 지정), 그리고 `c` 가 오는 패턴이 아닌 경우를 찾는다. 두 번째 `\2` 는 음수 전방 탐색 밖에 있으므로 *undefined* 와 매치되어 항상 성공한다. 전체 표현식은 배열:</p>
          <pre><code class="javascript">["baaabaac", "ba", undefined, "abaac"]</code></pre>
          <p>을 반환한다.</p>
        </emu-note>
        <emu-grammar>Assertion :: `(?&lt;=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Disjunction| 에 대해 인수 _rer_, ~backward~ 로 CompileSubpattern 한 결과로 둔다.
          1. _m_ 을 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _d_ 를 매개변수 (_y_) 를 가지며 아무것도 캡처하지 않고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. _y_ 반환.
            1. _r_ 를 _m_(_x_, _d_) 로 둔다.
            1. _r_ 가 ~failure~ 이면 ~failure~ 반환.
            1. Assert: _r_ 는 MatchState.
            1. _cap_ 을 _r_.[[Captures]] 로 둔다.
            1. _Input_ 을 _x_.[[Input]] 으로 둔다.
            1. _xe_ 를 _x_.[[EndIndex]] 로 둔다.
            1. _z_ 를 MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ } 로 둔다.
            1. _c_(_z_) 반환.
        </emu-alg>
        <emu-grammar>Assertion :: `(?&lt;!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Disjunction| 에 대해 인수 _rer_, ~backward~ 로 CompileSubpattern 한 결과로 둔다.
          1. _m_ 을 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 를 반환한다:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _d_ 를 매개변수 (_y_) 를 가지며 아무것도 캡처하지 않고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. _y_ 반환.
            1. _r_ 를 _m_(_x_, _d_) 로 둔다.
            1. _r_ 가 ~failure~ 가 아니면 ~failure~ 반환.
            1. _c_(_x_) 반환.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-iswordchar-abstract-operation" type="abstract operation">
          <h1>
            IsWordChar (
              _rer_: RegExp Record,
              _Input_: 문자 리스트,
              _e_: 정수,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _InputLength_ 를 _Input_ 의 요소 개수로 둔다.
            1. _e_ = -1 또는 _e_ = _InputLength_ 이면 *false* 반환.
            1. _c_ 를 문자 _Input_[_e_] 로 둔다.
            1. WordCharacters(_rer_) 가 _c_ 를 포함하면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilequantifier" type="sdo" oldids="sec-quantifier">
        <h1>런타임 의미론: CompileQuantifier ( ): [[Min]] (음이 아닌 정수), [[Max]] (음이 아닌 정수 또는 +∞), [[Greedy]] (Boolean) 필드를 갖는 레코드</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Quantifier :: QuantifierPrefix</emu-grammar>
        <emu-alg>
          1. _qp_ 를 |QuantifierPrefix| 에 대해 CompileQuantifierPrefix 한 결과로 둔다.
          1. { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* } 레코드를 반환한다.
        </emu-alg>
        <emu-grammar>Quantifier :: QuantifierPrefix `?`</emu-grammar>
        <emu-alg>
          1. _qp_ 를 |QuantifierPrefix| 에 대해 CompileQuantifierPrefix 한 결과로 둔다.
          1. { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* } 레코드를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compilequantifierprefix" type="sdo">
        <h1>런타임 의미론: CompileQuantifierPrefix ( ): [[Min]] (음이 아닌 정수), [[Max]] (음이 아닌 정수 또는 +∞) 필드를 갖는 레코드</h1>
        <dl class="header">
        </dl>
        <emu-grammar>QuantifierPrefix :: `*`</emu-grammar>
        <emu-alg>
          1. { [[Min]]: 0, [[Max]]: +∞ } 반환.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `+`</emu-grammar>
        <emu-alg>
          1. { [[Min]]: 1, [[Max]]: +∞ } 반환.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `?`</emu-grammar>
        <emu-alg>
          1. { [[Min]]: 0, [[Max]]: 1 } 반환.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. _i_ 를 |DecimalDigits| 의 MV ( <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 참조 ) 로 둔다.
          1. { [[Min]]: _i_, [[Max]]: _i_ } 반환.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,}`</emu-grammar>
        <emu-alg>
          1. _i_ 를 |DecimalDigits| 의 MV 로 둔다.
          1. { [[Min]]: _i_, [[Max]]: +∞ } 반환.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. _i_ 를 첫 번째 |DecimalDigits| 의 MV 로 둔다.
          1. _j_ 를 두 번째 |DecimalDigits| 의 MV 로 둔다.
          1. { [[Min]]: _i_, [[Max]]: _j_ } 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compileatom" type="sdo" oldids="sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape">
        <h1>
          런타임 의미론: CompileAtom (
          _rer_: RegExp Record,
          _direction_: ~forward~ 또는 ~backward~,
          ): Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-compileatom-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>

        <!-- Atom -->
        <emu-grammar>Atom :: PatternCharacter</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |PatternCharacter| 가 매치한 문자로 둔다.
          1. _A_ 를 문자 _ch_ 하나를 포함하는 1요소 CharSet 으로 둔다.
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) 반환.
        </emu-alg>
        <emu-grammar>Atom :: `.`</emu-grammar>
        <emu-alg>
          1. _A_ 를 AllCharacters(_rer_) 로 둔다.
          1. _rer_.[[DotAll]] 이 *true* 가 아니면
            1. |LineTerminator| 생성 규칙 우변의 코드 포인트에 대응하는 문자들을 _A_ 에서 제거한다.
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) 반환.
        </emu-alg>
        <emu-grammar>Atom :: CharacterClass</emu-grammar>
        <emu-alg>
          1. _cc_ 를 |CharacterClass| 에 대해 인수 _rer_ 로 CompileCharacterClass 한 결과로 둔다.
          1. _cs_ 를 _cc_.[[CharSet]] 로 둔다.
          1. _rer_.[[UnicodeSets]] 가 *false* 이거나, _cs_ 의 모든 CharSetElement 가 단일 문자(또는 _cs_ 가 비어 있음)로 구성된다면 CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_) 반환.
          1. Assert: _cc_.[[Invert]] 는 *false*.
          1. _lm_ 을 빈 Matcher 리스트로 둔다.
          1. _cs_ 내에서 2 문자 이상인 각 CharSetElement _s_ 에 대해 길이 내림차순으로 반복:
            1. _cs2_ 를 _s_ 의 마지막 코드 포인트 하나를 포함하는 1요소 CharSet 으로 둔다.
            1. _m2_ 를 CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_) 로 둔다.
            1. _s_ 의 뒤에서 두 번째부터 역순으로 각 코드 포인트 _c1_ 에 대해:
              1. _cs1_ 을 코드 포인트 _c1_ 하나를 포함하는 1요소 CharSet 으로 둔다.
              1. _m1_ 을 CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_) 로 둔다.
              1. _m2_ = MatchSequence(_m1_, _m2_, _direction_) 로 설정.
            1. _m2_ 를 _lm_ 에 추가.
          1. _singles_ 를 단일 문자로 구성된 _cs_ 의 모든 CharSetElement 를 포함하는 CharSet 으로 둔다.
          1. CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) 를 _lm_ 에 추가.
          1. _cs_ 가 빈 문자 시퀀스를 포함하면 EmptyMatcher() 를 _lm_ 에 추가.
          1. _m2_ 를 _lm_ 의 마지막 Matcher 로 둔다.
          1. _lm_ 의 뒤에서 두 번째 요소부터 역순으로 각 Matcher _m1_ 에 대해:
            1. _m2_ = MatchTwoAlternatives(_m1_, _m2_) 로 설정.
          1. _m2_ 반환.
        </emu-alg>
        <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _m_ 을 |Disjunction| 에 대해 인수 _rer_, _direction_ 으로 CompileSubpattern 한 결과로 둔다.
          1. _parenIndex_ 를 CountLeftCapturingParensBefore(|Atom|) 로 둔다.
          1. _direction_, _m_, _parenIndex_ 를 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 반환:
            1. Assert: _x_ 는 MatchState.
            1. Assert: _c_ 는 MatcherContinuation.
            1. _d_ 를 매개변수 (_y_) 를 가지며 _x_, _c_, _direction_, _parenIndex_ 를 캡처하고 호출 시 다음을 수행하는 새 MatcherContinuation 으로 둔다:
              1. Assert: _y_ 는 MatchState.
              1. _cap_ 을 _y_.[[Captures]] 의 복사본으로 둔다.
              1. _Input_ 을 _x_.[[Input]] 으로 둔다.
              1. _xe_ 를 _x_.[[EndIndex]] 로 둔다.
              1. _ye_ 를 _y_.[[EndIndex]] 로 둔다.
              1. _direction_ 이 ~forward~ 이면
                1. Assert: _xe_ ≤ _ye_.
                1. _r_ 를 CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ } 로 둔다.
              1. 그렇지 않으면
                1. Assert: _direction_ 은 ~backward~.
                1. Assert: _ye_ ≤ _xe_.
                1. _r_ 를 CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ } 로 둔다.
              1. _cap_[_parenIndex_ + 1] = _r_ 로 설정.
              1. _z_ 를 MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ } 로 둔다.
              1. _c_(_z_) 반환.
            1. _m_(_x_, _d_) 반환.
        </emu-alg>
        <emu-note>
          <p>`(` |Disjunction| `)` 형태의 괄호는 |Disjunction| 패턴 구성요소를 그룹화하고 매치 결과를 저장한다. 결과는 역참조(`\\` + 0이 아닌 10진수), 치환 문자열(replace String)에서 참조, 또는 정규 표현식 매칭 추상 클로저가 반환하는 배열의 일부로 사용될 수 있다. 괄호의 캡처 동작을 억제하려면 `(?:` |Disjunction| `)` 형태를 사용한다.</p>
        </emu-note>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _addModifiers_ 를 |RegularExpressionModifiers| 가 매치한 소스 텍스트로 둔다.
          1. _removeModifiers_ 를 빈 문자열로 둔다.
          1. _modifiedRer_ 를 UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), _removeModifiers_) 로 둔다.
          1. |Disjunction| 에 대해 인수 _modifiedRer_, _direction_ 으로 CompileSubpattern 한 결과 반환.
        </emu-alg>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. _addModifiers_ 를 첫 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트로 둔다.
          1. _removeModifiers_ 를 두 번째 |RegularExpressionModifiers| 가 매치한 소스 텍스트로 둔다.
          1. _modifiedRer_ 를 UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), CodePointsToString(_removeModifiers_)) 로 둔다.
          1. |Disjunction| 에 대해 인수 _modifiedRer_, _direction_ 으로 CompileSubpattern 한 결과 반환.
        </emu-alg>

        <!-- AtomEscape -->
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <emu-alg>
          1. _n_ 을 |DecimalEscape| 의 CapturingGroupNumber 로 둔다.
          1. Assert: _n_ ≤ _rer_.[[CapturingGroupsCount]].
          1. BackreferenceMatcher(_rer_, « _n_ », _direction_) 반환.
        </emu-alg>
        <emu-note>
          <p>`\\` + 0이 아닌 10진수 _n_ 형태의 이스케이프는 _n_<sup>번째</sup> 캡처 괄호의 결과(<emu-xref href="#sec-pattern-notation"></emu-xref>)와 매치된다. 정규 표현식이 _n_ 개보다 적은 캡처 괄호를 가지면 오류이다. 정규 표현식이 _n_ 개 이상 캡처 괄호를 가지지만 _n_<sup>번째</sup> 괄호가 아무 것도 캡처하지 않아 *undefined* 이면 해당 역참조는 항상 성공한다.</p>
        </emu-note>
        <emu-grammar>AtomEscape :: CharacterEscape</emu-grammar>
        <emu-alg>
          1. _cv_ 를 |CharacterEscape| 의 CharacterValue 로 둔다.
          1. _ch_ 를 문자 값이 _cv_ 인 문자로 둔다.
          1. _A_ 를 문자 _ch_ 하나를 포함하는 1요소 CharSet 으로 둔다.
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) 반환.
        </emu-alg>
        <emu-grammar>AtomEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. _cs_ 를 |CharacterClassEscape| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _rer_.[[UnicodeSets]] 가 *false* 이거나 _cs_ 의 모든 CharSetElement 가 단일 문자(또는 _cs_ 가 비어 있음)라면 CharacterSetMatcher(_rer_, _cs_, *false*, _direction_) 반환.
          1. _lm_ 을 빈 Matcher 리스트로 둔다.
          1. _cs_ 내 2 문자 이상인 각 CharSetElement _s_ 에 대해 길이 내림차순 반복:
            1. _cs2_ 를 _s_ 의 마지막 코드 포인트를 포함하는 CharSet 으로 둔다.
            1. _m2_ 를 CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_) 로 둔다.
            1. _s_ 의 뒤에서 두 번째부터 역순으로 각 코드 포인트 _c1_ 에 대해:
              1. _cs1_ 를 코드 포인트 _c1_ 포함하는 CharSet 으로 둔다.
              1. _m1_ 을 CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_) 로 둔다.
              1. _m2_ = MatchSequence(_m1_, _m2_, _direction_) 로 설정.
            1. _m2_ 를 _lm_ 에 추가.
          1. _singles_ 를 단일 문자 CharSetElement 로 이루어진 CharSet 으로 둔다.
          1. CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) 를 _lm_ 에 추가.
          1. _cs_ 가 빈 문자 시퀀스를 포함하면 EmptyMatcher() 를 _lm_ 에 추가.
          1. _m2_ 를 _lm_ 의 마지막 Matcher 로 둔다.
          1. _lm_ 의 뒤에서 두 번째부터 역순으로 각 Matcher _m1_ 에 대해
            1. _m2_ = MatchTwoAlternatives(_m1_, _m2_) 로 설정.
          1. _m2_ 반환.
        </emu-alg>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <emu-alg>
          1. _matchingGroupSpecifiers_ 를 GroupSpecifiersThatMatch(|GroupName|) 로 둔다.
          1. _parenIndices_ 를 새 빈 리스트로 둔다.
          1. _matchingGroupSpecifiers_ 의 각 |GroupSpecifier| _groupSpecifier_ 에 대해:
            1. _parenIndex_ 를 CountLeftCapturingParensBefore(_groupSpecifier_) 로 둔다.
            1. _parenIndex_ 를 _parenIndices_ 에 추가.
          1. BackreferenceMatcher(_rer_, _parenIndices_, _direction_) 반환.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-charactersetmatcher-abstract-operation" type="abstract operation">
          <h1>
            CharacterSetMatcher (
              _rer_: RegExp Record,
              _A_: CharSet,
              _invert_: Boolean,
              _direction_: ~forward~ 또는 ~backward~,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] 가 *true* 이면
              1. Assert: _invert_ 는 *false*.
              1. Assert: _A_ 의 모든 CharSetElement 는 단일 문자.
            1. _rer_, _A_, _invert_, _direction_ 을 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 반환:
              1. Assert: _x_ 는 MatchState.
              1. Assert: _c_ 는 MatcherContinuation.
              1. _Input_ 을 _x_.[[Input]] 로 둔다.
              1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
              1. _direction_ 이 ~forward~ 이면 _f_ = _e_ + 1.
              1. 그렇지 않으면 _f_ = _e_ - 1.
              1. _InputLength_ 를 _Input_ 요소 수로 둔다.
              1. _f_ &lt; 0 또는 _f_ > _InputLength_ 이면 ~failure~ 반환.
              1. _index_ = min(_e_, _f_) 로 둔다.
              1. _ch_ 를 문자 _Input_[_index_] 로 둔다.
              1. _cc_ 를 Canonicalize(_rer_, _ch_) 로 둔다.
              1. _A_ 내에서 정확히 한 문자를 포함하는 CharSetElement 중 Canonicalize(_rer_, _a_) 가 _cc_ 인 _a_ 가 존재하면 _found_ = *true*; 아니면 *false*.
              1. _invert_ = *false* 이고 _found_ = *false* 이면 ~failure~ 반환.
              1. _invert_ = *true* 이고 _found_ = *true* 이면 ~failure~ 반환.
              1. _cap_ 을 _x_.[[Captures]] 로 둔다.
              1. _y_ 를 MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ } 로 둔다.
              1. _c_(_y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-backreference-matcher" type="abstract operation">
          <h1>
            BackreferenceMatcher (
              _rer_: RegExp Record,
              _ns_: 양의 정수 리스트,
              _direction_: ~forward~ 또는 ~backward~,
            ): Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_, _ns_, _direction_ 을 캡처하고 매개변수 (_x_, _c_) 를 가지며 호출 시 다음을 수행하는 새 Matcher 반환:
              1. Assert: _x_ 는 MatchState.
              1. Assert: _c_ 는 MatcherContinuation.
              1. _Input_ 을 _x_.[[Input]] 로 둔다.
              1. _cap_ 을 _x_.[[Captures]] 로 둔다.
              1. _r_ 를 *undefined* 로 둔다.
              1. _ns_ 의 각 정수 _n_ 에 대해:
                1. _cap_[_n_] 이 *undefined* 가 아니면
                  1. Assert: _r_ 는 *undefined*.
                  1. _r_ = _cap_[_n_] 로 설정.
              1. _r_ 가 *undefined* 이면 _c_(_x_) 반환.
              1. _e_ 를 _x_.[[EndIndex]] 로 둔다.
              1. _rs_ 를 _r_.[[StartIndex]] 로 둔다.
              1. _re_ 를 _r_.[[EndIndex]] 로 둔다.
              1. _len_ = _re_ - _rs_ 로 둔다.
              1. _direction_ 이 ~forward~ 이면 _f_ = _e_ + _len_, 아니면 _f_ = _e_ - _len_.
              1. _InputLength_ 를 _Input_ 요소 수로 둔다.
              1. _f_ &lt; 0 또는 _f_ > _InputLength_ 이면 ~failure~ 반환.
              1. _g_ = min(_e_, _f_) 로 둔다.
              1. 0 ≤ _i_ < _len_ 인 어떤 정수 _i_ 가 Canonicalize(_rer_, _Input_[_rs_ + _i_]) ≠ Canonicalize(_rer_, _Input_[_g_ + _i_]) 이면 ~failure~ 반환.
              1. _y_ 를 MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ } 로 둔다.
              1. _c_(_y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-canonicalize-ch" type="abstract operation">
          <h1>
            Canonicalize (
              _rer_: RegExp Record,
              _ch_: 문자,
            ): 문자
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. HasEitherUnicodeFlag(_rer_) 가 *true* 이고 _rer_.[[IgnoreCase]] 가 *true* 이면
              1. Unicode Character Database 의 <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> 가 _ch_ 에 대한 simple 또는 common case folding 매핑을 제공하면 그 매핑을 적용한 결과 반환.
              1. _ch_ 반환.
            1. _rer_.[[IgnoreCase]] 가 *false* 이면 _ch_ 반환.
            1. Assert: _ch_ 는 UTF-16 코드 유닛.
            1. _cp_ 를 수치 값이 _ch_ 의 수치 값인 코드 포인트로 둔다.
            1. _u_ 를 Unicode Default Case Conversion 알고리즘에 따라 toUppercase(« _cp_ ») 로 둔다.
            1. _uStr_ 를 CodePointsToString(_u_) 로 둔다.
            1. _uStr_ 길이 ≠ 1 이면 _ch_ 반환.
            1. _cu_ 를 _uStr_ 의 단일 코드 유닛 요소로 둔다.
            1. _ch_ 의 수치 값 ≥ 128 이고 _cu_ 의 수치 값 &lt; 128 이면 _ch_ 반환.
            1. _cu_ 반환.
          </emu-alg>
          <emu-note>
            <p>HasEitherUnicodeFlag(_rer_) 가 *true* 이고 대소문자 구분이 무시될 때, 모든 문자는 비교 직전에 Unicode Standard 가 제공하는 simple case folding 으로 암묵적으로 폴딩된다. simple 매핑은 항상 단일 코드 포인트로 매핑하므로 `ß` (U+00DF) 를 `ss` 나 `SS` 로 매핑하지 않는다. 그러나 Basic Latin 블록 밖의 코드 포인트를 그 안으로 매핑할 수 있다 (예: `ſ` → `s`, `K` → `k`). 이런 코드 포인트를 포함하는 문자열은 `/[a-z]/ui` 같은 정규 표현식에 매치된다.</p>
            <p>HasEitherUnicodeFlag(_rer_) 가 *false* 인 대소문자 비구분 매칭에서는 toCasefold 대신 Unicode 기본 대문자 변환 toUppercase 기반 매핑을 사용하므로 약간 차이가 난다. 예를 들어 `Ω` (U+2126) 는 toUppercase 로 자기 자신을 반환하지만 toCasefold 로는 `ω` (U+03C9) 와 `Ω` (U+03A9) 와 함께 `ω` 로 매핑된다. 따라서 *"\u2126"* 는 `/[ω]/ui`, `/[\u03A9]/ui` 에 매치되지만 `/[ω]/i`, `/[\u03A9]/i` 에는 매치되지 않는다. 또한 Basic Latin 블록 밖 코드 포인트가 그 안으로 매핑되지 않으므로 *"\u017F ſ"*, *"\u212A K"* 는 `/[a-z]/i` 에 매치되지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-updatemodifiers" type="abstract operation">
          <h1>
            UpdateModifiers (
              _rer_: RegExp Record,
              _add_: String,
              _remove_: String,
            ): RegExp Record
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _add_ 와 _remove_ 는 공통 요소가 없다.
            1. _ignoreCase_ = _rer_.[[IgnoreCase]].
            1. _multiline_ = _rer_.[[Multiline]].
            1. _dotAll_ = _rer_.[[DotAll]].
            1. _unicode_ = _rer_.[[Unicode]].
            1. _unicodeSets_ = _rer_.[[UnicodeSets]].
            1. _capturingGroupsCount_ = _rer_.[[CapturingGroupsCount]].
            1. _remove_ 가 *"i"* 포함하면 _ignoreCase_ = *false*.
            1. Else _add_ 가 *"i"* 포함하면 _ignoreCase_ = *true*.
            1. _remove_ 가 *"m"* 포함하면 _multiline_ = *false*.
            1. Else _add_ 가 *"m"* 포함하면 _multiline_ = *true*.
            1. _remove_ 가 *"s"* 포함하면 _dotAll_ = *false*.
            1. Else _add_ 가 *"s"* 포함하면 _dotAll_ = *true*.
            1. RegExp Record { [[IgnoreCase]]: _ignoreCase_, [[Multiline]]: _multiline_, [[DotAll]]: _dotAll_, [[Unicode]]: _unicode_, [[UnicodeSets]]: _unicodeSets_, [[CapturingGroupsCount]]: _capturingGroupsCount_ } 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilecharacterclass" type="sdo" oldids="sec-characterclass">
        <h1>
          런타임 의미론: CompileCharacterClass (
          _rer_: RegExp Record,
          ): [[CharSet]] (CharSet), [[Invert]] (Boolean) 필드를 가진 레코드
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>CharacterClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. { [[CharSet]]: _A_, [[Invert]]: *false* } 반환.
        </emu-alg>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _rer_.[[UnicodeSets]] 가 *true* 이면
            1. { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* } 반환.
          1. { [[CharSet]]: _A_, [[Invert]]: *true* } 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compiletocharset" type="sdo" oldids="sec-classranges,sec-nonemptyclassranges,sec-nonemptyclassrangesnodash,sec-classatom,sec-classatomnodash,sec-classescape,sec-characterclassescape">
        <h1>
          런타임 의미론: CompileToCharSet (
          _rer_: RegExp Record,
          ): CharSet
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-compiletocharset-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>

        <!-- ClassContents -->
        <emu-grammar>ClassContents :: [empty]</emu-grammar>
        <emu-alg>
          1. 빈 CharSet 반환.
        </emu-alg>

        <!-- NonemptyClassRanges -->
        <emu-grammar>NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassAtom| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 |NonemptyClassRangesNoDash| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. CharSet _A_ 와 _B_ 의 합집합 반환.
        </emu-alg>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ 를 첫 번째 |ClassAtom| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 두 번째 |ClassAtom| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _C_ 를 |ClassContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _D_ 를 CharacterRange(_A_, _B_) 로 둔다.
          1. _D_ 와 _C_ 의 합집합 반환.
        </emu-alg>

        <!-- NonemptyClassRangesNoDash -->
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassAtomNoDash| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 |NonemptyClassRangesNoDash| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. CharSet _A_ 와 _B_ 의 합집합 반환.
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassAtomNoDash| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 |ClassAtom| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _C_ 를 |ClassContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _D_ 를 CharacterRange(_A_, _B_) 로 둔다.
          1. _D_ 와 _C_ 의 합집합 반환.
        </emu-alg>
        <emu-note>
          <p>|ClassContents| 는 하나의 |ClassAtom| 이나 `-` 로 구분된 두 |ClassAtom| 범위로 확장될 수 있다. 후자의 경우 첫 번째와 두 번째 |ClassAtom| 사이(포함)의 모든 문자를 포함한다. 어느 |ClassAtom| 도 단일 문자를 나타내지 않으면(예: \w) 또는 첫 번째 |ClassAtom| 의 문자 값이 두 번째보다 엄격히 크면 오류이다.</p>
        </emu-note>
        <emu-note>
          <p>패턴이 대소문자를 무시하더라도 범위의 두 끝 문자 대소문자는 범위에 속하는 문자를 결정하는 데 여전히 중요하다. 예를 들어 `/[E-F]/i` 는 `E`, `F`, `e`, `f` 만 매치하지만 `/[E-f]/i` 는 Unicode Basic Latin 블록의 모든 대소문자와 `[`, `\\`, `]`, `^`, `_`, <code>`</code> 기호를 매치한다.</p>
        </emu-note>
        <emu-note>
          <p>`-` 문자는 리터럴로 취급되거나 범위를 나타낼 수 있다. |ClassContents| 의 첫/마지막 문자, 범위의 시작/끝 경계, 또는 범위 지정 직후에 나타나면 리터럴로 취급된다.</p>
        </emu-note>

        <!-- ClassAtom -->
        <emu-grammar>ClassAtom :: `-`</emu-grammar>
        <emu-alg>
          1. 문자 `-` (U+002D HYPHEN-MINUS) 하나를 포함하는 CharSet 반환.
        </emu-alg>

        <!-- ClassAtomNoDash -->
        <emu-grammar>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</emu-grammar>
        <emu-alg>
          1. |SourceCharacter| 가 매치한 문자를 포함하는 CharSet 반환.
        </emu-alg>

        <!-- ClassEscape -->
        <emu-grammar>
          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. _cv_ 를 이 |ClassEscape| 의 CharacterValue 로 둔다.
          1. _c_ 를 문자 값이 _cv_ 인 문자로 둔다.
          1. 문자 _c_ 하나를 포함하는 CharSet 반환.
        </emu-alg>
        <emu-note>
          <p>|ClassAtom| 은 정규 표현식 다른 부분에서 허용되는 이스케이프 대부분을 사용할 수 있으나 `\\b`, `\\B`, 역참조는 제외된다. |CharacterClass| 내부에서 `\\b` 는 백스페이스 문자를 의미하며, `\\B` 와 역참조는 오류이다. |ClassAtom| 내에서 역참조를 사용하면 오류가 발생한다.</p>
        </emu-note>

        <!-- CharacterClassEscape -->
        <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>
        <emu-alg>
          1. 문자 `0`..`9` 10개를 포함하는 CharSet 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `D`</emu-grammar>
        <emu-alg>
          1. _S_ 를 <emu-grammar>CharacterClassEscape :: `d`</emu-grammar> 가 반환한 CharSet 으로 둔다.
          1. CharacterComplement(_rer_, _S_) 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>
        <emu-alg>
          1. |WhiteSpace| 또는 |LineTerminator| 생성 규칙 우변의 코드 포인트에 대응하는 모든 문자를 포함하는 CharSet 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `S`</emu-grammar>
        <emu-alg>
          1. _S_ 를 <emu-grammar>CharacterClassEscape :: `s`</emu-grammar> 가 반환한 CharSet 으로 둔다.
          1. CharacterComplement(_rer_, _S_) 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>
        <emu-alg>
          1. MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)) 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `W`</emu-grammar>
        <emu-alg>
          1. _S_ 를 <emu-grammar>CharacterClassEscape :: `w`</emu-grammar> 가 반환한 CharSet 으로 둔다.
          1. CharacterComplement(_rer_, _S_) 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `p{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. |UnicodePropertyValueExpression| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과 반환.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. _S_ 를 |UnicodePropertyValueExpression| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. Assert: _S_ 는 단일 코드 포인트만 포함한다.
          1. CharacterComplement(_rer_, _S_) 반환.
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <emu-alg>
          1. _ps_에 |UnicodePropertyName|에 의해 매치된 소스 텍스트를 할당한다.
          1. _p_에 UnicodeMatchProperty(_rer_, _ps_)의 결과를 할당한다.
          1. 단언: _p_는 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>의 “<emu-not-ref>Property name and aliases</emu-not-ref>” 열에 나열된 <emu-not-ref>Unicode property name</emu-not-ref> 또는 속성 별칭이다.
          1. _vs_에 |UnicodePropertyValue|에 의해 매치된 소스 텍스트를 할당한다.
          1. _v_에 UnicodeMatchPropertyValue(_p_, _vs_)의 결과를 할당한다.
          1. _A_에 속성 데이터베이스 정의에 속성 _p_와 값 _v_가 포함된 모든 유니코드 코드 포인트를 포함하는 CharSet을 할당한다.
          1. MaybeSimpleCaseFolding(_rer_, _A_)를 반환한다.
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. _s_에 |LoneUnicodePropertyNameOrValue|에 의해 매치된 소스 텍스트를 할당한다.
          1. UnicodeMatchPropertyValue(`General_Category`, _s_)가 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>에 나열된 General_Category (gc) 속성에 대한 유니코드 속성 값 또는 속성 값 별칭인 경우,
            1. 속성 데이터베이스 정의에 속성 “General_Category”와 값 _s_가 포함된 모든 유니코드 코드 포인트를 포함하는 CharSet을 반환한다.
          1. _p_에 UnicodeMatchProperty(_rer_, _s_)의 결과를 할당한다.
          1. 단언: _p_는 <emu-xref href="#table-binary-unicode-properties"></emu-xref>의 “<emu-not-ref>Property name and aliases</emu-not-ref>” 열에 나열된 바이너리 유니코드 속성 또는 속성 별칭이거나, <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>의 “<emu-not-ref>Property name</emu-not-ref>” 열에 나열된 문자열의 바이너리 유니코드 속성이다.
          1. _A_에 속성 데이터베이스 정의에 속성 _p_와 값 “True”가 포함된 모든 CharSetElement를 포함하는 CharSet을 할당한다.
          1. MaybeSimpleCaseFolding(_rer_, _A_)를 반환한다.
        </emu-alg>

        <!-- ClassUnion -->
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassSetRange| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. |ClassUnion| 이 존재하면
            1. _B_ 를 |ClassUnion| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
            1. CharSet _A_, _B_ 의 합집합 반환.
          1. _A_ 반환.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. |ClassUnion| 존재하면
            1. _B_ 를 |ClassUnion| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
            1. CharSet _A_, _B_ 합집합 반환.
          1. _A_ 반환.
        </emu-alg>

        <!-- ClassIntersection -->
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ 를 첫 번째 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 두 번째 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. CharSet _A_, _B_ 교집합 반환.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassIntersection| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. CharSet _A_, _B_ 교집합 반환.
        </emu-alg>

        <!-- ClassSubtraction -->
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ 를 첫 번째 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 두 번째 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _A_ 중 _B_ 에 속하지 않는 CharSetElement 들만 포함하는 CharSet 반환.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassSubtraction| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 |ClassSetOperand| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _A_ 중 _B_ 에 속하지 않는 CharSetElement 들만 포함하는 CharSet 반환.
        </emu-alg>

        <!-- ClassSetRange -->
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. _A_ 를 첫 번째 |ClassSetCharacter| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _B_ 를 두 번째 |ClassSetCharacter| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)) 반환.
        </emu-alg>
        <emu-note>
          <p>결과는 종종 두 개 이상의 범위로 구성된다. UnicodeSets *true*, IgnoreCase *true* 인 경우 MaybeSimpleCaseFolding(_rer_, [Ā-č]) 는 해당 범위의 홀수 코드 포인트만 포함할 수 있다.</p>
        </emu-note>

        <!-- ClassSetOperand -->
        <emu-grammar>ClassSetOperand :: ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassSetCharacter| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. MaybeSimpleCaseFolding(_rer_, _A_) 반환.
        </emu-alg>
        <emu-grammar>ClassSetOperand :: ClassStringDisjunction</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassStringDisjunction| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. MaybeSimpleCaseFolding(_rer_, _A_) 반환.
        </emu-alg>
        <emu-grammar>ClassSetOperand :: NestedClass</emu-grammar>
        <emu-alg>
          1. |NestedClass| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과 반환.
        </emu-alg>

        <!-- NestedClass -->
        <emu-grammar>NestedClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. |ClassContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과 반환.
        </emu-alg>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. CharacterComplement(_rer_, _A_) 반환.
        </emu-alg>
        <emu-grammar>NestedClass :: `\` CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. |CharacterClassEscape| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과 반환.
        </emu-alg>

        <!-- ClassStringDisjunction -->
        <emu-grammar>ClassStringDisjunction :: `\q{` ClassStringDisjunctionContents `}`</emu-grammar>
        <emu-alg>
          1. |ClassStringDisjunctionContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과 반환.
        </emu-alg>

        <!-- ClassStringDisjunctionContents -->
        <emu-grammar>ClassStringDisjunctionContents :: ClassString</emu-grammar>
        <emu-alg>
          1. _s_ 를 |ClassString| 에 대해 인수 _rer_ 로 CompileClassSetString 한 결과로 둔다.
          1. 문자열 _s_ 하나를 포함하는 CharSet 반환.
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. _s_ 를 |ClassString| 에 대해 인수 _rer_ 로 CompileClassSetString 한 결과로 둔다.
          1. _A_ 를 문자열 _s_ 하나를 포함하는 CharSet 으로 둔다.
          1. _B_ 를 |ClassStringDisjunctionContents| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. CharSet _A_, _B_ 합집합 반환.
        </emu-alg>

        <!-- ClassSetCharacter -->
        <emu-grammar>
          ClassSetCharacter ::
            SourceCharacter but not ClassSetSyntaxCharacter
            `\` CharacterEscape
            `\` ClassSetReservedPunctuator
        </emu-grammar>
        <emu-alg>
          1. _cv_ 를 이 |ClassSetCharacter| 의 CharacterValue 로 둔다.
          1. _c_ 를 문자 값이 _cv_ 인 문자로 둔다.
          1. 문자 _c_ 하나를 포함하는 CharSet 반환.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. U+0008 (BACKSPACE) 문자 하나를 포함하는 CharSet 반환.
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-characterrange-abstract-operation" type="abstract operation">
          <h1>
            CharacterRange (
              _A_: CharSet,
              _B_: CharSet,
            ): CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _A_, _B_ 는 각각 정확히 한 문자만 포함.
            1. _a_ 를 CharSet _A_ 의 그 문자로 둔다.
            1. _b_ 를 CharSet _B_ 의 그 문자로 둔다.
            1. _i_ 를 문자 _a_ 의 문자 값으로 둔다.
            1. _j_ 를 문자 _b_ 의 문자 값으로 둔다.
            1. Assert: _i_ ≤ _j_.
            1. 문자 값이 _i_.._j_ (포함) 범위에 속하는 모든 문자를 포함하는 CharSet 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-haseitherunicodeflag-abstract-operation" type="abstract operation">
          <h1>
            HasEitherUnicodeFlag (
              _rer_: RegExp Record,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_.[[Unicode]] 가 *true* 이거나 _rer_.[[UnicodeSets]] 가 *true* 이면
              1. *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-wordcharacters" type="abstract operation" oldids="sec-runtime-semantics-wordcharacters-abstract-operation">
          <h1>
            WordCharacters (
              _rer_: RegExp Record,
            ): CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>`\\b`, `\\B`, `\\w`, `\\W` 판단에 사용되는 “단어 문자”들을 포함하는 CharSet 반환</dd>
          </dl>
          <emu-alg>
            1. _basicWordChars_ 를 ASCII 단어 문자를 모두 포함하는 CharSet 으로 둔다.
            1. _extraWordChars_ 를 _basicWordChars_ 에 없지만 Canonicalize(_rer_, _c_) 가 _basicWordChars_ 에 있는 문자 _c_ 전부를 포함하는 CharSet 으로 둔다.
            1. Assert: _extraWordChars_ 는 HasEitherUnicodeFlag(_rer_) 가 *true* 이고 _rer_.[[IgnoreCase]] 가 *true* 인 경우를 제외하면 비어 있음.
            1. _basicWordChars_ 와 _extraWordChars_ 합집합 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allcharacters" type="abstract operation">
          <h1>
            AllCharacters (
              _rer_: RegExp Record,
            ): CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>정규 표현식 플래그에 따른 “모든 문자” 집합을 반환한다.</dd>
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] *true*, _rer_.[[IgnoreCase]] *true* 이면
              1. [declared="c"] Simple Case Folding 매핑이 없는(즉 scf(_c_) = _c_) 모든 유니코드 코드 포인트 _c_ 를 포함하는 CharSet 반환.
            1. Else HasEitherUnicodeFlag(_rer_) *true* 이면
              1. 모든 코드 포인트 값을 포함하는 CharSet 반환.
            1. Else
              1. 모든 코드 유닛 값을 포함하는 CharSet 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-maybesimplecasefolding" type="abstract operation">
          <h1>
            MaybeSimpleCaseFolding (
              _rer_: RegExp Record,
              _A_: CharSet,
            ): CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_rer_.[[UnicodeSets]] 가 *false* 이거나 _rer_.[[IgnoreCase]] 가 *false* 이면 _A_ 를 반환한다. 그렇지 않으면 Unicode Character Database 의 <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> (<emu-eqn id="eqn-scf" aoid="scf">scf(_cp_)</emu-eqn>) 정의(각각 단일 코드 포인트를 다른 단일 코드 포인트로 매핑)를 사용하여 _A_ 의 각 CharSetElement 를 문자 단위로 정규 형태로 매핑한 결과 CharSet 을 반환한다.</dd>
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]] *false* 또는 _rer_.[[IgnoreCase]] *false* 이면 _A_ 반환.
            1. _B_ 를 새 빈 CharSet 으로 둔다.
            1. _A_ 의 각 CharSetElement _s_ 에 대해:
              1. _t_ 를 빈 문자 시퀀스로 둔다.
              1. _s_ 의 각 단일 코드 포인트 _cp_ 에 대해:
                1. scf(_cp_) 를 _t_ 에 추가.
              1. _t_ 를 _B_ 에 추가.
            1. _B_ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-charactercomplement" type="abstract operation">
          <h1>
            CharacterComplement (
              _rer_: RegExp Record,
              _S_: CharSet,
            ): CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _A_ 를 AllCharacters(_rer_) 로 둔다.
            1. _A_ 중 _S_ 에 속하지 않는 CharSetElement 들만 포함하는 CharSet 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchproperty-p" type="abstract operation">
          <h1>
            UnicodeMatchProperty (
              _rer_: 정규식 레코드,
              _p_: ECMAScript 소스 텍스트,
            ): <emu-not-ref>Unicode property name</emu-not-ref>
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _rer_.[[UnicodeSets]]가 *true*이고 _p_가 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>의 “<emu-not-ref>Property name</emu-not-ref>” 열에 나열된 <emu-not-ref>Unicode property name</emu-not-ref>인 경우,
              1. 유니코드 코드 포인트 _p_의 리스트를 반환한다.
            1. 단언: _p_는 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> 또는 <emu-xref href="#table-binary-unicode-properties"></emu-xref>의 “<emu-not-ref>Property name and aliases</emu-not-ref>” 열에 나열된 <emu-not-ref>Unicode property name</emu-not-ref> 또는 속성 별칭이다.
            1. _c_에 해당 행의 “<emu-not-ref>Canonical property name</emu-not-ref>” 열에 주어진 _p_의 표준 <emu-not-ref>property name</emu-not-ref>을 할당한다.
            1. 유니코드 코드 포인트 _c_의 리스트를 반환한다.
          </emu-alg>
          <p>구현체는 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>, <emu-xref href="#table-binary-unicode-properties"></emu-xref>, <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>에 나열된 <emu-not-ref>Unicode property names</emu-not-ref>와 별칭을 지원해야 한다. 상호 운용성을 보장하기 위해, 구현체는 다른 <emu-not-ref>property names</emu-not-ref>나 별칭을 지원해서는 안 된다.</p>
          <emu-note>
            <p>예를 들어, `Script_Extensions`(<emu-not-ref>property name</emu-not-ref>)와 `scx`(속성 별칭)는 유효하지만, `script_extensions`나 `Scx`는 유효하지 않다.</p>
          </emu-note>
          <emu-note>
            <p>나열된 속성들은 <a href="https://unicode.org/reports/tr18/#RL1.2">UTS18 RL1.2</a>가 요구하는 것보다 더 넓은 집합을 이룬다.</p>
          </emu-note>
          <emu-note>
            <p>이 표의 항목 표기(대소문자 포함)는 유니코드 문자 데이터베이스의 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt"><code>PropertyAliases.txt</code></a> 파일에서 사용된 표기와 일치한다. 해당 파일의 정확한 표기는 <a href="https://www.unicode.org/policies/stability_policy.html#Alias_Stability">안정적으로 보장</a>된다.</p>
          </emu-note>
          <emu-import href="table-nonbinary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties-of-strings.html"></emu-import>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchpropertyvalue-p-v" type="abstract operation">
          <h1>
            UnicodeMatchPropertyValue (
              _p_: ECMAScript 소스 텍스트,
              _v_: ECMAScript 소스 텍스트,
            ): 유니코드 속성 값
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 단언: _p_는 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>의 “<emu-not-ref>Canonical property name</emu-not-ref>” 열에 나열된 표준, 별칭이 아닌 <emu-not-ref>Unicode property name</emu-not-ref>이다.
            1. 단언: _v_는 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>에 나열된 유니코드 속성 _p_에 대한 속성 값 또는 속성 값 별칭이다.
            1. _value_에 해당 행의 “Canonical property value” 열에 주어진 _v_의 표준 속성 값을 할당한다.
            1. 유니코드 코드 포인트 _value_의 리스트를 반환한다.
          </emu-alg>
          <p>구현체는 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>에 나열된 속성에 대해 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>에 나열된 유니코드 속성 값 및 속성 값 별칭을 지원해야 한다. 상호 운용성을 보장하기 위해, 구현체는 다른 속성 값이나 속성 값 별칭을 지원해서는 안 된다.</p>
          <emu-note>
            <p>예를 들어, `Xpeo`와 `Old_Persian`은 `Script_Extensions`의 유효한 값이지만, `xpeo`와 `Old Persian`은 유효하지 않다.</p>
          </emu-note>
          <emu-note>
            <p>이 알고리즘은 <a href="https://unicode.org/reports/tr44/#Matching_Symbolic">UAX44에 나열된 심볼릭 값 일치 규칙</a>과 다르다: 대소문자, <emu-xref href="#sec-white-space">공백</emu-xref>, U+002D(하이픈-마이너스), U+005F(로우 라인)은 무시되지 않으며, `Is` 접두사는 지원되지 않는다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileclasssetstring" type="sdo">
        <h1>
          런타임 의미론: CompileClassSetString (
          _rer_: RegExp Record,
          ): 문자 시퀀스
        </h1>
        <dl class="header">
        </dl>

        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. 빈 문자 시퀀스 반환.
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. |NonEmptyClassString| 에 대해 인수 _rer_ 로 CompileClassSetString 한 결과 반환.
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. _cs_ 를 |ClassSetCharacter| 에 대해 인수 _rer_ 로 CompileToCharSet 한 결과로 둔다.
          1. _s1_ 을 _cs_ 의 단일 CharSetElement 인 문자 시퀀스로 둔다.
          1. |NonEmptyClassString| 이 존재하면
            1. _s2_ 를 |NonEmptyClassString| 에 대해 인수 _rer_ 로 CompileClassSetString 한 결과로 둔다.
            1. _s1_ 과 _s2_ 의 연결(concatenation) 반환.
          1. _s1_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-creation" oldids="sec-abstract-operations-for-the-regexp-constructor">
      <h1>RegExp 생성용 추상 연산 (Abstract Operations for RegExp Creation)</h1>

      <emu-clause id="sec-regexpcreate" type="abstract operation">
        <h1>
          RegExpCreate (
            _P_: ECMAScript 언어 값,
            _F_: String 또는 *undefined*,
          ): Object 를 포함하는 정상 완료(normal completion) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _obj_ 를 ! RegExpAlloc(%RegExp%) 의 결과로 둔다.
          1. ? RegExpInitialize(_obj_, _P_, _F_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpalloc" type="abstract operation">
        <h1>
          RegExpAlloc (
            _newTarget_: 생성자(constructor),
          ): Object 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _obj_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%RegExp.prototype%"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] ») 로 둔다.
          1. ! DefinePropertyOrThrow(_obj_, *"lastIndex"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 를 수행한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpinitialize" type="abstract operation">
        <h1>
          RegExpInitialize (
            _obj_: Object,
            _pattern_: ECMAScript 언어 값,
            _flags_: ECMAScript 언어 값,
          ): Object 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _pattern_ 이 *undefined* 이면 _P_ 를 빈 String 으로 둔다.
          1. 아니면 _P_ 를 ? ToString(_pattern_) 으로 둔다.
          1. _flags_ 가 *undefined* 이면 _F_ 를 빈 String 으로 둔다.
          1. 아니면 _F_ 를 ? ToString(_flags_) 로 둔다.
          1. _F_ 가 *"d"*, *"g"*, *"i"*, *"m"*, *"s"*, *"u"*, *"v"*, *"y"* 외의 코드 유닛을 포함하거나, 어떤 코드 유닛이든 두 번 이상 포함하면 *SyntaxError* 예외를 throw 한다.
          1. _F_ 가 *"i"* 를 포함하면 _i_ = *true*; 아니면 *false*.
          1. _F_ 가 *"m"* 를 포함하면 _m_ = *true*; 아니면 *false*.
          1. _F_ 가 *"s"* 를 포함하면 _s_ = *true*; 아니면 *false*.
          1. _F_ 가 *"u"* 를 포함하면 _u_ = *true*; 아니면 *false*.
          1. _F_ 가 *"v"* 를 포함하면 _v_ = *true*; 아니면 *false*.
          1. _u_ 가 *true* 이거나 _v_ 가 *true* 이면
            1. _patternText_ 를 StringToCodePoints(_P_) 로 둔다.
          1. 아니면
            1. _patternText_ 를 _P_ 의 각 16-bit 요소를 UTF-16 디코딩 없이 Unicode BMP 코드 포인트로 해석한 결과로 둔다.
          1. _parseResult_ 를 ParsePattern(_patternText_, _u_, _v_) 로 둔다.
          1. _parseResult_ 가 비어 있지 않은 *SyntaxError* 객체들의 List 이면 *SyntaxError* 예외를 throw 한다.
          1. Assert: _parseResult_ 는 |Pattern| Parse Node 이다.
          1. _obj_.[[OriginalSource]] = _P_.
          1. _obj_.[[OriginalFlags]] = _F_.
          1. _capturingGroupsCount_ 를 CountLeftCapturingParensWithin(_parseResult_) 로 둔다.
          1. _rer_ 를 RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ } 로 둔다.
          1. _obj_.[[RegExpRecord]] = _rer_.
          1. _obj_.[[RegExpMatcher]] = CompilePattern of _parseResult_ with argument _rer_.
          1. ? <emu-meta suppress-effects="user-code">Set(_obj_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta> 를 수행한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-parsepattern" type="abstract operation">
        <h1>
          정적 의미론: ParsePattern (
          _patternText_: Unicode 코드 포인트 시퀀스,
          _u_: Boolean,
          _v_: Boolean,
          ): Parse Node 또는 비어 있지 않은 *SyntaxError* 객체 List
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 절은 <emu-xref href="#sec-parsepattern-annexb"></emu-xref> 에서 수정된다.</p>
        </emu-note>
        <emu-alg>
          1. _v_ 가 *true* 이고 _u_ 가 *true* 이면
            1. _parseResult_ 를 하나 이상의 *SyntaxError* 객체를 포함하는 List 로 둔다.
          1. Else if _v_ 가 *true* 이면
            1. _parseResult_ = ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else if _u_ 가 *true* 이면
            1. _parseResult_ = ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else
            1. _parseResult_ = ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. _parseResult_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-constructor">
      <h1>RegExp 생성자 (The RegExp Constructor)</h1>
      <p>RegExp 생성자는 다음을 만족한다:</p>
      <ul>
        <li><dfn>%RegExp%</dfn> 이다.</li>
        <li>전역 객체의 *"RegExp"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 RegExp 객체를 생성·초기화한다.</li>
        <li>생성자가 아닌 함수로 호출될 때, 새 RegExp 객체를 반환하거나 인자가 RegExp 객체 하나뿐이면 그 인자를 그대로 반환한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 RegExp 동작을 상속하려는 서브클래스 생성자는 필요한 내부 슬롯을 가진 인스턴스를 생성·초기화하기 위해 반드시 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-regexp-pattern-flags">
        <h1>RegExp ( _pattern_, _flags_ )</h1>
        <p>이 함수가 호출되면 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _patternIsRegExp_ 를 ? IsRegExp(_pattern_) 로 둔다.
          1. NewTarget 이 *undefined* 이면
            1. _newTarget_ = 활성 함수 객체.
            1. _patternIsRegExp_ 가 *true* 이고 _flags_ 가 *undefined* 이면
              1. _patternConstructor_ = ? Get(_pattern_, *"constructor"*).
              1. SameValue(_newTarget_, _patternConstructor_) 가 *true* 이면 _pattern_ 반환.
          1. Else
            1. _newTarget_ = NewTarget.
          1. _pattern_ 이 Object 이고 [[RegExpMatcher]] 내부 슬롯을 가지면
            1. _P_ = _pattern_.[[OriginalSource]].
            1. _flags_ 가 *undefined* 이면 _F_ = _pattern_.[[OriginalFlags]]; 아니면 _F_ = _flags_.
          1. Else if _patternIsRegExp_ = *true* 이면
            1. _P_ = ? Get(_pattern_, *"source"*).
            1. _flags_ 가 *undefined* 이면
              1. _F_ = ? Get(_pattern_, *"flags"*).
            1. Else
              1. _F_ = _flags_.
          1. Else
            1. _P_ = _pattern_.
            1. _F_ = _flags_.
          1. _O_ = ? RegExpAlloc(_newTarget_).
          1. ? RegExpInitialize(_O_, _P_, _F_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>패턴이 |StringLiteral| 로 제공되면, 본 함수가 처리하기 전에 일반적인 이스케이프 시퀀스 치환이 수행된다. 패턴이 이스케이프 시퀀스를 포함해야 인식되는 경우, |StringLiteral| 구성 시 제거되지 않도록 U+005C (REVERSE SOLIDUS) 코드 포인트는 이중 이스케이프되어야 한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>RegExp 생성자의 프로퍼티 (Properties of the RegExp Constructor)</h1>
      <p>RegExp 생성자는 다음을 만족한다:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-regexp.escape">
        <h1>RegExp.escape ( _S_ )</h1>
        <p>이 함수는 정규 표현식 |Pattern| 내에서 특수 의미가 될 수 있는 문자들을 동등한 이스케이프 시퀀스로 치환한 _S_ 의 복사본을 반환한다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>

        <emu-alg>
          1. _S_ 가 String 이 아니면 *TypeError* 예외를 throw.
          1. _escaped_ 를 빈 String 으로 둔다.
          1. _cpList_ = StringToCodePoints(_S_).
          1. _cpList_ 의 각 코드 포인트 _cp_ 에 대해
            1. _escaped_ 가 빈 String 이고 _cp_ 가 |DecimalDigit| 또는 |AsciiLetter| 에 매치되면
              1. NOTE: 선행 숫자를 이스케이프하면 `\0` 이나 `\1` 같은 |DecimalEscape| 뒤에서도 확장으로 해석되지 않고 _S_ 와 매치되도록 보장한다. 선행 ASCII 문자 이스케이프는 `\c` 이후 문맥에 대해 동일한 목적을 가진다.
              1. _numericValue_ = _cp_ 의 수치 값.
              1. _hex_ = Number::toString(𝔽(_numericValue_), 16).
              1. Assert: _hex_ 길이는 2.
              1. _escaped_ = 0x005C (REVERSE SOLIDUS) + *"x"* + _hex_.
            1. Else
              1. _escaped_ = _escaped_ + EncodeForRegExpEscape(_cp_).
          1. _escaped_ 반환.
        </emu-alg>

        <emu-note>
          <p>이름이 비슷하지만 EscapeRegExpPattern 과 `RegExp.escape` 는 다른 일을 한다. 전자는 패턴을 문자열로 표현하기 위해 이스케이프하고, 후자는 문자열을 패턴 안에 표현하기 위해 이스케이프한다.</p>
        </emu-note>

        <emu-clause id="sec-encodeforregexpescape" type="abstract operation">
          <h1>
            EncodeForRegExpEscape (
              _cp_: 코드 포인트,
            ): String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_cp_ 를 매칭하는 |Pattern| 을 나타내는 String 을 반환한다. _cp_ 가 공백 또는 ASCII 구두점이면 이스케이프 시퀀스를 반환하고, 그렇지 않으면 _cp_ 자체의 String 표현을 반환한다.</dd>
          </dl>

          <emu-alg>
            1. _cp_ 가 |SyntaxCharacter| 에 매치되거나 U+002F (SOLIDUS)이면
              1. 0x005C (REVERSE SOLIDUS) 와 UTF16EncodeCodePoint(_cp_) 의 연결을 반환.
            1. Else if _cp_ 가 <emu-xref href="#table-controlescape-code-point-values"></emu-xref> “Code Point” 열에 나온 코드 포인트이면
              1. 0x005C (REVERSE SOLIDUS) 와 해당 행 “ControlEscape” 열의 문자열 연결을 반환.
            1. _otherPunctuators_ = *",-=&lt;>#&amp;!%:;@~'`"* + 코드 유닛 0x0022 (QUOTATION MARK).
            1. _toEscape_ = StringToCodePoints(_otherPunctuators_).
            1. _toEscape_ 가 _cp_ 를 포함하거나, _cp_ 가 |WhiteSpace| 또는 |LineTerminator| 에 매치되거나, _cp_ 가 리드 서러게이트 또는 트레일 서러게이트와 같은 수치 값을 가지면
              1. _cpNum_ = _cp_ 의 수치 값.
              1. _cpNum_ ≤ 0xFF 이면
                1. _hex_ = Number::toString(𝔽(_cpNum_), 16).
                1. 0x005C (REVERSE SOLIDUS) + *"x"* + StringPad(_hex_, 2, *"0"*, ~start~) 반환.
              1. _escaped_ = 빈 String.
              1. _codeUnits_ = UTF16EncodeCodePoint(_cp_).
              1. 각 코드 유닛 _cu_ 에 대해
                1. _escaped_ = _escaped_ + UnicodeEscape(_cu_).
              1. _escaped_ 반환.
            1. UTF16EncodeCodePoint(_cp_) 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype">
        <h1>RegExp.prototype</h1>
        <p>`RegExp.prototype` 의 초기 값은 RegExp 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-regexp-@@species" id="sec-get-regexp-%symbol.species%">
        <h1>get RegExp [ %Symbol.species% ]</h1>
        <p>`RegExp[%Symbol.species%]` 는 set 접근자가 *undefined* 인 접근자 프로퍼티이다. get 접근자는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환한다.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p>RegExp 프로토타입 메서드는 일반적으로 자신의 *this* 값의 생성자를 사용해 파생 객체를 만든다. 그러나 서브클래스 생성자는 %Symbol.species% 재정의를 통해 그 기본 동작을 바꿀 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>RegExp 프로토타입 객체의 프로퍼티 (Properties of the RegExp Prototype Object)</h1>
      <p><dfn>RegExp 프로토타입 객체</dfn>는 다음을 만족한다:</p>
      <ul>
        <li><dfn>%RegExp.prototype%</dfn> 이다.</li>
        <li>일반(ordinary) 객체이다.</li>
        <li>RegExp 인스턴스가 아니며 [[RegExpMatcher]] 내부 슬롯이나 그 밖의 RegExp 인스턴스 내부 슬롯을 가지지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <emu-note>
        <p>RegExp 프로토타입 객체는 자체 *"valueOf"* 프로퍼티를 갖지 않고 Object 프로토타입 객체로부터 상속받는다.</p>
      </emu-note>

      <emu-clause id="sec-regexp.prototype.constructor">
        <h1>RegExp.prototype.constructor</h1>
        <p>`RegExp.prototype.constructor` 의 초기 값은 %RegExp% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.exec">
        <h1>RegExp.prototype.exec ( _string_ )</h1>
        <p>이 메서드는 _string_ 에서 정규 표현식 패턴의 발생을 검색하고 매치 결과를 담은 Array 또는 매치 실패 시 *null* 을 반환한다.</p>
        <p>호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. ? RequireInternalSlot(_R_, [[RegExpMatcher]]) 수행.
          1. _S_ = ? ToString(_string_).
          1. ? RegExpBuiltinExec(_R_, _S_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.dotAll">
        <h1>get RegExp.prototype.dotAll</h1>
        <p>`RegExp.prototype.dotAll` 은 set 접근자가 *undefined* 인 접근자 프로퍼티이며 get 접근자는 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. _cu_ = 코드 유닛 0x0073 (LATIN SMALL LETTER S).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.flags">
        <h1>get RegExp.prototype.flags</h1>
        <p>`RegExp.prototype.flags` 는 set 접근자가 *undefined* 인 접근자 프로퍼티이며 get 접근자는 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. _R_ 이 Object 가 아니면 *TypeError* 예외 throw.
          1. _codeUnits_ = 새 빈 List.
          1. _hasIndices_ = ToBoolean(? Get(_R_, *"hasIndices"*)).
          1. _hasIndices_ 가 *true* 이면 코드 유닛 0x0064 (d) 를 _codeUnits_ 에 추가.
          1. _global_ = ToBoolean(? Get(_R_, *"global"*)).
          1. _global_ 이 *true* 이면 0x0067 (g) 추가.
          1. _ignoreCase_ = ToBoolean(? Get(_R_, *"ignoreCase"*)).
          1. _ignoreCase_ 가 *true* 이면 0x0069 (i) 추가.
          1. _multiline_ = ToBoolean(? Get(_R_, *"multiline"*)).
          1. _multiline_ 이 *true* 이면 0x006D (m) 추가.
          1. _dotAll_ = ToBoolean(? Get(_R_, *"dotAll"*)).
          1. _dotAll_ 이 *true* 이면 0x0073 (s) 추가.
          1. _unicode_ = ToBoolean(? Get(_R_, *"unicode"*)).
          1. _unicode_ 가 *true* 이면 0x0075 (u) 추가.
          1. _unicodeSets_ = ToBoolean(? Get(_R_, *"unicodeSets"*)).
          1. _unicodeSets_ 가 *true* 이면 0x0076 (v) 추가.
          1. _sticky_ = ToBoolean(? Get(_R_, *"sticky"*)).
          1. _sticky_ 가 *true* 이면 0x0079 (y) 추가.
          1. _codeUnits_ 요소들로 이루어진 String 반환. _codeUnits_ 비어 있으면 빈 String 반환.
        </emu-alg>

        <emu-clause id="sec-regexphasflag" type="abstract operation">
          <h1>
            RegExpHasFlag (
              _R_: ECMAScript 언어 값,
              _codeUnit_: 코드 유닛,
            ): Boolean 또는 *undefined* 를 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _R_ 이 Object 가 아니면 *TypeError* 예외.
            1. _R_ 이 [[OriginalFlags]] 내부 슬롯을 갖지 않으면
              1. SameValue(_R_, %RegExp.prototype%) 가 *true* 이면 *undefined* 반환.
              1. 아니면 *TypeError* 예외.
            1. _flags_ = _R_.[[OriginalFlags]].
            1. _flags_ 가 _codeUnit_ 을 포함하면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.global">
        <h1>get RegExp.prototype.global</h1>
        <p>`RegExp.prototype.global` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. _cu_ = 0x0067 (LATIN SMALL LETTER G).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.hasIndices">
        <h1>get RegExp.prototype.hasIndices</h1>
        <p>`RegExp.prototype.hasIndices` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. _cu_ = 0x0064 (LATIN SMALL LETTER D).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.ignorecase">
        <h1>get RegExp.prototype.ignoreCase</h1>
        <p>`RegExp.prototype.ignoreCase` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. _cu_ = 0x0069 (LATIN SMALL LETTER I).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@match" id="sec-regexp.prototype-%symbol.match%">
        <h1>RegExp.prototype [ %Symbol.match% ] ( _string_ )</h1>
        <p>이 메서드는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _rx_ = *this* 값.
          1. _rx_ 가 Object 가 아니면 *TypeError* 예외.
          1. _S_ = ? ToString(_string_).
          1. _flags_ = ? ToString(? Get(_rx_, *"flags"*)).
          1. _flags_ 가 *"g"* 를 포함하지 않으면
            1. ? RegExpExec(_rx_, _S_) 반환.
          1. Else
            1. _flags_ 가 *"u"* 또는 *"v"* 포함하면 _fullUnicode_ = *true*; 아니면 *false*.
            1. ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
            1. _A_ = ! ArrayCreate(0).
            1. _n_ = 0.
            1. 반복:
              1. _result_ = ? RegExpExec(_rx_, _S_).
              1. _result_ 가 *null* 이면
                1. _n_ = 0 이면 *null* 반환.
                1. _A_ 반환.
              1. Else
                1. _matchStr_ = ? ToString(? Get(_result_, *"0"*)).
                1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).
                1. _matchStr_ 가 빈 String 이면
                  1. _thisIndex_ = ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))).
                  1. _nextIndex_ = AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
                1. _n_ = _n_ + 1.
        </emu-alg>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.match]"* 이다.</p>
        <emu-note>
          <p>%Symbol.match% 프로퍼티는 IsRegExp 추상 연산이 객체가 정규 표현식 기본 동작을 가지는지 식별하는 데 사용된다. 해당 프로퍼티가 없거나 Boolean 으로 *true* 로 강제되지 않는 값이면 정규 표현식 객체로 의도되지 않은 것이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-regexp-prototype-matchall" id="sec-regexp-prototype-%symbol.matchall%">
        <h1>RegExp.prototype [ %Symbol.matchAll% ] ( _string_ )</h1>
        <p>이 메서드는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this* 값.
          1. _R_ 이 Object 아니면 *TypeError*.
          1. _S_ = ? ToString(_string_).
          1. _C_ = ? SpeciesConstructor(_R_, %RegExp%).
          1. _flags_ = ? ToString(? Get(_R_, *"flags"*)).
          1. _matcher_ = ? Construct(_C_, « _R_, _flags_ »).
          1. _lastIndex_ = ? ToLength(? Get(_R_, *"lastIndex"*)).
          1. ? Set(_matcher_, *"lastIndex"*, _lastIndex_, *true*).
          1. _flags_ 가 *"g"* 포함하면 _global_ = *true*; 아니면 *false*.
          1. _flags_ 가 *"u"* 또는 *"v"* 포함하면 _fullUnicode_ = *true*; 아니면 *false*.
          1. CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_) 반환.
        </emu-alg>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.matchAll]"* 이다.</p>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.multiline">
        <h1>get RegExp.prototype.multiline</h1>
        <p>`RegExp.prototype.multiline` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this*.
          1. _cu_ = 0x006D (m).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@replace" id="sec-regexp.prototype-%symbol.replace%">
        <h1>RegExp.prototype [ %Symbol.replace% ] ( _string_, _replaceValue_ )</h1>
        <p>이 메서드는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _rx_ = *this*.
          1. _rx_ Object 아니면 *TypeError*.
          1. _S_ = ? ToString(_string_).
          1. _lengthS_ = _S_ 길이.
          1. _functionalReplace_ = IsCallable(_replaceValue_).
          1. _functionalReplace_ = *false* 이면 _replaceValue_ = ? ToString(_replaceValue_).
          1. _flags_ = ? ToString(? Get(_rx_, *"flags"*)).
          1. _flags_ 가 *"g"* 포함하면 _global_ = *true*; 아니면 *false*.
          1. _global_ = *true* 이면 ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
          1. _results_ = 새 빈 List.
          1. _done_ = *false*.
          1. _done_ 이 *false* 인 동안 반복
            1. _result_ = ? RegExpExec(_rx_, _S_).
            1. _result_ = *null* 이면 _done_ = *true*.
            1. Else
              1. _results_ 에 _result_ 추가.
              1. _global_ = *false* 이면 _done_ = *true*.
              1. Else
                1. _matchStr_ = ? ToString(? Get(_result_, *"0"*)).
                1. _matchStr_ 가 빈 String 이면
                  1. _thisIndex_ = ℝ(? ToLength(? Get(_rx_, *"lastIndex"*)) ).
                  1. _flags_ 가 *"u"* 또는 *"v"* 포함하면 _fullUnicode_ = *true*; 아니면 *false*.
                  1. _nextIndex_ = AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
          1. _accumulatedResult_ = 빈 String.
          1. _nextSourcePosition_ = 0.
          1. 각 _result_ ∈ _results_ 에 대해
            1. _resultLength_ = ? LengthOfArrayLike(_result_).
            1. _nCaptures_ = max(_resultLength_ - 1, 0).
            1. _matched_ = ? ToString(? Get(_result_, *"0"*)).
            1. _matchLength_ = _matched_ 길이.
            1. _position_ = ? ToIntegerOrInfinity(? Get(_result_, *"index"*)).
            1. _position_ = 0.._lengthS_ 로 clamp.
            1. _captures_ = 새 빈 List.
            1. _n_ = 1.
            1. _n_ ≤ _nCaptures_ 동안
              1. _capN_ = ? Get(_result_, ! ToString(𝔽(_n_))).
              1. _capN_ ≠ *undefined* 이면 _capN_ = ? ToString(_capN_).
              1. _captures_ 에 _capN_ 추가.
              1. NOTE: _n_ = 1 때 첫 캡처가 인덱스 0에 들어간다.
              1. _n_ = _n_ + 1.
            1. _namedCaptures_ = ? Get(_result_, *"groups"*).
            1. _functionalReplace_ = *true* 이면
              1. _replacerArgs_ = « _matched_ » ⧺ _captures_ ⧺ « 𝔽(_position_), _S_ ».
              1. _namedCaptures_ ≠ *undefined* 이면 _replacerArgs_ 끝에 추가.
              1. _replacementValue_ = ? Call(_replaceValue_, *undefined*, _replacerArgs_).
              1. _replacementString_ = ? ToString(_replacementValue_).
            1. Else
              1. _namedCaptures_ ≠ *undefined* 이면 _namedCaptures_ = ? ToObject(_namedCaptures_).
              1. _replacementString_ = ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).
            1. _position_ ≥ _nextSourcePosition_ 이면
              1. NOTE: _position_ 이 뒤로 가면 비정상 서브클래스 동작일 수 있으며 그 치환은 무시.
              1. _accumulatedResult_ = _accumulatedResult_ + _S_ 의 [_nextSourcePosition_, _position_) + _replacementString_.
              1. _nextSourcePosition_ = _position_ + _matchLength_.
          1. _nextSourcePosition_ ≥ _lengthS_ 이면 _accumulatedResult_ 반환.
          1. _accumulatedResult_ + _S_ 의 [_nextSourcePosition_, 끝) 반환.
        </emu-alg>
        <p>이 메서드의 *"name"* 값은 *"[Symbol.replace]"* 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@search" id="sec-regexp.prototype-%symbol.search%">
        <h1>RegExp.prototype [ %Symbol.search% ] ( _string_ )</h1>
        <p>호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _rx_ = *this*.
          1. _rx_ Object 아니면 *TypeError*.
          1. _S_ = ? ToString(_string_).
          1. _previousLastIndex_ = ? Get(_rx_, *"lastIndex"*).
          1. _previousLastIndex_ ≠ *+0*<sub>𝔽</sub> 이면 ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
          1. _result_ = ? RegExpExec(_rx_, _S_).
          1. _currentLastIndex_ = ? Get(_rx_, *"lastIndex"*).
          1. SameValue(_currentLastIndex_, _previousLastIndex_) = *false* 이면 ? Set(_rx_, *"lastIndex"*, _previousLastIndex_, *true*).
          1. _result_ = *null* 이면 *-1*<sub>𝔽</sub> 반환.
          1. ? Get(_result_, *"index"*) 반환.
        </emu-alg>
        <p>이 메서드의 *"name"* 값은 *"[Symbol.search]"* 이다.</p>
        <emu-note>
          <p>검색 수행 시 이 RegExp 객체의 *"lastIndex"* 및 *"global"* 프로퍼티는 무시되며 *"lastIndex"* 는 변경되지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.source">
        <h1>get RegExp.prototype.source</h1>
        <p>`RegExp.prototype.source` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this*.
          1. _R_ Object 아니면 *TypeError*.
          1. _R_ 가 [[OriginalSource]] 슬롯 없으면
            1. SameValue(_R_, %RegExp.prototype%) *true* 이면 *"(?:)"* 반환.
            1. 아니면 *TypeError*.
          1. Assert: _R_ 는 [[OriginalFlags]] 슬롯을 가진다.
          1. _src_ = _R_.[[OriginalSource]].
          1. _flags_ = _R_.[[OriginalFlags]].
          1. EscapeRegExpPattern(_src_, _flags_) 반환.
        </emu-alg>

        <emu-clause id="sec-escaperegexppattern" type="abstract operation">
          <h1>
            EscapeRegExpPattern (
              _P_: String,
              _F_: String,
            ): String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _F_ 가 *"v"* 포함하면 _patternSymbol_ = |Pattern[+UnicodeMode, +UnicodeSetsMode]|.
            1. Else if _F_ 가 *"u"* 포함하면 _patternSymbol_ = |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.
            1. Else _patternSymbol_ = |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.
            1. _S_ 를: _P_ 를 UTF-16 인코딩된 코드 포인트로 해석(<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>)한 것과 동등한 _patternSymbol_ 형태의 String 으로 하고, 아래에서 기술한 특정 코드 포인트를 이스케이프한 값으로 둔다. _S_ 는 _P_ 와 다를 수도 동일할 수도 있다. _S_ 를 _patternSymbol_ 로 평가해 얻는 추상 클로저는 객체의 [[RegExpMatcher]] 가 주는 추상 클로저와 동일하게 동작해야 한다. 동일한 _P_, _F_ 로 여러 번 호출 시 결과는 동일해야 한다.
            1. 패턴에 나타나는 `/` 또는 |LineTerminator| 는 *"/"*, _S_, *"/"*, _F_ 의 연결이 동등한 동작의 |RegularExpressionLiteral| 로 파싱 가능하도록 필요 시 이스케이프해야 한다. 예: _P_ = *"/"* 이면 _S_ 는 *"\\/"* 또는 *"\\u002F"* 등 가능하나 *"/"* 는 불가 ( `///`+_F_ 는 |SingleLineComment| 로 파싱 ). _P_ 가 빈 String 이면 _S_ = *"(?:)"* 로 충족할 수 있다.
            1. _S_ 반환.
          </emu-alg>

          <emu-note>
            <p>`RegExp.escape` 와 EscapeRegExpPattern 은 목적이 다르다. 전자는 문자열을 패턴 내부 표현용으로, 후자는 패턴을 문자열 표현용으로 이스케이프한다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@split" id="sec-regexp.prototype-%symbol.split%">
        <h1>RegExp.prototype [ %Symbol.split% ] ( _string_, _limit_ )</h1>
        <emu-note>
          <p>이 메서드는 _string_ 을 String 으로 변환한 결과를 왼쪽에서 오른쪽으로 정규 표현식 매치 경계를 찾아 나눈 부분 문자열들을 Array 에 저장해 반환한다. 매치된 부분들은 반환 배열에 포함되지 않고 구분자로만 사용된다.</p>
          <p>*this* 값이 빈 정규식이거나 빈 String 과 매치 가능한 정규식일 수 있다. 이 경우 입력 String 시작·끝 혹은 이전 구분자 매치 끝의 빈 <emu-not-ref>substring</emu-not-ref> 과는 매치하지 않는다. (예: 패턴이 빈 String 과 매치하면 문자열은 개별 코드 유닛 요소로 분해되어 결과 배열 길이는 문자열 길이와 같고 각 <emu-not-ref>substring</emu-not-ref> 은 한 코드 유닛을 가진다.) 특정 인덱스에서 백트래킹으로 비어 있지 않은 매치가 가능하더라도 첫 번째 매치만 고려한다. (예: `/a*?/[Symbol.split]("ab")` → `["a", "b"]`, `/a*/[Symbol.split]("ab")` → `["","b"]`)</p>
          <p>_string_ 이 빈 String (또는 변환 결과가 빈 String)이면 정규식이 빈 String 과 매치 가능한지 여부에 따라 결과가 달라진다. 가능하면 결과 배열은 비어 있고, 불가능하면 결과 배열은 빈 String 하나를 가진다.</p>
          <p>정규식이 캡처 괄호를 포함하면 _separator_ 매치 때마다 ( *undefined* 포함 ) 각 캡처 결과가 출력 배열에 삽입된다. 예:</p>
          <pre><code class="javascript">/&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split]("A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;")</code></pre>
          <p>결과:</p>
          <pre><code class="javascript">["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]</code></pre>
          <p>_limit_ 이 *undefined* 가 아니면 결과 배열은 최대 _limit_ 요소로 잘린다.</p>
        </emu-note>
        <p>호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _rx_ = *this*.
          1. _rx_ Object 아니면 *TypeError*.
          1. _S_ = ? ToString(_string_).
          1. _C_ = ? SpeciesConstructor(_rx_, %RegExp%).
          1. _flags_ = ? ToString(? Get(_rx_, *"flags"*)).
          1. _flags_ 가 *"u"* 또는 *"v"* 포함하면 _unicodeMatching_ = *true*; 아니면 *false*.
          1. _flags_ 가 *"y"* 포함하면 _newFlags_ = _flags_; 아니면 _newFlags_ = _flags_ + *"y"*.
          1. _splitter_ = ? Construct(_C_, « _rx_, _newFlags_ »).
          1. _A_ = ! ArrayCreate(0).
          1. _lengthA_ = 0.
          1. _limit_ = *undefined* 이면 _lim_ = 2<sup>32</sup> - 1; 아니면 _lim_ = ℝ(? ToUint32(_limit_)).
          1. _lim_ = 0 이면 _A_ 반환.
          1. _S_ 가 빈 String 이면
            1. _z_ = ? RegExpExec(_splitter_, _S_).
            1. _z_ ≠ *null* 이면 _A_ 반환.
            1. ! CreateDataPropertyOrThrow(_A_, *"0"*, _S_).
            1. _A_ 반환.
          1. _size_ = _S_ 길이.
          1. _p_ = 0.
          1. _q_ = _p_.
          1. _q_ &lt; _size_ 동안 반복
            1. ? Set(_splitter_, *"lastIndex"*, 𝔽(_q_), *true*).
            1. _z_ = ? RegExpExec(_splitter_, _S_).
            1. _z_ = *null* 이면
              1. _q_ = AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
            1. Else
              1. _e_ = ℝ(? ToLength(? Get(_splitter_, *"lastIndex"*)) ).
              1. _e_ = min(_e_, _size_).
              1. _e_ = _p_ 이면
                1. _q_ = AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
              1. Else
                1. _T_ = _S_ 의 [_p_, _q_) 부분 문자열.
                1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).
                1. _lengthA_ = _lengthA_ + 1.
                1. _lengthA_ = _lim_ 이면 _A_ 반환.
                1. _p_ = _e_.
                1. _numberOfCaptures_ = ? LengthOfArrayLike(_z_).
                1. _numberOfCaptures_ = max(_numberOfCaptures_ - 1, 0).
                1. _i_ = 1.
                1. _i_ ≤ _numberOfCaptures_ 동안
                  1. _nextCapture_ = ? Get(_z_, ! ToString(𝔽(_i_))).
                  1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).
                  1. _i_ = _i_ + 1.
                  1. _lengthA_ = _lengthA_ + 1.
                  1. _lengthA_ = _lim_ 이면 _A_ 반환.
                1. _q_ = _p_.
          1. _T_ = _S_ 의 [_p_, _size_) 부분 문자열.
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).
          1. _A_ 반환.
        </emu-alg>
        <p>이 메서드의 *"name"* 값은 *"[Symbol.split]"* 이다.</p>
        <emu-note>
          <p>이 메서드는 이 RegExp 객체의 *"global"*, *"sticky"* 프로퍼티 값을 무시한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.sticky">
        <h1>get RegExp.prototype.sticky</h1>
        <p>`RegExp.prototype.sticky` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this*.
          1. _cu_ = 0x0079 (y).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.test">
        <h1>RegExp.prototype.test ( _S_ )</h1>
        <p>호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this*.
          1. _R_ Object 아니면 *TypeError*.
          1. _string_ = ? ToString(_S_).
          1. _match_ = ? RegExpExec(_R_, _string_).
          1. _match_ ≠ *null* 이면 *true* 반환; 아니면 *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.tostring">
        <h1>RegExp.prototype.toString ( )</h1>
        <emu-alg>
          1. _R_ = *this*.
          1. _R_ Object 아니면 *TypeError*.
          1. _pattern_ = ? ToString(? Get(_R_, *"source"*)).
            1. _flags_ = ? ToString(? Get(_R_, *"flags"*)).
          1. _result_ = *"/"* + _pattern_ + *"/"* + _flags_.
          1. _result_ 반환.
        </emu-alg>
        <emu-note>
          <p>반환된 String 은 동일한 동작을 하는 또 다른 RegExp 객체로 평가되는 |RegularExpressionLiteral| 형태이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicode">
        <h1>get RegExp.prototype.unicode</h1>
        <p>`RegExp.prototype.unicode` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this*.
          1. _cu_ = 0x0075 (u).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicodesets">
        <h1>get RegExp.prototype.unicodeSets</h1>
        <p>`RegExp.prototype.unicodeSets` 접근자 get 은 다음을 수행한다:</p>
        <emu-alg>
          1. _R_ = *this*.
          1. _cu_ = 0x0076 (v).
          1. ? RegExpHasFlag(_R_, _cu_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-matching">
      <h1>RegExp 매칭용 추상 연산 (Abstract Operations for RegExp Matching)</h1>

      <emu-clause id="sec-regexpexec" type="abstract operation">
        <h1>
          RegExpExec (
            _R_: Object,
            _S_: String,
          ): Object 또는 *null* 을 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _exec_ = ? Get(_R_, *"exec"*).
          1. IsCallable(_exec_) = *true* 이면
            1. _result_ = ? Call(_exec_, _R_, « _S_ »).
            1. _result_ 가 Object 도 *null* 도 아니면 *TypeError*.
            1. _result_ 반환.
          1. ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. ? RegExpBuiltinExec(_R_, _S_) 반환.
        </emu-alg>
        <emu-note>
          <p>호출 가능한 *"exec"* 프로퍼티가 없으면 내장 매칭 알고리즘을 사용한다. 이는 이전 버전과의 호환을 위해, 당시 대부분의 내장 알고리즘이 *"exec"* 의 동적 조회를 수행하지 않았던 동작을 유지한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-regexpbuiltinexec" type="abstract operation">
        <h1>
          RegExpBuiltinExec (
            _R_: 초기화된 RegExp 인스턴스,
            _S_: String,
          ): Array exotic object 또는 *null* 을 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _length_ = _S_ 길이.
          1. _lastIndex_ = ℝ(? ToLength(! Get(_R_, *"lastIndex"*))).
          1. _flags_ = _R_.[[OriginalFlags]].
          1. _flags_ 가 *"g"* 포함하면 _global_ = *true*; 아니면 *false*.
          1. _flags_ 가 *"y"* 포함하면 _sticky_ = *true*; 아니면 *false*.
          1. _flags_ 가 *"d"* 포함하면 _hasIndices_ = *true*; 아니면 *false*.
          1. _global_ = *false* 이고 _sticky_ = *false* 이면 _lastIndex_ = 0.
          1. _matcher_ = _R_.[[RegExpMatcher]].
          1. _flags_ 가 *"u"* 또는 *"v"* 포함하면 _fullUnicode_ = *true*; 아니면 *false*.
          1. _matchSucceeded_ = *false*.
          1. _fullUnicode_ = *true* 이면 _input_ = StringToCodePoints(_S_); 아니면 _input_ = _S_ 코드 유닛 List.
          1. NOTE: _input_ 의 각 요소는 문자로 간주.
          1. _matchSucceeded_ = *false* 동안 반복
            1. _lastIndex_ > _length_ 이면
              1. _global_ 또는 _sticky_ 가 *true* 이면
                1. ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
              1. *null* 반환.
            1. _inputIndex_ = _S_ 의 _lastIndex_ 위치에서 얻은 문자의 _input_ 내 인덱스.
            1. _r_ = _matcher_(_input_, _inputIndex_).
            1. _r_ = ~failure~ 이면
              1. _sticky_ = *true* 이면
                1. ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
                1. *null* 반환.
              1. _lastIndex_ = AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).
            1. Else
              1. Assert: _r_ 는 MatchState.
              1. _matchSucceeded_ = *true*.
          1. _e_ = _r_.[[EndIndex]].
          1. _fullUnicode_ = *true* 이면 _e_ = GetStringIndex(_S_, _e_).
          1. _global_ 또는 _sticky_ = *true* 이면
            1. ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, 𝔽(_e_), *true*)</emu-meta>.
          1. _n_ = _r_.[[Captures]] 요소 수.
          1. Assert: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]].
          1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
          1. _A_ = ! ArrayCreate(_n_ + 1).
          1. Assert: _A_.*"length"* = _n_ + 1.
          1. ! CreateDataPropertyOrThrow(_A_, *"index"*, 𝔽(_lastIndex_)).
          1. ! CreateDataPropertyOrThrow(_A_, *"input"*, _S_).
          1. _match_ = Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }.
          1. _indices_ = 새 빈 List.
          1. _groupNames_ = 새 빈 List.
          1. _indices_ 에 _match_ 추가.
          1. _matchedSubstr_ = GetMatchString(_S_, _match_).
          1. ! CreateDataPropertyOrThrow(_A_, *"0"*, _matchedSubstr_).
          1. _R_ 가 |GroupName| 을 하나라도 포함하면
            1. _groups_ = OrdinaryObjectCreate(*null*).
            1. _hasGroups_ = *true*.
          1. Else
            1. _groups_ = *undefined*.
            1. _hasGroups_ = *false*.
          1. ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_).
          1. _matchedGroupNames_ = 새 빈 List.
          1. 1 ≤ _i_ ≤ _n_ 에 대해 상승 순서 반복
            1. _captureI_ = _r_.[[Captures]] 의 _i_ 번째 요소.
            1. _captureI_ = *undefined* 이면
              1. _capturedValue_ = *undefined*.
              1. _indices_ 에 *undefined* 추가.
            1. Else
              1. _captureStart_ = _captureI_.[[StartIndex]].
              1. _captureEnd_ = _captureI_.[[EndIndex]].
              1. _fullUnicode_ = *true* 이면
                1. _captureStart_ = GetStringIndex(_S_, _captureStart_).
                1. _captureEnd_ = GetStringIndex(_S_, _captureEnd_).
              1. _capture_ = Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }.
              1. _capturedValue_ = GetMatchString(_S_, _capture_).
              1. _indices_ 에 _capture_ 추가.
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).
            1. _i_ 번째 캡처가 |GroupName| 으로 정의된 경우
              1. _s_ = 그 |GroupName| 의 CapturingGroupName.
              1. _matchedGroupNames_ 가 _s_ 포함하면
                1. Assert: _capturedValue_ 는 *undefined*.
                1. _groupNames_ 에 *undefined* 추가.
              1. Else
                1. _capturedValue_ ≠ *undefined* 이면 _matchedGroupNames_ 에 _s_ 추가.
                1. ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).
                1. _groupNames_ 에 _s_ 추가.
            1. Else
              1. _groupNames_ 에 *undefined* 추가.
          1. _hasIndices_ = *true* 이면
            1. _indicesArray_ = MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_).
            1. ! CreateDataPropertyOrThrow(_A_, *"indices"*, _indicesArray_).
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-advancestringindex" type="abstract operation">
        <h1>
          AdvanceStringIndex (
            _S_: String,
            _index_: 음이 아닌 정수,
            _unicode_: Boolean,
          ): 정수
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _index_ ≤ 2<sup>53</sup> - 1.
          1. _unicode_ = *false* 이면 _index_ + 1 반환.
          1. _length_ = _S_ 길이.
          1. _index_ + 1 ≥ _length_ 이면 _index_ + 1 반환.
          1. _cp_ = CodePointAt(_S_, _index_).
          1. _index_ + _cp_.[[CodeUnitCount]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getstringindex" type="abstract operation">
        <h1>
          GetStringIndex (
            _S_: String,
            _codePointIndex_: 음이 아닌 정수,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_S_ 를 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하고 _codePointIndex_ 번째 코드 포인트에 대응하는 코드 유닛 인덱스를 반환한다. 존재하지 않으면 _S_ 길이를 반환한다.</dd>
        </dl>
        <emu-alg>
          1. _S_ 가 빈 String 이면 0 반환.
          1. _len_ = _S_ 길이.
          1. _codeUnitCount_ = 0.
          1. _codePointCount_ = 0.
          1. _codeUnitCount_ &lt; _len_ 동안
            1. _codePointCount_ = _codePointIndex_ 이면 _codeUnitCount_ 반환.
            1. _cp_ = CodePointAt(_S_, _codeUnitCount_).
            1. _codeUnitCount_ += _cp_.[[CodeUnitCount]].
            1. _codePointCount_ += 1.
          1. _len_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-match-records">
        <h1>매치 레코드 (Match Records)</h1>
        <p><dfn variants="Match Records">Match Record</dfn> 는 정규 표현식 매치 또는 캡처의 시작·끝 인덱스를 캡슐화하는 Record 값이다.</p>
        <p>Match Record 는 <emu-xref href="#table-match-record"></emu-xref> 의 필드를 가진다.</p>
        <emu-table id="table-match-record" caption="Match Record 필드">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[StartIndex]]</td>
              <td>음이 아닌 정수</td>
              <td>문자열 시작으로부터 (포함) 매치가 시작되는 코드 유닛 수.</td>
            </tr>
            <tr>
              <td>[[EndIndex]]</td>
              <td>[[StartIndex]] 이상 정수</td>
              <td>문자열 시작으로부터 (배타) 매치가 끝나는 코드 유닛 수.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getmatchstring" type="abstract operation">
        <h1>
          GetMatchString (
            _S_: String,
            _match_: Match Record,
          ): String
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ _S_ 길이.
          1. _S_ 의 [_match_.[[StartIndex]], _match_.[[EndIndex]]) 부분 문자열 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmatchindexpair" type="abstract operation">
        <h1>
          GetMatchIndexPair (
            _S_: String,
            _match_: Match Record,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ _S_ 길이.
          1. CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) ») 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makematchindicesindexpairarray" type="abstract operation">
        <h1>
          MakeMatchIndicesIndexPairArray (
            _S_: String,
            _indices_: Match Record 또는 *undefined* 의 List,
            _groupNames_: String 또는 *undefined* 의 List,
            _hasGroups_: Boolean,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _n_ = _indices_ 요소 수.
          1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
          1. Assert: _groupNames_ 는 _n_ - 1 요소.
          1. NOTE: _groupNames_ 는 _indices_[1] 부터 정렬 대응.
          1. _A_ = ! ArrayCreate(_n_).
          1. _hasGroups_ = *true* 이면 _groups_ = OrdinaryObjectCreate(*null*); 아니면 *undefined*.
          1. ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_).
          1. 0 ≤ _i_ &lt; _n_ 에 대해 상승 순서 반복
            1. _matchIndices_ = _indices_[_i_].
            1. _matchIndices_ ≠ *undefined* 이면 _matchIndexPair_ = GetMatchIndexPair(_S_, _matchIndices_); 아니면 *undefined*.
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_).
            1. _i_ > 0 이면
              1. _s_ = _groupNames_[_i_ - 1].
              1. _s_ ≠ *undefined* 이면
                1. Assert: _groups_ ≠ *undefined*.
                1. ! CreateDataPropertyOrThrow(_groups_, _s_, _matchIndexPair_).
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-regexp-instances">
      <h1>RegExp 인스턴스의 프로퍼티 (Properties of RegExp Instances)</h1>
      <p>RegExp 인스턴스는 RegExp 프로토타입으로부터 프로퍼티를 상속하는 일반 객체다. [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] 내부 슬롯을 가지며 [[RegExpMatcher]] 값은 해당 RegExp 객체 |Pattern| 의 추상 클로저 표현이다.</p>
      <emu-note>
        <p>ECMAScript 2015 이전에는 RegExp 인스턴스가 자체 데이터 프로퍼티 *"source"*, *"global"*, *"ignoreCase"*, *"multiline"* 를 가진다고 명세되었으나, 이제 `RegExp.prototype` 의 접근자 프로퍼티로 정의된다.</p>
      </emu-note>
      <p>RegExp 인스턴스는 다음 프로퍼티도 가진다:</p>

      <emu-clause id="sec-lastindex">
        <h1>lastIndex</h1>
        <p>*"lastIndex"* 프로퍼티 값은 다음 매치를 시작할 String 인덱스를 지정한다. 사용 시 정수 Number 로 강제된다( <emu-xref href="#sec-regexpbuiltinexec"></emu-xref> 참조 ). 이 프로퍼티 특성은 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-string-iterator-objects">
      <h1>RegExp 문자열 이터레이터 객체 (RegExp String Iterator Objects)</h1>
      <p><dfn variants="RegExp String Iterators,RegExp String Iterator object,RegExp String Iterator objects">RegExp String Iterator</dfn> 는 특정 RegExp 인스턴스 객체를 사용하여 특정 String 인스턴스 객체 위를 순회(iteration)하는 과정을 표현하는 객체이다. RegExp String Iterator 객체에 대한 이름 있는 생성자는 없으며, 대신 RegExp 인스턴스 객체의 특정 메서드를 호출할 때 생성된다.</p>

      <emu-clause id="sec-createregexpstringiterator" type="abstract operation">
        <h1>
          CreateRegExpStringIterator (
            _R_: Object,
            _S_: String,
            _global_: Boolean,
            _fullUnicode_: Boolean,
          ): Object
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _iterator_ 를 OrdinaryObjectCreate(%RegExpStringIteratorPrototype%, « [[IteratingRegExp]], [[IteratedString]], [[Global]], [[Unicode]], [[Done]] ») 로 둔다.
          1. _iterator_.[[IteratingRegExp]] = _R_.
          1. _iterator_.[[IteratedString]] = _S_.
          1. _iterator_.[[Global]] = _global_.
          1. _iterator_.[[Unicode]] = _fullUnicode_.
          1. _iterator_.[[Done]] = *false*.
          1. _iterator_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%regexpstringiteratorprototype%-object">
        <h1>%RegExpStringIteratorPrototype% 객체 (The %RegExpStringIteratorPrototype% Object)</h1>
        <p><dfn>%RegExpStringIteratorPrototype%</dfn> 객체는 다음을 만족한다:</p>
        <ul>
          <li>모든 RegExp String Iterator 객체들이 상속하는 프로퍼티들을 가진다.</li>
          <li>일반(ordinary) 객체이다.</li>
          <li>값이 %Iterator.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%regexpstringiteratorprototype%.next">
          <h1>%RegExpStringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 throw 한다.
            1. _O_ 가 RegExp String Iterator Object Instance 의 모든 내부 슬롯( <emu-xref href="#sec-properties-of-regexp-string-iterator-instances"></emu-xref> 참조 )을 갖지 않으면 *TypeError* 예외를 throw 한다.
            1. _O_.[[Done]] 가 *true* 이면
              1. CreateIteratorResultObject(*undefined*, *true*) 를 반환한다.
            1. _R_ = _O_.[[IteratingRegExp]].
            1. _S_ = _O_.[[IteratedString]].
            1. _global_ = _O_.[[Global]].
            1. _fullUnicode_ = _O_.[[Unicode]].
            1. _match_ = ? RegExpExec(_R_, _S_).
            1. _match_ 가 *null* 이면
              1. _O_.[[Done]] = *true* 로 설정한다.
              1. CreateIteratorResultObject(*undefined*, *true*) 를 반환한다.
            1. _global_ 이 *false* 이면
              1. _O_.[[Done]] = *true* 로 설정한다.
              1. CreateIteratorResultObject(_match_, *false*) 를 반환한다.
            1. _matchStr_ = ? ToString(? Get(_match_, *"0"*)).
            1. _matchStr_ 가 빈 String 이면
              1. _thisIndex_ = ℝ(? ToLength(? Get(_R_, *"lastIndex"*))).
              1. _nextIndex_ = AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
              1. ? Set(_R_, *"lastIndex"*, 𝔽(_nextIndex_), *true*) 를 수행한다.
            1. CreateIteratorResultObject(_match_, *false*) 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%regexpstringiteratorprototype%-@@tostringtag" id="sec-%regexpstringiteratorprototype%-%symbol.tostringtag%">
          <h1>%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 String 값 *"RegExp String Iterator"* 이다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-regexp-string-iterator-instances">
        <h1>RegExp 문자열 이터레이터 인스턴스의 프로퍼티 (Properties of RegExp String Iterator Instances)</h1>
        <p>RegExp String Iterator 인스턴스는 %RegExpStringIteratorPrototype% 본질(intrinsic) 객체로부터 프로퍼티를 상속하는 일반 객체이다. 이러한 인스턴스는 <emu-xref href="#table-regexp-string-iterator-instance-slots"></emu-xref> 에 열거된 내부 슬롯들과 함께 초기 생성된다.</p>
        <emu-table id="table-regexp-string-iterator-instance-slots" caption="RegExp String Iterator 인스턴스의 내부 슬롯 (Internal Slots of RegExp String Iterator Instances)">
          <table>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>[[IteratingRegExp]]</td>
              <td>an Object</td>
              <td>순회에 사용되는 정규 표현식. IsRegExp([[IteratingRegExp]]) 는 초기에는 *true* 이다.</td>
            </tr>
            <tr>
              <td>[[IteratedString]]</td>
              <td>a String</td>
              <td>순회 대상이 되는 String 값.</td>
            </tr>
            <tr>
              <td>[[Global]]</td>
              <td>a Boolean</td>
              <td>[[IteratingRegExp]] 가 global 인지 여부.</td>
            </tr>
            <tr>
              <td>[[Unicode]]</td>
              <td>a Boolean</td>
              <td>[[IteratingRegExp]] 가 Unicode 모드인지 여부.</td>
            </tr>
            <tr>
              <td>[[Done]]</td>
              <td>a Boolean</td>
              <td>순회가 완료되었는지 여부.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>인덱스드 컬렉션 (Indexed Collections)</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array 객체 (Array Objects)</h1>
    <p>Array 는 특정 클래스의 프로퍼티 이름에 특별한 처리를 부여하는 이그조틱(exotic) 객체이다. 이러한 특별 처리에 대한 정의는 <emu-xref href="#sec-array-exotic-objects"></emu-xref> 를 참고.</p>

    <emu-clause id="sec-array-constructor">
      <h1>Array 생성자 (The Array Constructor)</h1>
      <p>Array 생성자:</p>
      <ul>
        <li><dfn>%Array%</dfn> 이다.</li>
        <li>전역 객체의 *"Array"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새 Array 를 생성하고 초기화한다.</li>
        <li>생성자가 아니라 함수로 호출될 때도 새 Array 를 생성하고 초기화한다. 따라서 함수 호출 `Array(…)` 는 동일한 인자를 갖는 객체 생성 식 `new Array(…)` 와 동등하다.</li>
        <li>인자 개수와 타입에 따라 동작이 달라지는 함수이다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 이그조틱 Array 동작을 상속하려는 서브클래스 생성자는 Array 이그조틱 객체인 서브클래스 인스턴스를 초기화하기 위해 Array 생성자에 대한 `super` 호출을 포함해야 한다. 그러나 대부분의 `Array.prototype` 메서드는 *this* 값이 Array 이그조틱 객체일 필요가 없는 제네릭 메서드이다.</li>
      </ul>

      <emu-clause id="sec-array" oldids="sec-array-constructor-array,sec-array-len,sec-array-items">
        <h1>Array ( ..._values_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 _newTarget_ 을 활성 함수 객체로; 아니면 _newTarget_ = NewTarget.
          1. _proto_ 를 ? GetPrototypeFromConstructor(_newTarget_, *"%Array.prototype%"*) 로 둔다.
          1. _numberOfArgs_ 를 _values_ 의 요소 개수로 둔다.
          1. _numberOfArgs_ = 0 이면
            1. ! ArrayCreate(0, _proto_) 를 반환.
          1. Else if _numberOfArgs_ = 1 이면
            1. _len_ = _values_[0].
            1. _array_ = ! ArrayCreate(0, _proto_).
            1. _len_ 이 Number 가 아니면
              1. ! CreateDataPropertyOrThrow(_array_, *"0"*, _len_) 수행.
              1. _intLen_ = *1*<sub>𝔽</sub>.
            1. Else,
              1. _intLen_ = ! ToUint32(_len_).
              1. SameValueZero(_intLen_, _len_) 이 *false* 이면 *RangeError* 예외.
            1. ! Set(_array_, *"length"*, _intLen_, *true*) 수행.
            1. _array_ 반환.
          1. Else,
            1. Assert: _numberOfArgs_ ≥ 2.
            1. _array_ = ? ArrayCreate(_numberOfArgs_, _proto_).
            1. _k_ = 0.
            1. _k_ &lt; _numberOfArgs_ 인 동안 반복
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _itemK_ = _values_[_k_].
              1. ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_) 수행.
              1. _k_ = _k_ + 1.
            1. Assert: _array_ 의 *"length"* 프로퍼티의 수학적 값은 _numberOfArgs_.
            1. _array_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Array 생성자의 프로퍼티 (Properties of the Array Constructor)</h1>
      <p>Array 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>값이 *1*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-array.from">
        <h1>Array.from ( _items_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _mapper_ 가 *undefined* 이면
            1. _mapping_ = *false*.
          1. Else,
            1. IsCallable(_mapper_) 가 *false* 이면 *TypeError* 예외.
            1. _mapping_ = *true*.
          1. _usingIterator_ = ? GetMethod(_items_, %Symbol.iterator%).
          1. _usingIterator_ 가 *undefined* 가 아니면
            1. IsConstructor(_C_) 가 *true* 이면
              1. _A_ = ? Construct(_C_).
            1. Else,
              1. _A_ = ! ArrayCreate(0).
            1. _iteratorRecord_ = ? GetIteratorFromMethod(_items_, _usingIterator_).
            1. _k_ = 0.
            1. 반복:
              1. _k_ ≥ 2<sup>53</sup> - 1 이면
                1. _error_ = ThrowCompletion(새 *TypeError* 객체).
                1. Return ? IteratorClose(_iteratorRecord_, _error_).
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _next_ = ? IteratorStepValue(_iteratorRecord_).
              1. _next_ 가 ~done~ 이면
                1. ? Set(_A_, *"length"*, 𝔽(_k_), *true*) 수행.
                1. _A_ 반환.
              1. _mapping_ = *true* 이면
                1. _mappedValue_ = Completion(Call(_mapper_, _thisArg_, « _next_, 𝔽(_k_) »)).
                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_).
              1. Else,
                1. _mappedValue_ = _next_.
              1. _defineStatus_ = Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)).
              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_).
              1. _k_ = _k_ + 1.
          1. NOTE: _items_ 는 이터러블이 아니므로 array-like 객체로 가정.
          1. _arrayLike_ = ! ToObject(_items_).
          1. _len_ = ? LengthOfArrayLike(_arrayLike_).
          1. IsConstructor(_C_) 가 *true* 이면
            1. _A_ = ? Construct(_C_, « 𝔽(_len_) »).
          1. Else,
            1. _A_ = ? ArrayCreate(_len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ? Get(_arrayLike_, _Pk_).
            1. _mapping_ = *true* 이면
              1. _mappedValue_ = ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
            1. Else,
              1. _mappedValue_ = _kValue_.
            1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_) 수행.
            1. _k_ = _k_ + 1.
          1. ? Set(_A_, *"length"*, 𝔽(_len_), *true*) 수행.
          1. _A_ 반환.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭한 팩토리 메서드이며 *this* 값이 Array 생성자일 필요가 없다. 따라서 단일 숫자 인자를 취할 수 있는 다른 생성자들로 이전되거나 상속될 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.isarray">
        <h1>Array.isArray ( _arg_ )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? IsArray(_arg_) 를 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.of">
        <h1>Array.of ( ..._items_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _len_ = _items_ 의 요소 개수.
          1. _lenNumber_ = 𝔽(_len_).
          1. _C_ = *this* 값.
          1. IsConstructor(_C_) *true* 이면
            1. _A_ = ? Construct(_C_, « _lenNumber_ »).
          1. Else,
            1. _A_ = ? ArrayCreate(_len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _kValue_ = _items_[_k_].
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_) 수행.
            1. _k_ = _k_ + 1.
          1. ? Set(_A_, *"length"*, _lenNumber_, *true*) 수행.
          1. _A_ 반환.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭한 팩토리 메서드이며 *this* 값이 Array 생성자일 필요가 없다. 그러므로 단일 숫자 인자를 받을 수 있는 다른 생성자들에게 이전되거나 상속될 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype">
        <h1>Array.prototype</h1>
        <p>`Array.prototype` 의 값은 Array 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-array-@@species" id="sec-get-array-%symbol.species%">
        <h1>get Array [ %Symbol.species% ]</h1>
        <p>`Array[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환한다.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p>Array 프로토타입 메서드는 일반적으로 *this* 값의 생성자를 사용해 파생 객체를 생성한다. 그러나 서브클래스 생성자는 %Symbol.species% 프로퍼티 재정의를 통해 기본 동작을 재정의할 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-prototype-object">
      <h1>Array 프로토타입 객체의 프로퍼티 (Properties of the Array Prototype Object)</h1>
      <p><dfn>Array 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%Array.prototype%</dfn> 이다.</li>
        <li>Array 이그조틱 객체이며 그에 지정된 내부 메서드를 가진다.</li>
        <li>초기 값이 *+0*<sub>𝔽</sub> 이고 특성이 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 인 *"length"* 프로퍼티를 가진다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <emu-note>
        <p>Array 프로토타입 객체는 ECMAScript 2015 이전에 작성된 코드와의 호환성을 보장하기 위해 Array 이그조틱 객체로 명세된다.</p>
      </emu-note>

      <emu-clause id="sec-array.prototype.at">
        <h1>Array.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_).
          1. _relativeIndex_ ≥ 0 이면
            1. _k_ = _relativeIndex_.
          1. Else,
            1. _k_ = _len_ + _relativeIndex_.
          1. _k_ &lt; 0 또는 _k_ ≥ _len_ 이면 *undefined* 반환.
          1. ? Get(_O_, ! ToString(𝔽(_k_))) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.concat">
        <h1>Array.prototype.concat ( ..._items_ )</h1>
        <p>이 메서드는 객체의 배열 요소 뒤에 각 인자의 배열 요소들을 이어붙인 배열을 반환한다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _A_ = ? ArraySpeciesCreate(_O_, 0).
          1. _n_ = 0.
          1. _items_ 앞에 _O_ 를 prepend.
          1. 각 _items_ 의 요소 _E_ 에 대해
            1. _spreadable_ = ? IsConcatSpreadable(_E_).
            1. _spreadable_ = *true* 이면
              1. _len_ = ? LengthOfArrayLike(_E_).
              1. _n_ + _len_ > 2<sup>53</sup> - 1 이면 *TypeError* 예외.
              1. _k_ = 0.
              1. _k_ &lt; _len_ 동안 반복
                1. _Pk_ = ! ToString(𝔽(_k_)).
                1. _exists_ = ? HasProperty(_E_, _Pk_).
                1. _exists_ = *true* 이면
                  1. _subElement_ = ? Get(_E_, _Pk_).
                  1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_) 수행.
                1. _n_ = _n_ + 1.
                1. _k_ = _k_ + 1.
            1. Else,
              1. NOTE: _E_ 는 펼치지 않고 단일 항목으로 추가된다.
              1. _n_ ≥ 2<sup>53</sup> - 1 이면 *TypeError* 예외.
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_) 수행.
              1. _n_ = _n_ + 1.
          1. [id="step-array-proto-concat-set-length"] ? Set(_A_, *"length"*, 𝔽(_n_), *true*) 수행.
          1. _A_ 반환.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        <emu-note>
          <p>단계 <emu-xref href="#step-array-proto-concat-set-length"></emu-xref> 에서 *"length"* 프로퍼티를 명시적으로 설정하는 것은 _items_ 의 마지막 비어 있지 않은 요소에 후행 홀(holes)이 있거나 _A_ 가 내장 Array 가 아닌 경우 길이가 정확하도록 하기 위함이다.</p>
        </emu-note>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭하며 *this* 값이 Array 일 필요가 없다. 따라서 다른 종류의 객체에 메서드로 이전 가능하다.</p>
        </emu-note>

        <emu-clause id="sec-isconcatspreadable" type="abstract operation">
          <h1>
            IsConcatSpreadable (
              _O_: ECMAScript 언어 값,
            ): Boolean 을 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _O_ 가 Object 가 아니면 *false* 반환.
            1. _spreadable_ = ? Get(_O_, %Symbol.isConcatSpreadable%).
            1. _spreadable_ 이 *undefined* 가 아니면 ToBoolean(_spreadable_) 반환.
            1. ? IsArray(_O_) 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.constructor">
        <h1>Array.prototype.constructor</h1>
        <p>`Array.prototype.constructor` 의 초기 값은 %Array% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.copywithin">
        <h1>Array.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <emu-note>
          <p>_end_ 인자는 선택적이다. 주어지지 않으면 *this* 값의 길이가 사용된다.</p>
        </emu-note>
        <emu-note>
          <p>_target_ 이 음수이면 배열 길이 _length_ 에 대해 <emu-eqn>_length_ + _target_</emu-eqn> 으로 간주된다. _start_ 가 음수이면 <emu-eqn>_length_ + _start_</emu-eqn>, _end_ 가 음수이면 <emu-eqn>_length_ + _end_</emu-eqn> 으로 간주.</p>
        </emu-note>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeTarget_ = ? ToIntegerOrInfinity(_target_).
          1. _relativeTarget_ = -∞ 이면 _to_ = 0.
          1. Else if _relativeTarget_ &lt; 0 이면 _to_ = max(_len_ + _relativeTarget_, 0).
          1. Else _to_ = min(_relativeTarget_, _len_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _from_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _from_ = max(_len_ + _relativeStart_, 0).
          1. Else _from_ = min(_relativeStart_, _len_).
          1. _end_ 이 *undefined* 이면 _relativeEnd_ = _len_; else _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _final_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _final_ = max(_len_ + _relativeEnd_, 0).
          1. Else _final_ = min(_relativeEnd_, _len_).
          1. _count_ = min(_final_ - _from_, _len_ - _to_).
          1. _from_ &lt; _to_ 그리고 _to_ &lt; _from_ + _count_ 이면
            1. _direction_ = -1.
            1. _from_ = _from_ + _count_ - 1.
            1. _to_ = _to_ + _count_ - 1.
          1. Else,
            1. _direction_ = 1.
          1. _count_ > 0 동안 반복
            1. _fromKey_ = ! ToString(𝔽(_from_)).
            1. _toKey_ = ! ToString(𝔽(_to_)).
            1. _fromPresent_ = ? HasProperty(_O_, _fromKey_).
            1. _fromPresent_ = *true* 이면
              1. _fromValue_ = ? Get(_O_, _fromKey_).
              1. ? Set(_O_, _toKey_, _fromValue_, *true*) 수행.
            1. Else,
              1. Assert: _fromPresent_ = *false*.
              1. ? DeletePropertyOrThrow(_O_, _toKey_) 수행.
            1. _from_ = _from_ + _direction_.
            1. _to_ = _to_ + _direction_.
            1. _count_ = _count_ - 1.
          1. _O_ 반환.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭하다; *this* 값이 Array 일 필요가 없다. 따라서 다른 객체에 이전 가능.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.entries">
        <h1>Array.prototype.entries ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. CreateArrayIterator(_O_, ~key+value~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.every">
        <h1>Array.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ 은 세 인자를 받고 Boolean 으로 강제 가능한 값을 반환하는 함수여야 한다. `every` 는 배열에 존재하는 각 요소에 대해(누락 요소 제외) 오름차순으로 _callback_ 을 호출하며 _callback_ 이 *false* 를 반환하는 요소를 찾으면 즉시 *false* 를 반환한다. 찾지 못하면 *true* 반환. 배열의 누락된 요소에 대해서는 호출되지 않는다.</p>
          <p>_thisArg_ 가 제공되면 각 호출의 *this* 값으로 사용되고, 아니면 *undefined* 사용.</p>
          <p>_callback_ 은 (요소 값, 요소 인덱스, 탐색 중인 객체) 3개 인자로 호출.</p>
          <p>`every` 자체는 객체를 직접 변경하지 않지만 _callback_ 호출로 인해 변경될 수 있다.</p>
          <p>`every` 가 처리할 요소 범위는 첫 호출 전에 고정된다. 이후 추가된 요소는 방문되지 않고, 값이 변경된 기존 요소는 방문 시점의 값이 전달되며, 방문 전에 삭제된 요소는 방문하지 않는다. 공집합(빈 배열)에 대해 *true* 를 반환한다.</p>
        </emu-note>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. _testResult_ = *false* 이면 *false* 반환.
            1. _k_ = _k_ + 1.
          1. *true* 반환.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 제네릭하여 *this* 값이 Array 일 필요가 없다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.fill">
        <h1>Array.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <emu-note>
          <p>_start_ 인자는 선택적이며, 없으면 *+0*<sub>𝔽</sub> 사용.</p>
          <p>_end_ 인자는 선택적이며, 없으면 *this* 값의 길이 사용.</p>
        </emu-note>
        <emu-note>
          <p>_start_ 음수 → <emu-eqn>_length_ + _start_</emu-eqn>, _end_ 음수 → <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _k_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _k_ = max(_len_ + _relativeStart_, 0).
          1. Else _k_ = min(_relativeStart_, _len_).
          1. _end_ 이 *undefined* 이면 _relativeEnd_ = _len_; else _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _final_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _final_ = max(_len_ + _relativeEnd_, 0).
          1. Else _final_ = min(_relativeEnd_, _len_).
          1. _k_ &lt; _final_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. ? Set(_O_, _Pk_, _value_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _O_ 반환.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.filter">
        <h1>Array.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ 은 세 인자를 받고 Boolean 으로 강제 가능한 값을 반환하는 함수. `filter` 는 배열 존재 요소(누락 제외)에 대해 오름차순 호출하며 *true* 를 반환한 값들로 새 배열을 만든다.</p>
          <p>_thisArg_ 제공 시 각 호출의 *this* 값, 아니면 *undefined*.</p>
          <p>인자: (요소 값, 인덱스, 순회 객체).</p>
          <p>`filter` 자체는 직접 변이하지 않으나 _callback_ 으로 변이 가능.</p>
          <p>처리 범위는 시작 전에 고정. 이후 추가 요소 방문 안 함; 값 변경된 요소는 방문 시 값; 방문 전 삭제된 요소는 방문 안 함.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError*.
          1. _A_ = ? ArraySpeciesCreate(_O_, 0).
          1. _k_ = 0.
          1. _to_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _selected_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. _selected_ = *true* 이면
                1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_) 수행.
                1. _to_ = _to_ + 1.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.find">
        <h1>Array.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>오름차순으로 _predicate_ 실행하여 *true* 로 강제 가능한 값을 반환하는 첫 요소 값을 즉시 반환, 없으면 *undefined*. 추가 정보는 FindViaPredicate 참조.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. _findRec_.[[Value]] 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findindex">
        <h1>Array.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>오름차순으로 _predicate_ 실행해 *true* 로 강제 가능한 값인 첫 요소의 인덱스 반환, 없으면 -1. FindViaPredicate 참조.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. _findRec_.[[Index]] 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlast">
        <h1>Array.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>내림차순으로 _predicate_ 실행하여 *true* 로 강제 가능한 첫 요소 값 반환, 없으면 *undefined*. FindViaPredicate 참조.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. _findRec_.[[Value]] 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭 (Array object 일 필요 없음).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlastindex">
        <h1>Array.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>내림차순으로 _predicate_ 실행하여 *true* 로 강제 가능한 첫 요소 인덱스 반환, 없으면 -1. FindViaPredicate 참조.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. _findRec_.[[Index]] 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭 (Array object 일 필요 없음).</p>
        </emu-note>

        <emu-clause id="sec-findviapredicate" type="abstract operation">
          <h1>
            FindViaPredicate (
              _O_: Object,
              _len_: 음이 아닌 정수,
              _direction_: ~ascending~ 또는 ~descending~,
              _predicate_: ECMAScript 언어 값,
              _thisArg_: ECMAScript 언어 값,
            ): [[Index]] (정수 Number), [[Value]] (ECMAScript 언어 값) 필드를 가진 Record 를 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              <p>_O_ 는 배열 유사 객체 또는 TypedArray 여야 한다. 이 연산은 _direction_ 에 따라 오름차순 또는 내림차순 인덱스 순서로 각 요소에 대해 _predicate_ 를 호출하고, *true* 로 강제 가능한 값을 반환하면 그 요소의 인덱스와 값을 담은 Record 를 반환한다. 없다면 인덱스 *-1*<sub>𝔽</sub>, 값 *undefined* 인 Record 반환.</p>
              <p>_predicate_ 는 함수여야 하며 (요소 값, 요소 인덱스, 순회 객체)의 인자를 받는다. 반환값은 Boolean 으로 강제된다.</p>
              <p>_thisArg_ 는 각 호출의 *this* 값.</p>
              <p>이 연산 자체는 객체를 직접 변이하지 않지만 _predicate_ 호출로 변이될 수 있다.</p>
              <p>처리 범위는 순회 직전 고정. 이후 추가 요소는 방문되지 않고, 변경된 요소 값은 방문 시 값, 순회 시작 후 방문 전 삭제된 요소는 여전히 방문되며 프로토타입에서 조회되거나 *undefined* 가 된다.</p>
            </dd>
          </dl>
          <emu-alg>
            1. IsCallable(_predicate_) *false* 이면 *TypeError* 예외.
            1. _direction_ 이 ~ascending~ 이면
              1. _indices_ = 0 (포함) 부터 _len_ (배타) 까지 정수의 오름차순 List.
            1. Else,
              1. _indices_ = 0 (포함) 부터 _len_ (배타) 까지 정수의 내림차순 List.
            1. 각 정수 _k_ ∈ _indices_ 에 대해
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. NOTE: _O_ 가 TypedArray 인 경우 이하 Get 호출은 정상 완료.
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _testResult_ = ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
              1. ToBoolean(_testResult_) *true* 이면 Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ } 반환.
            1. Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* } 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flat">
        <h1>Array.prototype.flat ( [ _depth_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _sourceLen_ = ? LengthOfArrayLike(_O_).
          1. _depthNum_ = 1.
          1. _depth_ 가 *undefined* 가 아니면
            1. _depthNum_ = ? ToIntegerOrInfinity(_depth_).
            1. _depthNum_ &lt; 0 이면 _depthNum_ = 0.
          1. _A_ = ? ArraySpeciesCreate(_O_, 0).
          1. ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_) 수행.
          1. _A_ 반환.
        </emu-alg>

        <emu-clause id="sec-flattenintoarray" type="abstract operation">
          <h1>
            FlattenIntoArray (
              _target_: Object,
              _source_: Object,
              _sourceLen_: 음이 아닌 정수,
              _start_: 음이 아닌 정수,
              _depth_: 음이 아닌 정수 또는 +&infin;,
              optional _mapperFunction_: 함수 객체,
              optional _thisArg_: ECMAScript 언어 값,
            ): 음이 아닌 정수를 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _mapperFunction_ 이 존재하면 IsCallable(_mapperFunction_) = *true*, _thisArg_ 존재, 그리고 _depth_ = 1.
            1. _targetIndex_ = _start_.
            1. _sourceIndex_ = *+0*<sub>𝔽</sub>.
            1. ℝ(_sourceIndex_) &lt; _sourceLen_ 동안 반복
              1. _P_ = ! ToString(_sourceIndex_).
              1. _exists_ = ? HasProperty(_source_, _P_).
              1. _exists_ = *true* 이면
                1. _element_ = ? Get(_source_, _P_).
                1. _mapperFunction_ 존재하면
                  1. _element_ = ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).
                1. _shouldFlatten_ = *false*.
                1. _depth_ > 0 이면
                  1. _shouldFlatten_ = ? IsArray(_element_).
                1. _shouldFlatten_ = *true* 이면
                  1. _depth_ = +∞ 이면 _newDepth_ = +∞; Else _newDepth_ = _depth_ - 1.
                  1. _elementLen_ = ? LengthOfArrayLike(_element_).
                  1. _targetIndex_ = ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).
                1. Else
                  1. _targetIndex_ ≥ 2<sup>53</sup> - 1 이면 *TypeError* 예외.
                  1. ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_) 수행.
                  1. _targetIndex_ = _targetIndex_ + 1.
              1. _sourceIndex_ = _sourceIndex_ + *1*<sub>𝔽</sub>.
            1. _targetIndex_ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flatmap">
        <h1>Array.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _sourceLen_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_mapperFunction_) *false* 이면 *TypeError* 예외.
          1. _A_ = ? ArraySpeciesCreate(_O_, 0).
          1. ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_) 수행.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.foreach">
        <h1>Array.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ 은 3 인자를 받는 함수. `forEach` 는 배열 존재 요소(누락 제외)에 대해 오름차순 1회 호출한다.</p>
          <p>_thisArg_ 제공 시 *this*, 아니면 *undefined*.</p>
          <p>인자: (값, 인덱스, 객체).</p>
          <p>직접 변이하지 않지만 _callback_ 으로 변이 가능.</p>
          <p>처리 범위는 시작 전에 고정; 이후 추가 요소 방문 안 함; 변경 요소 값은 방문 시; 삭제된 요소는 방문 안 함.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError*.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ ») 수행.
            1. _k_ = _k_ + 1.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.includes">
        <h1>Array.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>오름차순으로 SameValueZero 알고리즘을 사용해 _searchElement_ 를 비교하며 위치가 있으면 *true*, 없으면 *false* 반환.</p>
          <p>두 번째 인자 _fromIndex_ 기본값 *+0*<sub>𝔽</sub>. 길이 이상이면 *false*. *-0*<sub>𝔽</sub> 보다 작으면 배열 끝에서의 오프셋으로 사용. 계산된 인덱스 ≤ *+0*<sub>𝔽</sub> 이면 전체 검색.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _len_ = 0 이면 *false* 반환.
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: _fromIndex_ 가 *undefined* 이면 _n_ = 0.
          1. _n_ = +∞ 이면 *false* 반환.
          1. Else if _n_ = -∞ 이면 _n_ = 0.
          1. _n_ ≥ 0 이면
            1. _k_ = _n_.
          1. Else,
            1. _k_ = _len_ + _n_.
            1. _k_ &lt; 0 이면 _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _elementK_ = ? Get(_O_, ! ToString(𝔽(_k_))).
            1. SameValueZero(_searchElement_, _elementK_) *true* 이면 *true* 반환.
            1. _k_ = _k_ + 1.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
        <emu-note>
          <p>`indexOf` 와 다르게 SameValueZero 사용으로 *NaN* 탐지 가능하며 누락 요소를 건너뛰지 않고 *undefined* 로 처리.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.indexof">
        <h1>Array.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>오름차순으로 IsStrictlyEqual 알고리즘으로 비교하여 발견된 가장 작은 인덱스 반환, 없으면 *-1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>두 번째 인자 _fromIndex_ 기본 *+0*<sub>𝔽</sub>. 길이 이상이면 *-1*<sub>𝔽</sub>. *-0*<sub>𝔽</sub> 보다 작으면 끝에서 오프셋. 계산 인덱스 ≤ *+0*<sub>𝔽</sub> 이면 전체 검색.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _len_ = 0 이면 *-1*<sub>𝔽</sub> 반환.
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: _fromIndex_ *undefined* ⇒ _n_ = 0.
          1. _n_ = +∞ 이면 *-1*<sub>𝔽</sub> 반환.
          1. Else if _n_ = -∞ ⇒ _n_ = 0.
          1. _n_ ≥ 0 이면
            1. _k_ = _n_.
          1. Else
            1. _k_ = _len_ + _n_.
            1. _k_ &lt; 0 ⇒ _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _elementK_ = ? Get(_O_, _Pk_).
              1. IsStrictlyEqual(_searchElement_, _elementK_) *true* 이면 𝔽(_k_) 반환.
            1. _k_ = _k_ + 1.
          1. *-1*<sub>𝔽</sub> 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.join">
        <h1>Array.prototype.join ( _separator_ )</h1>
        <p>요소들을 String 으로 변환 후 _separator_ 로 구분해 연결한 String 반환. 구분자 생략 시 쉼표 사용.</p>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _separator_ 가 *undefined* 이면 _sep_ = *","*.
          1. Else _sep_ = ? ToString(_separator_).
          1. _R_ = 빈 String.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _k_ > 0 이면 _R_ = _R_ + _sep_.
            1. _element_ = ? Get(_O_, ! ToString(𝔽(_k_))).
            1. _element_ 가 *undefined*, *null* 이 아니면
              1. _S_ = ? ToString(_element_).
              1. _R_ = _R_ + _S_.
            1. _k_ = _k_ + 1.
          1. _R_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.keys">
        <h1>Array.prototype.keys ( )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. CreateArrayIterator(_O_, ~key~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.lastindexof">
        <h1>Array.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>내림차순 IsStrictlyEqual 로 비교, 발견된 가장 큰 인덱스 반환, 없으면 *-1*<sub>𝔽</sub>. _fromIndex_ 기본은 길이 - 1.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _len_ = 0 이면 *-1*<sub>𝔽</sub> 반환.
          1. _fromIndex_ 존재하면 _n_ = ? ToIntegerOrInfinity(_fromIndex_); else _n_ = _len_ - 1.
          1. _n_ = -∞ 이면 *-1*<sub>𝔽</sub> 반환.
          1. _n_ ≥ 0 이면
            1. _k_ = min(_n_, _len_ - 1).
          1. Else
            1. _k_ = _len_ + _n_.
          1. _k_ ≥ 0 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _elementK_ = ? Get(_O_, _Pk_).
              1. IsStrictlyEqual(_searchElement_, _elementK_) *true* 이면 𝔽(_k_) 반환.
            1. _k_ = _k_ - 1.
          1. *-1*<sub>𝔽</sub> 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.map">
        <h1>Array.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>각 존재 요소에 대해 오름차순으로 _callback_ 실행하고 결과로 새 Array 구성. 누락 요소는 호출 안 함.</p>
          <p>_thisArg_ 있으면 *this*, 없으면 *undefined*.</p>
          <p>인자: (값, 인덱스, 객체).</p>
          <p>`map` 은 직접 변이 안 하지만 _callback_ 으로 변이 가능.</p>
          <p>범위는 시작 전 고정. 이후 추가 요소 방문 안 함; 변경 요소는 방문 시 값; 삭제된 요소는 방문 안 함.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError*.
          1. _A_ = ? ArraySpeciesCreate(_O_, _len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _mappedValue_ = ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
              1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_) 수행.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.pop">
        <h1>Array.prototype.pop ( )</h1>
        <emu-note>
          <p>배열의 마지막 요소를 제거하고 그 값을 반환.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _len_ = 0 이면
            1. ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*).
            1. *undefined* 반환.
          1. Else
            1. Assert: _len_ > 0.
            1. _newLen_ = 𝔽(_len_ - 1).
            1. _index_ = ! ToString(_newLen_).
            1. _element_ = ? Get(_O_, _index_).
            1. ? DeletePropertyOrThrow(_O_, _index_).
            1. ? Set(_O_, *"length"*, _newLen_, *true*).
            1. _element_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.push">
        <h1>Array.prototype.push ( ..._items_ )</h1>
        <emu-note>
          <p>인자들을 나타나는 순서대로 배열 끝에 추가하고 새 길이를 반환.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _argCount_ = _items_ 요소 개수.
          1. _len_ + _argCount_ > 2<sup>53</sup> - 1 이면 *TypeError* 예외.
          1. 각 _items_ 요소 _E_ 에 대해
            1. ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*) 수행.
            1. _len_ = _len_ + 1.
          1. ? Set(_O_, *"length"*, 𝔽(_len_), *true*) 수행.
          1. 𝔽(_len_) 반환.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduce">
        <h1>Array.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ 은 네 인자를 받는 함수. `reduce` 는 첫 요소 이후 각 존재 요소에 대해 오름차순 호출.</p>
          <p>인자: _previousValue_, _currentValue_, _currentIndex_, 순회 객체. 첫 호출 시 _initialValue_ 가 제공되면 _previousValue_ = _initialValue_, _currentValue_ = 첫 값; 없으면 _previousValue_ = 첫 값, _currentValue_ = 두 번째 값. 요소 없고 _initialValue_ 미제공 시 *TypeError*.</p>
          <p>직접 변이하지 않지만 호출로 변이될 수 있음.</p>
          <p>처리 범위는 시작 전 고정. 이후 추가 요소 방문 안 함; 변경 요소 값은 방문 시 값; 삭제된 요소 방문 안 함.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError*.
          1. _len_ = 0 이고 _initialValue_ 미존재이면 *TypeError*.
          1. _k_ = 0.
          1. _accumulator_ = *undefined*.
          1. _initialValue_ 존재하면
            1. _accumulator_ = _initialValue_.
          1. Else
            1. _kPresent_ = *false*.
            1. _kPresent_ = *false* 그리고 _k_ &lt; _len_ 동안
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _kPresent_ = ? HasProperty(_O_, _Pk_).
              1. _kPresent_ = *true* 이면
                1. _accumulator_ = ? Get(_O_, _Pk_).
              1. _k_ = _k_ + 1.
            1. _kPresent_ = *false* 이면 *TypeError*.
          1. _k_ &lt; _len_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. _k_ = _k_ + 1.
          1. _accumulator_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduceright">
        <h1>Array.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ 은 네 인자를 받는 함수. `reduceRight` 는 마지막 요소 이전 각 존재 요소를 내림차순 호출.</p>
          <p>첫 호출 시 _initialValue_ 있으면 _previousValue_ = _initialValue_, _currentValue_ = 마지막 값; 없으면 _previousValue_ = 마지막 값, _currentValue_ = 끝에서 두 번째. 요소 없고 _initialValue_ 없으면 *TypeError*.</p>
          <p>변이 규칙은 reduce 와 유사.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError*.
          1. _len_ = 0 이고 _initialValue_ 미존재이면 *TypeError*.
          1. _k_ = _len_ - 1.
          1. _accumulator_ = *undefined*.
          1. _initialValue_ 존재하면
            1. _accumulator_ = _initialValue_.
          1. Else
            1. _kPresent_ = *false*.
            1. _kPresent_ = *false* 그리고 _k_ ≥ 0 동안
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _kPresent_ = ? HasProperty(_O_, _Pk_).
              1. _kPresent_ = *true* 이면
                1. _accumulator_ = ? Get(_O_, _Pk_).
              1. _k_ = _k_ - 1.
            1. _kPresent_ = *false* 이면 *TypeError*.
          1. _k_ ≥ 0 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. _k_ = _k_ - 1.
          1. _accumulator_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reverse">
        <h1>Array.prototype.reverse ( )</h1>
        <emu-note>
          <p>배열 요소 순서를 반대로 재배열하고 그 배열을 반환.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _middle_ = floor(_len_ / 2).
          1. _lower_ = 0.
          1. _lower_ ≠ _middle_ 동안
            1. _upper_ = _len_ - _lower_ - 1.
            1. _upperP_ = ! ToString(𝔽(_upper_)).
            1. _lowerP_ = ! ToString(𝔽(_lower_)).
            1. _lowerExists_ = ? HasProperty(_O_, _lowerP_).
            1. _lowerExists_ = *true* 이면
              1. _lowerValue_ = ? Get(_O_, _lowerP_).
            1. _upperExists_ = ? HasProperty(_O_, _upperP_).
            1. _upperExists_ = *true* 이면
              1. _upperValue_ = ? Get(_O_, _upperP_).
            1. _lowerExists_ = *true* 그리고 _upperExists_ = *true* 이면
              1. ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else if _lowerExists_ = *false* 그리고 _upperExists_ = *true*
              1. ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. ? DeletePropertyOrThrow(_O_, _upperP_).
            1. Else if _lowerExists_ = *true* 그리고 _upperExists_ = *false*
              1. ? DeletePropertyOrThrow(_O_, _lowerP_).
              1. ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else
              1. Assert: 둘 다 *false*.
              1. NOTE: 동작 없음.
            1. _lower_ = _lower_ + 1.
          1. _O_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.shift">
        <h1>Array.prototype.shift ( )</h1>
        <p>배열의 첫 요소를 제거하고 그 값을 반환한다.</p>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _len_ = 0 이면
            1. ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*).
            1. *undefined* 반환.
          1. _first_ = ? Get(_O_, *"0"*).
          1. _k_ = 1.
          1. _k_ &lt; _len_ 동안
            1. _from_ = ! ToString(𝔽(_k_)).
            1. _to_ = ! ToString(𝔽(_k_ - 1)).
            1. _fromPresent_ = ? HasProperty(_O_, _from_).
            1. _fromPresent_ = *true* 이면
              1. _fromValue_ = ? Get(_O_, _from_).
              1. ? Set(_O_, _to_, _fromValue_, *true*).
            1. Else
              1. Assert: _fromPresent_ = *false*.
              1. ? DeletePropertyOrThrow(_O_, _to_).
            1. _k_ = _k_ + 1.
          1. ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).
          1. ? Set(_O_, *"length"*, 𝔽(_len_ - 1), *true*).
          1. _first_ 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.slice">
        <h1>Array.prototype.slice ( _start_, _end_ )</h1>
        <p>배열의 _start_ 부터 (포함), _end_ (배타) 까지 요소를 포함하는 배열을 반환 (_end_ 가 *undefined* 이면 끝까지). _start_ 음수 → <emu-eqn>_length_ + _start_</emu-eqn>, _end_ 음수 → <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _k_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _k_ = max(_len_ + _relativeStart_, 0).
          1. Else _k_ = min(_relativeStart_, _len_).
          1. _end_ *undefined* 이면 _relativeEnd_ = _len_; else _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _final_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _final_ = max(_len_ + _relativeEnd_, 0).
          1. Else _final_ = min(_relativeEnd_, _len_).
          1. _count_ = max(_final_ - _k_, 0).
          1. _A_ = ? ArraySpeciesCreate(_O_, _count_).
          1. _n_ = 0.
          1. _k_ &lt; _final_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_) 수행.
            1. _k_ = _k_ + 1.
            1. _n_ = _n_ + 1.
          1. [id="step-array-proto-slice-set-length"] ? Set(_A_, *"length"*, 𝔽(_n_), *true*) 수행.
          1. _A_ 반환.
        </emu-alg>
        <emu-note>
          <p>단계 <emu-xref href="#step-array-proto-slice-set-length"></emu-xref> 에서 *"length"* 를 명시적으로 설정하는 것은 _A_ 가 내장 Array 가 아닌 경우에도 길이가 정확하도록 하기 위함.</p>
        </emu-note>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.some">
        <h1>Array.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ 은 세 인자를 받고 Boolean 으로 강제 가능한 값을 반환. `some` 은 존재 요소를 오름차순으로 호출하다가 *true* 반환 시 즉시 *true*, 없으면 *false*. 누락 요소는 호출 안 함.</p>
          <p>_thisArg_ 제공 시 *this*, 아니면 *undefined*.</p>
          <p>인자: (요소 값, 인덱스, 객체).</p>
          <p>직접 변이하지 않지만 _callback_ 으로 변이 가능.</p>
          <p>처리 범위는 시작 전 고정. 이후 추가 요소 방문 안 함; 변경 요소 값은 방문 시 값; 삭제된 요소 방문 안 함. 빈 배열이면 *false*.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. IsCallable(_callback_) *false* 이면 *TypeError*.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ? HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _kValue_ = ? Get(_O_, _Pk_).
              1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. _testResult_ = *true* 이면 *true* 반환.
            1. _k_ = _k_ + 1.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.sort" oldids="sec-sortcompare">
        <h1>Array.prototype.sort ( _comparator_ )</h1>
        <p>배열 요소를 정렬한다. _comparator_ 가 *undefined* 가 아니면 두 인자 _x_, _y_ 를 받아 _x_ &lt; _y_ 이면 음수, _x_ > _y_ 이면 양수, 같으면 0인 Number 를 반환하는 함수여야 한다.</p>
        <p>호출 시:</p>
        <emu-alg>
          1. [id="step-array-sort-comparefn"] _comparator_ ≠ *undefined* 이고 IsCallable(_comparator_) = *false* 이면 *TypeError*.
          1. _obj_ = ? ToObject(*this* value).
          1. [id="step-array-sort-len"] _len_ = ? LengthOfArrayLike(_obj_).
          1. _SortCompare_ 를 (_x_, _y_) 매개변수로 하고 _comparator_ 캡처하여 호출 시 ? CompareArrayElements(_x_, _y_, _comparator_) 를 반환하는 새 추상 클로저로 둔다.
          1. [id="step-array-sortindexedproperties"] _sortedList_ = ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).
          1. _itemCount_ = _sortedList_ 의 요소 수.
          1. _j_ = 0.
          1. _j_ &lt; _itemCount_ 동안
            1. ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*) 수행.
            1. _j_ = _j_ + 1.
          1. NOTE: 단계 <emu-xref href="#step-array-sortindexedproperties"></emu-xref> 에서 ~skip-holes~ 사용. 남은 인덱스는 감지된 홀 수를 유지하기 위해 삭제된다.
          1. _j_ &lt; _len_ 동안
            1. ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))) 수행.
            1. _j_ = _j_ + 1.
          1. _obj_ 반환.
        </emu-alg>
        <emu-note>
          <p>존재하지 않는 프로퍼티 값은 항상 *undefined* 프로퍼티 값보다 크고, *undefined* 는 다른 어떤 값보다 크기 때문에 (CompareArrayElements 참조) *undefined* 값이 결과 끝에, 그 뒤에 존재하지 않는 값이 온다.</p>
        </emu-note>
        <emu-note>
          <p>단계 <emu-xref href="#step-sortcompare-tostring-x"></emu-xref>, <emu-xref href="#step-sortcompare-tostring-y"></emu-xref> 의 ToString 호출은 _SortCompare_ 가 일관 비교자가 아니게 만들 수 있다.</p>
        </emu-note>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>

        <emu-clause id="sec-sortindexedproperties" type="abstract operation">
          <h1>
            SortIndexedProperties (
              _obj_: Object,
              _len_: 음이 아닌 정수,
              _SortCompare_: 두 매개변수 추상 클로저,
              _holes_: ~skip-holes~ 또는 ~read-through-holes~,
            ): ECMAScript 언어 값 List 를 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _items_ = 새 빈 List.
            1. _k_ = 0.
            1. _k_ &lt; _len_ 동안
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _holes_ 가 ~skip-holes~ 이면
                1. _kRead_ = ? HasProperty(_obj_, _Pk_).
              1. Else
                1. Assert: _holes_ = ~read-through-holes~.
                1. _kRead_ = *true*.
              1. _kRead_ = *true* 이면
                1. _kValue_ = ? Get(_obj_, _Pk_).
                1. _items_ 에 _kValue_ 추가.
              1. _k_ = _k_ + 1.
            1. [id="step-array-sort"] 구현 정의 순서의 <emu-meta effects="user-code">_SortCompare_ 호출</emu-meta> 로 _items_ 정렬. abrupt completion 반환 시 추가 호출 중지 후 그 Completion Record 반환.
            1. _items_ 반환.
          </emu-alg>
          <p><dfn id="sort-order">정렬 순서</dfn> 는 위 알고리즘 단계 <emu-xref href="#step-array-sort"></emu-xref> 완료 후 _items_ 의 순서. _SortCompare_ 가 일관 비교자가 아니면 구현 정의. Array.prototype.sort 또는 Array.prototype.toSorted 가 호출할 때 _comparator_ 가 *undefined* 이고 특정 값에 대한 모든 ToString 적용 결과가 동일하지 않으면 정렬 순서 역시 구현 정의.</p>
          <p>구현 정의 아닌 경우 다음 조건 충족 필요:</p>
          <ul>
            <li>_itemCount_ 보다 작은 음이 아닌 정수의 어떤 수학적 순열 π 가 존재하여, 모든 _j_ 에 대해 old[_j_] 와 new[π(_j_)] 는 정확히 동일해야 한다.</li>
            <li>모든 _j_, _k_ (각각 _itemCount_ 미만) 대해 <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) &lt; 0</emu-eqn>이면 <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>.</li>
            <li>_j_ &lt; _k_ &lt; _itemCount_ 이고 <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) = 0</emu-eqn> 이면 <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn> (안정 정렬).</li>
          </ul>
          <p>old[_j_] 표기는 단계 <emu-xref href="#step-array-sort"></emu-xref> 실행 전 _items_[_j_] 를, new[_j_] 표기는 실행 후 _items_[_j_] 를 의미.</p>
          <p>추상 클로저 또는 함수 _comparator_ 가 집합 _S_ 에 대한 <dfn id="consistent-comparator">일관 비교자</dfn> 이려면 _S_ 내 값 _a_, _b_, _c_ (동일 가능)에 대해 다음 조건 만족: <emu-eqn>_a_ &lt;<sub>C</sub> _b_</emu-eqn> 는 <emu-eqn>ℝ(_comparator_(_a_, _b_)) &lt; 0</emu-eqn>, <emu-eqn>_a_ =<sub>C</sub> _b_</emu-eqn> 는 0, <emu-eqn>_a_ ><sub>C</sub> _b_</emu-eqn> 는 > 0 뜻.</p>
          <ul>
            <li>특정 (_a_, _b_) 쌍에 대해 _comparator_(_a_, _b_) 는 항상 동일 _v_ (Number, *NaN* 아님) 반환. 따라서 정확히 하나만 성립.</li>
            <li>_comparator_(_a_, _b_) 호출은 _obj_ 또는 그 프로토타입 체인 객체를 수정하지 않는다.</li>
            <li>_a_ =<sub>C</sub> _a_ (반사성)</li>
            <li>_a_ =<sub>C</sub> _b_ ⇒ _b_ =<sub>C</sub> _a_ (대칭성)</li>
            <li>_a_ =<sub>C</sub> _b_, _b_ =<sub>C</sub> _c_ ⇒ _a_ =<sub>C</sub> _c_ (이행성)</li>
            <li>_a_ &lt;<sub>C</sub> _b_, _b_ &lt;<sub>C</sub> _c_ ⇒ _a_ &lt;<sub>C</sub> _c_</li>
            <li>_a_ ><sub>C</sub> _b_, _b_ ><sub>C</sub> _c_ ⇒ _a_ ><sub>C</sub> _c_</li>
          </ul>
          <emu-note>
            <p>위 조건은 _comparator_ 가 _S_ 를 등가류로 나누고 그 등가류가 전순서를 갖도록 하는 데 필요충분.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-comparearrayelements" type="abstract operation">
          <h1>
            CompareArrayElements (
              _x_: ECMAScript 언어 값,
              _y_: ECMAScript 언어 값,
              _comparator_: 함수 객체 또는 *undefined*,
            ): Number 를 포함하는 정상 완료 또는 abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_, _y_ 둘 다 *undefined* 이면 *+0*<sub>𝔽</sub> 반환.
            1. _x_ 가 *undefined* 이면 *1*<sub>𝔽</sub> 반환.
            1. _y_ 가 *undefined* 이면 *-1*<sub>𝔽</sub> 반환.
            1. _comparator_ ≠ *undefined* 이면
              1. _v_ = ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »)).
              1. _v_ 가 *NaN* 이면 *+0*<sub>𝔽</sub> 반환.
              1. _v_ 반환.
            1. [id="step-sortcompare-tostring-x"] _xString_ = ? ToString(_x_).
            1. [id="step-sortcompare-tostring-y"] _yString_ = ? ToString(_y_).
            1. _xSmaller_ = ! IsLessThan(_xString_, _yString_, *true*).
            1. _xSmaller_ = *true* 이면 *-1*<sub>𝔽</sub> 반환.
            1. _ySmaller_ = ! IsLessThan(_yString_, _xString_, *true*).
            1. _ySmaller_ = *true* 이면 *1*<sub>𝔽</sub> 반환.
            1. *+0*<sub>𝔽</sub> 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.splice">
        <h1>Array.prototype.splice ( _start_, _deleteCount_, ..._items_ )</h1>
        <emu-note>
          <p>이 메서드는 정수 인덱스 _start_ 부터 _deleteCount_ 개 요소를 삭제하고 _items_ 요소로 대체한다. 삭제된 요소(있다면)를 담은 Array 반환.</p>
        </emu-note>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _actualStart_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _actualStart_ = max(_len_ + _relativeStart_, 0).
          1. Else _actualStart_ = min(_relativeStart_, _len_).
          1. _itemCount_ = _items_ 요소 개수.
          1. _start_ 미존재이면
            1. _actualDeleteCount_ = 0.
          1. Else if _deleteCount_ 미존재이면
            1. _actualDeleteCount_ = _len_ - _actualStart_.
          1. Else
            1. _dc_ = ? ToIntegerOrInfinity(_deleteCount_).
            1. _actualDeleteCount_ = _dc_ 를 0 과 _len_ - _actualStart_ 사이로 clamp 한 값.
          1. _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1 이면 *TypeError*.
          1. _A_ = ? ArraySpeciesCreate(_O_, _actualDeleteCount_).
          1. _k_ = 0.
          1. _k_ &lt; _actualDeleteCount_ 동안
            1. _from_ = ! ToString(𝔽(_actualStart_ + _k_)).
            1. ? HasProperty(_O_, _from_) = *true* 이면
              1. _fromValue_ = ? Get(_O_, _from_).
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_) 수행.
            1. _k_ = _k_ + 1.
          1. [id="step-array-proto-splice-set-length"] ? Set(_A_, *"length"*, 𝔽(_actualDeleteCount_), *true*) 수행.
          1. _itemCount_ &lt; _actualDeleteCount_ 이면
            1. _k_ = _actualStart_.
            1. _k_ &lt; (_len_ - _actualDeleteCount_) 동안
              1. _from_ = ! ToString(𝔽(_k_ + _actualDeleteCount_)).
              1. _to_ = ! ToString(𝔽(_k_ + _itemCount_)).
              1. ? HasProperty(_O_, _from_) = *true* 이면
                1. _fromValue_ = ? Get(_O_, _from_).
                1. ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else
                1. ? DeletePropertyOrThrow(_O_, _to_).
              1. _k_ = _k_ + 1.
            1. _k_ = _len_.
            1. _k_ > (_len_ - _actualDeleteCount_ + _itemCount_) 동안
              1. ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).
              1. _k_ = _k_ - 1.
          1. Else if _itemCount_ > _actualDeleteCount_ 이면
            1. _k_ = (_len_ - _actualDeleteCount_).
            1. _k_ > _actualStart_ 동안
              1. _from_ = ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).
              1. _to_ = ! ToString(𝔽(_k_ + _itemCount_ - 1)).
              1. ? HasProperty(_O_, _from_) = *true* 이면
                1. _fromValue_ = ? Get(_O_, _from_).
                1. ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else
                1. ? DeletePropertyOrThrow(_O_, _to_).
              1. _k_ = _k_ - 1.
          1. _k_ = _actualStart_.
          1. 각 _items_ 요소 _E_ 에 대해
            1. ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).
            1. _k_ = _k_ + 1.
          1. [id="step-array-proto-splice-set-length-2"] ? Set(_O_, *"length"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*) 수행.
          1. _A_ 반환.
        </emu-alg>
        <emu-note>
          <p>단계 <emu-xref href="#step-array-proto-splice-set-length"></emu-xref>, <emu-xref href="#step-array-proto-splice-set-length-2"></emu-xref> 의 명시적 설정은 내장 Array 가 아닌 경우에도 길이가 정확하도록 하기 위함.</p>
        </emu-note>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tolocalestring">
        <h1>Array.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API 를 포함하는 구현은 ECMA-402 명세에 따라 이 메서드를 구현해야 한다. 포함하지 않으면 아래 명세를 사용.</p>
        <emu-note>
          <p>ECMA-402 첫 에디션은 이 메서드의 대체 명세를 포함하지 않았다.</p>
        </emu-note>
        <p>선택적 매개변수의 의미는 ECMA-402 명세에서 정의되며, 이를 포함하지 않는 구현은 다른 용도로 사용해서는 안 된다.</p>
        <p>호출 시:</p>
        <emu-alg>
          1. _array_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_array_).
          1. _separator_ = 호스트 환경 현재 로캘에 적합한 구현 정의 목록 구분자 String (예: *", "*).
          1. _R_ = 빈 String.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _k_ > 0 이면 _R_ = _R_ + _separator_.
            1. _element_ = ? Get(_array_, ! ToString(𝔽(_k_))).
            1. _element_ 가 *undefined*, *null* 이 아니면
              1. _S_ = ? ToString(? Invoke(_element_, *"toLocaleString"*)).
              1. _R_ = _R_ + _S_.
            1. _k_ = _k_ + 1.
          1. _R_ 반환.
        </emu-alg>
        <emu-note>
          <p>각 요소를 `toLocaleString` 으로 변환하고 로캘 민감 구분자 String 으로 결합. `toString` 과 유사하나 로캘 민감 결과를 의도.</p>
        </emu-note>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.toreversed">
        <h1>Array.prototype.toReversed ( )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _A_ = ? ArrayCreate(_len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _from_ = ! ToString(𝔽(_len_ - _k_ - 1)).
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _fromValue_ = ? Get(_O_, _from_).
            1. ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_) 수행.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tosorted">
        <h1>Array.prototype.toSorted ( _comparator_ )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _comparator_ ≠ *undefined* 그리고 IsCallable(_comparator_) = *false* 이면 *TypeError*.
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _A_ = ? ArrayCreate(_len_).
          1. _SortCompare_ 를 (_x_, _y_) → ? CompareArrayElements(_x_, _y_, _comparator_) 클로저로 둔다.
          1. _sortedList_ = ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).
          1. _j_ = 0.
          1. _j_ &lt; _len_ 동안
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]) 수행.
            1. _j_ = _j_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tospliced">
        <h1>Array.prototype.toSpliced ( _start_, _skipCount_, ..._items_ )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _actualStart_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _actualStart_ = max(_len_ + _relativeStart_, 0).
          1. Else _actualStart_ = min(_relativeStart_, _len_).
          1. _insertCount_ = _items_ 요소 개수.
          1. _start_ 미존재이면
            1. _actualSkipCount_ = 0.
          1. Else if _skipCount_ 미존재이면
            1. _actualSkipCount_ = _len_ - _actualStart_.
          1. Else
            1. _sc_ = ? ToIntegerOrInfinity(_skipCount_).
            1. _actualSkipCount_ = _sc_ 를 0 과 _len_ - _actualStart_ 사이로 clamp.
          1. _newLen_ = _len_ + _insertCount_ - _actualSkipCount_.
          1. _newLen_ > 2<sup>53</sup> - 1 이면 *TypeError*.
          1. _A_ = ? ArrayCreate(_newLen_).
          1. _i_ = 0.
          1. _r_ = _actualStart_ + _actualSkipCount_.
          1. _i_ &lt; _actualStart_ 동안
            1. _Pi_ = ! ToString(𝔽(_i_)).
            1. _iValue_ = ? Get(_O_, _Pi_).
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_) 수행.
            1. _i_ = _i_ + 1.
          1. 각 _items_ 요소 _E_ 에 대해
            1. _Pi_ = ! ToString(𝔽(_i_)).
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_) 수행.
            1. _i_ = _i_ + 1.
          1. _i_ &lt; _newLen_ 동안
            1. _Pi_ = ! ToString(𝔽(_i_)).
            1. _from_ = ! ToString(𝔽(_r_)).
            1. _fromValue_ = ? Get(_O_, _from_).
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_) 수행.
            1. _i_ = _i_ + 1.
            1. _r_ = _r_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tostring">
        <h1>Array.prototype.toString ( )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _array_ = ? ToObject(*this* value).
          1. _func_ = ? Get(_array_, *"join"*).
          1. IsCallable(_func_) *false* 이면 _func_ = 본질 함수 %Object.prototype.toString%.
          1. ? Call(_func_, _array_) 반환.
        </emu-alg>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.unshift">
        <h1>Array.prototype.unshift ( ..._items_ )</h1>
        <p>인자를 배열 앞에 추가하며, 추가된 순서를 유지.</p>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _argCount_ = _items_ 요소 개수.
          1. _argCount_ > 0 이면
            1. _len_ + _argCount_ > 2<sup>53</sup> - 1 이면 *TypeError*.
            1. _k_ = _len_.
            1. _k_ > 0 동안
              1. _from_ = ! ToString(𝔽(_k_ - 1)).
              1. _to_ = ! ToString(𝔽(_k_ + _argCount_ - 1)).
              1. _fromPresent_ = ? HasProperty(_O_, _from_).
              1. _fromPresent_ = *true* 이면
                1. _fromValue_ = ? Get(_O_, _from_).
                1. ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else
                1. Assert: _fromPresent_ = *false*.
                1. ? DeletePropertyOrThrow(_O_, _to_).
              1. _k_ = _k_ - 1.
            1. _j_ = *+0*<sub>𝔽</sub>.
            1. 각 _items_ 요소 _E_ 에 대해
              1. ? Set(_O_, ! ToString(_j_), _E_, *true*).
              1. _j_ = _j_ + *1*<sub>𝔽</sub>.
          1. ? Set(_O_, *"length"*, 𝔽(_len_ + _argCount_), *true*) 수행.
          1. 𝔽(_len_ + _argCount_) 반환.
        </emu-alg>
        <p>이 메서드의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>제네릭.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.values">
        <h1>Array.prototype.values ( )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. CreateArrayIterator(_O_, ~value~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.with">
        <h1>Array.prototype.with ( _index_, _value_ )</h1>
        <p>호출 시:</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value).
          1. _len_ = ? LengthOfArrayLike(_O_).
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_).
          1. _relativeIndex_ ≥ 0 이면 _actualIndex_ = _relativeIndex_; Else _actualIndex_ = _len_ + _relativeIndex_.
          1. _actualIndex_ ≥ _len_ 또는 _actualIndex_ &lt; 0 이면 *RangeError* 예외.
          1. _A_ = ? ArrayCreate(_len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _k_ = _actualIndex_ 이면 _fromValue_ = _value_; Else _fromValue_ = ? Get(_O_, _Pk_).
            1. ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_) 수행.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@iterator" id="sec-array.prototype-%symbol.iterator%">
        <h1>Array.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 프로퍼티의 초기 값은 <emu-xref href="#sec-array.prototype.values"></emu-xref> 에 정의된 %Array.prototype.values% 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@unscopables" id="sec-array.prototype-%symbol.unscopables%">
        <h1>Array.prototype [ %Symbol.unscopables% ]</h1>
        <p>%Symbol.unscopables% 데이터 프로퍼티의 초기 값은 다음 단계를 통해 생성된 객체이다:</p>
        <emu-alg>
          1. _unscopableList_ = OrdinaryObjectCreate(*null*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"at"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findLast"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findLastIndex"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toReversed"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toSorted"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toSpliced"*, *true*).
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*).
          1. _unscopableList_ 반환.
        </emu-alg>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <emu-note>
          <p>이 객체의 자체 프로퍼티 이름들은 ECMAScript 2015 이전 `Array.prototype` 표준 프로퍼티가 아니던 이름들이다. 이 이름들은 `with` 문 바인딩 목적에서 무시되어, Array 를 바인딩 객체로 사용하는 `with` 문에 의해 외부 스코프 바인딩이 가려지는 기존 코드 동작을 보존한다.</p>
          <p>*"with"* 이 _unscopableList_ 에 포함되지 않는 이유는 이미 <emu-xref href="#sec-keywords-and-reserved-words">예약어</emu-xref> 이기 때문이다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-array-instances">
      <h1>Array 인스턴스의 프로퍼티 (Properties of Array Instances)</h1>
      <p>Array 인스턴스는 Array 이그조틱 객체이며 해당 객체에 지정된 내부 메서드를 가진다. 또한 Array 프로토타입 객체로부터 프로퍼티를 상속한다.</p>
      <p>Array 인스턴스는 *"length"* 프로퍼티와 배열 인덱스 이름을 가진 열거 가능한 프로퍼티 집합을 가진다.</p>

      <emu-clause id="sec-properties-of-array-instances-length">
        <h1>length</h1>
        <p>Array 인스턴스의 *"length"* 프로퍼티는 그 값이 배열 인덱스 이름을 가진 모든 설정 가능( configurable ) 자체 프로퍼티 이름보다 항상 수치적으로 큰 데이터 프로퍼티이다.</p>
        <p>*"length"* 프로퍼티는 초기 특성 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 를 가진다.</p>
        <emu-note>
          <p>*"length"* 값을 줄이면 이전 길이와 새 길이 사이의 인덱스를 가진 자체 배열 요소가 삭제된다. 단, non-configurable 프로퍼티는 삭제되지 않는다. 배열의 *"length"* 를 기존 non-configurable <emu-xref href="#array-index">array-indexed</emu-xref> 프로퍼티의 가장 큰 수치적 이름보다 작거나 같은 값으로 설정하려 하면 길이는 그 프로퍼티 이름보다 1 큰 값으로 설정된다. <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref> 참조.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-iterator-objects">
      <h1>Array 이터레이터 객체 (Array Iterator Objects)</h1>
      <p><dfn variants="Array Iterators,Array Iterator object,Array Iterator objects">Array Iterator</dfn> 는 특정 Array 인스턴스 객체 위의 특정 순회를 표현하는 객체이다. 이름 있는 생성자는 없으며 Array 인스턴스 객체의 특정 메서드를 호출하여 생성된다.</p>

      <emu-clause id="sec-createarrayiterator" type="abstract operation">
        <h1>
          CreateArrayIterator (
            _array_: Object,
            _kind_: ~key+value~, ~key~, 또는 ~value~,
          ): Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>이터레이터를 반환하는 Array 메서드들이 사용할 이터레이터 객체를 생성하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _iterator_ = OrdinaryObjectCreate(%ArrayIteratorPrototype%, « [[IteratedArrayLike]], [[ArrayLikeNextIndex]], [[ArrayLikeIterationKind]] »).
          1. _iterator_.[[IteratedArrayLike]] = _array_.
          1. _iterator_.[[ArrayLikeNextIndex]] = 0.
          1. _iterator_.[[ArrayLikeIterationKind]] = _kind_.
          1. _iterator_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%arrayiteratorprototype%-object">
        <h1>%ArrayIteratorPrototype% 객체 (The %ArrayIteratorPrototype% Object)</h1>
        <p><dfn>%ArrayIteratorPrototype%</dfn> 객체:</p>
        <ul>
          <li>모든 Array Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
          <li>일반 객체이다.</li>
          <li>값이 %Iterator.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%arrayiteratorprototype%.next">
          <h1>%ArrayIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. _O_ = *this* 값.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외.
            1. _O_ 가 Array Iterator Instance 의 모든 내부 슬롯(<emu-xref href="#sec-properties-of-array-iterator-instances"></emu-xref>)을 갖지 않으면 *TypeError* 예외.
            1. _array_ = _O_.[[IteratedArrayLike]].
            1. _array_ = *undefined* 이면 CreateIteratorResultObject(*undefined*, *true*) 반환.
            1. _index_ = _O_.[[ArrayLikeNextIndex]].
            1. _kind_ = _O_.[[ArrayLikeIterationKind]].
            1. _array_ 가 [[TypedArrayName]] 내부 슬롯을 가지면
              1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).
              1. IsTypedArrayOutOfBounds(_taRecord_) *true* 이면 *TypeError* 예외.
              1. _len_ = TypedArrayLength(_taRecord_).
            1. Else
              1. _len_ = ? LengthOfArrayLike(_array_).
            1. _index_ ≥ _len_ 이면
              1. _O_.[[IteratedArrayLike]] = *undefined*.
              1. CreateIteratorResultObject(*undefined*, *true*) 반환.
            1. _O_.[[ArrayLikeNextIndex]] = _index_ + 1.
            1. _indexNumber_ = 𝔽(_index_).
            1. _kind_ 이 ~key~ 이면
              1. _result_ = _indexNumber_.
            1. Else
              1. _elementKey_ = ! ToString(_indexNumber_).
              1. _elementValue_ = ? Get(_array_, _elementKey_).
              1. _kind_ 이 ~value~ 이면
                1. _result_ = _elementValue_.
              1. Else
                1. Assert: _kind_ = ~key+value~.
                1. _result_ = CreateArrayFromList(« _indexNumber_, _elementValue_ »).
            1. CreateIteratorResultObject(_result_, *false*) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%arrayiteratorprototype%-@@tostringtag" id="sec-%arrayiteratorprototype%-%symbol.tostringtag%">
          <h1>%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"Array Iterator"*.</p>
          <p>이 프로퍼티 특성 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-array-iterator-instances">
        <h1>Array 이터레이터 인스턴스의 프로퍼티 (Properties of Array Iterator Instances)</h1>
        <p>Array 이터레이터 인스턴스는 %ArrayIteratorPrototype% 본질 객체로부터 프로퍼티를 상속하는 일반 객체이다. 초기 생성 시 내부 슬롯은 <emu-xref href="#table-internal-slots-of-array-iterator-instances"></emu-xref> 에 나열된 것을 갖는다.</p>
        <emu-table id="table-internal-slots-of-array-iterator-instances" caption="Array 이터레이터 인스턴스의 내부 슬롯 (Internal Slots of Array Iterator Instances)" oldids="table-48">
          <table>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedArrayLike]]
              </td>
              <td>
                an Object or *undefined*
              </td>
              <td>
                순회 중인 array-like 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeNextIndex]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                이 이터레이터가 다음에 검사할 요소의 정수 인덱스.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeIterationKind]]
              </td>
              <td>
                ~key+value~, ~key~, or ~value~
              </td>
              <td>
                각 요소에 대해 반환되는 내용을 식별하는 값.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray 객체</h1>
    <p>_TypedArray_ 는 기본 이진 데이터 버퍼(<emu-xref href="#sec-arraybuffer-objects"></emu-xref>)에 대한 배열 유사 뷰를 제공한다. <dfn variants="TypedArray element types">TypedArray 요소 타입</dfn>은 특정 _TypedArray_ 인스턴스의 모든 요소가 갖는 기본 이진 스칼라 데이터 타입이다. 지원되는 각 요소 타입마다 <emu-xref href="#table-the-typedarray-constructors"></emu-xref>에 열거된 고유한 _TypedArray_ 생성자가 있다. <emu-xref href="#table-the-typedarray-constructors"></emu-xref>의 각 생성자는 그에 상응하는 별도의 프로토타입 객체를 가진다.</p>
    <emu-table id="table-the-typedarray-constructors" caption="TypedArray 생성자" oldids="table-49">
      <table>
        <thead>
          <tr>
            <th>
              생성자 이름 및 내재 객체
            </th>
            <th>
              요소 타입
            </th>
            <th>
              요소 크기
            </th>
            <th>
              변환 연산
            </th>
            <th>
              설명
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Int8Array<br>
            <dfn>%Int8Array%</dfn>
          </td>
          <td>
            ~int8~
          </td>
          <td>
            1
          </td>
          <td>
            ToInt8
          </td>
          <td>
            8비트 2의 보수 부호 있는 정수
          </td>
        </tr>
        <tr>
          <td>
            Uint8Array<br>
            <dfn>%Uint8Array%</dfn>
          </td>
          <td>
            ~uint8~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8
          </td>
          <td>
            8비트 부호 없는 정수
          </td>
        </tr>
        <tr>
          <td>
            Uint8ClampedArray<br>
            <dfn>%Uint8ClampedArray%</dfn>
          </td>
          <td>
            ~uint8clamped~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8Clamp
          </td>
          <td>
            8비트 부호 없는 정수 (클램프 변환)
          </td>
        </tr>
        <tr>
          <td>
            Int16Array<br>
            <dfn>%Int16Array%</dfn>
          </td>
          <td>
            ~int16~
          </td>
          <td>
            2
          </td>
          <td>
            ToInt16
          </td>
          <td>
            16비트 2의 보수 부호 있는 정수
          </td>
        </tr>
        <tr>
          <td>
            Uint16Array<br>
            <dfn>%Uint16Array%</dfn>
          </td>
          <td>
            ~uint16~
          </td>
          <td>
            2
          </td>
          <td>
            ToUint16
          </td>
          <td>
            16비트 부호 없는 정수
          </td>
        </tr>
        <tr>
          <td>
            Int32Array<br>
            <dfn>%Int32Array%</dfn>
          </td>
          <td>
            ~int32~
          </td>
          <td>
            4
          </td>
          <td>
            ToInt32
          </td>
          <td>
            32비트 2의 보수 부호 있는 정수
          </td>
        </tr>
        <tr>
          <td>
            Uint32Array<br>
            <dfn>%Uint32Array%</dfn>
          </td>
          <td>
            ~uint32~
          </td>
          <td>
            4
          </td>
          <td>
            ToUint32
          </td>
          <td>
            32비트 부호 없는 정수
          </td>
        </tr>
        <tr>
          <td>
            BigInt64Array<br>
            <dfn>%BigInt64Array%</dfn>
          </td>
          <td>
            ~bigint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigInt64
          </td>
          <td>
            64비트 2의 보수 부호 있는 정수
          </td>
        </tr>
        <tr>
          <td>
            BigUint64Array<br>
            <dfn>%BigUint64Array%</dfn>
          </td>
          <td>
            ~biguint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigUint64
          </td>
          <td>
            64비트 부호 없는 정수
          </td>
        </tr>
        <tr>
          <td>
            Float16Array<br>
            <dfn>%Float16Array%</dfn>
          </td>
          <td>
            ~float16~
          </td>
          <td>
            2
          </td>
          <td>
          </td>
          <td>
            16비트 IEEE 부동소수점
          </td>
        </tr>
        <tr>
          <td>
            Float32Array<br>
            <dfn>%Float32Array%</dfn>
          </td>
          <td>
            ~float32~
          </td>
          <td>
            4
          </td>
          <td>
          </td>
          <td>
            32비트 IEEE 부동소수점
          </td>
        </tr>
        <tr>
          <td>
            Float64Array<br>
            <dfn>%Float64Array%</dfn>
          </td>
          <td>
            ~float64~
          </td>
          <td>
            8
          </td>
          <td>
          </td>
          <td>
            64비트 IEEE 부동소수점
          </td>
        </tr>
      </table>
    </emu-table>
    <p>아래 정의들에서 _TypedArray_ 에 대한 참조는 위 표에서 해당하는 적절한 생성자 이름으로 치환되어야 한다.</p>

    <emu-clause id="sec-%typedarray%-intrinsic-object">
      <h1>%TypedArray% 내재 객체</h1>
      <p><dfn>%TypedArray%</dfn> 내재 객체는 다음과 같다:</p>
      <ul>
        <li>모든 _TypedArray_ 생성자 객체가 상속하는 생성자 함수 객체이다.</li>
        <li>연관된 프로토타입 객체와 함께 모든 _TypedArray_ 생성자와 그 인스턴스가 상속하는 공통 프로퍼티를 제공한다.</li>
        <li>전역 이름을 가지지 않으며 전역 객체의 프로퍼티로 나타나지 않는다.</li>
        <li>여러 _TypedArray_ 생성자의 추상 상위(super) 클래스 역할을 한다.</li>
        <li>추상 클래스 생성자이므로 호출 시 오류를 던진다. _TypedArray_ 생성자들은 이에 대한 `super` 호출을 수행하지 않는다.</li>
      </ul>

      <emu-clause id="sec-%typedarray%">
        <h1>%TypedArray% ( )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *TypeError* 예외를 던진다.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티 값은 *+0*<sub>𝔽</sub> 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarray%-intrinsic-object">
      <h1>%TypedArray% 내재 객체의 프로퍼티</h1>
      <p>%TypedArray% 내재 객체는 다음을 가진다:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯.</li>
        <li>값이 *"TypedArray"* 인 *"name"* 프로퍼티.</li>
        <li>다음 프로퍼티들:</li>
      </ul>

      <emu-clause id="sec-%typedarray%.from">
        <h1>%TypedArray%.from ( _source_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. IsConstructor(_C_) 가 *false* 이면 *TypeError* 예외.
          1. _mapper_ 가 *undefined* 이면
            1. _mapping_ = *false*.
          1. Else,
            1. IsCallable(_mapper_) 가 *false* 이면 *TypeError* 예외.
            1. _mapping_ = *true*.
          1. _usingIterator_ = ? GetMethod(_source_, %Symbol.iterator%).
          1. _usingIterator_ 가 *undefined* 가 아니면
            1. _values_ = ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)).
            1. _len_ = _values_ 의 요소 개수.
            1. _targetObj_ = ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
            1. _k_ = 0.
            1. _k_ &lt; _len_ 동안 반복
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _kValue_ = _values_ 의 첫 번째 요소.
              1. _values_ 의 첫 요소를 제거.
              1. _mapping_ = *true* 이면
                1. _mappedValue_ = ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
              1. Else,
                1. _mappedValue_ = _kValue_.
              1. ? Set(_targetObj_, _Pk_, _mappedValue_, *true*) 수행.
              1. _k_ = _k_ + 1.
            1. Assert: _values_ 는 이제 빈 List.
            1. _targetObj_ 반환.
          1. NOTE: _source_ 는 이터러블이 아니므로 배열 유사 객체로 간주.
          1. _arrayLike_ = ! ToObject(_source_).
          1. _len_ = ? LengthOfArrayLike(_arrayLike_).
          1. _targetObj_ = ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ? Get(_arrayLike_, _Pk_).
            1. _mapping_ = *true* 이면
              1. _mappedValue_ = ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
            1. Else,
              1. _mappedValue_ = _kValue_.
            1. ? Set(_targetObj_, _Pk_, _mappedValue_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _targetObj_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.of">
        <h1>%TypedArray%.of ( ..._items_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _len_ = _items_ 의 요소 개수.
          1. _C_ = *this* 값.
          1. IsConstructor(_C_) 가 *false* 이면 *TypeError* 예외.
          1. _newObj_ = ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _kValue_ = _items_[_k_].
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. ? Set(_newObj_, _Pk_, _kValue_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _newObj_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype">
        <h1>%TypedArray%.prototype</h1>
        <p>%TypedArray%`.prototype` 의 초기 값은 %TypedArray% 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%-@@species" id="sec-get-%typedarray%-%symbol.species%">
        <h1>get %TypedArray% [ %Symbol.species% ]</h1>
        <p>%TypedArray%`[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p>%TypedArray.prototype% 메서드는 일반적으로 자신의 *this* 값의 생성자를 사용해 파생 객체를 생성한다. 하지만 서브클래스 생성자는 %Symbol.species% 프로퍼티 재정의를 통해 그 기본 동작을 바꿀 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
      <h1>%TypedArray% 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>%TypedArray% 프로토타입 객체</dfn>는 다음과 같다:</p>
      <ul>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li><dfn>%TypedArray.prototype%</dfn> 이다.</li>
        <li>일반 객체이다.</li>
        <li>[[ViewedArrayBuffer]] 또는 _TypedArray_ 인스턴스 전용의 다른 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-%typedarray%.prototype.at">
        <h1>%TypedArray%.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_).
          1. _relativeIndex_ ≥ 0 이면
            1. _k_ = _relativeIndex_.
          1. Else,
            1. _k_ = _len_ + _relativeIndex_.
          1. _k_ &lt; 0 또는 _k_ ≥ _len_ 이면 *undefined* 반환.
          1. ! Get(_O_, ! ToString(𝔽(_k_))) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.buffer">
        <h1>get %TypedArray%.prototype.buffer</h1>
        <p>%TypedArray%`.prototype.buffer` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _buffer_ = _O_.[[ViewedArrayBuffer]].
          1. _buffer_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
        <h1>get %TypedArray%.prototype.byteLength</h1>
        <p>%TypedArray%`.prototype.byteLength` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. _size_ = TypedArrayByteLength(_taRecord_).
          1. 𝔽(_size_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
        <h1>get %TypedArray%.prototype.byteOffset</h1>
        <p>%TypedArray%`.prototype.byteOffset` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *true* 이면 *+0*<sub>𝔽</sub> 반환.
          1. _offset_ = _O_.[[ByteOffset]].
          1. 𝔽(_offset_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.constructor">
        <h1>%TypedArray%.prototype.constructor</h1>
        <p>%TypedArray%`.prototype.constructor` 의 초기 값은 %TypedArray% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.copywithin">
        <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.copywithin"></emu-xref>에 정의된 `Array.prototype.copyWithin` 과 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_에 *this* 값을 할당한다.
          1. _taRecord_에 ? ValidateTypedArray(_O_, ~seq-cst~)를 할당한다.
          1. _len_에 TypedArrayLength(_taRecord_)를 할당한다.
          1. _relativeTarget_에 ? ToIntegerOrInfinity(_target_)를 할당한다.
          1. _relativeTarget_ = -∞이면, _targetIndex_에 0을 할당한다.
          1. 그렇지 않고 _relativeTarget_ &lt; 0이면, _targetIndex_에 max(_len_ + _relativeTarget_, 0)을 할당한다.
          1. 그렇지 않으면, _targetIndex_에 min(_relativeTarget_, _len_)을 할당한다.
          1. _relativeStart_에 ? ToIntegerOrInfinity(_start_)를 할당한다.
          1. _relativeStart_ = -∞이면, _startIndex_에 0을 할당한다.
          1. 그렇지 않고 _relativeStart_ &lt; 0이면, _startIndex_에 max(_len_ + _relativeStart_, 0)을 할당한다.
          1. 그렇지 않으면, _startIndex_에 min(_relativeStart_, _len_)을 할당한다.
          1. _end_가 *undefined*이면, _relativeEnd_에 _len_을 할당한다; 아니면 _relativeEnd_에 ? ToIntegerOrInfinity(_end_)를 할당한다.
          1. _relativeEnd_ = -∞이면, _endIndex_에 0을 할당한다.
          1. 그렇지 않고 _relativeEnd_ &lt; 0이면, _endIndex_에 max(_len_ + _relativeEnd_, 0)을 할당한다.
          1. 그렇지 않으면, _endIndex_에 min(_relativeEnd_, _len_)을 할당한다.
          1. _count_에 min(_endIndex_ - _startIndex_, _len_ - _targetIndex_)를 할당한다.
          1. _count_ > 0이면,
            1. 참고: 복사는 소스 데이터의 비트 수준 인코딩을 보존하는 방식으로 수행되어야 한다.
            1. _buffer_에 _O_.[[ViewedArrayBuffer]]를 할당한다.
            1. _taRecord_에 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)를 할당한다.
            1. IsTypedArrayOutOfBounds(_taRecord_)가 *true*이면, *TypeError* 예외를 throw한다.
            1. _len_에 TypedArrayLength(_taRecord_)를 할당한다.
            1. 참고: 위 단계의 부작용으로 _O_의 크기가 줄어들 수 있으며, 이 경우 복사는 여전히 적용 가능한 가장 긴 접두사(prefix)로 진행해야 한다.
            1. _count_에 min(_count_, _len_ - _startIndex_, _len_ - _targetIndex_)를 다시 할당한다.
            1. _elementSize_에 TypedArrayElementSize(_O_)를 할당한다.
            1. _byteOffset_에 _O_.[[ByteOffset]]을 할당한다.
            1. _toByteIndex_에 (_targetIndex_ × _elementSize_) + _byteOffset_을 할당한다.
            1. _fromByteIndex_에 (_startIndex_ × _elementSize_) + _byteOffset_을 할당한다.
            1. _countBytes_에 _count_ × _elementSize_를 할당한다.
            1. _fromByteIndex_ &lt; _toByteIndex_ 이고 _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_이면,
              1. _direction_에 -1을 할당한다.
              1. _fromByteIndex_에 _fromByteIndex_ + _countBytes_ - 1을 할당한다.
              1. _toByteIndex_에 _toByteIndex_ + _countBytes_ - 1을 할당한다.
            1. 그렇지 않으면,
              1. _direction_에 1을 할당한다.
            1. _countBytes_ > 0인 동안 반복한다,
              1. _value_에 GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~)를 할당한다.
              1. SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~)를 수행한다.
              1. _fromByteIndex_에 _fromByteIndex_ + _direction_을 할당한다.
              1. _toByteIndex_에 _toByteIndex_ + _direction_을 할당한다.
              1. _countBytes_에 _countBytes_ - 1을 할당한다.
          1. _O_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.entries">
        <h1>%TypedArray%.prototype.entries ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? ValidateTypedArray(_O_, ~seq-cst~) 수행.
          1. CreateArrayIterator(_O_, ~key+value~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.every">
        <h1>%TypedArray%.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.every"></emu-xref>에 정의된 `Array.prototype.every` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. _testResult_ = *false* 이면 *false* 반환.
            1. _k_ = _k_ + 1.
          1. *true* 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.fill"></emu-xref>에 정의된 `Array.prototype.fill` 과 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _O_.[[ContentType]] 가 ~bigint~ 이면 _value_ = ? ToBigInt(_value_).
          1. 아니면 _value_ = ? ToNumber(_value_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _startIndex_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _startIndex_ = max(_len_ + _relativeStart_, 0).
          1. Else _startIndex_ = min(_relativeStart_, _len_).
          1. _end_ 이 *undefined* 이면 _relativeEnd_ = _len_; else _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _endIndex_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _endIndex_ = max(_len_ + _relativeEnd_, 0).
          1. Else _endIndex_ = min(_relativeEnd_, _len_).
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. IsTypedArrayOutOfBounds(_taRecord_) *true* 이면 *TypeError* 예외.
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _endIndex_ = min(_endIndex_, _len_).
          1. _k_ = _startIndex_.
          1. _k_ &lt; _endIndex_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. ! Set(_O_, _Pk_, _value_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _O_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.filter">
        <h1>%TypedArray%.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.filter"></emu-xref>에 정의된 `Array.prototype.filter` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _kept_ = 새 빈 List.
          1. _captured_ = 0.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. _selected_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. _selected_ = *true* 이면
              1. _kept_ 에 _kValue_ 추가.
              1. _captured_ = _captured_ + 1.
            1. _k_ = _k_ + 1.
          1. _A_ = ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »).
          1. _n_ = 0.
          1. 각 _kept_ 요소 _e_ 에 대해
            1. ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*) 수행.
            1. _n_ = _n_ + 1.
          1. _A_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.find">
        <h1>%TypedArray%.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.find"></emu-xref>에 정의된 `Array.prototype.find` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. _findRec_.[[Value]] 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findindex">
        <h1>%TypedArray%.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.findindex"></emu-xref>에 정의된 `Array.prototype.findIndex` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. _findRec_.[[Index]] 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlast">
        <h1>%TypedArray%.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.findlast"></emu-xref>에 정의된 `Array.prototype.findLast` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. _findRec_.[[Value]] 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlastindex">
        <h1>%TypedArray%.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref>에 정의된 `Array.prototype.findLastIndex` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. _findRec_.[[Index]] 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.foreach">
        <h1>%TypedArray%.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.foreach"></emu-xref>에 정의된 `Array.prototype.forEach` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ ») 수행.
            1. _k_ = _k_ + 1.
          1. *undefined* 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.includes">
        <h1>%TypedArray%.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.includes"></emu-xref>에 정의된 `Array.prototype.includes` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _len_ = 0 이면 *false* 반환.
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: _fromIndex_ 가 *undefined* 이면 _n_ = 0.
          1. _n_ = +∞ 이면 *false* 반환.
          1. Else if _n_ = -∞ 이면 _n_ = 0.
          1. _n_ ≥ 0 이면
            1. _k_ = _n_.
          1. Else
            1. _k_ = _len_ + _n_.
            1. _k_ &lt; 0 이면 _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _elementK_ = ! Get(_O_, ! ToString(𝔽(_k_))).
            1. SameValueZero(_searchElement_, _elementK_) *true* 이면 *true* 반환.
            1. _k_ = _k_ + 1.
          1. *false* 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.indexof">
        <h1>%TypedArray%.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.indexof"></emu-xref>에 정의된 `Array.prototype.indexOf` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _len_ = 0 이면 *-1*<sub>𝔽</sub> 반환.
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: _fromIndex_ *undefined* ⇒ _n_ = 0.
          1. _n_ = +∞ 이면 *-1*<sub>𝔽</sub> 반환.
          1. Else if _n_ = -∞ 이면 _n_ = 0.
          1. _n_ ≥ 0 이면
            1. _k_ = _n_.
          1. Else
            1. _k_ = _len_ + _n_.
            1. _k_ &lt; 0 이면 _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ! HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _elementK_ = ! Get(_O_, _Pk_).
              1. IsStrictlyEqual(_searchElement_, _elementK_) *true* 이면 𝔽(_k_) 반환.
            1. _k_ = _k_ + 1.
          1. *-1*<sub>𝔽</sub> 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.join">
        <h1>%TypedArray%.prototype.join ( _separator_ )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.join"></emu-xref>에 정의된 `Array.prototype.join` 과 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _separator_ 가 *undefined* 이면 _sep_ = *","*.
          1. Else _sep_ = ? ToString(_separator_).
          1. _R_ = 빈 String.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _k_ > 0 이면 _R_ = _R_ + _sep_.
            1. _element_ = ! Get(_O_, ! ToString(𝔽(_k_))).
            1. _element_ ≠ *undefined* 이면
              1. _S_ = ! ToString(_element_).
              1. _R_ = _R_ + _S_.
            1. _k_ = _k_ + 1.
          1. _R_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.keys">
        <h1>%TypedArray%.prototype.keys ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? ValidateTypedArray(_O_, ~seq-cst~) 수행.
          1. CreateArrayIterator(_O_, ~key~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.lastindexof">
        <h1>%TypedArray%.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref>에 정의된 `Array.prototype.lastIndexOf` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _len_ = 0 이면 *-1*<sub>𝔽</sub> 반환.
          1. _fromIndex_ 존재하면 _n_ = ? ToIntegerOrInfinity(_fromIndex_); else _n_ = _len_ - 1.
          1. _n_ = -∞ 이면 *-1*<sub>𝔽</sub> 반환.
          1. _n_ ≥ 0 이면
            1. _k_ = min(_n_, _len_ - 1).
          1. Else
            1. _k_ = _len_ + _n_.
          1. _k_ ≥ 0 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kPresent_ = ! HasProperty(_O_, _Pk_).
            1. _kPresent_ = *true* 이면
              1. _elementK_ = ! Get(_O_, _Pk_).
              1. IsStrictlyEqual(_searchElement_, _elementK_) *true* 이면 𝔽(_k_) 반환.
            1. _k_ = _k_ - 1.
          1. *-1*<sub>𝔽</sub> 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.length">
        <h1>get %TypedArray%.prototype.length</h1>
        <p>%TypedArray%`.prototype.length` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]], [[ArrayLength]] 내부 슬롯을 가진다.
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. IsTypedArrayOutOfBounds(_taRecord_) *true* 이면 *+0*<sub>𝔽</sub> 반환.
          1. _length_ = TypedArrayLength(_taRecord_).
          1. 𝔽(_length_) 반환.
        </emu-alg>
        <p>이 함수는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.map">
        <h1>%TypedArray%.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.map"></emu-xref>에 정의된 `Array.prototype.map` 과 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _A_ = ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. _mappedValue_ = ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. ? Set(_A_, _Pk_, _mappedValue_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduce">
        <h1>%TypedArray%.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.reduce"></emu-xref>에 정의된 `Array.prototype.reduce` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _len_ = 0 이고 _initialValue_ 미존재이면 *TypeError* 예외.
          1. _k_ = 0.
          1. _accumulator_ = *undefined*.
          1. _initialValue_ 존재하면
            1. _accumulator_ = _initialValue_.
          1. Else
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _accumulator_ = ! Get(_O_, _Pk_).
            1. _k_ = _k_ + 1.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. _k_ = _k_ + 1.
          1. _accumulator_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduceright">
        <h1>%TypedArray%.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.reduceright"></emu-xref>에 정의된 `Array.prototype.reduceRight` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _len_ = 0 이고 _initialValue_ 미존재이면 *TypeError* 예외.
          1. _k_ = _len_ - 1.
          1. _accumulator_ = *undefined*.
          1. _initialValue_ 존재하면
            1. _accumulator_ = _initialValue_.
          1. Else
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _accumulator_ = ! Get(_O_, _Pk_).
            1. _k_ = _k_ - 1.
          1. _k_ ≥ 0 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. _k_ = _k_ - 1.
          1. _accumulator_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reverse">
        <h1>%TypedArray%.prototype.reverse ( )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.reverse"></emu-xref>에 정의된 `Array.prototype.reverse` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _middle_ = floor(_len_ / 2).
          1. _lower_ = 0.
          1. _lower_ ≠ _middle_ 동안
            1. _upper_ = _len_ - _lower_ - 1.
            1. _upperP_ = ! ToString(𝔽(_upper_)).
            1. _lowerP_ = ! ToString(𝔽(_lower_)).
            1. _lowerValue_ = ! Get(_O_, _lowerP_).
            1. _upperValue_ = ! Get(_O_, _upperP_).
            1. ! Set(_O_, _lowerP_, _upperValue_, *true*).
            1. ! Set(_O_, _upperP_, _lowerValue_, *true*).
            1. _lower_ = _lower_ + 1.
          1. _O_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.set" oldids="sec-%typedarray%.prototype.set-overloaded-offset">
        <h1>%TypedArray%.prototype.set ( _source_ [ , _offset_ ] )</h1>
        <p>이 메서드는 _source_ 로부터 값을 읽어 이 _TypedArray_ 에 여러 값을 설정한다. 구체적 동작은 _source_ 타입에 따라 다르다. 선택적 _offset_ 값은 이 _TypedArray_ 내에서 값이 기록될 첫 요소 인덱스를 나타내며 생략되면 0 으로 간주된다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _target_ = *this* 값.
          1. ? RequireInternalSlot(_target_, [[TypedArrayName]]) 수행.
          1. Assert: _target_ 은 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _targetOffset_ = ? ToIntegerOrInfinity(_offset_).
          1. _targetOffset_ &lt; 0 이면 *RangeError* 예외.
          1. _source_ 가 [[TypedArrayName]] 내부 슬롯을 가진 Object 이면
            1. ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_) 수행.
          1. Else
            1. ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_) 수행.
          1. *undefined* 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>

        <emu-clause id="sec-settypedarrayfromarraylike" type="abstract operation" oldids="sec-%typedarray%.prototype.set-array-offset">
          <h1>
            SetTypedArrayFromArrayLike (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: an ECMAScript language value, but not a TypedArray,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_targetOffset_ 인덱스부터 시작하여 _source_ 로부터 읽은 여러 값을 _target_ 에 설정한다.</dd>
          </dl>
          <emu-alg>
            1. _targetRecord_ = MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).
            1. IsTypedArrayOutOfBounds(_targetRecord_) *true* 이면 *TypeError* 예외.
            1. _targetLength_ = TypedArrayLength(_targetRecord_).
            1. _src_ = ? ToObject(_source_).
            1. _srcLength_ = ? LengthOfArrayLike(_src_).
            1. _targetOffset_ = +∞ 이면 *RangeError* 예외.
            1. _srcLength_ + _targetOffset_ > _targetLength_ 이면 *RangeError* 예외.
            1. _k_ = 0.
            1. _k_ &lt; _srcLength_ 동안 반복
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _value_ = ? Get(_src_, _Pk_).
              1. _targetIndex_ = 𝔽(_targetOffset_ + _k_).
              1. ? TypedArraySetElement(_target_, _targetIndex_, _value_) 수행.
              1. _k_ = _k_ + 1.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>
            SetTypedArrayFromTypedArray (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: a TypedArray,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_targetOffset_ 인덱스부터 시작하여 _source_ 로부터 읽은 여러 값을 _target_ 에 설정한다.</dd>
          </dl>
          <emu-alg>
            1. _targetBuffer_ = _target_.[[ViewedArrayBuffer]].
            1. _targetRecord_ = MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).
            1. IsTypedArrayOutOfBounds(_targetRecord_) *true* 이면 *TypeError* 예외.
            1. _targetLength_ = TypedArrayLength(_targetRecord_).
            1. _srcBuffer_ = _source_.[[ViewedArrayBuffer]].
            1. _srcRecord_ = MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~).
            1. IsTypedArrayOutOfBounds(_srcRecord_) *true* 이면 *TypeError* 예외.
            1. _srcLength_ = TypedArrayLength(_srcRecord_).
            1. _targetType_ = TypedArrayElementType(_target_).
            1. _targetElementSize_ = TypedArrayElementSize(_target_).
            1. _targetByteOffset_ = _target_.[[ByteOffset]].
            1. _srcType_ = TypedArrayElementType(_source_).
            1. _srcElementSize_ = TypedArrayElementSize(_source_).
            1. _srcByteOffset_ = _source_.[[ByteOffset]].
            1. _targetOffset_ = +∞ 이면 *RangeError* 예외.
            1. _srcLength_ + _targetOffset_ > _targetLength_ 이면 *RangeError* 예외.
            1. _target_.[[ContentType]] ≠ _source_.[[ContentType]] 이면 *TypeError* 예외.
            1. IsSharedArrayBuffer(_srcBuffer_) = *true*, IsSharedArrayBuffer(_targetBuffer_) = *true*, 그리고 _srcBuffer_.[[ArrayBufferData]] 가 _targetBuffer_.[[ArrayBufferData]] 와 동일하면 _sameSharedArrayBuffer_ = *true*; 아니면 *false*.
            1. SameValue(_srcBuffer_, _targetBuffer_) = *true* 또는 _sameSharedArrayBuffer_ = *true* 이면
              1. _srcByteLength_ = TypedArrayByteLength(_srcRecord_).
              1. _srcBuffer_ = ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).
              1. _srcByteIndex_ = 0.
            1. Else
              1. _srcByteIndex_ = _srcByteOffset_.
            1. _targetByteIndex_ = (_targetOffset_ × _targetElementSize_) + _targetByteOffset_.
            1. _limit_ = _targetByteIndex_ + (_targetElementSize_ × _srcLength_).
            1. _srcType_ = _targetType_ 이면
              1. NOTE: 전송은 소스 데이터의 비트 수준 인코딩을 보존해야 한다.
              1. _targetByteIndex_ &lt; _limit_ 동안 반복
                1. _value_ = GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).
                1. SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~) 수행.
                1. _srcByteIndex_ = _srcByteIndex_ + 1.
                1. _targetByteIndex_ = _targetByteIndex_ + 1.
            1. Else
              1. _targetByteIndex_ &lt; _limit_ 동안 반복
                1. _value_ = GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~).
                1. SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~) 수행.
                1. _srcByteIndex_ = _srcByteIndex_ + _srcElementSize_.
                1. _targetByteIndex_ = _targetByteIndex_ + _targetElementSize_.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.slice">
        <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.slice"></emu-xref>에 정의된 `Array.prototype.slice` 와 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _srcArrayLength_ = TypedArrayLength(_taRecord_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _startIndex_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _startIndex_ = max(_srcArrayLength_ + _relativeStart_, 0).
          1. Else _startIndex_ = min(_relativeStart_, _srcArrayLength_).
          1. _end_ *undefined* 이면 _relativeEnd_ = _srcArrayLength_; else _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _endIndex_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _endIndex_ = max(_srcArrayLength_ + _relativeEnd_, 0).
          1. Else _endIndex_ = min(_relativeEnd_, _srcArrayLength_).
          1. _countBytes_ = max(_endIndex_ - _startIndex_, 0).
          1. _A_ = ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »).
          1. _countBytes_ > 0 이면
            1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
            1. IsTypedArrayOutOfBounds(_taRecord_) *true* 이면 *TypeError* 예외.
            1. _endIndex_ = min(_endIndex_, TypedArrayLength(_taRecord_)).
            1. _countBytes_ = max(_endIndex_ - _startIndex_, 0).
            1. _srcType_ = TypedArrayElementType(_O_).
            1. _targetType_ = TypedArrayElementType(_A_).
            1. _srcType_ = _targetType_ 이면
              1. NOTE: 전송은 소스 데이터의 비트 수준 인코딩을 보존해야 한다.
              1. _srcBuffer_ = _O_.[[ViewedArrayBuffer]].
              1. _targetBuffer_ = _A_.[[ViewedArrayBuffer]].
              1. _elementSize_ = TypedArrayElementSize(_O_).
              1. _srcByteOffset_ = _O_.[[ByteOffset]].
              1. _srcByteIndex_ = (_startIndex_ × _elementSize_) + _srcByteOffset_.
              1. _targetByteIndex_ = _A_.[[ByteOffset]].
              1. _endByteIndex_ = _targetByteIndex_ + (_countBytes_ × _elementSize_).
              1. _targetByteIndex_ &lt; _endByteIndex_ 동안 반복
                1. _value_ = GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).
                1. SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~) 수행.
                1. _srcByteIndex_ = _srcByteIndex_ + 1.
                1. _targetByteIndex_ = _targetByteIndex_ + 1.
            1. Else
              1. _n_ = 0.
              1. _k_ = _startIndex_.
              1. _k_ &lt; _endIndex_ 동안 반복
                1. _Pk_ = ! ToString(𝔽(_k_)).
                1. _kValue_ = ! Get(_O_, _Pk_).
                1. ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*) 수행.
                1. _k_ = _k_ + 1.
                1. _n_ = _n_ + 1.
          1. _A_ 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.some">
        <h1>%TypedArray%.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드의 인자 해석과 사용은 <emu-xref href="#sec-array.prototype.some"></emu-xref>에 정의된 `Array.prototype.some` 과 동일하다.</p>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _kValue_ = ! Get(_O_, _Pk_).
            1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. _testResult_ = *true* 이면 *true* 반환.
            1. _k_ = _k_ + 1.
          1. *false* 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.sort" oldids="sec-typedarraysortcompare">
        <h1>%TypedArray%.prototype.sort ( _comparator_ )</h1>
        <p>이는 별도의 메서드로서 아래 설명된 부분을 제외하면 <emu-xref href="#sec-array.prototype.sort"></emu-xref>에 정의된 `Array.prototype.sort` 와 동일한 요구사항을 구현한다. 이 메서드 구현은 *this* 값이 길이가 고정된 객체이며 정수 인덱스 프로퍼티가 희소하지 않다는 사실을 활용해 최적화될 수 있다.</p>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _comparator_ ≠ *undefined* 이고 IsCallable(_comparator_) = *false* 이면 *TypeError* 예외.
          1. _obj_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_obj_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. NOTE: 다음 클로저는 <emu-xref href="#sec-array.prototype.sort"></emu-xref>에서 수행되는 문자열 비교 대신 수치 비교를 수행한다.
          1. _SortCompare_ 를 (_x_, _y_) 매개변수로 하고 _comparator_ 를 캡처하여 호출 시 ? CompareTypedArrayElements(_x_, _y_, _comparator_) 를 반환하는 새 추상 클로저로 둔다.
          1. _sortedList_ = ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).
          1. _j_ = 0.
          1. _j_ &lt; _len_ 동안 반복
            1. ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*) 수행.
            1. _j_ = _j_ + 1.
          1. _obj_ 반환.
        </emu-alg>
        <emu-note>
          <p>*NaN* 은 (CompareTypedArrayElements 참조) 다른 어떤 값보다 항상 크게 비교되므로 _comparator_ 가 제공되지 않을 때 *NaN* 값은 결과 끝에 정렬된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.subarray">
        <h1>%TypedArray%.prototype.subarray ( _start_, _end_ )</h1>
        <p>이 메서드는 새로운 _TypedArray_ 를 반환하며 그 요소 타입은 이 _TypedArray_ 의 요소 타입과 같고, ArrayBuffer 는 동일한 ArrayBuffer 를 사용하며 _start_ (포함) 부터 _end_ (배타) 전까지의 요소를 참조한다. _start_ 또는 _end_ 가 음수이면 배열의 끝을 기준으로 하는 인덱스를 의미한다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _buffer_ = _O_.[[ViewedArrayBuffer]].
          1. _srcRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. IsTypedArrayOutOfBounds(_srcRecord_) *true* 이면
            1. _srcLength_ = 0.
          1. Else
            1. _srcLength_ = TypedArrayLength(_srcRecord_).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _startIndex_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _startIndex_ = max(_srcLength_ + _relativeStart_, 0).
          1. Else _startIndex_ = min(_relativeStart_, _srcLength_).
          1. _elementSize_ = TypedArrayElementSize(_O_).
          1. _srcByteOffset_ = _O_.[[ByteOffset]].
          1. _beginByteOffset_ = _srcByteOffset_ + (_startIndex_ × _elementSize_).
          1. _O_.[[ArrayLength]] 가 ~auto~ 이고 _end_ 가 *undefined* 이면
            1. _argumentsList_ = « _buffer_, 𝔽(_beginByteOffset_) ».
          1. Else
            1. _end_ *undefined* 이면 _relativeEnd_ = _srcLength_; else _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
            1. _relativeEnd_ = -∞ 이면 _endIndex_ = 0.
            1. Else if _relativeEnd_ &lt; 0 이면 _endIndex_ = max(_srcLength_ + _relativeEnd_, 0).
            1. Else _endIndex_ = min(_relativeEnd_, _srcLength_).
            1. _newLength_ = max(_endIndex_ - _startIndex_, 0).
            1. _argumentsList_ = « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) ».
          1. ? TypedArraySpeciesCreate(_O_, _argumentsList_) 반환.
        </emu-alg>
        <p>이 메서드는 제네릭이 아니다. *this* 값은 [[TypedArrayName]] 내부 슬롯을 가진 객체여야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tolocalestring">
        <h1>%TypedArray%.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>이 별도 메서드는 <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref>에 정의된 `Array.prototype.toLocaleString` 과 동일한 알고리즘을 구현하되 *"length"* 에 대한 [[Get]] 대신 TypedArrayLength 를 호출한다. 기본 버퍼가 리사이즈 가능하지 않고 정수 인덱스 프로퍼티가 희소하지 않음을 이용해 최적화할 수 있으나, 그러한 최적화는 알고리즘의 지정된 동작에 관측 가능한 변화를 초래해서는 안 된다.</p>
        <p>이 메서드는 제네릭이 아니다. 알고리즘 평가 전에 *this* 값과 ~seq-cst~ 를 인자로 ValidateTypedArray 가 호출된다. 그 결과가 abrupt completion 이면 해당 예외가 알고리즘 대신 던져진다.</p>
        <emu-note>
          <p>ECMAScript 구현이 ECMA-402 국제화 API 를 포함한다면 이 메서드는 ECMA-402 명세에 있는 `Array.prototype.toLocaleString` 알고리즘을 기반으로 한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.toreversed">
        <h1>%TypedArray%.prototype.toReversed ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _A_ = ? TypedArrayCreateSameType(_O_, _len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _from_ = ! ToString(𝔽(_len_ - _k_ - 1)).
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _fromValue_ = ! Get(_O_, _from_).
            1. ! Set(_A_, _Pk_, _fromValue_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tosorted">
        <h1>%TypedArray%.prototype.toSorted ( _comparator_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _comparator_ ≠ *undefined* 그리고 IsCallable(_comparator_) = *false* 이면 *TypeError* 예외.
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _A_ = ? TypedArrayCreateSameType(_O_, _len_).
          1. NOTE: 다음 클로저는 <emu-xref href="#sec-array.prototype.tosorted"></emu-xref> 에서의 문자열 비교 대신 수치 비교를 수행한다.
          1. _SortCompare_ 를 (_x_, _y_) → ? CompareTypedArrayElements(_x_, _y_, _comparator_) 클로저로 둔다.
          1. _sortedList_ = ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).
          1. _j_ = 0.
          1. _j_ &lt; _len_ 동안 반복
            1. ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*) 수행.
            1. _j_ = _j_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tostring">
        <h1>%TypedArray%.prototype.toString ( )</h1>
        <p>*"toString"* 프로퍼티의 초기 값은 <emu-xref href="#sec-array.prototype.tostring"></emu-xref>에 정의된 %Array.prototype.toString% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.values">
        <h1>%TypedArray%.prototype.values ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? ValidateTypedArray(_O_, ~seq-cst~) 수행.
          1. CreateArrayIterator(_O_, ~value~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.with">
        <h1>%TypedArray%.prototype.with ( _index_, _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _taRecord_ = ? ValidateTypedArray(_O_, ~seq-cst~).
          1. _len_ = TypedArrayLength(_taRecord_).
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_).
          1. _relativeIndex_ ≥ 0 이면 _actualIndex_ = _relativeIndex_; Else _actualIndex_ = _len_ + _relativeIndex_.
          1. _O_.[[ContentType]] = ~bigint~ 이면 _numericValue_ = ? ToBigInt(_value_).
          1. Else _numericValue_ = ? ToNumber(_value_).
          1. IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) *false* 이면 *RangeError* 예외.
          1. _A_ = ? TypedArrayCreateSameType(_O_, _len_).
          1. _k_ = 0.
          1. _k_ &lt; _len_ 동안 반복
            1. _Pk_ = ! ToString(𝔽(_k_)).
            1. _k_ = _actualIndex_ 이면 _fromValue_ = _numericValue_; Else _fromValue_ = ! Get(_O_, _Pk_).
            1. ! Set(_A_, _Pk_, _fromValue_, *true*) 수행.
            1. _k_ = _k_ + 1.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%typedarray%.prototype-@@iterator" id="sec-%typedarray%.prototype-%symbol.iterator%">
        <h1>%TypedArray%.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 프로퍼티의 초기 값은 <emu-xref href="#sec-%typedarray%.prototype.values"></emu-xref>에 정의된 %TypedArray.prototype.values% 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%.prototype-@@tostringtag" id="sec-get-%typedarray%.prototype-%symbol.tostringtag%">
        <h1>get %TypedArray%.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%TypedArray%`.prototype[%Symbol.toStringTag%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. _O_ 가 Object 가 아니면 *undefined* 반환.
          1. _O_ 가 [[TypedArrayName]] 내부 슬롯을 가지지 않으면 *undefined* 반환.
          1. _name_ = _O_.[[TypedArrayName]].
          1. Assert: _name_ 은 String.
          1. _name_ 반환.
        </emu-alg>
        <p>이 프로퍼티는 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        <p>이 함수의 *"name"* 프로퍼티 초기 값은 *"get [Symbol.toStringTag]"* 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-typedarray-objects">
      <h1>TypedArray 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-typedarraycreatefromconstructor" oldids="typedarray-create" type="abstract operation">
        <h1>
          TypedArrayCreateFromConstructor (
            _constructor_: a constructor,
            _argumentList_: a List of ECMAScript language values,
          ): TypedArray 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>생성자 함수를 사용하여 새로운 TypedArray 를 생성하는 과정을 지정한다.</dd>
        </dl>
        <emu-alg>
          1. _newTypedArray_ = ? Construct(_constructor_, _argumentList_).
          1. _taRecord_ = ? ValidateTypedArray(_newTypedArray_, ~seq-cst~).
          1. Assert: _newTypedArray_ 는 <emu-xref href="#sec-properties-of-typedarray-instances" title></emu-xref>에 언급된 모든 내부 슬롯을 가진다.
          1. _argumentList_ 요소 수가 1 이고 _argumentList_[0] 이 Number 이면
            1. IsTypedArrayOutOfBounds(_taRecord_) *true* 이면 *TypeError* 예외.
            1. _length_ = TypedArrayLength(_taRecord_).
            1. _length_ &lt; ℝ(_argumentList_[0]) 이면 *TypeError* 예외.
          1. _newTypedArray_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-create-same-type" type="abstract operation">
        <h1>
          TypedArrayCreateSameType (
            _exemplar_: a TypedArray,
            _length_: a non-negative integer,
          ): TypedArray 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>이 연산은 _exemplar_에서 파생된 생성자 함수를 사용하여 새로운 TypedArray를 생성하도록 지정하는 데 사용됩니다. %Symbol.species%를 통해 커스텀 TypedArray 하위 클래스를 생성할 수 있는 TypedArraySpeciesCreate와 달리, 이 연산은 항상 내장 TypedArray 생성자 중 하나만을 사용합니다.</dd>
        </dl>
        <emu-alg>
          1. _constructor_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _exemplar_.[[TypedArrayName]] 생성자 이름에 연관된 내재 객체.
          1. _result_ = ? <emu-meta suppress-effects="user-code">TypedArrayCreateFromConstructor(_constructor_, « 𝔽(_length_) »)</emu-meta>.
          1. Assert: _result_ 는 [[TypedArrayName]], [[ContentType]] 내부 슬롯을 가진다.
          1. Assert: _result_.[[ContentType]] = _exemplar_.[[ContentType]].
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-species-create" type="abstract operation">
        <h1>
          TypedArraySpeciesCreate (
            _exemplar_: a TypedArray,
            _argumentList_: a List of ECMAScript language values,
          ): TypedArray 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_exemplar_ 에서 파생된 생성자 함수를 사용하여 새로운 TypedArray 를 생성한다. ArraySpeciesCreate 가 %Symbol.species% 를 통해 비-Array 객체를 만들 수 있는 것과 달리 이 연산은 실제 TypedArray 생성자임을 강제한다.</dd>
        </dl>
        <emu-alg>
          1. _defaultConstructor_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _exemplar_.[[TypedArrayName]] 생성자 이름에 연관된 내재 객체.
          1. _constructor_ = ? SpeciesConstructor(_exemplar_, _defaultConstructor_).
          1. _result_ = ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).
          1. _result_.[[ContentType]] ≠ _exemplar_.[[ContentType]] 이면 *TypeError* 예외.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validatetypedarray" type="abstract operation">
        <h1>
          ValidateTypedArray (
            _O_: an ECMAScript language value,
            _order_: ~seq-cst~ or ~unordered~,
          ): TypedArray With Buffer Witness Record 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_O_, [[TypedArrayName]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_O_, _order_).
          1. IsTypedArrayOutOfBounds(_taRecord_) *true* 이면 *TypeError* 예외.
          1. _taRecord_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementsize" type="abstract operation">
        <h1>
          TypedArrayElementSize (
            _O_: a TypedArray,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _O_.[[TypedArrayName]] 에 대해 지정된 요소 크기(Element Size) 값을 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementtype" type="abstract operation">
        <h1>
          TypedArrayElementType (
            _O_: a TypedArray,
          ): TypedArray element type
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _O_.[[TypedArrayName]] 에 대해 지정된 요소 타입(Element Type) 값을 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-comparetypedarrayelements" type="abstract operation">
        <h1>
          CompareTypedArrayElements (
            _x_: a Number or a BigInt,
            _y_: a Number or a BigInt,
            _comparator_: a function object or *undefined*,
          ): Number 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _x_, _y_ 둘 다 Number 이거나 둘 다 BigInt.
          1. _comparator_ ≠ *undefined* 이면
            1. _v_ = ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »)).
            1. _v_ 가 *NaN* 이면 *+0*<sub>𝔽</sub> 반환.
            1. _v_ 반환.
          1. _x_ 와 _y_ 모두 *NaN* 이면 *+0*<sub>𝔽</sub> 반환.
          1. _x_ 가 *NaN* 이면 *1*<sub>𝔽</sub> 반환.
          1. _y_ 가 *NaN* 이면 *-1*<sub>𝔽</sub> 반환.
          1. _x_ &lt; _y_ 이면 *-1*<sub>𝔽</sub> 반환.
          1. _x_ > _y_ 이면 *1*<sub>𝔽</sub> 반환.
          1. _x_ 가 *-0*<sub>𝔽</sub> 이고 _y_ 가 *+0*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. _x_ 가 *+0*<sub>𝔽</sub> 이고 _y_ 가 *-0*<sub>𝔽</sub> 이면 *1*<sub>𝔽</sub> 반환.
          1. *+0*<sub>𝔽</sub> 반환.
        </emu-alg>
        <emu-note>
          이는 <emu-xref href="#sec-comparearrayelements"></emu-xref>에서의 문자열 비교 대신 수치 비교를 수행한다.
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-constructors">
      <h1>_TypedArray_ 생성자</h1>
      <p>각 _TypedArray_ 생성자는 다음을 만족한다:</p>
      <ul>
        <li>내재 객체로, 아래에 설명된 구조를 가지며, <emu-xref href="#table-the-typedarray-constructors"></emu-xref>에서 별도로 명시하지 않는 한, 생성자 이름에 _TypedArray_ 대신 다른 이름이 사용된다는 점만 다릅니다.</li>
        <li>인자의 개수와 유형에 따라 동작이 달라지는 함수입니다. _TypedArray_를 호출할 때 실제 동작은 전달된 인자의 개수와 종류에 따라 결정됩니다.</li>
        <li>함수로 호출하는 용도가 아니며, 그렇게 호출할 경우 예외가 발생합니다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있습니다. 지정된 _TypedArray_ 동작을 상속받으려는 서브클래스 생성자는, %TypedArray%`.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성 및 초기화하기 위해 _TypedArray_ 생성자에 대한 `super` 호출을 포함해야 합니다.</li>
      </ul>

      <emu-clause id="sec-typedarray" oldids="sec-typedarray-length,sec-typedarray-object">
        <h1>_TypedArray_ ( ..._args_ )</h1>
        <p>각 _TypedArray_ 생성자는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _constructorName_ = 이 <var>TypedArray</var> 생성자에 대해 <emu-xref href="#table-the-typedarray-constructors"></emu-xref>에 지정된 Constructor Name 값의 String.
          1. _proto_ = <code>"%<var>TypedArray</var>.prototype%"</code>.
          1. _numberOfArgs_ = _args_ 의 요소 개수.
          1. _numberOfArgs_ = 0 이면
            1. ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0) 반환.
          1. Else
            1. _firstArgument_ = _args_[0].
            1. _firstArgument_ 가 Object 이면
              1. _O_ = ? AllocateTypedArray(_constructorName_, NewTarget, _proto_).
              1. _firstArgument_ 가 [[TypedArrayName]] 내부 슬롯을 가지면
                1. ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_) 수행.
              1. Else if _firstArgument_ 가 [[ArrayBufferData]] 내부 슬롯을 가지면
                1. _numberOfArgs_ > 1 이면 _byteOffset_ = _args_[1]; else _byteOffset_ = *undefined*.
                1. _numberOfArgs_ > 2 이면 _length_ = _args_[2]; else _length_ = *undefined*.
                1. ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_) 수행.
              1. Else
                1. Assert: _firstArgument_ 는 [[TypedArrayName]] 도 [[ArrayBufferData]] 도 없는 Object.
                1. _usingIterator_ = ? GetMethod(_firstArgument_, %Symbol.iterator%).
                1. _usingIterator_ ≠ *undefined* 이면
                  1. _values_ = ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_)).
                  1. ? InitializeTypedArrayFromList(_O_, _values_) 수행.
                1. Else
                  1. NOTE: _firstArgument_ 는 이터러블이 아니므로 배열 유사 객체로 간주.
                  1. ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_) 수행.
              1. _O_ 반환.
            1. Else
              1. Assert: _firstArgument_ 는 Object 가 아님.
              1. _elementLength_ = ? ToIndex(_firstArgument_).
              1. ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_) 반환.
        </emu-alg>

        <emu-clause id="sec-allocatetypedarray" type="abstract operation">
          <h1>
            AllocateTypedArray (
              _constructorName_: <emu-xref href="#table-the-typedarray-constructors"></emu-xref>에 있는 TypedArray 생성자 이름인 String,
              _newTarget_: a constructor,
              _defaultProto_: a String,
              optional _length_: a non-negative integer,
            ): TypedArray 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>TypedArray 생성자의 인스턴스를 검증하고 생성하는 데 사용된다. _length_ 인자가 전달되면 해당 길이의 ArrayBuffer 를 할당해 새 TypedArray 인스턴스와 연관시킨다. AllocateTypedArray 는 _TypedArray_ 가 사용하는 공통 의미를 제공한다.</dd>
          </dl>
          <emu-alg>
            1. _proto_ = ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).
            1. _obj_ = TypedArrayCreate(_proto_).
            1. Assert: _obj_.[[ViewedArrayBuffer]] 는 *undefined*.
            1. _obj_.[[TypedArrayName]] = _constructorName_.
            1. _constructorName_ 이 *"BigInt64Array"* 또는 *"BigUint64Array"* 이면 _obj_.[[ContentType]] = ~bigint~.
            1. 아니면 _obj_.[[ContentType]] = ~number~.
            1. _length_ 미존재이면
              1. _obj_.[[ByteLength]] = 0.
              1. _obj_.[[ByteOffset]] = 0.
              1. _obj_.[[ArrayLength]] = 0.
            1. Else
              1. ? AllocateTypedArrayBuffer(_obj_, _length_) 수행.
            1. _obj_ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray">
          <h1>
            InitializeTypedArrayFromTypedArray (
              _O_: a TypedArray,
              _srcArray_: a TypedArray,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _srcData_ = _srcArray_.[[ViewedArrayBuffer]].
            1. _elementType_ = TypedArrayElementType(_O_).
            1. _elementSize_ = TypedArrayElementSize(_O_).
            1. _srcType_ = TypedArrayElementType(_srcArray_).
            1. _srcElementSize_ = TypedArrayElementSize(_srcArray_).
            1. _srcByteOffset_ = _srcArray_.[[ByteOffset]].
            1. _srcRecord_ = MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~).
            1. IsTypedArrayOutOfBounds(_srcRecord_) *true* 이면 *TypeError* 예외.
            1. _elementLength_ = TypedArrayLength(_srcRecord_).
            1. _byteLength_ = _elementSize_ × _elementLength_.
            1. _elementType_ = _srcType_ 이면
              1. _data_ = ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).
            1. Else
              1. _data_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
              1. _srcArray_.[[ContentType]] ≠ _O_.[[ContentType]] 이면 *TypeError* 예외.
              1. _srcByteIndex_ = _srcByteOffset_.
              1. _targetByteIndex_ = 0.
              1. _count_ = _elementLength_.
              1. _count_ > 0 동안 반복
                1. _value_ = GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~).
                1. SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~) 수행.
                1. _srcByteIndex_ = _srcByteIndex_ + _srcElementSize_.
                1. _targetByteIndex_ = _targetByteIndex_ + _elementSize_.
                1. _count_ = _count_ - 1.
            1. _O_.[[ViewedArrayBuffer]] = _data_.
            1. _O_.[[ByteLength]] = _byteLength_.
            1. _O_.[[ByteOffset]] = 0.
            1. _O_.[[ArrayLength]] = _elementLength_.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length">
          <h1>
            InitializeTypedArrayFromArrayBuffer (
              _O_: a TypedArray,
              _buffer_: an ArrayBuffer or a SharedArrayBuffer,
              _byteOffset_: an ECMAScript language value,
              _length_: an ECMAScript language value,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _elementSize_ = TypedArrayElementSize(_O_).
            1. _offset_ = ? ToIndex(_byteOffset_).
            1. _offset_ modulo _elementSize_ ≠ 0 이면 *RangeError* 예외.
            1. _bufferIsFixedLength_ = IsFixedLengthArrayBuffer(_buffer_).
            1. _length_ ≠ *undefined* 이면
              1. _newLength_ = ? ToIndex(_length_).
            1. IsDetachedBuffer(_buffer_) *true* 이면 *TypeError* 예외.
            1. _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~).
            1. _length_ = *undefined* 이고 _bufferIsFixedLength_ = *false* 이면
              1. _offset_ > _bufferByteLength_ 이면 *RangeError* 예외.
              1. _O_.[[ByteLength]] = ~auto~.
              1. _O_.[[ArrayLength]] = ~auto~.
            1. Else
              1. _length_ = *undefined* 이면
                1. _bufferByteLength_ modulo _elementSize_ ≠ 0 이면 *RangeError* 예외.
                1. _newByteLength_ = _bufferByteLength_ - _offset_.
                1. _newByteLength_ &lt; 0 이면 *RangeError* 예외.
              1. Else
                1. _newByteLength_ = _newLength_ × _elementSize_.
                1. _offset_ + _newByteLength_ > _bufferByteLength_ 이면 *RangeError* 예외.
              1. _O_.[[ByteLength]] = _newByteLength_.
              1. _O_.[[ArrayLength]] = _newByteLength_ / _elementSize_.
            1. _O_.[[ViewedArrayBuffer]] = _buffer_.
            1. _O_.[[ByteOffset]] = _offset_.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromlist" type="abstract operation">
          <h1>
            InitializeTypedArrayFromList (
              _O_: a TypedArray,
              _values_: a List of ECMAScript language values,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _len_ = _values_ 요소 개수.
            1. ? AllocateTypedArrayBuffer(_O_, _len_) 수행.
            1. _k_ = 0.
            1. _k_ &lt; _len_ 동안 반복
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _kValue_ = _values_ 의 첫 요소.
              1. _values_ 의 첫 요소 제거.
              1. ? Set(_O_, _Pk_, _kValue_, *true*) 수행.
              1. _k_ = _k_ + 1.
            1. Assert: _values_ 는 이제 빈 List.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraylike" type="abstract operation">
          <h1>
            InitializeTypedArrayFromArrayLike (
              _O_: a TypedArray,
              _arrayLike_: an Object, but not a TypedArray or an ArrayBuffer,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _len_ = ? LengthOfArrayLike(_arrayLike_).
            1. ? AllocateTypedArrayBuffer(_O_, _len_) 수행.
            1. _k_ = 0.
            1. _k_ &lt; _len_ 동안 반복
              1. _Pk_ = ! ToString(𝔽(_k_)).
              1. _kValue_ = ? Get(_arrayLike_, _Pk_).
              1. ? Set(_O_, _Pk_, _kValue_, *true*) 수행.
              1. _k_ = _k_ + 1.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allocatetypedarraybuffer" type="abstract operation">
          <h1>
            AllocateTypedArrayBuffer (
              _O_: a TypedArray,
              _length_: a non-negative integer,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_O_ 에 ArrayBuffer 를 할당하고 연관시킨다.</dd>
          </dl>
          <emu-alg>
            1. Assert: _O_.[[ViewedArrayBuffer]] 는 *undefined*.
            1. _elementSize_ = TypedArrayElementSize(_O_).
            1. _byteLength_ = _elementSize_ × _length_.
            1. _data_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
            1. _O_.[[ViewedArrayBuffer]] = _data_.
            1. _O_.[[ByteLength]] = _byteLength_.
            1. _O_.[[ByteOffset]] = 0.
            1. _O_.[[ArrayLength]] = _length_.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>_TypedArray_ 생성자들의 프로퍼티</h1>
      <p>각 _TypedArray_ 생성자는 다음을 가진다:</p>
      <ul>
        <li>값이 %TypedArray% 인 [[Prototype]] 내부 슬롯.</li>
        <li>값이 *3*<sub>𝔽</sub> 인 *"length"* 프로퍼티.</li>
        <li><emu-xref href="#table-the-typedarray-constructors"></emu-xref>에 지정된 생성자 이름의 String 값인 *"name"* 프로퍼티.</li>
        <li>다음 프로퍼티들:</li>
      </ul>

      <emu-clause id="sec-typedarray.bytes_per_element">
        <h1>_TypedArray_.BYTES_PER_ELEMENT</h1>
        <p>_TypedArray_`.BYTES_PER_ELEMENT` 의 값은 <emu-xref href="#table-the-typedarray-constructors"></emu-xref>에서 _TypedArray_ 에 대해 지정된 요소 크기(Element Size) 값이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype">
        <h1>_TypedArray_.prototype</h1>
        <p>_TypedArray_`.prototype` 의 초기 값은 해당하는 _TypedArray_ 프로토타입 내재 객체(<emu-xref href="#sec-properties-of-typedarray-prototype-objects"></emu-xref>)이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-prototype-objects">
      <h1>_TypedArray_ 프로토타입 객체들의 프로퍼티</h1>
      <p>각 _TypedArray_ 프로토타입 객체는 다음을 가진다:</p>
      <ul>
        <li>값이 %TypedArray.prototype% 인 [[Prototype]] 내부 슬롯.</li>
        <li>일반 객체.</li>
        <li>[[ViewedArrayBuffer]] 및 _TypedArray_ 인스턴스 전용의 다른 내부 슬롯이 없다.</li>
      </ul>

      <emu-clause id="sec-typedarray.prototype.bytes_per_element">
        <h1>_TypedArray_.prototype.BYTES_PER_ELEMENT</h1>
        <p>_TypedArray_`.prototype.BYTES_PER_ELEMENT` 의 값은 <emu-xref href="#table-the-typedarray-constructors"></emu-xref>에서 _TypedArray_ 에 대해 지정된 요소 크기(Element Size) 값이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype.constructor">
        <h1>_TypedArray_.prototype.constructor</h1>
        <p>주어진 _TypedArray_ 생성자에 대한 프로토타입의 *"constructor"* 프로퍼티 초기 값은 그 생성자 자신이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-instances">
      <h1>_TypedArray_ 인스턴스의 프로퍼티</h1>
      <p>_TypedArray_ 인스턴스는 TypedArray 이다. 각 _TypedArray_ 인스턴스는 해당 _TypedArray_ 프로토타입 객체로부터 프로퍼티를 상속한다. 각 _TypedArray_ 인스턴스는 내부 슬롯 [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] 를 가진다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-uint8array">
    <h1>Uint8Array 객체</h1>
    <p>Uint8Array는 위에서 설명한 _TypedArray_의 한 종류입니다. 추가적으로, Uint8Array 생성자(<emu-xref href="#sec-additional-properties-of-the-uint8array-constructor"></emu-xref>)와 Uint8Array 프로토타입 객체(<emu-xref href="#sec-additional-properties-of-the-uint8array-prototype-object"></emu-xref>)에는 추가 메서드들이 있습니다.</p>

    <emu-clause id="sec-additional-properties-of-the-uint8array-constructor">
      <h1>Uint8Array 생성자의 추가 속성</h1>

      <emu-clause id="sec-uint8array.frombase64">
        <h1>Uint8Array.fromBase64 ( _string_ [ , _options_ ] )</h1>
        <emu-alg>
          1. _string_이 String이 아니면, *TypeError* 예외를 throw한다.
          1. _opts_를 ? GetOptionsObject(_options_)로 둔다.
          1. _alphabet_을 ? Get(_opts_, *"alphabet"*)로 둔다.
          1. _alphabet_이 *undefined*이면, _alphabet_을 *"base64"*로 설정한다.
          1. _alphabet_이 *"base64"* 또는 *"base64url"*이 아니면, *TypeError* 예외를 throw한다.
          1. _lastChunkHandling_을 ? Get(_opts_, *"lastChunkHandling"*)로 둔다.
          1. _lastChunkHandling_이 *undefined*이면, _lastChunkHandling_을 *"loose"*로 설정한다.
          1. _lastChunkHandling_이 *"loose"*, *"strict"*, *"stop-before-partial"* 중 하나가 아니면, *TypeError* 예외를 throw한다.
          1. _result_를 FromBase64(_string_, _alphabet_, _lastChunkHandling_)로 둔다.
          1. _result_.[[Error]]가 ~none~이 아니면,
            1. Return ThrowCompletion(_result_.[[Error]]).
          1. _resultLength_을 _result_.[[Bytes]]의 요소 개수로 둔다.
          1. _ta_를 ? <emu-meta suppress-effects="user-code">AllocateTypedArray(*"Uint8Array"*, %Uint8Array%, *"%Uint8Array.prototype%"*, _resultLength_)</emu-meta>로 둔다.
          1. Assert: _ta_.[[ViewedArrayBuffer]].[[ArrayBufferByteLength]]는 _result_.[[Bytes]]의 요소 개수와 같다.
          1. _ta_.[[ViewedArrayBuffer]].[[ArrayBufferData]]의 각 인덱스 값을 _result_.[[Bytes]]의 해당 인덱스 값으로 설정한다.
          1. _ta_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-uint8array.fromhex">
        <h1>Uint8Array.fromHex ( _string_ )</h1>
        <emu-alg>
          1. _string_이 String이 아니면, *TypeError* 예외를 throw한다.
          1. _result_를 FromHex(_string_)로 둔다.
          1. _result_.[[Error]]가 ~none~이 아니면,
            1. Return ThrowCompletion(_result_.[[Error]]).
          1. _resultLength_을 _result_.[[Bytes]]의 요소 개수로 둔다.
          1. _ta_를 ? <emu-meta suppress-effects="user-code">AllocateTypedArray(*"Uint8Array"*, %Uint8Array%, *"%Uint8Array.prototype%"*, _resultLength_)</emu-meta>로 둔다.
          1. Assert: _ta_.[[ViewedArrayBuffer]].[[ArrayBufferByteLength]]는 _result_.[[Bytes]]의 요소 개수와 같다.
          1. _ta_.[[ViewedArrayBuffer]].[[ArrayBufferData]]의 각 인덱스 값을 _result_.[[Bytes]]의 해당 인덱스 값으로 설정한다.
          1. _ta_를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-additional-properties-of-the-uint8array-prototype-object">
      <h1>Uint8Array 프로토타입 객체의 추가 속성</h1>

      <emu-clause id="sec-uint8array.prototype.setfrombase64">
        <h1>Uint8Array.prototype.setFromBase64 ( _string_ [ , _options_ ] )</h1>
        <emu-alg>
          1. _into_를 *this* 값으로 둔다.
          1. ? ValidateUint8Array(_into_)를 수행한다.
          1. _string_이 String이 아니면, *TypeError* 예외를 throw한다.
          1. _opts_를 ? GetOptionsObject(_options_)로 둔다.
          1. _alphabet_을 ? Get(_opts_, *"alphabet"*)로 둔다.
          1. _alphabet_이 *undefined*이면, _alphabet_을 *"base64"*로 설정한다.
          1. _alphabet_이 *"base64"* 또는 *"base64url"*이 아니면, *TypeError* 예외를 throw한다.
          1. _lastChunkHandling_을 ? Get(_opts_, *"lastChunkHandling"*)로 둔다.
          1. _lastChunkHandling_이 *undefined*이면, _lastChunkHandling_을 *"loose"*로 설정한다.
          1. _lastChunkHandling_이 *"loose"*, *"strict"*, *"stop-before-partial"* 중 하나가 아니면, *TypeError* 예외를 throw한다.
          1. _taRecord_를 MakeTypedArrayWithBufferWitnessRecord(_into_, ~seq-cst~)로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_)가 *true*이면, *TypeError* 예외를 throw한다.
          1. _byteLength_를 TypedArrayLength(_taRecord_)로 둔다.
          1. _result_를 FromBase64(_string_, _alphabet_, _lastChunkHandling_, _byteLength_)로 둔다.
          1. _bytes_를 _result_.[[Bytes]]로 둔다.
          1. _written_을 _bytes_의 요소 개수로 둔다.
          1. 참고: FromBase64는 사용자 코드를 실행하지 않으므로, _into_의 ArrayBuffer는 분리되거나 크기가 줄어들 수 없다.
          1. Assert: _written_ ≤ _byteLength_.
          1. SetUint8ArrayBytes(_into_, _bytes_)를 수행한다.
          1. _result_.[[Error]]가 ~none~이 아니면,
            1. Return ThrowCompletion(_result_.[[Error]]).
          1. _resultObject_를 OrdinaryObjectCreate(%Object.prototype%)로 둔다.
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"read"*, 𝔽(_result_.[[Read]]))를 수행한다.
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"written"*, 𝔽(_written_))를 수행한다.
          1. _resultObject_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-uint8array.prototype.setfromhex">
        <h1>Uint8Array.prototype.setFromHex ( _string_ )</h1>
        <emu-alg>
          1. _into_를 *this* 값으로 둔다.
          1. ? ValidateUint8Array(_into_)를 수행한다.
          1. _string_이 String이 아니면, *TypeError* 예외를 throw한다.
          1. _taRecord_를 MakeTypedArrayWithBufferWitnessRecord(_into_, ~seq-cst~)로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_)가 *true*이면, *TypeError* 예외를 throw한다.
          1. _byteLength_를 TypedArrayLength(_taRecord_)로 둔다.
          1. _result_를 FromHex(_string_, _byteLength_)로 둔다.
          1. _bytes_를 _result_.[[Bytes]]로 둔다.
          1. _written_을 _bytes_의 요소 개수로 둔다.
          1. 참고: FromHex는 사용자 코드를 실행하지 않으므로, _into_의 ArrayBuffer는 분리되거나 크기가 줄어들 수 없다.
          1. Assert: _written_ ≤ _byteLength_.
          1. SetUint8ArrayBytes(_into_, _bytes_)를 수행한다.
          1. _result_.[[Error]]가 ~none~이 아니면,
            1. Return ThrowCompletion(_result_.[[Error]]).
          1. _resultObject_를 OrdinaryObjectCreate(%Object.prototype%)로 둔다.
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"read"*, 𝔽(_result_.[[Read]]))를 수행한다.
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"written"*, 𝔽(_written_))를 수행한다.
          1. _resultObject_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-uint8array.prototype.tobase64">
        <h1>Uint8Array.prototype.toBase64 ( [ _options_ ] )</h1>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? ValidateUint8Array(_O_)를 수행한다.
          1. _opts_를 ? GetOptionsObject(_options_)로 둔다.
          1. _alphabet_을 ? Get(_opts_, *"alphabet"*)로 둔다.
          1. _alphabet_이 *undefined*이면, _alphabet_을 *"base64"*로 설정한다.
          1. _alphabet_이 *"base64"* 또는 *"base64url"*이 아니면, *TypeError* 예외를 throw한다.
          1. _omitPadding_을 ToBoolean(? Get(_opts_, *"omitPadding"*)))로 둔다.
          1. _toEncode_를 ? GetUint8ArrayBytes(_O_)로 둔다.
          1. _alphabet_이 *"base64"*라면,
            1. _outAscii_를 <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 4절에 명시된 base64 인코딩에 따라 _toEncode_를 인코딩한 결과의 코드 포인트 시퀀스로 둔다. 패딩은 _omitPadding_이 *false*일 때만 포함된다.
          1. 그렇지 않으면,
            1. Assert: _alphabet_이 *"base64url"*임.
            1. _outAscii_를 <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 5절에 명시된 base64url 인코딩에 따라 _toEncode_를 인코딩한 결과의 코드 포인트 시퀀스로 둔다. 패딩은 _omitPadding_이 *false*일 때만 포함된다.
          1. CodePointsToString(_outAscii_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-uint8array.prototype.tohex">
        <h1>Uint8Array.prototype.toHex ( )</h1>
        <emu-alg>
          1. _O_를 *this* 값으로 둔다.
          1. ? ValidateUint8Array(_O_)를 수행한다.
          1. _toEncode_를 ? GetUint8ArrayBytes(_O_)로 둔다.
          1. _out_을 빈 문자열로 둔다.
          1. _toEncode_의 각 바이트 _byte_에 대해,
            1. _hex_를 Number::toString(𝔽(_byte_), 16)으로 둔다.
            1. _hex_를 StringPad(_hex_, 2, *"0"*, ~start~)로 설정한다.
            1. _out_을 _out_과 _hex_의 문자열 연결 결과로 설정한다.
          1. _out_을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-uint8array-objects">
      <h1>Uint8Array 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-validateuint8array" type="abstract operation">
        <h1>
          ValidateUint8Array (
            _ta_: ECMAScript 언어 값,
          ): ~unused~를 포함하는 normal completion 또는 throw completion 중 하나
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. ? RequireInternalSlot(_ta_, [[TypedArrayName]])를 수행한다.
          1. _ta_.[[TypedArrayName]]이 *"Uint8Array"*가 아니면, *TypeError* 예외를 throw한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getuint8arraybytes" type="abstract operation">
        <h1>
          GetUint8ArrayBytes (
            _ta_: Uint8Array,
          ): 바이트 값의 List를 포함하는 normal completion 또는 throw completion 중 하나
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _buffer_를 _ta_.[[ViewedArrayBuffer]]로 둔다.
          1. _taRecord_를 MakeTypedArrayWithBufferWitnessRecord(_ta_, ~seq-cst~)로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_)가 *true*이면, *TypeError* 예외를 throw한다.
          1. _len_을 TypedArrayLength(_taRecord_)로 둔다.
          1. _byteOffset_을 _ta_.[[ByteOffset]]로 둔다.
          1. _bytes_를 새 빈 List로 둔다.
          1. _index_를 0으로 둔다.
          1. _index_ &lt; _len_인 동안 반복한다,
            1. _byteIndex_를 _byteOffset_ + _index_로 둔다.
            1. _byte_를 ℝ(GetValueFromBuffer(_buffer_, _byteIndex_, ~uint8~, *true*, ~unordered~))로 둔다.
            1. _bytes_에 _byte_를 추가한다.
            1. _index_를 _index_ + 1로 설정한다.
          1. _bytes_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setuint8arraybytes" type="abstract operation">
        <h1>
          SetUint8ArrayBytes (
            _into_: Uint8Array,
            _bytes_: 바이트 값의 List,
          ): ~unused~
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _offset_을 _into_.[[ByteOffset]]로 둔다.
          1. _len_을 _bytes_의 요소 개수로 둔다.
          1. _index_를 0으로 둔다.
          1. _index_ &lt; _len_인 동안 반복한다,
            1. _byte_를 _bytes_[_index_]로 둔다.
            1. _byteIndexInBuffer_를 _index_ + _offset_으로 둔다.
            1. SetValueInBuffer(_into_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, ~uint8~, 𝔽(_byte_), *true*, ~unordered~)를 수행한다.
            1. _index_를 _index_ + 1로 설정한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-skipasciiwhitespace" type="abstract operation">
        <h1>
          SkipAsciiWhitespace (
            _string_: String,
            _index_: 음이 아닌 정수,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _length_를 _string_의 길이로 둔다.
          1. _index_ &lt; _length_인 동안 반복한다,
            1. _char_를 _string_ 내 인덱스 _index_의 코드 유닛으로 둔다.
            1. _char_가 0x0009 (TAB), 0x000A (LF), 0x000C (FF), 0x000D (CR), 0x0020 (SPACE) 중 하나가 아니면
              1. _index_를 반환한다.
            1. _index_를 _index_ + 1로 설정한다.
          1. _index_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodefinalbase64chunk" type="abstract operation">
        <h1>
          DecodeFinalBase64Chunk (
            _chunk_: 길이 2 또는 3의 String,
            _throwOnExtraBits_: Boolean,
          ): 바이트 값의 List를 포함하는 normal completion 또는 throw completion 중 하나
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _chunkLength_를 _chunk_의 길이로 둔다.
          1. _chunkLength_ = 2이면,
            1. _chunk_를 _chunk_와 *"AA"*의 문자열 결합 결과로 설정한다.
          1. 그렇지 않으면,
            1. Assert: _chunkLength_는 3이다.
            1. _chunk_를 _chunk_와 *"A"*의 문자열 결합 결과로 설정한다.
          1. _bytes_를 DecodeFullLengthBase64Chunk(_chunk_)로 둔다.
          1. _chunkLength_ = 2이면,
            1. _throwOnExtraBits_이 *true*이고 _bytes_[1] ≠ 0이면,
              1. *SyntaxError* 예외를 throw한다.
            1. « _bytes_[0] »을 반환한다.
          1. 그렇지 않으면,
            1. _throwOnExtraBits_이 *true*이고 _bytes_[2] ≠ 0이면,
              1. *SyntaxError* 예외를 throw한다.
            1. « _bytes_[0], _bytes_[1] »을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodefulllengthbase64chunk" type="abstract operation">
        <h1>
          DecodeFullLengthBase64Chunk (
            _chunk_: 길이 4의 String,
          ): 길이 3의 바이트 값 List
        </h1>
        <dl class="header">
        </dl>
        <p><dfn id="standard-base64-alphabet">표준 base64 알파벳</dfn>은 *"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"*입니다. 즉, 이 문자열의 각 요소는 Unicode Basic Latin 블록 내의 모든 문자 및 숫자, 그리고 *"+"*와 *"/"*에 해당하는 코드 유닛입니다.</p>
        <emu-alg>
          1. _byteSequence_를 _chunk_를 base64로 디코드한 결과의 유일한 3바이트 시퀀스로 둔다(즉, <a href="https://datatracker.ietf.org/doc/html/rfc4648">RFC 4648</a> 4절에 명시된 base64 인코딩을 _byteSequence_에 적용하면 _chunk_가 된다).
          1. _byteSequence_의 요소를 순서대로 포함하는 List를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frombase64" type="abstract operation">
        <h1>
          FromBase64 (
            _string_: String,
            _alphabet_: *"base64"* 또는 *"base64url"*,
            _lastChunkHandling_: *"loose"*, *"strict"*, *"stop-before-partial"*,
            optional _maxLength_: 음이 아닌 정수,
          ): [[Read]](정수), [[Bytes]](바이트 값 List), [[Error]](*SyntaxError* 객체 또는 ~none~) 필드를 가지는 Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _maxLength_가 없으면,
            1. _maxLength_를 2<sup>53</sup> - 1로 설정한다.
            1. 참고: 입력이 String이므로, String의 길이는 2<sup>53</sup> - 1로 제한되고, 출력은 입력 문자 개수보다 더 많은 바이트가 필요하지 않으므로, 이 한계에 도달할 수 없다. 하지만 편집상 유한 값으로 사용한다.
          1. 참고: 아래 알고리즘에서 검증과 디코드의 순서는 관찰 불가능하다. 구현체는 효율적인 순서로, 혹은 검증과 디코드를 섞어서 수행할 수 있다.
          1. _maxLength_ = 0이면,
            1. Record { [[Read]]: 0, [[Bytes]]: « », [[Error]]: ~none~ }를 반환한다.
          1. _read_를 0으로 둔다.
          1. _bytes_를 새 빈 List로 둔다.
          1. _chunk_를 빈 문자열로 둔다.
          1. _chunkLength_를 0으로 둔다.
          1. _index_를 0으로 둔다.
          1. _length_를 _string_의 길이로 둔다.
          1. 반복한다,
            1. _index_를 SkipAsciiWhitespace(_string_, _index_)로 설정한다.
            1. _index_ = _length_이면,
              1. _chunkLength_ > 0이면,
                1. _lastChunkHandling_이 *"stop-before-partial"*이면,
                  1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
                1. 그렇지 않고 _lastChunkHandling_이 *"loose"*이면,
                  1. _chunkLength_ = 1이면,
                    1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
                    1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
                  1. _bytes_를 _bytes_와 ! DecodeFinalBase64Chunk(_chunk_, *false*)의 리스트 결합 결과로 설정한다.
                1. 그렇지 않으면,
                  1. Assert: _lastChunkHandling_이 *"strict"*임.
                  1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
                  1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
              1. Record { [[Read]]: _length_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
            1. _char_를 _string_의 _index_부터 _index_ + 1까지의 부분 문자열로 둔다.
            1. _index_를 _index_ + 1로 설정한다.
            1. _char_가 *"="*이면,
              1. _chunkLength_ &lt; 2이면,
                1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
                1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
              1. _index_를 SkipAsciiWhitespace(_string_, _index_)로 설정한다.
              1. _chunkLength_ = 2이면,
                1. _index_ = _length_이면,
                  1. _lastChunkHandling_이 *"stop-before-partial"*이면,
                    1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
                  1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
                  1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
                1. _char_를 _string_의 _index_부터 _index_ + 1까지의 부분 문자열로 둔다.
                1. _char_가 *"="*이면,
                  1. _index_를 SkipAsciiWhitespace(_string_, _index_ + 1)로 설정한다.
              1. _index_ &lt; _length_이면,
                1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
                1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
              1. _lastChunkHandling_이 *"strict"*이면 _throwOnExtraBits_를 *true*, 아니면 *false*로 둔다.
              1. _decodeResult_를 Completion(DecodeFinalBase64Chunk(_chunk_, _throwOnExtraBits_))로 둔다.
              1. _decodeResult_가 abrupt completion이면,
                1. _error_를 _decodeResult_.[[Value]]로 둔다.
                1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
              1. _bytes_를 _bytes_와 ! _decodeResult_의 리스트 결합 결과로 설정한다.
              1. Record { [[Read]]: _length_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
            1. _alphabet_이 *"base64url"*이면,
              1. _char_가 *"+"* 또는 *"/"*이면,
                1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
                1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
              1. 아니고 _char_가 *"-"*이면,
                1. _char_를 *"+"*로 설정한다.
              1. 아니고 _char_가 *"_"*이면,
                1. _char_를 *"/"*로 설정한다.
            1. _char_의 유일한 코드 유닛이 표준 base64 알파벳에 포함되어 있지 않으면,
              1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
              1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
            1. _remaining_을 _maxLength_ - _bytes_의 요소 개수로 둔다.
            1. _remaining_ = 1이고 _chunkLength_ = 2이거나, _remaining_ = 2이고 _chunkLength_ = 3이면,
              1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
            1. _chunk_를 _chunk_와 _char_의 문자열 결합 결과로 설정한다.
            1. _chunkLength_를 _chunk_의 길이로 설정한다.
            1. _chunkLength_ = 4이면,
              1. _bytes_를 _bytes_와 DecodeFullLengthBase64Chunk(_chunk_)의 리스트 결합 결과로 설정한다.
              1. _chunk_를 빈 문자열로 설정한다.
              1. _chunkLength_를 0으로 설정한다.
              1. _read_를 _index_로 설정한다.
              1. _bytes_의 요소 개수 = _maxLength_이면,
                1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-fromhex" type="abstract operation">
        <h1>
          FromHex (
            _string_: String,
            optional _maxLength_: 음이 아닌 정수,
          ): [[Read]](정수), [[Bytes]](바이트 값 List), [[Error]](*SyntaxError* 객체 또는 ~none~) 필드를 가지는 Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _maxLength_가 없으면, _maxLength_를 2<sup>53</sup> - 1로 설정한다.
          1. _length_를 _string_의 길이로 둔다.
          1. _bytes_를 새 빈 List로 둔다.
          1. _read_를 0으로 둔다.
          1. _length_를 2로 나눈 나머지가 0이 아니면,
            1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
            1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
          1. _read_ &lt; _length_이고 _bytes_의 요소 개수 &lt; _maxLength_인 동안 반복한다,
            1. _hexits_를 _string_의 _read_부터 _read_ + 2까지의 부분 문자열로 둔다.
            1. _hexits_에 *"0123456789abcdefABCDEF"*에 포함되지 않은 코드 유닛이 있으면,
              1. _error_를 새로 생성한 *SyntaxError* 객체로 둔다.
              1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: _error_ }를 반환한다.
            1. _read_를 _read_ + 2로 설정한다.
            1. _byte_를 _hexits_가 16진수 표기법으로 나타내는 정수 값으로 둔다. (A~F, a~f는 10~15 값)
            1. _bytes_에 _byte_를 추가한다.
          1. Record { [[Read]]: _read_, [[Bytes]]: _bytes_, [[Error]]: ~none~ }를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>키드 컬렉션(Keyed Collections)</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map 객체</h1>
    <p>Map 은 키/값 쌍의 컬렉션이며 키와 값 모두 임의의 ECMAScript 언어 값을 사용할 수 있다. 하나의 고유 키 값은 그 Map 컬렉션 안에서 하나의 키/값 쌍에만 등장할 수 있다. 고유 키 값의 구분은 SameValueZero 비교 알고리즘의 의미론을 사용한다.</p>
    <p>Map 은 평균적으로 컬렉션의 요소 수에 대해 준선형(sublinear) 접근 시간을 제공하는 해시 테이블 또는 다른 메커니즘을 사용하여 구현되어야 한다. 이 명세에서 사용하는 자료 구조는 Map 의 요구되는 관측 가능 의미를 설명하기 위한 것이며 실제 구현 모델이 되려는 목적은 아니다.</p>

    <emu-clause id="sec-map-constructor">
      <h1>Map 생성자</h1>
      <p>Map 생성자:</p>
      <ul>
        <li><dfn>%Map%</dfn> 이다.</li>
        <li>전역 객체의 *"Map"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새 Map 을 생성하고 초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Map 동작을 상속하려는 서브클래스 생성자는 `Map.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 Map 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-map-iterable">
        <h1>Map ( [ _iterable_ ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _map_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%Map.prototype%"*, « [[MapData]] »).
          1. _map_.[[MapData]] 를 새 빈 List 로 설정.
          1. _iterable_ 이 *undefined* 또는 *null* 이면 _map_ 반환.
          1. _adder_ = ? Get(_map_, *"set"*).
          1. IsCallable(_adder_) 가 *false* 이면 *TypeError* 예외.
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>매개변수 _iterable_ 이 존재하면, 첫 번째 요소가 Map 키로 사용될 값이고 두 번째 요소가 그 키에 연결할 값인 2-요소 배열 유사 객체를 생성하는 이터레이터 객체를 반환하는 %Symbol.iterator% 메서드를 구현한 객체일 것으로 기대된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-add-entries-from-iterable" type="abstract operation">
        <h1>
          AddEntriesFromIterable (
            _target_: an Object,
            _iterable_: an ECMAScript language value, but not *undefined* or *null*,
            _adder_: a function object,
          ): 정상 완료(ECMAScript 언어 값 포함) 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_adder_ 는 _target_ 을 receiver 로 하여 호출된다.</dd>
        </dl>
        <emu-alg>
          1. _iteratorRecord_ = ? GetIterator(_iterable_, ~sync~).
          1. 반복:
            1. _next_ = ? IteratorStepValue(_iteratorRecord_).
            1. _next_ 가 ~done~ 이면 _target_ 반환.
            1. _next_ 가 Object 가 아니면
              1. _error_ = ThrowCompletion(새로 생성된 *TypeError* 객체).
              1. Return ? IteratorClose(_iteratorRecord_, _error_).
            1. _k_ = Completion(Get(_next_, *"0"*)).
            1. IfAbruptCloseIterator(_k_, _iteratorRecord_).
            1. _v_ = Completion(Get(_next_, *"1"*)).
            1. IfAbruptCloseIterator(_v_, _iteratorRecord_).
            1. _status_ = Completion(Call(_adder_, _target_, « _k_, _v_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
        <emu-note>
          <p>매개변수 _iterable_ 은 2-요소 배열 유사 객체를 생성하는 이터레이터 객체를 반환하는 %Symbol.iterator% 메서드를 구현한 객체일 것으로 기대된다. 첫 요소는 Map 키로, 두 번째 요소는 그 키에 연결할 값이다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Map 생성자의 프로퍼티</h1>
      <p>Map 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-map.groupby">
        <h1>Map.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ 은 두 인자를 받는 함수여야 한다. `groupBy` 는 _items_ 의 각 요소에 대해 오름차순으로 한 번씩 _callback_ 을 호출하고 새 Map 을 구성한다. _callback_ 이 반환한 각 값은 Map 의 키로 사용된다. 그러한 키마다 결과 Map 은 그 키를 키로 하고 _callback_ 이 그 키를 반환한 모든 요소가 담긴 배열을 값으로 갖는 엔트리를 가진다.</p>
          <p>_callback_ 은 요소의 값과 요소의 인덱스 두 인자로 호출된다.</p>
          <p>`groupBy` 의 반환 값은 Map 이다.</p>
        </emu-note>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _groups_ = ? GroupBy(_items_, _callback_, ~collection~).
          1. _map_ = ! Construct(%Map%).
          1. 각 Record { [[Key]], [[Elements]] } _g_ ∈ _groups_ 에 대해
            1. _elements_ = CreateArrayFromList(_g_.[[Elements]]).
            1. _entry_ = Record { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }.
            1. _entry_ 를 _map_.[[MapData]] 에 append.
          1. _map_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype">
        <h1>Map.prototype</h1>
        <p>`Map.prototype` 의 초기 값은 Map 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-map-@@species" id="sec-get-map-%symbol.species%">
        <h1>get Map [ %Symbol.species% ]</h1>
        <p>`Map[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p>파생 컬렉션 객체를 생성하는 메서드는 파생 객체를 생성할 때 사용할 생성자를 결정하기 위해 %Symbol.species% 를 호출해야 한다. 서브클래스 생성자는 기본 생성자 할당을 변경하기 위해 %Symbol.species% 를 재정의할 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-prototype-object">
      <h1>Map 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Map 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Map.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[MapData]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-map.prototype.clear">
        <h1>Map.prototype.clear ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. _M_.[[MapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] = ~empty~ 로 설정.
            1. _p_.[[Value]] = ~empty~ 로 설정.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>기존 [[MapData]] List 는 그 List 순회를 중간에 일시중단한 기존 Map Iterator 객체가 있을 수 있으므로 유지된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.constructor">
        <h1>Map.prototype.constructor</h1>
        <p>`Map.prototype.constructor` 의 초기 값은 %Map% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype.delete">
        <h1>Map.prototype.delete ( _key_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. _key_ = CanonicalizeKeyedCollectionKey(_key_).
          1. _M_.[[MapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 이고 SameValue(_p_.[[Key]], _key_) = *true* 이면
              1. _p_.[[Key]] = ~empty~.
              1. _p_.[[Value]] = ~empty~.
              1. *true* 반환.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>값 ~empty~ 는 엔트리가 삭제되었음을 나타내는 명세 기법이다. 실제 구현은 내부 자료 구조에서 물리적으로 제거하는 등의 다른 동작을 할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.entries">
        <h1>Map.prototype.entries ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. Return ? CreateMapIterator(_M_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.foreach">
        <h1>Map.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _entries_ = _M_.[[MapData]].
          1. _numEntries_ = _entries_ 요소 수.
          1. _index_ = 0.
          1. 반복, _index_ &lt; _numEntries_ 동안
            1. _e_ = _entries_[_index_].
            1. _index_ = _index_ + 1.
            1. _e_.[[Key]] ≠ ~empty~ 이면
              1. ? Call(_callback_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ ») 수행.
              1. NOTE: _callback_ 실행 중 _entries_ 요소 수가 증가할 수 있다.
              1. _numEntries_ = _entries_ 요소 수로 재설정.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>_callback_ 은 세 인자를 받는 함수여야 한다. `forEach` 는 Map 에 존재하는 각 키/값 쌍을 키 삽입 순서대로 한 번씩 _callback_ 에 전달한다. _callback_ 은 실제 존재하는 키에 대해서만 호출되며 Map 에서 삭제된 키에 대해서는 호출되지 않는다.</p>
          <p>_thisArg_ 가 제공되면 각 호출의 *this* 값으로 사용되며, 제공되지 않으면 *undefined* 사용.</p>
          <p>_callback_ 은 (값, 키, 순회 중인 Map) 세 인자로 호출된다.</p>
          <p>`forEach` 자체는 호출된 객체를 직접 변이하지 않지만 _callback_ 호출에 의해 변이될 수 있다. Map 의 [[MapData]] 각 엔트리는 한 번만 방문된다. 호출 시작 후 추가된 새 키는 방문된다. 이미 방문된 키가 삭제되고 다시 추가되면 다시 방문된다. 시작 후 방문되기 전에 삭제된 키는 재추가되지 않는 한 방문되지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.get">
        <h1>Map.prototype.get ( _key_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. _key_ = CanonicalizeKeyedCollectionKey(_key_).
          1. _M_.[[MapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면 _p_.[[Value]] 반환.
          1. *undefined* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.has">
        <h1>Map.prototype.has ( _key_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. _key_ = CanonicalizeKeyedCollectionKey(_key_).
          1. _M_.[[MapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.keys">
        <h1>Map.prototype.keys ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. Return ? CreateMapIterator(_M_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.set">
        <h1>Map.prototype.set ( _key_, _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. _key_ = CanonicalizeKeyedCollectionKey(_key_).
          1. _M_.[[MapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면
              1. _p_.[[Value]] = _value_.
              1. _M_ 반환.
          1. _p_ = Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. _p_ 를 _M_.[[MapData]] 에 append.
          1. _M_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-map.prototype.size">
        <h1>get Map.prototype.size</h1>
        <p>`Map.prototype.size` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[MapData]]) 수행.
          1. _count_ = 0.
          1. _M_.[[MapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 이면 _count_ = _count_ + 1.
          1. 𝔽(_count_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.values">
        <h1>Map.prototype.values ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. Return ? CreateMapIterator(_M_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@iterator" id="sec-map.prototype-%symbol.iterator%">
        <h1>Map.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 프로퍼티의 초기 값은 <emu-xref href="#sec-map.prototype.entries"></emu-xref>에 정의된 %Map.prototype.entries% 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@tostringtag" id="sec-map.prototype-%symbol.tostringtag%">
        <h1>Map.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"Map"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-map-instances">
      <h1>Map 인스턴스의 프로퍼티</h1>
      <p>Map 인스턴스는 일반 객체이며 Map 프로토타입 객체로부터 프로퍼티를 상속한다. 또한 [[MapData]] 내부 슬롯을 가진다.</p>
    </emu-clause>

    <emu-clause id="sec-map-iterator-objects">
      <h1>Map 이터레이터 객체</h1>
      <p><dfn variants="Map Iterators,Map Iterator object,Map Iterator objects">Map Iterator</dfn> 는 특정 Map 인스턴스 객체에 대한 특정 순회를 나타내는 객체이다. Map Iterator 객체에 대한 이름 있는 생성자는 없다. 대신 Map 인스턴스 객체의 특정 메서드를 호출하여 생성된다.</p>

      <emu-clause id="sec-createmapiterator" type="abstract operation" oldids="sec-properties-of-map-iterator-instances,table-50,table-internal-slots-of-map-iterator-instances">
        <h1>
          CreateMapIterator (
            _map_: an ECMAScript language value,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): Generator 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>Map 메서드 중 그러한 이터레이터를 반환하는 것들이 사용할 이터레이터 객체를 생성한다.</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_map_, [[MapData]]) 수행.
          1. _closure_ 를 매개변수 없고 _map_, _kind_ 를 캡처하며 호출 시 다음 단계를 수행하는 새 추상 클로저로 둔다:
            1. _entries_ = _map_.[[MapData]].
            1. _index_ = 0.
            1. _numEntries_ = _entries_ 요소 수.
            1. 반복, _index_ &lt; _numEntries_ 동안
              1. _e_ = _entries_[_index_].
              1. _index_ = _index_ + 1.
              1. _e_.[[Key]] ≠ ~empty~ 이면
                1. _kind_ 가 ~key~ 이면
                  1. _result_ = _e_.[[Key]].
                1. Else if _kind_ = ~value~ 이면
                  1. _result_ = _e_.[[Value]].
                1. Else
                  1. Assert: _kind_ = ~key+value~.
                  1. _result_ = CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).
                1. ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)) 수행.
                1. NOTE: GeneratorYield 로 일시 중단된 동안 _entries_ 요소 수가 증가할 수 있다.
                1. _numEntries_ = _entries_ 요소 수로 재설정.
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%MapIteratorPrototype%"*, %MapIteratorPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%mapiteratorprototype%-object">
        <h1>%MapIteratorPrototype% 객체</h1>
        <p><dfn>%MapIteratorPrototype%</dfn> 객체:</p>
        <ul>
          <li>모든 Map Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
          <li>일반 객체이다.</li>
          <li>값이 %Iterator.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%mapiteratorprototype%.next">
          <h1>%MapIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%MapIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%mapiteratorprototype%-@@tostringtag" id="sec-%mapiteratorprototype%-%symbol.tostringtag%">
          <h1>%MapIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"Map Iterator"* 이다.</p>
          <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set 객체</h1>
    <p>Set 객체는 ECMAScript 언어 값들의 컬렉션이다. 하나의 고유 값은 Set 컬렉션에서 한 번만 요소로 등장할 수 있다. 고유 값의 구분은 SameValueZero 비교 알고리즘 의미론을 사용한다.</p>
    <p>Set 객체는 평균적으로 컬렉션 요소 수에 대해 준선형 접근 시간을 제공하는 해시 테이블 또는 다른 메커니즘으로 구현되어야 한다. 이 명세의 자료 구조는 Set 객체의 요구되는 관측 가능 의미를 설명하기 위한 것으로 실제 구현 모델을 의도하지 않는다.</p>

    <emu-clause id="sec-abstract-operations-for-set-objects">
      <h1>Set 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-set-records">
        <h1>Set Record</h1>
        <p><dfn variants="Set Records">Set Record</dfn> 는 Set 또는 유사 객체의 인터페이스를 캡슐화하기 위해 사용되는 Record 값이다.</p>
        <p>Set Record 는 <emu-xref href="#table-set-record-fields"></emu-xref> 에 나열된 필드를 가진다.</p>
        <emu-table id="table-set-record-fields" caption="Set Record 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[SetObject]]
              </td>
              <td>
                an Object
              </td>
              <td>
                해당 Set 또는 유사 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[Size]]
              </td>
              <td>
                a non-negative integer or +∞
              </td>
              <td>
                객체의 보고된 크기.
              </td>
            </tr>
            <tr>
              <td>
                [[Has]]
              </td>
              <td>
                a function object
              </td>
              <td>
                객체의 `has` 메서드.
              </td>
            </tr>
            <tr>
              <td>
                [[Keys]]
              </td>
              <td>
                a function object
              </td>
              <td>
                객체의 `keys` 메서드.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getsetrecord" type="abstract operation">
        <h1>
          GetSetRecord (
            _obj_: an ECMAScript language value,
          ): Set Record 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _obj_ 가 Object 가 아니면 *TypeError* 예외.
          1. _rawSize_ = ? Get(_obj_, *"size"*).
          1. _numSize_ = ? ToNumber(_rawSize_).
          1. NOTE: _rawSize_ 가 *undefined* 이면 _numSize_ 는 *NaN*.
          1. _numSize_ 가 *NaN* 이면 *TypeError* 예외.
          1. _intSize_ = ! ToIntegerOrInfinity(_numSize_).
          1. _intSize_ &lt; 0 이면 *RangeError* 예외.
          1. _has_ = ? Get(_obj_, *"has"*).
          1. IsCallable(_has_) *false* 이면 *TypeError* 예외.
          1. _keys_ = ? Get(_obj_, *"keys"*).
          1. IsCallable(_keys_) *false* 이면 *TypeError* 예외.
          1. 새 Set Record { [[SetObject]]: _obj_, [[Size]]: _intSize_, [[Has]]: _has_, [[Keys]]: _keys_ } 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatahas" type="abstract operation">
        <h1>
          SetDataHas (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. SetDataIndex(_setData_, _value_) 가 ~not-found~ 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdataindex" type="abstract operation">
        <h1>
          SetDataIndex (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): 음이 아닌 정수 또는 ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _value_ = CanonicalizeKeyedCollectionKey(_value_).
          1. _size_ = _setData_ 요소 수.
          1. _index_ = 0.
          1. 반복, _index_ &lt; _size_ 동안
            1. _e_ = _setData_[_index_].
            1. _e_ ≠ ~empty~ 그리고 _e_ 가 _value_ 이면
              1. _index_ 반환.
            1. _index_ = _index_ + 1.
          1. ~not-found~ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatasize" type="abstract operation">
        <h1>
          SetDataSize (
            _setData_: a List of either ECMAScript language values or ~empty~,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _count_ = 0.
          1. _setData_ 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 이면 _count_ = _count_ + 1.
          1. _count_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-set-constructor">
      <h1>Set 생성자</h1>
      <p>Set 생성자:</p>
      <ul>
        <li><dfn>%Set%</dfn> 이다.</li>
        <li>전역 객체의 *"Set"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새 Set 객체를 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Set 동작을 상속하려는 서브클래스 생성자는 `Set.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 Set 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-set-iterable">
        <h1>Set ( [ _iterable_ ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _set_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%Set.prototype%"*, « [[SetData]] »).
          1. _set_.[[SetData]] 를 새 빈 List 로 설정.
          1. _iterable_ 이 *undefined* 또는 *null* 이면 _set_ 반환.
          1. _adder_ = ? Get(_set_, *"add"*).
          1. IsCallable(_adder_) *false* 이면 *TypeError* 예외.
          1. _iteratorRecord_ = ? GetIterator(_iterable_, ~sync~).
          1. 반복:
            1. _next_ = ? IteratorStepValue(_iteratorRecord_).
            1. _next_ 가 ~done~ 이면 _set_ 반환.
            1. _status_ = Completion(Call(_adder_, _set_, « _next_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Set 생성자의 프로퍼티</h1>
      <p>Set 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-set.prototype">
        <h1>Set.prototype</h1>
        <p>`Set.prototype` 의 초기 값은 Set 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-set-@@species" id="sec-get-set-%symbol.species%">
        <h1>get Set [ %Symbol.species% ]</h1>
        <p>`Set[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p>파생 컬렉션 객체를 생성하는 메서드는 파생 객체 생성을 위해 사용할 생성자를 결정하기 위해 %Symbol.species% 를 호출해야 한다. 서브클래스 생성자는 기본 생성자 할당을 변경하기 위해 %Symbol.species% 를 재정의할 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-prototype-object">
      <h1>Set 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Set 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Set.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[SetData]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-set.prototype.add">
        <h1>Set.prototype.add ( _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[SetData]]) 수행.
          1. _value_ = CanonicalizeKeyedCollectionKey(_value_).
          1. _S_.[[SetData]] 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 그리고 SameValue(_e_, _value_) = *true* 이면
              1. _S_ 반환.
          1. _value_ 를 _S_.[[SetData]] 에 append.
          1. _S_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.clear">
        <h1>Set.prototype.clear ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[SetData]]) 수행.
          1. _S_.[[SetData]] 의 각 요소 _e_ 에 대해
            1. 값이 _e_ 인 _S_.[[SetData]] 의 요소를 값이 ~empty~ 인 요소로 교체.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>기존 [[SetData]] List 는 그 List 순회를 중간에 일시중단한 Set Iterator 객체가 있을 수 있으므로 유지된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.constructor">
        <h1>Set.prototype.constructor</h1>
        <p>`Set.prototype.constructor` 의 초기 값은 %Set% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype.delete">
        <h1>Set.prototype.delete ( _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[SetData]]) 수행.
          1. _value_ = CanonicalizeKeyedCollectionKey(_value_).
          1. _S_.[[SetData]] 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 그리고 SameValue(_e_, _value_) = *true* 이면
              1. 값이 _e_ 인 _S_.[[SetData]] 요소를 값이 ~empty~ 인 요소로 교체.
              1. *true* 반환.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>값 ~empty~ 는 엔트리가 삭제되었음을 나타내는 명세 기법이다. 실제 구현은 내부 자료 구조에서 물리적으로 제거하는 등의 다른 동작을 할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.difference">
        <h1>Set.prototype.difference ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. _resultSetData_ = _O_.[[SetData]] 의 복사본.
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]] 이면
            1. _thisSize_ = _O_.[[SetData]] 요소 수.
            1. _index_ = 0.
            1. 반복, _index_ &lt; _thisSize_ 동안
              1. _e_ = _resultSetData_[_index_].
              1. _e_ ≠ ~empty~ 이면
                1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. _inOther_ = *true* 이면
                  1. _resultSetData_[_index_] = ~empty~.
              1. _index_ = _index_ + 1.
          1. Else
            1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. _next_ = ~not-started~.
            1. 반복, _next_ ≠ ~done~ 동안
              1. _next_ = ? IteratorStepValue(_keysIter_).
              1. _next_ ≠ ~done~ 이면
                1. _next_ = CanonicalizeKeyedCollectionKey(_next_).
                1. _valueIndex_ = SetDataIndex(_resultSetData_, _next_).
                1. _valueIndex_ ≠ ~not-found~ 이면
                  1. _resultSetData_[_valueIndex_] = ~empty~.
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. _result_.[[SetData]] = _resultSetData_.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.entries">
        <h1>Set.prototype.entries ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. Return ? CreateSetIterator(_S_, ~key+value~).
        </emu-alg>
        <emu-note>
          <p>순회 목적상 Set 은 각 엔트리의 키와 값이 같은 Map 과 유사하게 보인다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.foreach">
        <h1>Set.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[SetData]]) 수행.
          1. IsCallable(_callback_) *false* 이면 *TypeError* 예외.
          1. _entries_ = _S_.[[SetData]].
          1. _numEntries_ = _entries_ 요소 수.
          1. _index_ = 0.
          1. 반복, _index_ &lt; _numEntries_ 동안
            1. _e_ = _entries_[_index_].
            1. _index_ = _index_ + 1.
            1. _e_ ≠ ~empty~ 이면
              1. ? Call(_callback_, _thisArg_, « _e_, _e_, _S_ ») 수행.
              1. NOTE: _callback_ 실행 중 _entries_ 요소 수가 증가할 수 있다.
              1. _numEntries_ = _entries_ 요소 수로 재설정.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>_callback_ 은 세 인자를 받는 함수여야 한다. `forEach` 는 Set 객체에 존재하는 각 값을 값 삽입 순서대로 한 번씩 _callback_ 에 전달한다. _callback_ 은 실제 존재하는 값에 대해서만 호출되며 삭제된 값에 대해서는 호출되지 않는다.</p>
          <p>_thisArg_ 가 제공되면 각 호출의 *this* 값으로 사용되고, 제공되지 않으면 *undefined* 사용.</p>
          <p>_callback_ 은 세 인자로 호출되며 처음 두 인자는 Set 에 포함된 같은 값이고 세 번째 인자는 순회 중인 Set 객체이다.</p>
          <p>세 인자 호출 형태는 Map 과 Array 의 `forEach` 콜백 형태와 일관성을 유지하기 위함이다. Set 에서는 각 항목 값이 키이자 값으로 간주된다.</p>
          <p>`forEach` 는 대상 객체를 직접 변이하지 않지만 _callback_ 호출에 의해 변이될 수 있다.</p>
          <p>각 값은 일반적으로 한 번만 방문된다. 그러나 방문 후 삭제됐다가 `forEach` 완료 전에 재추가되면 다시 방문된다. 시작 후 방문되기 전에 삭제된 값은 재추가되지 않는 한 방문되지 않는다. 시작 후 추가된 새 값은 방문된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.has">
        <h1>Set.prototype.has ( _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[SetData]]) 수행.
          1. _value_ = CanonicalizeKeyedCollectionKey(_value_).
          1. _S_.[[SetData]] 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 그리고 SameValue(_e_, _value_) = *true* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.intersection">
        <h1>Set.prototype.intersection ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. _resultSetData_ = 새 빈 List.
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]] 이면
            1. _thisSize_ = _O_.[[SetData]] 요소 수.
            1. _index_ = 0.
            1. 반복, _index_ &lt; _thisSize_ 동안
              1. _e_ = _O_.[[SetData]][_index_].
              1. _index_ = _index_ + 1.
              1. _e_ ≠ ~empty~ 이면
                1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. _inOther_ = *true* 이면
                  1. NOTE: 이전 _otherRec_.[[Has]] 호출이 _O_.[[SetData]] 요소를 제거 후 재추가하여 같은 요소가 두 번 방문될 수 있다.
                  1. SetDataHas(_resultSetData_, _e_) = *false* 이면
                    1. _e_ 를 _resultSetData_ 에 append.
                1. NOTE: _otherRec_.[[Has]] 실행 중 _O_.[[SetData]] 요소 수가 증가할 수 있다.
                1. _thisSize_ = _O_.[[SetData]] 요소 수로 재설정.
          1. Else
            1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. _next_ = ~not-started~.
            1. 반복, _next_ ≠ ~done~ 동안
              1. _next_ = ? IteratorStepValue(_keysIter_).
              1. _next_ ≠ ~done~ 이면
                1. _next_ = CanonicalizeKeyedCollectionKey(_next_).
                1. _inThis_ = SetDataHas(_O_.[[SetData]], _next_).
                1. _inThis_ = *true* 이면
                  1. NOTE: _other_ 는 임의 객체이므로 *"keys"* 이터레이터가 같은 값을 여러 번 낼 수 있다.
                  1. SetDataHas(_resultSetData_, _next_) = *false* 이면
                    1. _next_ 를 _resultSetData_ 에 append.
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. _result_.[[SetData]] = _resultSetData_.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.isdisjointfrom">
        <h1>Set.prototype.isDisjointFrom ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]] 이면
            1. _thisSize_ = _O_.[[SetData]] 요소 수.
            1. _index_ = 0.
            1. 반복, _index_ &lt; _thisSize_ 동안
              1. _e_ = _O_.[[SetData]][_index_].
              1. _index_ = _index_ + 1.
              1. _e_ ≠ ~empty~ 이면
                1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. _inOther_ = *true* 이면 *false* 반환.
                1. NOTE: _otherRec_.[[Has]] 실행 중 _O_.[[SetData]] 요소 수가 증가할 수 있다.
                1. _thisSize_ = _O_.[[SetData]] 요소 수로 재설정.
          1. Else
            1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. _next_ = ~not-started~.
            1. 반복, _next_ ≠ ~done~ 동안
              1. _next_ = ? IteratorStepValue(_keysIter_).
              1. _next_ ≠ ~done~ 이면
                1. SetDataHas(_O_.[[SetData]], _next_) = *true* 이면
                  1. ? IteratorClose(_keysIter_, NormalCompletion(~unused~)) 수행.
                  1. *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issubsetof">
        <h1>Set.prototype.isSubsetOf ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. SetDataSize(_O_.[[SetData]]) > _otherRec_.[[Size]] 이면 *false* 반환.
          1. _thisSize_ = _O_.[[SetData]] 요소 수.
          1. _index_ = 0.
          1. 반복, _index_ &lt; _thisSize_ 동안
            1. _e_ = _O_.[[SetData]][_index_].
            1. _index_ = _index_ + 1.
            1. _e_ ≠ ~empty~ 이면
              1. _inOther_ = ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
              1. _inOther_ = *false* 이면 *false* 반환.
              1. NOTE: _otherRec_.[[Has]] 실행 중 _O_.[[SetData]] 요소 수가 증가할 수 있다.
              1. _thisSize_ = _O_.[[SetData]] 요소 수로 재설정.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issupersetof">
        <h1>Set.prototype.isSupersetOf ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. SetDataSize(_O_.[[SetData]]) &lt; _otherRec_.[[Size]] 이면 *false* 반환.
          1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. _next_ = ~not-started~.
          1. 반복, _next_ ≠ ~done~ 동안
            1. _next_ = ? IteratorStepValue(_keysIter_).
            1. _next_ ≠ ~done~ 이면
              1. SetDataHas(_O_.[[SetData]], _next_) = *false* 이면
                1. ? IteratorClose(_keysIter_, NormalCompletion(~unused~)) 수행.
                1. *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.keys">
        <h1>Set.prototype.keys ( )</h1>
        <p>*"keys"* 프로퍼티의 초기 값은 <emu-xref href="#sec-set.prototype.values"></emu-xref>에 정의된 %Set.prototype.values% 이다.</p>
        <emu-note>
          <p>순회 목적상 Set 은 각 엔트리의 키와 값이 같은 Map 과 유사하게 보인다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-set.prototype.size">
        <h1>get Set.prototype.size</h1>
        <p>`Set.prototype.size` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[SetData]]) 수행.
          1. _size_ = SetDataSize(_S_.[[SetData]]).
          1. 𝔽(_size_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.symmetricdifference">
        <h1>Set.prototype.symmetricDifference ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. _resultSetData_ = _O_.[[SetData]] 의 복사본.
          1. _next_ = ~not-started~.
          1. 반복, _next_ ≠ ~done~ 동안
            1. _next_ = ? IteratorStepValue(_keysIter_).
            1. _next_ ≠ ~done~ 이면
              1. _next_ = CanonicalizeKeyedCollectionKey(_next_).
              1. _resultIndex_ = SetDataIndex(_resultSetData_, _next_).
              1. _resultIndex_ = ~not-found~ 이면 _alreadyInResult_ = *false*; 아니면 *true*.
              1. SetDataHas(_O_.[[SetData]], _next_) = *true* 이면
                1. _alreadyInResult_ = *true* 이고 _resultIndex_ 가 ~not-found~ 이 아님이면 _resultSetData_[_resultIndex_] = ~empty~.
              1. Else
                1. _alreadyInResult_ = *false* 이면 _next_ 를 _resultSetData_ 에 append.
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. _result_.[[SetData]] = _resultSetData_.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.union">
        <h1>Set.prototype.union ( _other_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[SetData]]) 수행.
          1. _otherRec_ = ? GetSetRecord(_other_).
          1. _keysIter_ = ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. _resultSetData_ = _O_.[[SetData]] 의 복사본.
          1. _next_ = ~not-started~.
          1. 반복, _next_ ≠ ~done~ 동안
            1. _next_ = ? IteratorStepValue(_keysIter_).
            1. _next_ ≠ ~done~ 이면
              1. _next_ = CanonicalizeKeyedCollectionKey(_next_).
              1. SetDataHas(_resultSetData_, _next_) = *false* 이면
                1. _next_ 를 _resultSetData_ 에 append.
          1. _result_ = OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. _result_.[[SetData]] = _resultSetData_.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.values">
        <h1>Set.prototype.values ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. Return ? CreateSetIterator(_S_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@iterator" id="sec-set.prototype-%symbol.iterator%">
        <h1>Set.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 프로퍼티 초기 값은 <emu-xref href="#sec-set.prototype.values"></emu-xref>에 정의된 %Set.prototype.values% 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@tostringtag" id="sec-set.prototype-%symbol.tostringtag%">
        <h1>Set.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"Set"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-set-instances">
      <h1>Set 인스턴스의 프로퍼티</h1>
      <p>Set 인스턴스는 일반 객체이며 Set 프로토타입 객체로부터 프로퍼티를 상속한다. 또한 [[SetData]] 내부 슬롯을 가진다.</p>
    </emu-clause>

    <emu-clause id="sec-set-iterator-objects">
      <h1>Set 이터레이터 객체</h1>
      <p><dfn variants="Set Iterators,Set Iterator object,Set Iterator objects">Set Iterator</dfn> 는 아래 정의된 구조를 가지며 특정 Set 인스턴스 객체에 대한 특정 순회를 나타내는 일반 객체이다. Set Iterator 객체에 대한 이름 있는 생성자는 없다. 대신 Set 인스턴스 객체의 특정 메서드를 호출하여 생성된다.</p>

      <emu-clause id="sec-createsetiterator" type="abstract operation" oldids="sec-properties-of-set-iterator-instances,table-51,table-internal-slots-of-set-iterator-instances">
        <h1>
          CreateSetIterator (
            _set_: an ECMAScript language value,
            _kind_: ~key+value~ or ~value~,
          ): Generator 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>Set 메서드 중 그러한 이터레이터를 반환하는 것들이 사용할 이터레이터 객체를 생성한다.</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_set_, [[SetData]]) 수행.
          1. _closure_ 를 매개변수 없고 _set_, _kind_ 를 캡처하며 호출 시 다음 단계를 수행하는 새 추상 클로저로 둔다:
            1. _index_ = 0.
            1. _entries_ = _set_.[[SetData]].
            1. _numEntries_ = _entries_ 요소 수.
            1. 반복, _index_ &lt; _numEntries_ 동안
              1. _e_ = _entries_[_index_].
              1. _index_ = _index_ + 1.
              1. _e_ ≠ ~empty~ 이면
                1. _kind_ = ~key+value~ 이면
                  1. _result_ = CreateArrayFromList(« _e_, _e_ »).
                  1. ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)) 수행.
                1. Else
                  1. Assert: _kind_ = ~value~.
                  1. ? GeneratorYield(CreateIteratorResultObject(_e_, *false*)) 수행.
                1. NOTE: GeneratorYield 로 일시 중단된 동안 _entries_ 요소 수가 증가할 수 있다.
                1. _numEntries_ = _entries_ 요소 수로 재설정.
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%SetIteratorPrototype%"*, %SetIteratorPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%setiteratorprototype%-object">
        <h1>%SetIteratorPrototype% 객체</h1>
        <p><dfn>%SetIteratorPrototype%</dfn> 객체:</p>
        <ul>
          <li>모든 Set Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
          <li>일반 객체이다.</li>
          <li>값이 %Iterator.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%setiteratorprototype%.next">
          <h1>%SetIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%SetIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%setiteratorprototype%-@@tostringtag" id="sec-%setiteratorprototype%-%symbol.tostringtag%">
          <h1>%SetIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"Set Iterator"* 이다.</p>
          <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap 객체</h1>
    <p>WeakMap 은 키가 객체 및/또는 심볼이고 값이 임의의 ECMAScript 언어 값일 수 있는 키/값 쌍의 컬렉션이다. WeakMap 은 특정 키를 가진 키/값 쌍이 포함되는지 질의할 수 있지만, 보유한 키/값 쌍을 열거하는 메커니즘은 제공되지 않는다. 특정 조건에서, live 가 아닌 값들은 <emu-xref href="#sec-weakref-execution"></emu-xref> 에 설명된 바와 같이 WeakMap 키로서 제거된다.</p>
    <p>구현은 WeakMap 의 키/값 쌍이 더 이상 접근 불가능(inaccessible) 해진 시점과 그 키/값 쌍이 WeakMap 에서 제거되는 시점 사이에 임의로 결정된 지연(latency)을 부과할 수 있다. 이 지연이 ECMAScript 프로그램에 관측 가능하다면 프로그램 실행에 영향을 줄 수 있는 불확정성의 원천이 될 것이다. 이러한 이유로 ECMAScript 구현은 관찰자가 관찰하려는 키를 제시하지 않고 WeakMap 의 키를 관찰할 수 있는 어떤 수단도 제공해서는 안 된다.</p>
    <p>WeakMap 은 평균적으로 컬렉션의 키/값 쌍 수에 대해 준선형 접근 시간을 제공하는 해시 테이블 또는 다른 메커니즘으로 구현되어야 한다. 명세에서 사용하는 자료 구조는 WeakMap 의 요구되는 관측 가능 의미를 설명하기 위한 것이며 실제 구현 모델을 의도하지 않는다.</p>
    <emu-note>
      <p>WeakMap 과 WeakSet 은 WeakMap 또는 WeakSet 인스턴스가 없었다면 해당 객체 혹은 심볼이 접근 불가능해져서 구현의 가비지 컬렉션 메커니즘에 의해 자원 회수 대상이 되었을 경우 메모리 자원을 “누출”하지 않는 방식으로 객체나 심볼에 상태를 동적으로 연관시키기 위한 메커니즘을 제공하기 위해 설계되었다. 이 특성은 WeakMap 또는 WeakSet 인스턴스에서 키로 객체/심볼을 역으로 매핑(inverted per-object/symbol mapping)하는 방식으로 달성할 수 있다. 또는 각 WeakMap/WeakSet 인스턴스가 내부적으로 키와 값 데이터를 저장할 수도 있으나 이 방식은 구현과 가비지 컬렉터 사이의 협조가 필요하다. 다음 참조들은 WeakMap 과 WeakSet 구현에 유용할 수 있는 메커니즘을 설명한다:</p>
      <p>Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In <i>Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)</i>, A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183, <a href="http://doi.acm.org/10.1145/263698.263733">http://doi.acm.org/10.1145/263698.263733</a>.</p>
      <p>Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, <a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak">http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak</a></p>
    </emu-note>

    <emu-clause id="sec-weakmap-constructor">
      <h1>WeakMap 생성자</h1>
      <p>WeakMap 생성자:</p>
      <ul>
        <li><dfn>%WeakMap%</dfn> 이다.</li>
        <li>전역 객체의 *"WeakMap"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새 WeakMap 을 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 WeakMap 동작을 상속하려는 서브클래스 생성자는 `WeakMap.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 WeakMap 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-weakmap-iterable">
        <h1>WeakMap ( [ _iterable_ ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _map_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakMap.prototype%"*, « [[WeakMapData]] »).
          1. _map_.[[WeakMapData]] 를 새 빈 List 로 설정.
          1. _iterable_ 이 *undefined* 또는 *null* 이면 _map_ 반환.
          1. _adder_ = ? Get(_map_, *"set"*).
          1. IsCallable(_adder_) *false* 이면 *TypeError* 예외.
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>매개변수 _iterable_ 이 존재하면 첫 요소가 WeakMap 키로 사용될 값이고 두 번째 요소가 그 키에 연결할 값인 2-요소 배열 유사 객체를 생성하는 이터레이터 객체를 반환하는 %Symbol.iterator% 메서드를 구현한 객체일 것으로 기대된다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>WeakMap 생성자의 프로퍼티</h1>
      <p>WeakMap 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype">
        <h1>WeakMap.prototype</h1>
        <p>`WeakMap.prototype` 의 초기 값은 WeakMap 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-prototype-object">
      <h1>WeakMap 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>WeakMap 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%WeakMap.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[WeakMapData]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype.constructor">
        <h1>WeakMap.prototype.constructor</h1>
        <p>`WeakMap.prototype.constructor` 의 초기 값은 %WeakMap% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.delete">
        <h1>WeakMap.prototype.delete ( _key_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[WeakMapData]]) 수행.
          1. CanBeHeldWeakly(_key_) *false* 이면 *false* 반환.
          1. _M_.[[WeakMapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면
              1. _p_.[[Key]] = ~empty~.
              1. _p_.[[Value]] = ~empty~.
              1. *true* 반환.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>값 ~empty~ 는 엔트리가 삭제되었음을 나타내는 명세 기법이다. 실제 구현은 엔트리를 내부 자료 구조에서 물리적으로 제거하는 등의 다른 동작을 할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.get">
        <h1>WeakMap.prototype.get ( _key_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[WeakMapData]]) 수행.
          1. CanBeHeldWeakly(_key_) *false* 이면 *undefined* 반환.
          1. _M_.[[WeakMapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면 _p_.[[Value]] 반환.
          1. *undefined* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.has">
        <h1>WeakMap.prototype.has ( _key_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[WeakMapData]]) 수행.
          1. CanBeHeldWeakly(_key_) *false* 이면 *false* 반환.
          1. _M_.[[WeakMapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.set">
        <h1>WeakMap.prototype.set ( _key_, _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _M_ = *this* 값.
          1. ? RequireInternalSlot(_M_, [[WeakMapData]]) 수행.
          1. CanBeHeldWeakly(_key_) *false* 이면 *TypeError* 예외.
          1. _M_.[[WeakMapData]] 의 각 Record { [[Key]], [[Value]] } _p_ 에 대해
            1. _p_.[[Key]] ≠ ~empty~ 그리고 SameValue(_p_.[[Key]], _key_) = *true* 이면
              1. _p_.[[Value]] = _value_.
              1. _M_ 반환.
          1. _p_ = Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. _p_ 를 _M_.[[WeakMapData]] 에 append.
          1. _M_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakmap.prototype-@@tostringtag" id="sec-weakmap.prototype-%symbol.tostringtag%">
        <h1>WeakMap.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"WeakMap"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakmap-instances">
      <h1>WeakMap 인스턴스의 프로퍼티</h1>
      <p>WeakMap 인스턴스는 일반 객체이며 WeakMap 프로토타입 객체로부터 프로퍼티를 상속한다. 또한 [[WeakMapData]] 내부 슬롯을 가진다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet 객체</h1>
    <p>WeakSet 은 객체 및/또는 심볼의 컬렉션이다. 하나의 고유 객체나 심볼은 WeakSet 컬렉션에서 한 번만 요소로 등장할 수 있다. WeakSet 은 특정 값을 포함하는지 질의할 수 있지만, 보유한 값을 열거하는 메커니즘은 제공되지 않는다. 특정 조건에서 live 가 아닌 값들은 <emu-xref href="#sec-weakref-execution"></emu-xref> 에 설명된 바와 같이 WeakSet 요소로서 제거된다.</p>
    <p>구현은 WeakSet 이 포함한 값이 접근 불가능하게 된 시점과 그 값이 WeakSet 에서 제거되는 시점 사이에 임의로 결정된 지연을 부과할 수 있다. 이 지연이 ECMAScript 프로그램에 관측 가능하다면 프로그램 실행에 영향을 줄 수 있는 불확정성의 원인이 된다. 이러한 이유로 ECMAScript 구현은 관찰자가 관찰된 값을 제시하지 않고 WeakSet 이 특정 값을 포함하는지 결정할 수 있는 수단을 제공해서는 안 된다.</p>
    <p>WeakSet 은 평균적으로 컬렉션 요소 수에 대해 준선형 접근 시간을 제공하는 해시 테이블 또는 다른 메커니즘으로 구현되어야 한다. 명세에서 사용하는 자료 구조는 WeakSet 의 요구되는 관측 가능 의미를 설명하기 위한 것이며 실제 구현 모델을 의도하지 않는다.</p>
    <emu-note>
      <p><emu-xref href="#sec-weakmap-objects"></emu-xref> 의 NOTE 참고.</p>
    </emu-note>

    <emu-clause id="sec-weakset-constructor">
      <h1>WeakSet 생성자</h1>
      <p>WeakSet 생성자:</p>
      <ul>
        <li><dfn>%WeakSet%</dfn> 이다.</li>
        <li>전역 객체의 *"WeakSet"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새 WeakSet 을 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 WeakSet 동작을 상속하려는 서브클래스 생성자는 `WeakSet.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 WeakSet 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-weakset-iterable">
        <h1>WeakSet ( [ _iterable_ ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _set_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakSet.prototype%"*, « [[WeakSetData]] »).
          1. _set_.[[WeakSetData]] 를 새 빈 List 로 설정.
          1. _iterable_ 이 *undefined* 또는 *null* 이면 _set_ 반환.
          1. _adder_ = ? Get(_set_, *"add"*).
          1. IsCallable(_adder_) *false* 이면 *TypeError* 예외.
          1. _iteratorRecord_ = ? GetIterator(_iterable_, ~sync~).
          1. 반복:
            1. _next_ = ? IteratorStepValue(_iteratorRecord_).
            1. _next_ 가 ~done~ 이면 _set_ 반환.
            1. _status_ = Completion(Call(_adder_, _set_, « _next_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>WeakSet 생성자의 프로퍼티</h1>
      <p>WeakSet 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-weakset.prototype">
        <h1>WeakSet.prototype</h1>
        <p>`WeakSet.prototype` 의 초기 값은 WeakSet 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-prototype-object">
      <h1>WeakSet 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>WeakSet 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%WeakSet.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[WeakSetData]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-weakset.prototype.add">
        <h1>WeakSet.prototype.add ( _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[WeakSetData]]) 수행.
          1. CanBeHeldWeakly(_value_) *false* 이면 *TypeError* 예외.
          1. _S_.[[WeakSetData]] 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 그리고 SameValue(_e_, _value_) = *true* 이면
              1. _S_ 반환.
          1. _value_ 를 _S_.[[WeakSetData]] 에 append.
          1. _S_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.constructor">
        <h1>WeakSet.prototype.constructor</h1>
        <p>`WeakSet.prototype.constructor` 의 초기 값은 %WeakSet% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.delete">
        <h1>WeakSet.prototype.delete ( _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[WeakSetData]]) 수행.
          1. CanBeHeldWeakly(_value_) *false* 이면 *false* 반환.
          1. _S_.[[WeakSetData]] 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 그리고 SameValue(_e_, _value_) = *true* 이면
              1. 값이 _e_ 인 _S_.[[WeakSetData]] 요소를 값이 ~empty~ 인 요소로 교체.
              1. *true* 반환.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>값 ~empty~ 는 엔트리가 삭제되었음을 나타내는 명세 기법이다. 실제 구현은 내부 자료 구조에서 물리적으로 제거하는 등의 다른 동작을 할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.has">
        <h1>WeakSet.prototype.has ( _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ = *this* 값.
          1. ? RequireInternalSlot(_S_, [[WeakSetData]]) 수행.
          1. CanBeHeldWeakly(_value_) *false* 이면 *false* 반환.
          1. _S_.[[WeakSetData]] 의 각 요소 _e_ 에 대해
            1. _e_ ≠ ~empty~ 그리고 SameValue(_e_, _value_) = *true* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakset.prototype-@@tostringtag" id="sec-weakset.prototype-%symbol.tostringtag%">
        <h1>WeakSet.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"WeakSet"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakset-instances">
      <h1>WeakSet 인스턴스의 프로퍼티</h1>
      <p>WeakSet 인스턴스는 일반 객체이며 WeakSet 프로토타입 객체로부터 프로퍼티를 상속한다. 또한 [[WeakSetData]] 내부 슬롯을 가진다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-keyed-collections">
    <h1>키드 컬렉션을 위한 추상 연산</h1>

    <emu-clause id="sec-canonicalizekeyedcollectionkey" type="abstract operation">
      <h1>
        CanonicalizeKeyedCollectionKey (
          _key_: an ECMAScript language value,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _key_ 가 *-0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
        1. _key_ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>구조화된 데이터 (Structured Data)</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer 객체</h1>

    <emu-clause id="sec-arraybuffer-notation">
      <h1>표기 (Notation)</h1>
      <p>본 절, <emu-xref href="#sec-atomics-object"></emu-xref>, 그리고 <emu-xref href="#sec-memory-model"></emu-xref> 에서의 아래 설명들은 read-modify-write 수정 함수 내부 데이터 구조를 사용한다.</p>
      <p><dfn variants="read-modify-write modification functions">read-modify-write 수정 함수</dfn>란 두 개의 바이트 값 List 를 인수로 받고 바이트 값 List 를 반환하는 추상 클로저로 표현되는 수학적 함수이다. 이러한 추상 클로저는 다음 모든 성질을 만족한다:</p>
      <ul>
        <li>알고리즘 단계 전부를 원자적으로 수행한다.</li>
        <li>개별 알고리즘 단계는 관측 불가능하다.</li>
      </ul>
      <emu-note>
        <p>read-modify-write 수정 함수의 알고리즘 단계가 순수한 수학적 함수임을 검증하는 데 도움을 주기 위해 다음 편집 지침을 권장한다:</p>
        <ul>
          <li>직접 또는 호출된 추상 연산과 추상 클로저를 통한 간접 접근을 포함하여, 매개변수와 캡처된 값 외의 어떤 언어/명세 값에도 접근하지 않는다.</li>
          <li>Completion Record 를 반환하는 추상 연산이나 추상 클로저를 직접 또는 간접으로 호출하지 않는다.</li>
          <li>Completion Record 를 반환하지 않는다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-fixed-length-and-resizable-arraybuffer-objects">
      <h1>고정 길이 및 크기 변경 가능(ArrayBuffer) 객체</h1>
      <p><dfn>fixed-length ArrayBuffer</dfn> 는 생성 후 바이트 길이가 변하지 않는 ArrayBuffer 이다.</p>
      <p><dfn>resizable ArrayBuffer</dfn> 는 <emu-xref href="#sec-arraybuffer.prototype.resize" title></emu-xref> 호출을 통해 생성 후 바이트 길이가 변할 수 있는 ArrayBuffer 이다.</p>
      <p>어떤 종류의 ArrayBuffer 객체가 생성되는지는 <emu-xref href="#sec-arraybuffer-length" title></emu-xref> 에 전달된 인수에 따라 결정된다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-arraybuffer-objects">
      <h1>ArrayBuffer 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-allocatearraybuffer" type="abstract operation">
        <h1>
          AllocateArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): ArrayBuffer 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ArrayBuffer 를 생성하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _slots_ = « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».
          1. _maxByteLength_ 가 존재하고 ~empty~ 가 아니면 _allocatingResizableBuffer_ = *true*; 그렇지 않으면 *false*.
          1. _allocatingResizableBuffer_ = *true* 이면
            1. _byteLength_ > _maxByteLength_ 이면 *RangeError* 예외.
            1. _slots_ 에 [[ArrayBufferMaxByteLength]] 추가.
          1. _obj_ = ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, _slots_).
          1. _block_ = ? CreateByteDataBlock(_byteLength_).
          1. _obj_.[[ArrayBufferData]] = _block_.
          1. _obj_.[[ArrayBufferByteLength]] = _byteLength_.
          1. _allocatingResizableBuffer_ = *true* 이면
            1. 길이가 _maxByteLength_ 바이트인 Data Block _block_ 을 생성할 수 없다면 *RangeError* 예외.
            1. NOTE: Resizable ArrayBuffer 는 제자리(in-place) 증가로 구현 가능하도록 설계되었다. 예를 들어 가상 메모리를 미리 예약할 수 없는 경우 구현은 예외를 던질 수 있다.
            1. _obj_.[[ArrayBufferMaxByteLength]] = _maxByteLength_.
          1. _obj_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybufferbytelength" type="abstract operation">
        <h1>
          ArrayBufferByteLength (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _order_: ~seq-cst~ or ~unordered~,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsSharedArrayBuffer(_arrayBuffer_) = *true* 그리고 _arrayBuffer_ 가 [[ArrayBufferByteLengthData]] 내부 슬롯을 가지면
            1. _bufferByteLengthBlock_ = _arrayBuffer_.[[ArrayBufferByteLengthData]].
            1. _rawLength_ = GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_).
            1. _isLittleEndian_ = 주변 에이전트의 Agent Record 의 [[LittleEndian]] 필드 값.
            1. Return ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)).
          1. Assert: IsDetachedBuffer(_arrayBuffer_) = *false*.
          1. Return _arrayBuffer_.[[ArrayBufferByteLength]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffercopyanddetach" type="abstract operation">
        <h1>
          ArrayBufferCopyAndDetach (
            _arrayBuffer_: an ECMAScript language value,
            _newLength_: an ECMAScript language value,
            _preserveResizability_: ~preserve-resizability~ or ~fixed-length~,
          ): ArrayBuffer 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_arrayBuffer_) = *true* 이면 *TypeError* 예외.
          1. _newLength_ 가 *undefined* 이면
            1. _newByteLength_ = _arrayBuffer_.[[ArrayBufferByteLength]].
          1. Else
            1. _newByteLength_ = ? ToIndex(_newLength_).
          1. IsDetachedBuffer(_arrayBuffer_) = *true* 이면 *TypeError* 예외.
          1. _preserveResizability_ = ~preserve-resizability~ 그리고 IsFixedLengthArrayBuffer(_arrayBuffer_) = *false* 이면
            1. _newMaxByteLength_ = _arrayBuffer_.[[ArrayBufferMaxByteLength]].
          1. Else
            1. _newMaxByteLength_ = ~empty~.
          1. _arrayBuffer_.[[ArrayBufferDetachKey]] ≠ *undefined* 이면 *TypeError* 예외.
          1. _newBuffer_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta>.
          1. _copyLength_ = min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]).
          1. _fromBlock_ = _arrayBuffer_.[[ArrayBufferData]].
          1. _toBlock_ = _newBuffer_.[[ArrayBufferData]].
          1. CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_) 수행.
          1. NOTE: 새 Data Block 생성과 구 Data Block 으로부터의 복사는 관측 불가능하다. 구현은 zero-copy 이동 또는 `realloc` 으로 최적화할 수 있다.
          1. ! DetachArrayBuffer(_arrayBuffer_) 수행.
          1. _newBuffer_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdetachedbuffer" type="abstract operation">
        <h1>
          IsDetachedBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _arrayBuffer_.[[ArrayBufferData]] 가 *null* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-detacharraybuffer" type="abstract operation">
        <h1>
          DetachArrayBuffer (
            _arrayBuffer_: an ArrayBuffer,
            optional _key_: anything,
          ): ~unused~ 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>skip global checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) = *false*.
          1. _key_ 가 존재하지 않으면 _key_ = *undefined*.
          1. _arrayBuffer_.[[ArrayBufferDetachKey]] ≠ _key_ 이면 *TypeError* 예외.
          1. _arrayBuffer_.[[ArrayBufferData]] = *null*.
          1. _arrayBuffer_.[[ArrayBufferByteLength]] = 0.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-note>
          <p>ArrayBuffer 인스턴스를 분리(detach)하면 그 인스턴스가 사용하던 Data Block 과의 연결이 끊어지고 버퍼의 바이트 길이는 0이 된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-clonearraybuffer" type="abstract operation">
        <h1>
          CloneArrayBuffer (
            _srcBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _srcByteOffset_: a non-negative integer,
            _srcLength_: a non-negative integer,
          ): ArrayBuffer 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_srcByteOffset_ 부터 _srcLength_ 바이트 범위의 _srcBuffer_ 데이터를 복사한 새 ArrayBuffer 를 생성한다.</dd>
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_srcBuffer_) = *false*.
          1. _targetBuffer_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta>.
          1. _srcBlock_ = _srcBuffer_.[[ArrayBufferData]].
          1. _targetBlock_ = _targetBuffer_.[[ArrayBufferData]].
          1. CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_) 수행.
          1. _targetBuffer_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
        <h1>
          GetArrayBufferMaxByteLengthOption (
            _options_: an ECMAScript language value,
          ): 음이 아닌 정수 또는 ~empty~ 를 포함하는 정상 완료, 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _options_ 가 Object 가 아니면 ~empty~ 반환.
          1. _maxByteLength_ = ? Get(_options_, *"maxByteLength"*).
          1. _maxByteLength_ = *undefined* 이면 ~empty~ 반환.
          1. Return ? ToIndex(_maxByteLength_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation">
        <h1>
          HostResizeArrayBuffer (
            _buffer_: an ArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): ~handled~ 또는 ~unhandled~ 를 포함하는 정상 완료, 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>호스트가 _buffer_ 에 대한 구현 정의 크기 조정을 수행할 기회를 제공한다. 크기 조정을 처리하지 않으려면 기본 동작을 위해 ~unhandled~ 를 반환할 수 있다.</dd>
        </dl>

        <p>HostResizeArrayBuffer 구현은 다음 요구사항을 준수해야 한다:</p>
        <ul>
          <li>_buffer_ 를 분리(detach)하지 않는다.</li>
          <li>정상 완료로 ~handled~ 를 반환하면 _buffer_.[[ArrayBufferByteLength]] = _newByteLength_ 이다.</li>
        </ul>

        <p>기본 구현은 NormalCompletion(~unhandled~) 를 반환한다.</p>
      </emu-clause>

      <emu-clause id="sec-isfixedlengtharraybuffer" type="abstract operation">
        <h1>
          IsFixedLengthArrayBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _arrayBuffer_ 가 [[ArrayBufferMaxByteLength]] 내부 슬롯을 가지면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunsignedelementtype" type="abstract operation">
        <h1>
          IsUnsignedElementType (
            _type_: a TypedArray element type,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>인수 _type_ 이 부호 없는 TypedArray 요소 타입인지 검증한다.</dd>
        </dl>
        <emu-alg>
          1. _type_ 이 ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, ~biguint64~ 중 하나이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunclampedintegerelementtype" type="abstract operation">
        <h1>
          IsUnclampedIntegerElementType (
            _type_: a TypedArray element type,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>인수 _type_ 이 ~uint8clamped~ 를 제외한 정수 TypedArray 요소 타입인지 검증한다.</dd>
        </dl>
        <emu-alg>
          1. _type_ 이 ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, ~uint32~ 중 하나이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isbigintelementtype" type="abstract operation">
        <h1>
          IsBigIntElementType (
            _type_: a TypedArray element type,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>인수 _type_ 이 BigInt TypedArray 요소 타입인지 검증한다.</dd>
        </dl>
        <emu-alg>
          1. _type_ 이 ~biguint64~ 또는 ~bigint64~ 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isnotearconfiguration" type="abstract operation">
        <h1>
          IsNoTearConfiguration (
            _type_: a TypedArray element type,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsUnclampedIntegerElementType(_type_) = *true* 이면 *true* 반환.
          1. IsBigIntElementType(_type_) = *true* 이고 _order_ 가 ~init~, ~unordered~ 가 아니면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rawbytestonumeric" type="abstract operation" oldids="sec-rawbytestonumber">
        <h1>
          RawBytesToNumeric (
            _type_: a TypedArray element type,
            _rawBytes_: a List of byte values,
            _isLittleEndian_: a Boolean,
          ): Number 또는 BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 요소 타입 _type_ 에 대해 지정된 Element Size 값.
          1. _isLittleEndian_ = *false* 이면 _rawBytes_ 요소 순서를 반전.
          1. _type_ = ~float16~ 이면
            1. _value_ = _rawBytes_ 바이트들을 이어 붙인 후 little-endian 비트열로 해석한 IEEE 754-2019 binary16 값.
            1. _value_ 가 NaN 이면 *NaN* 반환.
            1. _value_ 에 해당하는 Number 값 반환.
          1. _type_ = ~float32~ 이면
            1. (동일 절차, binary32) → NaN 처리 동일.
          1. _type_ = ~float64~ 이면
            1. (동일 절차, binary64) → NaN 처리 동일.
          1. IsUnsignedElementType(_type_) = *true* 이면
            1. _intValue_ = _rawBytes_ 바이트들을 이어 붙여 해석한 unsigned little-endian 이진 수.
          1. Else
            1. _intValue_ = _rawBytes_ 바이트들을 이어 붙여 해석한 길이 (_elementSize_ × 8) 비트의 little-endian 2의 보수 이진 수.
          1. IsBigIntElementType(_type_) = *true* 이면 _intValue_ 에 해당하는 BigInt 반환.
          1. 그렇지 않으면 _intValue_ 에 해당하는 Number 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getrawbytesfromsharedblock" type="abstract operation">
        <h1>
          GetRawBytesFromSharedBlock (
            _block_: a Shared Data Block,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
          ): 바이트 값 List
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 요소 타입 _type_ 의 Element Size 값.
          1. _execution_ = 주변 에이전트의 Agent Record 의 [[CandidateExecution]] 필드.
          1. _eventsRecord_ = _execution_.[[EventsRecords]] 중 [[AgentSignifier]] = AgentSignifier() 인 Agent Events Record.
          1. _isTypedArray_ = *true* 그리고 IsNoTearConfiguration(_type_, _order_) = *true* 이면 _noTear_ = *true*, 아니면 *false*.
          1. _rawValue_ = 길이 _elementSize_ 이고 요소가 비결정적으로 선택된 바이트 값인 List.
          1. NOTE: 구현에서 _rawValue_ 는 하드웨어의 비원자/원자 읽기 결과이다. 비결정성은 약한 일관성 하드웨어의 관측 가능 동작을 기술하기 위한 의미적 규정이다.
          1. _readEvent_ = ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.
          1. _eventsRecord_.[[EventList]] 에 _readEvent_ 추가.
          1. _execution_.[[ChosenValues]] 에 Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } 추가.
          1. _rawValue_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvaluefrombuffer" type="abstract operation">
        <h1>
          GetValueFromBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
            optional _isLittleEndian_: a Boolean,
          ): Number 또는 BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) = *false*.
          1. Assert: _byteIndex_ 에서 시작하여 _type_ 값을 표현하기에 충분한 바이트가 존재.
          1. _block_ = _arrayBuffer_.[[ArrayBufferData]].
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _type_ 의 Element Size.
          1. IsSharedArrayBuffer(_arrayBuffer_) = *true* 이면
            1. Assert: _block_ 은 Shared Data Block.
            1. _rawValue_ = GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_).
          1. Else
            1. _rawValue_ = _block_ 에서 [_byteIndex_, _byteIndex_ + _elementSize_) 구간의 바이트 List.
          1. Assert: _rawValue_ 길이 = _elementSize_.
          1. _isLittleEndian_ 미지정이면 주변 에이전트 Agent Record 의 [[LittleEndian]] 값으로 설정.
          1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numerictorawbytes" type="abstract operation" oldids="sec-numbertorawbytes">
        <h1>
          NumericToRawBytes (
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isLittleEndian_: a Boolean,
          ): 바이트 값 List
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _type_ = ~float16~ 이면
            1. _rawBytes_ = _value_ 를 roundTiesToEven 방식으로 IEEE 754-2019 binary16 형식으로 변환한 2바이트 List (little endian). _value_ 가 *NaN* 이면 구현이 선택한 binary16 NaN 인코딩(구현 구분 가능한 동일 *NaN* 에 대해 항상 동일 인코딩)을 사용.
          1. Else if _type_ = ~float32~
            1. (동일, 4바이트 binary32)
          1. Else if _type_ = ~float64~
            1. (동일, 8바이트 binary64)
          1. Else
            1. _n_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _type_ 의 Element Size.
            1. _conversionOperation_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 변환 연산 열의 _type_ 에 해당하는 추상 연산.
            1. _intValue_ = ℝ(! _conversionOperation_(_value_)).
            1. _intValue_ ≥ 0 이면
              1. _rawBytes_ = _intValue_ 의 _n_ 바이트 이진 인코딩 (little endian).
            1. Else
              1. _rawBytes_ = _intValue_ 의 _n_ 바이트 2의 보수 이진 인코딩 (little endian).
          1. _isLittleEndian_ = *false* 이면 _rawBytes_ 순서 반전.
          1. _rawBytes_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setvalueinbuffer" type="abstract operation">
        <h1>
          SetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
            optional _isLittleEndian_: a Boolean,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) = *false*.
          1. Assert: _byteIndex_ 에서 시작하여 _type_ 값을 표현하기 충분한 바이트 존재.
          1. Assert: IsBigIntElementType(_type_) = *true* 이면 _value_ 는 BigInt; 아니면 Number.
          1. _block_ = _arrayBuffer_.[[ArrayBufferData]].
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _type_ 의 Element Size.
          1. _isLittleEndian_ 미지정이면 주변 에이전트 Agent Record 의 [[LittleEndian]] 값으로 설정.
          1. _rawBytes_ = NumericToRawBytes(_type_, _value_, _isLittleEndian_).
          1. IsSharedArrayBuffer(_arrayBuffer_) = *true* 이면
            1. _execution_ = 주변 에이전트 Agent Record 의 [[CandidateExecution]].
            1. _eventsRecord_ = _execution_.[[EventsRecords]] 중 현재 AgentSignifier() 와 일치하는 것.
            1. _isTypedArray_ = *true* 그리고 IsNoTearConfiguration(_type_, _order_) = *true* 이면 _noTear_ = *true*; 아니면 *false*.
            1. WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } 를 _eventsRecord_.[[EventList]] 에 추가.
          1. Else
            1. _rawBytes_ 개별 바이트를 _block_[_byteIndex_] 부터 순서대로 저장.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" type="abstract operation">
        <h1>
          GetModifySetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _op_: a read-modify-write modification function,
          ): Number 또는 BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) = *false*.
          1. Assert: _byteIndex_ 에서 시작하여 _type_ 값을 표현하기 충분한 바이트 존재.
          1. Assert: IsBigIntElementType(_type_) = *true* 이면 _value_ 는 BigInt; 아니면 Number.
          1. _block_ = _arrayBuffer_.[[ArrayBufferData]].
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _type_ 의 Element Size.
          1. _isLittleEndian_ = 주변 에이전트 Agent Record 의 [[LittleEndian]] 값.
          1. _rawBytes_ = NumericToRawBytes(_type_, _value_, _isLittleEndian_).
          1. IsSharedArrayBuffer(_arrayBuffer_) = *true* 이면
            1. _execution_ = 주변 에이전트 Agent Record 의 [[CandidateExecution]].
            1. _eventsRecord_ = _execution_.[[EventsRecords]] 중 현재 AgentSignifier() 에 해당하는 것.
            1. _rawBytesRead_ = 길이 _elementSize_ 인, 비결정적으로 선택된 바이트 값 List.
            1. NOTE: 구현에서 _rawBytesRead_ 는 하드웨어의 load-link / load-exclusive / read-modify-write 명령의 피연산자 결과. 비결정성은 약한 일관성 하드웨어의 관측 가능 행위를 기술.
            1. _rmwEvent_ = ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.
            1. _eventsRecord_.[[EventList]] 에 _rmwEvent_ 추가.
            1. _execution_.[[ChosenValues]] 에 Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } 추가.
          1. Else
            1. _rawBytesRead_ = 길이 _elementSize_ 인 바이트 시퀀스 (_block_[_byteIndex_] 부터).
            1. _rawBytesModified_ = _op_(_rawBytesRead_, _rawBytes_).
            1. _rawBytesModified_ 바이트를 _block_[_byteIndex_] 부터 저장.
          1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arraybuffer-constructor">
      <h1>ArrayBuffer 생성자</h1>
      <p>ArrayBuffer 생성자:</p>
      <ul>
        <li><dfn>%ArrayBuffer%</dfn> 이다.</li>
        <li>전역 객체 *"ArrayBuffer"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새 ArrayBuffer 를 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의 `extends` 절의 값으로 사용할 수 있다. 지정된 ArrayBuffer 동작을 상속하려면 서브클래스 생성자가 `ArrayBuffer.prototype` 내장 메서드 지원에 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 ArrayBuffer 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-arraybuffer-length">
        <h1>ArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _byteLength_ = ? ToIndex(_length_).
          1. _requestedMaxByteLength_ = ? GetArrayBufferMaxByteLengthOption(_options_).
          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>ArrayBuffer 생성자의 프로퍼티</h1>
      <p>ArrayBuffer 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-arraybuffer.isview">
        <h1>ArrayBuffer.isView ( _arg_ )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _arg_ 가 Object 가 아니면 *false* 반환.
          1. _arg_ 가 [[ViewedArrayBuffer]] 내부 슬롯을 가지면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype">
        <h1>ArrayBuffer.prototype</h1>
        <p>`ArrayBuffer.prototype` 의 초기 값은 ArrayBuffer 프로토타입 객체이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-arraybuffer-@@species" id="sec-get-arraybuffer-%symbol.species%">
        <h1>get ArrayBuffer [ %Symbol.species% ]</h1>
        <p>`ArrayBuffer[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값 반환.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p><emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> 는 보통 자신의 *this* 값의 생성자를 사용해 파생 객체를 생성한다. 그러나 서브클래스 생성자는 %Symbol.species% 재정의를 통해 <emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> 메서드에 대한 기본 동작을 변경할 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>ArrayBuffer 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>ArrayBuffer 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%ArrayBuffer.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[ArrayBufferData]] 또는 [[ArrayBufferByteLength]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength</h1>
        <p>`ArrayBuffer.prototype.byteLength` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. IsDetachedBuffer(_O_) = *true* 이면 *+0*<sub>𝔽</sub> 반환.
          1. _length_ = _O_.[[ArrayBufferByteLength]].
          1. 𝔽(_length_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.constructor">
        <h1>ArrayBuffer.prototype.constructor</h1>
        <p>`ArrayBuffer.prototype.constructor` 의 초기 값은 %ArrayBuffer% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.detached">
        <h1>get ArrayBuffer.prototype.detached</h1>
        <p>`ArrayBuffer.prototype.detached` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. Return IsDetachedBuffer(_O_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
        <h1>get ArrayBuffer.prototype.maxByteLength</h1>
        <p>`ArrayBuffer.prototype.maxByteLength` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. IsDetachedBuffer(_O_) = *true* 이면 *+0*<sub>𝔽</sub> 반환.
          1. IsFixedLengthArrayBuffer(_O_) = *true* 이면
            1. _length_ = _O_.[[ArrayBufferByteLength]].
          1. Else
            1. _length_ = _O_.[[ArrayBufferMaxByteLength]].
          1. 𝔽(_length_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.resizable">
        <h1>get ArrayBuffer.prototype.resizable</h1>
        <p>`ArrayBuffer.prototype.resizable` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. IsFixedLengthArrayBuffer(_O_) = *false* 이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.resize">
        <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. _newByteLength_ = ? ToIndex(_newLength_).
          1. IsDetachedBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]] 이면 *RangeError* 예외.
          1. _hostHandled_ = ? HostResizeArrayBuffer(_O_, _newByteLength_).
          1. _hostHandled_ = ~handled~ 이면 *undefined* 반환.
          1. _oldBlock_ = _O_.[[ArrayBufferData]].
          1. _newBlock_ = ? CreateByteDataBlock(_newByteLength_).
          1. _copyLength_ = min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
          1. CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_) 수행.
          1. NOTE: 새 Data Block 생성과 복사는 관측 불가능하며, 구현은 제자리 증가/축소로 구현할 수 있다.
          1. _O_.[[ArrayBufferData]] = _newBlock_.
          1. _O_.[[ArrayBufferByteLength]] = _newByteLength_.
          1. *undefined* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. IsDetachedBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. _len_ = _O_.[[ArrayBufferByteLength]].
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _first_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _first_ = max(_len_ + _relativeStart_, 0).
          1. Else _first_ = min(_relativeStart_, _len_).
          1. _end_ = *undefined* 이면 _relativeEnd_ = _len_; 아니면 _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _final_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _final_ = max(_len_ + _relativeEnd_, 0).
          1. Else _final_ = min(_relativeEnd_, _len_).
          1. _newLen_ = max(_final_ - _first_, 0).
          1. _ctor_ = ? SpeciesConstructor(_O_, %ArrayBuffer%).
          1. _new_ = ? Construct(_ctor_, « 𝔽(_newLen_) »).
          1. ? RequireInternalSlot(_new_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_new_) = *true* 이면 *TypeError* 예외.
          1. IsDetachedBuffer(_new_) = *true* 이면 *TypeError* 예외.
          1. SameValue(_new_, _O_) = *true* 이면 *TypeError* 예외.
          1. _new_.[[ArrayBufferByteLength]] &lt; _newLen_ 이면 *TypeError* 예외.
          1. NOTE: 위 단계의 부작용으로 _O_ 가 분리 또는 크기 변경되었을 수 있다.
          1. IsDetachedBuffer(_O_) = *true* 이면 *TypeError* 예외.
          1. _fromBuf_ = _O_.[[ArrayBufferData]].
          1. _toBuf_ = _new_.[[ArrayBufferData]].
          1. _currentLen_ = _O_.[[ArrayBufferByteLength]].
          1. _first_ &lt; _currentLen_ 이면
            1. _count_ = min(_newLen_, _currentLen_ - _first_).
            1. CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_) 수행.
          1. _new_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfer">
        <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfertofixedlength">
        <h1>ArrayBuffer.prototype.transferToFixedLength ( [ _newLength_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-arraybuffer.prototype-@@tostringtag" id="sec-arraybuffer.prototype-%symbol.tostringtag%">
        <h1>ArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"ArrayBuffer"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-instances">
      <h1>ArrayBuffer 인스턴스의 프로퍼티</h1>
      <p>ArrayBuffer 인스턴스는 ArrayBuffer 프로토타입 객체로부터 프로퍼티를 상속한다. 각 ArrayBuffer 인스턴스는 [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] 내부 슬롯을 갖는다. 크기 변경 가능한 인스턴스는 [[ArrayBufferMaxByteLength]] 내부 슬롯도 갖는다.</p>
      <p>[[ArrayBufferData]] 가 *null* 인 ArrayBuffer 인스턴스는 분리(detached)된 것으로 간주되며 해당 ArrayBuffer 내 데이터에 접근·수정하는 모든 연산은 실패한다.</p>
      <p>[[ArrayBufferDetachKey]] 가 *undefined* 가 아닌 값으로 설정된 ArrayBuffer 인스턴스는 DetachArrayBuffer 호출 시 동일 "detach key" 를 인수로 전달해야 하며, 그렇지 않으면 TypeError 가 발생한다. 이 내부 슬롯은 명세 알고리즘이 아닌 특정 임베딩 환경에서만 설정된다.</p>
    </emu-clause>

    <emu-clause id="sec-resizable-arraybuffer-guidelines">
      <h1>크기 변경 가능 ArrayBuffer 가이드라인</h1>
      <emu-note>
        <p>다음은 크기 변경 가능 ArrayBuffer 를 사용하는 ECMAScript 프로그래머를 위한 지침이다.</p>
        <p>가능하다면 배포 환경에서 프로그램을 테스트하는 것을 권장한다. 사용 가능한 물리 메모리 양은 하드웨어 장치마다 크게 다르다. 유사하게 가상 메모리 서브시스템 역시 하드웨어 및 운영체제에 따라 크게 다르다. 64비트 데스크톱 웹 브라우저에서 메모리 부족 없이 동작하는 애플리케이션이 32비트 모바일 웹 브라우저에서는 메모리를 소진할 수 있다.</p>
        <p>크기 변경 가능 ArrayBuffer 의 *"maxByteLength"* 옵션 값을 선택할 때는 애플리케이션에 필요한 최소 가능한 값을 선택할 것을 권장한다. *"maxByteLength"* 가 1,073,741,824 (2<sup>30</sup> 바이트, 1GiB) 를 초과하지 않도록 권장한다.</p>
        <p>특정 최대 크기에 대해 크기 변경 가능 ArrayBuffer 를 성공적으로 생성했다 해서 이후 모든 크기 변경이 성공함을 보장하지 않는다.</p>
      </emu-note>

      <emu-note>
        <p>다음은 크기 변경 가능 ArrayBuffer 를 구현하는 ECMAScript 구현자들을 위한 지침이다.</p>
        <p>Resizable ArrayBuffer 는 크기 변경 시 복사를 수행하거나, 가상 메모리를 미리 예약하는 제자리 증가(in-place growth), 또는 생성자 *"maxByteLength"* 값에 따라 양자의 혼합으로 구현될 수 있다.</p>
        <p>호스트가 다중 테넌트(예: 동시에 여러 ECMAScript 애플리케이션 실행) 환경(웹 브라우저 등)이고 구현이 가상 메모리 예약을 통한 제자리 증가를 선택한다면, 32비트와 64비트 구현 모두에서 *"maxByteLength"* ≥ 1GiB~1.5GiB 값에 대해 예외를 던질 것을 권장한다. 이는 단일 애플리케이션이 가상 주소 공간을 고갈시킬 가능성과 상호 운용성 위험을 줄이기 위함이다.</p>
        <p>호스트에 가상 메모리가 없거나(예: MMU 없는 임베디드 장치), 혹은 호스트가 복사 기반 크기 조정만 구현한다면 *"maxByteLength"* 옵션에 대해 임의의 <emu-not-ref>Number value for</emu-not-ref> 를 받을 수 있다. 하지만 요청된 크기의 메모리 블록을 절대 할당할 수 없다면 *RangeError* 를 던질 것을 권장한다(예: 요청 크기가 장치에서 사용 가능한 최대 메모리보다 큰 경우).</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer 객체</h1>

    <emu-clause id="sec-fixed-length-and-growable-sharedarraybuffer-objects">
      <h1>고정 길이 및 증가 가능(Growable) SharedArrayBuffer 객체</h1>
      <p><dfn>fixed-length SharedArrayBuffer</dfn> 는 생성 후 바이트 길이가 변경될 수 없는 SharedArrayBuffer 이다.</p>
      <p><dfn>growable SharedArrayBuffer</dfn> 는 <emu-xref href="#sec-sharedarraybuffer.prototype.grow" title></emu-xref> 호출을 통해 생성 후 바이트 길이가 증가할 수 있는 SharedArrayBuffer 이다.</p>
      <p>생성되는 SharedArrayBuffer 객체의 종류는 <emu-xref href="#sec-sharedarraybuffer-length" title></emu-xref> 에 전달되는 인수에 따라 결정된다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects">
      <h1>SharedArrayBuffer 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation">
        <h1>
          AllocateSharedArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): SharedArrayBuffer 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>SharedArrayBuffer 를 생성하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _slots_ = « [[ArrayBufferData]] ».
          1. _maxByteLength_ 가 존재하고 ~empty~ 가 아니면 _allocatingGrowableBuffer_ = *true*; 아니면 *false*.
          1. _allocatingGrowableBuffer_ = *true* 이면
            1. _byteLength_ > _maxByteLength_ 이면 *RangeError* 예외.
            1. _slots_ 에 [[ArrayBufferByteLengthData]] 및 [[ArrayBufferMaxByteLength]] 추가.
          1. Else
            1. _slots_ 에 [[ArrayBufferByteLength]] 추가.
          1. _obj_ = ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, _slots_).
          1. _allocatingGrowableBuffer_ = *true* 이면 _allocLength_ = _maxByteLength_; 아니면 _allocLength_ = _byteLength_.
          1. _block_ = ? CreateSharedByteDataBlock(_allocLength_).
          1. _obj_.[[ArrayBufferData]] = _block_.
          1. _allocatingGrowableBuffer_ = *true* 이면
            1. Assert: _byteLength_ ≤ _maxByteLength_.
            1. _byteLengthBlock_ = ? CreateSharedByteDataBlock(8).
            1. SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~) 수행.
            1. _obj_.[[ArrayBufferByteLengthData]] = _byteLengthBlock_.
            1. _obj_.[[ArrayBufferMaxByteLength]] = _maxByteLength_.
          1. Else
            1. _obj_.[[ArrayBufferByteLength]] = _byteLength_.
          1. _obj_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issharedarraybuffer" type="abstract operation">
        <h1>
          IsSharedArrayBuffer (
            _obj_: an ArrayBuffer or a SharedArrayBuffer,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>객체가 ArrayBuffer, SharedArrayBuffer, 또는 그 서브타입인지 검사한다.</dd>
        </dl>
        <emu-alg>
          1. _bufferData_ = _obj_.[[ArrayBufferData]].
          1. _bufferData_ 가 *null* 이면 *false* 반환.
          1. _bufferData_ 가 Data Block 이면 *false* 반환.
          1. Assert: _bufferData_ 는 Shared Data Block.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation">
        <h1>
          HostGrowSharedArrayBuffer (
            _buffer_: a SharedArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): ~handled~ 또는 ~unhandled~ 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>호스트가 _buffer_ 에 대해 구현 정의 증가(grow)를 수행할 기회를 제공한다. 처리하지 않으려면 기본 동작을 위해 ~unhandled~ 를 반환할 수 있다.</dd>
        </dl>
        <p>HostGrowSharedArrayBuffer 구현은 다음 요구사항을 따른다:</p>
        <ul>
          <li>추상 연산이 ~unhandled~ 로 정상 완료하지 않고, _newByteLength_ &lt; _buffer_ 의 현재 바이트 길이이거나 _newByteLength_ > _buffer_.[[ArrayBufferMaxByteLength]] 이면 *RangeError* 예외.</li>
          <li>_isLittleEndian_ = 주변 에이전트 Agent Record 의 [[LittleEndian]] 필드 값. 연산이 ~handled~ 로 정상 완료하면, [[Order]] = ~seq-cst~, [[Payload]] = NumericToRawBytes(~biguint64~, _newByteLength_, _isLittleEndian_), [[Block]] = _buffer_.[[ArrayBufferByteLengthData]], [[ByteIndex]] = 0, [[ElementSize]] = 8 인 WriteSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트가 후보 실행에 추가되어, `SharedArrayBuffer.prototype.grow` 에 대한 경합 호출이 “소실”(조용히 아무 것도 하지 않음)되지 않도록 한다.</li>
        </ul>

        <emu-note>
          <p>두 번째 요구사항은 _buffer_ 의 현재 바이트 길이를 언제/어떻게 읽는지에 대해 의도적으로 모호하다. 길이 갱신은 하드웨어의 원자적 read-modify-write 명령을 통해 이루어져야 하므로 load-link/store-conditional 또는 load-exclusive/store-exclusive 쌍을 사용하는 구조에서는 명령을 가깝게 유지하고 싶을 수 있다. 따라서 SharedArrayBuffer.prototype.grow 자체는 HostGrowSharedArrayBuffer 호출 전 _newByteLength_ 에 대한 경계 검사를 수행하지 않으며, 현재 바이트 길이를 언제 읽어야 한다는 요구도 없다.</p>
          <p>이는 _newByteLength_ 가 0 이상이며 _buffer_.[[ArrayBufferMaxByteLength]] 이하임이 보장되는 HostResizeArrayBuffer 와 대조적이다.</p>
        </emu-note>

        <p>기본 구현은 NormalCompletion(~unhandled~) 를 반환한다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer-constructor">
      <h1>SharedArrayBuffer 생성자</h1>
      <p>SharedArrayBuffer 생성자:</p>
      <ul>
        <li><dfn>%SharedArrayBuffer%</dfn> 이다.</li>
        <li>해당 프로퍼티가 존재한다면 전역 객체 *"SharedArrayBuffer"* 프로퍼티의 초기 값이다 (아래 참조).</li>
        <li>생성자로 호출되면 새 SharedArrayBuffer 를 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의 `extends` 절의 값으로 사용할 수 있다. 지정된 SharedArrayBuffer 동작을 상속하려는 서브클래스 생성자는 `SharedArrayBuffer.prototype` 내장 메서드 동작을 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 SharedArrayBuffer 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <p>호스트가 SharedArrayBuffer 에 대한 동시 접근을 제공하지 않는 경우 전역 객체의 *"SharedArrayBuffer"* 프로퍼티를 생략할 수 있다.</p>

      <emu-note>
        <p>`ArrayBuffer` 와 달리 `SharedArrayBuffer` 는 분리(detach)되지 않으며 그 내부 [[ArrayBufferData]] 슬롯은 *null* 이 되지 않는다.</p>
      </emu-note>

      <emu-clause id="sec-sharedarraybuffer-length">
        <h1>SharedArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. _byteLength_ = ? ToIndex(_length_).
          1. _requestedMaxByteLength_ = ? GetArrayBufferMaxByteLengthOption(_options_).
          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>SharedArrayBuffer 생성자의 프로퍼티</h1>
      <p>SharedArrayBuffer 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-sharedarraybuffer.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>`SharedArrayBuffer.prototype` 의 초기 값은 SharedArrayBuffer 프로토타입 객체이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer-@@species" id="sec-sharedarraybuffer-%symbol.species%">
        <h1>get SharedArrayBuffer [ %Symbol.species% ]</h1>
        <p>`SharedArrayBuffer[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. *this* 값 반환.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object">
      <h1>SharedArrayBuffer 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>SharedArrayBuffer 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%SharedArrayBuffer.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[ArrayBufferData]] 또는 [[ArrayBufferByteLength]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>
        <p>`SharedArrayBuffer.prototype.byteLength` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *false* 이면 *TypeError* 예외.
          1. _length_ = ArrayBufferByteLength(_O_, ~seq-cst~).
          1. 𝔽(_length_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>`SharedArrayBuffer.prototype.constructor` 의 초기 값은 %SharedArrayBuffer% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.grow">
        <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *false* 이면 *TypeError* 예외.
          1. _newByteLength_ = ? ToIndex(_newLength_).
          1. _hostHandled_ = ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).
          1. _hostHandled_ = ~handled~ 이면 *undefined* 반환.
          1. _isLittleEndian_ = 주변 에이전트 Agent Record 의 [[LittleEndian]] 값.
          1. _byteLengthBlock_ = _O_.[[ArrayBufferByteLengthData]].
          1. _currentByteLengthRawBytes_ = GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~).
          1. _newByteLengthRawBytes_ = NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_).
          1. 반복:
            1. NOTE: 동일 버퍼에 대한 경합 증가 호출이 완전 순서화되고 유실되지 않으며 침묵 실패하지 않도록 하는 compare-and-exchange 루프이다. 경합 없이 증가 시도 가능하면 루프 종료.
            1. _currentByteLength_ = ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)).
            1. _newByteLength_ = _currentByteLength_ 이면 *undefined* 반환.
            1. _newByteLength_ &lt; _currentByteLength_ 또는 _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]] 이면 *RangeError* 예외.
            1. _byteLengthDelta_ = _newByteLength_ - _currentByteLength_.
            1. _byteLengthDelta_ 바이트로 구성된 새 Shared Data Block 값을 생성할 수 없으면 *RangeError* 예외.
            1. NOTE: 새 Shared Data Block 은 여기서 구성/사용되지 않는다. 증가 가능한 SharedArrayBuffer 의 관측 가능 동작은 생성 시 최대 크기 Shared Data Block 할당으로 지정되며, 구현이 메모리를 소진하면 *RangeError* 를 던져야 함을 이 단계가 반영.
            1. _readByteLengthRawBytes_ = AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_).
            1. ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) = *true* 이면 *undefined* 반환.
            1. _currentByteLengthRawBytes_ = _readByteLengthRawBytes_.
        </emu-alg>
        <emu-note>
          <p>길이 갱신 compare-exchange 의 허위 실패는 금지된다. 새 길이에 대한 경계 검사 통과 및 메모리 부족이 아니면 항상 ReadModifyWriteSharedMemory 이벤트(성공한 compare-exchange)가 후보 실행에 추가된다.</p>
          <p>SharedArrayBuffer.prototype.grow 에 대한 병렬 호출은 완전 순서화된다. 예를 들어 `sab.grow(10)` 과 `sab.grow(20)` 이 경합할 때 둘 중 하나가 승리하며, `sab.grow(20)` 이 먼저 일어났다면 `sab.grow(10)` 호출은 버퍼를 축소하지 않고 대신 RangeError 를 던진다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
        <h1>get SharedArrayBuffer.prototype.growable</h1>
        <p>`SharedArrayBuffer.prototype.growable` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *false* 이면 *TypeError* 예외.
          1. IsFixedLengthArrayBuffer(_O_) = *false* 이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
        <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
        <p>`SharedArrayBuffer.prototype.maxByteLength` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음을 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *false* 이면 *TypeError* 예외.
          1. IsFixedLengthArrayBuffer(_O_) = *true* 이면
            1. _length_ = _O_.[[ArrayBufferByteLength]].
          1. Else
            1. _length_ = _O_.[[ArrayBufferMaxByteLength]].
          1. 𝔽(_length_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_O_) = *false* 이면 *TypeError* 예외.
          1. _len_ = ArrayBufferByteLength(_O_, ~seq-cst~).
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_).
          1. _relativeStart_ = -∞ 이면 _first_ = 0.
          1. Else if _relativeStart_ &lt; 0 이면 _first_ = max(_len_ + _relativeStart_, 0).
          1. Else _first_ = min(_relativeStart_, _len_).
          1. _end_ = *undefined* 이면 _relativeEnd_ = _len_; 아니면 _relativeEnd_ = ? ToIntegerOrInfinity(_end_).
          1. _relativeEnd_ = -∞ 이면 _final_ = 0.
          1. Else if _relativeEnd_ &lt; 0 이면 _final_ = max(_len_ + _relativeEnd_, 0).
          1. Else _final_ = min(_relativeEnd_, _len_).
          1. _newLen_ = max(_final_ - _first_, 0).
          1. _ctor_ = ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. _new_ = ? Construct(_ctor_, « 𝔽(_newLen_) »).
          1. ? RequireInternalSlot(_new_, [[ArrayBufferData]]) 수행.
          1. IsSharedArrayBuffer(_new_) = *false* 이면 *TypeError* 예외.
          1. _new_.[[ArrayBufferData]] 가 _O_.[[ArrayBufferData]] 와 같으면 *TypeError* 예외.
          1. ArrayBufferByteLength(_new_, ~seq-cst~) &lt; _newLen_ 이면 *TypeError* 예외.
          1. _fromBuf_ = _O_.[[ArrayBufferData]].
          1. _toBuf_ = _new_.[[ArrayBufferData]].
          1. CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_) 수행.
          1. _new_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer.prototype.toString,sec-sharedarraybuffer.prototype-@@tostringtag" id="sec-sharedarraybuffer.prototype-%symbol.tostringtag%">
        <h1>SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"SharedArrayBuffer"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-instances">
      <h1>SharedArrayBuffer 인스턴스의 프로퍼티</h1>
      <p>SharedArrayBuffer 인스턴스는 SharedArrayBuffer 프로토타입 객체로부터 프로퍼티를 상속한다. 각 SharedArrayBuffer 인스턴스는 [[ArrayBufferData]] 내부 슬롯을 가진다. 증가 불가능 인스턴스는 [[ArrayBufferByteLength]] 내부 슬롯을 가진다. 증가 가능 인스턴스는 [[ArrayBufferByteLengthData]] 및 [[ArrayBufferMaxByteLength]] 내부 슬롯을 가진다.</p>

      <emu-note>
        <p>SharedArrayBuffer 인스턴스는 ArrayBuffer 인스턴스와 달리 분리(detach)되지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-growable-sharedarraybuffer-guidelines">
      <h1>증가 가능 SharedArrayBuffer 가이드라인</h1>
      <emu-note>
        <p>다음은 증가 가능 SharedArrayBuffer 를 사용하는 ECMAScript 프로그래머를 위한 지침이다.</p>
        <p>가능하다면 배포 환경에서 프로그램을 테스트할 것을 권장한다. 사용 가능한 물리 메모리 양은 하드웨어 장치마다 크게 다르다. 가상 메모리 서브시스템 또한 하드웨어와 운영체제에 따라 매우 다르다. 64비트 데스크톱 웹 브라우저에서 메모리 부족 없이 실행되는 애플리케이션이 32비트 모바일 웹 브라우저에서는 메모리를 소진할 수 있다.</p>
        <p>증가 가능 SharedArrayBuffer 의 *"maxByteLength"* 옵션 값은 애플리케이션에 필요한 최소 크기를 선택할 것을 권장한다. *"maxByteLength"* 가 1073741824 (1GiB) 를 넘지 않도록 권장한다.</p>
        <p>특정 최대 크기로 증가 가능 SharedArrayBuffer 를 성공적으로 생성했더라도 향후 grow 가 항상 성공함을 보장하지 않는다.</p>
        <p>증가 가능 SharedArrayBuffer 의 길이(load) 중 모두가 동기화 ~seq-cst~ load 는 아니다. 예를 들어 정수 인덱스 프로퍼티 접근의 경계 검사 목적(`u8[idx]`)으로 수행되는 길이 load 는 동기화되지 않는다. 일반적으로 명시적 동기화가 없으면 한 프로퍼티 접근이 경계 내라는 사실이 같은 에이전트의 이후 접근도 경계 내임을 의미하지 않는다. 반면 SharedArrayBuffer 의 `length`, `byteLength` 게터, %TypedArray%.prototype, DataView.prototype 을 통한 명시적 길이 load 는 동기화된다. TypedArray 가 완전히 out-of-bounds 인지 검사하기 위해 내장 메서드가 수행하는 길이 load 역시 동기화된다.</p>
      </emu-note>

      <emu-note>
        <p>다음은 증가 가능 SharedArrayBuffer 를 구현하는 ECMAScript 구현자를 위한 지침이다.</p>
        <p>증가 가능 SharedArrayBuffer 는 가상 메모리를 미리 예약한 제자리 증가 방식으로 구현할 것을 권장한다.</p>
        <p>grow 연산은 증가 가능 SharedArrayBuffer 에 대한 메모리 접근과 병렬로 일어날 수 있으므로, 메모리 모델 제약은 unordered 접근조차 ‘찢어짐(tearing)’이 없어야 함을 요구한다. 실제로 이는 기반 데이터 블록을 ‘세계 정지’ 없이 복사로 증가시킬 수 없음을 의미한다. 직렬화 지점을 만들고 느리기 때문에 ‘세계 정지’ 전략은 권장되지 않는다.</p>
        <p>증가된 메모리는 생성 순간부터(경합 접근 포함) 0 으로 보이는 형태여야 한다. 이는 온디맨드 zero-filled 가상 메모리 페이지나 수동 초기화 시 주의 깊은 동기화로 달성할 수 있다.</p>
        <p>증가 가능 SharedArrayBuffer 의 TypedArray 뷰에 대한 정수 인덱스 프로퍼티 접근은 (위 프로그래머 지침에서 언급했듯) 기반 버퍼 길이에 대한 동기화 load 가 아니므로 비증가 SharedArrayBuffer 의 TypedArray 접근과 유사하게 최적화될 수 있도록 의도되었다. 예: 경계 검사를 루프 밖으로 끌어올릴 수 있다.</p>
        <p>가상 메모리가 없는(예: MMU 없는 임베디드 장치) 호스트에서는 복사 방식으로 증가 가능 SharedArrayBuffer 를 구현하기 어렵다. 이런 호스트에서 메모리 사용 행태는 가상 메모리가 있는 호스트와 크게 다를 수 있으므로 사용자에게 명확히 알릴 필요가 있다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView 객체</h1>

    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>DataView 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-dataview-with-buffer-witness-records">
        <h1>버퍼 증명(버퍼 위트니스) Record 를 가진 DataView</h1>
        <p><dfn variants="DataView With Buffer Witness Records">DataView With Buffer Witness Record</dfn> 는 DataView 와, 뷰 대상 버퍼의 캐시된 바이트 길이를 함께 캡슐화하기 위해 사용되는 Record 값이다. 이는 뷰 대상 버퍼가 증가 가능 SharedArrayBuffer 인 경우 바이트 길이 데이터 블록에 대해 단일 공유 메모리 읽기 이벤트가 되도록 돕는 용도로 사용된다.</p>
        <p>DataView With Buffer Witness Record 는 <emu-xref href="#table-dataview-with-buffer-witness-record-fields"></emu-xref> 에 나열된 필드를 갖는다.</p>
        <emu-table id="table-dataview-with-buffer-witness-record-fields" caption="DataView With Buffer Witness Record 필드">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a DataView
              </td>
              <td>
                버퍼의 바이트 길이를 로드한 해당 DataView 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                Record 생성 시점의 객체 [[ViewedArrayBuffer]] 바이트 길이.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-makedataviewwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeDataViewWithBufferWitnessRecord (
            _obj_: a DataView,
            _order_: ~seq-cst~ or ~unordered~,
          ): DataView With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _buffer_ = _obj_.[[ViewedArrayBuffer]].
          1. IsDetachedBuffer(_buffer_) = *true* 이면
            1. _byteLength_ = ~detached~.
          1. Else
            1. _byteLength_ = ArrayBufferByteLength(_buffer_, _order_).
          1. DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ } 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewbytelength" type="abstract operation">
        <h1>
          GetViewByteLength (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): 음이 아닌 정수
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsViewOutOfBounds(_viewRecord_) = *false*.
          1. _view_ = _viewRecord_.[[Object]].
          1. _view_.[[ByteLength]] ≠ ~auto~ 이면 _view_.[[ByteLength]] 반환.
          1. Assert: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) = *false*.
          1. _byteOffset_ = _view_.[[ByteOffset]].
          1. _byteLength_ = _viewRecord_.[[CachedBufferByteLength]].
          1. Assert: _byteLength_ ≠ ~detached~.
          1. _byteLength_ - _byteOffset_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isviewoutofbounds" type="abstract operation">
        <h1>
          IsViewOutOfBounds (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _view_ = _viewRecord_.[[Object]].
          1. _bufferByteLength_ = _viewRecord_.[[CachedBufferByteLength]].
          1. Assert: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) = *true* ⇔ _bufferByteLength_ = ~detached~.
          1. _bufferByteLength_ = ~detached~ 이면 *true* 반환.
          1. _byteOffsetStart_ = _view_.[[ByteOffset]].
          1. _view_.[[ByteLength]] = ~auto~ 이면
            1. _byteOffsetEnd_ = _bufferByteLength_.
          1. Else
            1. _byteOffsetEnd_ = _byteOffsetStart_ + _view_.[[ByteLength]].
          1. _byteOffsetStart_ > _bufferByteLength_ 또는 _byteOffsetEnd_ > _bufferByteLength_ 이면 *true* 반환.
          1. NOTE: 길이 0 DataView 는 out-of-bounds 로 간주되지 않는다.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewvalue" type="abstract operation">
        <h1>
          GetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
          ): Number 또는 BigInt 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>DataView 인스턴스 함수들이 뷰의 버퍼에서 값을 읽어올 때 사용된다.</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_view_, [[DataView]]) 수행.
          1. Assert: _view_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _getIndex_ = ? ToIndex(_requestIndex_).
          1. _isLittleEndian_ = ToBoolean(_isLittleEndian_).
          1. _viewOffset_ = _view_.[[ByteOffset]].
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).
          1. NOTE: 뷰의 백업 버퍼가 증가 가능 SharedArrayBuffer 인 경우 경계 검사는 동기화 연산이 아니다.
          1. IsViewOutOfBounds(_viewRecord_) = *true* 이면 *TypeError* 예외.
          1. _viewSize_ = GetViewByteLength(_viewRecord_).
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _type_ 의 Element Size.
          1. _getIndex_ + _elementSize_ > _viewSize_ 이면 *RangeError* 예외.
          1. _bufferIndex_ = _getIndex_ + _viewOffset_.
          1. Return GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setviewvalue" type="abstract operation">
        <h1>
          SetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
            _value_: an ECMAScript language value,
          ): *undefined* 를 포함하는 정상 완료 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>DataView 인스턴스 함수들이 뷰의 버퍼에 값을 저장할 때 사용된다.</dd>
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_view_, [[DataView]]) 수행.
          1. Assert: _view_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _getIndex_ = ? ToIndex(_requestIndex_).
          1. IsBigIntElementType(_type_) = *true* 이면 _numberValue_ = ? ToBigInt(_value_); 아니면 _numberValue_ = ? ToNumber(_value_).
          1. _isLittleEndian_ = ToBoolean(_isLittleEndian_).
          1. _viewOffset_ = _view_.[[ByteOffset]].
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).
          1. NOTE: 뷰의 백업 버퍼가 증가 가능 SharedArrayBuffer 인 경우 경계 검사는 동기화 연산이 아니다.
          1. IsViewOutOfBounds(_viewRecord_) = *true* 이면 *TypeError* 예외.
          1. _viewSize_ = GetViewByteLength(_viewRecord_).
          1. _elementSize_ = <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 에서 _type_ 의 Element Size.
          1. _getIndex_ + _elementSize_ > _viewSize_ 이면 *RangeError* 예외.
          1. _bufferIndex_ = _getIndex_ + _viewOffset_.
          1. SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_) 수행.
          1. *undefined* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-dataview-constructor">
      <h1>DataView 생성자</h1>
      <p>DataView 생성자:</p>
      <ul>
        <li><dfn>%DataView%</dfn> 이다.</li>
        <li>전역 객체 *"DataView"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새 DataView 를 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의 `extends` 절 값으로 사용할 수 있다. 지정된 DataView 동작을 상속하려는 서브클래스 생성자는 `DataView.prototype` 내장 메서드 지원에 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 DataView 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
        <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외.
          1. ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]) 수행.
          1. _offset_ = ? ToIndex(_byteOffset_).
          1. IsDetachedBuffer(_buffer_) = *true* 이면 *TypeError* 예외.
          1. _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~).
          1. _offset_ > _bufferByteLength_ 이면 *RangeError* 예외.
          1. _bufferIsFixedLength_ = IsFixedLengthArrayBuffer(_buffer_).
          1. _byteLength_ = *undefined* 이면
            1. _bufferIsFixedLength_ = *true* 이면
              1. _viewByteLength_ = _bufferByteLength_ - _offset_.
            1. Else
              1. _viewByteLength_ = ~auto~.
          1. Else
            1. _viewByteLength_ = ? ToIndex(_byteLength_).
            1. _offset_ + _viewByteLength_ > _bufferByteLength_ 이면 *RangeError* 예외.
          1. _O_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).
          1. IsDetachedBuffer(_buffer_) = *true* 이면 *TypeError* 예외.
          1. _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~).
          1. _offset_ > _bufferByteLength_ 이면 *RangeError* 예외.
          1. _byteLength_ ≠ *undefined* 이면
            1. _offset_ + _viewByteLength_ > _bufferByteLength_ 이면 *RangeError* 예외.
          1. _O_.[[ViewedArrayBuffer]] = _buffer_.
          1. _O_.[[ByteLength]] = _viewByteLength_.
          1. _O_.[[ByteOffset]] = _offset_.
          1. _O_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>DataView 생성자의 프로퍼티</h1>
      <p>DataView 생성자:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-dataview.prototype">
        <h1>DataView.prototype</h1>
        <p>`DataView.prototype` 의 초기 값은 DataView 프로토타입 객체이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-prototype-object">
      <h1>DataView 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>DataView 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%DataView.prototype%</dfn> 이다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>일반 객체이다.</li>
        <li>[[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-get-dataview.prototype.buffer">
        <h1>get DataView.prototype.buffer</h1>
        <p>`DataView.prototype.buffer` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[DataView]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _buffer_ = _O_.[[ViewedArrayBuffer]].
          1. _buffer_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.bytelength">
        <h1>get DataView.prototype.byteLength</h1>
        <p>`DataView.prototype.byteLength` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[DataView]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. IsViewOutOfBounds(_viewRecord_) = *true* 이면 *TypeError* 예외.
          1. _size_ = GetViewByteLength(_viewRecord_).
          1. 𝔽(_size_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.byteoffset">
        <h1>get DataView.prototype.byteOffset</h1>
        <p>`DataView.prototype.byteOffset` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ = *this* 값.
          1. ? RequireInternalSlot(_O_, [[DataView]]) 수행.
          1. Assert: _O_ 는 [[ViewedArrayBuffer]] 내부 슬롯을 가진다.
          1. _viewRecord_ = MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. IsViewOutOfBounds(_viewRecord_) = *true* 이면 *TypeError* 예외.
          1. _offset_ = _O_.[[ByteOffset]].
          1. 𝔽(_offset_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.constructor">
        <h1>DataView.prototype.constructor</h1>
        <p>`DataView.prototype.constructor` 의 초기 값은 %DataView% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbigint64">
        <h1>DataView.prototype.getBigInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbiguint64">
        <h1>DataView.prototype.getBigUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat16">
        <h1>DataView.prototype.getFloat16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat32">
        <h1>DataView.prototype.getFloat32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat64">
        <h1>DataView.prototype.getFloat64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint8">
        <h1>DataView.prototype.getInt8 ( _byteOffset_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? GetViewValue(_view_, _byteOffset_, *true*, ~int8~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint16">
        <h1>DataView.prototype.getInt16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint32">
        <h1>DataView.prototype.getInt32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint8">
        <h1>DataView.prototype.getUint8 ( _byteOffset_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? GetViewValue(_view_, _byteOffset_, *true*, ~uint8~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint16">
        <h1>DataView.prototype.getUint16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint32">
        <h1>DataView.prototype.getUint32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbigint64">
        <h1>DataView.prototype.setBigInt64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbiguint64">
        <h1>DataView.prototype.setBigUint64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat16">
        <h1>DataView.prototype.setFloat16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat32">
        <h1>DataView.prototype.setFloat32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat64">
        <h1>DataView.prototype.setFloat64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint8">
        <h1>DataView.prototype.setInt8 ( _byteOffset_, _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? SetViewValue(_view_, _byteOffset_, *true*, ~int8~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint16">
        <h1>DataView.prototype.setInt16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint32">
        <h1>DataView.prototype.setInt32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint8">
        <h1>DataView.prototype.setUint8 ( _byteOffset_, _value_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. Return ? SetViewValue(_view_, _byteOffset_, *true*, ~uint8~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint16">
        <h1>DataView.prototype.setUint16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint32">
        <h1>DataView.prototype.setUint32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _view_ = *this* 값.
          1. _littleEndian_ 미지정이면 _littleEndian_ = *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-dataview.prototype-@@tostringtag" id="sec-dataview.prototype-%symbol.tostringtag%">
        <h1>DataView.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"DataView"* 이다.</p>
        <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-dataview-instances">
      <h1>DataView 인스턴스의 프로퍼티</h1>
      <p>DataView 인스턴스는 DataView 프로토타입 객체로부터 프로퍼티를 상속한다. 각 DataView 인스턴스는 [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] 내부 슬롯을 가진다.</p>
      <emu-note>
        <p>[[DataView]] 내부 슬롯의 값 자체는 명세 내에서 사용되지 않는다. 이 내부 슬롯의 존재 여부가 해당 객체가 DataView 생성자를 사용해 생성되었음을 식별하는 데 사용된다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics-object">
    <h1>Atomics 객체</h1>
    <p>Atomics 객체:</p>
    <ul>
      <li><dfn>%Atomics%</dfn> 이다.</li>
      <li>전역 객체 *"Atomics"* 프로퍼티의 초기 값이다.</li>
      <li>일반 객체이다.</li>
      <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      <li>[[Construct]] 내부 메서드가 없다; `new` 연산자로 생성자로 사용할 수 없다.</li>
      <li>[[Call]] 내부 메서드가 없다; 함수로 호출될 수 없다.</li>
    </ul>
    <p>Atomics 객체는 공유 메모리 배열 셀에 대해 분리 불가능(원자적)하게 동작하는 함수들과 에이전트가 원시적 이벤트를 대기/디스패치할 수 있게 하는 함수들을 제공한다. 규범적으로 사용하면 Atomics 함수는 공유 메모리를 통해 통신하는 다중 에이전트 프로그램이 병렬 CPU 상에서도 잘 이해된 순서로 실행되도록 한다. 공유 메모리 통신을 지배하는 규칙은 아래에 정의된 메모리 모델이 제공한다.</p>
    <emu-note>
      <p>ECMAScript 에서 공유 메모리를 프로그래밍/구현하기 위한 비규범적 가이드라인은 메모리 모델 절 끝부분의 주석을 참고하라.</p>
    </emu-note>

    <emu-clause id="sec-waiter-record">
      <h1>Waiter Record</h1>
      <p><dfn variants="Waiter Records">Waiter Record</dfn> 는 특정 `Atomics.wait` 또는 `Atomics.waitAsync` 호출을 나타내기 위해 사용되는 Record 값이다.</p>
      <p>Waiter Record 는 <emu-xref href="#table-waiterrecord"></emu-xref> 에 나열된 필드를 가진다.</p>
      <emu-table id="table-waiterrecord" caption="Waiter Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[AgentSignifier]]
            </td>
            <td>
              agent signifier
            </td>
            <td>
              `Atomics.wait` 또는 `Atomics.waitAsync` 를 호출한 에이전트.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            </td>
            <td>
              PromiseCapability Record 또는 ~blocking~
            </td>
            <td>
              `Atomics.waitAsync` 호출을 나타내면 결과 promise, 아니면 ~blocking~.
            </td>
          </tr>
          <tr>
            <td>
              [[TimeoutTime]]
            </td>
            <td>
              음이 아닌 확장 수학적 값
            </td>
            <td>
              타임아웃이 트리거될 수 있는 가장 이른 시각; 시간 값으로 계산.
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            </td>
            <td>
              *"ok"* 또는 *"timed-out"*
            </td>
            <td>
              호출의 반환 값.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-waiterlist-records" oldids="sec-waiterlist-objects">
      <h1>WaiterList Records</h1>
      <p><dfn variants="WaiterList Records">WaiterList Record</dfn> 는 `Atomics.wait`, `Atomics.waitAsync`, `Atomics.notify` 를 통한 에이전트 대기 및 알림을 설명하는 데 사용된다.</p>
      <p>WaiterList Record 는 <emu-xref href="#table-waiterlistrecord"></emu-xref> 에 나열된 필드를 가진다.</p>
      <emu-table id="table-waiterlistrecord" caption="WaiterList Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Waiters]]
            </td>
            <td>
              Waiter Record 들의 List
            </td>
            <td>
              이 WaiterList 가 연관된 위치에서 대기 중인 `Atomics.wait` / `Atomics.waitAsync` 호출들.
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            </td>
            <td>
              Synchronize 이벤트 또는 ~empty~
            </td>
            <td>
              가장 최근 임계 구역 이탈 이벤트, 또는 한번도 진입한 적 없으면 ~empty~.
            </td>
          </tr>
        </table>
      </emu-table>
      <p>같은 agent signifier 를 가진 여러 Waiter Record 가 하나의 WaiterList 에 있을 수 있다.</p>
      <p>에이전트 클러스터는 WaiterList Record 의 저장소를 가진다; 저장소는 (_block_, _i_) 로 인덱싱되고 _block_ 은 Shared Data Block, _i_ 는 _block_ 메모리의 바이트 오프셋이다. WaiterList Record 는 에이전트 독립적이다: (_block_, _i_) 로 조회하면 클러스터 내 어떤 에이전트에서도 동일한 WaiterList Record 가 결과로 나온다.</p>
      <p>각 WaiterList Record 는 평가 중 그 WaiterList Record 에 대한 배타적 접근을 제어하는 <dfn variants="critical sections">critical section</dfn> 을 가진다. 한 번에 하나의 에이전트만 critical section 에 진입할 수 있다. 진입/이탈은 추상 연산 EnterCriticalSection 과 LeaveCriticalSection 이 제어한다. WaiterList Record 에 대한 연산—대기 에이전트 추가/제거, 목록 순회, 목록의 에이전트 일시중단/알림, Synchronize 이벤트 설정/조회—는 critical section 에 진입한 에이전트만 수행할 수 있다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-atomics">
      <h1>Atomics 를 위한 추상 연산</h1>

      <emu-clause id="sec-validateintegertypedarray" type="abstract operation" oldids="sec-validatesharedintegertypedarray">
        <h1>
          ValidateIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _waitable_: a Boolean,
          ): 정상 완료(TypedArray With Buffer Witness Record 포함) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _taRecord_ = ? ValidateTypedArray(_typedArray_, ~unordered~).
          1. NOTE: _typedArray_ 의 백업 버퍼가 증가 가능 SharedArrayBuffer 인 경우 경계 검사는 동기화 연산이 아니다.
          1. _waitable_ = *true* 이면
            1. _typedArray_.[[TypedArrayName]] 가 *"Int32Array"*, *"BigInt64Array"* 둘 다 아니면 *TypeError* 예외.
          1. Else
            1. _type_ = TypedArrayElementType(_typedArray_).
            1. IsUnclampedIntegerElementType(_type_) = *false* 그리고 IsBigIntElementType(_type_) = *false* 이면 *TypeError* 예외.
          1. Return _taRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccess" type="abstract operation">
        <h1>
          ValidateAtomicAccess (
            _taRecord_: a TypedArray With Buffer Witness Record,
            _requestIndex_: an ECMAScript language value,
          ): 정상 완료(정수) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _length_ = TypedArrayLength(_taRecord_).
          1. _accessIndex_ = ? ToIndex(_requestIndex_).
          1. Assert: _accessIndex_ ≥ 0.
          1. _accessIndex_ ≥ _length_ 이면 *RangeError* 예외.
          1. _typedArray_ = _taRecord_.[[Object]].
          1. _elementSize_ = TypedArrayElementSize(_typedArray_).
          1. _offset_ = _typedArray_.[[ByteOffset]].
          1. Return (_accessIndex_ × _elementSize_) + _offset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccessonintegertypedarray" type="abstract operation">
        <h1>
          ValidateAtomicAccessOnIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
          ): 정상 완료(정수) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _taRecord_ = ? ValidateIntegerTypedArray(_typedArray_, *false*).
          1. Return ? ValidateAtomicAccess(_taRecord_, _requestIndex_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-revalidateatomicaccess" type="abstract operation">
        <h1>
          RevalidateAtomicAccess (
            _typedArray_: a TypedArray,
            _byteIndexInBuffer_: an integer,
          ): 정상 완료(~unused~) 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>이 연산은 Atomics 메서드에서 모든 인수 강제가 수행된 후 버퍼가 경계 밖이 되었을 수 있으므로 원자 연산용 인덱스를 다시 검증한다. _typedArray_ 의 백업 버퍼가 SharedArrayBuffer 인 경우 이 연산은 throw 하지 않는다.</dd>
        </dl>
        <emu-alg>
          1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~).
          1. NOTE: _typedArray_ 의 백업 버퍼가 증가 가능 SharedArrayBuffer 인 경우 경계 검사는 동기화되지 않는다.
          1. IsTypedArrayOutOfBounds(_taRecord_) = *true* 이면 *TypeError* 예외.
          1. Assert: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].
          1. _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]] 이면 *RangeError* 예외.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getwaiterlist" type="abstract operation">
        <h1>
          GetWaiterList (
            _block_: a Shared Data Block,
            _i_: a non-negative integer that is evenly divisible by 4,
          ): WaiterList Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _i_ 및 _i_ + 3 은 _block_ 메모리의 유효 바이트 오프셋.
          1. Return (_block_, _i_) 쌍이 참조하는 WaiterList Record.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-entercriticalsection" type="abstract operation">
        <h1>
          EnterCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 어떤 WaiterList Record 의 critical section 안에 있지 않다.
          1. 어떤 에이전트도 _WL_ 의 critical section 에 없을 때까지 대기한 후 다른 에이전트가 진입하지 못하게 한 상태로 진입.
          1. _WL_.[[MostRecentLeaveEvent]] ≠ ~empty~ 이면
            1. NOTE: 최소 1번 진입된 _WL_ 은 LeaveCriticalSection 에 의해 Synchronize 이벤트가 설정된다.
            1. _execution_ = 주변 에이전트의 Agent Record.[[CandidateExecution]].
            1. _eventsRecord_ = _execution_.[[EventsRecords]] 중 [[AgentSignifier]] = AgentSignifier() 인 Agent Events Record.
            1. _enterEvent_ = 새로운 Synchronize 이벤트.
            1. _eventsRecord_.[[EventList]] 에 _enterEvent_ 추가.
            1. _eventsRecord_.[[AgentSynchronizesWith]] 에 (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) 추가.
          1. Return ~unused~.
        </emu-alg>
        <p>EnterCriticalSection 은 에이전트가 다른 에이전트가 떠나기를 기다려야 할 때 <dfn>경합(contention)</dfn> 이 있다. 경합이 없을 때 EnterCriticalSection 호출의 FIFO 순서가 관측 가능하다. 경합이 있을 때 구현은 임의 순서를 선택할 수 있으나 무기한 대기는 유발할 수 없다.</p>
      </emu-clause>

      <emu-clause id="sec-leavecriticalsection" type="abstract operation">
        <h1>
          LeaveCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 _WL_ 의 critical section 안에 있다.
          1. _execution_ = 주변 에이전트 Agent Record.[[CandidateExecution]].
          1. _eventsRecord_ = _execution_.[[EventsRecords]] 중 [[AgentSignifier]] = AgentSignifier() 인 것.
          1. _leaveEvent_ = 새로운 Synchronize 이벤트.
          1. _eventsRecord_.[[EventList]] 에 _leaveEvent_ 추가.
          1. _WL_.[[MostRecentLeaveEvent]] = _leaveEvent_ 로 설정.
          1. _WL_ 의 critical section 떠남.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-addwaiter" type="abstract operation">
        <h1>
          AddWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 _WL_ critical section 안에 있다.
          1. Assert: _WL_.[[Waiters]] 에 [[PromiseCapability]] 와 [[AgentSignifier]] 가 각각 _waiterRecord_ 와 동일한 Waiter Record 가 없다.
          1. _WL_.[[Waiters]] 에 _waiterRecord_ 추가.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiter" type="abstract operation">
        <h1>
          RemoveWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 _WL_ critical section 안에 있다.
          1. Assert: _WL_.[[Waiters]] 는 _waiterRecord_ 를 포함한다.
          1. _WL_.[[Waiters]] 에서 _waiterRecord_ 제거.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiters" type="abstract operation">
        <h1>
          RemoveWaiters (
            _WL_: a WaiterList Record,
            _c_: a non-negative integer or +&infin;,
          ): Waiter Record 들의 List
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 _WL_ critical section 안에 있다.
          1. _len_ = _WL_.[[Waiters]] 요소 수.
          1. _n_ = min(_c_, _len_).
          1. _L_ = _WL_.[[Waiters]] 의 처음 _n_ 요소로 이루어진 List.
          1. _WL_.[[Waiters]] 의 처음 _n_ 요소 제거.
          1. Return _L_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-suspendthisagent" type="abstract operation" oldids="sec-suspend,sec-suspendagent">
        <h1>
          SuspendThisAgent (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 _WL_ critical section 안에 있다.
          1. Assert: _WL_.[[Waiters]] 는 _waiterRecord_ 포함.
          1. _thisAgent_ = AgentSignifier().
          1. Assert: _waiterRecord_.[[AgentSignifier]] 는 _thisAgent_.
          1. Assert: _waiterRecord_.[[PromiseCapability]] 는 ~blocking~.
          1. Assert: AgentCanSuspend() = *true*.
          1. LeaveCriticalSection(_WL_) 수행 후 주변 에이전트를 _waiterRecord_.[[TimeoutTime]] 시각까지 일시중단하되, critical section 을 벗어난 직후부터 suspend 적용 전 사이 도착한 알림이 손실되지 않도록 결합된 연산으로 수행. 주변 에이전트는 타임아웃 또는 다른 에이전트가 NotifyWaiter(_WL_, _thisAgent_) (즉 `Atomics.notify`) 를 호출하여 깨어날 수 있다.
          1. EnterCriticalSection(_WL_) 수행.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-notifywaiter" type="abstract operation">
        <h1>
          NotifyWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: 주변 에이전트는 _WL_ critical section 안에 있다.
          1. _waiterRecord_.[[PromiseCapability]] 가 ~blocking~ 이면
            1. signifier 가 _waiterRecord_.[[AgentSignifier]] 인 에이전트를 suspend 에서 깨움.
            1. NOTE: 이는 SuspendThisAgent 내 실행 재개를 유발.
          1. Else if AgentSignifier() 가 _waiterRecord_.[[AgentSignifier]] 이면
            1. _promiseCapability_ = _waiterRecord_.[[PromiseCapability]].
            1. ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] ») 수행.
          1. Else
            1. EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]) 수행.
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>에이전트는 호스트에 전달하는 것 외에 다른 에이전트의 promise capability 에 접근해서는 안 된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueresolveinagentjob" type="abstract operation">
        <h1>
          EnqueueResolveInAgentJob (
            _agentSignifier_: an agent signifier,
            _promiseCapability_: a PromiseCapability Record,
            _resolution_: *"ok"* or *"timed-out"*,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _resolveJob_ = 매개변수 없고 _agentSignifier_, _promiseCapability_, _resolution_ 을 캡처하며 호출 시:
            1. Assert: AgentSignifier() = _agentSignifier_.
            1. ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ ») 수행.
            1. Return ~unused~.
          1. _realmInTargetAgent_ = ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).
          1. Assert: _agentSignifier_ = _realmInTargetAgent_.[[AgentSignifier]].
          1. HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_) 수행.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dowait" type="abstract operation">
        <h1>
          DoWait (
            _mode_: ~sync~ or ~async~,
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _timeout_: an ECMAScript language value,
          ): 정상 완료(Object, *"not-equal"*, *"timed-out"*, *"ok"* 중 하나) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _taRecord_ = ? ValidateIntegerTypedArray(_typedArray_, *true*).
          1. _buffer_ = _taRecord_.[[Object]].[[ViewedArrayBuffer]].
          1. IsSharedArrayBuffer(_buffer_) = *false* 이면 *TypeError* 예외.
          1. _i_ = ? ValidateAtomicAccess(_taRecord_, _index_).
          1. _arrayTypeName_ = _typedArray_.[[TypedArrayName]].
          1. _arrayTypeName_ = *"BigInt64Array"* 이면 _v_ = ? ToBigInt64(_value_); Else _v_ = ? ToInt32(_value_).
          1. _q_ = ? ToNumber(_timeout_).
          1. _q_ 가 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _t_ = +∞; else if _q_ = *-∞*<sub>𝔽</sub> 이면 _t_ = 0; else _t_ = max(ℝ(_q_), 0).
          1. _mode_ = ~sync~ 그리고 AgentCanSuspend() = *false* 이면 *TypeError* 예외.
          1. _block_ = _buffer_.[[ArrayBufferData]].
          1. _offset_ = _typedArray_.[[ByteOffset]].
          1. _byteIndexInBuffer_ = (_i_ × 4) + _offset_.
          1. _WL_ = GetWaiterList(_block_, _byteIndexInBuffer_).
          1. _mode_ = ~sync~ 이면
            1. _promiseCapability_ = ~blocking~.
            1. _resultObject_ = *undefined*.
          1. Else
            1. _promiseCapability_ = ! NewPromiseCapability(%Promise%).
            1. _resultObject_ = OrdinaryObjectCreate(%Object.prototype%).
          1. EnterCriticalSection(_WL_) 수행.
          1. _elementType_ = TypedArrayElementType(_typedArray_).
          1. _w_ = GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
          1. _v_ ≠ _w_ 이면
            1. LeaveCriticalSection(_WL_) 수행.
            1. _mode_ = ~sync~ 이면 *"not-equal"* 반환.
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*) 수행.
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"not-equal"*) 수행.
            1. Return _resultObject_.
          1. _t_ = 0 그리고 _mode_ = ~async~ 이면
            1. NOTE: 동기 즉시 타임아웃은 특별 처리 없음. 비동기 즉시 타임아웃은 빠른 실패를 위해 특별 처리.
            1. LeaveCriticalSection(_WL_) 수행.
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*) 수행.
            1. ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"timed-out"*) 수행.
            1. Return _resultObject_.
          1. _thisAgent_ = AgentSignifier().
          1. _now_ = 현재 시간(UTC) time value.
          1. _additionalTimeout_ = 구현 정의 음이 아닌 수학적 값.
          1. _timeoutTime_ = ℝ(_now_) + _t_ + _additionalTimeout_.
          1. NOTE: _t_ = +∞ 이면 _timeoutTime_ 도 +∞.
          1. _waiterRecord_ = 새 Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* }.
          1. AddWaiter(_WL_, _waiterRecord_) 수행.
          1. _mode_ = ~sync~ 이면
            1. SuspendThisAgent(_WL_, _waiterRecord_) 수행.
          1. Else if _timeoutTime_ 유한이면
            1. EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_) 수행.
          1. LeaveCriticalSection(_WL_) 수행.
          1. _mode_ = ~sync~ 이면 _waiterRecord_.[[Result]] 반환.
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *true*) 수행.
          1. ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, _promiseCapability_.[[Promise]]) 수행.
          1. Return _resultObject_.
        </emu-alg>
        <emu-note>
          <p>_additionalTimeout_ 은 전력 소비 감소나 타이밍 공격 완화를 위한 타이머 해상도 조정 등 필요 시 타임아웃에 패딩을 허용한다. 호출마다 값이 다를 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueatomicswaitasynctimeoutjob" type="abstract operation">
        <h1>
          EnqueueAtomicsWaitAsyncTimeoutJob (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _timeoutJob_ = 매개변수 없고 _WL_, _waiterRecord_ 캡처하며 호출 시:
            1. EnterCriticalSection(_WL_) 수행.
            1. _WL_.[[Waiters]] 가 _waiterRecord_ 포함하면
              1. _timeOfJobExecution_ = 현재 시간(UTC) time value.
              1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (시간 비단조 가능성 무시).
              1. _waiterRecord_.[[Result]] = *"timed-out"*.
              1. RemoveWaiter(_WL_, _waiterRecord_) 수행.
              1. NotifyWaiter(_WL_, _waiterRecord_) 수행.
            1. LeaveCriticalSection(_WL_) 수행.
            1. Return ~unused~.
          1. _now_ = 현재 시간(UTC) time value.
          1. _currentRealm_ = 현재 Realm Record.
          1. HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_) 수행.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomiccompareexchangeinsharedblock" type="abstract operation">
        <h1>
          AtomicCompareExchangeInSharedBlock (
            _block_: a Shared Data Block,
            _byteIndexInBuffer_: an integer,
            _elementSize_: a non-negative integer,
            _expectedBytes_: a List of byte values,
            _replacementBytes_: a List of byte values,
          ): 바이트 값 List
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _execution_ = 주변 에이전트 Agent Record.[[CandidateExecution]].
          1. _eventsRecord_ = _execution_.[[EventsRecords]] 중 [[AgentSignifier]] = AgentSignifier() 인 것.
          1. _rawBytesRead_ = 길이 _elementSize_ 이고 요소가 비결정적으로 선택된 바이트 값 List.
          1. NOTE: 구현에서 _rawBytesRead_ 는 load-link, load-exclusive, 또는 read-modify-write 명령의 피연산자 결과. 비결정성은 약한 일관성 하드웨어 관측 가능 동작을 기술.
          1. NOTE: 기대값과 읽은 값 비교는 기대값 불일치 시 불필요한 강한 동기화를 피하기 위해 read-modify-write 수정 함수 밖에서 수행.
          1. ByteListEqual(_rawBytesRead_, _expectedBytes_) = *true* 이면
            1. _second_ = 매개변수 (_oldBytes_, _newBytes_) 를 가지고 아무것도 캡처하지 않으며 호출 시 원자적으로 _newBytes_ 반환하는 새 read-modify-write 수정 함수.
            1. _event_ = ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.
          1. Else
            1. _event_ = ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }.
          1. _eventsRecord_.[[EventList]] 에 _event_ 추가.
          1. _execution_.[[ChosenValues]] 에 Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } 추가.
          1. Return _rawBytesRead_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation">
        <h1>
          AtomicReadModifyWrite (
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _op_: a read-modify-write modification function,
          ): 정상 완료(Number 또는 BigInt) 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_op_ 는 두 List (바이트 값) 인수를 받아 바이트 값 List 를 반환한다. 이 연산은 원자적으로 값을 로드하고 다른 값과 결합 후 저장하며 로드한 값을 반환한다.</dd>
        </dl>
        <emu-alg>
          1. _byteIndexInBuffer_ = ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
          1. _typedArray_.[[ContentType]] = ~bigint~ 이면 _v_ = ? ToBigInt(_value_); 아니면 _v_ = 𝔽(? ToIntegerOrInfinity(_value_)).
          1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) 수행.
          1. _buffer_ = _typedArray_.[[ViewedArrayBuffer]].
          1. _elementType_ = TypedArrayElementType(_typedArray_).
          1. Return GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistbitwiseop" type="abstract operation">
        <h1>
          ByteListBitwiseOp (
            _op_: `&amp;`, `^`, or `|`,
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): 바이트 값 List
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>모든 바이트에 대한 비트 연산을 수행하고 바이트 값 List 를 원자적으로 반환한다.</dd>
        </dl>
        <emu-alg>
          1. Assert: _xBytes_ 와 _yBytes_ 는 동일한 길이.
          1. _result_ = 새 빈 List.
          1. _i_ = 0.
          1. 각 _xBytes_ 요소 _xByte_ 에 대해
            1. _yByte_ = _yBytes_[_i_].
            1. _op_ = `&amp;` 이면
              1. _resultByte_ = _xByte_ AND _yByte_.
            1. Else if _op_ = `^` 이면
              1. _resultByte_ = _xByte_ XOR _yByte_.
            1. Else
              1. Assert: _op_ = `|`.
              1. _resultByte_ = _xByte_ OR _yByte_.
            1. _i_ = _i_ + 1.
            1. _result_ 에 _resultByte_ 추가.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistequal" type="abstract operation">
        <h1>
          ByteListEqual (
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _xBytes_, _yBytes_ 길이 다르면 *false* 반환.
          1. _i_ = 0.
          1. 각 _xBytes_ 요소 _xByte_ 에 대해
            1. _yByte_ = _yBytes_[_i_].
            1. _xByte_ ≠ _yByte_ 이면 *false* 반환.
            1. _i_ = _i_ + 1.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-atomics.add">
      <h1>Atomics.add ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _add_ = 매개변수 (_xBytes_, _yBytes_) 를 가지고 _typedArray_ 를 캡처하며 호출 시 원자적으로:
          1. _type_ = TypedArrayElementType(_typedArray_).
          1. _isLittleEndian_ = 주변 에이전트 Agent Record 의 [[LittleEndian]] 값.
          1. _x_ = RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).
          1. _y_ = RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).
          1. _x_ 가 Number 이면
            1. _sum_ = Number::add(_x_, _y_).
          1. Else
            1. Assert: _x_ 는 BigInt.
            1. _sum_ = BigInt::add(_x_, _y_).
          1. _sumBytes_ = NumericToRawBytes(_type_, _sum_, _isLittleEndian_).
          1. Assert: _sumBytes_, _xBytes_, _yBytes_ 길이 동일.
          1. Return _sumBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.and">
      <h1>Atomics.and ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _and_ = 매개변수 (_xBytes_, _yBytes_) 를 가지고 아무것도 캡처하지 않으며 호출 시 원자적으로:
          1. Return ByteListBitwiseOp(`&amp;`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _byteIndexInBuffer_ = ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. _buffer_ = _typedArray_.[[ViewedArrayBuffer]].
        1. _block_ = _buffer_.[[ArrayBufferData]].
        1. _typedArray_.[[ContentType]] = ~bigint~ 이면
          1. _expected_ = ? ToBigInt(_expectedValue_).
          1. _replacement_ = ? ToBigInt(_replacementValue_).
        1. Else
          1. _expected_ = 𝔽(? ToIntegerOrInfinity(_expectedValue_)).
          1. _replacement_ = 𝔽(? ToIntegerOrInfinity(_replacementValue_)).
        1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) 수행.
        1. _elementType_ = TypedArrayElementType(_typedArray_).
        1. _elementSize_ = TypedArrayElementSize(_typedArray_).
        1. _isLittleEndian_ = 주변 에이전트 Agent Record.[[LittleEndian]].
        1. _expectedBytes_ = NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).
        1. _replacementBytes_ = NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).
        1. IsSharedArrayBuffer(_buffer_) = *true* 이면
          1. _rawBytesRead_ = AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).
        1. Else
          1. _rawBytesRead_ = 길이 _elementSize_ 인 List ( _block_[_byteIndexInBuffer_] 로부터 _elementSize_ 바이트 ).
          1. ByteListEqual(_rawBytesRead_, _expectedBytes_) = *true* 이면
            1. _replacementBytes_ 바이트들을 _block_[_byteIndexInBuffer_] 부터 저장.
        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange">
      <h1>Atomics.exchange ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _second_ = 매개변수 (_oldBytes_, _newBytes_) 를 가지며 아무것도 캡처하지 않고 호출 시 원자적으로 _newBytes_ 반환하는 read-modify-write 수정 함수.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree ( _size_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _n_ = ? ToIntegerOrInfinity(_size_).
        1. _AR_ = 주변 에이전트의 Agent Record.
        1. _n_ = 1 이면 _AR_.[[IsLockFree1]] 반환.
        1. _n_ = 2 이면 _AR_.[[IsLockFree2]] 반환.
        1. _n_ = 4 이면 *true* 반환.
        1. _n_ = 8 이면 _AR_.[[IsLockFree8]] 반환.
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>이 함수는 최적화용 프리미티브이다. 크기 _n_ 바이트 데이터에 대한 atomic primitive (`compareExchange`, `load`, `store`, `add`, `sub`, `and`, `or`, `xor`, `exchange`) 의 원자 단계가 주변 에이전트가 데이터 범위를 넘어서는 lock 을 획득하지 않고 수행된다면 `Atomics.isLockFree`(_n_) 은 *true* 를 반환한다는 직관을 제공한다. 고성능 알고리즘은 이 함수를 사용해 임계 영역에서 락 vs 원자 연산 사용을 결정한다. 원자 프리미티브가 lock-free 가 아니면 자체 락을 제공하는 편이 종종 더 효율적이다.</p>
        <p>`Atomics.isLockFree`(4) 는 관련 하드웨어 모두에서 지원 가능하므로 항상 *true* 를 반환한다. 이는 프로그램 단순화에 도움된다.</p>
        <p>이 함수 반환값과 무관하게 모든 원자 연산은 원자성이 보장된다. 즉 중간 연산(예: “tearing”)이 관측되지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-atomics.load" oldids="sec-atomicload">
      <h1>Atomics.load ( _typedArray_, _index_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _byteIndexInBuffer_ = ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) 수행.
        1. _buffer_ = _typedArray_.[[ViewedArrayBuffer]].
        1. _elementType_ = TypedArrayElementType(_typedArray_).
        1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.or">
      <h1>Atomics.or ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _or_ = 매개변수 (_xBytes_, _yBytes_) 를 가지고 아무것도 캡처하지 않으며 호출 시 원자적으로:
          1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _byteIndexInBuffer_ = ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. _typedArray_.[[ContentType]] = ~bigint~ 이면 _v_ = ? ToBigInt(_value_); 아니면 _v_ = 𝔽(? ToIntegerOrInfinity(_value_)).
        1. ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_) 수행.
        1. _buffer_ = _typedArray_.[[ViewedArrayBuffer]].
        1. _elementType_ = TypedArrayElementType(_typedArray_).
        1. SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~) 수행.
        1. Return _v_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.sub">
      <h1>Atomics.sub ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _subtract_ = 매개변수 (_xBytes_, _yBytes_) 를 가지고 _typedArray_ 를 캡처하며 호출 시 원자적으로:
          1. _type_ = TypedArrayElementType(_typedArray_).
          1. _isLittleEndian_ = 주변 에이전트 Agent Record.[[LittleEndian]].
          1. _x_ = RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).
          1. _y_ = RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).
          1. _x_ 가 Number 이면
            1. _difference_ = Number::subtract(_x_, _y_).
          1. Else
            1. Assert: _x_ 는 BigInt.
            1. _difference_ = BigInt::subtract(_x_, _y_).
          1. _differenceBytes_ = NumericToRawBytes(_type_, _difference_, _isLittleEndian_).
          1. Assert: _differenceBytes_, _xBytes_, _yBytes_ 길이 동일.
          1. Return _differenceBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>이 함수는 주변 에이전트를 대기 큐에 두고 알림 또는 타임아웃까지 일시중단하며 결과 구분 문자열을 반환한다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. Return ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.waitasync">
      <h1>Atomics.waitAsync ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>이 함수는 호출 에이전트가 알림을 받거나 타임아웃에 도달했을 때 resolve 되는 Promise 를 반환한다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. Return ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.notify">
      <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
      <p>이 함수는 대기 큐에서 잠자고 있는 일부 에이전트를 깨운다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _taRecord_ = ? ValidateIntegerTypedArray(_typedArray_, *true*).
        1. _byteIndexInBuffer_ = ? ValidateAtomicAccess(_taRecord_, _index_).
        1. _count_ = *undefined* 이면
          1. _c_ = +∞.
        1. Else
          1. _intCount_ = ? ToIntegerOrInfinity(_count_).
          1. _c_ = max(_intCount_, 0).
        1. _buffer_ = _typedArray_.[[ViewedArrayBuffer]].
        1. _block_ = _buffer_.[[ArrayBufferData]].
        1. IsSharedArrayBuffer(_buffer_) = *false* 이면 *+0*<sub>𝔽</sub> 반환.
        1. _WL_ = GetWaiterList(_block_, _byteIndexInBuffer_).
        1. EnterCriticalSection(_WL_) 수행.
        1. _S_ = RemoveWaiters(_WL_, _c_).
        1. 각 _S_ 요소 _W_ 에 대해
          1. NotifyWaiter(_WL_, _W_) 수행.
        1. LeaveCriticalSection(_WL_) 수행.
        1. _n_ = _S_ 요소 수.
        1. Return 𝔽(_n_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.xor">
      <h1>Atomics.xor ( _typedArray_, _index_, _value_ )</h1>
      <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _xor_ = 매개변수 (_xBytes_, _yBytes_) 를 가지고 아무것도 캡처하지 않으며 호출 시 원자적으로:
          1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_).
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-atomics-@@tostringtag" id="sec-atomics-%symbol.tostringtag%">
      <h1>Atomics [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"Atomics"* 이다.</p>
      <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-json-object">
    <h1>JSON 객체</h1>
    <p>JSON 객체:</p>
    <ul>
      <li><dfn>%JSON%</dfn> 이다.</li>
      <li>전역 객체 *"JSON"* 프로퍼티의 초기 값이다.</li>
      <li>일반 객체이다.</li>
      <li>JSON 텍스트를 파싱 및 구성하기 위한 `parse` 와 `stringify` 두 함수 포함.</li>
      <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      <li>[[Construct]] 내부 메서드가 없어 `new` 생성자로 사용할 수 없다.</li>
      <li>[[Call]] 내부 메서드가 없어 함수로 호출할 수 없다.</li>
    </ul>
    <p>JSON 데이터 교환 형식은 ECMA-404 에 정의된다. 본 명세에서 사용하는 JSON 교환 형식은 ECMA-404 에 기술된 것과 정확히 동일하다. `JSON.parse` 및 `JSON.stringify` 의 적합 구현은 ECMA-404 명세에 기술된 교환 형식을 삭제나 확장 없이 정확히 지원해야 한다.</p>

    <emu-clause id="sec-json.parse">
      <h1>JSON.parse ( _text_ [ , _reviver_ ] )</h1>
      <p>이 함수는 JSON 텍스트(JSON 형식 문자열)를 파싱하여 ECMAScript 언어 값을 생성한다. JSON 형식은 ECMAScript 리터럴, 배열 초기자, 객체 초기자와 유사한 구문으로 리터럴, 배열, 객체를 표현한다. 파싱 후 JSON 객체는 ECMAScript 객체로, JSON 배열은 ECMAScript Array 인스턴스로 실현된다. JSON 문자열, 숫자, 불리언, null 은 ECMAScript String, Number, Boolean 및 *null* 로 실현된다.</p>
      <p>선택적 _reviver_ 매개변수는 _key_, _value_ 두 매개변수를 받는 함수로 결과를 필터/변환할 수 있다. 파싱에서 생성된 각 _key_/_value_ 쌍에 대해 호출되며 반환값이 원래 값 대신 사용된다. 받은 값을 그대로 반환하면 구조는 수정되지 않는다. *undefined* 를 반환하면 그 프로퍼티는 결과에서 삭제된다.</p>
      <emu-alg>
        1. _jsonString_ = ? ToString(_text_).
        1. _unfiltered_ = ? ParseJSON(_jsonString_).
        1. IsCallable(_reviver_) = *true* 이면
          1. _root_ = OrdinaryObjectCreate(%Object.prototype%).
          1. _rootName_ = 빈 문자열.
          1. ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_) 수행.
          1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).
        1. Else
          1. Return _unfiltered_.
      </emu-alg>
      <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub>이다.</p>

      <emu-clause id="sec-ParseJSON" type="abstract operation">
        <h1>
          ParseJSON (
            _text_: a String,
          ): 정상 완료(ECMAScript 언어 값) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. [id="step-json-parse-validate"] StringToCodePoints(_text_) 가 ECMA-404 에 지정된 유효한 JSON 텍스트가 아니면 *SyntaxError* 예외.
          1. _scriptString_ = *"("* 와 _text_ 및 *");"* 의 문자열 연결.
          1. [id="step-json-parse-parse"] _script_ = ParseText(_scriptString_, |Script|).
          1. NOTE: <emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref> 에 정의된 초기 에러 규칙은 위 ParseText 호출에 대해 특별 처리.
          1. Assert: _script_ 는 Parse Node.
          1. [id="step-json-parse-eval"] _result_ = ! <emu-meta suppress-effects="user-code">Evaluation of _script_</emu-meta>.
          1. NOTE: <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> 에 정의된 PropertyDefinitionEvaluation 의미론은 위 평가에 대해 특별 처리.
          1. [id="step-json-parse-assert-type"] Assert: _result_ 는 String, Number, Boolean, |ArrayLiteral| 또는 |ObjectLiteral| 로 정의된 Object, 또는 *null*.
          1. Return _result_.
        </emu-alg>
        <p>적합한 `JSON.parse` 구현은 JSON 문법을 확장할 수 없다. 수정/확장된 JSON 교환 형식을 지원하려면 다른 parse 함수를 정의해야 한다.</p>
        <emu-note>
          <p>유효 JSON 텍스트는 ECMAScript |PrimaryExpression| 구문의 부분집합이다. 단계 <emu-xref href="#step-json-parse-validate"></emu-xref> 는 _jsonString_ 이 그 부분집합에 부합하는지 검증하고, <emu-xref href="#step-json-parse-assert-type"></emu-xref> 는 평가 결과가 적절한 타입임을 단언한다.</p>
          <p>그러나 <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> 가 ParseJSON 중 다르게 동작하므로, 동일 소스 텍스트가 |PrimaryExpression| 으로 평가될 때와 JSON 으로 평가될 때 다른 결과를 낼 수 있다. 또한 객체 리터럴에서 중복 *"__proto__"* 프로퍼티에 대한 Early Error 가 ParseJSON 중에는 적용되지 않으므로 문법과 일치해도 ParseJSON 이 허용하는 텍스트 일부는 |PrimaryExpression| 으로 유효하지 않다.</p>
        </emu-note>
        <emu-note>
          <p>객체 내 이름 문자열이 중복될 경우 동일 키의 앞선 값들은 덮어써진다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-internalizejsonproperty" type="abstract operation">
        <h1>
          InternalizeJSONProperty (
            _holder_: an Object,
            _name_: a String,
            _reviver_: a function object,
          ): 정상 완료(ECMAScript 언어 값) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>이 알고리즘은 [[Delete]] 또는 CreateDataProperty 가 *false* 를 반환해도 예외를 던지지 않도록 의도되었다.</p>
        </emu-note>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _val_ = ? Get(_holder_, _name_).
          1. _val_ 이 Object 이면
            1. _isArray_ = ? IsArray(_val_).
            1. _isArray_ = *true* 이면
              1. _len_ = ? LengthOfArrayLike(_val_).
              1. _I_ = 0.
              1. 반복, _I_ &lt; _len_ 동안
                1. _prop_ = ! ToString(𝔽(_I_)).
                1. _newElement_ = ? InternalizeJSONProperty(_val_, _prop_, _reviver_).
                1. _newElement_ = *undefined* 이면
                  1. ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_prop_) 수행.
                1. Else
                  1. ? CreateDataProperty(_val_, _prop_, _newElement_) 수행.
                1. _I_ = _I_ + 1.
            1. Else
              1. _keys_ = ? EnumerableOwnProperties(_val_, ~key~).
              1. 각 String _P_ ∈ _keys_ 에 대해
                1. _newElement_ = ? InternalizeJSONProperty(_val_, _P_, _reviver_).
                1. _newElement_ = *undefined* 이면
                  1. ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_P_) 수행.
                1. Else
                  1. ? CreateDataProperty(_val_, _P_, _newElement_) 수행.
          1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json.stringify">
      <h1>JSON.stringify ( _value_ [ , _replacer_ [ , _space_ ] ] )</h1>
      <p>이 함수는 ECMAScript 언어 값을 UTF-16 인코딩된 JSON 형식 String 또는 *undefined* 로 반환한다. 세 매개변수를 받을 수 있다. _value_ 는 일반적으로 객체나 배열이지만 String, Boolean, Number, *null* 일 수도 있다. 선택적 _replacer_ 는 객체/배열을 문자열화하는 방식을 바꾸는 함수이거나 문자열/숫자 배열(포함 리스트)이다. 선택적 _space_ 는 결과에 공백을 삽입해 가독성을 높이기 위한 String 또는 Number 이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _stack_ = 새 빈 List.
        1. _indent_ = 빈 문자열.
        1. _PropertyList_ = *undefined*.
        1. _ReplacerFunction_ = *undefined*.
        1. _replacer_ 가 Object 이면
          1. IsCallable(_replacer_) = *true* 이면
            1. _ReplacerFunction_ = _replacer_.
          1. Else
            1. _isArray_ = ? IsArray(_replacer_).
            1. _isArray_ = *true* 이면
              1. _PropertyList_ = 새 빈 List.
              1. _len_ = ? LengthOfArrayLike(_replacer_).
              1. _k_ = 0.
              1. 반복, _k_ &lt; _len_ 동안
                1. _prop_ = ! ToString(𝔽(_k_)).
                1. _v_ = ? Get(_replacer_, _prop_).
                1. _item_ = *undefined*.
                1. _v_ 가 String 이면
                  1. _item_ = _v_.
                1. Else if _v_ 가 Number 이면
                  1. _item_ = ! ToString(_v_).
                1. Else if _v_ 가 Object 이면
                  1. _v_ 에 [[StringData]] 또는 [[NumberData]] 내부 슬롯이 있으면 _item_ = ? ToString(_v_).
                1. _item_ ≠ *undefined* 그리고 _PropertyList_ 에 _item_ 이 없으면
                  1. _PropertyList_ 에 _item_ 추가.
                1. _k_ = _k_ + 1.
        1. _space_ 가 Object 이면
          1. _space_ 가 [[NumberData]] 내부 슬롯을 가지면
            1. _space_ = ? ToNumber(_space_).
          1. Else if _space_ 가 [[StringData]] 내부 슬롯을 가지면
            1. _space_ = ? ToString(_space_).
        1. _space_ 가 Number 이면
          1. _spaceMV_ = ! ToIntegerOrInfinity(_space_).
          1. _spaceMV_ = min(10, _spaceMV_).
          1. _spaceMV_ &lt; 1 이면 _gap_ = 빈 문자열; 아니면 _gap_ = 코드 유닛 0x0020 (SPACE) * _spaceMV_ 개.
        1. Else if _space_ 가 String 이면
          1. _space_ 길이 ≤ 10 이면 _gap_ = _space_; 아니면 _gap_ = _space_ 의 0~10 부분 문자열.
        1. Else
          1. _gap_ = 빈 문자열.
        1. _wrapper_ = OrdinaryObjectCreate(%Object.prototype%).
        1. ! CreateDataPropertyOrThrow(_wrapper_, 빈 문자열, _value_) 수행.
        1. _state_ = JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.
        1. Return ? SerializeJSONProperty(_state_, 빈 문자열, _wrapper_).
      </emu-alg>
      <p>이 함수의 *"length"* 프로퍼티는 *3*<sub>𝔽</sub>이다.</p>
      <emu-note>
        <p>JSON 구조는 임의 깊이로 중첩 가능하지만 비순환이어야 한다. _value_ 가 순환 구조이면 *TypeError* 예외를 던져야 한다. 예:</p>
        <pre><code class="javascript">
          a = [];
          a[0] = a;
          my_text = JSON.stringify(a); // 여기서는 TypeError 가 발생해야 함.
        </code></pre>
      </emu-note>
      <emu-note>
        <p>기호적(심볼이 아님) 기본 값들은 다음과 같이 표현된다:</p>
        <ul>
          <li>*null* 값 → 문자열 *"null"*.</li>
          <li>*undefined* 값 → 렌더되지 않음.</li>
          <li>*true* 값 → 문자열 *"true"*.</li>
          <li>*false* 값 → 문자열 *"false"*.</li>
        </ul>
      </emu-note>
      <emu-note>
        <p>문자열 값은 QUOTATION MARK (`"`) 코드 유닛으로 둘러싸인다. 코드 유닛 `"` 및 `\\` 는 `\\` 접두로 이스케이프. 제어 문자 코드 유닛은 `\\u`HHHH 또는 더 짧은 `\\b`, `\\f`, `\\n`, `\\r`, `\\t` 로 대체.</p>
      </emu-note>
      <emu-note>
        <p>유한수는 ToString(_number_) 호출과 같이 문자열화된다. 부호와 무관하게 *NaN*, *Infinity* 는 문자열 *"null"* 로 표현.</p>
      </emu-note>
      <emu-note>
        <p>JSON 표현이 없는 값(*undefined*, 함수 등)은 문자열을 생성하지 않고 *undefined* 반환. 배열에서는 *"null"* 로, 객체에서는 해당 프로퍼티가 제외된다.</p>
      </emu-note>
      <emu-note>
        <p>객체는 U+007B 후 0개 이상 프로퍼티 (U+002C 로 구분), U+007D 로 닫힘. 프로퍼티는 따옴표로 둘러싼 이름, U+003A, 문자열화된 값. 배열은 U+005B 후 값들(콤마 구분), U+005D 로 닫힘.</p>
      </emu-note>

      <emu-clause id="sec-json-serialization-record">
        <h1>JSON Serialization Record</h1>
        <p><dfn variants="JSON Serialization Records">JSON Serialization Record</dfn> 는 JSON 형식 직렬화를 가능하게 하는 Record 값이다.</p>
        <p>JSON Serialization Record 는 <emu-xref href="#table-json-serialization-record"></emu-xref> 필드를 가진다.</p>
        <emu-table id="table-json-serialization-record" caption="JSON Serialization Record 필드">
          <table>
            <thead>
              <tr>
                <th>필드 이름</th>
                <th>값</th>
                <th>의미</th>
              </tr>
            </thead>
            <tr>
              <td>[[ReplacerFunction]]</td>
              <td>함수 객체 또는 *undefined*</td>
              <td>객체 프로퍼티 대체 값을 제공 (JSON.stringify 의 _replacer_).</td>
            </tr>
            <tr>
              <td>[[PropertyList]]</td>
              <td>문자열 List 또는 *undefined*</td>
              <td>비배열 객체 직렬화 시 포함할 프로퍼티 이름들 (_replacer_).</td>
            </tr>
            <tr>
              <td>[[Gap]]</td>
              <td>String</td>
              <td>들여쓰기 단위 (_space_).</td>
            </tr>
            <tr>
              <td>[[Stack]]</td>
              <td>Object List</td>
              <td>직렬화 진행 중 중첩 객체 집합 (순환 감지).</td>
            </tr>
            <tr>
              <td>[[Indent]]</td>
              <td>String</td>
              <td>현재 들여쓰기.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-serializejsonproperty" type="abstract operation">
        <h1>
          SerializeJSONProperty (
            _state_: a JSON Serialization Record,
            _key_: a String,
            _holder_: an Object,
          ): 정상 완료(String 또는 *undefined*) 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _value_ = ? Get(_holder_, _key_).
          1. _value_ 가 Object 또는 BigInt 면
            1. _toJSON_ = ? GetV(_value_, *"toJSON"*).
            1. IsCallable(_toJSON_) = *true* 이면
              1. _value_ = ? Call(_toJSON_, _value_, « _key_ »).
          1. _state_.[[ReplacerFunction]] ≠ *undefined* 이면
            1. _value_ = ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).
          1. _value_ 가 Object 이면
            1. &#8288;[[NumberData]] 슬롯 있으면 _value_ = ? ToNumber(_value_).
            1. Else if [[StringData]] 슬롯 있으면 _value_ = ? ToString(_value_).
            1. Else if [[BooleanData]] 슬롯 있으면 _value_ = _value_.[[BooleanData]].
            1. Else if [[BigIntData]] 슬롯 있으면 _value_ = _value_.[[BigIntData]].
          1. _value_ = *null* 이면 *"null"* 반환.
          1. _value_ = *true* 이면 *"true"* 반환.
          1. _value_ = *false* 이면 *"false"* 반환.
          1. _value_ 가 String 이면 QuoteJSONString(_value_) 반환.
          1. _value_ 가 Number 이면
            1. _value_ 가 유한수면 ! ToString(_value_) 반환.
            1. *"null"* 반환.
          1. _value_ 가 BigInt 이면 *TypeError* 예외.
          1. _value_ 가 Object 이고 IsCallable(_value_) = *false* 이면
            1. _isArray_ = ? IsArray(_value_).
            1. _isArray_ = *true* 이면 ? SerializeJSONArray(_state_, _value_) 반환.
            1. Return ? SerializeJSONObject(_state_, _value_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-quotejsonstring" type="abstract operation">
        <h1>
          QuoteJSONString (
            _value_: a String,
          ): String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_value_ 를 0x0022 (QUOTATION MARK) 코드 유닛으로 감싸고 특정 코드 유닛을 이스케이프한다. 이 연산은 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 기술된 대로 _value_ 를 UTF-16 인코딩 코드 포인트 시퀀스로 해석한다.</dd>
        </dl>
        <emu-alg>
          1. _product_ = 코드 유닛 0x0022 로만 구성된 String.
          1. StringToCodePoints(_value_) 의 각 코드 포인트 _C_ 에 대해
            1. _C_ 가 <emu-xref href="#table-json-single-character-escapes"></emu-xref> “Code Point” 열에 나열되면
              1. _product_ = _product_ + 해당 행 “Escape Sequence” 열의 이스케이프 시퀀스.
            1. Else if _C_ 의 수치값 &lt; 0x0020 또는 선행/후행 서로게이트와 동일 수치값이면
              1. _unit_ = _C_ 의 수치값을 가진 코드 유닛.
              1. _product_ = _product_ + UnicodeEscape(_unit_).
            1. Else
              1. _product_ = _product_ + UTF16EncodeCodePoint(_C_).
          1. _product_ = _product_ + 코드 유닛 0x0022.
          1. Return _product_.
        </emu-alg>
        <emu-table id="table-json-single-character-escapes" caption="JSON 단일 문자 이스케이프 시퀀스">
          <table>
            <thead>
              <tr>
                <th>
                  Code Point
                </th>
                <th>
                  유니코드 이름
                </th>
                <th>
                  Escape Sequence
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                U+0008
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                `\\b`
              </td>
            </tr>
            <tr>
              <td>
                U+0009
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                `\\t`
              </td>
            </tr>
            <tr>
              <td>
                U+000A
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                `\\n`
              </td>
            </tr>
            <tr>
              <td>
                U+000C
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                `\\f`
              </td>
            </tr>
            <tr>
              <td>
                U+000D
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                `\\r`
              </td>
            </tr>
            <tr>
              <td>
                U+0022
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `\\"`
              </td>
            </tr>
            <tr>
              <td>
                U+005C
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\\\`
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unicodeescape" type="abstract operation">
        <h1>
          UnicodeEscape (
            _C_: a code unit,
          ): String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_C_ 를 유니코드 이스케이프 시퀀스로 표현한다.</dd>
        </dl>
        <emu-alg>
          1. _n_ = _C_ 의 수치값.
          1. Assert: _n_ ≤ 0xFFFF.
          1. _hex_ = _n_ 의 소문자 16진수 문자열 표현.
          1. Return 코드 유닛 0x005C (REVERSE SOLIDUS) + *"u"* + StringPad(_hex_, 4, *"0"*, ~start~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonobject" type="abstract operation">
        <h1>
          SerializeJSONObject (
            _state_: a JSON Serialization Record,
            _value_: an Object,
          ): 정상 완료(String) 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>객체를 직렬화한다.</dd>
        </dl>
        <emu-alg>
          1. _state_.[[Stack]] 이 _value_ 를 포함하면 순환 구조이므로 *TypeError* 예외.
          1. _state_.[[Stack]] 에 _value_ 추가.
          1. _stepBack_ = _state_.[[Indent]].
          1. _state_.[[Indent]] = _state_.[[Indent]] + _state_.[[Gap]].
          1. _state_.[[PropertyList]] ≠ *undefined* 이면
            1. _K_ = _state_.[[PropertyList]].
          1. Else
            1. _K_ = ? EnumerableOwnProperties(_value_, ~key~).
          1. _partial_ = 새 빈 List.
          1. 각 _K_ 요소 _P_ 에 대해
            1. _strP_ = ? SerializeJSONProperty(_state_, _P_, _value_).
            1. _strP_ ≠ *undefined* 이면
              1. _member_ = QuoteJSONString(_P_).
              1. _member_ = _member_ + *":"*.
              1. _state_.[[Gap]] ≠ 빈 문자열이면
                1. _member_ = _member_ + 코드 유닛 0x0020 (SPACE).
              1. _member_ = _member_ + _strP_.
              1. _partial_ 에 _member_ 추가.
          1. _partial_ 이 비어 있으면
            1. _final_ = *"{}"*.
          1. Else
            1. _state_.[[Gap]] = 빈 문자열이면
              1. _properties_ = _partial_ 요소를 0x002C (COMMA) 로 연결한 String (선/후방 콤마 없음).
              1. _final_ = *"{"* + _properties_ + *"}"*.
            1. Else
              1. _separator_ = 0x002C (COMMA) + 0x000A (LINE FEED) + _state_.[[Indent]].
              1. _properties_ = _partial_ 요소를 _separator_ 로 연결한 String.
              1. _final_ = *"{"* + 0x000A + _state_.[[Indent]] + _properties_ + 0x000A + _stepBack_ + *"}"*.
          1. _state_.[[Stack]] 마지막 요소 제거.
          1. _state_.[[Indent]] = _stepBack_.
          1. Return _final_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonarray" type="abstract operation">
        <h1>
          SerializeJSONArray (
            _state_: a JSON Serialization Record,
            _value_: an ECMAScript language value,
          ): 정상 완료(String) 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>배열을 직렬화한다.</dd>
        </dl>
        <emu-alg>
          1. _state_.[[Stack]] 이 _value_ 포함하면 순환이므로 *TypeError* 예외.
          1. _state_.[[Stack]] 에 _value_ 추가.
          1. _stepBack_ = _state_.[[Indent]].
          1. _state_.[[Indent]] = _state_.[[Indent]] + _state_.[[Gap]].
          1. _partial_ = 새 빈 List.
          1. _len_ = ? LengthOfArrayLike(_value_).
          1. _index_ = 0.
          1. 반복, _index_ &lt; _len_ 동안
            1. _strP_ = ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).
            1. _strP_ = *undefined* 이면
              1. _partial_ 에 *"null"* 추가.
            1. Else
              1. _partial_ 에 _strP_ 추가.
            1. _index_ = _index_ + 1.
          1. _partial_ 비어 있으면
            1. _final_ = *"[]"*.
          1. Else
            1. _state_.[[Gap]] = 빈 문자열이면
              1. _properties_ = _partial_ 요소를 0x002C (COMMA) 로 연결.
              1. _final_ = *"["* + _properties_ + *"]"*.
            1. Else
              1. _separator_ = 0x002C (COMMA) + 0x000A (LINE FEED) + _state_.[[Indent]].
              1. _properties_ = _partial_ 요소를 _separator_ 로 연결.
              1. _final_ = *"["* + 0x000A + _state_.[[Indent]] + _properties_ + 0x000A + _stepBack_ + *"]"*.
          1. _state_.[[Stack]] 마지막 요소 제거.
          1. _state_.[[Indent]] = _stepBack_.
          1. Return _final_.
        </emu-alg>
        <emu-note>
          <p>배열 표현은 *+0*<sub>𝔽</sub> 이상 `array.length` 미만 인덱스 요소만 포함한다. 배열 인덱스가 아닌 키 프로퍼티는 제외된다. 배열은 여는 대괄호, 콤마로 구분된 요소, 닫는 대괄호로 문자열화된다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-json-@@tostringtag" id="sec-json-%symbol.tostringtag%">
      <h1>JSON [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"JSON"* 이다.</p>
      <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>메모리 관리 (Managing Memory)</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef 객체</h1>
    <p>WeakRef 는 대상 객체나 심볼을 가비지 컬렉션으로부터 유지하지(보호하지) 않은 채로 참조하기 위해 사용되는 객체이다. WeakRef 는 대상이 아직 가비지 컬렉션에 의해 회수되지 않았다면 대상 값에 접근할 수 있도록 역참조(dereference)될 수 있다.</p>

    <emu-clause id="sec-weak-ref-constructor">
      <h1>WeakRef 생성자</h1>
      <p><dfn variants="WeakRefs">WeakRef</dfn> 생성자:</p>
      <ul>
        <li><dfn>%WeakRef%</dfn> 이다.</li>
        <li>
          전역 객체의 *"WeakRef"* 프로퍼티 초기 값이다.
        </li>
        <li>
          생성자로 호출될 때 새 WeakRef 를 생성하고 초기화한다.
        </li>
        <li>
          함수로 호출하도록 의도되지 않았으며 그렇게 호출되면 예외를 던진다.
        </li>
        <li>
          클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 `WeakRef` 동작을 상속하려는 서브클래스 생성자는 `WeakRef.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 `WeakRef` 생성자에 대한 `super` 호출을 포함해야 한다.
        </li>
      </ul>

      <emu-clause id="sec-weak-ref-target">
        <h1>WeakRef ( _target_ )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외를 던진다.
          1. CanBeHeldWeakly(_target_) 이 *false* 이면 *TypeError* 예외를 던진다.
          1. _weakRef_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakRef.prototype%"*, « [[WeakRefTarget]] »).
          1. AddToKeptObjects(_target_) 수행.
          1. _weakRef_.[[WeakRefTarget]] 를 _target_ 으로 설정.
          1. _weakRef_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor">
      <h1>WeakRef 생성자의 프로퍼티</h1>
      <p>WeakRef 생성자:</p>
      <ul>
        <li>
          값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.
        </li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype">
        <h1>WeakRef.prototype</h1>
        <p>`WeakRef.prototype` 의 초기 값은 WeakRef 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 속성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-prototype-object">
      <h1>WeakRef 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>WeakRef 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%WeakRef.prototype%</dfn> 이다.</li>
        <li>
          값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.
        </li>
        <li>일반 객체이다.</li>
        <li>[[WeakRefTarget]] 내부 슬롯을 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype.constructor" normative-optional>
        <h1>WeakRef.prototype.constructor</h1>

        <p>`WeakRef.prototype.constructor` 의 초기 값은 %WeakRef% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-weak-ref.prototype.deref">
        <h1>WeakRef.prototype.deref ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _weakRef_ 를 *this* 값으로 둔다.
          1. ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]) 수행.
          1. WeakRefDeref(_weakRef_) 를 반환.
        </emu-alg>

        <emu-note>
          <p>WeakRef 가 *undefined* 가 아닌 _target_ 값을 반환한다면, 현재 ECMAScript 코드 실행이 완료될 때까지 이 _target_ 값은 가비지 컬렉션되지 않아야 한다. AddToKeptObjects 연산이 읽기 일관성이 유지되도록 보장한다.</p>

          <pre><code class="javascript">
            let target = { foo() {} };
            let weakRef = new WeakRef(target);

            // ... later ...

            if (weakRef.deref()) {
              weakRef.deref().foo();
            }
          </code></pre>

          <p>위 예에서 첫 번째 deref 가 *undefined* 로 평가되지 않는다면 두 번째 deref 또한 *undefined* 가 될 수 없다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-weak-ref.prototype-@@tostringtag" id="sec-weak-ref.prototype-%symbol.tostringtag%">
        <h1>WeakRef.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"WeakRef"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 속성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-weakref-abstract-operations">
      <h1>WeakRef 추상 연산</h1>

      <emu-clause id="sec-weakrefderef" type="abstract operation">
        <h1>
          WeakRefDeref (
            _weakRef_: a WeakRef,
          ): an ECMAScript language value
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _target_ = _weakRef_.[[WeakRefTarget]].
          1. _target_ 이 ~empty~ 가 아니면
            1. AddToKeptObjects(_target_) 수행.
            1. _target_ 반환.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>이 추상 연산은 liveness 를 간단히 정의할 수 있도록 WeakRef.prototype.deref 와 분리되어 정의된다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weak-ref-instances">
      <h1>WeakRef 인스턴스의 프로퍼티</h1>
      <p>WeakRef 인스턴스는 WeakRef 프로토타입 객체로부터 프로퍼티를 상속하는 일반 객체이다. 또한 [[WeakRefTarget]] 내부 슬롯을 가진다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry 객체</h1>
    <p>FinalizationRegistry 는 대상 객체와 심볼이 가비지 컬렉션될 때 수행되는 정리(cleanup) 동작의 등록 및 등록 해제를 관리하는 객체이다.</p>

    <emu-clause id="sec-finalization-registry-constructor">
      <h1>FinalizationRegistry 생성자</h1>
      <p><dfn variants="FinalizationRegistrys">FinalizationRegistry</dfn> 생성자:</p>
      <ul>
        <li><dfn>%FinalizationRegistry%</dfn> 이다.</li>
        <li>
          전역 객체의 *"FinalizationRegistry"* 프로퍼티 초기 값이다.
        </li>
        <li>
          생성자로 호출될 때 새 FinalizationRegistry 를 생성·초기화한다.
        </li>
        <li>
          함수로 호출하도록 의도되지 않았으며 그렇게 호출되면 예외를 던진다.
        </li>
        <li>
          클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 `FinalizationRegistry` 동작을 상속하려는 서브클래스 생성자는 `FinalizationRegistry.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성·초기화하기 위해 `FinalizationRegistry` 생성자에 대한 `super` 호출을 포함해야 한다.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry-cleanup-callback">
        <h1>FinalizationRegistry ( _cleanupCallback_ )</h1>
        <p>이 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외를 던진다.
          1. IsCallable(_cleanupCallback_) 이 *false* 이면 *TypeError* 예외를 던진다.
          1. _finalizationRegistry_ = ? OrdinaryCreateFromConstructor(NewTarget, *"%FinalizationRegistry.prototype%"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).
          1. _fn_ = 활성 함수 객체로 둔다.
          1. _finalizationRegistry_.[[Realm]] = _fn_.[[Realm]] 로 설정.
          1. _finalizationRegistry_.[[CleanupCallback]] = HostMakeJobCallback(_cleanupCallback_) 로 설정.
          1. _finalizationRegistry_.[[Cells]] = 새 빈 List 로 설정.
          1. _finalizationRegistry_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor">
      <h1>FinalizationRegistry 생성자의 프로퍼티</h1>
      <p>FinalizationRegistry 생성자:</p>
      <ul>
        <li>
          값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.
        </li>
        <li>다음 프로퍼티를 가진다:</li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype">
        <h1>FinalizationRegistry.prototype</h1>
        <p>`FinalizationRegistry.prototype` 의 초기 값은 FinalizationRegistry 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 속성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-prototype-object">
      <h1>FinalizationRegistry 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>FinalizationRegistry 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%FinalizationRegistry.prototype%</dfn> 이다.</li>
        <li>
          값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.
        </li>
        <li>일반 객체이다.</li>
        <li>
          [[Cells]] 및 [[CleanupCallback]] 내부 슬롯을 가지지 않는다.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype.constructor">
        <h1>FinalizationRegistry.prototype.constructor</h1>
        <p>`FinalizationRegistry.prototype.constructor` 의 초기 값은 %FinalizationRegistry% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.register">
        <h1>FinalizationRegistry.prototype.register ( _target_, _heldValue_ [ , _unregisterToken_ ] )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _finalizationRegistry_ 를 *this* 값으로 둔다.
          1. ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]) 수행.
          1. CanBeHeldWeakly(_target_) 이 *false* 이면 *TypeError* 예외.
          1. SameValue(_target_, _heldValue_) = *true* 이면 *TypeError* 예외.
          1. CanBeHeldWeakly(_unregisterToken_) 이 *false* 이면
            1. _unregisterToken_ 이 *undefined* 가 아니면 *TypeError* 예외.
            1. _unregisterToken_ = ~empty~ 로 설정.
          1. _cell_ = Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.
          1. _finalizationRegistry_.[[Cells]] 에 _cell_ 추가.
          1. *undefined* 반환.
        </emu-alg>

        <emu-note>
          <p>명세의 알고리즘과 정의에 따르면 _finalizationRegistry_.[[Cells]] 가 _cell_ 을 포함하는 동안 _cell_.[[HeldValue]] 는 live 이다; 그러나 이것이 반드시 _cell_.[[UnregisterToken]] 또는 _cell_.[[Target]] 이 live 임을 의미하지는 않는다. 예를 들어 객체를 자기 자신을 unregister token 으로 하여 등록해도 그 객체를 영원히 살려 두지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.unregister">
        <h1>FinalizationRegistry.prototype.unregister ( _unregisterToken_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _finalizationRegistry_ 를 *this* 값으로 둔다.
          1. ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]) 수행.
          1. CanBeHeldWeakly(_unregisterToken_) 이 *false* 이면 *TypeError* 예외.
          1. _removed_ = *false* 로 둔다.
          1. _finalizationRegistry_.[[Cells]] 의 각 Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_ 에 대해
            1. _cell_.[[UnregisterToken]] 이 ~empty~ 가 아니고 SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) = *true* 이면
              1. _finalizationRegistry_.[[Cells]] 에서 _cell_ 제거.
              1. _removed_ = *true* 로 설정.
          1. _removed_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-finalization-registry.prototype-@@tostringtag" id="sec-finalization-registry.prototype-%symbol.tostringtag%">
        <h1>FinalizationRegistry.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티 초기 값은 String *"FinalizationRegistry"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 속성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-finalization-registry-instances">
      <h1>FinalizationRegistry 인스턴스의 프로퍼티</h1>
      <p>FinalizationRegistry 인스턴스는 FinalizationRegistry 프로토타입 객체로부터 프로퍼티를 상속하는 일반 객체이다. 또한 [[Cells]] 및 [[CleanupCallback]] 내부 슬롯을 가진다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>제어 추상화 객체 (Control Abstraction Objects)</h1>

  <emu-clause id="sec-iteration">
    <h1>반복 (Iteration)</h1>

    <emu-clause id="sec-common-iteration-interfaces">
      <h1>공통 반복 인터페이스 (Common Iteration Interfaces)</h1>
      <p>인터페이스는 특정 명세를 만족하는 값들을 갖는 프로퍼티 키들의 집합이다. 어떤 객체가 한 인터페이스 명세에 기술된 모든 프로퍼티를 제공하면 그 객체는 그 인터페이스를 <em>준수</em>(conform)한다고 한다. 인터페이스 자체가 별도의 객체로 표현되지는 않는다. 하나의 인터페이스를 준수하는 개별적으로 구현된 객체는 여럿 있을 수 있다. 하나의 객체가 여러 인터페이스를 동시에 준수할 수도 있다.</p>

      <emu-clause id="sec-iterable-interface">
        <h1>Iterable 인터페이스 (The Iterable Interface)</h1>
        <p><dfn variants="iterable,iterables,iterable object,iterable objects">iterable 인터페이스</dfn>는 <emu-xref href="#table-iterable-interface-required-properties"></emu-xref>에 기술된 프로퍼티를 포함한다:</p>
        <emu-table id="table-iterable-interface-required-properties" caption="Iterable 인터페이스 필수 프로퍼티 (Iterable Interface Required Properties)" oldids="table-52">
          <table>
            <thead>
              <tr>
                <th>
                  프로퍼티 (Property)
                </th>
                <th>
                  값 (Value)
                </th>
                <th>
                  요구사항 (Requirements)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `%Symbol.iterator%`
              </td>
              <td>
                이터레이터 객체를 반환하는 함수
              </td>
              <td>
                반환된 객체는 iterator 인터페이스를 준수해야 한다.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-iterator-interface">
        <h1>Iterator 인터페이스 (The Iterator Interface)</h1>
        <p><dfn variants="iterator object,iterator objects,iterator,iterators">iterator 인터페이스</dfn>를 구현하는 객체는 <emu-xref href="#table-iterator-interface-required-properties"></emu-xref>의 프로퍼티를 포함해야 한다. 그러한 객체는 <emu-xref href="#table-iterator-interface-optional-properties"></emu-xref>의 프로퍼티를 추가로 구현할 수도 있다.</p>
        <emu-table id="table-iterator-interface-required-properties" caption="Iterator 인터페이스 필수 프로퍼티 (Iterator Interface Required Properties)" oldids="table-53">
          <table>
            <thead>
              <tr>
                <th>
                  프로퍼티
                </th>
                <th>
                  값
                </th>
                <th>
                  요구사항
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"next"*
              </td>
              <td>
                IteratorResult 객체를 반환하는 함수
              </td>
              <td>
                반환된 객체는 IteratorResult 인터페이스를 준수해야 한다. 어떤 이터레이터의 `next` 메서드에 대한 이전 호출이 *"done"* 프로퍼티가 *true*인 IteratorResult 객체를 반환했다면, 그 객체에 대한 이후의 모든 `next` 호출도 *"done"* 프로퍼티가 *true*인 IteratorResult 객체를 반환해야 한다. 그러나 이 요구사항은 강제되지 않는다.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>`next` 함수에 인수를 전달할 수 있지만, 그것들의 해석 및 유효성은 대상 이터레이터에 의존한다. for-of 문 및 기타 일반적인 이터레이터 소비자는 어떤 인수도 전달하지 않으므로, 그러한 방식으로 사용될 것을 기대하는 이터레이터 객체는 인수 없이 호출되는 상황을 처리할 준비가 되어 있어야 한다.</p>
        </emu-note>
        <emu-table id="table-iterator-interface-optional-properties" caption="Iterator 인터페이스 선택적 프로퍼티 (Iterator Interface Optional Properties)" oldids="table-54">
          <table>
            <thead>
              <tr>
                <th>
                  프로퍼티
                </th>
                <th>
                  값
                </th>
                <th>
                  요구사항
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"return"*
              </td>
              <td>
                IteratorResult 객체를 반환하는 함수
              </td>
              <td>
                반환된 객체는 IteratorResult 인터페이스를 준수해야 한다. 이 메서드를 호출하면 호출자가 더 이상 이터레이터의 `next` 메서드를 호출할 의도가 없음을 이터레이터 객체에 알린다. 반환된 IteratorResult 객체는 대개 *"done"* 프로퍼티 값이 *true*이고, `return` 메서드의 인수로 전달된 값을 가진 *"value"* 프로퍼티를 가진다. 그러나 이 요구사항은 강제되지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                *"throw"*
              </td>
              <td>
                IteratorResult 객체를 반환하는 함수
              </td>
              <td>
                반환된 객체는 IteratorResult 인터페이스를 준수해야 한다. 이 메서드를 호출하면 호출자가 에러 상태를 감지했음을 이터레이터 객체에 알린다. 인수는 에러 상태를 식별하는 데 사용될 수 있고 일반적으로 예외 객체일 것이다. 일반적인 반응은 인수로 전달된 값을 `throw`하는 것이다. 메서드가 `throw`하지 않는 경우, 반환된 IteratorResult 객체는 대개 *"done"* 프로퍼티 값이 *true*이다.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>보통 이러한 메서드의 호출자는 호출 전에 그 존재를 확인해야 한다. `for`-`of`, `yield*`, 배열 구조 분해 등을 포함한 특정 ECMAScript 언어 기능은 존재 여부를 확인한 후 이들 메서드를 호출한다. 이터러블 객체를 인수로 받는 대부분의 ECMAScript 라이브러리 함수도 조건부로 이들을 호출한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-asynciterable-interface">
        <h1>Async Iterable 인터페이스 (The Async Iterable Interface)</h1>
        <p><dfn variants="async iterable,async iterables,async iterable object,async iterable objects">async iterable 인터페이스</dfn>는 <emu-xref href="#table-async-iterable"></emu-xref>에 기술된 프로퍼티를 포함한다:</p>
        <emu-table id="table-async-iterable" caption="Async Iterable 인터페이스 필수 프로퍼티 (Async Iterable Interface Required Properties)">
          <table>
            <thead>
              <tr>
                <th>프로퍼티</th>
                <th>값</th>
                <th>요구사항</th>
              </tr>
            </thead>
            <tr>
              <td>`%Symbol.asyncIterator%`</td>
              <td>async 이터레이터 객체를 반환하는 함수</td>
              <td>반환된 객체는 async iterator 인터페이스를 준수해야 한다.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asynciterator-interface">
        <h1>Async Iterator 인터페이스 (The Async Iterator Interface)</h1>
        <p><dfn variants="async iterator object,async iterator objects,async iterator,async iterators">async iterator 인터페이스</dfn>를 구현하는 객체는 <emu-xref href="#table-async-iterator-required"></emu-xref>의 프로퍼티를 포함해야 한다. 그러한 객체는 <emu-xref href="#table-async-iterator-optional"></emu-xref>의 프로퍼티를 추가로 구현할 수도 있다.</p>
        <emu-table id="table-async-iterator-required" caption="Async Iterator 인터페이스 필수 프로퍼티 (Async Iterator Interface Required Properties)">
          <table>
            <thead>
              <tr>
                <th>프로퍼티</th>
                <th>값</th>
                <th>요구사항</th>
              </tr>
            </thead>
            <tr>
              <td>*"next"*</td>
              <td>IteratorResult 객체에 대한 promise 를 반환하는 함수</td>
              <td>
                <p>반환된 promise가 이행(fulfill)될 때, IteratorResult 인터페이스를 준수하는 객체로 이행해야 한다. 어떤 async iterator의 `next` 메서드에 대한 이전 호출이 *"done"* 프로퍼티가 *true*인 IteratorResult 객체에 대한 promise를 반환했다면, 그 객체의 이후 모든 `next` 호출 역시 *"done"* 프로퍼티가 *true*인 IteratorResult 객체에 대한 promise를 반환해야 한다. 그러나 이 요구사항은 강제되지 않는다.</p>

                <p>추가로, 이행 값으로 사용되는 IteratorResult 객체는 promise(또는 "thenable")가 아닌 값을 가진 *"value"* 프로퍼티를 가져야 한다. 하지만 이 요구사항 또한 강제되지 않는다.</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>`next` 함수에 인수를 전달할 수 있지만, 그것들의 해석 및 유효성은 대상 async iterator에 의존한다. `for`-`await`-`of` 문 및 기타 일반적인 async iterator 소비자는 인수를 전달하지 않으므로, 그러한 방식으로 사용될 것을 기대하는 async iterator 객체는 인수 없이 호출되는 상황을 처리할 준비가 되어 있어야 한다.</p>
        </emu-note>
        <emu-table id="table-async-iterator-optional" caption="Async Iterator 인터페이스 선택적 프로퍼티 (Async Iterator Interface Optional Properties)">
          <table>
            <thead>
              <tr>
                <th>프로퍼티</th>
                <th>값</th>
                <th>요구사항</th>
              </tr>
            </thead>
            <tr>
              <td>*"return"*</td>
              <td>IteratorResult 객체에 대한 promise 를 반환하는 함수</td>
              <td>
                <p>반환된 promise가 이행될 때, IteratorResult 인터페이스를 준수하는 객체로 이행해야 한다. 이 메서드를 호출하면 호출자가 async iterator의 `next` 메서드를 더 이상 호출할 의도가 없음을 async iterator 객체에 알린다. 반환되는 promise는 대개 *"done"* 프로퍼티 값이 *true*이고, `return` 메서드의 인수로 전달된 값을 가진 *"value"* 프로퍼티가 있는 IteratorResult 객체로 이행된다. 그러나 이 요구사항은 강제되지 않는다.</p>

                <p>추가로, 이행 값으로 사용되는 IteratorResult 객체는 promise(또는 "thenable")가 아닌 값을 가진 *"value"* 프로퍼티를 가져야 한다. 인수 값이 일반적인 방식으로 사용되는 경우, 만약 그것이 거부된(rejected) promise라면 동일한 reason으로 거부된 promise가 반환되어야 하고, 이행된(fulfilled) promise라면 그 이행 값을 반환 promise의 IteratorResult 객체 이행 값의 *"value"* 프로퍼티로 사용해야 한다. 그러나 이러한 요구사항들도 강제되지 않는다.</p>
              </td>
            </tr>
            <tr>
              <td>*"throw"*</td>
              <td>IteratorResult 객체에 대한 promise 를 반환하는 함수</td>
              <td>
                <p>반환된 promise가 이행될 때, IteratorResult 인터페이스를 준수하는 객체로 이행해야 한다. 이 메서드를 호출하면 호출자가 에러 상태를 감지했음을 async iterator 객체에 알린다. 인수는 에러 상태를 식별하는 데 사용될 수 있으며 일반적으로 예외 객체일 것이다. 전형적인 반응은 인수로 전달된 값으로 거부되는(rejected) promise를 반환하는 것이다.</p>

                <p>반환된 promise가 이행되는 경우, IteratorResult 객체 이행 값은 보통 *"done"* 프로퍼티 값이 *true*이다. 또한 *"value"* 프로퍼티는 promise(또는 "thenable")가 아닌 값을 가져야 하지만, 이 요구사항은 강제되지 않는다.</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>일반적으로 이러한 메서드의 호출자는 호출 전에 그 존재를 확인해야 한다. `for`-`await`-`of` 및 `yield*` 등을 포함한 특정 ECMAScript 언어 기능은 존재 여부를 확인한 뒤 이들 메서드를 호출한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iteratorresult-interface">
        <h1>IteratorResult 인터페이스 (The IteratorResult Interface)</h1>
        <p><dfn variants="IteratorResult object,IteratorResult objects">IteratorResult 인터페이스</dfn>는 <emu-xref href="#table-iteratorresult-interface-properties"></emu-xref>에 열거된 프로퍼티를 포함한다:</p>
        <emu-table id="table-iteratorresult-interface-properties" caption="IteratorResult 인터페이스 프로퍼티 (IteratorResult Interface Properties)" oldids="table-55">
          <table>
            <thead>
              <tr>
                <th>
                  프로퍼티
                </th>
                <th>
                  값
                </th>
                <th>
                  요구사항
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"done"*
              </td>
              <td>
                Boolean
              </td>
              <td>
                이는 이터레이터 `next` 메서드 호출의 결과 상태이다. 이터레이터의 끝에 도달했다면 *"done"* 은 *true*이다. 끝에 도달하지 않았다면 *"done"* 은 *false*이며 값이 존재한다. *"done"* 프로퍼티(소유 또는 상속)가 존재하지 않는다면 그 값은 *false*로 간주한다.
              </td>
            </tr>
            <tr>
              <td>
                *"value"*
              </td>
              <td>
                ECMAScript 언어 값
              </td>
              <td>
                done 이 *false*이면, 이는 현재 반복 요소 값이다. done 이 *true*이면, 이는 이터레이터가 제공했다면 그 반환 값이다. 이터레이터에 반환 값이 없다면 *"value"* 는 *undefined*이다. 그 경우, 객체가 명시적 *"value"* 프로퍼티를 상속하지 않는다면 *"value"* 프로퍼티는 준수 객체에서 생략될 수 있다.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-helper-objects">
      <h1>Iterator Helper 객체 (Iterator Helper Objects)</h1>
      <p><dfn variants="Iterator Helper objects">Iterator Helper 객체</dfn>는 특정 소스 이터레이터 객체의 지연(lazy) 변환을 표현하는 일반 객체이다. Iterator Helper 객체에 대한 명명된 생성자는 없다. 대신, Iterator Helper 객체는 Iterator 인스턴스 객체의 특정 메서드를 호출하여 생성된다.</p>

      <emu-clause id="sec-%iteratorhelperprototype%-object">
        <h1>%IteratorHelperPrototype% 객체 (The %IteratorHelperPrototype% Object)</h1>
        <p><dfn>%IteratorHelperPrototype%</dfn> 객체:</p>
        <ul>
          <li>모든 Iterator Helper 객체가 상속하는 프로퍼티를 가진다.</li>
          <li>일반 객체이다.</li>
          <li>[[Prototype]] 내부 슬롯 값이 %Iterator.prototype%이다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%iteratorhelperprototype%.next">
          <h1>%IteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. ? GeneratorResume(*this* value, *undefined*, *"Iterator Helper"*)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%.return">
          <h1>%IteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. ? RequireInternalSlot(_O_, [[UnderlyingIterator]])를 수행한다.
            1. _O_ 가 [[GeneratorState]] 내부 슬롯을 가지고 있음을 단언(Assert)한다.
            1. _O_.[[GeneratorState]] 가 ~suspended-start~ 이면,
              1. _O_.[[GeneratorState]] 를 ~completed~ 로 설정한다.
              1. 주: 한 번 generator가 completed 상태에 들어가면 다시 나오지 않고 그 연관 실행 컨텍스트는 재개되지 않는다. _O_ 와 연관된 어떤 실행 상태도 이 시점에서 폐기될 수 있다.
              1. ? IteratorClose(_O_.[[UnderlyingIterator]], NormalCompletion(~unused~))를 수행한다.
              1. CreateIteratorResultObject(*undefined*, *true*)를 반환한다.
            1. _C_ 를 ReturnCompletion(*undefined*)로 둔다.
            1. ? GeneratorResumeAbrupt(_O_, _C_, *"Iterator Helper"*)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%-%symbol.tostringtag%">
          <h1>%IteratorHelperPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"Iterator Helper"* 이다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-objects">
      <h1>Iterator 객체 (Iterator Objects)</h1>

      <emu-clause id="sec-iterator-constructor">
        <h1>Iterator 생성자 (The Iterator Constructor)</h1>
        <p><dfn>Iterator</dfn> 생성자:</p>
        <ul>
          <li><dfn>%Iterator%</dfn> 이다.</li>
          <li>전역 객체의 *"Iterator"* 프로퍼티의 초기 값이다.</li>
          <li>서브클래싱 가능하도록 설계되었다. 클래스 정의의 *extends* 절 값으로 사용할 수 있다.</li>
        </ul>

        <emu-clause id="sec-iterator">
          <h1>Iterator ( )</h1>
          <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. NewTarget 이 *undefined* 이거나 활성 함수 객체라면 *TypeError* 예외를 던진다.
            1. ? OrdinaryCreateFromConstructor(NewTarget, *"%Iterator.prototype%"*)를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-iterator-constructor">
        <h1>Iterator 생성자의 프로퍼티 (Properties of the Iterator Constructor)</h1>
        <p>Iterator 생성자:</p>
        <ul>
          <li>[[Prototype]] 내부 슬롯 값이 %Function.prototype%이다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-iterator.from">
          <h1>Iterator.from ( _O_ )</h1>
          <emu-alg>
            1. _iteratorRecord_ 를 ? GetIteratorFlattenable(_O_, ~iterate-string-primitives~)로 둔다.
            1. _hasInstance_ 를 ? OrdinaryHasInstance(%Iterator%, _iteratorRecord_.[[Iterator]])로 둔다.
            1. _hasInstance_ 가 *true* 이면,
              1. _iteratorRecord_.[[Iterator]] 를 반환한다.
            1. _wrapper_ 를 OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] »)로 둔다.
            1. _wrapper_.[[Iterated]] 를 _iteratorRecord_ 로 설정한다.
            1. _wrapper_ 를 반환한다.
          </emu-alg>

          <emu-clause id="sec-%wrapforvaliditeratorprototype%-object">
            <h1>%WrapForValidIteratorPrototype% 객체 (The %WrapForValidIteratorPrototype% Object)</h1>
            <p><dfn>%WrapForValidIteratorPrototype%</dfn> 객체:</p>
            <ul>
              <li>일반 객체이다.</li>
              <li>[[Prototype]] 내부 슬롯 값이 %Iterator.prototype%이다.</li>
            </ul>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.next">
              <h1>%WrapForValidIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. _O_ 를 *this* 값으로 둔다.
                1. ? RequireInternalSlot(_O_, [[Iterated]])를 수행한다.
                1. _iteratorRecord_ 를 _O_.[[Iterated]] 로 둔다.
                1. ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]])를 반환한다.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.return">
              <h1>%WrapForValidIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. _O_ 를 *this* 값으로 둔다.
                1. ? RequireInternalSlot(_O_, [[Iterated]])를 수행한다.
                1. _iterator_ 를 _O_.[[Iterated]].[[Iterator]] 로 둔다.
                1. _iterator_ 가 Object 임을 단언한다.
                1. _returnMethod_ 를 ? GetMethod(_iterator_, *"return"*)로 둔다.
                1. _returnMethod_ 가 *undefined* 이면
                  1. CreateIteratorResultObject(*undefined*, *true*)를 반환한다.
                1. ? Call(_returnMethod_, _iterator_)를 반환한다.
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype">
          <h1>Iterator.prototype</h1>
          <p>Iterator.prototype의 초기 값은 Iterator 프로토타입 객체이다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-%iteratorprototype%-object" id="sec-%iterator.prototype%-object">
        <h1>Iterator 프로토타입 객체의 프로퍼티 (Properties of the Iterator Prototype Object)</h1>
        <p><dfn>Iterator 프로토타입 객체</dfn>:</p>
        <ul>
          <li><dfn>%Iterator.prototype%</dfn> 이다.</li>
          <li>[[Prototype]] 내부 슬롯 값이 %Object.prototype%이다.</li>
          <li>일반 객체이다.</li>
        </ul>
        <emu-note>
          <p>이 명세에서 iterator 인터페이스를 구현하는 모든 객체는 %Iterator.prototype%을 상속한다. ECMAScript 코드는 또한 %Iterator.prototype%을 상속하는 객체를 정의할 수 있다. %Iterator.prototype%은 모든 iterator 객체에 적용 가능한 추가 메서드를 추가할 수 있는 장소를 제공한다.</p>
          <p>다음 식은 ECMAScript 코드가 %Iterator.prototype% 객체에 접근할 수 있는 한 가지 방법이다:</p>
          <pre><code class="javascript">Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))</code></pre>
        </emu-note>

        <emu-clause id="sec-iterator.prototype.constructor">
          <h1>Iterator.prototype.constructor</h1>
          <p>`Iterator.prototype.constructor` 는 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진 접근자 프로퍼티이다. [[Get]] 과 [[Set]] 특성은 다음과 같이 정의된다:</p>

          <emu-clause id="sec-get-iterator.prototype.constructor">
            <h1>get Iterator.prototype.constructor</h1>
            <p>[[Get]] 특성의 값은 인수가 필요 없는 내장 함수이다. 호출 시 다음 단계를 수행한다:</p>
            <emu-alg>
              1. %Iterator% 를 반환한다.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-set-iterator.prototype.constructor">
            <h1>set Iterator.prototype.constructor</h1>
            <p>[[Set]] 특성의 값은 인수 _v_ 를 받는 내장 함수이다. 호출 시 다음 단계를 수행한다:</p>
            <emu-alg>
              1. ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, *"constructor"*, _v_)를 수행한다.
              1. *undefined* 를 반환한다.
            </emu-alg>
          </emu-clause>

          <emu-note>
            <p>대부분의 내장 프로토타입에 있는 *"constructor"* 프로퍼티와 달리, 웹 호환성 이유로 이 프로퍼티는 접근자여야 한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.drop">
          <h1>Iterator.prototype.drop ( _limit_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. _numLimit_ 를 Completion(ToNumber(_limit_))로 둔다.
            1. IfAbruptCloseIterator(_numLimit_, _iterated_).
            1. _numLimit_ 이 *NaN* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *RangeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _integerLimit_ 를 ! ToIntegerOrInfinity(_numLimit_)로 둔다.
            1. _integerLimit_ &lt; 0 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *RangeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _closure_ 를 _iterated_ 와 _integerLimit_ 를 포획(capture)하는 매개변수 없는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
              1. _remaining_ 을 _integerLimit_ 로 둔다.
              1. _remaining_ > 0 인 동안 반복,
                1. _remaining_ ≠ +∞ 이면,
                  1. _remaining_ 을 _remaining_ - 1 로 설정한다.
                1. _next_ 를 ? IteratorStep(_iterated_)로 둔다.
                1. _next_ 가 ~done~ 이면, ReturnCompletion(*undefined*)를 반환한다.
              1. 반복,
                1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
                1. _value_ 가 ~done~ 이면, ReturnCompletion(*undefined*)를 반환한다.
                1. _completion_ 을 Completion(Yield(_value_))로 둔다.
                1. IfAbruptCloseIterator(_completion_, _iterated_).
            1. _result_ 를 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)로 둔다.
            1. _result_.[[UnderlyingIterator]] 를 _iterated_ 로 설정한다.
            1. _result_ 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.every">
          <h1>Iterator.prototype.every ( _predicate_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_predicate_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _counter_ 를 0 으로 둔다.
            1. 반복,
              1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _value_ 가 ~done~ 이면 *true* 를 반환한다.
              1. _result_ 를 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
              1. IfAbruptCloseIterator(_result_, _iterated_).
              1. ToBoolean(_result_) 가 *false* 이면, ? IteratorClose(_iterated_, NormalCompletion(*false*))를 반환한다.
              1. _counter_ 를 _counter_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.filter">
          <h1>Iterator.prototype.filter ( _predicate_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_predicate_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _closure_ 를 _iterated_ 와 _predicate_ 를 포획하는 매개변수 없는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
              1. _counter_ 를 0 으로 둔다.
              1. 반복,
                1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
                1. _value_ 가 ~done~ 이면 ReturnCompletion(*undefined*)를 반환한다.
                1. _selected_ 를 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
                1. IfAbruptCloseIterator(_selected_, _iterated_).
                1. ToBoolean(_selected_) 가 *true* 이면,
                  1. _completion_ 을 Completion(Yield(_value_))로 둔다.
                  1. IfAbruptCloseIterator(_completion_, _iterated_).
                1. _counter_ 를 _counter_ + 1 로 설정한다.
            1. _result_ 를 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)로 둔다.
            1. _result_.[[UnderlyingIterator]] 를 _iterated_ 로 설정한다.
            1. _result_ 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.find">
          <h1>Iterator.prototype.find ( _predicate_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_predicate_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _counter_ 를 0 으로 둔다.
            1. 반복,
              1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _value_ 가 ~done~ 이면 *undefined* 를 반환한다.
              1. _result_ 를 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
              1. IfAbruptCloseIterator(_result_, _iterated_).
              1. ToBoolean(_result_) 가 *true* 이면, ? IteratorClose(_iterated_, NormalCompletion(_value_))를 반환한다.
              1. _counter_ 를 _counter_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.flatmap">
          <h1>Iterator.prototype.flatMap ( _mapper_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_mapper_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _closure_ 를 _iterated_ 와 _mapper_ 를 포획하는 매개변수 없는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
              1. _counter_ 를 0 으로 둔다.
              1. 반복,
                1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
                1. _value_ 가 ~done~ 이면 ReturnCompletion(*undefined*)를 반환한다.
                1. _mapped_ 를 Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
                1. IfAbruptCloseIterator(_mapped_, _iterated_).
                1. _innerIterator_ 를 Completion(GetIteratorFlattenable(_mapped_, ~reject-primitives~))로 둔다.
                1. IfAbruptCloseIterator(_innerIterator_, _iterated_).
                1. _innerAlive_ 를 *true* 로 둔다.
                1. _innerAlive_ 가 *true* 인 동안 반복,
                  1. _innerValue_ 를 Completion(IteratorStepValue(_innerIterator_))로 둔다.
                  1. IfAbruptCloseIterator(_innerValue_, _iterated_).
                  1. _innerValue_ 가 ~done~ 이면,
                    1. _innerAlive_ 를 *false* 로 설정한다.
                  1. 그렇지 않으면,
                    1. _completion_ 을 Completion(Yield(_innerValue_))로 둔다.
                    1. _completion_ 이 abrupt completion 이면,
                      1. _backupCompletion_ 을 Completion(IteratorClose(_innerIterator_, _completion_))로 둔다.
                      1. IfAbruptCloseIterator(_backupCompletion_, _iterated_).
                      1. ? IteratorClose(_iterated_, _completion_)를 반환한다.
                1. _counter_ 를 _counter_ + 1 로 설정한다.
            1. _result_ 를 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)로 둔다.
            1. _result_.[[UnderlyingIterator]] 를 _iterated_ 로 설정한다.
            1. _result_ 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.foreach">
          <h1>Iterator.prototype.forEach ( _procedure_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_procedure_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _counter_ 를 0 으로 둔다.
            1. 반복,
              1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _value_ 가 ~done~ 이면 *undefined* 를 반환한다.
              1. _result_ 를 Completion(Call(_procedure_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
              1. IfAbruptCloseIterator(_result_, _iterated_).
              1. _counter_ 를 _counter_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.map">
          <h1>Iterator.prototype.map ( _mapper_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_mapper_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _closure_ 를 _iterated_ 와 _mapper_ 를 포획하는 매개변수 없는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
              1. _counter_ 를 0 으로 둔다.
              1. 반복,
                1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
                1. _value_ 가 ~done~ 이면 ReturnCompletion(*undefined*)를 반환한다.
                1. _mapped_ 를 Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
                1. IfAbruptCloseIterator(_mapped_, _iterated_).
                1. _completion_ 을 Completion(Yield(_mapped_))로 둔다.
                1. IfAbruptCloseIterator(_completion_, _iterated_).
                1. _counter_ 를 _counter_ + 1 로 설정한다.
            1. _result_ 를 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)로 둔다.
            1. _result_.[[UnderlyingIterator]] 를 _iterated_ 로 설정한다.
            1. _result_ 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.reduce">
          <h1>Iterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_reducer_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _initialValue_ 가 존재하지 않으면,
              1. _accumulator_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _accumulator_ 가 ~done~ 이면 *TypeError* 예외를 던진다.
              1. _counter_ 를 1 로 둔다.
            1. 그렇지 않으면,
              1. _accumulator_ 를 _initialValue_ 로 둔다.
              1. _counter_ 를 0 으로 둔다.
            1. 반복,
              1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _value_ 가 ~done~ 이면 _accumulator_ 를 반환한다.
              1. _result_ 를 Completion(Call(_reducer_, *undefined*, « _accumulator_, _value_, 𝔽(_counter_) »))로 둔다.
              1. IfAbruptCloseIterator(_result_, _iterated_).
              1. _accumulator_ 를 _result_ 로 설정한다.
              1. _counter_ 를 _counter_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.some">
          <h1>Iterator.prototype.some ( _predicate_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. IsCallable(_predicate_) 가 *false* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _counter_ 를 0 으로 둔다.
            1. 반복,
              1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _value_ 가 ~done~ 이면 *false* 를 반환한다.
              1. _result_ 를 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))로 둔다.
              1. IfAbruptCloseIterator(_result_, _iterated_).
              1. ToBoolean(_result_) 가 *true* 이면, ? IteratorClose(_iterated_, NormalCompletion(*true*))를 반환한다.
              1. _counter_ 를 _counter_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.take">
          <h1>Iterator.prototype.take ( _limit_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* } 로 둔다.
            1. _numLimit_ 를 Completion(ToNumber(_limit_))로 둔다.
            1. IfAbruptCloseIterator(_numLimit_, _iterated_).
            1. _numLimit_ 이 *NaN* 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *RangeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _integerLimit_ 를 ! ToIntegerOrInfinity(_numLimit_)로 둔다.
            1. _integerLimit_ &lt; 0 이면,
              1. _error_ 를 ThrowCompletion(새로 생성된 *RangeError* 객체)로 둔다.
              1. ? IteratorClose(_iterated_, _error_)를 반환한다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 설정한다.
            1. _closure_ 를 _iterated_ 와 _integerLimit_ 를 포획하는 매개변수 없는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
              1. _remaining_ 을 _integerLimit_ 로 둔다.
              1. 반복,
                1. _remaining_ = 0 이면,
                  1. ? IteratorClose(_iterated_, ReturnCompletion(*undefined*))를 반환한다.
                1. _remaining_ ≠ +∞ 이면,
                  1. _remaining_ 을 _remaining_ - 1 로 설정한다.
                1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
                1. _value_ 가 ~done~ 이면 ReturnCompletion(*undefined*)를 반환한다.
                1. _completion_ 을 Completion(Yield(_value_))로 둔다.
                1. IfAbruptCloseIterator(_completion_, _iterated_).
            1. _result_ 를 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)로 둔다.
            1. _result_.[[UnderlyingIterator]] 를 _iterated_ 로 설정한다.
            1. _result_ 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype.toarray">
          <h1>Iterator.prototype.toArray ( )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _iterated_ 를 ? GetIteratorDirect(_O_)로 둔다.
            1. _items_ 를 새로운 빈 List 로 둔다.
            1. 반복,
              1. _value_ 를 ? IteratorStepValue(_iterated_)로 둔다.
              1. _value_ 가 ~done~ 이면 CreateArrayFromList(_items_)를 반환한다.
              1. _value_ 를 _items_ 에 추가한다.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%iteratorprototype%-@@iterator,sec-%iteratorprototype%-%symbol.iterator%" id="sec-iterator.prototype-%symbol.iterator%">
          <h1>Iterator.prototype [ %Symbol.iterator% ] ( )</h1>
          <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. *this* 값을 반환한다.
          </emu-alg>
          <p>이 함수의 *"name"* 프로퍼티 값은 *"[Symbol.iterator]"* 이다.</p>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype-%symbol.tostringtag%">
          <h1>Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>`Iterator.prototype[%Symbol.toStringTag%]` 는 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진 접근자 프로퍼티이다. [[Get]] 과 [[Set]] 특성은 다음과 같이 정의된다:</p>

          <emu-clause id="sec-get-iterator.prototype-%symbol.tostringtag%">
            <h1>get Iterator.prototype [ %Symbol.toStringTag% ]</h1>
            <p>[[Get]] 특성의 값은 인수가 필요 없는 내장 함수이다. 호출 시 다음 단계를 수행한다:</p>
            <emu-alg>
              1. *"Iterator"* 를 반환한다.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-set-iterator.prototype-%symbol.tostringtag%">
            <h1>set Iterator.prototype [ %Symbol.toStringTag% ]</h1>
            <p>[[Set]] 특성의 값은 인수 _v_ 를 받는 내장 함수이다. 호출 시 다음 단계를 수행한다:</p>
            <emu-alg>
              1. ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, %Symbol.toStringTag%, _v_)를 수행한다.
              1. *undefined* 를 반환한다.
            </emu-alg>
          </emu-clause>

          <emu-note>
            <p>대부분의 내장 프로토타입에 있는 %Symbol.toStringTag% 프로퍼티와 달리, 웹 호환성 이유로 이 프로퍼티는 접근자여야 한다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>%AsyncIteratorPrototype% 객체 (The %AsyncIteratorPrototype% Object)</h1>
      <p><dfn>%AsyncIteratorPrototype%</dfn> 객체:</p>
      <ul>
        <li>[[Prototype]] 내부 슬롯 값이 %Object.prototype%이다.</li>
        <li>일반 객체이다.</li>
      </ul>
      <emu-note>
        <p>이 명세에서 async iterator 인터페이스를 구현하는 모든 객체는 %AsyncIteratorPrototype%을 상속한다. ECMAScript 코드는 또한 %AsyncIteratorPrototype%을 상속하는 객체를 정의할 수 있다. %AsyncIteratorPrototype% 객체는 모든 async iterator 객체에 적용 가능한 추가 메서드를 추가할 수 있는 장소를 제공한다.</p>
      </emu-note>

      <emu-clause oldids="sec-asynciteratorprototype-asynciterator" id="sec-%asynciteratorprototype%-%symbol.asynciterator%">
        <h1>%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환한다.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"[Symbol.asyncIterator]"* 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-from-sync-iterator-objects">
      <h1>Sync 이터레이터 기반 Async 이터레이터 객체 (Async-from-Sync Iterator Objects)</h1>
      <p><dfn variants="Async-from-Sync Iterator objects">Async-from-Sync Iterator 객체</dfn>는 특정 동기(synchronous) 이터레이터를 적응(adapt)한 async 이터레이터이다. Async-from-Sync Iterator 객체는 ECMAScript 코드에서 직접 접근할 수 없다. Async-from-Sync Iterator 객체에 대한 명명된 생성자는 없다. 대신, 필요할 때 CreateAsyncFromSyncIterator 추상 연산에 의해 생성된다.</p>

      <emu-clause id="sec-createasyncfromsynciterator" type="abstract operation">
        <h1>
          CreateAsyncFromSyncIterator (
            _syncIteratorRecord_: an Iterator Record,
          ): an Iterator Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>동기 Iterator Record 로부터 async Iterator Record 를 생성하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _asyncIterator_ 를 OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »)로 둔다.
          1. _asyncIterator_.[[SyncIteratorRecord]] 를 _syncIteratorRecord_ 로 설정한다.
          1. _nextMethod_ 를 ! Get(_asyncIterator_, *"next"*)로 둔다.
          1. _iteratorRecord_ 를 Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* } 로 둔다.
          1. _iteratorRecord_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%asyncfromsynciteratorprototype%-object">
        <h1>%AsyncFromSyncIteratorPrototype% 객체 (The %AsyncFromSyncIteratorPrototype% Object)</h1>
        <p><dfn>%AsyncFromSyncIteratorPrototype%</dfn> 객체:</p>
        <ul>
          <li>모든 Async-from-Sync Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
          <li>일반 객체이다.</li>
          <li>[[Prototype]] 내부 슬롯 값이 %AsyncIteratorPrototype%이다.</li>
          <li>ECMAScript 코드에서 직접 접근할 수 없다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.next">
          <h1>%AsyncFromSyncIteratorPrototype%.next ( [ _value_ ] )</h1>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 [[SyncIteratorRecord]] 내부 슬롯을 가진 Object 임을 단언한다.
            1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%)로 둔다.
            1. _syncIteratorRecord_ 를 _O_.[[SyncIteratorRecord]] 로 둔다.
            1. _value_ 가 존재하면,
              1. _result_ 를 Completion(IteratorNext(_syncIteratorRecord_, _value_))로 둔다.
            1. 그렇지 않으면,
              1. _result_ 를 Completion(IteratorNext(_syncIteratorRecord_))로 둔다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.return">
          <h1>%AsyncFromSyncIteratorPrototype%.return ( [ _value_ ] )</h1>

          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 [[SyncIteratorRecord]] 내부 슬롯을 가진 Object 임을 단언한다.
            1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%)로 둔다.
            1. _syncIteratorRecord_ 를 _O_.[[SyncIteratorRecord]] 로 둔다.
            1. _syncIterator_ 를 _syncIteratorRecord_.[[Iterator]] 로 둔다.
            1. _return_ 을 Completion(GetMethod(_syncIterator_, *"return"* ))로 둔다.
            1. IfAbruptRejectPromise(_return_, _promiseCapability_).
            1. _return_ 이 *undefined* 이면,
              1. _iteratorResult_ 를 CreateIteratorResultObject(_value_, *true*)로 둔다.
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »)를 수행한다.
              1. _promiseCapability_.[[Promise]] 를 반환한다.
            1. _value_ 가 존재하면,
              1. _result_ 를 Completion(Call(_return_, _syncIterator_, « _value_ »))로 둔다.
            1. 그렇지 않으면,
              1. _result_ 를 Completion(Call(_return_, _syncIterator_))로 둔다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. _result_ 가 Object 가 아니면,
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 »)를 수행한다.
              1. _promiseCapability_.[[Promise]] 를 반환한다.
            1. AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *false*)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.throw">
          <h1>%AsyncFromSyncIteratorPrototype%.throw ( [ _value_ ] )</h1>
          <emu-note>이 명세에서 _value_ 는 항상 제공되지만, <emu-xref title href="#sec-%asyncfromsynciteratorprototype%.return"></emu-xref>과의 일관성을 위해 선택적으로 남겨 둔다.</emu-note>

          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. _O_ 가 [[SyncIteratorRecord]] 내부 슬롯을 가진 Object 임을 단언한다.
            1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%)로 둔다.
            1. _syncIteratorRecord_ 를 _O_.[[SyncIteratorRecord]] 로 둔다.
            1. _syncIterator_ 를 _syncIteratorRecord_.[[Iterator]] 로 둔다.
            1. _throw_ 를 Completion(GetMethod(_syncIterator_, *"throw"* ))로 둔다.
            1. IfAbruptRejectPromise(_throw_, _promiseCapability_).
            1. _throw_ 가 *undefined* 이면,
              1. 주: _syncIterator_ 에 `throw` 메서드가 없다면, capability 거부 전에 정리할 기회를 주기 위해 그것을 닫는다.
              1. _closeCompletion_ 을 NormalCompletion(~empty~)로 둔다.
              1. _result_ 를 Completion(IteratorClose(_syncIteratorRecord_, _closeCompletion_))로 둔다.
              1. IfAbruptRejectPromise(_result_, _promiseCapability_).
              1. 주: 다음 단계는 프로토콜 위반(_syncIterator_ 에 `throw` 메서드가 없음)을 나타내기 위해 *TypeError* 를 던진다.
              1. 주: _syncIterator_ 를 닫는 것이 throw 하지 않으면 그 연산 결과는, 거부된 promise 를 산출한다 해도, 무시된다.
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 »)를 수행한다.
              1. _promiseCapability_.[[Promise]] 를 반환한다.
            1. _value_ 가 존재하면,
              1. _result_ 를 Completion(Call(_throw_, _syncIterator_, « _value_ »))로 둔다.
            1. 그렇지 않으면,
              1. _result_ 를 Completion(Call(_throw_, _syncIterator_))로 둔다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. _result_ 가 Object 가 아니면,
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 »)를 수행한다.
              1. _promiseCapability_.[[Promise]] 를 반환한다.
            1. AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*)를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-async-from-sync-iterator-instances">
        <h1>Async-from-Sync Iterator 인스턴스의 프로퍼티 (Properties of Async-from-Sync Iterator Instances)</h1>
        <p>Async-from-Sync Iterator 인스턴스는 %AsyncFromSyncIteratorPrototype% 내재 객체를 상속하는 일반 객체이다. Async-from-Sync Iterator 인스턴스는 <emu-xref href="#table-async-from-sync-iterator-internal-slots"></emu-xref>에 열거된 내부 슬롯을 가지고 초기화된다.</p>
        <emu-table id="table-async-from-sync-iterator-internal-slots" caption="Async-from-Sync Iterator 인스턴스의 내부 슬롯 (Internal Slots of Async-from-Sync Iterator Instances)">
          <table>
            <thead>
              <tr>
                <th>
                  내부 슬롯 (Internal Slot)
                </th>
                <th>
                  타입 (Type)
                </th>
                <th>
                  설명 (Description)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[SyncIteratorRecord]]
              </td>
              <td>
                Iterator Record
              </td>
              <td>
                적응되고 있는 원래의 동기 이터레이터를 나타낸다.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncfromsynciteratorcontinuation" type="abstract operation" oldids="sec-async-from-sync-iterator-value-unwrap-functions">
        <h1>
          AsyncFromSyncIteratorContinuation (
            _result_: an Object,
            _promiseCapability_: a PromiseCapability Record for an intrinsic %Promise%,
            _syncIteratorRecord_: an Iterator Record,
            _closeOnRejection_: a Boolean,
          ): a Promise
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 주: _promiseCapability_ 가 내재 %Promise% 로부터 유도되었으므로, 이후 IfAbruptRejectPromise 사용이 수반하는 _promiseCapability_.[[Reject]] 호출은 throw 하지 않는 것이 보장된다.
          1. _done_ 을 Completion(IteratorComplete(_result_))로 둔다.
          1. IfAbruptRejectPromise(_done_, _promiseCapability_).
          1. _value_ 를 Completion(IteratorValue(_result_))로 둔다.
          1. IfAbruptRejectPromise(_value_, _promiseCapability_).
          1. _valueWrapper_ 를 Completion(PromiseResolve(%Promise%, _value_))로 둔다.
          1. _valueWrapper_ 가 abrupt completion 이고, _done_ 이 *false* 이며, _closeOnRejection_ 이 *true* 이면
            1. _valueWrapper_ 를 Completion(IteratorClose(_syncIteratorRecord_, _valueWrapper_))로 설정한다.
          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).
          1. _unwrap_ 을 매개변수 (_v_) 를 가지고 _done_ 을 포획하는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
            1. CreateIteratorResultObject(_v_, _done_)를 반환한다.
          1. _onFulfilled_ 를 CreateBuiltinFunction(_unwrap_, 1, *""*, « »)로 둔다.
          1. 주: _onFulfilled_ 는 IteratorResult 객체의 *"value"* 프로퍼티를 처리할 때 그 값이 promise 인 경우 이를 대기하고 새 "언랩된" IteratorResult 객체로 재포장하기 위해 사용된다.
          1. _done_ 이 *true* 이거나 _closeOnRejection_ 이 *false* 이면,
            1. _onRejected_ 를 *undefined* 로 둔다.
          1. 그렇지 않으면,
            1. _closeIterator_ 를 매개변수 (_error_) 를 가지고 _syncIteratorRecord_ 를 포획하는 새로운 Abstract Closure 로 두고, 호출 시 다음 단계를 수행하게 한다:
              1. ? IteratorClose(_syncIteratorRecord_, ThrowCompletion(_error_))를 반환한다.
            1. _onRejected_ 를 CreateBuiltinFunction(_closeIterator_, 1, *""*, « »)로 둔다.
            1. 주: _onRejected_ 는 IteratorResult 객체가 내놓는 *"value"* 프로퍼티가 거부된 promise 인 경우 이터레이터를 닫는 데 사용된다.
          1. PerformPromiseThen(_valueWrapper_, _onFulfilled_, _onRejected_, _promiseCapability_)를 수행한다.
          1. _promiseCapability_.[[Promise]] 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise Objects</h1>
    <p>Promise 는 지연(그리고 비동기일 수도 있는) 계산의 최종 결과에 대한 자리표시자로 사용되는 객체이다.</p>
    <p>모든 Promise 는 상호 배타적인 세 가지 상태 중 하나이다: <em>fulfilled</em>, <em>rejected</em>, <em>pending</em>:</p>
    <ul>
      <li>
        Promise `p` 는 `p.then(f, r)` 이 즉시 함수 `f` 를 호출하는 Job 을 큐잉(enqueue)하면 fulfilled 상태이다.
      </li>
      <li>
        Promise `p` 는 `p.then(f, r)` 이 즉시 함수 `r` 를 호출하는 Job 을 큐잉하면 rejected 상태이다.
      </li>
      <li>
        Promise 가 fulfilled 도 rejected 도 아니면 pending 상태이다.
      </li>
    </ul>
    <p>Promise 가 pending 이 아니면, 즉 fulfilled 이거나 rejected 이면 <em>settled</em> 되었다고 말한다.</p>
    <p>Promise 가 settled 이거나 다른 promise 의 상태에 “고정(lock in)” 되었으면 <em>resolved</em> 되었다고 한다. 이미 resolved 된 promise 를 resolve 또는 reject 하려는 시도는 아무 효과가 없다. Promise 가 resolved 가 아니면 <em>unresolved</em> 이다. Unresolved promise 는 항상 pending 상태이다. Resolved promise 는 pending, fulfilled 또는 rejected 일 수 있다.</p>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise 추상 연산 (Promise Abstract Operations)</h1>

      <emu-clause id="sec-promisecapability-records">
        <h1>PromiseCapability Records</h1>
        <p><dfn variants="PromiseCapability Records">PromiseCapability Record</dfn> 는 특정 Promise 또는 Promise 유사 객체와 그것을 resolve 또는 reject 할 수 있는 함수들을 함께 캡슐화하기 위해 사용되는 Record 값이다. PromiseCapability Record 는 NewPromiseCapability 추상 연산에 의해 생성된다.</p>
        <p>PromiseCapability Record 는 <emu-xref href="#table-promisecapability-record-fields"></emu-xref>에 열거된 필드를 가진다.</p>
        <emu-table id="table-promisecapability-record-fields" caption="PromiseCapability Record Fields (PromiseCapability 레코드 필드)" oldids="table-57">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Promise]]
              </td>
              <td>
                an Object
              </td>
              <td>
                Promise 로 사용할 수 있는 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[Resolve]]
              </td>
              <td>
                a function object
              </td>
              <td>
                해당 promise 를 resolve 하는 데 사용되는 함수.
              </td>
            </tr>
            <tr>
              <td>
                [[Reject]]
              </td>
              <td>
                a function object
              </td>
              <td>
                해당 promise 를 reject 하는 데 사용되는 함수.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
          <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
          <p>IfAbruptRejectPromise 는 PromiseCapability Record 를 사용하는 알고리즘 단계 시퀀스의 축약 표현이다. 다음과 같은 알고리즘 단계:</p>
          <emu-alg>
            1. IfAbruptRejectPromise(_value_, _capability_).
          </emu-alg>
          <p>는 다음과 동일한 의미이다:</p>
          <emu-alg>
            1. Assert: _value_ 는 Completion Record 이다.
            1. _value_ 가 abrupt completion 이면,
              1. ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »)를 수행한다.
              1. _capability_.[[Promise]] 를 반환한다.
            1. 그렇지 않으면,
              1. _value_ 를 ! _value_ 로 설정한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction Records</h1>
        <p><dfn variants="PromiseReaction Records">PromiseReaction Record</dfn> 는 promise 가 특정 값으로 resolved 또는 rejected 될 때 어떻게 반응해야 하는지를 저장하기 위한 Record 값이다. PromiseReaction Record 는 PerformPromiseThen 추상 연산에 의해 생성되며, NewPromiseReactionJob 이 반환하는 Abstract Closure 에 의해 사용된다.</p>
        <p>PromiseReaction Record 는 <emu-xref href="#table-promisereaction-record-fields"></emu-xref>에 열거된 필드를 가진다.</p>
        <emu-table id="table-promisereaction-record-fields" caption="PromiseReaction Record Fields (PromiseReaction 레코드 필드)" oldids="table-58">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                a PromiseCapability Record or *undefined*
              </td>
              <td>
                이 레코드가 반응 핸들러를 제공하는 promise 의 capability.
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                ~fulfill~ or ~reject~
              </td>
              <td>
                [[Handler]] 가 ~empty~ 일 때 처리 유형별 동작을 허용하기 위해 사용된다.
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                a JobCallback Record or ~empty~
              </td>
              <td>
                들어오는 값에 적용되어 그 반환 값이 파생된 promise 에서 일어날 일을 결정하는 함수. [[Handler]] 가 ~empty~ 이면 [[Type]] 값에 따라 결정되는 함수가 대신 사용된다.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-createresolvingfunctions" type="abstract operation">
        <h1>
          CreateResolvingFunctions (
            _promise_: a Promise,
          ): a Record with fields [[Resolve]] (a function object) and [[Reject]] (a function object)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _alreadyResolved_ 를 Record { [[Value]]: *false* } 로 둔다.
          1. _stepsResolve_ 를 <emu-xref href="#sec-promise-resolve-functions" title></emu-xref> 에 정의된 알고리즘 단계로 둔다.
          1. _lengthResolve_ 를 <emu-xref href="#sec-promise-resolve-functions" title></emu-xref> 에 있는 함수 정의의 선택적이 아닌 매개변수 개수로 둔다.
          1. _resolve_ 를 CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *""*, « [[Promise]], [[AlreadyResolved]] ») 로 둔다.
          1. _resolve_.[[Promise]] 를 _promise_ 로 설정한다.
          1. _resolve_.[[AlreadyResolved]] 를 _alreadyResolved_ 로 설정한다.
          1. _stepsReject_ 을 <emu-xref href="#sec-promise-reject-functions" title></emu-xref> 에 정의된 알고리즘 단계로 둔다.
          1. _lengthReject_ 를 <emu-xref href="#sec-promise-reject-functions" title></emu-xref> 에 있는 함수 정의의 선택적이 아닌 매개변수 개수로 둔다.
          1. _reject_ 를 CreateBuiltinFunction(_stepsReject_, _lengthReject_, *""*, « [[Promise]], [[AlreadyResolved]] ») 로 둔다.
          1. _reject_.[[Promise]] 를 _promise_ 로 설정한다.
          1. _reject_.[[AlreadyResolved]] 를 _alreadyResolved_ 로 설정한다.
          1. Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ } 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-promise-reject-functions">
          <h1>Promise Reject Functions</h1>
          <p>Promise reject 함수는 [[Promise]] 와 [[AlreadyResolved]] 내부 슬롯을 가진 익명 내장 함수이다.</p>
          <p>Promise reject 함수가 인수 _reason_ 과 함께 호출되면 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _F_ 를 활성 함수 객체로 둔다.
            1. Assert: _F_ 는 값이 Object 인 [[Promise]] 내부 슬롯을 가진다.
            1. _promise_ 를 _F_.[[Promise]] 로 둔다.
            1. _alreadyResolved_ 를 _F_.[[AlreadyResolved]] 로 둔다.
            1. _alreadyResolved_.[[Value]] 가 *true* 이면 *undefined* 를 반환한다.
            1. _alreadyResolved_.[[Value]] 를 *true* 로 설정한다.
            1. RejectPromise(_promise_, _reason_) 를 수행한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
          <p>Promise reject 함수의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        </emu-clause>

        <emu-clause id="sec-promise-resolve-functions">
          <h1>Promise Resolve Functions</h1>
          <p>Promise resolve 함수는 [[Promise]] 와 [[AlreadyResolved]] 내부 슬롯을 가진 익명 내장 함수이다.</p>
          <p>Promise resolve 함수가 인수 _resolution_ 과 함께 호출되면 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _F_ 를 활성 함수 객체로 둔다.
            1. Assert: _F_ 는 값이 Object 인 [[Promise]] 내부 슬롯을 가진다.
            1. _promise_ 를 _F_.[[Promise]] 로 둔다.
            1. _alreadyResolved_ 를 _F_.[[AlreadyResolved]] 로 둔다.
            1. _alreadyResolved_.[[Value]] 가 *true* 이면 *undefined* 를 반환한다.
            1. _alreadyResolved_.[[Value]] 를 *true* 로 설정한다.
            1. SameValue(_resolution_, _promise_) 가 *true* 이면,
              1. _selfResolutionError_ 를 새로 생성된 *TypeError* 객체로 둔다.
              1. RejectPromise(_promise_, _selfResolutionError_) 를 수행한다.
              1. *undefined* 를 반환한다.
            1. _resolution_ 이 Object 가 아니면,
              1. FulfillPromise(_promise_, _resolution_) 를 수행한다.
              1. *undefined* 를 반환한다.
            1. _then_ 을 Completion(Get(_resolution_, *"then"* )) 로 둔다.
            1. _then_ 이 abrupt completion 이면,
              1. RejectPromise(_promise_, _then_.[[Value]]) 를 수행한다.
              1. *undefined* 를 반환한다.
            1. _thenAction_ 을 _then_.[[Value]] 로 둔다.
            1. IsCallable(_thenAction_) 이 *false* 이면,
              1. FulfillPromise(_promise_, _resolution_) 를 수행한다.
              1. *undefined* 를 반환한다.
            1. _thenJobCallback_ 을 HostMakeJobCallback(_thenAction_) 로 둔다.
            1. _job_ 을 NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_) 로 둔다.
            1. HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]) 를 수행한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
          <p>Promise resolve 함수의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-fulfillpromise" type="abstract operation">
        <h1>
          FulfillPromise (
            _promise_: a Promise,
            _value_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promise_.[[PromiseState]] 는 ~pending~ 이다.
          1. _reactions_ 를 _promise_.[[PromiseFulfillReactions]] 로 둔다.
          1. _promise_.[[PromiseResult]] 를 _value_ 로 설정한다.
          1. _promise_.[[PromiseFulfillReactions]] 를 *undefined* 로 설정한다.
          1. _promise_.[[PromiseRejectReactions]] 를 *undefined* 로 설정한다.
          1. _promise_.[[PromiseState]] 를 ~fulfilled~ 로 설정한다.
          1. TriggerPromiseReactions(_reactions_, _value_) 를 수행한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromisecapability" type="abstract operation" oldids="sec-getcapabilitiesexecutor-functions">
        <h1>
          NewPromiseCapability (
            _C_: an ECMAScript language value,
          ): either a normal completion containing a PromiseCapability Record or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>내장 Promise 생성자 방식으로 _C_ 를 생성자로 사용하여 promise 를 만들고 그 `resolve`, `reject` 함수를 추출하려 시도한다. 그 promise 와 두 함수는 새로운 PromiseCapability Record 를 초기화하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. IsConstructor(_C_) 가 *false* 이면 *TypeError* 예외를 던진다.
          1. 주: _C_ 는 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수라고 가정한다 (<emu-xref href="#sec-promise-executor"></emu-xref> 참조).
          1. _resolvingFunctions_ 를 Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* } 로 둔다.
          1. _executorClosure_ 를 매개변수 (_resolve_, _reject_) 를 가지고 _resolvingFunctions_ 를 포획하며 호출 시 다음을 수행하는 새로운 Abstract Closure 로 둔다:
            1. _resolvingFunctions_.[[Resolve]] 가 *undefined* 가 아니면 *TypeError* 예외를 던진다.
            1. _resolvingFunctions_.[[Reject]] 가 *undefined* 가 아니면 *TypeError* 예외를 던진다.
            1. _resolvingFunctions_.[[Resolve]] 를 _resolve_ 로 설정한다.
            1. _resolvingFunctions_.[[Reject]] 를 _reject_ 로 설정한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _executor_ 를 CreateBuiltinFunction(_executorClosure_, 2, *""*, « ») 로 둔다.
          1. _promise_ 를 ? Construct(_C_, « _executor_ ») 로 둔다.
          1. IsCallable(_resolvingFunctions_.[[Resolve]]) 가 *false* 이면 *TypeError* 예외를 던진다.
          1. IsCallable(_resolvingFunctions_.[[Reject]]) 가 *false* 이면 *TypeError* 예외를 던진다.
          1. PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] } 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 추상 연산은 전달된 executor 함수 인수를 Promise 생성자와 동일한 방식으로 호출하는 어떤 생성자에도 일반화되어 Promise 서브클래싱을 지원한다. 이는 Promise 생성자의 정적 메서드들을 임의의 서브클래스로 일반화하는 데 사용된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-ispromise" type="abstract operation">
        <h1>
          IsPromise (
            _x_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>객체에 promise 브랜드가 있는지 검사한다.</dd>
        </dl>
        <emu-alg>
          1. _x_ 가 Object 가 아니면 *false* 를 반환한다.
          1. _x_ 에 [[PromiseState]] 내부 슬롯이 없으면 *false* 를 반환한다.
          1. *true* 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rejectpromise" type="abstract operation">
        <h1>
          RejectPromise (
            _promise_: a Promise,
            _reason_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promise_.[[PromiseState]] 는 ~pending~ 이다.
            1. _reactions_ 를 _promise_.[[PromiseRejectReactions]] 로 둔다.
            1. _promise_.[[PromiseResult]] 를 _reason_ 으로 설정한다.
            1. _promise_.[[PromiseFulfillReactions]] 를 *undefined* 로 설정한다.
            1. _promise_.[[PromiseRejectReactions]] 를 *undefined* 로 설정한다.
            1. _promise_.[[PromiseState]] 를 ~rejected~ 로 설정한다.
            1. _promise_.[[PromiseIsHandled]] 가 *false* 이면 HostPromiseRejectionTracker(_promise_, *"reject"*) 를 수행한다.
            1. TriggerPromiseReactions(_reactions_, _reason_) 를 수행한다.
            1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-triggerpromisereactions" type="abstract operation">
        <h1>
          TriggerPromiseReactions (
            _reactions_: a List of PromiseReaction Records,
            _argument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_reactions_ 의 각 레코드에 대해 새로운 Job 을 큐잉한다. 각 Job 은 PromiseReaction Record 의 [[Type]] 과 [[Handler]] 를 처리하며, [[Handler]] 가 ~empty~ 가 아니면 주어진 인수를 전달하여 호출한다. [[Handler]] 가 ~empty~ 이면 동작은 [[Type]] 에 의해 결정된다.</dd>
        </dl>
        <emu-alg>
          1. _reactions_ 의 각 요소 _reaction_ 에 대해,
            1. _job_ 을 NewPromiseReactionJob(_reaction_, _argument_) 로 둔다.
            1. HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]) 를 수행한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" type="host-defined abstract operation">
        <h1>
          HostPromiseRejectionTracker (
            _promise_: a Promise,
            _operation_: *"reject"* or *"handle"*,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>호스트 환경이 promise rejection 을 추적할 수 있도록 한다.</dd>
        </dl>
        <p>HostPromiseRejectionTracker 의 기본 구현은 ~unused~ 를 반환하는 것이다.</p>

        <emu-note>
          <p>HostPromiseRejectionTracker 는 두 시나리오에서 호출된다:</p>

          <ul>
            <li>Promise 가 핸들러 없이 reject 될 때 _operation_ 인수가 *"reject"* 로 호출된다.</li>
            <li>처음으로 핸들러가 reject 된 promise 에 추가될 때 _operation_ 인수가 *"handle"* 로 호출된다.</li>
          </ul>

          <p>전형적인 구현은 처리되지 않은 rejection 을 개발자에게 알리려고 시도하며, 이후 새로운 핸들러가 부착되어 이전 알림이 무효화되는 경우도 알리도록 주의할 수 있다.</p>
        </emu-note>

        <emu-note>
          <p>_operation_ 이 *"handle"* 이면 구현은 가비지 컬렉션을 방해하는 방식으로 _promise_ 에 대한 참조를 보유하지 않아야 한다. _operation_ 이 *"reject"* 이면, rejection 은 드물고 핫 코드 경로가 아닐 것으로 예상되므로 _promise_ 에 대한 참조를 보유할 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise 작업 (Promise Jobs)</h1>

      <emu-clause id="sec-newpromisereactionjob" type="abstract operation" oldids="sec-promisereactionjob">
        <h1>
          NewPromiseReactionJob (
            _reaction_: a PromiseReaction Record,
            _argument_: an ECMAScript language value,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record or *null*)
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>들어오는 값에 적절한 핸들러를 적용하고, 그 핸들러의 반환 값을 사용하여 그 핸들러와 연관된 파생 promise 를 resolve 또는 reject 하는 새로운 Job 추상 클로저를 반환한다.</dd>
        </dl>
        <emu-alg>
          1. _job_ 을 매개변수 없고 _reaction_ 및 _argument_ 를 포획(capture)하며 호출 시 다음 단계를 수행하는 새로운 Job 추상 클로저로 둔다:
            1. _promiseCapability_ 를 _reaction_.[[Capability]] 로 둔다.
            1. _type_ 을 _reaction_.[[Type]] 로 둔다.
            1. _handler_ 를 _reaction_.[[Handler]] 로 둔다.
            1. _handler_ 가 ~empty~ 이면,
              1. _type_ 이 ~fulfill~ 이면
                1. _handlerResult_ 를 NormalCompletion(_argument_) 로 둔다.
              1. 그렇지 않으면,
                1. Assert: _type_ 은 ~reject~.
                1. _handlerResult_ 를 ThrowCompletion(_argument_) 로 둔다.
            1. 그렇지 않으면,
              1. _handlerResult_ 를 Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)) 로 둔다.
            1. _promiseCapability_ 가 *undefined* 이면,
              1. Assert: _handlerResult_ 는 abrupt completion 이 아님.
              1. ~empty~ 를 반환한다.
            1. Assert: _promiseCapability_ 는 PromiseCapability Record.
            1. _handlerResult_ 가 abrupt completion 이면,
              1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] ») 를 반환한다.
            1. 그렇지 않으면,
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] ») 를 반환한다.
          1. _handlerRealm_ 을 *null* 로 둔다.
          1. _reaction_.[[Handler]] 가 ~empty~ 가 아니면,
            1. _getHandlerRealmResult_ 를 Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])) 로 둔다.
            1. _getHandlerRealmResult_ 가 normal completion 이면 _handlerRealm_ 을 _getHandlerRealmResult_.[[Value]] 로 설정한다.
            1. 그렇지 않으면 _handlerRealm_ 을 현재 Realm Record 로 설정한다.
            1. 주: _handlerRealm_ 은 핸들러가 *undefined* 인 경우를 제외하고 *null* 이 아니다. 핸들러가 취소된 Proxy 이고 어떤 ECMAScript 코드도 실행되지 않을 때 _handlerRealm_ 은 에러 객체를 생성하는 데 사용된다.
          1. Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ } 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromiseresolvethenablejob" type="abstract operation" oldids="sec-promiseresolvethenablejob">
        <h1>
          NewPromiseResolveThenableJob (
            _promiseToResolve_: a Promise,
            _thenable_: an Object,
            _then_: a JobCallback Record,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _job_ 을 매개변수 없고 _promiseToResolve_, _thenable_, _then_ 을 포획하며 호출 시 다음 단계를 수행하는 새로운 Job 추상 클로저로 둔다:
            1. _resolvingFunctions_ 를 CreateResolvingFunctions(_promiseToResolve_) 로 둔다.
            1. _thenCallResult_ 를 Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)) 로 둔다.
            1. _thenCallResult_ 가 abrupt completion 이면,
              1. ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] ») 를 반환한다.
            1. ! _thenCallResult_ 를 반환한다.
          1. _getThenRealmResult_ 를 Completion(GetFunctionRealm(_then_.[[Callback]])) 로 둔다.
          1. _getThenRealmResult_ 가 normal completion 이면 _thenRealm_ 을 _getThenRealmResult_.[[Value]] 로 둔다.
          1. 그렇지 않으면 _thenRealm_ 을 현재 Realm Record 로 둔다.
          1. 주: _thenRealm_ 은 *null* 이 아니다. _then_.[[Callback]] 이 취소된 Proxy 이고 어떤 코드도 실행되지 않을 때 _thenRealm_ 은 에러 객체 생성을 위해 사용된다.
          1. Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ } 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 Job 은 제공된 thenable 과 그 `then` 메서드를 사용하여 주어진 promise 를 resolve 한다. 이 과정은 `then` 메서드의 평가가 주변 코드의 평가가 끝난 후에 일어나도록 Job 으로 수행되어야 한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-constructor">
      <h1>Promise 생성자 (The Promise Constructor)</h1>
      <p>Promise 생성자:</p>
      <ul>
        <li><dfn>%Promise%</dfn> 이다.</li>
        <li>전역 객체의 *"Promise"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 Promise 를 생성하고 초기화한다.</li>
        <li>함수로 호출하는 것은 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용될 수 있다. 지정된 Promise 동작을 상속하려는 서브클래스 생성자는 `Promise` 및 `Promise.prototype` 내장 메서드를 지원하는 데 필요한 내부 상태로 서브클래스 인스턴스를 생성 및 초기화하기 위해 Promise 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-promise-executor">
        <h1>Promise ( _executor_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외를 던진다.
          1. IsCallable(_executor_) 가 *false* 이면 *TypeError* 예외를 던진다.
          1. _promise_ 를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Promise.prototype%"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] ») 로 둔다.
          1. _promise_.[[PromiseState]] 를 ~pending~ 으로 설정한다.
          1. _promise_.[[PromiseResult]] 를 ~empty~ 로 설정한다.
          1. _promise_.[[PromiseFulfillReactions]] 를 새로운 빈 List 로 설정한다.
          1. _promise_.[[PromiseRejectReactions]] 를 새로운 빈 List 로 설정한다.
          1. _promise_.[[PromiseIsHandled]] 를 *false* 로 설정한다.
          1. _resolvingFunctions_ 를 CreateResolvingFunctions(_promise_) 로 둔다.
          1. _completion_ 을 Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)) 로 둔다.
          1. _completion_ 이 abrupt completion 이면,
            1. ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] ») 를 수행한다.
          1. _promise_ 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_executor_ 인수는 함수 객체여야 한다. 이는 이 Promise 가 표현하는 (지연될 수 있는) 동작을 시작하고 완료를 보고하기 위해 호출된다. Executor 는 두 인수: _resolve_ 와 _reject_ 로 호출된다. 이들은 지연 계산의 최종 완료 또는 실패를 보고하기 위해 _executor_ 함수에서 사용할 수 있는 함수이다. Executor 함수에서 반환하는 것은 지연 동작이 완료되었음을 의미하지 않고 단지 나중에 그 지연 동작을 수행하라는 요청이 수락되었음을 의미한다.</p>
          <p>_executor_ 에 전달되는 _resolve_ 함수는 단일 인수를 받는다. _executor_ 코드는 결국 _resolve_ 함수를 호출해 관련 Promise 를 resolve 하려 함을 나타낼 수 있다. _resolve_ 함수에 전달되는 인수는 지연 동작의 최종 값을 나타내며 실제 이행 값이거나 그것이 이행될 경우 값을 제공할 다른 promise 일 수 있다.</p>
          <p>_executor_ 에 전달되는 _reject_ 함수는 단일 인수를 받는다. _executor_ 코드는 결국 _reject_ 함수를 호출해 관련 Promise 가 rejected 되었고 결코 fulfilled 되지 않을 것임을 나타낼 수 있다. _reject_ 함수에 전달되는 인수는 promise 의 rejection 값으로 사용되며 일반적으로 Error 객체이다.</p>
          <p>Promise 생성자가 _executor_ 함수에 전달하는 resolve 및 reject 함수는 실제로 해당 promise 를 resolve 및 reject 할 수 있는 능력을 가진다. 서브클래스는 resolve 와 reject 에 대해 사용자 정의 값을 전달하는 다른 생성자 동작을 가질 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Promise 생성자의 프로퍼티 (Properties of the Promise Constructor)</h1>
      <p>Promise 생성자:</p>
      <ul>
        <li>[[Prototype]] 내부 슬롯 값이 %Function.prototype% 이다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-promise.all">
        <h1>Promise.all ( _iterable_ )</h1>
        <p>이 함수는 전달된 promise 들의 이행 값 배열로 이행되는 새로운 promise 를 반환하거나, 가장 먼저 reject 된 promise 의 reason 으로 reject 된다. 이 알고리즘을 수행하면서 전달된 iterable 의 모든 요소를 promise 로 resolve 한다.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. _promiseResolve_ 를 Completion(GetPromiseResolve(_C_)) 로 둔다.
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. _iteratorRecord_ 를 Completion(GetIterator(_iterable_, ~sync~)) 로 둔다.
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. _result_ 를 Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) 로 둔다.
          1. _result_ 가 abrupt completion 이면,
            1. _iteratorRecord_.[[Done]] 가 *false* 이면 _result_ 를 Completion(IteratorClose(_iteratorRecord_, _result_)) 로 설정한다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. ! _result_ 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 *this* 값이 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수이기를 요구한다.</p>
        </emu-note>

        <emu-clause id="sec-getpromiseresolve" type="abstract operation">
          <h1>
            GetPromiseResolve (
              _promiseConstructor_: a constructor,
            ): either a normal completion containing a function object or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _promiseResolve_ 를 ? Get(_promiseConstructor_, *"resolve"*) 로 둔다.
            1. IsCallable(_promiseResolve_) 가 *false* 이면 *TypeError* 예외를 던진다.
            1. _promiseResolve_ 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-performpromiseall" type="abstract operation">
          <h1>
            PerformPromiseAll (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _values_ 를 새로운 빈 List 로 둔다.
            1. _remainingElementsCount_ 를 Record { [[Value]]: 1 } 로 둔다.
            1. _index_ 를 0 으로 둔다.
            1. 반복,
              1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
              1. _next_ 가 ~done~ 이면,
                1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
                1. _remainingElementsCount_.[[Value]] = 0 이면,
                  1. _valuesArray_ 를 CreateArrayFromList(_values_) 로 둔다.
                  1. ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») 를 수행한다.
                1. _resultCapability_.[[Promise]] 를 반환한다.
              1. *undefined* 를 _values_ 에 추가한다.
              1. _nextPromise_ 를 ? Call(_promiseResolve_, _constructor_, « _next_ ») 로 둔다.
              1. _steps_ 를 <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref> 에 정의된 알고리즘 단계로 둔다.
              1. _length_ 를 <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref> 에 있는 함수 정의의 선택적이 아닌 매개변수 개수로 둔다.
              1. _onFulfilled_ 를 CreateBuiltinFunction(_steps_, _length_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] ») 로 둔다.
              1. _onFulfilled_.[[AlreadyCalled]] 를 *false* 로 설정한다.
              1. _onFulfilled_.[[Index]] 를 _index_ 로 설정한다.
              1. _onFulfilled_.[[Values]] 를 _values_ 로 설정한다.
              1. _onFulfilled_.[[Capability]] 를 _resultCapability_ 로 설정한다.
              1. _onFulfilled_.[[RemainingElements]] 를 _remainingElementsCount_ 로 설정한다.
              1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] + 1 로 설정한다.
              1. ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _resultCapability_.[[Reject]] ») 를 수행한다.
              1. _index_ 를 _index_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.all-resolve-element-functions">
          <h1>`Promise.all` Resolve Element Functions</h1>
          <p>`Promise.all` resolve 요소 함수는 특정 `Promise.all` 요소를 resolve 하는 데 사용되는 익명 내장 함수이다. 각 `Promise.all` resolve 요소 함수는 [[Index]], [[Values]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 내부 슬롯을 가진다.</p>
          <p>`Promise.all` resolve 요소 함수가 인수 _x_ 와 함께 호출되면 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _F_ 를 활성 함수 객체로 둔다.
            1. _F_.[[AlreadyCalled]] 가 *true* 이면 *undefined* 를 반환한다.
            1. _F_.[[AlreadyCalled]] 를 *true* 로 설정한다.
            1. _index_ 를 _F_.[[Index]] 로 둔다.
            1. _values_ 를 _F_.[[Values]] 로 둔다.
            1. _promiseCapability_ 를 _F_.[[Capability]] 로 둔다.
            1. _remainingElementsCount_ 를 _F_.[[RemainingElements]] 로 둔다.
            1. _values_[_index_] 를 _x_ 로 설정한다.
            1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
            1. _remainingElementsCount_.[[Value]] = 0 이면,
              1. _valuesArray_ 를 CreateArrayFromList(_values_) 로 둔다.
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») 를 반환한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
          <p>`Promise.all` resolve 요소 함수의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.allsettled">
        <h1>Promise.allSettled ( _iterable_ )</h1>
        <p>이 함수는 모든 원래 promise 가 settled(즉 fulfilled 또는 rejected) 된 후에, promise 상태 스냅샷 객체들의 배열로 이행되는 promise 를 반환한다. 이 알고리즘을 수행하면서 전달된 iterable 의 모든 요소를 promise 로 resolve 한다.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. _promiseResolve_ 를 Completion(GetPromiseResolve(_C_)) 로 둔다.
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. _iteratorRecord_ 를 Completion(GetIterator(_iterable_, ~sync~)) 로 둔다.
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. _result_ 를 Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) 로 둔다.
          1. _result_ 가 abrupt completion 이면,
            1. _iteratorRecord_.[[Done]] 가 *false* 이면 _result_ 를 Completion(IteratorClose(_iteratorRecord_, _result_)) 로 설정한다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. ! _result_ 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 *this* 값이 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수이기를 요구한다.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseallsettled" type="abstract operation">
          <h1>
            PerformPromiseAllSettled (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _values_ 를 새로운 빈 List 로 둔다.
            1. _remainingElementsCount_ 를 Record { [[Value]]: 1 } 로 둔다.
            1. _index_ 를 0 으로 둔다.
            1. 반복,
              1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
              1. _next_ 가 ~done~ 이면,
                1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
                1. _remainingElementsCount_.[[Value]] = 0 이면,
                  1. _valuesArray_ 를 CreateArrayFromList(_values_) 로 둔다.
                  1. ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») 를 수행한다.
                1. _resultCapability_.[[Promise]] 를 반환한다.
              1. *undefined* 를 _values_ 에 추가한다.
              1. _nextPromise_ 를 ? Call(_promiseResolve_, _constructor_, « _next_ ») 로 둔다.
              1. _stepsFulfilled_ 를 <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref> 에 정의된 알고리즘 단계로 둔다.
              1. _lengthFulfilled_ 를 <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref> 에 있는 함수 정의의 선택적이 아닌 매개변수 개수로 둔다.
              1. _onFulfilled_ 를 CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] ») 로 둔다.
              1. _alreadyCalled_ 를 Record { [[Value]]: *false* } 로 둔다.
              1. _onFulfilled_.[[AlreadyCalled]] 를 _alreadyCalled_ 로 설정한다.
              1. _onFulfilled_.[[Index]] 를 _index_ 로 설정한다.
              1. _onFulfilled_.[[Values]] 를 _values_ 로 설정한다.
              1. _onFulfilled_.[[Capability]] 를 _resultCapability_ 로 설정한다.
              1. _onFulfilled_.[[RemainingElements]] 를 _remainingElementsCount_ 로 설정한다.
              1. _stepsRejected_ 를 <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref> 에 정의된 알고리즘 단계로 둔다.
              1. _lengthRejected_ 를 <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref> 에 있는 함수 정의의 선택적이 아닌 매개변수 개수로 둔다.
              1. _onRejected_ 를 CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] ») 로 둔다.
              1. _onRejected_.[[AlreadyCalled]] 를 _alreadyCalled_ 로 설정한다.
              1. _onRejected_.[[Index]] 를 _index_ 로 설정한다.
              1. _onRejected_.[[Values]] 를 _values_ 로 설정한다.
              1. _onRejected_.[[Capability]] 를 _resultCapability_ 로 설정한다.
              1. _onRejected_.[[RemainingElements]] 를 _remainingElementsCount_ 로 설정한다.
              1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] + 1 로 설정한다.
              1. ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _onRejected_ ») 를 수행한다.
              1. _index_ 를 _index_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-resolve-element-functions">
          <h1>`Promise.allSettled` Resolve Element Functions</h1>
          <p>`Promise.allSettled` resolve 요소 함수는 특정 `Promise.allSettled` 요소를 resolve 하는 데 사용되는 익명 내장 함수이다. 각 함수는 [[Index]], [[Values]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 내부 슬롯을 가진다.</p>
          <p>`Promise.allSettled` resolve 요소 함수가 인수 _x_ 로 호출되면 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _F_ 를 활성 함수 객체로 둔다.
            1. _alreadyCalled_ 를 _F_.[[AlreadyCalled]] 로 둔다.
            1. _alreadyCalled_.[[Value]] 가 *true* 이면 *undefined* 를 반환한다.
            1. _alreadyCalled_.[[Value]] 를 *true* 로 설정한다.
            1. _index_ 를 _F_.[[Index]] 로 둔다.
            1. _values_ 를 _F_.[[Values]] 로 둔다.
            1. _promiseCapability_ 를 _F_.[[Capability]] 로 둔다.
            1. _remainingElementsCount_ 를 _F_.[[RemainingElements]] 로 둔다.
            1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"fulfilled"*) 를 수행한다.
            1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _x_) 를 수행한다.
            1. _values_[_index_] 를 _obj_ 로 설정한다.
            1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
            1. _remainingElementsCount_.[[Value]] = 0 이면,
              1. _valuesArray_ 를 CreateArrayFromList(_values_) 로 둔다.
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») 를 반환한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
          <p>`Promise.allSettled` resolve 요소 함수의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-reject-element-functions">
          <h1>`Promise.allSettled` Reject Element Functions</h1>
          <p>`Promise.allSettled` reject 요소 함수는 특정 `Promise.allSettled` 요소를 reject 하는 데 사용되는 익명 내장 함수이다. 각 함수는 [[Index]], [[Values]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 내부 슬롯을 가진다.</p>
          <p>`Promise.allSettled` reject 요소 함수가 인수 _x_ 로 호출되면 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _F_ 를 활성 함수 객체로 둔다.
            1. _alreadyCalled_ 를 _F_.[[AlreadyCalled]] 로 둔다.
            1. _alreadyCalled_.[[Value]] 가 *true* 이면 *undefined* 를 반환한다.
            1. _alreadyCalled_.[[Value]] 를 *true* 로 설정한다.
            1. _index_ 를 _F_.[[Index]] 로 둔다.
            1. _values_ 를 _F_.[[Values]] 로 둔다.
            1. _promiseCapability_ 를 _F_.[[Capability]] 로 둔다.
            1. _remainingElementsCount_ 를 _F_.[[RemainingElements]] 로 둔다.
            1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"rejected"*) 를 수행한다.
            1. ! CreateDataPropertyOrThrow(_obj_, *"reason"*, _x_) 를 수행한다.
            1. _values_[_index_] 를 _obj_ 로 설정한다.
            1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
            1. _remainingElementsCount_.[[Value]] = 0 이면,
              1. _valuesArray_ 를 CreateArrayFromList(_values_) 로 둔다.
              1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ ») 를 반환한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
          <p>`Promise.allSettled` reject 요소 함수의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.any">
        <h1>Promise.any ( _iterable_ )</h1>
        <p>이 함수는 전달된 promise 중 처음 fulfilled 되는 promise 로 fulfilled 되거나, 모두 rejected 되면 rejection reason 들을 담은 `AggregateError` 로 reject 되는 promise 를 반환한다. 이 알고리즘을 수행하면서 전달된 iterable 의 모든 요소를 promise 로 resolve 한다.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. _promiseResolve_ 를 Completion(GetPromiseResolve(_C_)) 로 둔다.
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. _iteratorRecord_ 를 Completion(GetIterator(_iterable_, ~sync~)) 로 둔다.
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. _result_ 를 Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) 로 둔다.
          1. _result_ 가 abrupt completion 이면,
            1. _iteratorRecord_.[[Done]] 가 *false* 이면 _result_ 를 Completion(IteratorClose(_iteratorRecord_, _result_)) 로 설정한다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. ! _result_ 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 *this* 값이 `Promise` 생성자의 매개변수 규약을 지원하는 생성자 함수이기를 요구한다.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseany" type="abstract operation">
          <h1>
            PerformPromiseAny (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _errors_ 를 새로운 빈 List 로 둔다.
            1. _remainingElementsCount_ 를 Record { [[Value]]: 1 } 로 둔다.
            1. _index_ 를 0 으로 둔다.
            1. 반복,
              1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
              1. _next_ 가 ~done~ 이면,
                1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
                1. _remainingElementsCount_.[[Value]] = 0 이면,
                  1. _error_ 를 새로 생성된 *AggregateError* 객체로 둔다.
                  1. ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }) 를 수행한다.
                  1. ThrowCompletion(_error_) 를 반환한다.
                1. _resultCapability_.[[Promise]] 를 반환한다.
              1. *undefined* 를 _errors_ 에 추가한다.
              1. _nextPromise_ 를 ? Call(_promiseResolve_, _constructor_, « _next_ ») 로 둔다.
              1. _stepsRejected_ 를 <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref> 에 정의된 알고리즘 단계로 둔다.
              1. _lengthRejected_ 를 <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref> 에 있는 함수 정의의 선택적이 아닌 매개변수 개수로 둔다.
              1. _onRejected_ 를 CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] ») 로 둔다.
              1. _onRejected_.[[AlreadyCalled]] 를 *false* 로 설정한다.
              1. _onRejected_.[[Index]] 를 _index_ 로 설정한다.
              1. _onRejected_.[[Errors]] 를 _errors_ 로 설정한다.
              1. _onRejected_.[[Capability]] 를 _resultCapability_ 로 설정한다.
              1. _onRejected_.[[RemainingElements]] 를 _remainingElementsCount_ 로 설정한다.
              1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] + 1 로 설정한다.
              1. ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _onRejected_ ») 를 수행한다.
              1. _index_ 를 _index_ + 1 로 설정한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.any-reject-element-functions">
          <h1>`Promise.any` Reject Element Functions</h1>
          <p>`Promise.any` reject 요소 함수는 특정 `Promise.any` 요소를 reject 하는 데 사용되는 익명 내장 함수이다. 각 함수는 [[Index]], [[Errors]], [[Capability]], [[RemainingElements]], [[AlreadyCalled]] 내부 슬롯을 가진다.</p>
          <p>`Promise.any` reject 요소 함수가 인수 _x_ 로 호출되면 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _F_ 를 활성 함수 객체로 둔다.
            1. _F_.[[AlreadyCalled]] 가 *true* 이면 *undefined* 를 반환한다.
            1. _F_.[[AlreadyCalled]] 를 *true* 로 설정한다.
            1. _index_ 를 _F_.[[Index]] 로 둔다.
            1. _errors_ 를 _F_.[[Errors]] 로 둔다.
            1. _promiseCapability_ 를 _F_.[[Capability]] 로 둔다.
            1. _remainingElementsCount_ 를 _F_.[[RemainingElements]] 로 둔다.
            1. _errors_[_index_] 를 _x_ 로 설정한다.
            1. _remainingElementsCount_.[[Value]] 를 _remainingElementsCount_.[[Value]] - 1 로 설정한다.
            1. _remainingElementsCount_.[[Value]] = 0 이면,
              1. _error_ 를 새로 생성된 *AggregateError* 객체로 둔다.
              1. ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }) 를 수행한다.
              1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ ») 를 반환한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
          <p>`Promise.any` reject 요소 함수의 *"length"* 프로퍼티는 *1*<sub>𝔽</sub> 이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype">
        <h1>Promise.prototype</h1>
        <p>`Promise.prototype` 의 초기 값은 Promise 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-promise.race">
        <h1>Promise.race ( _iterable_ )</h1>
        <p>이 함수는 가장 먼저 settle 되는 전달된 promise 와 동일한 방식으로 settle 되는 새 promise 를 반환한다. 이 알고리즘을 수행하면서 전달된 _iterable_ 의 모든 요소를 promise 로 resolve 한다.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. _promiseResolve_ 를 Completion(GetPromiseResolve(_C_)) 로 둔다.
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. _iteratorRecord_ 를 Completion(GetIterator(_iterable_, ~sync~)) 로 둔다.
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. _result_ 를 Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)) 로 둔다.
          1. _result_ 가 abrupt completion 이면,
            1. _iteratorRecord_.[[Done]] 가 *false* 이면 _result_ 를 Completion(IteratorClose(_iteratorRecord_, _result_)) 로 설정한다.
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. ! _result_ 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_iterable_ 인수가 어떤 값도 산출하지 않거나 _iterable_ 이 산출한 promise 들 중 어느 것도 settle 되지 않으면, 이 메서드가 반환하는 pending promise 는 결코 settle 되지 않는다.</p>
        </emu-note>
        <emu-note>
          <p>이 함수는 *this* 값이 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수이며 또한 `resolve` 메서드를 제공한다고 기대한다.</p>
        </emu-note>

        <emu-clause id="sec-performpromiserace" type="abstract operation">
          <h1>
            PerformPromiseRace (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 반복,
              1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
              1. _next_ 가 ~done~ 이면,
                1. _resultCapability_.[[Promise]] 를 반환한다.
              1. _nextPromise_ 를 ? Call(_promiseResolve_, _constructor_, « _next_ ») 로 둔다.
              1. ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] ») 를 수행한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.reject">
        <h1>Promise.reject ( _r_ )</h1>
        <p>이 함수는 전달된 인수로 reject 된 새로운 promise 를 반환한다.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ ») 를 수행한다.
          1. _promiseCapability_.[[Promise]] 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 *this* 값이 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수이기를 기대한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.resolve">
        <h1>Promise.resolve ( _x_ )</h1>
        <p>이 함수는 전달된 인수로 resolve 된 새로운 promise 를 반환하거나, 인수가 이 생성자가 생성한 promise 라면 그 인수 자체를 반환한다.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _C_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
          1. ? PromiseResolve(_C_, _x_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 *this* 값이 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수이기를 기대한다.</p>
        </emu-note>

        <emu-clause id="sec-promise-resolve" type="abstract operation">
          <h1>
            PromiseResolve (
              _C_: an Object,
              _x_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_ 로 resolve 된 새로운 promise 를 반환한다.</dd>
          </dl>
          <emu-alg>
            1. IsPromise(_x_) 가 *true* 이면,
              1. _xConstructor_ 를 ? Get(_x_, *"constructor"*) 로 둔다.
              1. SameValue(_xConstructor_, _C_) 가 *true* 이면 _x_ 를 반환한다.
            1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
            1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ ») 를 수행한다.
            1. _promiseCapability_.[[Promise]] 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.try">
        <h1>Promise.try ( _callback_, ..._args_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _C_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. _status_ 를 Completion(Call(_callback_, *undefined*, _args_)) 로 둔다.
          1. _status_ 가 abrupt completion 이면,
            1. ? Call(_promiseCapability_.[[Reject]], *undefined*, « _status_.[[Value]] ») 를 수행한다.
          1. 그렇지 않으면,
            1. ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _status_.[[Value]] ») 를 수행한다.
          1. _promiseCapability_.[[Promise]] 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 함수는 *this* 값이 Promise 생성자의 매개변수 규약을 지원하는 생성자 함수이기를 기대한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.withResolvers">
        <h1>Promise.withResolvers ( )</h1>
        <p>이 함수는 세 개의 프로퍼티를 가진 객체를 반환한다: 새로운 promise 와 그에 연관된 `resolve` 및 `reject` 함수.</p>
        <emu-alg>
          1. _C_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ! CreateDataPropertyOrThrow(_obj_, *"promise"*, _promiseCapability_.[[Promise]]) 를 수행한다.
          1. ! CreateDataPropertyOrThrow(_obj_, *"resolve"*, _promiseCapability_.[[Resolve]]) 를 수행한다.
          1. ! CreateDataPropertyOrThrow(_obj_, *"reject"*, _promiseCapability_.[[Reject]]) 를 수행한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-get-promise-@@species" id="sec-get-promise-%symbol.species%">
        <h1>get Promise [ %Symbol.species% ]</h1>
        <p>`Promise[%Symbol.species%]` 는 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *this* 값을 반환한다.
        </emu-alg>
        <p>이 함수의 *"name"* 프로퍼티 값은 *"get [Symbol.species]"* 이다.</p>
        <emu-note>
          <p>Promise 프로토타입 메서드는 일반적으로 파생 객체를 생성하기 위해 *this* 값의 생성자를 사용한다. 그러나 서브클래스 생성자는 그 %Symbol.species% 프로퍼티를 재정의하여 기본 동작을 바꿀 수 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Promise 프로토타입 객체의 프로퍼티 (Properties of the Promise Prototype Object)</h1>
      <p><dfn>Promise 프로토타입 객체</dfn>는 다음과 같다:</p>
      <ul>
        <li><dfn>%Promise.prototype%</dfn> 이다.</li>
        <li>[[Prototype]] 내부 슬롯의 값이 %Object.prototype% 이다.</li>
        <li>일반 객체이다.</li>
        <li>[[PromiseState]] 내부 슬롯이나 Promise 인스턴스의 다른 어떤 내부 슬롯도 가지지 않는다.</li>
      </ul>

      <emu-clause id="sec-promise.prototype.catch">
        <h1>Promise.prototype.catch ( _onRejected_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _promise_ 를 *this* 값으로 둔다.
          1. ? Invoke(_promise_, *"then"*, « *undefined*, _onRejected_ ») 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.constructor">
        <h1>Promise.prototype.constructor</h1>
        <p>`Promise.prototype.constructor` 의 초기 값은 %Promise% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.finally" oldids="sec-thenfinallyfunctions,sec-catchfinallyfunctions">
        <h1>Promise.prototype.finally ( _onFinally_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _promise_ 를 *this* 값으로 둔다.
          1. _promise_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
          1. _C_ 를 ? SpeciesConstructor(_promise_, %Promise%) 로 둔다.
          1. Assert: IsConstructor(_C_) 는 *true*.
          1. IsCallable(_onFinally_) 가 *false* 이면,
            1. _thenFinally_ 를 _onFinally_ 로 둔다.
            1. _catchFinally_ 를 _onFinally_ 로 둔다.
          1. 그렇지 않으면,
            1. _thenFinallyClosure_ 를 매개변수 (_value_) 를 가지고 _onFinally_ 와 _C_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
              1. _result_ 를 ? Call(_onFinally_, *undefined*) 로 둔다.
              1. _p_ 를 ? PromiseResolve(_C_, _result_) 로 둔다.
              1. _returnValue_ 를 매개변수 없는 새로운 Abstract Closure 로 두고 _value_ 를 포획하며 호출 시 다음 단계를 수행하게 한다:
                1. NormalCompletion(_value_) 를 반환한다.
              1. _valueThunk_ 를 CreateBuiltinFunction(_returnValue_, 0, *""*, « ») 로 둔다.
              1. ? Invoke(_p_, *"then"*, « _valueThunk_ ») 를 반환한다.
            1. _thenFinally_ 를 CreateBuiltinFunction(_thenFinallyClosure_, 1, *""*, « ») 로 둔다.
            1. _catchFinallyClosure_ 를 매개변수 (_reason_) 를 가지고 _onFinally_ 와 _C_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
              1. _result_ 를 ? Call(_onFinally_, *undefined*) 로 둔다.
              1. _p_ 를 ? PromiseResolve(_C_, _result_) 로 둔다.
              1. _throwReason_ 을 매개변수 없는 새로운 Abstract Closure 로 두고 _reason_ 을 포획하며 호출 시 다음 단계를 수행하게 한다:
                1. ThrowCompletion(_reason_) 를 반환한다.
              1. _thrower_ 를 CreateBuiltinFunction(_throwReason_, 0, *""*, « ») 로 둔다.
              1. ? Invoke(_p_, *"then"*, « _thrower_ ») 를 반환한다.
            1. _catchFinally_ 를 CreateBuiltinFunction(_catchFinallyClosure_, 1, *""*, « ») 로 둔다.
          1. ? Invoke(_promise_, *"then"*, « _thenFinally_, _catchFinally_ ») 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _promise_ 를 *this* 값으로 둔다.
          1. IsPromise(_promise_) 가 *false* 이면 *TypeError* 예외를 던진다.
          1. _C_ 를 ? SpeciesConstructor(_promise_, %Promise%) 로 둔다.
          1. _resultCapability_ 를 ? NewPromiseCapability(_C_) 로 둔다.
          1. PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-performpromisethen" type="abstract operation">
          <h1>
            PerformPromiseThen (
              _promise_: a Promise,
              _onFulfilled_: an ECMAScript language value,
              _onRejected_: an ECMAScript language value,
              optional _resultCapability_: a PromiseCapability Record,
            ): an ECMAScript language value
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_promise_ 에 대해 _onFulfilled_ 및 _onRejected_ 를 정착(settlement) 동작으로 사용하여 “then” 연산을 수행한다. _resultCapability_ 가 전달되면 그 promise 를 갱신하여 결과를 저장한다. 전달되지 않은 경우, 결과가 중요하지 않은 명세 내부 연산에 의해 호출된 것이다.</dd>
          </dl>
          <emu-alg>
            1. Assert: IsPromise(_promise_) 는 *true*.
            1. _resultCapability_ 가 존재하지 않으면,
              1. _resultCapability_ 를 *undefined* 로 설정한다.
            1. IsCallable(_onFulfilled_) 가 *false* 이면
              1. _onFulfilledJobCallback_ 을 ~empty~ 로 둔다.
            1. 그렇지 않으면,
              1. _onFulfilledJobCallback_ 을 HostMakeJobCallback(_onFulfilled_) 로 둔다.
            1. IsCallable(_onRejected_) 가 *false* 이면
              1. _onRejectedJobCallback_ 을 ~empty~ 로 둔다.
            1. 그렇지 않으면,
              1. _onRejectedJobCallback_ 을 HostMakeJobCallback(_onRejected_) 로 둔다.
            1. _fulfillReaction_ 을 PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ } 로 둔다.
            1. _rejectReaction_ 을 PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ } 로 둔다.
            1. _promise_.[[PromiseState]] 가 ~pending~ 이면,
              1. _fulfillReaction_ 을 _promise_.[[PromiseFulfillReactions]] 에 추가한다.
              1. _rejectReaction_ 을 _promise_.[[PromiseRejectReactions]] 에 추가한다.
            1. 그렇지 않고 _promise_.[[PromiseState]] 가 ~fulfilled~ 이면,
              1. _value_ 를 _promise_.[[PromiseResult]] 로 둔다.
              1. _fulfillJob_ 을 NewPromiseReactionJob(_fulfillReaction_, _value_) 로 둔다.
              1. HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]) 를 수행한다.
            1. 그렇지 않으면,
              1. Assert: _promise_.[[PromiseState]] 는 ~rejected~.
              1. _reason_ 을 _promise_.[[PromiseResult]] 로 둔다.
              1. _promise_.[[PromiseIsHandled]] 가 *false* 이면 HostPromiseRejectionTracker(_promise_, *"handle"*) 를 수행한다.
              1. _rejectJob_ 을 NewPromiseReactionJob(_rejectReaction_, _reason_) 로 둔다.
              1. HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]) 를 수행한다.
            1. _promise_.[[PromiseIsHandled]] 를 *true* 로 설정한다.
            1. _resultCapability_ 가 *undefined* 이면
              1. *undefined* 를 반환한다.
            1. 그렇지 않으면
              1. _resultCapability_.[[Promise]] 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-promise.prototype-@@tostringtag" id="sec-promise.prototype-%symbol.tostringtag%">
        <h1>Promise.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"Promise"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-promise-instances">
      <h1>Promise 인스턴스의 프로퍼티 (Properties of Promise Instances)</h1>
      <p>Promise 인스턴스는 (내재 %Promise.prototype%) Promise 프로토타입 객체로부터 프로퍼티를 상속하는 일반 객체이다. Promise 인스턴스는 <emu-xref href="#table-internal-slots-of-promise-instances"></emu-xref>에 기술된 내부 슬롯을 가지고 초기화된다.</p>
      <emu-table id="table-internal-slots-of-promise-instances" caption="Promise 인스턴스의 내부 슬롯 (Internal Slots of Promise Instances)" oldids="table-59">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[PromiseState]]
            </td>
            <td>
              ~pending~, ~fulfilled~, or ~rejected~
            </td>
            <td>
              해당 promise 의 `then` 메서드로의 호출에 어떻게 반응할지 결정한다.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseResult]]
            </td>
            <td>
              an ECMAScript language value or ~empty~
            </td>
            <td>
              promise 가 fulfilled 또는 rejected 된 값(있다면). [[PromiseState]] 가 ~pending~ 일 때 그리고 그 때에만 ~empty~.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseFulfillReactions]]
            </td>
            <td>
              a List of PromiseReaction Records
            </td>
            <td>
              promise 가 ~pending~ 에서 ~fulfilled~ 상태로 전이할 때 처리될 기록들.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseRejectReactions]]
            </td>
            <td>
              a List of PromiseReaction Records
            </td>
            <td>
              promise 가 ~pending~ 에서 ~rejected~ 상태로 전이할 때 처리될 기록들.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseIsHandled]]
            </td>
            <td>
              a Boolean
            </td>
            <td>
              이 promise 가 한 번이라도 fulfillment 또는 rejection 핸들러를 가졌는지 나타내며, 처리되지 않은 거부 추적(unhandled rejection tracking)에 사용된다.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generatorfunction-objects">
    <h1>GeneratorFunction 객체 (GeneratorFunction Objects)</h1>
    <p>GeneratorFunction 들은 보통 |GeneratorDeclaration|, |GeneratorExpression|, |GeneratorMethod| 를 평가하여 생성되는 함수들이다. 또한 %GeneratorFunction% 내재(intrinsic)를 호출하여 생성될 수도 있다.</p>
    <emu-figure id="figure-2" caption="Generator 객체 간의 관계 (Generator Objects Relationships)" informative>
      <img alt="수많은 상자와 화살표의 구조도." height="700" src="https://tc39.es/ecma262/img/figure-2.svg" width="900">
    </emu-figure>

    <emu-clause id="sec-generatorfunction-constructor">
      <h1>GeneratorFunction 생성자 (The GeneratorFunction Constructor)</h1>
      <p>GeneratorFunction 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%GeneratorFunction%</dfn> 이다.</li>
        <li>`Function` 의 서브클래스이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 GeneratorFunction 을 생성하고 초기화한다. 따라서 함수 호출 `GeneratorFunction (…)` 은 동일한 인수로 `new GeneratorFunction (…)` 객체 생성 표현식과 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 GeneratorFunction 동작을 상속하려는 서브클래스 생성자는 내장 GeneratorFunction 동작에 필요한 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 GeneratorFunction 생성자에 대한 `super` 호출을 포함해야 한다. 제너레이터 함수 객체를 정의하는 모든 ECMAScript 문법 형태는 GeneratorFunction 의 직접 인스턴스를 생성한다. GeneratorFunction 서브클래스 인스턴스를 만들 수 있는 문법적 수단은 없다.</li>
      </ul>

      <emu-clause id="sec-generatorfunction">
        <h1>GeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>마지막 인수(있다면)는 제너레이터 함수의 본문(실행 코드)을 지정한다; 그 앞의 인수들은 형식 매개변수를 지정한다.</p>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 활성 함수 객체로 둔다.
          1. _bodyArg_ 가 존재하지 않으면 _bodyArg_ 를 빈 문자열로 설정한다.
          1. ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> 의 NOTE 를 참조.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-constructor">
      <h1>GeneratorFunction 생성자의 프로퍼티 (Properties of the GeneratorFunction Constructor)</h1>
      <p>GeneratorFunction 생성자는 다음과 같다:</p>
      <ul>
        <li>Function 생성자로부터 상속하는 표준 내장 함수 객체이다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Function% 이다.</li>
        <li oldids="sec-generatorfunction.length>*" length"* 프로퍼티 값이 *1*<sub>𝔽</sub> 이다.</li>
        <li>*"name"* 프로퍼티 값이 *"GeneratorFunction"* 이다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype">
        <h1>GeneratorFunction.prototype</h1>
        <p>`GeneratorFunction.prototype` 의 초기 값은 GeneratorFunction 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-prototype-object">
      <h1>GeneratorFunction 프로토타입 객체의 프로퍼티 (Properties of the GeneratorFunction Prototype Object)</h1>
      <p><dfn>GeneratorFunction 프로토타입 객체</dfn>는 다음과 같다:</p>
      <ul>
        <li><dfn>%GeneratorFunction.prototype%</dfn> 이다 (<emu-xref href="#figure-2"></emu-xref> 참조).</li>
        <li>일반 객체이다.</li>
        <li>함수 객체가 아니며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 또는 <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref> 에 열거된 [[ECMAScriptCode]] 내부 슬롯이나 다른 내부 슬롯을 가지지 않는다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Function.prototype% 이다.</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype.constructor">
        <h1>GeneratorFunction.prototype.constructor</h1>
        <p>`GeneratorFunction.prototype.constructor` 의 초기 값은 %GeneratorFunction% 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype.prototype">
        <h1>GeneratorFunction.prototype.prototype</h1>
        <p>`GeneratorFunction.prototype.prototype` 의 초기 값은 %GeneratorPrototype% 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-generatorfunction.prototype-@@tostringtag" id="sec-generatorfunction.prototype-%symbol.tostringtag%">
        <h1>GeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"GeneratorFunction"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-generatorfunction-instances">
      <h1>GeneratorFunction 인스턴스 (GeneratorFunction Instances)</h1>
      <p>모든 GeneratorFunction 인스턴스는 ECMAScript 함수 객체이며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 열거된 내부 슬롯을 가진다. 그러한 모든 인스턴스의 [[IsClassConstructor]] 내부 슬롯 값은 *false* 이다.</p>
      <p>각 GeneratorFunction 인스턴스는 다음 자체 프로퍼티들을 가진다:</p>

      <emu-clause id="sec-generatorfunction-instances-length">
        <h1>length</h1>
        <p><emu-xref href="#sec-function-instances-length"></emu-xref> 에 기술된 Function 인스턴스의 *"length"* 프로퍼티 명세는 GeneratorFunction 인스턴스에도 적용된다.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> 에 기술된 Function 인스턴스의 *"name"* 프로퍼티 명세는 GeneratorFunction 인스턴스에도 적용된다.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-prototype">
        <h1>prototype</h1>
        <p>GeneratorFunction 인스턴스가 생성될 때마다 또 다른 일반 객체가 생성되어 해당 제너레이터 함수의 *"prototype"* 프로퍼티 초기 값이 된다. 이 prototype 프로퍼티의 값은 제너레이터 함수 객체가 [[Call]] 로 호출될 때 새로 생성되는 Generator 의 [[Prototype]] 내부 슬롯을 초기화하는 데 사용된다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>Function 인스턴스와 달리, GeneratorFunction 의 *"prototype"* 프로퍼티 값인 객체는 그 값이 해당 GeneratorFunction 인스턴스인 *"constructor"* 프로퍼티를 가지지 않는다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgeneratorfunction-objects">
    <h1>AsyncGeneratorFunction 객체 (AsyncGeneratorFunction Objects)</h1>
    <p>AsyncGeneratorFunction 들은 보통 |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |AsyncGeneratorMethod| 문법 생산물을 평가하여 생성된다. 또한 %AsyncGeneratorFunction% 내재를 호출하여 생성될 수 있다.</p>

    <emu-clause id="sec-asyncgeneratorfunction-constructor">
      <h1>AsyncGeneratorFunction 생성자 (The AsyncGeneratorFunction Constructor)</h1>
      <p>AsyncGeneratorFunction 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%AsyncGeneratorFunction%</dfn> 이다.</li>
        <li>`Function` 의 서브클래스이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 AsyncGeneratorFunction 을 생성하고 초기화한다. 따라서 `AsyncGeneratorFunction (...)` 호출은 동일한 인수의 `new AsyncGeneratorFunction (...)` 과 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 AsyncGeneratorFunction 동작을 상속하려는 서브클래스 생성자는 내장 AsyncGeneratorFunction 동작에 필요한 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 AsyncGeneratorFunction 생성자에 대한 `super` 호출을 포함해야 한다. async generator 함수 객체를 정의하는 모든 ECMAScript 문법 형태는 AsyncGeneratorFunction 의 직접 인스턴스를 생성한다. AsyncGeneratorFunction 서브클래스 인스턴스를 만들 수 있는 문법적 수단은 없다.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction">
        <h1>AsyncGeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>마지막 인수(있다면)는 async generator 함수의 본문(실행 코드)을 지정한다; 그 앞의 인수들은 형식 매개변수를 지정한다.</p>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 활성 함수 객체로 둔다.
          1. _bodyArg_ 가 존재하지 않으면 _bodyArg_ 를 빈 문자열로 설정한다.
          1. ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> 의 NOTE 를 참조.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction">
      <h1>AsyncGeneratorFunction 생성자의 프로퍼티 (Properties of the AsyncGeneratorFunction Constructor)</h1>
      <p>AsyncGeneratorFunction 생성자는 다음과 같다:</p>
      <ul>
        <li>Function 생성자로부터 상속하는 표준 내장 함수 객체이다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Function% 이다.</li>
        <li oldids="sec-asyncgeneratorfunction-length>*" length"* 프로퍼티 값이 *1*<sub>𝔽</sub> 이다.</li>
        <li>*"name"* 프로퍼티 값이 *"AsyncGeneratorFunction"* 이다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype">
        <h1>AsyncGeneratorFunction.prototype</h1>
        <p>`AsyncGeneratorFunction.prototype` 의 초기 값은 AsyncGeneratorFunction 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction-prototype">
      <h1>AsyncGeneratorFunction 프로토타입 객체의 프로퍼티 (Properties of the AsyncGeneratorFunction Prototype Object)</h1>
      <p><dfn>AsyncGeneratorFunction 프로토타입 객체</dfn>는 다음과 같다:</p>
      <ul>
        <li><dfn>%AsyncGeneratorFunction.prototype%</dfn> 이다.</li>
        <li>일반 객체이다.</li>
        <li>함수 객체가 아니며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 또는 <emu-xref href="#table-internal-slots-of-asyncgenerator-instances"></emu-xref> 에 열거된 [[ECMAScriptCode]] 내부 슬롯이나 다른 내부 슬롯을 가지지 않는다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Function.prototype% 이다.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-constructor">
        <h1>AsyncGeneratorFunction.prototype.constructor</h1>
        <p>`AsyncGeneratorFunction.prototype.constructor` 의 초기 값은 %AsyncGeneratorFunction% 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-prototype">
        <h1>AsyncGeneratorFunction.prototype.prototype</h1>
        <p>`AsyncGeneratorFunction.prototype.prototype` 의 초기 값은 %AsyncGeneratorPrototype% 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-asyncgeneratorfunction-prototype-tostringtag" id="sec-asyncgeneratorfunction-prototype-%symbol.tostringtag%">
        <h1>AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"AsyncGeneratorFunction"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunction-instances">
      <h1>AsyncGeneratorFunction 인스턴스 (AsyncGeneratorFunction Instances)</h1>
      <p>모든 AsyncGeneratorFunction 인스턴스는 ECMAScript 함수 객체이며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 열거된 내부 슬롯을 가진다. 그러한 모든 인스턴스의 [[IsClassConstructor]] 내부 슬롯 값은 *false* 이다.</p>
      <p>각 AsyncGeneratorFunction 인스턴스는 다음 자체 프로퍼티들을 가진다:</p>

      <emu-clause id="sec-asyncgeneratorfunction-instance-length">
        <h1>length</h1>
        <p>*"length"* 프로퍼티의 값은 AsyncGeneratorFunction 이 일반적으로 기대하는 인수 개수를 나타내는 정수 Number 이다. 그러나 언어는 다른 개수의 인수로 호출하는 것을 허용한다. *"length"* 프로퍼티에 지정된 것과 다른 인수 개수로 호출될 때의 AsyncGeneratorFunction 동작은 함수에 따라 다르다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> 에 기술된 Function 인스턴스의 *"name"* 프로퍼티 명세는 AsyncGeneratorFunction 인스턴스에도 적용된다.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-prototype">
        <h1>prototype</h1>
        <p>AsyncGeneratorFunction 인스턴스가 생성될 때마다 또 다른 일반 객체가 생성되어 해당 async generator 함수의 *"prototype"* 프로퍼티 초기 값이 된다. 이 prototype 프로퍼티 값은 generator 함수 객체가 [[Call]] 로 호출될 때 새로 생성되는 AsyncGenerator 의 [[Prototype]] 내부 슬롯을 초기화하는 데 사용된다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>function 인스턴스와 달리, AsyncGeneratorFunction 의 *"prototype"* 프로퍼티 값인 객체는 그 값이 해당 AsyncGeneratorFunction 인스턴스인 *"constructor"* 프로퍼티를 가지지 않는다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator 객체 (Generator Objects)</h1>
    <p>Generator 는 제너레이터 함수를 호출하여 생성되며 이터레이터 인터페이스와 iterable 인터페이스를 모두 준수한다.</p>
    <p>Generator 인스턴스는 그것을 생성한 제너레이터 함수의 *"prototype"* 프로퍼티 초기 값으로부터 직접 프로퍼티를 상속한다. Generator 인스턴스는 %GeneratorPrototype% 으로부터 간접적으로 프로퍼티를 상속한다.</p>

    <emu-clause id="sec-properties-of-generator-prototype">
      <h1>%GeneratorPrototype% 객체 (The %GeneratorPrototype% Object)</h1>
      <p><dfn>%GeneratorPrototype%</dfn> 객체는 다음과 같다:</p>
      <ul>
        <li><dfn>%GeneratorFunction.prototype.prototype%</dfn> 이다.</li>
        <li>일반 객체이다.</li>
        <li>Generator 인스턴스가 아니며 [[GeneratorState]] 내부 슬롯을 가지지 않는다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Iterator.prototype% 이다.</li>
        <li>모든 Generator 인스턴스가 간접적으로 상속하는 프로퍼티들을 가진다.</li>
      </ul>

      <emu-clause id="sec-generator.prototype.constructor">
        <h1>%GeneratorPrototype%.constructor</h1>
        <p>%GeneratorPrototype%`.constructor` 의 초기 값은 %GeneratorFunction.prototype% 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.next">
        <h1>%GeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. ? GeneratorResume(*this* value, _value_, ~empty~) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.return">
        <h1>%GeneratorPrototype%.return ( _value_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _g_ 를 *this* 값으로 둔다.
          1. _C_ 를 ReturnCompletion(_value_) 로 둔다.
          1. ? GeneratorResumeAbrupt(_g_, _C_, ~empty~) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.throw">
        <h1>%GeneratorPrototype%.throw ( _exception_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _g_ 를 *this* 값으로 둔다.
          1. _C_ 를 ThrowCompletion(_exception_) 로 둔다.
          1. ? GeneratorResumeAbrupt(_g_, _C_, ~empty~) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-generator.prototype-@@tostringtag" id="sec-generator.prototype-%symbol.tostringtag%">
        <h1>%GeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"Generator"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Generator 인스턴스의 프로퍼티 (Properties of Generator Instances)</h1>
      <p>Generator 인스턴스는 <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref> 에 기술된 내부 슬롯을 가지고 초기화된다.</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Generator 인스턴스의 내부 슬롯 (Internal Slots of Generator Instances)" oldids="table-56">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              ~suspended-start~, ~suspended-yield~, ~executing~, or ~completed~
            </td>
            <td>
              제너레이터의 현재 실행 상태.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              an execution context
            </td>
            <td>
              이 제너레이터의 코드를 실행할 때 사용되는 실행 컨텍스트.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              a String or ~empty~
            </td>
            <td>
              서로 다른 종류의 제너레이터를 구분하는 브랜드. ECMAScript 소스 텍스트로 선언된 제너레이터의 [[GeneratorBrand]] 는 항상 ~empty~.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator 추상 연산 (Generator Abstract Operations)</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[GeneratorState]] 는 ~suspended-start~.
          1. _genContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _genContext_ 의 Generator 컴포넌트를 _generator_ 로 설정한다.
          1. _closure_ 를 매개변수 없고 _generatorBody_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. _acGenContext_ 를 실행 중인 실행 컨텍스트로 둔다.
            1. _acGenerator_ 를 _acGenContext_ 의 Generator 컴포넌트로 둔다.
            1. _generatorBody_ 가 Parse Node 이면
              1. _result_ 를 Completion(Evaluation of _generatorBody_) 로 둔다.
            1. 그렇지 않으면
              1. Assert: _generatorBody_ 는 매개변수 없는 Abstract Closure.
              1. _result_ 를 Completion(_generatorBody_()) 로 둔다.
            1. Assert: 여기로 돌아오면 제너레이터는 예외를 던졌거나 암시적 또는 명시적 return 을 수행했다.
            1. _acGenContext_ 를 실행 컨텍스트 스택에서 제거하고 스택 꼭대기 실행 컨텍스트를 실행 중인 컨텍스트로 복원한다.
            1. _acGenerator_.[[GeneratorState]] 를 ~completed~ 로 설정한다.
            1. 주: 제너레이터가 ~completed~ 상태에 들어가면 다시 나오지 않고 그 연관 실행 컨텍스트는 재개되지 않는다. _acGenerator_ 와 연관된 실행 상태는 이 시점에서 폐기 가능.
            1. _result_ 가 normal completion 이면
              1. _resultValue_ 를 *undefined* 로 둔다.
            1. Else if _result_ 가 return completion 이면
              1. _resultValue_ 를 _result_.[[Value]] 로 둔다.
            1. Else,
              1. Assert: _result_ 는 throw completion.
              1. ? _result_ 를 반환한다.
            1. NormalCompletion(CreateIteratorResultObject(_resultValue_, *true*)) 를 반환한다.
          1. _genContext_ 의 코드 평가 상태를 설정하여 해당 실행 컨텍스트가 재개될 때 _closure_ 가 인수 없이 호출되도록 한다.
          1. _generator_.[[GeneratorContext]] 를 _genContext_ 로 설정한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing one of ~suspended-start~, ~suspended-yield~, or ~completed~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_generator_, [[GeneratorState]]) 를 수행한다.
          1. ? RequireInternalSlot(_generator_, [[GeneratorBrand]]) 를 수행한다.
          1. _generator_.[[GeneratorBrand]] 가 _generatorBrand_ 와 다르면 *TypeError* 예외를 던진다.
          1. Assert: _generator_ 는 또한 [[GeneratorContext]] 내부 슬롯을 가진다.
          1. _state_ 를 _generator_.[[GeneratorState]] 로 둔다.
          1. _state_ 가 ~executing~ 이면 *TypeError* 예외를 던진다.
          1. _state_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _state_ 를 ? GeneratorValidate(_generator_, _generatorBrand_) 로 둔다.
          1. _state_ 가 ~completed~ 이면 CreateIteratorResultObject(*undefined*, *true*) 를 반환한다.
          1. Assert: _state_ 는 ~suspended-start~ 또는 ~suspended-yield~.
          1. _genContext_ 를 _generator_.[[GeneratorContext]] 로 둔다.
          1. _methodContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _methodContext_ 를 suspend 한다.
          1. _generator_.[[GeneratorState]] 를 ~executing~ 으로 설정한다.
          1. _genContext_ 를 실행 컨텍스트 스택에 push; 이제 _genContext_ 가 실행 중인 실행 컨텍스트.
          1. <emu-meta effects="user-code">_genContext_ 의 중단된 평가를 재개</emu-meta> 하되 그것을 중단시킨 연산의 결과로 NormalCompletion(_value_) 를 사용한다. _result_ 를 재개된 계산이 반환한 값으로 둔다.
          1. Assert: 여기로 돌아올 때 _genContext_ 는 이미 실행 컨텍스트 스택에서 제거되었고 _methodContext_ 가 현재 실행 중인 실행 컨텍스트.
          1. ? _result_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _state_ 를 ? GeneratorValidate(_generator_, _generatorBrand_) 로 둔다.
          1. _state_ 가 ~suspended-start~ 이면
            1. _generator_.[[GeneratorState]] 를 ~completed~ 로 설정한다.
            1. 주: 제너레이터가 ~completed~ 상태에 들어가면 다시 나오지 않고 연관 실행 컨텍스트는 재개되지 않는다. _generator_ 와 연관된 실행 상태는 이 시점에서 폐기 가능.
            1. _state_ 를 ~completed~ 로 설정한다.
          1. _state_ 가 ~completed~ 이면
            1. _abruptCompletion_ 이 return completion 이면
              1. CreateIteratorResultObject(_abruptCompletion_.[[Value]], *true*) 를 반환한다.
            1. ? _abruptCompletion_ 를 반환한다.
          1. Assert: _state_ 는 ~suspended-yield~.
          1. _genContext_ 를 _generator_.[[GeneratorContext]] 로 둔다.
          1. _methodContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _methodContext_ 를 suspend 한다.
          1. _generator_.[[GeneratorState]] 를 ~executing~ 으로 설정한다.
          1. _genContext_ 를 실행 컨텍스트 스택에 push; 이제 _genContext_ 가 실행 중인 실행 컨텍스트.
          1. <emu-meta effects="user-code">_genContext_ 의 중단된 평가를 재개</emu-meta> 하되 그것을 중단시킨 연산의 결과로 _abruptCompletion_ 을 사용한다. _result_ 를 재개된 계산이 반환한 Completion Record 로 둔다.
          1. Assert: 여기로 돌아올 때 _genContext_ 는 이미 실행 컨텍스트 스택에서 제거되었고 _methodContext_ 가 현재 실행 중인 실행 컨텍스트.
          1. ? _result_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getgeneratorkind" type="abstract operation">
        <h1>GetGeneratorKind ( ): ~non-generator~, ~sync~, or ~async~</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _genContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _genContext_ 가 Generator 컴포넌트를 가지지 않으면 ~non-generator~ 를 반환한다.
          1. _generator_ 를 _genContext_ 의 Generator 컴포넌트 값으로 둔다.
          1. _generator_ 에 [[AsyncGeneratorState]] 내부 슬롯이 있으면 ~async~ 를 반환한다.
          1. 아니면 ~sync~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatoryield" type="abstract operation">
        <h1>
          GeneratorYield (
            _iteratorResult_: an Object that conforms to the IteratorResult interface,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. _genContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. Assert: _genContext_ 는 제너레이터의 실행 컨텍스트.
          1. _generator_ 를 _genContext_ 의 Generator 컴포넌트 값으로 둔다.
          1. Assert: GetGeneratorKind() 는 ~sync~.
          1. _generator_.[[GeneratorState]] 를 ~suspended-yield~ 로 설정한다.
          1. _genContext_ 를 실행 컨텍스트 스택에서 제거하고 스택 꼭대기 실행 컨텍스트를 실행 중인 컨텍스트로 복원한다.
          1. _callerContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _callerContext_ 를 NormalCompletion(_iteratorResult_) 를 전달하며 재개한다. _genContext_ 가 다시 재개되면 _resumptionValue_ 를 재개된 Completion Record 로 둔다.
          1. Assert: 여기 도달했다면 _genContext_ 가 다시 실행 중인 실행 컨텍스트이다.
          1. _resumptionValue_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yield" type="abstract operation">
        <h1>
          Yield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _generatorKind_ 를 GetGeneratorKind() 로 둔다.
          1. _generatorKind_ 가 ~async~ 이면 ? AsyncGeneratorYield(? Await(_value_)) 를 반환한다.
          1. 그렇지 않으면 ? GeneratorYield(CreateIteratorResultObject(_value_, *false*)) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
            optional _extraSlots_: a List of names of internal slots,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 주: _closure_ 는 IteratorResult 객체를 산출하기 위해 Yield 연산을 사용할 수 있다.
          1. _extraSlots_ 가 존재하지 않으면 새 빈 List 로 설정한다.
          1. _internalSlotsList_ 를 _extraSlots_ 와 « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] » 의 리스트 연결로 둔다.
          1. _generator_ 를 OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_) 로 둔다.
          1. _generator_.[[GeneratorBrand]] 를 _generatorBrand_ 로 설정한다.
          1. _generator_.[[GeneratorState]] 를 ~suspended-start~ 로 설정한다.
          1. _callerContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _calleeContext_ 를 새로운 실행 컨텍스트로 둔다.
          1. _calleeContext_ 의 Function 을 *null* 로 설정한다.
          1. _calleeContext_ 의 Realm 을 현재 Realm Record 로 설정한다.
          1. _calleeContext_ 의 ScriptOrModule 을 _callerContext_ 의 ScriptOrModule 로 설정한다.
          1. _callerContext_ 가 이미 suspend 상태가 아니면 suspend 한다.
          1. _calleeContext_ 를 실행 컨텍스트 스택에 push; 이제 _calleeContext_ 가 실행 중인 실행 컨텍스트.
          1. GeneratorStart(_generator_, _closure_) 를 수행한다.
          1. _calleeContext_ 를 실행 컨텍스트 스택에서 제거하고 _callerContext_ 를 실행 중인 실행 컨텍스트로 복원한다.
          1. _generator_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator 객체 (AsyncGenerator Objects)</h1>
    <p>AsyncGenerator 는 async 제너레이터 함수를 호출하여 생성되며 async 이터레이터 인터페이스와 async iterable 인터페이스를 모두 준수한다.</p>

    <p>AsyncGenerator 인스턴스는 그것을 생성한 async 제너레이터 함수의 *"prototype"* 프로퍼티 초기 값으로부터 직접 프로퍼티를 상속한다. AsyncGenerator 인스턴스는 %AsyncGeneratorPrototype% 으로부터 간접적으로 프로퍼티를 상속한다.</p>

    <emu-clause id="sec-properties-of-asyncgenerator-prototype">
      <h1>%AsyncGeneratorPrototype% 객체 (The %AsyncGeneratorPrototype% Object)</h1>
      <p><dfn>%AsyncGeneratorPrototype%</dfn> 객체:</p>
      <ul>
        <li><dfn>%AsyncGeneratorFunction.prototype.prototype%</dfn> 이다.</li>
        <li>일반 객체이다.</li>
        <li>AsyncGenerator 인스턴스가 아니며 [[AsyncGeneratorState]] 내부 슬롯을 갖지 않는다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %AsyncIteratorPrototype% 이다.</li>
        <li>모든 AsyncGenerator 인스턴스가 간접적으로 상속하는 프로퍼티들을 가진다.</li>
      </ul>

      <emu-clause id="sec-asyncgenerator-prototype-constructor">
        <h1>%AsyncGeneratorPrototype%.constructor</h1>
        <p>%AsyncGeneratorPrototype%`.constructor` 의 초기 값은 %AsyncGeneratorFunction.prototype% 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-next">
        <h1>%AsyncGeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. _generator_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
          1. _result_ 를 Completion(AsyncGeneratorValidate(_generator_, ~empty~)) 로 둔다.
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. _state_ 를 _generator_.[[AsyncGeneratorState]] 로 둔다.
          1. _state_ 가 ~completed~ 이면,
            1. _iteratorResult_ 를 CreateIteratorResultObject(*undefined*, *true*) 로 둔다.
            1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ ») 를 수행한다.
            1. _promiseCapability_.[[Promise]] 를 반환한다.
          1. _completion_ 을 NormalCompletion(_value_) 로 둔다.
          1. AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_) 를 수행한다.
          1. _state_ 가 ~suspended-start~ 또는 ~suspended-yield~ 이면,
            1. AsyncGeneratorResume(_generator_, _completion_) 를 수행한다.
          1. 그렇지 않으면,
            1. Assert: _state_ 는 ~executing~ 또는 ~draining-queue~.
          1. _promiseCapability_.[[Promise]] 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-return">
        <h1>%AsyncGeneratorPrototype%.return ( _value_ )</h1>
        <emu-alg>
          1. _generator_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
          1. _result_ 를 Completion(AsyncGeneratorValidate(_generator_, ~empty~)) 로 둔다.
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. _completion_ 을 ReturnCompletion(_value_) 로 둔다.
          1. AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_) 를 수행한다.
          1. _state_ 를 _generator_.[[AsyncGeneratorState]] 로 둔다.
          1. _state_ 가 ~suspended-start~ 또는 ~completed~ 이면
            1. _generator_.[[AsyncGeneratorState]] 를 ~draining-queue~ 로 설정한다.
            1. AsyncGeneratorAwaitReturn(_generator_) 를 수행한다.
          1. Else if _state_ 가 ~suspended-yield~ 이면
            1. AsyncGeneratorResume(_generator_, _completion_) 를 수행한다.
          1. 그렇지 않으면,
            1. Assert: _state_ 는 ~executing~ 또는 ~draining-queue~.
          1. _promiseCapability_.[[Promise]] 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-throw">
        <h1>%AsyncGeneratorPrototype%.throw ( _exception_ )</h1>
        <emu-alg>
          1. _generator_ 를 *this* 값으로 둔다.
          1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
          1. _result_ 를 Completion(AsyncGeneratorValidate(_generator_, ~empty~)) 로 둔다.
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. _state_ 를 _generator_.[[AsyncGeneratorState]] 로 둔다.
          1. _state_ 가 ~suspended-start~ 이면
            1. _generator_.[[AsyncGeneratorState]] 를 ~completed~ 로 설정한다.
            1. _state_ 를 ~completed~ 로 설정한다.
          1. _state_ 가 ~completed~ 이면
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ ») 를 수행한다.
            1. _promiseCapability_.[[Promise]] 를 반환한다.
          1. _completion_ 을 ThrowCompletion(_exception_) 로 둔다.
          1. AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_) 를 수행한다.
          1. _state_ 가 ~suspended-yield~ 이면
            1. AsyncGeneratorResume(_generator_, _completion_) 를 수행한다.
          1. 그렇지 않으면,
            1. Assert: _state_ 는 ~executing~ 또는 ~draining-queue~.
          1. _promiseCapability_.[[Promise]] 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-asyncgenerator-prototype-tostringtag" id="sec-asyncgenerator-prototype-%symbol.tostringtag%">
        <h1>%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"AsyncGenerator"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>AsyncGenerator 인스턴스의 프로퍼티 (Properties of AsyncGenerator Instances)</h1>
      <p>AsyncGenerator 인스턴스는 아래에 기술된 내부 슬롯을 가지고 초기화된다:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="AsyncGenerator 인스턴스의 내부 슬롯 (Internal Slots of AsyncGenerator Instances)">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>~suspended-start~, ~suspended-yield~, ~executing~, ~draining-queue~, or ~completed~</td>
            <td>async 제너레이터의 현재 실행 상태.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>an execution context</td>
            <td>이 async 제너레이터의 코드를 실행할 때 사용되는 실행 컨텍스트.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>a List of AsyncGeneratorRequest Records</td>
            <td>async 제너레이터 재개 요청을 나타내는 레코드. 상태 전이 중을 제외하면 [[AsyncGeneratorState]] 가 ~executing~ 또는 ~draining-queue~ 일 때 그리고 그 때에만 비어 있지 않다.</td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>a String or ~empty~</td>
            <td>서로 다른 종류의 async 제너레이터를 구분하는 브랜드. ECMAScript 소스 텍스트로 선언된 async 제너레이터의 [[GeneratorBrand]] 는 항상 ~empty~.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator 추상 연산 (AsyncGenerator Abstract Operations)</h1>

      <emu-clause id="sec-asyncgeneratorrequest-records">
        <h1>AsyncGeneratorRequest 레코드 (AsyncGeneratorRequest Records)</h1>
        <p><dfn variants="AsyncGeneratorRequests">AsyncGeneratorRequest</dfn> 는 async 제너레이터를 어떻게 재개해야 하는지에 대한 정보를 저장하고 해당 promise 를 이행하거나 거부하기 위한 capability 를 포함하는 Record 값이다.</p>
        <p>다음 필드를 가진다:</p>
        <emu-table caption="AsyncGeneratorRequest Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Completion]]</td>
              <td>a Completion Record</td>
              <td>async 제너레이터를 재개할 때 사용할 Completion Record.</td>
            </tr>
            <tr>
              <td>[[Capability]]</td>
              <td>a PromiseCapability Record</td>
              <td>이 요청과 연관된 promise capability.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] 는 ~suspended-start~.
          1. _genContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _genContext_ 의 Generator 컴포넌트를 _generator_ 로 설정한다.
          1. _closure_ 를 매개변수 없고 _generatorBody_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. _acGenContext_ 를 실행 중인 실행 컨텍스트로 둔다.
            1. _acGenerator_ 를 _acGenContext_ 의 Generator 컴포넌트로 둔다.
            1. _generatorBody_ 가 Parse Node 이면
              1. _result_ 를 Completion(Evaluation of _generatorBody_) 로 둔다.
            1. 그렇지 않으면
              1. Assert: _generatorBody_ 는 매개변수 없는 Abstract Closure.
              1. _result_ 를 Completion(_generatorBody_()) 로 둔다.
            1. Assert: 여기로 돌아오면 async 제너레이터는 예외를 던졌거나 암시적 또는 명시적 return 을 수행한 것이다.
            1. _acGenContext_ 를 실행 컨텍스트 스택에서 제거하고 스택 꼭대기 실행 컨텍스트를 실행 중인 컨텍스트로 복원한다.
            1. _acGenerator_.[[AsyncGeneratorState]] 를 ~draining-queue~ 로 설정한다.
            1. _result_ 가 normal completion 이면 _result_ 를 NormalCompletion(*undefined*) 로 설정한다.
            1. _result_ 가 return completion 이면 _result_ 를 NormalCompletion(_result_.[[Value]]) 로 설정한다.
            1. AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*) 를 수행한다.
            1. AsyncGeneratorDrainQueue(_acGenerator_) 를 수행한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _genContext_ 의 코드 평가 상태를 설정하여 그 실행 컨텍스트가 재개될 때 _closure_ 가 인수 없이 호출되도록 한다.
          1. _generator_.[[AsyncGeneratorContext]] 를 _genContext_ 로 설정한다.
          1. _generator_.[[AsyncGeneratorQueue]] 를 새 빈 List 로 설정한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]) 를 수행한다.
          1. ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]) 를 수행한다.
          1. ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]) 를 수행한다.
          1. _generator_.[[GeneratorBrand]] 가 _generatorBrand_ 와 다르면 *TypeError* 예외를 던진다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorenqueue" type="abstract operation">
        <h1>
          AsyncGeneratorEnqueue (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _promiseCapability_: a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _request_ 를 AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ } 로 둔다.
          1. _request_ 를 _generator_.[[AsyncGeneratorQueue]] 에 추가한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorcompletestep" type="abstract operation">
        <h1>
          AsyncGeneratorCompleteStep (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _done_: a Boolean,
            optional _realm_: a Realm Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorQueue]] 는 비어 있지 않다.
          1. _next_ 를 _generator_.[[AsyncGeneratorQueue]] 의 첫 번째 요소로 둔다.
          1. 첫 번째 요소를 _generator_.[[AsyncGeneratorQueue]] 에서 제거한다.
          1. _promiseCapability_ 를 _next_.[[Capability]] 로 둔다.
          1. _value_ 를 _completion_.[[Value]] 로 둔다.
          1. _completion_ 이 throw completion 이면,
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ ») 를 수행한다.
          1. 그렇지 않으면,
            1. Assert: _completion_ 은 normal completion.
            1. _realm_ 이 존재하면,
              1. _oldRealm_ 을 실행 중인 실행 컨텍스트의 Realm 으로 둔다.
              1. 실행 중인 실행 컨텍스트의 Realm 을 _realm_ 으로 설정한다.
              1. _iteratorResult_ 를 CreateIteratorResultObject(_value_, _done_) 로 둔다.
              1. 실행 중인 실행 컨텍스트의 Realm 을 _oldRealm_ 으로 되돌린다.
            1. 그렇지 않으면,
              1. _iteratorResult_ 를 CreateIteratorResultObject(_value_, _done_) 로 둔다.
            1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ ») 를 수행한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] 는 ~suspended-start~ 또는 ~suspended-yield~.
          1. _genContext_ 를 _generator_.[[AsyncGeneratorContext]] 로 둔다.
          1. _callerContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _callerContext_ 를 suspend 한다.
          1. _generator_.[[AsyncGeneratorState]] 를 ~executing~ 으로 설정한다.
          1. _genContext_ 를 실행 컨텍스트 스택에 push; 이제 _genContext_ 가 실행 중인 실행 컨텍스트.
          1. <emu-meta effects="user-code">_genContext_ 의 중단된 평가를 재개</emu-meta> 하되 그것을 중단시킨 연산의 결과로 _completion_ 을 사용한다. _result_ 를 재개된 계산이 반환한 Completion Record 로 둔다.
          1. Assert: _result_ 는 절대 abrupt completion 이 아니다.
          1. Assert: 여기로 돌아오면 _genContext_ 는 이미 실행 컨텍스트 스택에서 제거되었고 _callerContext_ 가 현재 실행 컨텍스트이다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorunwrapyieldresumption" type="abstract operation">
        <h1>
          AsyncGeneratorUnwrapYieldResumption (
            _resumptionValue_: a Completion Record,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _resumptionValue_ 가 return completion 이 아니면 ? _resumptionValue_ 를 반환한다.
          1. _awaited_ 를 Completion(Await(_resumptionValue_.[[Value]])) 로 둔다.
          1. _awaited_ 가 throw completion 이면 ? _awaited_ 를 반환한다.
          1. Assert: _awaited_ 는 normal completion.
          1. ReturnCompletion(_awaited_.[[Value]]) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratoryield" type="abstract operation">
        <h1>
          AsyncGeneratorYield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _genContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. Assert: _genContext_ 는 제너레이터의 실행 컨텍스트.
          1. _generator_ 를 _genContext_ 의 Generator 컴포넌트 값으로 둔다.
          1. Assert: GetGeneratorKind() 는 ~async~.
          1. _completion_ 을 NormalCompletion(_value_) 로 둔다.
          1. Assert: 실행 컨텍스트 스택은 최소 두 개의 요소를 가진다.
          1. _previousContext_ 를 실행 컨텍스트 스택의 위에서 두 번째 요소로 둔다.
          1. _previousRealm_ 을 _previousContext_ 의 Realm 으로 둔다.
          1. AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_) 를 수행한다.
          1. _queue_ 를 _generator_.[[AsyncGeneratorQueue]] 로 둔다.
          1. _queue_ 가 비어 있지 않으면,
            1. 주: 제너레이터를 suspend 하지 않고 실행을 계속한다.
            1. _toYield_ 를 _queue_ 의 첫 요소로 둔다.
            1. _resumptionValue_ 를 Completion(_toYield_.[[Completion]]) 로 둔다.
            1. ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_) 를 반환한다.
          1. 그렇지 않으면,
            1. _generator_.[[AsyncGeneratorState]] 를 ~suspended-yield~ 로 설정한다.
            1. _genContext_ 를 실행 컨텍스트 스택에서 제거하고 스택 꼭대기 실행 컨텍스트를 실행 중인 컨텍스트로 복원한다.
            1. _callerContext_ 를 실행 중인 실행 컨텍스트로 둔다.
            1. _callerContext_ 를 *undefined* 를 전달하며 재개한다. _genContext_ 가 다시 재개되면 _resumptionValue_ 를 그 재개에 사용된 Completion Record 로 둔다.
            1. Assert: 여기 도달하면 _genContext_ 가 다시 실행 중인 실행 컨텍스트이다.
            1. ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorawaitreturn" type="abstract operation">
        <h1>
          AsyncGeneratorAwaitReturn (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] 는 ~draining-queue~.
          1. _queue_ 를 _generator_.[[AsyncGeneratorQueue]] 로 둔다.
          1. Assert: _queue_ 는 비어 있지 않다.
          1. _next_ 를 _queue_ 의 첫 요소로 둔다.
          1. _completion_ 을 Completion(_next_.[[Completion]]) 로 둔다.
          1. Assert: _completion_ 은 return completion.
          1. _promiseCompletion_ 을 Completion(PromiseResolve(%Promise%, _completion_.[[Value]])) 로 둔다.
          1. _promiseCompletion_ 이 abrupt completion 이면,
            1. AsyncGeneratorCompleteStep(_generator_, _promiseCompletion_, *true*) 를 수행한다.
            1. AsyncGeneratorDrainQueue(_generator_) 를 수행한다.
            1. ~unused~ 를 반환한다.
          1. Assert: _promiseCompletion_ 은 normal completion.
          1. _promise_ 를 _promiseCompletion_.[[Value]] 로 둔다.
          1. _fulfilledClosure_ 를 매개변수 (_value_) 를 가지고 _generator_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. Assert: _generator_.[[AsyncGeneratorState]] 는 ~draining-queue~.
            1. _result_ 를 NormalCompletion(_value_) 로 둔다.
            1. AsyncGeneratorCompleteStep(_generator_, _result_, *true*) 를 수행한다.
            1. AsyncGeneratorDrainQueue(_generator_) 를 수행한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _onFulfilled_ 를 CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « ») 로 둔다.
          1. _rejectedClosure_ 를 매개변수 (_reason_) 를 가지고 _generator_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. Assert: _generator_.[[AsyncGeneratorState]] 는 ~draining-queue~.
            1. _result_ 를 ThrowCompletion(_reason_) 로 둔다.
            1. AsyncGeneratorCompleteStep(_generator_, _result_, *true*) 를 수행한다.
            1. AsyncGeneratorDrainQueue(_generator_) 를 수행한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _onRejected_ 를 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « ») 로 둔다.
          1. PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_) 를 수행한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratordrainqueue" type="abstract operation">
        <h1>
          AsyncGeneratorDrainQueue (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>return completion 을 보유한 AsyncGeneratorRequest 를 만날 때까지 제너레이터의 AsyncGeneratorQueue 를 비운다.</dd>
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] 는 ~draining-queue~.
          1. _queue_ 를 _generator_.[[AsyncGeneratorQueue]] 로 둔다.
          1. 반복, _queue_ 가 비어 있지 않은 동안,
            1. _next_ 를 _queue_ 의 첫 요소로 둔다.
            1. _completion_ 을 Completion(_next_.[[Completion]]) 로 둔다.
            1. _completion_ 이 return completion 이면,
              1. AsyncGeneratorAwaitReturn(_generator_) 를 수행한다.
              1. ~unused~ 를 반환한다.
            1. 그렇지 않으면,
              1. _completion_ 이 normal completion 이면
                1. _completion_ 을 NormalCompletion(*undefined*) 로 설정한다.
              1. AsyncGeneratorCompleteStep(_generator_, _completion_, *true*) 를 수행한다.
          1. _generator_.[[AsyncGeneratorState]] 를 ~completed~ 로 설정한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ 는 Await 연산과 IteratorResult 객체를 산출하기 위한 Yield 연산을 포함할 수 있다.
          1. _internalSlotsList_ 를 « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] » 로 둔다.
          1. _generator_ 를 OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_) 로 둔다.
          1. _generator_.[[GeneratorBrand]] 를 _generatorBrand_ 로 설정한다.
          1. _generator_.[[AsyncGeneratorState]] 를 ~suspended-start~ 로 설정한다.
          1. _callerContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _calleeContext_ 를 새로운 실행 컨텍스트로 둔다.
          1. _calleeContext_ 의 Function 을 *null* 로 설정한다.
          1. _calleeContext_ 의 Realm 을 현재 Realm Record 로 설정한다.
          1. _calleeContext_ 의 ScriptOrModule 을 _callerContext_ 의 ScriptOrModule 로 설정한다.
          1. _callerContext_ 가 이미 suspend 상태가 아니면 suspend 한다.
          1. _calleeContext_ 를 실행 컨텍스트 스택에 push; 이제 _calleeContext_ 가 실행 중인 실행 컨텍스트.
          1. AsyncGeneratorStart(_generator_, _closure_) 를 수행한다.
          1. _calleeContext_ 를 실행 컨텍스트 스택에서 제거하고 _callerContext_ 를 실행 중인 실행 컨텍스트로 복원한다.
          1. _generator_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction 객체 (AsyncFunction Objects)</h1>
    <p>AsyncFunction 들은 보통 |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncMethod|, |AsyncArrowFunction| 을 평가하여 생성되는 함수들이다. 또한 %AsyncFunction% 내재를 호출하여 생성될 수도 있다.</p>

    <emu-clause id="sec-async-function-constructor">
      <h1>AsyncFunction 생성자 (The AsyncFunction Constructor)</h1>

      <p>AsyncFunction 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%AsyncFunction%</dfn> 이다.</li>
        <li>`Function` 의 서브클래스이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 AsyncFunction 을 생성하고 초기화한다. 따라서 함수 호출 `AsyncFunction(…)` 은 동일한 인수의 `new AsyncFunction(…)` 객체 생성 표현식과 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 AsyncFunction 동작을 상속하려는 서브클래스 생성자는 내장 async 함수 동작에 필요한 내부 슬롯을 갖춘 서브클래스 인스턴스를 생성·초기화하기 위해 AsyncFunction 생성자에 대한 `super` 호출을 포함해야 한다. async 함수 객체를 정의하는 모든 ECMAScript 문법 형태는 AsyncFunction 의 직접 인스턴스를 생성한다. AsyncFunction 서브클래스 인스턴스를 만들 수 있는 문법적 수단은 없다.</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-arguments">
        <h1>AsyncFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>마지막 인수(있다면)는 async 함수의 본문(실행 코드)을 지정한다. 그 앞의 인수들은 형식 매개변수를 지정한다.</p>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>

        <emu-alg>
          1. _C_ 를 활성 함수 객체로 둔다.
          1. _bodyArg_ 가 존재하지 않으면 _bodyArg_ 를 빈 문자열로 설정한다.
          1. ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_) 를 반환한다.
        </emu-alg>

        <emu-note><emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> 의 NOTE 참조.</emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-constructor-properties">
      <h1>AsyncFunction 생성자의 프로퍼티 (Properties of the AsyncFunction Constructor)</h1>

      <p>AsyncFunction 생성자는 다음과 같다:</p>
      <ul>
        <li>Function 생성자로부터 상속하는 표준 내장 함수 객체이다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Function% 이다.</li>
        <li oldids="sec-async-function-constructor-length">*"length"* 프로퍼티 값이 *1*<sub>𝔽</sub> 이다.</li>
        <li>*"name"* 프로퍼티 값이 *"AsyncFunction"* 이다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-prototype">
        <h1>AsyncFunction.prototype</h1>
        <p>`AsyncFunction.prototype` 의 초기 값은 AsyncFunction 프로토타입 객체이다.</p>

        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-prototype-properties">
      <h1>AsyncFunction 프로토타입 객체의 프로퍼티 (Properties of the AsyncFunction Prototype Object)</h1>
      <p><dfn>AsyncFunction 프로토타입 객체</dfn>:</p>
      <ul>
        <li><dfn>%AsyncFunction.prototype%</dfn> 이다.</li>
        <li>일반 객체이다.</li>
        <li>함수 객체가 아니며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 열거된 [[ECMAScriptCode]] 내부 슬롯이나 그 밖의 내부 슬롯을 가지지 않는다.</li>
        <li>[[Prototype]] 내부 슬롯 값이 %Function.prototype% 이다.</li>
      </ul>

      <emu-clause id="sec-async-function-prototype-properties-constructor">
        <h1>AsyncFunction.prototype.constructor</h1>

        <p>`AsyncFunction.prototype.constructor` 의 초기 값은 %AsyncFunction% 이다.</p>

        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-async-function-prototype-properties-toStringTag" id="sec-async-function-prototype-%symbol.tostringtag%">
        <h1>AsyncFunction.prototype [ %Symbol.toStringTag% ]</h1>

        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 문자열 *"AsyncFunction"* 이다.</p>

        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-instances">
      <h1>AsyncFunction 인스턴스 (AsyncFunction Instances)</h1>

      <p>모든 AsyncFunction 인스턴스는 ECMAScript 함수 객체이며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 열거된 내부 슬롯을 가진다. 그러한 모든 인스턴스의 [[IsClassConstructor]] 내부 슬롯 값은 *false* 이다. AsyncFunction 인스턴스는 생성자가 아니며 [[Construct]] 내부 메서드를 갖지 않는다. AsyncFunction 인스턴스는 생성 불가능하므로 prototype 프로퍼티를 갖지 않는다.</p>
      <p>각 AsyncFunction 인스턴스는 다음 자체 프로퍼티를 가진다:</p>

      <emu-clause id="sec-async-function-instances-length">
        <h1>length</h1>
        <p><emu-xref href="#sec-function-instances-length"></emu-xref> 에 기술된 Function 인스턴스 *"length"* 프로퍼티 명세는 AsyncFunction 인스턴스에도 적용된다.</p>
      </emu-clause>

      <emu-clause id="sec-async-function-instances-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> 에 기술된 Function 인스턴스 *"name"* 프로퍼티 명세는 AsyncFunction 인스턴스에도 적용된다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async 함수 추상 연산 (Async Functions Abstract Operations)</h1>

      <emu-clause id="sec-async-functions-abstract-operations-async-function-start" type="abstract operation">
        <h1>
          AsyncFunctionStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncFunctionBody_: a |FunctionBody| Parse Node, an |ExpressionBody| Parse Node, or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _runningContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _asyncContext_ 를 _runningContext_ 의 복사본으로 둔다.
          1. NOTE: 실행 상태 복사는 AsyncBlockStart 가 그 실행을 재개하기 위해 필요하다. 현재 실행 중인 컨텍스트를 재개하는 것은 잘 정의되지 않는다.
          1. AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_) 를 수행한다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncblockstart" type="abstract operation">
        <h1>
          AsyncBlockStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncBody_: a Parse Node or an Abstract Closure with no parameters,
            _asyncContext_: an execution context,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _runningContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _closure_ 를 매개변수 없고 _promiseCapability_, _asyncBody_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. _acAsyncContext_ 를 실행 중인 실행 컨텍스트로 둔다.
            1. _asyncBody_ 가 Parse Node 이면
              1. _result_ 를 Completion(Evaluation of _asyncBody_) 로 둔다.
            1. 그렇지 않으면
              1. Assert: _asyncBody_ 는 매개변수 없는 Abstract Closure.
              1. _result_ 를 Completion(_asyncBody_()) 로 둔다.
            1. Assert: 여기로 돌아오면 async 함수는 예외를 던졌거나 암시적 또는 명시적 return 을 수행했고 모든 await 가 완료되었다.
            1. _acAsyncContext_ 를 실행 컨텍스트 스택에서 제거하고 스택 꼭대기 실행 컨텍스트를 실행 중인 컨텍스트로 복원한다.
            1. _result_ 가 normal completion 이면
              1. ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* ») 를 수행한다.
            1. Else if _result_ 가 return completion 이면
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] ») 를 수행한다.
            1. Else,
              1. Assert: _result_ 는 throw completion.
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] ») 를 수행한다.
            1. [id="step-asyncblockstart-return-undefined"] NormalCompletion(~unused~) 를 반환한다.
          1. _asyncContext_ 의 코드 평가 상태를 설정하여 그 실행 컨텍스트가 재개될 때 _closure_ 가 인수 없이 호출되도록 한다.
          1. _asyncContext_ 를 실행 컨텍스트 스택에 push; 이제 _asyncContext_ 가 실행 중인 실행 컨텍스트.
          1. <emu-meta effects="user-code">_asyncContext_ 의 중단된 평가를 재개</emu-meta> 한다. _result_ 를 재개된 계산이 반환한 값으로 둔다.
          1. Assert: 여기로 돌아오면 _asyncContext_ 는 이미 실행 컨텍스트 스택에서 제거되었고 _runningContext_ 가 현재 실행 컨텍스트이다.
          1. Assert: _result_ 는 값이 ~unused~ 인 normal completion. 이 값의 가능한 출처는 Await 이거나, async 함수가 어떤 것도 await 하지 않는 경우 위 <emu-xref href="#step-asyncblockstart-return-undefined"></emu-xref> 단계이다.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="await" oldids="await-fulfilled,await-rejected" type="abstract operation">
        <h1>
          Await (
            _value_: an ECMAScript language value,
          ): either a normal completion containing either an ECMAScript language value or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _asyncContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _promise_ 를 ? PromiseResolve(%Promise%, _value_) 로 둔다.
          1. _fulfilledClosure_ 를 매개변수 (_v_) 를 가지고 _asyncContext_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. _prevContext_ 를 실행 중인 실행 컨텍스트로 둔다.
            1. _prevContext_ 를 suspend 한다.
            1. _asyncContext_ 를 실행 컨텍스트 스택에 push; 이제 _asyncContext_ 가 실행 중인 실행 컨텍스트.
            1. <emu-meta effects="user-code">_asyncContext_ 의 중단된 평가를 재개</emu-meta> 하되 그것을 중단시킨 연산의 결과로 NormalCompletion(_v_) 를 사용한다.
            1. Assert: 이 단계에 도달하면 _asyncContext_ 는 이미 실행 컨텍스트 스택에서 제거되었고 _prevContext_ 가 현재 실행 컨텍스트이다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _onFulfilled_ 를 CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « ») 로 둔다.
          1. _rejectedClosure_ 를 매개변수 (_reason_) 를 가지고 _asyncContext_ 를 포획하며 호출 시 다음 단계를 수행하는 새로운 Abstract Closure 로 둔다:
            1. _prevContext_ 를 실행 중인 실행 컨텍스트로 둔다.
            1. _prevContext_ 를 suspend 한다.
            1. _asyncContext_ 를 실행 컨텍스트 스택에 push; 이제 _asyncContext_ 가 실행 중인 실행 컨텍스트.
            1. <emu-meta effects="user-code">_asyncContext_ 의 중단된 평가를 재개</emu-meta> 하되 그것을 중단시킨 연산의 결과로 ThrowCompletion(_reason_) 를 사용한다.
            1. Assert: 이 단계에 도달하면 _asyncContext_ 는 이미 실행 컨텍스트 스택에서 제거되었고 _prevContext_ 가 현재 실행 컨텍스트이다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _onRejected_ 를 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « ») 로 둔다.
          1. PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_) 를 수행한다.
          1. _asyncContext_ 를 실행 컨텍스트 스택에서 제거하고 스택 꼭대기 실행 컨텍스트를 실행 중인 컨텍스트로 복원한다.
          1. _callerContext_ 를 실행 중인 실행 컨텍스트로 둔다.
          1. _callerContext_ 를 ~empty~ 를 전달하며 재개한다. _asyncContext_ 가 다시 재개되면 _completion_ 을 그 재개에 사용된 Completion Record 로 둔다.
          1. Assert: 여기 도달하면 _asyncContext_ 가 다시 실행 중인 실행 컨텍스트이다.
          1. _completion_ 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection">
  <h1>반사 (Reflection)</h1>

  <emu-clause id="sec-reflect-object">
    <h1>Reflect 객체 (The Reflect Object)</h1>
    <p>Reflect 객체:</p>
    <ul>
      <li><dfn>%Reflect%</dfn>이다.</li>
      <li>전역 객체의 *"Reflect"* 프로퍼티 초기 값이다.</li>
      <li>일반 객체이다.</li>
      <li>[[Prototype]] 내부 슬롯 값이 %Object.prototype%이다.</li>
      <li>함수 객체가 아니다.</li>
      <li>[[Construct]] 내부 메서드가 없다; `new` 연산자로 생성자로 사용할 수 없다.</li>
      <li>[[Call]] 내부 메서드가 없다; 함수로 호출될 수 없다.</li>
    </ul>

    <emu-clause id="sec-reflect.apply">
      <h1>Reflect.apply ( _target_, _thisArgument_, _argumentsList_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. IsCallable(_target_) 이 *false*이면 *TypeError* 예외를 던진다.
        1. _args_ 를 ? CreateListFromArrayLike(_argumentsList_)로 둔다.
        1. PrepareForTailCall()을 수행한다.
        1. ? Call(_target_, _thisArgument_, _args_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.construct">
      <h1>Reflect.construct ( _target_, _argumentsList_ [ , _newTarget_ ] )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. IsConstructor(_target_) 가 *false*이면 *TypeError* 예외를 던진다.
        1. _newTarget_ 이 존재하지 않으면 _newTarget_ 을 _target_ 으로 설정한다.
        1. 아니고 IsConstructor(_newTarget_) 이 *false*이면 *TypeError* 예외를 던진다.
        1. _args_ 를 ? CreateListFromArrayLike(_argumentsList_)로 둔다.
        1. ? Construct(_target_, _args_, _newTarget_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.defineproperty">
      <h1>Reflect.defineProperty ( _target_, _propertyKey_, _attributes_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _key_ 를 ? ToPropertyKey(_propertyKey_) 로 둔다.
        1. _desc_ 를 ? ToPropertyDescriptor(_attributes_) 로 둔다.
        1. ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.deleteproperty">
      <h1>Reflect.deleteProperty ( _target_, _propertyKey_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _key_ 를 ? ToPropertyKey(_propertyKey_) 로 둔다.
        1. ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_key_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.get">
      <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _key_ 를 ? ToPropertyKey(_propertyKey_) 로 둔다.
        1. _receiver_ 가 존재하지 않으면
          1. _receiver_ 를 _target_ 으로 설정한다.
        1. ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_key_, _receiver_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getownpropertydescriptor">
      <h1>Reflect.getOwnPropertyDescriptor ( _target_, _propertyKey_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _key_ 를 ? ToPropertyKey(_propertyKey_) 로 둔다.
        1. _desc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
        1. FromPropertyDescriptor(_desc_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getprototypeof">
      <h1>Reflect.getPrototypeOf ( _target_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]()</emu-meta> 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.has">
      <h1>Reflect.has ( _target_, _propertyKey_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _key_ 를 ? ToPropertyKey(_propertyKey_) 로 둔다.
        1. ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_key_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.isextensible">
      <h1>Reflect.isExtensible ( _target_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. ? <emu-meta effects="user-code">_target_.[[IsExtensible]]()</emu-meta> 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.ownkeys">
      <h1>Reflect.ownKeys ( _target_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _keys_ 를 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
        1. CreateArrayFromList(_keys_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.preventextensions">
      <h1>Reflect.preventExtensions ( _target_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta> 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.set">
      <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _key_ 를 ? ToPropertyKey(_propertyKey_) 로 둔다.
        1. _receiver_ 가 존재하지 않으면
          1. _receiver_ 를 _target_ 으로 설정한다.
        1. ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.setprototypeof">
      <h1>Reflect.setPrototypeOf ( _target_, _proto_ )</h1>
      <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외를 던진다.
        1. _proto_ 가 Object 가 아니고 *null* 도 아니면 *TypeError* 예외를 던진다.
        1. ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-reflect-@@tostringtag" id="sec-reflect-%symbol.tostringtag%">
      <h1>Reflect [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% 프로퍼티 초기 값은 문자열 *"Reflect"* 이다.</p>
      <p>이 프로퍼티의 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-objects">
    <h1>Proxy 객체 (Proxy Objects)</h1>

    <emu-clause id="sec-proxy-constructor">
      <h1>Proxy 생성자 (The Proxy Constructor)</h1>
      <p>Proxy 생성자:</p>
      <ul>
        <li><dfn>%Proxy%</dfn>이다.</li>
        <li>전역 객체의 *"Proxy"* 프로퍼티 초기 값이다.</li>
        <li>생성자로 호출될 때 새 Proxy 객체를 생성·초기화한다.</li>
        <li>함수로 호출하도록 의도되지 않았으며 그렇게 호출하면 예외를 던진다.</li>
      </ul>

      <emu-clause id="sec-proxy-target-handler">
        <h1>Proxy ( _target_, _handler_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 *TypeError* 예외를 던진다.
          1. ? ProxyCreate(_target_, _handler_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-proxy-constructor">
      <h1>Proxy 생성자의 프로퍼티 (Properties of the Proxy Constructor)</h1>
      <p>Proxy 생성자:</p>
      <ul>
        <li>[[Prototype]] 내부 슬롯 값이 %Function.prototype%이다.</li>
        <li>*"prototype"* 프로퍼티가 없다 (Proxy 객체는 초기화가 필요한 [[Prototype]] 내부 슬롯을 갖지 않는다).</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-proxy.revocable" oldids="sec-proxy-revocation-functions">
        <h1>Proxy.revocable ( _target_, _handler_ )</h1>
        <p>이 함수는 취소(revocable) 가능한 Proxy 객체를 생성한다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _proxy_ 를 ? ProxyCreate(_target_, _handler_) 로 둔다.
          1. _revokerClosure_ 를 아무 것도 포획하지 않고 매개변수 없는 새로운 Abstract Closure 로 두어 호출 시 다음 단계를 수행하게 한다:
            1. _F_ 를 활성 함수 객체로 둔다.
            1. _p_ 를 _F_.[[RevocableProxy]] 로 둔다.
            1. _p_ 가 *null* 이면 NormalCompletion(*undefined*) 를 반환한다.
            1. _F_.[[RevocableProxy]] 를 *null* 로 설정한다.
            1. Assert: _p_ 는 Proxy 특이(exotic) 객체이다.
            1. _p_.[[ProxyTarget]] 을 *null* 로 설정한다.
            1. _p_.[[ProxyHandler]] 를 *null* 로 설정한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _revoker_ 를 CreateBuiltinFunction(_revokerClosure_, 0, *""*, « [[RevocableProxy]] ») 로 둔다.
          1. _revoker_.[[RevocableProxy]] 를 _proxy_ 로 설정한다.
          1. _result_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ! CreateDataPropertyOrThrow(_result_, *"proxy"*, _proxy_) 를 수행한다.
          1. ! CreateDataPropertyOrThrow(_result_, *"revoke"*, _revoker_) 를 수행한다.
          1. _result_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-module-namespace-objects">
    <h1>모듈 네임스페이스 객체 (Module Namespace Objects)</h1>
    <p>모듈 네임스페이스 객체는 모듈의 내보낸 바인딩에 속성 기반 런타임 접근을 제공하는 모듈 네임스페이스 특이 객체이다. 이를 위한 생성자 함수는 없다. 대신 |NameSpaceImport| 를 포함하는 |ImportDeclaration| 으로 가져온 각 모듈마다 이러한 객체가 생성된다.</p>
    <p><emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> 에 명시된 프로퍼티 외에 각 모듈 네임스페이스 객체는 다음 자체 프로퍼티를 가진다:</p>

    <emu-clause oldids="sec-@@tostringtag" id="sec-%symbol.tostringtag%">
      <h1>%Symbol.toStringTag%</h1>
      <p>%Symbol.toStringTag% 프로퍼티 초기 값은 문자열 *"Module"* 이다.</p>
      <p>이 프로퍼티 특성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }이다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-memory-model">
  <h1>메모리 모델 (Memory Model)</h1>
  <p>메모리 일관성 모델 또는 <dfn>memory model</dfn> 은 SharedArrayBuffer 로 백업된 TypedArray 인스턴스 접근과 Atomics 객체의 메서드를 통해 발생하는 Shared Data Block 이벤트의 가능한 순서를 지정한다. 프로그램에 (아래 정의된) 데이터 레이스가 없을 때 이벤트들의 순서는 각 에이전트의 동작을 인터리빙한 것과 같이 순차적 일관성(sequentially consistent)으로 보인다. 프로그램에 데이터 레이스가 있을 때 공유 메모리 연산은 순차적 비일관성처럼 보일 수 있다. 예를 들어, 프로그램은 인과성 위반 동작 및 그 밖의 놀라운 현상을 보일 수 있다. 이러한 놀라움은 컴파일러 변환과 CPU 설계(예: 순서 재배치 실행 및 추측 실행)에서 비롯된다. 메모리 모델은 프로그램이 순차적 일관성 동작을 보이는 정확한 조건과 데이터 레이스에서 읽힐 수 있는 가능한 값들을 모두 정의한다. 즉, 정의되지 않은 동작은 없다.</p>
  <p>메모리 모델은 SharedArrayBuffer 의 추상 연산 또는 평가 중 Atomics 객체 메서드에 의해 도입된 이벤트에 대한 관계 제약으로 정의된다.</p>
  <emu-note>
    <p>이 절은 SharedArrayBuffer 추상 연산이 도입하는 이벤트에 대한 공리적(axiomatic) 모델을 제공한다. 모델은 명세의 나머지와 달리 알고리즘적으로 표현될 수 없음을 강조해야 한다. 추상 연산에 의한 비결정적 이벤트 도입은 ECMAScript 평가의 실행 의미와 메모리 모델의 공리적 의미 사이의 인터페이스이다. 이러한 이벤트의 의미는 평가 내 모든 이벤트의 그래프를 고려하여 정의된다. 이것들은 정적 의미(Static Semantics)나 런타임 의미(Runtime Semantics)가 아니다. 입증된 알고리즘 구현이 아니라 특정 이벤트 그래프가 허용되는지 금지되는지를 결정하는 제약 집합이다.</p>
  </emu-note>

  <emu-clause id="sec-memory-model-fundamentals">
    <h1>메모리 모델 기초 (Memory Model Fundamentals)</h1>
    <p>공유 메모리 접근(읽기/쓰기)은 아래에서 정의되는 두 그룹, atomic 접근과 data 접근으로 나뉜다. Atomic 접근은 순차적 일관성을 가지며, 즉 에이전트 클러스터의 모든 에이전트가 동의하는 엄격한 전체 순서가 있다. 비-atomic 접근은 모든 에이전트가 동의하는 엄격한 전체 순서가 없으므로 정렬되지(unordered) 않는다.</p>
    <emu-note>
      <p>순차적 일관성과 unordered 보다 약하거나 강한(예: release-acquire) 순서는 지원되지 않는다.</p>
    </emu-note>
    <p><dfn variants="Shared Data Block events">Shared Data Block event</dfn> 는 <dfn>ReadSharedMemory</dfn>, <dfn>WriteSharedMemory</dfn> 또는 <dfn>ReadModifyWriteSharedMemory</dfn> Record 이다.</p>

    <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory 이벤트 필드 (ReadSharedMemory Event Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~ 또는 ~unordered~</td>
          <td>이벤트에 대해 메모리 모델이 보장하는 가장 약한 순서.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>Boolean</td>
          <td>이 이벤트가 동일 범위를 가진 여러 write 이벤트로부터 읽을 수 있는지 여부.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>Shared Data Block</td>
          <td>이벤트가 동작하는 블록.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>음이 아닌 정수</td>
          <td>[[Block]] 내 읽기의 바이트 주소.</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>음이 아닌 정수</td>
          <td>읽기의 크기.</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory 이벤트 필드 (WriteSharedMemory Event Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~, ~unordered~, 또는 ~init~</td>
          <td>이벤트에 대해 메모리 모델이 보장하는 가장 약한 순서.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>Boolean</td>
          <td>이 이벤트가 동일 범위를 가진 여러 read 이벤트로부터 읽힐 수 있는지 여부.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>Shared Data Block</td>
          <td>이벤트가 동작하는 블록.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>음이 아닌 정수</td>
          <td>[[Block]] 내 쓰기의 바이트 주소.</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>음이 아닌 정수</td>
          <td>쓰기의 크기.</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>바이트 값 List</td>
          <td>다른 이벤트가 읽을 바이트 값 List.</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory 이벤트 필드 (ReadModifyWriteSharedMemory Event Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~</td>
          <td>Read-modify-write 이벤트는 항상 순차적 일관성.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>*true*</td>
          <td>Read-modify-write 이벤트는 tear 될 수 없다.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>Shared Data Block</td>
          <td>이벤트가 동작하는 블록.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>음이 아닌 정수</td>
          <td>[[Block]] 내 read-modify-write 의 바이트 주소.</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>음이 아닌 정수</td>
          <td>read-modify-write 의 크기.</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>바이트 값 List</td>
          <td>[[ModifyOp]] 에 전달될 바이트 값 List.</td>
        </tr>
        <tr>
          <td>[[ModifyOp]]</td>
          <td>read-modify-write 수정 함수</td>
          <td>읽은 바이트 List 와 [[Payload]] 로부터 수정된 바이트 List 를 반환하는 추상 클로저.</td>
        </tr>
      </table>
    </emu-table>

    <p>이러한 이벤트는 추상 연산 또는 Atomics 객체 메서드에 의해 도입된다.</p>
    <p>일부 연산은 <dfn>Synchronize</dfn> 이벤트도 도입할 수 있다. <dfn variants="Synchronize events">Synchronize event</dfn> 는 필드가 없으며, 다른 이벤트의 허용 순서를 직접 제한하기 위해 존재한다.</p>
    <p>Shared Data Block 및 Synchronize 이벤트 외에 호스트 특화 이벤트가 있다.</p>
    <p>ReadSharedMemory, WriteSharedMemory, ReadModifyWriteSharedMemory 이벤트의 범위(range)는 [[ByteIndex]] 부터 [[ByteIndex]] + [[ElementSize]] - 1 까지의 연속 정수 집합이다. 두 이벤트의 [[Block]] 이 같고 범위가 원소별 동일하면 범위가 같다. [[Block]] 이 같고 범위가 동일하지 않으며 교집합이 비어 있지 않으면 범위가 겹친다(overlapping). [[Block]] 이 다르거나 범위가 같지도 겹치지도 않으면 범위는 분리(disjoint)되었다.</p>
    <emu-note>
      <p>계정해야 할 호스트 특화 동기화 이벤트 예: 한 에이전트에서 다른 에이전트로 SharedArrayBuffer 를 보내기(브라우저의 `postMessage`), 에이전트 시작/종료, 공유 메모리 외 채널을 통한 에이전트 클러스터 내 통신. 특정 실행 _execution_ 에 대해 이러한 이벤트는 host-synchronizes-with 엄격 부분 순서로 호스트에 의해 제공된다. 추가로, 호스트는 _execution_.[[EventList]] 에 호스트 특화 동기화 이벤트를 추가하여 is-agent-order-before 관계에 참여할 수 있다.</p>
    </emu-note>
    <p>이벤트는 아래에 정의된 관계에 의해 후보 실행 내에서 순서화된다.</p>
  </emu-clause>

  <emu-clause id="sec-agent-event-records">
    <h1>에이전트 이벤트 레코드 (Agent Events Records)</h1>
    <p><dfn variants="Agent Events Records">Agent Events Record</dfn> 는 다음 필드를 가진 Record 이다.</p>
    <emu-table id="table-agent-events-records" caption="Agent Events Record 필드 (Agent Events Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[AgentSignifier]]</td>
          <td>에이전트 식별자</td>
          <td>이 순서를 발생시킨 평가의 에이전트.</td>
        </tr>
        <tr>
          <td>[[EventList]]</td>
          <td>이벤트 List</td>
          <td>평가 중 리스트에 이벤트가 추가된다.</td>
        </tr>
        <tr>
          <td>[[AgentSynchronizesWith]]</td>
          <td>Synchronize 이벤트 쌍 List</td>
          <td>운영상 의미가 도입한 동기화 관계.</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-chosen-value-records">
    <h1>Chosen Value 레코드 (Chosen Value Records)</h1>
    <p><dfn variants="Chosen Value Records">Chosen Value Record</dfn> 는 다음 필드를 가진 Record 이다.</p>
    <emu-table id="table-chosen-value-records" caption="Chosen Value Record 필드 (Chosen Value Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Event]]</td>
          <td>Shared Data Block event</td>
          <td>이 선택 값에 대해 도입된 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트.</td>
        </tr>
        <tr>
          <td>[[ChosenValue]]</td>
          <td>바이트 값 List</td>
          <td>평가 동안 비결정적으로 선택된 바이트.</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-candidate-executions">
    <h1>후보 실행 (Candidate Executions)</h1>
    <p><dfn variants="candidate executions">candidate execution</dfn> 은 에이전트 클러스터 평가의 다음 필드를 가진 Record 이다.</p>
    <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record 필드 (Candidate Execution Record Fields)">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[EventsRecords]]</td>
          <td>Agent Events Records List</td>
          <td>평가 중 추가된 이벤트 List 를 에이전트에 매핑.</td>
        </tr>
        <tr>
          <td>[[ChosenValues]]</td>
          <td>Chosen Value Records List</td>
          <td>평가 중 선택된 바이트 값 List 를 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트에 매핑.</td>
        </tr>
      </table>
    </emu-table>

    <p><dfn variants="empty candidate executions">empty candidate execution</dfn> 은 필드가 빈 List 인 candidate execution Record 이다.</p>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-the-memory-model" oldids="sec-synchronizeeventset">
    <h1>메모리 모델을 위한 추상 연산 (Abstract Operations for the Memory Model)</h1>

    <emu-clause id="sec-event-set" type="abstract operation">
      <h1>
        EventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _events_ 를 빈 Set 으로 둔다.
        1. _execution_.[[EventsRecords]] 의 각 Agent Events Record _aer_ 에 대해,
          1. _aer_.[[EventList]] 의 각 이벤트 _E_ 에 대해
            1. _E_ 를 _events_ 에 추가한다.
        1. _events_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedatablockeventset" type="abstract operation">
      <h1>
        SharedDataBlockEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _events_ 를 빈 Set 으로 둔다.
        1. EventSet(_execution_) 의 각 이벤트 _E_ 에 대해
          1. _E_ 가 ReadSharedMemory, WriteSharedMemory, ReadModifyWriteSharedMemory 이벤트이면 _E_ 를 _events_ 에 추가한다.
        1. _events_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hosteventset" type="abstract operation">
      <h1>
        HostEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _events_ 를 빈 Set 으로 둔다.
        1. EventSet(_execution_) 의 각 이벤트 _E_ 에 대해
          1. _E_ 가 SharedDataBlockEventSet(_execution_) 에 없으면 _E_ 를 _events_ 에 추가한다.
        1. _events_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-composewriteeventbytes" type="abstract operation">
      <h1>
        ComposeWriteEventBytes (
          _execution_: a candidate execution,
          _byteIndex_: a non-negative integer,
          _Ws_: a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _byteLocation_ 을 _byteIndex_ 로 둔다.
        1. _bytesRead_ 를 새 빈 List 로 둔다.
        1. _Ws_ 의 각 요소 _W_ 에 대해
          1. Assert: _W_ 는 자신의 범위에 _byteLocation_ 을 포함한다.
          1. _payloadIndex_ 를 _byteLocation_ - _W_.[[ByteIndex]] 로 둔다.
          1. _W_ 가 WriteSharedMemory 이벤트이면
            1. _byte_ 를 _W_.[[Payload]][_payloadIndex_] 로 둔다.
          1. 아니면
            1. Assert: _W_ 는 ReadModifyWriteSharedMemory 이벤트.
            1. _bytes_ 를 ValueOfReadEvent(_execution_, _W_) 로 둔다.
            1. _bytesModified_ 를 _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]) 로 둔다.
            1. _byte_ 를 _bytesModified_[_payloadIndex_] 로 둔다.
          1. _byte_ 를 _bytesRead_ 끝에 추가한다.
          1. _byteLocation_ 을 _byteLocation_ + 1 로 설정한다.
        1. _bytesRead_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>read-modify-write 수정 [[ModifyOp]] 는 ReadModifyWriteSharedMemory 이벤트를 도입하는 Atomics 객체의 함수 프로퍼티로 제공된다.</p>
      </emu-note>
      <emu-note>
        <p>이 추상 연산은 write 이벤트 List 를 바이트 값 List 로 합성한다. 이는 ReadSharedMemory 및 ReadModifyWriteSharedMemory 이벤트의 이벤트 의미에서 사용된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valueofreadevent" type="abstract operation">
      <h1>
        ValueOfReadEvent (
          _execution_: a candidate execution,
          _R_: a ReadSharedMemory or ReadModifyWriteSharedMemory event,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _Ws_ 를 _execution_ 에서 reads-bytes-from(_R_) 로 둔다.
        1. Assert: _Ws_ 는 길이가 _R_.[[ElementSize]] 와 같은 WriteSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 List 이다.
        1. ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_) 를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relations-of-candidate-executions">
    <h1>후보 실행의 관계 (Relations of Candidate Executions)</h1>

    <p>다음 관계와 수학적 함수는 특정 후보 실행 위에서 매개변수화되며 그 이벤트들을 순서화한다.</p>

    <emu-clause id="sec-agent-order">
      <h1>is-agent-order-before</h1>
      <p>후보 실행 _execution_ 에 대해, 그 <dfn>is-agent-order-before</dfn> 관계는 다음을 만족하는 최소 관계이다.</p>
      <ul>
        <li>이벤트 _E_, _D_ 에 대해 _execution_.[[EventsRecords]] 의 어떤 Agent Events Record _aer_ 가 있어 _aer_.[[EventList]] 에 _E_ 와 _D_ 둘 다 포함되고 _E_ 가 List 순서에서 _D_ 앞에 있으면 _E_ is-agent-order-before _D_ 이다.</li>
      </ul>

      <emu-note>
        <p>각 에이전트는 평가 중 per-agent 엄격 전체 순서로 이벤트를 도입한다. 이것은 그 엄격 전체 순서들의 합집합이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-reads-bytes-from" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>후보 실행 _execution_ 에 대해, 그 <em>reads-bytes-from</em> 함수는 SharedDataBlockEventSet(_execution_) 의 이벤트를 SharedDataBlockEventSet(_execution_) 내 이벤트 List 로 매핑하는 수학적 함수이며 다음 조건을 만족한다.</p>
      <ul>
        <li>
          <p>SharedDataBlockEventSet(_execution_) 내 각 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _R_ 에 대해 reads-bytes-from(_R_) 는 길이가 _R_.[[ElementSize]] 인 List 로서 다음을 모두 만족하는 WriteSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _Ws_ 를 원소로 가진다.</p>
          <ul>
            <li>_Ws_ 의 인덱스 _i_ 의 각 이벤트 _W_ 는 _R_.[[ByteIndex]] + _i_ 를 자신의 범위에 가진다.</li>
            <li>_R_ 은 _Ws_ 안에 없다.</li>
          </ul>
        </li>
      </ul>
      <p>후보 실행은 항상 reads-bytes-from 함수를 허용한다.</p>
    </emu-clause>

    <emu-clause id="sec-reads-from">
      <h1>reads-from</h1>
      <p>후보 실행 _execution_ 에 대해, 그 <dfn>reads-from</dfn> 관계는 다음을 만족하는 최소 관계이다.</p>
      <ul>
        <li>이벤트 _R_, _W_ 에 대해 SharedDataBlockEventSet(_execution_) 이 둘 다 포함하고 reads-bytes-from(_R_) 이 _W_ 를 포함하면 _R_ reads-from _W_ 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>후보 실행 _execution_ 에 대해, 그 <dfn>host-synchronizes-with</dfn> 관계는 적어도 다음을 만족하는 호스트 제공 엄격 부분 순서이다.</p>
      <ul>
        <li>_E_ host-synchronizes-with _D_ 이면 HostEventSet(_execution_) 이 _E_ 와 _D_ 를 포함한다.</li>
        <li>host-synchronizes-with 와 is-agent-order-before 의 합집합은 순환이 없다.</li>
      </ul>

      <emu-note>
        <p>두 호스트 특화 이벤트 _E_, _D_ 에 대해 _E_ host-synchronizes-with _D_ 이면 _E_ happens-before _D_ 이다.</p>
      </emu-note>
      <emu-note>
        <p>이 관계는 HTML 워커 간 `postMessage` 같은 추가 동기화 메커니즘을 호스트가 제공할 수 있게 한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>후보 실행 _execution_ 에 대해, 그 <dfn>synchronizes-with</dfn> 관계는 다음을 만족하는 최소 관계이다.</p>
      <ul>
        <li>
          이벤트 _R_, _W_ 에 대해 _R_ reads-from _W_, _R_.[[Order]] 가 ~seq-cst~, _W_.[[Order]] 가 ~seq-cst~, 그리고 _R_, _W_ 범위가 같으면 _W_ synchronizes-with _R_.
        </li>
        <li>
          _execution_.[[EventsRecords]] 의 각 _eventsRecord_ 에 대해:
          <ul>
            <li>_eventsRecord_.[[AgentSynchronizesWith]] 가 (_S_, _Sw_) 를 포함하면 _S_ synchronizes-with _Sw_.</li>
          </ul>
        </li>
        <li>_execution_.[[HostSynchronizesWith]] 가 (_E_, _D_) 를 포함하면 _E_ synchronizes-with _D_.</li>
      </ul>

      <emu-note>
        <p>문헌 관례상 write 이벤트가 read 이벤트와 synchronizes-with 관계를 가진다.</p>
      </emu-note>

      <emu-note>
        <p>~init~ 이벤트는 이 관계에 참여하지 않고 happens-before 에 의해 직접 제약된다.</p>
      </emu-note>

      <emu-note>
        <p>reads-from 로 연결된 모든 ~seq-cst~ 이벤트가 synchronizes-with 로 연결되지는 않는다. 범위가 같은 경우에만 그렇다.</p>
      </emu-note>

      <emu-note>
        <p>_W_ synchronizes-with _R_ 라도 _R_ 은 _W_ 이외의 write 로부터 reads-from 할 수 있다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-happens-before">
      <h1>happens-before</h1>
      <p>후보 실행 _execution_ 에 대해, 그 <dfn>happens-before</dfn> 관계는 다음을 만족하는 최소 관계이다.</p>

      <ul>
        <li>
          <p>이벤트 _E_, _D_ 에 대해 다음 중 하나가 참이면 _E_ happens-before _D_:</p>
          <ul>
            <li>_E_ is-agent-order-before _D_.</li>
            <li>_E_ synchronizes-with _D_.</li>
            <li>SharedDataBlockEventSet(_execution_) 이 _E_, _D_ 를 모두 포함하고 _E_.[[Order]] 가 ~init~ 이며 _E_, _D_ 범위가 겹친다.</li>
            <li>이벤트 _F_ 가 존재하여 _E_ happens-before _F_ 그리고 _F_ happens-before _D_.</li>
          </ul>
        </li>
      </ul>

      <emu-note>
        <p>happens-before 는 agent-order 의 상위 집합이므로 후보 실행은 단일 스레드 평가 의미와 합치된다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-valid-executions">
    <h1>유효한 실행의 속성 (Properties of Valid Executions)</h1>

    <emu-clause id="sec-valid-chosen-reads">
      <h1>Valid Chosen Reads</h1>
      <p>후보 실행 _execution_ 이 아래 알고리즘이 *true* 를 반환하면 valid chosen reads 를 가진다.</p>
      <emu-alg>
        1. SharedDataBlockEventSet(_execution_) 의 각 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _R_ 에 대해
          1. _chosenValueRecord_ 를 _execution_.[[ChosenValues]] 중 [[Event]] 가 _R_ 인 요소로 둔다.
          1. _chosenValue_ 를 _chosenValueRecord_.[[ChosenValue]] 로 둔다.
          1. _readValue_ 를 ValueOfReadEvent(_execution_, _R_) 로 둔다.
          1. _chosenLen_ 을 _chosenValue_ 의 원소 수로 둔다.
          1. _readLen_ 을 _readValue_ 의 원소 수로 둔다.
          1. _chosenLen_ ≠ _readLen_ 이면
            1. *false* 반환.
          1. 0 이상 _chosenLen_ 미만 정수 _i_ 중 일부에 대해 _chosenValue_[_i_] ≠ _readValue_[_i_] 이면
            1. *false* 반환.
        1. *true* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-coherent-reads">
      <h1>Coherent Reads</h1>
      <p>후보 실행 _execution_ 이 아래 알고리즘이 *true* 면 coherent reads 를 가진다.</p>
      <emu-alg>
        1. SharedDataBlockEventSet(_execution_) 의 각 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _R_ 에 대해
          1. _Ws_ 를 reads-bytes-from(_R_) 로 둔다.
          1. _byteLocation_ 을 _R_.[[ByteIndex]] 로 둔다.
          1. _Ws_ 의 각 요소 _W_ 에 대해
            1. _R_ happens-before _W_ 이면 *false* 반환.
            1. _byteLocation_ 을 범위에 가지는 WriteSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _V_ 가 존재하고 _W_ happens-before _V_ 및 _V_ happens-before _R_ 이면 *false* 반환.
            1. _byteLocation_ 을 _byteLocation_ + 1 로 설정.
        1. *true* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tear-free-aligned-reads">
      <h1>Tear Free Reads</h1>
      <p>후보 실행 _execution_ 이 아래 알고리즘이 *true* 면 tear free reads 를 가진다.</p>
      <emu-alg>
        1. SharedDataBlockEventSet(_execution_) 의 각 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _R_ 에 대해
          1. _R_.[[NoTear]] 가 *true* 이면
            1. _R_.[[ByteIndex]] % _R_.[[ElementSize]] == 0 임을 단언.
            1. _R_ reads-from _W_ 이고 _W_.[[NoTear]] 가 *true* 인 각 이벤트 _W_ 에 대해
              1. _R_, _W_ 범위가 같고 이벤트 _V_ 가 존재하여 _V_, _W_ 범위가 같고 _V_.[[NoTear]] *true* 이며 _W_ ≠ _V_, 그리고 _R_ reads-from _V_ 이면 *false* 반환.
        1. *true* 반환.
      </emu-alg>

      <emu-note>
        <p>이벤트의 [[NoTear]] 가 *true* 는 해당 이벤트가 정수 TypedArray 접근으로 도입되었을 때이고, 부동소수 TypedArray 또는 DataView 접근이면 *false* 이다.</p>
        <p>직관적으로 이는 정렬된(integer TypedArray) 방식으로 메모리 범위를 접근할 때 동일 범위를 가진 여러 write 이벤트와 경쟁 중 한 write 이벤트가 “승리”해야 함을 의미한다. 보다 정확히, 정렬된 read 이벤트는 같은 범위를 가진 서로 다른 여러 write 이벤트들의 바이트를 혼합해 읽을 수 없다. 다만 겹치는 범위를 가진 여러 write 이벤트로부터 읽는 것은 가능하다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-memory-order">
      <h1>순차적 일관 Atomics (Sequentially Consistent Atomics)</h1>
      <p>후보 실행 _execution_ 에 대해 <dfn>is-memory-order-before</dfn> 는 EventSet(_execution_) 의 모든 이벤트에 대한 엄격 전체 순서이며 다음을 만족한다.</p>
      <ul>
        <li>_E_ happens-before _D_ 이면 _E_ is-memory-order-before _D_.</li>
        <li>
          <p>_R_ reads-from _W_ 일 때, SharedDataBlockEventSet(_execution_) 내 ~seq-cst~ 인 어떤 WriteSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트 _V_ 가 존재하여 _W_ is-memory-order-before _V_, _V_ is-memory-order-before _R_ 이고 다음 중 하나가 참인 경우는 없다.</p>
          <ul>
            <li>_W_ synchronizes-with _R_ 이고 _V_, _R_ 범위가 같다.</li>
            <li>_W_, _V_ 모두 _R_ happens-before 이고 _W_.[[Order]] 가 ~seq-cst~, 그리고 _W_, _V_ 범위가 같다.</li>
            <li>_W_ happens-before _R_ 및 _W_ happens-before _V_, _R_.[[Order]] 가 ~seq-cst~ 이고 _V_, _R_ 범위가 같다.</li>
          </ul>
          <emu-note>
            <p>이 항목은 동일 범위의 ~seq-cst~ 이벤트를 추가로 제한한다.</p>
          </emu-note>
        </li>
        <li>
          <p>SharedDataBlockEventSet(_execution_) 의 각 _W_ (WriteSharedMemory 또는 ReadModifyWriteSharedMemory) 에 대해 _W_.[[Order]] 가 ~seq-cst~ 이면 _W_ 보다 memory-order 앞서는 동일 범위의 ReadSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트가 무한히 많지 않다.</p>
          <emu-note>
            <p>이 항목과 에이전트의 forward progress 보장은 ~seq-cst~ write 가 유한 시간 내 동일 범위 ~seq-cst~ read 에게 가시적이 되는 liveness 조건을 보장한다.</p>
          </emu-note>
        </li>
      </ul>
      <p>후보 실행이 is-memory-order-before 관계를 허용하면 sequentially consistent atomics 를 가진다.</p>

      <emu-note>
        <p>is-memory-order-before 는 EventSet(_execution_) 의 모든 이벤트를 포함하지만 happens-before 나 synchronizes-with 로 제약되지 않은 이벤트는 순서에서 어디든 위치할 수 있다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valid-executions">
      <h1>유효한 실행 (Valid Executions)</h1>
      <p>후보 실행 _execution_ 이 아래 모두 참이면 유효 실행(또는 실행)이다.</p>
      <ul>
        <li>호스트가 _execution_ 에 대한 host-synchronizes-with 관계를 제공.</li>
        <li>_execution_ 이 엄격 부분 순서인 happens-before 관계를 허용.</li>
        <li>_execution_ 은 valid chosen reads.</li>
        <li>_execution_ 은 coherent reads.</li>
        <li>_execution_ 은 tear free reads.</li>
        <li>_execution_ 은 sequentially consistent atomics.</li>
      </ul>
      <p>모든 프로그램은 적어도 하나의 유효 실행을 가진다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-races">
    <h1>경쟁 (Races)</h1>
    <p>실행 _execution_ 과 SharedDataBlockEventSet(_execution_) 에 포함된 이벤트 _E_, _D_ 에 대해 아래 알고리즘이 *true* 를 반환하면 _E_, _D_ 는 <em>race</em> 관계이다.</p>
    <emu-alg>
      1. _E_, _D_ 가 동일 Shared Data Block 이벤트가 아니면
        1. _E_ happens-before _D_ 및 _D_ happens-before _E_ 둘 다가 아닌 경우
          1. _E_, _D_ 가 모두 WriteSharedMemory 또는 ReadModifyWriteSharedMemory 이벤트이고 범위가 분리되지 않으면
            1. *true* 반환.
          1. _E_ reads-from _D_ 또는 _D_ reads-from _E_ 이면
            1. *true* 반환.
      1. *false* 반환.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-races">
    <h1>데이터 레이스 (Data Races)</h1>
    <p>실행 _execution_ 과 SharedDataBlockEventSet(_execution_) 에 포함된 이벤트 _E_, _D_ 에 대해 아래 알고리즘이 *true* 이면 _E_, _D_ 는 <dfn>data race</dfn> 관계이다.</p>
    <emu-alg>
      1. _E_, _D_ 가 <emu-xref href="#sec-races">race</emu-xref> 이면
        1. _E_.[[Order]] 가 ~seq-cst~ 가 아니거나 _D_.[[Order]] 가 ~seq-cst~ 가 아니면
          1. *true* 반환.
        1. _E_, _D_ 범위가 겹치면
          1. *true* 반환.
      1. *false* 반환.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-race-freedom">
    <h1>데이터 레이스 자유 (Data Race Freedom)</h1>
    <p>실행 _execution_ 이 SharedDataBlockEventSet(_execution_) 내 어떤 두 이벤트도 data race 가 아니면 <dfn>data race free</dfn> 이다.</p>
    <p>모든 실행이 data race free 이면 프로그램은 data race free 이다.</p>
    <p>메모리 모델은 data race free 프로그램에 대해 모든 이벤트의 순차적 일관성을 보장한다.</p>
  </emu-clause>

  <emu-clause id="sec-shared-memory-guidelines">
    <h1>공유 메모리 가이드라인 (Shared Memory Guidelines)</h1>
    <emu-note>
      <p>다음은 공유 메모리를 사용하는 ECMAScript 프로그래머를 위한 지침이다.</p>
      <p>프로그램을 data race free 로 유지(즉 동일 메모리 위치에서 동시 비-atomic 연산이 불가능하도록)할 것을 권장한다. Data race free 프로그램은 각 에이전트 평가 의미 단계가 서로 인터리빙되는 의미를 갖는다. 이런 경우 메모리 모델 세부사항을 이해할 필요가 없다.</p>
      <p>더 일반적으로, 프로그램이 data race free 가 아니어도 atomic 연산이 어떤 data race 에도 관여하지 않고 경쟁하는 연산이 모두 동일 접근 크기라면 예측 가능한 동작을 가질 수 있다. 가장 단순한 방법은 atomic 과 비-atomic 연산이 다른 메모리 셀을 사용하고 서로 다른 크기의 atomic 접근이 동시에 같은 셀을 접근하지 않게 하는 것이다. 즉 가능한 한 공유 메모리를 강한 타입처럼 다루어야 한다. 경쟁 중 비-atomic 접근의 순서와 타이밍에 의존할 수는 없지만 강한 타입처럼 다루면 값이 “찢어지는(tear)” 일은 없다.</p>
    </emu-note>

    <emu-note>
      <p>다음은 공유 메모리를 사용하는 프로그램에 대한 컴파일러 변환을 작성하는 ECMAScript 구현자를 위한 지침이다.</p>
      <p>단일 에이전트 환경에서 유효한 대부분의 프로그램 변환이 다중 에이전트 환경에서도 유효하도록 허용하는 것이 바람직하다. 종종 이러한 변환은 판단이 어렵다. 우리는 메모리 모델이 함축하거나 그보다 강한 규칙 몇 가지를 개략적으로 제시한다.</p>
      <p><dfn variants="agent-order slices">agent-order slice</dfn> 를 단일 에이전트에 속하는 is-agent-order-before 부분집합이라 하자.</p>
      <p>read 이벤트의 <dfn>possible read values</dfn> 는 모든 유효 실행에서 그 이벤트에 대한 ValueOfReadEvent 값들의 집합이다.</p>
      <p>공유 메모리가 없을 때 유효한 agent-order slice 변환은 아래 예외를 제외하고 공유 메모리 존재 시에도 유효하다.</p>
      <ul>
        <li>
          <p><em>Atomics 는 고정</em>: 변환은 agent-order slice 의 ~seq-cst~ 이벤트를 그 ~unordered~ 연산과 재배열하거나 서로 재배열하거나 제거해서는 안 된다.</p>
          <p>(실제로 재배열 금지는 ~seq-cst~ 연산이 동기화임을 가정하게 강제한다.)</p>
        </li>
        <li>
          <p><em>읽기는 안정적</em>: 주어진 shared memory read 는 한 실행에서 단일 값만 관찰해야 한다.</p>
        </li>
        <li>
          <p><em>쓰기는 안정적</em>: 관찰 가능한 모든 shared memory write 는 실행의 프로그램 의미에서 비롯해야 한다.</p>
        </li>
        <li>
          <p><em>가능한 읽기 값은 공집합이 아님</em>: 변환은 가능한 읽기 값 집합을 비게 할 수 없다.</p>
        </li>
      </ul>
      <p>여전히 유효한 변환 예: 동일 위치 다수 비-atomic 읽기 병합, 비-atomic 읽기 재배열, 추측 비-atomic 읽기 도입, 동일 위치 다수 비-atomic 쓰기 병합, 서로 다른 위치 비-atomic 쓰기 재배열, 루프 밖으로 비-atomic 읽기 hoist (종료 영향 있어도). 일반적으로 alias 된 TypedArray 는 위치 구분을 어렵게 한다.</p>
    </emu-note>

    <emu-note>
      <p>다음은 공유 메모리 접근에 대한 기계어 코드를 생성하는 ECMAScript 구현자를 위한 지침이다.</p>
      <p>ARM 또는 Power 보다 약하지 않은 메모리 모델을 가진 아키텍처에서 비-atomic store/load 는 일반 store/load 로 컴파일할 수 있다. Atomic store/load 는 순차적 일관성을 보장하는 명령으로 컴파일한다. 없으면 메모리 배리어 사용. Read-modify-write 는 아키텍처의 read-modify-write 명령(예: x86 LOCK prefix, ARM load-exclusive/store-exclusive, Power load-link/store-conditional)으로 컴파일.</p>
      <p>구체적으로 메모리 모델은 다음과 같은 코드 생성을 허용한다.</p>
      <ul>
        <li>프로그램의 모든 atomic 연산은 필요하다고 가정.</li>
        <li>Atomic 연산은 서로 또는 비-atomic 과 재배열되지 않는다.</li>
        <li>함수는 항상 atomic 연산 수행 가능하다고 가정.</li>
        <li>Atomic 연산은 더 큰 데이터의 read-modify-write 로 구현되지 않는다(플랫폼에 그 크기 atomic 없으면 lock-free 아니게 구현).</li>
      </ul>
      <p>단순 코드 생성 패턴:</p>
      <ul>
        <li>일반 load/store → 단일 load/store 명령.</li>
        <li>Lock-free atomic load/store → 전체 펜스, load/store, 전체 펜스.</li>
        <li>Lock-free atomic RMW → 전체 펜스, atomic RMW 시퀀스, 전체 펜스.</li>
        <li>Non-lock-free atomic → 스핀락 획득, 전체 펜스, 비-atomic load/store 시리즈, 전체 펜스, 스핀락 해제.</li>
      </ul>
      <p>이 매핑은 주소 범위에 대한 atomic 연산이 비-atomic 쓰기나 다른 크기 atomic 과 race 하지 않는 한 올바르다. 메모리 모델은 race 에 관여한 atomic 을 비-atomic 수준으로 강등하여 충분하다. 다만 이 단순 매핑은 atomic 연산을 순차적 일관성 펜스로 사용할 수 있게 하는 등 꽤 강하다.</p>
      <p>허용되는 로컬 개선 예:</p>
      <ul>
        <li>플랫폼 의존 중복 펜스 제거 (예: x86 에서 load/store 전후 펜스 일부 생략 등).</li>
        <li>대부분 플랫폼은 필요한 모든 크기 lock-free atomic 지원.</li>
        <li>두 back-to-back 펜스 → 하나로 대체; x86 에서 store 뒤 펜스만 유지 등.</li>
      </ul>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-grammar-summary">
  <h1>문법 요약</h1>

  <emu-annex id="sec-lexical-grammar">
    <h1>어휘 문법</h1>
    <emu-prodref name="SourceCharacter"></emu-prodref>
    <emu-prodref name="InputElementDiv"></emu-prodref>
    <emu-prodref name="InputElementRegExp"></emu-prodref>
    <emu-prodref name="InputElementRegExpOrTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementHashbangOrRegExp"></emu-prodref>
    <emu-prodref name="WhiteSpace"></emu-prodref>
    <emu-prodref name="LineTerminator"></emu-prodref>
    <emu-prodref name="LineTerminatorSequence"></emu-prodref>
    <emu-prodref name="Comment"></emu-prodref>
    <emu-prodref name="MultiLineComment"></emu-prodref>
    <emu-prodref name="MultiLineCommentChars"></emu-prodref>
    <emu-prodref name="PostAsteriskCommentChars"></emu-prodref>
    <emu-prodref name="MultiLineNotAsteriskChar"></emu-prodref>
    <emu-prodref name="MultiLineNotForwardSlashOrAsteriskChar"></emu-prodref>
    <emu-prodref name="SingleLineComment"></emu-prodref>
    <emu-prodref name="SingleLineCommentChars"></emu-prodref>
    <emu-prodref name="SingleLineCommentChar"></emu-prodref>
    <emu-prodref name="HashbangComment"></emu-prodref>
    <emu-prodref name="CommonToken"></emu-prodref>
    <emu-prodref name="PrivateIdentifier"></emu-prodref>
    <emu-prodref name="IdentifierName"></emu-prodref>
    <emu-prodref name="IdentifierStart"></emu-prodref>
    <emu-prodref name="IdentifierPart"></emu-prodref>
    <emu-prodref name="IdentifierStartChar"></emu-prodref>
    <emu-prodref name="IdentifierPartChar"></emu-prodref>
    <emu-prodref name="AsciiLetter"></emu-prodref>
    <emu-prodref name="UnicodeIDStart"></emu-prodref>
    <emu-prodref name="UnicodeIDContinue"></emu-prodref>
    <emu-prodref name="ReservedWord"></emu-prodref>
    <emu-prodref name="Punctuator"></emu-prodref>
    <emu-prodref name="OptionalChainingPunctuator"></emu-prodref>
    <emu-prodref name="OtherPunctuator"></emu-prodref>
    <emu-prodref name="DivPunctuator"></emu-prodref>
    <emu-prodref name="RightBracePunctuator"></emu-prodref>
    <emu-prodref name="NullLiteral"></emu-prodref>
    <emu-prodref name="BooleanLiteral"></emu-prodref>
    <emu-prodref name="NumericLiteralSeparator"></emu-prodref>
    <emu-prodref name="NumericLiteral"></emu-prodref>
    <emu-prodref name="DecimalBigIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="BigIntLiteralSuffix"></emu-prodref>
    <emu-prodref name="DecimalLiteral"></emu-prodref>
    <emu-prodref name="DecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="DecimalDigits"></emu-prodref>
    <emu-prodref name="DecimalDigit"></emu-prodref>
    <emu-prodref name="NonZeroDigit"></emu-prodref>
    <emu-prodref name="ExponentPart"></emu-prodref>
    <emu-prodref name="ExponentIndicator"></emu-prodref>
    <emu-prodref name="SignedInteger"></emu-prodref>
    <emu-prodref name="BinaryIntegerLiteral"></emu-prodref>
    <emu-prodref name="BinaryDigits"></emu-prodref>
    <emu-prodref name="BinaryDigit"></emu-prodref>
    <emu-prodref name="OctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigits"></emu-prodref>
    <emu-prodref name="LegacyOctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonOctalDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="LegacyOctalLikeDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigit"></emu-prodref>
    <emu-prodref name="NonOctalDigit"></emu-prodref>
    <emu-prodref name="HexIntegerLiteral"></emu-prodref>
    <emu-prodref name="HexDigits"></emu-prodref>
    <emu-prodref name="HexDigit"></emu-prodref>
    <emu-prodref name="StringLiteral"></emu-prodref>
    <emu-prodref name="DoubleStringCharacters"></emu-prodref>
    <emu-prodref name="SingleStringCharacters"></emu-prodref>
    <emu-prodref name="DoubleStringCharacter"></emu-prodref>
    <emu-prodref name="SingleStringCharacter"></emu-prodref>
    <emu-prodref name="LineContinuation"></emu-prodref>
    <emu-prodref name="EscapeSequence"></emu-prodref>
    <emu-prodref name="CharacterEscapeSequence"></emu-prodref>
    <emu-prodref name="SingleEscapeCharacter"></emu-prodref>
    <emu-prodref name="NonEscapeCharacter"></emu-prodref>
    <emu-prodref name="EscapeCharacter"></emu-prodref>
    <emu-prodref name="LegacyOctalEscapeSequence"></emu-prodref>
    <emu-prodref name="NonZeroOctalDigit"></emu-prodref>
    <emu-prodref name="ZeroToThree"></emu-prodref>
    <emu-prodref name="FourToSeven"></emu-prodref>
    <emu-prodref name="NonOctalDecimalEscapeSequence"></emu-prodref>
    <emu-prodref name="HexEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="Hex4Digits"></emu-prodref>
    <emu-prodref name="RegularExpressionLiteral"></emu-prodref>
    <emu-prodref name="RegularExpressionBody"></emu-prodref>
    <emu-prodref name="RegularExpressionChars"></emu-prodref>
    <emu-prodref name="RegularExpressionFirstChar"></emu-prodref>
    <emu-prodref name="RegularExpressionChar"></emu-prodref>
    <emu-prodref name="RegularExpressionBackslashSequence"></emu-prodref>
    <emu-prodref name="RegularExpressionNonTerminator"></emu-prodref>
    <emu-prodref name="RegularExpressionClass"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChars"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChar"></emu-prodref>
    <emu-prodref name="RegularExpressionFlags"></emu-prodref>
    <emu-prodref name="Template"></emu-prodref>
    <emu-prodref name="NoSubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateHead"></emu-prodref>
    <emu-prodref name="TemplateSubstitutionTail"></emu-prodref>
    <emu-prodref name="TemplateMiddle"></emu-prodref>
    <emu-prodref name="TemplateTail"></emu-prodref>
    <emu-prodref name="TemplateCharacters"></emu-prodref>
    <emu-prodref name="TemplateCharacter"></emu-prodref>
    <emu-prodref name="TemplateEscapeSequence"></emu-prodref>
    <emu-prodref name="NotEscapeSequence"></emu-prodref>
    <emu-prodref name="NotCodePoint"></emu-prodref>
    <emu-prodref name="CodePoint"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-expressions">
    <h1>표현식</h1>
    <emu-prodref name="IdentifierReference"></emu-prodref>
    <emu-prodref name="BindingIdentifier"></emu-prodref>
    <emu-prodref name="LabelIdentifier"></emu-prodref>
    <emu-prodref name="Identifier"></emu-prodref>
    <emu-prodref name="PrimaryExpression"></emu-prodref>
    <emu-prodref name="CoverParenthesizedExpressionAndArrowParameterList"></emu-prodref>
    <p>
      생성식(production) 인스턴스<br>
      <emu-prodref name="PrimaryExpression" a="parencover"></emu-prodref><br>
      를 처리할 때 |CoverParenthesizedExpressionAndArrowParameterList| 의 해석은 아래 문법을 사용하여 정제된다:
    </p>
    <emu-prodref name="ParenthesizedExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Literal"></emu-prodref>
    <emu-prodref name="ArrayLiteral"></emu-prodref>
    <emu-prodref name="ElementList"></emu-prodref>
    <emu-prodref name="Elision"></emu-prodref>
    <emu-prodref name="SpreadElement"></emu-prodref>
    <emu-prodref name="ObjectLiteral"></emu-prodref>
    <emu-prodref name="PropertyDefinitionList"></emu-prodref>
    <emu-prodref name="PropertyDefinition"></emu-prodref>
    <emu-prodref name="PropertyName"></emu-prodref>
    <emu-prodref name="LiteralPropertyName"></emu-prodref>
    <emu-prodref name="ComputedPropertyName"></emu-prodref>
    <emu-prodref name="CoverInitializedName"></emu-prodref>
    <emu-prodref name="Initializer"></emu-prodref>
    <emu-prodref name="TemplateLiteral"></emu-prodref>
    <emu-prodref name="SubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateSpans"></emu-prodref>
    <emu-prodref name="TemplateMiddleList"></emu-prodref>
    <emu-prodref name="MemberExpression"></emu-prodref>
    <emu-prodref name="SuperProperty"></emu-prodref>
    <emu-prodref name="MetaProperty"></emu-prodref>
    <emu-prodref name="NewTarget"></emu-prodref>
    <emu-prodref name="ImportMeta"></emu-prodref>
    <emu-prodref name="NewExpression"></emu-prodref>
    <emu-prodref name="CallExpression"></emu-prodref>
    <p>
      생성식 인스턴스<br>
      <emu-prodref name="CallExpression" a="callcover"></emu-prodref><br>
      를 처리할 때 |CoverCallExpressionAndAsyncArrowHead| 의 해석은 아래 문법으로 정제된다:
    </p>
    <emu-prodref name="CallMemberExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="SuperCall"></emu-prodref>
    <emu-prodref name="ImportCall"></emu-prodref>
    <emu-prodref name="Arguments"></emu-prodref>
    <emu-prodref name="ArgumentList"></emu-prodref>
    <emu-prodref name="OptionalExpression"></emu-prodref>
    <emu-prodref name="OptionalChain"></emu-prodref>
    <emu-prodref name="LeftHandSideExpression"></emu-prodref>
    <emu-prodref name="UpdateExpression"></emu-prodref>
    <emu-prodref name="UnaryExpression"></emu-prodref>
    <emu-prodref name="ExponentiationExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeOperator"></emu-prodref>
    <emu-prodref name="AdditiveExpression"></emu-prodref>
    <emu-prodref name="ShiftExpression"></emu-prodref>
    <emu-prodref name="RelationalExpression"></emu-prodref>
    <emu-prodref name="EqualityExpression"></emu-prodref>
    <emu-prodref name="BitwiseANDExpression"></emu-prodref>
    <emu-prodref name="BitwiseXORExpression"></emu-prodref>
    <emu-prodref name="BitwiseORExpression"></emu-prodref>
    <emu-prodref name="LogicalANDExpression"></emu-prodref>
    <emu-prodref name="LogicalORExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpressionHead"></emu-prodref>
    <emu-prodref name="ShortCircuitExpression"></emu-prodref>
    <emu-prodref name="ConditionalExpression"></emu-prodref>
    <emu-prodref name="AssignmentExpression"></emu-prodref>
    <emu-prodref name="AssignmentOperator"></emu-prodref>
    <p>
      특정 상황에서 생성식 인스턴스<br>
      <emu-prodref name="AssignmentExpression" a="assignment"></emu-prodref><br>
      를 처리할 때 |LeftHandSideExpression| 의 해석은 아래 문법을 사용하여 정제된다:
    </p>
    <emu-prodref name="AssignmentPattern"></emu-prodref>
    <emu-prodref name="ObjectAssignmentPattern"></emu-prodref>
    <emu-prodref name="ArrayAssignmentPattern"></emu-prodref>
    <emu-prodref name="AssignmentRestProperty"></emu-prodref>
    <emu-prodref name="AssignmentPropertyList"></emu-prodref>
    <emu-prodref name="AssignmentElementList"></emu-prodref>
    <emu-prodref name="AssignmentElisionElement"></emu-prodref>
    <emu-prodref name="AssignmentProperty"></emu-prodref>
    <emu-prodref name="AssignmentElement"></emu-prodref>
    <emu-prodref name="AssignmentRestElement"></emu-prodref>
    <emu-prodref name="DestructuringAssignmentTarget"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Expression"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-statements">
    <h1>문(Statements)</h1>
    <emu-prodref name="Statement"></emu-prodref>
    <emu-prodref name="Declaration"></emu-prodref>
    <emu-prodref name="HoistableDeclaration"></emu-prodref>
    <emu-prodref name="BreakableStatement"></emu-prodref>
    <emu-prodref name="BlockStatement"></emu-prodref>
    <emu-prodref name="Block"></emu-prodref>
    <emu-prodref name="StatementList"></emu-prodref>
    <emu-prodref name="StatementListItem"></emu-prodref>
    <emu-prodref name="LexicalDeclaration"></emu-prodref>
    <emu-prodref name="LetOrConst"></emu-prodref>
    <emu-prodref name="BindingList"></emu-prodref>
    <emu-prodref name="LexicalBinding"></emu-prodref>
    <emu-prodref name="VariableStatement"></emu-prodref>
    <emu-prodref name="VariableDeclarationList"></emu-prodref>
    <emu-prodref name="VariableDeclaration"></emu-prodref>
    <emu-prodref name="BindingPattern"></emu-prodref>
    <emu-prodref name="ObjectBindingPattern"></emu-prodref>
    <emu-prodref name="ArrayBindingPattern"></emu-prodref>
    <emu-prodref name="BindingRestProperty"></emu-prodref>
    <emu-prodref name="BindingPropertyList"></emu-prodref>
    <emu-prodref name="BindingElementList"></emu-prodref>
    <emu-prodref name="BindingElisionElement"></emu-prodref>
    <emu-prodref name="BindingProperty"></emu-prodref>
    <emu-prodref name="BindingElement"></emu-prodref>
    <emu-prodref name="SingleNameBinding"></emu-prodref>
    <emu-prodref name="BindingRestElement"></emu-prodref>
    <emu-prodref name="EmptyStatement"></emu-prodref>
    <emu-prodref name="ExpressionStatement"></emu-prodref>
    <emu-prodref name="IfStatement"></emu-prodref>
    <emu-prodref name="IterationStatement"></emu-prodref>
    <emu-prodref name="DoWhileStatement"></emu-prodref>
    <emu-prodref name="WhileStatement"></emu-prodref>
    <emu-prodref name="ForStatement"></emu-prodref>
    <emu-prodref name="ForInOfStatement"></emu-prodref>
    <emu-prodref name="ForDeclaration"></emu-prodref>
    <emu-prodref name="ForBinding"></emu-prodref>
    <emu-prodref name="ContinueStatement"></emu-prodref>
    <emu-prodref name="BreakStatement"></emu-prodref>
    <emu-prodref name="ReturnStatement"></emu-prodref>
    <emu-prodref name="WithStatement"></emu-prodref>
    <emu-prodref name="SwitchStatement"></emu-prodref>
    <emu-prodref name="CaseBlock"></emu-prodref>
    <emu-prodref name="CaseClauses"></emu-prodref>
    <emu-prodref name="CaseClause"></emu-prodref>
    <emu-prodref name="DefaultClause"></emu-prodref>
    <emu-prodref name="LabelledStatement"></emu-prodref>
    <emu-prodref name="LabelledItem"></emu-prodref>
    <emu-prodref name="ThrowStatement"></emu-prodref>
    <emu-prodref name="TryStatement"></emu-prodref>
    <emu-prodref name="Catch"></emu-prodref>
    <emu-prodref name="Finally"></emu-prodref>
    <emu-prodref name="CatchParameter"></emu-prodref>
    <emu-prodref name="DebuggerStatement"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-functions-and-classes">
    <h1>함수와 클래스</h1>
    <emu-prodref name="UniqueFormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameterList"></emu-prodref>
    <emu-prodref name="FunctionRestParameter"></emu-prodref>
    <emu-prodref name="FormalParameter"></emu-prodref>
    <emu-prodref name="FunctionDeclaration"></emu-prodref>
    <emu-prodref name="FunctionExpression"></emu-prodref>
    <emu-prodref name="FunctionBody"></emu-prodref>
    <emu-prodref name="FunctionStatementList"></emu-prodref>
    <emu-prodref name="ArrowFunction"></emu-prodref>
    <emu-prodref name="ArrowParameters"></emu-prodref>
    <emu-prodref name="ConciseBody"></emu-prodref>
    <emu-prodref name="ExpressionBody"></emu-prodref>
    <p>
      생성식 인스턴스<br>
      <emu-prodref name="ArrowParameters" a="parencover"></emu-prodref><br>
      를 처리할 때 |CoverParenthesizedExpressionAndArrowParameterList| 의 해석은 아래 문법을 사용해 정제된다:
    </p>
    <emu-prodref name="ArrowFormalParameters"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="AsyncArrowFunction"></emu-prodref>
    <emu-prodref name="AsyncConciseBody"></emu-prodref>
    <emu-prodref name="AsyncArrowBindingIdentifier"></emu-prodref>
    <emu-prodref name="CoverCallExpressionAndAsyncArrowHead"></emu-prodref>
    <p>
      생성식 인스턴스<br>
      <emu-prodref name="AsyncArrowFunction" a="callcover"></emu-prodref><br>
      를 처리할 때 |CoverCallExpressionAndAsyncArrowHead| 의 해석은 아래 문법으로 정제된다:
    </p>
    <emu-prodref name="AsyncArrowHead"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="MethodDefinition"></emu-prodref>
    <emu-prodref name="PropertySetParameterList"></emu-prodref>
    <emu-prodref name="GeneratorDeclaration"></emu-prodref>
    <emu-prodref name="GeneratorExpression"></emu-prodref>
    <emu-prodref name="GeneratorMethod"></emu-prodref>
    <emu-prodref name="GeneratorBody"></emu-prodref>
    <emu-prodref name="YieldExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorDeclaration"></emu-prodref>
    <emu-prodref name="AsyncGeneratorExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorMethod"></emu-prodref>
    <emu-prodref name="AsyncGeneratorBody"></emu-prodref>
    <emu-prodref name="AsyncFunctionDeclaration"></emu-prodref>
    <emu-prodref name="AsyncFunctionExpression"></emu-prodref>
    <emu-prodref name="AsyncMethod"></emu-prodref>
    <emu-prodref name="AsyncFunctionBody"></emu-prodref>
    <emu-prodref name="AwaitExpression"></emu-prodref>
    <emu-prodref name="ClassDeclaration"></emu-prodref>
    <emu-prodref name="ClassExpression"></emu-prodref>
    <emu-prodref name="ClassTail"></emu-prodref>
    <emu-prodref name="ClassHeritage"></emu-prodref>
    <emu-prodref name="ClassBody"></emu-prodref>
    <emu-prodref name="ClassElementList"></emu-prodref>
    <emu-prodref name="ClassElement"></emu-prodref>
    <emu-prodref name="FieldDefinition"></emu-prodref>
    <emu-prodref name="ClassElementName"></emu-prodref>
    <emu-prodref name="ClassStaticBlock"></emu-prodref>
    <emu-prodref name="ClassStaticBlockBody"></emu-prodref>
    <emu-prodref name="ClassStaticBlockStatementList"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-scripts-and-modules">
    <h1>스크립트와 모듈</h1>
    <emu-prodref name="Script"></emu-prodref>
    <emu-prodref name="ScriptBody"></emu-prodref>
    <emu-prodref name="Module"></emu-prodref>
    <emu-prodref name="ModuleBody"></emu-prodref>
    <emu-prodref name="ModuleItemList"></emu-prodref>
    <emu-prodref name="ModuleItem"></emu-prodref>
    <emu-prodref name="ModuleExportName"></emu-prodref>
    <emu-prodref name="ImportDeclaration"></emu-prodref>
    <emu-prodref name="ImportClause"></emu-prodref>
    <emu-prodref name="ImportedDefaultBinding"></emu-prodref>
    <emu-prodref name="NameSpaceImport"></emu-prodref>
    <emu-prodref name="NamedImports"></emu-prodref>
    <emu-prodref name="FromClause"></emu-prodref>
    <emu-prodref name="ImportsList"></emu-prodref>
    <emu-prodref name="ImportSpecifier"></emu-prodref>
    <emu-prodref name="ModuleSpecifier"></emu-prodref>
    <emu-prodref name="ImportedBinding"></emu-prodref>
    <emu-prodref name="WithClause"></emu-prodref>
    <emu-prodref name="WithEntries"></emu-prodref>
    <emu-prodref name="AttributeKey"></emu-prodref>
    <emu-prodref name="ExportDeclaration"></emu-prodref>
    <emu-prodref name="ExportFromClause"></emu-prodref>
    <emu-prodref name="NamedExports"></emu-prodref>
    <emu-prodref name="ExportsList"></emu-prodref>
    <emu-prodref name="ExportSpecifier"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-number-conversions">
    <h1>숫자 변환</h1>
    <emu-prodref name="StringNumericLiteral"></emu-prodref>
    <emu-prodref name="StrWhiteSpace"></emu-prodref>
    <emu-prodref name="StrWhiteSpaceChar"></emu-prodref>
    <emu-prodref name="StrNumericLiteral"></emu-prodref>
    <emu-prodref name="StrDecimalLiteral"></emu-prodref>
    <emu-prodref name="StrUnsignedDecimalLiteral"></emu-prodref>
    <p>|StringNumericLiteral| 문법에 의해 명시적으로 정의되지 않은 모든 문법 기호는 <emu-xref href="#sec-literals-numeric-literals">숫자 리터럴을 위한 어휘 문법</emu-xref>에서 사용된 정의를 가진다.</p>
    <emu-prodref name="StringIntegerLiteral"></emu-prodref>
    <emu-prodref name="StrIntegerLiteral"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-time-zone-offset-string-format">
    <h1>시간대 오프셋 문자열 형식</h1>
    <emu-prodref name="UTCOffset"></emu-prodref>
    <emu-prodref name="ASCIISign"></emu-prodref>
    <emu-prodref name="Hour"></emu-prodref>
    <emu-prodref name="HourSubcomponents"></emu-prodref>
    <emu-prodref name="TimeSeparator"></emu-prodref>
    <emu-prodref name="MinuteSecond"></emu-prodref>
    <emu-prodref name="TemporalDecimalFraction"></emu-prodref>
    <emu-prodref name="TemporalDecimalSeparator"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-regular-expressions">
    <h1>정규 표현식</h1>
    <emu-prodref name="Pattern"></emu-prodref>
    <emu-prodref name="Disjunction"></emu-prodref>
    <emu-prodref name="Alternative"></emu-prodref>
    <emu-prodref name="Term"></emu-prodref>
    <emu-prodref name="Assertion"></emu-prodref>
    <emu-prodref name="Quantifier"></emu-prodref>
    <emu-prodref name="QuantifierPrefix"></emu-prodref>
    <emu-prodref name="Atom"></emu-prodref>
    <emu-prodref name="RegularExpressionModifiers"></emu-prodref>
    <emu-prodref name="RegularExpressionModifier"></emu-prodref>
    <emu-prodref name="SyntaxCharacter"></emu-prodref>
    <emu-prodref name="PatternCharacter"></emu-prodref>
    <emu-prodref name="AtomEscape"></emu-prodref>
    <emu-prodref name="CharacterEscape"></emu-prodref>
    <emu-prodref name="ControlEscape"></emu-prodref>
    <emu-prodref name="GroupSpecifier"></emu-prodref>
    <emu-prodref name="GroupName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierStart"></emu-prodref>
    <emu-prodref name="RegExpIdentifierPart"></emu-prodref>
    <emu-prodref name="RegExpUnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeLeadSurrogate"></emu-prodref>
    <emu-prodref name="UnicodeTrailSurrogate"></emu-prodref>
    <p>연결될 `\\u` |HexLeadSurrogate| 선택이 모호한 각 `\\u` |HexTrailSurrogate| 는 그렇지 않으면 대응하는 `\\u` |HexTrailSurrogate| 가 없게 될 가장 가까운 `u` |HexLeadSurrogate| 와 연결되어야 한다.</p>
    <p>&nbsp;</p>
    <emu-prodref name="HexLeadSurrogate"></emu-prodref>
    <emu-prodref name="HexTrailSurrogate"></emu-prodref>
    <emu-prodref name="HexNonSurrogate"></emu-prodref>
    <emu-prodref name="IdentityEscape"></emu-prodref>
    <emu-prodref name="DecimalEscape"></emu-prodref>
    <emu-prodref name="CharacterClassEscape"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueExpression"></emu-prodref>
    <emu-prodref name="UnicodePropertyName"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValue"></emu-prodref>
    <emu-prodref name="LoneUnicodePropertyNameOrValue"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacter"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacter"></emu-prodref>
    <emu-prodref name="CharacterClass"></emu-prodref>
    <emu-prodref name="ClassContents"></emu-prodref>
    <emu-prodref name="NonemptyClassRanges"></emu-prodref>
    <emu-prodref name="NonemptyClassRangesNoDash"></emu-prodref>
    <emu-prodref name="ClassAtom"></emu-prodref>
    <emu-prodref name="ClassAtomNoDash"></emu-prodref>
    <emu-prodref name="ClassEscape"></emu-prodref>
    <emu-prodref name="ClassSetExpression"></emu-prodref>
    <emu-prodref name="ClassUnion"></emu-prodref>
    <emu-prodref name="ClassIntersection"></emu-prodref>
    <emu-prodref name="ClassSubtraction"></emu-prodref>
    <emu-prodref name="ClassSetRange"></emu-prodref>
    <emu-prodref name="ClassSetOperand"></emu-prodref>
    <emu-prodref name="NestedClass"></emu-prodref>
    <emu-prodref name="ClassStringDisjunction"></emu-prodref>
    <emu-prodref name="ClassStringDisjunctionContents"></emu-prodref>
    <emu-prodref name="ClassString"></emu-prodref>
    <emu-prodref name="NonEmptyClassString"></emu-prodref>
    <emu-prodref name="ClassSetCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedDoublePunctuator"></emu-prodref>
    <emu-prodref name="ClassSetSyntaxCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedPunctuator"></emu-prodref>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>웹 브라우저를 위한 추가 ECMAScript 기능</h1>
  <p>이 부록에 정의된 ECMAScript 언어 구문과 의미는 ECMAScript 호스트가 웹 브라우저인 경우 필수이다. 이 부록의 내용은 규범적이지만 ECMAScript 호스트가 웹 브라우저가 아닌 경우 선택 사항이다.</p>
  <p>이 부록에 정의된 일부 기능은 이 부록에서, 또 일부는 본문에서 정의된다.</p>
  <p>기능이 본문에서 정의되는 경우, 문서에 영향을 미치는 각 지점은 색상 박스 안의 "Normative Optional" 문구로 표시된다. 또한 어떤 기능이 알고리즘이나 초기 에러 규칙의 특정 문구를 수반할 때는 그것이 관련 기능에 대해 “<dfn variants="otherwise supports">the host supports</dfn>”하는 조건으로 보호된다. 웹 브라우저는 그러한 모든 기능을 지원해야 한다.</p>
  <emu-note>
    <p>이 부록은 다양한 레거시 기능과 웹 브라우저 ECMAScript 호스트의 기타 특성을 설명한다. 이 부록에 명시된 모든 언어 기능과 동작은 하나 이상의 바람직하지 않은 특성을 가지며 레거시 사용이 없다면 이 명세에서 제거되었을 것이다. 그러나 다수의 기존 웹 페이지가 이러한 기능을 사용하기 때문에 웹 브라우저는 계속해서 이를 지원해야 한다. 이 부록의 명세는 이러한 레거시 기능의 상호 운용 구현 요구 사항을 정의한다.</p>
    <p>이 기능들은 핵심 ECMAScript 언어의 일부로 간주되지 않는다. 프로그래머는 새로운 ECMAScript 코드를 작성할 때 이러한 기능과 동작의 존재를 사용하거나 가정해서는 안 된다. ECMAScript 구현은 구현이 웹 브라우저의 일부이거나 웹 브라우저가 마주치는 동일한 레거시 ECMAScript 코드를 실행해야 하는 경우가 아니면 이러한 기능을 구현하지 않는 것이 권장된다.</p>
  </emu-note>

  <emu-annex id="sec-additional-syntax">
    <h1>추가 구문</h1>

    <emu-annex id="sec-html-like-comments">
      <h1>HTML 유사 주석</h1>
      <p><emu-xref href="#sec-comments"></emu-xref>의 구문과 의미는 다음과 같이 확장되지만, 이 확장은 목표 심볼 |Module| 로 소스 텍스트를 파싱할 때는 허용되지 않는다:</p>
      <h2>구문</h2>
      <emu-grammar type="definition">
        InputElementHashbangOrRegExp ::
          WhiteSpace
          LineTerminator
          Comment
          CommonToken
          HashbangComment
          RegularExpressionLiteral
          HTMLCloseComment

        Comment ::
          MultiLineComment
          SingleLineComment
          SingleLineHTMLOpenComment
          SingleLineHTMLCloseComment
          SingleLineDelimitedComment

        MultiLineComment ::
          `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

        FirstCommentLine ::
          SingleLineDelimitedCommentChars

        SingleLineHTMLOpenComment ::
          `&lt;!--` SingleLineCommentChars?

        SingleLineHTMLCloseComment ::
          LineTerminatorSequence HTMLCloseComment

        SingleLineDelimitedComment ::
          `/*` SingleLineDelimitedCommentChars? `*/`

        HTMLCloseComment ::
          WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `--&gt;` SingleLineCommentChars?

        SingleLineDelimitedCommentChars ::
          SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotAsteriskChar ::
          SourceCharacter but not one of `*` or LineTerminator

        SingleLinePostAsteriskCommentChars ::
          SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotForwardSlashOrAsteriskChar ::
          SourceCharacter but not one of `/` or `*` or LineTerminator

        WhiteSpaceSequence ::
          WhiteSpace WhiteSpaceSequence?

        SingleLineDelimitedCommentSequence ::
          SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?
      </emu-grammar>
      <p>줄 종결자 코드 포인트를 포함하는 |MultiLineComment| 와 유사하게, |SingleLineHTMLCloseComment| 는 구문 문법에 의한 파싱 목적상 |LineTerminator| 로 간주된다.</p>
    </emu-annex>

    <emu-annex id="sec-regular-expressions-patterns">
      <h1>정규 표현식 패턴</h1>
      <p><emu-xref href="#sec-patterns"></emu-xref>의 구문은 다음과 같이 수정·확장된다. 이러한 변경은 문법 생성식의 순서 및 문맥 정보를 통해 해소되는 모호성을 도입한다. 아래 문법을 사용하여 파싱할 때 각 대안은 이전 생성식 대안이 일치하지 않을 경우에만 고려된다.</p>
      <p>이 대안 패턴 문법과 의미는 BMP 패턴의 구문과 의미만 변경한다. 다음 문법 확장은 [UnicodeMode] 매개변수를 가진 생성식을 포함한다. 그러나 이러한 확장 중 어느 것도 목표 심볼에 [UnicodeMode] 매개변수가 존재할 때 인식되는 유니코드 패턴의 구문을 변경하지 않는다.</p>
      <h2>구문</h2>
      <emu-grammar type="definition">
        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [+UnicodeMode] Assertion[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] Assertion[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups]

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          [+UnicodeMode] `(?=` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [+UnicodeMode] `(?!` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups]
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        QuantifiableAssertion[NamedCaptureGroups] ::
          `(?=` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`

        ExtendedAtom[NamedCaptureGroups] ::
          `.`
          `\` AtomEscape[~UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]
          CharacterClass[~UnicodeMode, ~UnicodeSetsMode]
          `(` GroupSpecifier[~UnicodeMode]? Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          InvalidBracedQuantifier
          ExtendedPatternCharacter

        InvalidBracedQuantifier ::
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        ExtendedPatternCharacter ::
          SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] DecimalEscape
          [~UnicodeMode] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &le; CountLeftCapturingParensWithin(the |Pattern| containing |DecimalEscape|)]
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode, NamedCaptureGroups] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          [~UnicodeMode] LegacyOctalEscapeSequence
          IdentityEscape[?UnicodeMode, ?NamedCaptureGroups]

        IdentityEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacterIdentityEscape[?NamedCaptureGroups]

        SourceCharacterIdentityEscape[NamedCaptureGroups] ::
          [~NamedCaptureGroups] SourceCharacter but not `c`
          [+NamedCaptureGroups] SourceCharacter but not one of `c` or `k`

        ClassAtomNoDash[UnicodeMode, NamedCaptureGroups] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]

        ClassEscape[UnicodeMode, NamedCaptureGroups] ::
          `b`
          [+UnicodeMode] `-`
          [~UnicodeMode] `c` ClassControlLetter
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]

        ClassControlLetter ::
          DecimalDigit
          `_`
      </emu-grammar>
      <emu-note>
        <p>동일한 좌변이 [+UnicodeMode] 와 [~UnicodeMode] 가드를 모두 가지는 경우 이는 모호성 해소 우선순위를 제어하기 위한 것이다.</p>
      </emu-note>

      <emu-annex id="sec-patterns-static-semantics-early-errors-annexb">
        <h1>정적 의미: 초기 에러</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-early-errors"></emu-xref>의 의미는 다음과 같이 확장된다:</p>
        <emu-grammar>ExtendedAtom :: InvalidBracedQuantifier</emu-grammar>
        <ul>
          <li>
            이 생성식이 어떤 소스 텍스트와 일치하면 Syntax Error 이다.
          </li>
        </ul>
        <p>또한 다음 생성식의 규칙은 <ins>강조된</ins> 텍스트를 추가하여 수정된다:</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            첫 번째 |ClassAtom| 의 IsCharacterClass 가 *true* 이거나 두 번째 |ClassAtom| 의 IsCharacterClass 가 *true* <ins>이고 이 생성식이 <sub>[UnicodeMode]</sub> 매개변수를 가진 경우</ins> Syntax Error 이다.
          </li>
          <li>
            첫 번째 |ClassAtom| 의 IsCharacterClass 가 *false*, 두 번째 |ClassAtom| 의 IsCharacterClass 가 *false* 이고 첫 번째 |ClassAtom| 의 CharacterValue 가 두 번째 |ClassAtom| 의 CharacterValue 보다 엄격하게 크면 Syntax Error 이다.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            |ClassAtomNoDash| 의 IsCharacterClass 가 *true* 이거나 |ClassAtom| 의 IsCharacterClass 가 *true* <ins>이고 이 생성식이 <sub>[UnicodeMode]</sub> 매개변수를 가진 경우</ins> Syntax Error 이다.
          </li>
          <li>
            |ClassAtomNoDash| 의 IsCharacterClass 가 *false*, |ClassAtom| 의 IsCharacterClass 가 *false* 이고 |ClassAtomNoDash| 의 CharacterValue 가 |ClassAtom| 의 CharacterValue 보다 엄격하게 크면 Syntax Error 이다.
          </li>
        </ul>
      </emu-annex>

      <emu-annex id="sec-countleftcapturingparens-annexb">
        <h1>정적 의미: CountLeftCapturingParensWithin 및 CountLeftCapturingParensBefore</h1>
        <p>CountLeftCapturingParensWithin 및 CountLeftCapturingParensBefore 정의에서 “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>”에 대한 참조는 “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>” 또는 “<emu-grammar>ExtendedAtom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>”를 의미하는 것으로 해석된다.</p>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-is-character-class-annexb">
        <h1>정적 의미: IsCharacterClass</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-is-character-class"></emu-xref>의 의미는 다음과 같이 확장된다:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. *false*를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-character-value-annexb">
        <h1>정적 의미: CharacterValue</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-character-value"></emu-xref>의 의미는 다음과 같이 확장된다:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. U+005C (REVERSE SOLIDUS)의 숫자 값을 반환한다.
        </emu-alg>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |ClassControlLetter| 가 매칭한 코드 포인트로 둔다.
          1. _i_ 를 _ch_ 의 숫자 값으로 둔다.
          1. _i_ 를 32로 나눈 나머지를 반환한다.
        </emu-alg>
        <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar>
        <emu-alg>
          1. |LegacyOctalEscapeSequence| 의 MV 를 반환한다(<emu-xref href="#sec-string-literals-static-semantics-mv"></emu-xref> 참조).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compilesubpattern-annexb" oldids="sec-regular-expression-patterns-semantics">
        <h1>런타임 의미: CompileSubpattern</h1>
        <p>CompileSubpattern 의 의미는 다음과 같이 확장된다:</p>

        <p><emu-grammar>Term :: QuantifiableAssertion Quantifier</emu-grammar> 에 대한 규칙은 |Atom| 대신 |QuantifiableAssertion| 을 대입한 것을 제외하면 <emu-grammar>Term :: Atom Quantifier</emu-grammar> 의 규칙과 동일하다.</p>
        <p><emu-grammar>Term :: ExtendedAtom Quantifier</emu-grammar> 에 대한 규칙은 |Atom| 대신 |ExtendedAtom| 을 대입한 것을 제외하면 <emu-grammar>Term :: Atom Quantifier</emu-grammar> 와 동일하다.</p>
        <p><emu-grammar>Term :: ExtendedAtom</emu-grammar> 에 대한 규칙은 |Atom| 대신 |ExtendedAtom| 을 대입한 것을 제외하면 <emu-grammar>Term :: Atom</emu-grammar> 과 동일하다.</p>
      </emu-annex>

      <emu-annex id="sec-compileassertion-annexb">
        <h1>런타임 의미: CompileAssertion</h1>
        <p><emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar> 및 <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar> 생성식에 대한 CompileAssertion 규칙은 |Assertion| 대신 |QuantifiableAssertion| 을 대입하여 |QuantifiableAssertion| 생성식에도 사용된다.</p>
      </emu-annex>

      <emu-annex id="sec-compileatom-annexb">
        <h1>런타임 의미: CompileAtom</h1>
        <p><emu-grammar>Atom :: PatternCharacter</emu-grammar> 를 제외한 |Atom| 생성식에 대한 CompileAtom 규칙은 |Atom| 대신 |ExtendedAtom| 을 대입하여 |ExtendedAtom| 생성식에도 사용된다. 다음 규칙(매개변수 _direction_)이 추가된다:</p>
        <emu-grammar>ExtendedAtom :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. _A_ 를 단일 문자 `\\` U+005C (REVERSE SOLIDUS)를 포함하는 CharSet 으로 둔다.
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) 를 반환한다.
        </emu-alg>
        <emu-grammar>ExtendedAtom :: ExtendedPatternCharacter</emu-grammar>
        <emu-alg>
          1. _ch_ 를 |ExtendedPatternCharacter| 가 표현하는 문자로 둔다.
          1. _A_ 를 문자 _ch_ 하나만 포함하는 CharSet 으로 둔다.
          1. CharacterSetMatcher(_rer_, _A_, *false*, _direction_) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compiletocharset-annexb">
        <h1>런타임 의미: CompileToCharSet</h1>
        <p><emu-xref href="#sec-compiletocharset"></emu-xref>의 의미는 다음과 같이 확장된다:</p>

        <p>다음 두 규칙은 CompileToCharSet 의 해당 규칙을 대체한다.</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ 를 첫 번째 |ClassAtom| 에 대한 CompileToCharSet(_rer_) 결과로 둔다.
          1. _B_ 를 두 번째 |ClassAtom| 에 대한 CompileToCharSet(_rer_) 결과로 둔다.
          1. _C_ 를 |ClassContents| 에 대한 CompileToCharSet(_rer_) 결과로 둔다.
          1. _D_ 를 CharacterRangeOrUnion(_rer_, _A_, _B_) 로 둔다.
          1. _D_ 와 _C_ 의 합집합을 반환한다.
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. _A_ 를 |ClassAtomNoDash| 에 대한 CompileToCharSet(_rer_) 결과로 둔다.
          1. _B_ 를 |ClassAtom| 에 대한 CompileToCharSet(_rer_) 결과로 둔다.
          1. _C_ 를 |ClassContents| 에 대한 CompileToCharSet(_rer_) 결과로 둔다.
          1. _D_ 를 CharacterRangeOrUnion(_rer_, _A_, _B_) 로 둔다.
          1. _D_ 와 _C_ 의 합집합을 반환한다.
        </emu-alg>

        <p>추가로 다음 규칙이 CompileToCharSet 에 추가된다.</p>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. _cv_ 를 이 |ClassEscape| 의 CharacterValue 로 둔다.
          1. _c_ 를 문자 값이 _cv_ 인 문자로 둔다.
          1. 문자 _c_ 하나만 포함하는 CharSet 을 반환한다.
        </emu-alg>
        <emu-grammar>ClassAtomNoDash :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. 단일 문자 `\\` U+005C (REVERSE SOLIDUS)를 포함하는 CharSet 을 반환한다.
        </emu-alg>

        <emu-note>이 생성식은 허용 가능한 제어 문자가 뒤따르지 않는 문자 클래스 내부의 `\c` 시퀀스로부터만 도달될 수 있다.</emu-note>

        <emu-annex id="sec-runtime-semantics-characterrangeorunion-abstract-operation" type="abstract operation">
          <h1>
            CharacterRangeOrUnion (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. HasEitherUnicodeFlag(_rer_) 가 *false* 이면
              1. _A_ 가 정확히 한 문자를 포함하지 않거나 _B_ 가 정확히 한 문자를 포함하지 않으면
                1. _C_ 를 단일 문자 `-` U+002D (HYPHEN-MINUS)를 포함하는 CharSet 으로 둔다.
                1. CharSet _A_, _B_, _C_ 의 합집합을 반환한다.
            1. CharacterRange(_A_, _B_) 를 반환한다.
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-parsepattern-annexb">
        <h1>정적 의미: ParsePattern ( _patternText_, _u_, _v_ )</h1>
        <p><emu-xref href="#sec-parsepattern"></emu-xref>의 의미는 다음과 같이 확장된다:</p>
        <p>추상 연산 ParsePattern 은 인수 _patternText_(유니코드 코드 포인트 시퀀스), _u_(Boolean), _v_(Boolean)을 받고 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _v_ 가 *true* 이고 _u_ 가 *true* 이면
            1. _parseResult_ 를 하나 이상의 *SyntaxError* 객체를 포함하는 List 로 둔다.
          1. Else if _v_ 가 *true* 이면
            1. _parseResult_ 를 ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|) 로 둔다.
          1. Else if _u_ 가 *true* 이면
            1. _parseResult_ 를 ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|) 로 둔다.
          1. Else,
            1. _parseResult_ 를 ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, ~NamedCaptureGroups]|) 로 둔다.
            1. _parseResult_ 가 Parse Node 이고 |GroupName| 을 포함하면
              1. _parseResult_ 를 ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|) 로 설정한다.
          1. _parseResult_ 를 반환한다.
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-additional-built-in-properties">
    <h1>추가 내장 프로퍼티</h1>
    <p>ECMAScript 호스트가 웹 브라우저인 경우 표준 내장 객체의 다음 추가 프로퍼티가 정의된다.</p>

    <emu-annex id="sec-additional-properties-of-the-global-object">
      <h1>전역 객체의 추가 프로퍼티</h1>
      <p><emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>의 항목을 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>에 추가한다.</p>
      <emu-table id="table-additional-well-known-intrinsic-objects" caption="추가 잘 알려진 내재 객체" oldids="table-60">
        <table>
          <thead>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              %escape%
            </td>
            <td>
              `escape`
            </td>
            <td>
              `escape` 함수 (<emu-xref href="#sec-escape-string"></emu-xref>)
            </td>
          </tr>
          <tr>
            <td>
              %unescape%
            </td>
            <td>
              `unescape`
            </td>
            <td>
              `unescape` 함수 (<emu-xref href="#sec-unescape-string"></emu-xref>)
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-annex id="sec-escape-string">
        <h1>escape ( _string_ )</h1>
        <p>이 함수는 전역 객체의 프로퍼티이다. 특정 코드 유닛이 16진수 이스케이프 시퀀스로 교체된 새로운 String 값을 계산한다.</p>
        <p>숫자 값이 0x00FF 이하인 코드 유닛을 교체할 때는 <code>%<var>xx</var></code> 형태의 2자리 이스케이프 시퀀스를 사용한다. 숫자 값이 0x00FF 를 초과하는 코드 유닛을 교체할 때는 <code>%u<var>xxxx</var></code> 형태의 4자리 이스케이프 시퀀스를 사용한다.</p>
        <p>이것은 <dfn>%escape%</dfn> 내재 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _string_ 을 ? ToString(_string_) 으로 설정한다.
          1. _len_ 을 _string_ 의 길이로 둔다.
          1. _R_ 을 빈 String 으로 둔다.
          1. _unescapedSet_ 을 ASCII 단어 문자와 *"@\*+-./"* 의 문자열 연결로 둔다.
          1. _k_ 를 0으로 둔다.
          1. 반복, _k_ &lt; _len_ 인 동안
            1. _C_ 를 _string_ 내 인덱스 _k_ 의 코드 유닛으로 둔다.
            1. _unescapedSet_ 이 _C_ 를 포함하면
              1. _S_ 를 _C_ 로 둔다.
            1. 아니면
              1. _n_ 을 _C_ 의 숫자 값으로 둔다.
              1. _n_ &lt; 256 이면
                1. _hex_ 를 _n_ 을 대문자 16진수로 서식화한 String 표현으로 둔다.
                1. _S_ 를 *"%"* 와 StringPad(_hex_, 2, *"0"*, ~start~) 의 문자열 연결로 둔다.
              1. 그렇지 않으면
                1. _hex_ 를 _n_ 을 대문자 16진수로 서식화한 String 표현으로 둔다.
                1. _S_ 를 *"%u"* 와 StringPad(_hex_, 4, *"0"*, ~start~) 의 문자열 연결로 둔다.
            1. _R_ 을 _R_ 과 _S_ 의 문자열 연결로 설정한다.
            1. _k_ 를 _k_ + 1 로 설정한다.
          1. _R_ 을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 인코딩은 부분적으로 RFC 1738 의 인코딩을 기반으로 하지만, 이 표준에 명시된 전체 인코딩은 RFC 1738 의 내용과 무관하게 위에서 설명된다. 이 인코딩은 RFC 3986 이 RFC 1738 에 적용한 변경 사항을 반영하지 않는다.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-unescape-string">
        <h1>unescape ( _string_ )</h1>
        <p>이 함수는 전역 객체의 프로퍼티이다. `escape` 함수가 도입했을 수 있는 형태의 각 이스케이프 시퀀스를 그것이 표현하는 코드 유닛으로 교체한 새로운 String 값을 계산한다.</p>
        <p>이것은 <dfn>%unescape%</dfn> 내재 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _string_ 을 ? ToString(_string_) 으로 설정한다.
          1. _len_ 을 _string_ 의 길이로 둔다.
          1. _R_ 을 빈 String 으로 둔다.
          1. _k_ 를 0으로 둔다.
          1. 반복, _k_ &lt; _len_ 인 동안
            1. _C_ 를 _string_ 내 인덱스 _k_ 의 코드 유닛으로 둔다.
            1. _C_ 가 코드 유닛 0x0025 (PERCENT SIGN)이면
              1. _hexDigits_ 를 빈 String 으로 둔다.
              1. _optionalAdvance_ 를 0으로 둔다.
              1. _k_ + 5 &lt; _len_ 이고 _string_ 내 인덱스 _k_ + 1 의 코드 유닛이 0x0075 (LATIN SMALL LETTER U)이면
                1. _hexDigits_ 를 _string_ 의 _k_ + 2 부터 _k_ + 6 까지의 부분 문자열로 설정한다.
                1. _optionalAdvance_ 를 5로 설정한다.
              1. Else if _k_ + 3 ≤ _len_ 이면
                1. _hexDigits_ 를 _string_ 의 _k_ + 1 부터 _k_ + 3 까지의 부분 문자열로 설정한다.
                1. _optionalAdvance_ 를 2로 설정한다.
              1. _parseResult_ 를 ParseText(_hexDigits_, |HexDigits[~Sep]|) 로 둔다.
              1. _parseResult_ 가 Parse Node 이면
                1. _n_ 을 _parseResult_ 의 MV 로 둔다.
                1. _C_ 를 숫자 값이 _n_ 인 코드 유닛으로 설정한다.
                1. _k_ 를 _k_ + _optionalAdvance_ 로 설정한다.
            1. _R_ 을 _R_ 과 _C_ 의 문자열 연결로 설정한다.
            1. _k_ 를 _k_ + 1 로 설정한다.
          1. _R_ 을 반환한다.
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-string.prototype-object">
      <h1>String.prototype 객체의 추가 프로퍼티</h1>

      <emu-annex id="sec-string.prototype.substr">
        <h1>String.prototype.substr ( _start_, _length_ )</h1>
        <p>이 메서드는 *this* 값을 String 으로 변환한 결과에서 인덱스 _start_ 에서 시작하여 _length_ 코드 유닛(또는 _length_ 가 *undefined* 이면 문자열 끝까지) 길이의 <emu-not-ref>substring</emu-not-ref> 을 반환한다. _start_ 가 음수이면 _sourceLength_ 를 문자열 길이로 하여 <emu-eqn>_sourceLength_ + _start_</emu-eqn> 로 처리한다. 결과는 String 객체가 아닌 String 값이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. ? RequireObjectCoercible(_O_) 를 수행한다.
          1. _S_ 를 ? ToString(_O_) 로 둔다.
          1. _size_ 를 _S_ 의 길이로 둔다.
          1. _intStart_ 를 ? ToIntegerOrInfinity(_start_) 로 둔다.
          1. _intStart_ = -∞ 이면 _intStart_ 를 0으로 설정한다.
          1. Else if _intStart_ &lt; 0 이면 _intStart_ 를 max(_size_ + _intStart_, 0) 으로 설정한다.
          1. Else, _intStart_ 를 min(_intStart_, _size_) 로 설정한다.
          1. _length_ 가 *undefined* 이면 _intLength_ 를 _size_ 로; 그렇지 않으면 _intLength_ 를 ? ToIntegerOrInfinity(_length_) 로 둔다.
          1. _intLength_ 를 0 과 _size_ 사이로 클램프한 결과로 설정한다.
          1. _intEnd_ 를 min(_intStart_ + _intLength_, _size_) 로 둔다.
          1. _S_ 의 _intStart_ 부터 _intEnd_ 까지의 substring 을 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 의도적으로 제네릭하다; *this* 값이 String 객체일 필요가 없다. 따라서 다른 종류의 객체에 메서드로 이전하여 사용할 수 있다.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-string.prototype.anchor">
        <h1>String.prototype.anchor ( _name_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"a"*, *"name"*, _name_) 를 반환한다.
        </emu-alg>

        <emu-annex id="sec-createhtml" type="abstract operation">
          <h1>
            CreateHTML (
              _string_: an ECMAScript language value,
              _tag_: a String,
              _attribute_: a String,
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ? RequireObjectCoercible(_string_) 를 수행한다.
            1. _S_ 를 ? ToString(_string_) 로 둔다.
            1. _p1_ 을 *"&lt;"* 와 _tag_ 의 문자열 연결로 둔다.
            1. _attribute_ 가 빈 String 이 아니면
              1. _V_ 를 ? ToString(_value_) 로 둔다.
              1. _escapedV_ 를 _V_ 와 같되 _V_ 내 코드 유닛 0x0022 (QUOTATION MARK) 의 각 출현이 6 코드 유닛 *"&amp;quot;"* 로 대체된 String 값으로 둔다.
              1. _p1_ 을 다음의 문자열 연결로 설정한다:
                * _p1_
                * 코드 유닛 0x0020 (SPACE)
                * _attribute_
                * 코드 유닛 0x003D (EQUALS SIGN)
                * 코드 유닛 0x0022 (QUOTATION MARK)
                * _escapedV_
                * 코드 유닛 0x0022 (QUOTATION MARK)
            1. _p2_ 를 _p1_ 과 *">"* 의 문자열 연결로 둔다.
            1. _p3_ 를 _p2_ 와 _S_ 의 문자열 연결로 둔다.
            1. _p4_ 를 _p3_, *"&lt;/"*, _tag_, *">"* 의 문자열 연결로 둔다.
            1. _p4_ 를 반환한다.
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-string.prototype.big">
        <h1>String.prototype.big ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"big"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.blink">
        <h1>String.prototype.blink ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"blink"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.bold">
        <h1>String.prototype.bold ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"b"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fixed">
        <h1>String.prototype.fixed ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"tt"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontcolor">
        <h1>String.prototype.fontcolor ( _colour_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"font"*, *"color"*, _colour_) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontsize">
        <h1>String.prototype.fontsize ( _size_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"font"*, *"size"*, _size_) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.italics">
        <h1>String.prototype.italics ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"i"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.link">
        <h1>String.prototype.link ( _url_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"a"*, *"href"*, _url_) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.small">
        <h1>String.prototype.small ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"small"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.strike">
        <h1>String.prototype.strike ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"strike"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sub">
        <h1>String.prototype.sub ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"sub"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sup">
        <h1>String.prototype.sup ( )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _S_ 를 *this* 값으로 둔다.
          1. ? CreateHTML(_S_, *"sup"*, *""*, *""*) 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="String.prototype.trimleft">
        <h1>String.prototype.trimLeft ( )</h1>
        <emu-note>
          <p>*"trimStart"* 프로퍼티가 더 선호된다. *"trimLeft"* 프로퍼티는 주로 오래된 코드와의 호환성을 위해 제공된다. 새로운 ECMAScript 코드에서는 *"trimStart"* 프로퍼티 사용이 권장된다.</p>
        </emu-note>
        <p>*"trimLeft"* 프로퍼티의 초기 값은 <emu-xref href="#sec-string.prototype.trimstart"></emu-xref>에 정의된 %String.prototype.trimStart% 이다.</p>
      </emu-annex>

      <emu-annex id="String.prototype.trimright">
        <h1>String.prototype.trimRight ( )</h1>
        <emu-note>
          <p>*"trimEnd"* 프로퍼티가 더 선호된다. *"trimRight"* 프로퍼티는 주로 오래된 코드와의 호환성을 위해 제공된다. 새로운 ECMAScript 코드에서는 *"trimEnd"* 프로퍼티 사용이 권장된다.</p>
        </emu-note>
        <p>*"trimRight"* 프로퍼티의 초기 값은 <emu-xref href="#sec-string.prototype.trimend"></emu-xref>에 정의된 %String.prototype.trimEnd% 이다.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-date.prototype-object">
      <h1>Date.prototype 객체의 추가 프로퍼티</h1>

      <emu-annex id="sec-date.prototype.getyear">
        <h1>Date.prototype.getYear ( )</h1>
        <emu-note>
          <p>`getFullYear` 메서드가 “year 2000 문제”를 피하기 때문에 거의 모든 용도에 더 권장된다.</p>
        </emu-note>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_ 를 *this* 값으로 둔다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) 를 수행한다.
          1. _t_ 를 _dateObject_.[[DateValue]] 로 둔다.
          1. _t_ 가 *NaN* 이면 *NaN* 을 반환한다.
          1. YearFromTime(LocalTime(_t_)) - *1900*<sub>𝔽</sub> 을 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.setyear">
        <h1>Date.prototype.setYear ( _year_ )</h1>
        <emu-note>
          <p>`setFullYear` 메서드가 “year 2000 문제”를 피하기 때문에 거의 모든 용도에 더 권장된다.</p>
        </emu-note>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _dateObject_ 를 *this* 값으로 둔다.
          1. ? RequireInternalSlot(_dateObject_, [[DateValue]]) 를 수행한다.
          1. _t_ 를 _dateObject_.[[DateValue]] 로 둔다.
          1. _y_ 를 ? ToNumber(_year_) 로 둔다.
          1. _t_ 가 *NaN* 이면 _t_ 를 *+0*<sub>𝔽</sub> 로; 아니면 _t_ 를 LocalTime(_t_) 로 설정한다.
          1. _yyyy_ 를 MakeFullYear(_y_) 로 둔다.
          1. _d_ 를 MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_)) 로 둔다.
          1. _date_ 를 MakeDate(_d_, TimeWithinDay(_t_)) 로 둔다.
          1. _u_ 를 TimeClip(UTC(_date_)) 로 둔다.
          1. _dateObject_.[[DateValue]] 를 _u_ 로 설정한다.
          1. _u_ 를 반환한다.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.togmtstring">
        <h1>Date.prototype.toGMTString ( )</h1>
        <emu-note>
          <p>`toUTCString` 메서드가 더 선호된다. 이 메서드는 주로 오래된 코드와의 호환성을 위해 제공된다.</p>
        </emu-note>
        <p>*"toGMTString"* 프로퍼티의 초기 값은 <emu-xref href="#sec-date.prototype.toutcstring"></emu-xref>에 정의된 %Date.prototype.toUTCString% 이다.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-regexp.prototype-object">
      <h1>RegExp.prototype 객체의 추가 프로퍼티</h1>

      <emu-annex id="sec-regexp.prototype.compile">
        <h1>RegExp.prototype.compile ( _pattern_, _flags_ )</h1>
        <p>이 메서드는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. ? RequireInternalSlot(_O_, [[RegExpMatcher]]) 를 수행한다.
          1. _pattern_ 이 Object 이고 [[RegExpMatcher]] 내부 슬롯을 가지면
            1. _flags_ 가 *undefined* 가 아니면 *TypeError* 예외를 던진다.
            1. _P_ 를 _pattern_.[[OriginalSource]] 로 둔다.
            1. _F_ 를 _pattern_.[[OriginalFlags]] 로 둔다.
          1. 아니면
            1. _P_ 를 _pattern_ 으로 둔다.
            1. _F_ 를 _flags_ 로 둔다.
          1. ? RegExpInitialize(_O_, _P_, _F_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 *this* 값 RegExp 를 새로운 패턴과 플래그로 완전히 재초기화한다. 구현은 이 메서드 사용을 결과 RegExp 객체가 여러 번 사용될 것이며 추가 최적화 후보라는 주장으로 해석할 수 있다.</p>
        </emu-note>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-other-additional-features">
    <h1>기타 추가 기능</h1>

    <emu-annex id="sec-labelled-function-declarations">
      <h1>레이블된 함수 선언</h1>
      <p>ECMAScript 2015 이전에는 |LabelledStatement| 의 명세가 문장 레이블을 |FunctionDeclaration| 과 연결하는 것을 허용하지 않았다. 그러나 레이블된 |FunctionDeclaration| 은 비엄격 코드에 대한 허용 확장이었고 대부분의 브라우저 호스트 ECMAScript 구현이 이를 지원했다. ECMAScript 2015 이후 문법 생성식 |LabelledStatement| 는 |FunctionDeclaration| 을 |LabelledItem| 으로 사용하는 것을 허용하지만 <emu-xref href="#sec-labelled-statements-static-semantics-early-errors"></emu-xref> 는 그것이 발생하면 Syntax Error 를 생성하는 초기 에러 규칙을 포함한다. 그 규칙은 호스트가 이 기능을 지원하는 비엄격 코드에서 Syntax Error 를 억제하도록 수정된다.</p>
      <emu-note>
        <p>|WithStatement|, |IfStatement|, |IterationStatement| 의 초기 에러 규칙은 비엄격 코드에서 이러한 문장이 레이블된 |FunctionDeclaration| 을 포함하는 것을 방지한다.</p>
      </emu-note>
    </emu-annex>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>블록 수준 함수 선언 웹 레거시 호환 의미</h1>
      <p>ECMAScript 2015 이전에는 |Block| 문장의 |StatementList| 요소로 |FunctionDeclaration| 이 등장하는 것이 ECMAScript 명세에 정의되지 않았다. 그러나 해당 형태의 |FunctionDeclaration| 지원은 허용 확장이었고 대부분의 브라우저 호스트 ECMAScript 구현이 이를 허용했다. 불행히도 그러한 선언의 의미는 구현마다 다르다. 이러한 의미 차이 때문에 |Block| 수준 함수 선언을 사용하는 기존 웹 ECMAScript 소스 텍스트는 그러한 선언에 대해 모든 브라우저 구현의 의미 교집합에만 의존하는 경우에만 브라우저 구현 간 이식 가능하다. 다음이 그 교집합 의미에 속하는 사용 사례이다:</p>
      <ol>
        <li>
          <p>함수가 선언되고 단일 블록 내에서만 참조된다.</p>
          <ul>
            <li>
              이름 _f_ 의 |BindingIdentifier| 를 가진 하나 이상의 |FunctionDeclaration| 이 둘러싼 함수 _g_ 의 함수 코드 내에 나타나고 그 선언은 |Block| 에 중첩된다.
            </li>
            <li>
              _g_ 의 함수 코드 내에 `var` 선언이 아닌 다른 _f_ 선언이 존재하지 않는다.
            </li>
            <li>
              _f_ 의 |IdentifierReference| 출현은 선언을 포함하는 |Block| 의 |StatementList| 내에 모두 존재한다.
            </li>
          </ul>
        </li>
        <li>
          <p>함수가 단일 |Block| 내에서 선언 및 사용될 수 있지만 동일한 |Block| 에 포함되지 않은 내부 함수 정의에서 참조된다.</p>
          <ul>
            <li>
              이름 _f_ 의 |BindingIdentifier| 를 가진 하나 이상의 |FunctionDeclaration| 이 둘러싼 함수 _g_ 의 함수 코드 내에 나타나고 그 선언은 |Block| 에 중첩된다.
            </li>
            <li>
              _g_ 의 함수 코드 내에 `var` 선언이 아닌 다른 _f_ 선언이 존재하지 않는다.
            </li>
            <li>
              _f_ 의 |IdentifierReference| 출현이 선언을 포함하는 |Block| 의 |StatementList| 내에 있을 수 있다.
            </li>
            <li>
              _g_ 에 중첩된 다른 함수 _h_ 내에 _f_ 의 |IdentifierReference| 출현이 적어도 하나 있고, _h_ 로부터 _f_ 참조를 가리는 다른 _f_ 선언이 없다.
            </li>
            <li>
              _h_ 의 모든 호출은 _f_ 선언이 평가된 이후에 발생한다.
            </li>
          </ul>
        </li>
        <li>
          <p>함수가 단일 블록에서 선언 및 사용될 수 있지만 후속 블록에서 참조된다.</p>
          <ul>
            <li>
              이름 _f_ 의 |BindingIdentifier| 를 가진 하나 이상의 |FunctionDeclaration| 이 둘러싼 함수 _g_ 의 함수 코드 내에 나타나고 그 선언은 |Block| 에 중첩된다.
            </li>
            <li>
              _g_ 의 함수 코드 내에 `var` 선언이 아닌 다른 _f_ 선언이 존재하지 않는다.
            </li>
            <li>
              _f_ 의 |IdentifierReference| 출현이 선언을 포함하는 |Block| 의 |StatementList| 내에 있을 수 있다.
            </li>
            <li>
              _f_ 선언을 포함하는 |Block| 을 어휘적으로 뒤따르는 _g_ 의 함수 코드 내에 _f_ 의 |IdentifierReference| 출현이 적어도 하나 있다.
            </li>
          </ul>
        </li>
      </ol>
      <p>첫 번째 사용 사례는 ECMAScript 2015 가 제공하는 |Block| 수준 함수 선언 의미와 상호 운용된다. 그 사용 사례를 사용하는 모든 기존 ECMAScript 소스 텍스트는 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>, <emu-xref href="#sec-ecmascript-language-statements-and-declarations"></emu-xref>, <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref> 절에 의해 정의된 블록 수준 함수 선언 의미를 사용하여 동작한다.</p>
      <p>두 번째 및 세 번째 사용 사례에 대한 ECMAScript 2015 상호 운용성은 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 절, <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref> 절, <emu-xref href="#sec-eval-x"></emu-xref> 절 및 <emu-xref href="#sec-globaldeclarationinstantiation"></emu-xref> 절 의미에 대한 다음 확장을 필요로 한다.</p>
      <p>ECMAScript 구현에 진단 경고 메시지를 보고하는 메커니즘이 있는 경우, 이러한 호환 의미가 적용되어 비호환 의미와 관찰 가능한 차이를 만드는 |FunctionDeclaration| 이 있는 코드를 포함하면 경고가 생성되어야 한다. 예를 들어, var 바인딩 도입이 초기 에러를 만들기 때문에 도입되지 않는 경우 경고 메시지는 생성되지 않아야 한다.</p>
      <p>이 기능은 다음 지점에서 특별한 의미를 포함한다:</p>
      <ul>
        <li><emu-grammar>Block : `{` StatementList `}`</emu-grammar> 에 대한 <emu-xref href="#sec-block-static-semantics-early-errors"></emu-xref> 의 초기 에러 규칙 중 하나</li>
        <li><emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar> 에 대한 <emu-xref href="#sec-switch-statement-static-semantics-early-errors"></emu-xref> 의 초기 에러 규칙 중 하나</li>
        <li>FunctionDeclarationInstantiation 의 <emu-xref href="#step-functiondeclarationinstantiation-web-compat-insertion-point"></emu-xref> 단계</li>
        <li>BlockDeclarationInstantiation 의 <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref> 단계</li>
        <li>BlockDeclarationInstantiation 의 <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref> 단계</li>
        <li>GlobalDeclarationInstantiation 의 <emu-xref href="#step-globaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> 단계</li>
        <li>EvalDeclarationInstantiation 의 <emu-xref href="#step-evaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> 단계</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-functiondeclarations-in-ifstatement-statement-clauses">
      <h1>IfStatement 문 절의 FunctionDeclaration</h1>
      <p>다음은 <emu-xref href="#sec-if-statement"></emu-xref>의 |IfStatement| 생성식을 확장한다:</p>
      <emu-grammar type="definition">
        IfStatement[Yield, Await, Return] :
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] [lookahead != `else`]
      </emu-grammar>
      <p>이 생성식은 비엄격 코드를 파싱할 때만 적용된다. 이 생성식과 일치하는 소스 텍스트는 각 |FunctionDeclaration[?Yield, ?Await, ~Default]| 출현이 소스 텍스트에서 그 위치를 차지하는 |BlockStatement| 의 유일한 |StatementListItem| 인 것처럼 처리된다. 그러한 합성 |BlockStatement| 의 의미에는 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> 에 명시된 웹 레거시 호환 의미가 포함된다.</p>
    </emu-annex>

    <emu-annex id="sec-variablestatements-in-catch-blocks">
      <h1>Catch 블록 내 VariableStatement</h1>
      <p>이 기능에서는 |Catch| 절의 |Block| 이 |CatchParameter| 에 의해 바인딩된 이름을 또한 바인딩하는 `var` 선언을 포함할 수 있다. 이는 <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar> 에 대한 <emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref> 의 초기 에러 규칙을 수정하여 달성된다.</p>
      <emu-note>
        <p>런타임에는 이러한 바인딩이 VariableDeclarationEnvironment 에서 인스턴스화된다. 이들은 |CatchParameter| 가 도입한 동일 이름 바인딩을 가리지 않으므로 해당 `var` 선언의 |Initializer| 는 `var` 바인딩이 아니라 대응 catch 매개변수에 할당한다.</p>
      </emu-note>
      <p>이 수정된 동작은 |Catch| 절의 |Block| 내 직접 eval 호출로 도입된 `var` 및 `function` 선언에도 적용된다. 이 변경은 EvalDeclarationInstantiation 의 <emu-xref href="#step-evaldeclarationinstantiation-throw-duplicate-binding"></emu-xref> 및 <emu-xref href="#step-evaldeclarationinstantiation-web-compat-bindingexists"></emu-xref> 단계를 수정하여 달성된다.</p>
    </emu-annex>

    <emu-annex id="sec-initializers-in-forin-statement-heads">
      <h1>ForIn 문 Head 의 Initializer</h1>
      <p>다음은 <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>의 |ForInOfStatement| 생성식을 확장한다:</p>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>
      <p>이 생성식은 비엄격 코드를 파싱할 때만 적용된다.</p>
      <p><emu-xref href="#sec-static-semantics-containsduplicatelabels"></emu-xref> 의 ContainsDuplicateLabels 정적 의미는 다음으로 확장된다:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| 의 ContainsDuplicateLabels(_labelSet_) 를 반환한다.
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-containsundefinedbreaktarget"></emu-xref> 의 ContainsUndefinedBreakTarget 정적 의미는 다음으로 확장된다:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| 의 ContainsUndefinedBreakTarget(_labelSet_) 를 반환한다.
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-containsundefinedcontinuetarget"></emu-xref> 의 ContainsUndefinedContinueTarget 정적 의미는 다음으로 확장된다:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement| 의 ContainsUndefinedContinueTarget(_iterationSet_, « ») 를 반환한다.
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-isdestructuring"></emu-xref> 의 IsDestructuring 정적 의미는 다음으로 확장된다:</p>
      <emu-grammar>
        BindingIdentifier :
          Identifier
          `yield`
          `await`
      </emu-grammar>
      <emu-alg>
        1. *false* 를 반환한다.
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-vardeclarednames"></emu-xref> 의 VarDeclaredNames 정적 의미는 다음으로 확장된다:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _names1_ 을 |BindingIdentifier| 의 BoundNames 로 둔다.
        1. _names2_ 를 |Statement| 의 VarDeclaredNames 로 둔다.
        1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-varscopeddeclarations"></emu-xref> 의 VarScopedDeclarations 정적 의미는 다음으로 확장된다:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_ 을 « |BindingIdentifier| » 로 둔다.
        1. _declarations2_ 를 |Statement| 의 VarScopedDeclarations 로 둔다.
        1. _declarations1_ 과 _declarations2_ 의 리스트 연결을 반환한다.
      </emu-alg>
      <p><emu-xref href="#sec-runtime-semantics-forinofloopevaluation"></emu-xref> 의 ForInOfLoopEvaluation 런타임 의미는 다음으로 확장된다:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _lhs_ 를 ? ResolveBinding(_bindingId_) 로 둔다.
        1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
          1. _value_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 로 둔다.
        1. Else,
          1. _rhs_ 를 |Initializer| 의 Evaluation 결과로 둔다.
          1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
        1. ? PutValue(_lhs_, _value_) 를 수행한다.
        1. _keyResult_ 를 ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~) 로 둔다.
        1. ? ForIn/OfBodyEvaluation(|BindingIdentifier|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_) 를 반환한다.
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-IsHTMLDDA-internal-slot">
      <h1>[[IsHTMLDDA]] 내부 슬롯</h1>
      <p><dfn>[[IsHTMLDDA]] 내부 슬롯</dfn> 은 호스트 정의 객체에 존재할 수 있다. [[IsHTMLDDA]] 내부 슬롯을 가진 객체는 <emu-xref href="#sec-toboolean">ToBoolean</emu-xref>, IsLooselyEqual 추상 연산 및 <emu-xref href="#sec-typeof-operator">`typeof` 연산자</emu-xref>의 피연산자로 사용될 때 *undefined* 처럼 동작한다.</p>
      <emu-note>
        <p>[[IsHTMLDDA]] 내부 슬롯을 가진 객체는 이 명세에서 생성되지 않는다. 그러나 웹 브라우저의 <a href="https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all"><code>document.all</code> 객체</a> 는 웹 호환성 목적을 위해 이 슬롯을 가진 호스트 정의 특이 객체이다. 이 종류 객체의 다른 알려진 예는 없으며 구현에서는 `document.all` 을 제외하고 새로 만들지 않아야 한다.</p>
      </emu-note>
      <p>이 기능은 다음 지점에서 특별한 의미를 포함한다:</p>
      <ul>
        <li>ToBoolean 의 <emu-xref href="#step-to-boolean-web-compat-insertion-point"></emu-xref> 단계</li>
        <li>IsLooselyEqual 의 <emu-xref href="#step-abstract-equality-comparison-web-compat-insertion-point"></emu-xref> 단계</li>
        <li>`typeof` 평가 의미의 <emu-xref href="#step-typeof-web-compat-insertion-point"></emu-xref> 단계</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-make-job-callback">
      <h1>HostMakeJobCallback 의 비기본 동작</h1>
      <p>HostMakeJobCallback 추상 연산은 웹 브라우저인 호스트가 비기본 동작을 지정할 수 있게 한다.</p>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-ensure-can-add-private-field">
      <h1>HostEnsureCanAddPrivateElement 의 비기본 동작</h1>
      <p>HostEnsureCanAddPrivateElement 추상 연산은 웹 브라우저인 호스트가 비기본 동작을 지정할 수 있게 한다.</p>
    </emu-annex>

    <emu-annex id="sec-runtime-errors-for-function-call-assignment-targets">
      <h1>함수 호출 대입 대상으로 인한 런타임 에러</h1>
      <p>함수 호출(<emu-xref href="#sec-function-calls"></emu-xref>)이 비엄격 코드에서 대입 대상(assignment target)으로 사용될 때 초기 에러를 생성하는 대신 평가 중 *ReferenceError* 예외가 발생한다.</p>
      <emu-note>
        <p>대입 대상이 |AssignmentExpression| 의 |LeftHandSideExpression| 인 경우 대입 연산자는 `=` 또는 |AssignmentOperator| 여야 한다; 특히 논리 대입 연산자(`??=`, `&&=`, `||=`)에는 이 허용이 적용되지 않는다.</p>
      </emu-note>
      <p><emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> 및 <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar> 에 대해 AssignmentTargetType 의 <emu-xref href="#step-assignmenttargettype-web-compat"></emu-xref> 단계를 참조하라.</p>
    </emu-annex>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-strict-mode-of-ecmascript">
  <h1>ECMAScript의 엄격 모드 (Strict Mode)</h1>
  <p><b>엄격 모드의 제한과 예외</b></p>
  <ul>
    <li>
      `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, `yield` 는 엄격 모드 코드 내에서 예약어이다 (<emu-xref href="#sec-keywords-and-reserved-words"></emu-xref>).
    </li>
    <li>
      적합한 구현은 엄격 모드 코드를 처리할 때 <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar> 및 <emu-grammar>DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral</emu-grammar> 생성식 인스턴스를 허용하지 않아야 한다.
    </li>
    <li>
      적합한 구현은 엄격 모드 코드를 처리할 때 <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> 및 <emu-grammar>EscapeSequence :: NonOctalDecimalEscapeSequence</emu-grammar> 생성식 인스턴스를 허용하지 않아야 한다.
    </li>
    <li>
      선언되지 않은 식별자나 그렇지 않고서는 해소 불가능한 참조에 대한 대입은 전역 객체에 프로퍼티를 생성하지 않는다. 단순 대입이 엄격 모드 코드 내에서 발생하면 그 |LeftHandSideExpression| 은 해소 불가능한 Reference 로 평가되어서는 안 된다. 그렇게 되면 *ReferenceError* 예외가 발생한다 (<emu-xref href="#sec-putvalue"></emu-xref>). 또한 |LeftHandSideExpression| 은 속성 값이 { [[Writable]]: *false* } 인 데이터 프로퍼티, 속성 값이 { [[Set]]: *undefined* } 인 접근자 프로퍼티, 또는 [[Extensible]] 내부 슬롯이 *false* 인 객체의 존재하지 않는 프로퍼티에 대한 참조여서도 안 된다. 이러한 경우 `TypeError` 예외가 발생한다 (<emu-xref href="#sec-assignment-operators"></emu-xref>).
    </li>
    <li>
      StringValue 가 *"eval"* 또는 *"arguments"* 인 |IdentifierReference| 는 대입 연산자 (<emu-xref href="#sec-assignment-operators"></emu-xref>) 혹은 |UpdateExpression| (<emu-xref href="#sec-update-expressions"></emu-xref>) 의 |LeftHandSideExpression| 으로, 또는 Prefix Increment (<emu-xref href="#sec-prefix-increment-operator"></emu-xref>) 나 Prefix Decrement (<emu-xref href="#sec-prefix-decrement-operator"></emu-xref>) 연산자의 피연산 |UnaryExpression| 으로 나타날 수 없다.
    </li>
    <li>
      엄격 함수의 arguments 객체는 접근 시 *TypeError* 예외를 던지는 설정 불가(accessor, 비구성) 접근자 프로퍼티 *"callee"* 를 정의한다 (<emu-xref href="#sec-createunmappedargumentsobject"></emu-xref>).
    </li>
    <li>
      엄격 함수의 arguments 객체는 해당 함수의 대응 형식 매개변수 바인딩과 <emu-xref href="#array-index">array-indexed</emu-xref> 프로퍼티 값을 동적으로 공유하지 않는다 (<emu-xref href="#sec-arguments-exotic-objects"></emu-xref>).
    </li>
    <li>
      엄격 함수에서 arguments 객체가 생성되는 경우 지역 식별자 `arguments` 의 그 객체에 대한 바인딩은 불변이며 따라서 대입 식의 대상이 될 수 없다 (<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>).
    </li>
    <li>
      엄격 모드 코드 내에서 |BindingIdentifier| 의 StringValue 가 *"eval"* 또는 *"arguments"* 이면 *SyntaxError* 이다 (<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      엄격 모드 eval 코드는 호출자 변수 환경 내에 변수를 또는 함수를 인스턴스화할 수 없다. 대신 새로운 변수 환경이 생성되고 그 환경이 eval 코드의 선언 바인딩 인스턴스화를 위해 사용된다 (<emu-xref href="#sec-eval-x"></emu-xref>).
    </li>
    <li>
      엄격 모드 코드 내에서 *this* 가 평가되면 *this* 값은 객체로 강제(coerce)되지 않는다. *undefined* 또는 *null* 인 *this* 값은 전역 객체로 변환되지 않으며 원시 값도 래퍼 객체로 변환되지 않는다. 함수 호출( `Function.prototype.apply`, `Function.prototype.call` 사용 호출 포함)을 통해 전달된 *this* 값은 전달된 *this* 값을 객체로 강제하지 않는다 (<emu-xref href="#sec-ordinarycallbindthis"></emu-xref>, <emu-xref href="#sec-function.prototype.apply"></emu-xref>, <emu-xref href="#sec-function.prototype.call"></emu-xref>).
    </li>
    <li>
      `delete` 연산자가 엄격 모드 코드 내에서 발생할 때 그 |UnaryExpression| 이 변수, 함수 인자, 함수 이름에 대한 직접 참조면 *SyntaxError* 가 던져진다 (<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      `delete` 연산자가 엄격 모드 코드 내에서 발생할 때 삭제할 프로퍼티가 속성 { [[Configurable]]: *false* } 를 갖거나 삭제할 수 없는 경우 *TypeError* 가 던져진다 (<emu-xref href="#sec-delete-operator-runtime-semantics-evaluation"></emu-xref>).
    </li>
    <li>
      엄격 모드 코드는 |WithStatement| 를 포함할 수 없다. 그런 문맥에서 |WithStatement| 가 나타나면 *SyntaxError* 이다 (<emu-xref href="#sec-with-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      엄격 모드 코드 내에서 |CatchParameter| 가 발생하고 그 BoundNames 가 `eval` 또는 `arguments` 를 포함하면 *SyntaxError* 이다 (<emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      동일한 |BindingIdentifier| 가 엄격 함수의 |FormalParameters| 내에서 두 번 이상 나타나면 *SyntaxError* 이다. Function, Generator, AsyncFunction 생성자를 사용하여 그러한 함수를 만들려는 시도도 *SyntaxError* 이다 (<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-createdynamicfunction"></emu-xref>).
    </li>
    <li>
      구현은 이 명세에 정의된 범위를 넘어 엄격 함수 내 함수 인스턴스의 *"caller"* 또는 *"arguments"* 라는 이름의 프로퍼티 의미를 확장할 수 없다.
    </li>
  </ul>
</emu-annex>

<emu-annex id="sec-host-layering-points">
  <h1>호스트 계층화 지점 (Host Layering Points)</h1>
  <p>호스트의 정의는 <emu-xref href="#sec-hosts-and-implementations"></emu-xref> 를 보라.</p>

  <emu-annex id="sec-host-hooks-summary">
    <h1>호스트 훅 (Host Hooks)</h1>
    <p><b>HostCallJobCallback(...)</b></p>
    <p><b>HostEnqueueFinalizationRegistryCleanupJob(...)</b></p>
    <p><b>HostEnqueueGenericJob(...)</b></p>
    <p><b>HostEnqueuePromiseJob(...)</b></p>
    <p><b>HostEnqueueTimeoutJob(...)</b></p>
    <p><b>HostEnsureCanCompileStrings(...)</b></p>
    <p><b>HostFinalizeImportMeta(...)</b></p>
    <p><b>HostGetImportMetaProperties(...)</b></p>
    <p><b>HostGrowSharedArrayBuffer(...)</b></p>
    <p><b>HostHasSourceTextAvailable(...)</b></p>
    <p><b>HostLoadImportedModule(...)</b></p>
    <p><b>HostGetSupportedImportAttributes(...)</b></p>
    <p><b>HostMakeJobCallback(...)</b></p>
    <p><b>HostPromiseRejectionTracker(...)</b></p>
    <p><b>HostResizeArrayBuffer(...)</b></p>
    <p><b>InitializeHostDefinedRealm(...)</b></p>
  </emu-annex>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>호스트 정의 필드</h1>
    <p>Realm Record 의 [[HostDefined]]: <emu-xref href="#table-realm-record-fields"></emu-xref> 참조.</p>
    <p>Script Record 의 [[HostDefined]]: <emu-xref href="#table-script-records"></emu-xref> 참조.</p>
    <p>Module Record 의 [[HostDefined]]: <emu-xref href="#table-module-record-fields"></emu-xref> 참조.</p>
    <p>JobCallback Record 의 [[HostDefined]]: <emu-xref href="#table-jobcallback-records"></emu-xref> 참조.</p>
    <p>Candidate Executions 의 [[HostSynchronizesWith]]: <emu-xref href="#table-candidate-execution-records"></emu-xref> 참조.</p>
    <p>[[IsHTMLDDA]]: <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref> 참조.</p>
  </emu-annex>

  <emu-annex id="sec-host-defined-objects-summary">
    <h1>호스트 정의 객체</h1>
    <p>전역 객체: <emu-xref href="#sec-global-object"></emu-xref> 절 참조.</p>
  </emu-annex>

  <emu-annex id="sec-host-running-jobs">
    <h1>작업 실행 (Running Jobs)</h1>
    <p>Job 추상 클로저 호출 전 준비 단계와 호출 후 정리 단계. <emu-xref href="#sec-jobs"></emu-xref> 참조.</p>
  </emu-annex>

  <emu-annex id="sec-host-internal-methods-of-exotic-objects">
    <h1>특이 객체의 내부 메서드</h1>
    <p>이 명세에 명시되지 않은 어떤 특이 객체에 대해 <emu-xref href="#table-essential-internal-methods"></emu-xref> 의 필수 내부 메서드.</p>
  </emu-annex>

  <emu-annex id="sec-host-built-in-objects-and-methods">
    <h1>내장 객체와 메서드</h1>
    <p><emu-xref href="#sec-forbidden-extensions"></emu-xref> 에서 제한된 것을 제외하고 이 명세에 정의되지 않은 내장 객체와 메서드.</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact">
  <h1>ECMAScript 2015의 정정 및 명확화 (호환성 영향 가능)</h1>
  <p><emu-xref href="#sec-candeclareglobalvar"></emu-xref>-<emu-xref href="#sec-createglobalfunctionbinding"></emu-xref>: 5 및 5.1판은 새로운 전역 선언에 해당하는 전역 객체 프로퍼티가 이미 존재하는지 판단하기 위해 프로퍼티 존재 테스트를 사용했다. ECMAScript 2015는 own 프로퍼티 존재 테스트를 사용한다. 이는 웹 브라우저에서 가장 일반적으로 구현된 방식과 일치한다.</p>
  <p><emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>: 5판은 배열 인덱스 또는 새로운 길이 값의 정수 변환 이전에 현재 배열 길이 캡처로 이동했다. 그러나 변환 과정이 배열 길이를 변경하는 부작용을 가지면 캡처된 길이 값은 무효화될 수 있었다. ECMAScript 2015는 그러한 부작용 발생 가능성 이후에 현재 배열 길이를 캡처해야 함을 명시한다.</p>
  <p><emu-xref href="#sec-timeclip"></emu-xref>: 이전 판은 0 시간 값 표현으로 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 를 TimeClip 추상 연산이 반환하도록 허용했다. ECMAScript 2015는 항상 *+0*<sub>𝔽</sub> 를 반환하도록 명시한다. 이는 2015판에서는 Date 의 시간 값이 관찰 가능하게 *-0*<sub>𝔽</sub> 가 아니며 시간 값을 반환하는 메서드는 *-0*<sub>𝔽</sub> 를 반환하지 않음을 의미한다.</p>
  <p><emu-xref href="#sec-date-time-string-format"></emu-xref>: UTC 오프셋 표현이 없으면 로컬 시간대를 사용한다. 5.1판은 빠진 시간대를 *"z"* 로 해석해야 한다고 잘못 기술했다.</p>
  <p><emu-xref href="#sec-date.prototype.toisostring"></emu-xref>: 연도가 Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>) 으로 표현될 수 없으면 RangeError 예외가 던져진다. 이전 판은 이 경우의 동작을 명시하지 않았다.</p>
  <p><emu-xref href="#sec-date.prototype.tostring"></emu-xref>: 이전 판은 시간 값이 *NaN* 일 때 `Date.prototype.toString` 이 반환하는 값을 명시하지 않았다. ECMAScript 2015는 결과가 문자열 *"Invalid Date"* 임을 명시한다.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>, <emu-xref href="#sec-escaperegexppattern"></emu-xref>: RegExp 인스턴스의 *"source"* 프로퍼티 값 내 LineTerminator 코드 포인트는 이스케이프 시퀀스로 표현되어야 한다. 5.1판은 `/` 만 이스케이프하도록 요구했다.</p>
  <p><emu-xref href="#sec-regexp.prototype-%symbol.match%"></emu-xref>, <emu-xref href="#sec-regexp.prototype-%symbol.replace%"></emu-xref>: 이전 판에서 `String.prototype.match` 및 `String.prototype.replace` 의 명세는 `global` 플래그가 설정된 RegExp 값 패턴 인수에 대해 잘못되었다. 이전 명세는 각 매칭 시도에서 `lastIndex` 가 변하지 않으면 1 증가해야 한다고 했다. 올바른 동작은 패턴이 빈 문자열과 일치한 경우에만 `lastIndex` 를 1 증가시키는 것이다.</p>
  <p><emu-xref href="#sec-array.prototype.sort"></emu-xref>: 이전 판은 _comparator_ 가 반환한 *NaN* 값이 `Array.prototype.sort` 에 의해 어떻게 해석되는지 명시하지 않았다. ECMAScript 2015는 그 값이 _comparator_ 가 *+0*<sub>𝔽</sub> 를 반환한 것처럼 취급된다고 명시한다. 또한 2015판은 _comparator_ 가 반환한 결과에 ToNumber 가 적용된다고 명시한다. 이전 판에서는 Number 값이 아닌 _comparator_ 결과의 영향이 구현 정의였다. 실제로 구현은 ToNumber 를 호출한다.</p>
</emu-annex>

<emu-annex id="sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions">
  <h1>이전 판과의 비호환성을 도입하는 추가 및 변경</h1>
  <p><emu-xref href="#sec-reference-record-specification-type"></emu-xref>: ECMAScript 2015에서 함수 호출은 Reference Record 를 반환할 수 없다.</p>
  <p><emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>: ECMAScript 2015에서 ToNumber 는 String 값에 적용될 때 |BinaryIntegerLiteral| 및 |OctalIntegerLiteral| 숫자 문자열을 인식하고 변환한다. 이전 판에서는 그러한 문자열이 *NaN* 으로 변환되었다.</p>
  <p><emu-xref href="#sec-code-realms"></emu-xref>: ECMAScript 2018에서 템플릿 객체는 이전 판의 Realm 내 템플릿 리터럴 또는 태그된 템플릿 모든 출현 간이 아니라 Parse Node (소스 위치) 기반으로 정규화된다.</p>
  <p><emu-xref href="#sec-white-space"></emu-xref>: ECMAScript 2016에서 Unicode 8.0.0 이상이 요구된다(2015판은 Unicode 5.1 요구). 특히 U+180E MONGOLIAN VOWEL SEPARATOR 가 `Space_Separator` (`Zs`) 범주에서 `Format` (`Cf`) 범주로 이동(Unicode 6.3.0)하여 공백 처리 메서드의 동작이 달라진다. 예: `"\u180E".trim().length` 는 이전 판에서 `0` 이었지만 ECMAScript 2016 이후 `1`. 또한 ECMAScript 2017은 항상 최신 Unicode 표준 사용을 요구.</p>
  <p><emu-xref href="#sec-names-and-keywords"></emu-xref>: ECMAScript 2015에서 |IdentifierName| 유효 코드 포인트는 Unicode 속성 “ID_Start”, “ID_Continue” 로 지정된다. 이전 판에서는 유효 |IdentifierName| 또는 |Identifier| 코드 포인트가 다양한 Unicode 범주를 열거하여 지정되었다.</p>
  <p><emu-xref href="#sec-rules-of-automatic-semicolon-insertion"></emu-xref>: ECMAScript 2015에서 자동 세미콜론 삽입은 do-while 문 끝에 세미콜론이 없으면 추가한다. 이 변경은 대부분 구현의 실제 동작과 일치.</p>
  <p><emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>: ECMAScript 2015에서 Object Initializer 내 중복 프로퍼티 이름은 더 이상 초기 에러가 아니다.</p>
  <p><emu-xref href="#sec-assignment-operators-static-semantics-early-errors"></emu-xref>: ECMAScript 2015에서 |FunctionExpression| 의 함수 이름과 같은 불변 바인딩에 대한 대입을 포함한 엄격 모드 코드는 초기 에러를 발생시키지 않고 런타임 에러를 발생시킨다.</p>
  <p><emu-xref href="#sec-block"></emu-xref>: ECMAScript 2015에서 토큰 let 으로 시작하고 그 뒤에 입력 요소 |LineTerminator| 및 |Identifier| 가 따라오는 |StatementList| 는 |LexicalDeclaration| 시작이다. 이전 판에서는 자동 세미콜론 삽입이 항상 |Identifier| 입력 요소 앞에 세미콜론 삽입.</p>
  <p><emu-xref href="#sec-expression-statement"></emu-xref>: ECMAScript 2015에서 토큰 `let` 으로 시작하고 토큰 `[` 가 뒤따르는 |StatementListItem| 은 |LexicalDeclaration| 시작이다. 이전 판에서는 그러한 시퀀스가 |ExpressionStatement| 시작이었다.</p>
  <p><emu-xref href="#sec-if-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015에서 |IfStatement| 의 정상 결과는 결코 ~empty~ 값이 아니다. 어떤 |Statement| 부분도 평가되지 않거나 평가된 |Statement| 부분이 ~empty~ 를 포함하는 정상 완료를 생성하면 결과는 *undefined*.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015에서 for 문 `(` 토큰 바로 뒤에 토큰 시퀀스 `let [` 가 오면 `let` 은 |LexicalDeclaration| 시작으로 처리된다. 이전 판에서는 그 시퀀스가 |Expression| 시작.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015에서 for-in 문 `(` 토큰 바로 뒤에 토큰 시퀀스 `let [` 가 오면 `let` 은 |ForDeclaration| 시작으로 처리된다. 이전 판에서는 그 시퀀스가 |LeftHandSideExpression| 시작.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015 이전에는 초기화 식이 `in` 키워드 앞 |VariableDeclaration| 일부로 나타날 수 있었다. ECMAScript 2015에서 동일 위치의 |ForBinding| 은 그러한 초기화자의 출현을 허용하지 않는다. ECMAScript 2017에서 그러한 초기화자는 비엄격 코드에서만 허용.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: ECMAScript 2015에서 |IterationStatement| 평가 결과는 결코 [[Value]] 가 ~empty~ 인 정상 완료가 아니다. |Statement| 부분이 평가되지 않았거나 최종 평가가 [[Value]] ~empty~ 인 정상 완료를 생성하면 결과 [[Value]] 는 *undefined* 인 정상 완료.</p>
  <p><emu-xref href="#sec-with-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015에서 |WithStatement| 평가 결과는 결코 [[Value]] 가 ~empty~ 인 정상 완료가 아니다. |Statement| 부분 평가가 [[Value]] ~empty~ 인 정상 완료를 생성하면 결과 [[Value]] 는 *undefined*.</p>
  <p><emu-xref href="#sec-switch-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015에서 |SwitchStatement| 평가 결과는 결코 [[Value]] 가 ~empty~ 인 정상 완료가 아니다. |CaseBlock| 부분 평가가 [[Value]] ~empty~ 인 정상 완료를 생성하면 결과 [[Value]] 는 *undefined*.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>: ECMAScript 2015에서 |Catch| 절이 매개변수와 동일한 |Identifier| 에 대해 `var` 선언을 포함하면 초기 에러이다. 이전 판에서는 그러한 변수 선언이 둘러싼 변수 환경에서 인스턴스화되지만 선언의 |Initializer| 값이 |Catch| 매개변수에 할당되었다.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>, <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref>: ECMAScript 2015에서 |Catch| 절이 동일한 |Identifier| 를 바인딩하는 `var` 또는 `FunctionDeclaration` 을 포함하는 비엄격 direct `eval` 을 평가하면 런타임 *SyntaxError* 가 던져진다.</p>
  <p><emu-xref href="#sec-try-statement-runtime-semantics-evaluation"></emu-xref>: ECMAScript 2015에서 |TryStatement| 결과는 결코 ~empty~ 값이 아니다. |Block| 부분이 ~empty~ 를 포함하는 정상 완료로 평가되면 결과는 *undefined*. |Block| 부분이 throw 완료로 평가되고 |Catch| 부분이 ~empty~ 정상 완료를 평가하면 |Finally| 가 없거나 |Finally| 가 ~empty~ 정상 완료로 평가되는 경우 결과는 *undefined*.</p>
  <p><emu-xref href="#sec-runtime-semantics-methoddefinitionevaluation"></emu-xref>: ECMAScript 2015에서 |ObjectLiteral| 의 접근자 프로퍼티 [[Get]] 또는 [[Set]] 속성 값으로 생성된 함수 객체는 생성자 함수가 아니며 *"prototype"* own 프로퍼티를 갖지 않는다. 이전 판에서는 생성자이며 *"prototype"* 프로퍼티가 있었다.</p>
  <p><emu-xref href="#sec-object.freeze"></emu-xref>: ECMAScript 2015에서 `Object.freeze` 인수가 객체가 아니면 자체 프로퍼티가 없는 비확장 ordinary 객체처럼 취급된다. 이전 판에서는 비객체 인수는 항상 *TypeError* 발생.</p>
  <p><emu-xref href="#sec-object.getownpropertydescriptor"></emu-xref>: ECMAScript 2015에서 `Object.getOwnPropertyDescriptor` 인수가 객체가 아니면 ToObject 사용 강제를 시도한다. 성공 시 결과가 원래 인수 대신 사용. 이전 판에서는 비객체 인수가 항상 *TypeError*.</p>
  <p><emu-xref href="#sec-object.getownpropertynames"></emu-xref>: ECMAScript 2015에서 `Object.getOwnPropertyNames` 인수가 객체가 아니면 ToObject 강제를 시도. 성공 시 결과 사용. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.getprototypeof"></emu-xref>: ECMAScript 2015에서 `Object.getPrototypeOf` 인수가 객체가 아니면 ToObject 강제를 시도. 성공하면 결과 사용. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.isextensible"></emu-xref>: ECMAScript 2015에서 `Object.isExtensible` 인수가 객체가 아니면 자체 프로퍼티 없는 비확장 ordinary 객체처럼 취급. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.isfrozen"></emu-xref>: ECMAScript 2015에서 `Object.isFrozen` 인수가 객체가 아니면 자체 프로퍼티 없는 비확장 ordinary 객체처럼 취급. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.issealed"></emu-xref>: ECMAScript 2015에서 `Object.isSealed` 인수가 객체가 아니면 자체 프로퍼티 없는 비확장 ordinary 객체처럼 취급. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.keys"></emu-xref>: ECMAScript 2015에서 `Object.keys` 인수가 객체가 아니면 ToObject 강제를 시도. 성공 시 결과 사용. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.preventextensions"></emu-xref>: ECMAScript 2015에서 `Object.preventExtensions` 인수가 객체가 아니면 자체 프로퍼티 없는 비확장 ordinary 객체처럼 취급. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-object.seal"></emu-xref>: ECMAScript 2015에서 `Object.seal` 인수가 객체가 아니면 자체 프로퍼티 없는 비확장 ordinary 객체처럼 취급. 이전 판에서는 *TypeError*.</p>
  <p><emu-xref href="#sec-function.prototype.bind"></emu-xref>: ECMAScript 2015에서 바운드 함수의 [[Prototype]] 내부 슬롯은 대상 함수의 [[GetPrototypeOf]] 값으로 설정된다. 이전 판에서는 항상 %Function.prototype%.</p>
  <p><emu-xref href="#sec-function-instances-length"></emu-xref>: ECMAScript 2015에서 함수 인스턴스의 *"length"* 프로퍼티는 설정 가능(configurable)하다. 이전 판에서는 불가능.</p>
  <p><emu-xref href="#sec-properties-of-the-nativeerror-constructors"></emu-xref>: ECMAScript 2015에서 _NativeError_ 생성자의 [[Prototype]] 내부 슬롯은 Error 생성자이다. 이전 판에서는 Function prototype 객체.</p>
  <p><emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref>: ECMAScript 2015에서 Date 프로토타입 객체는 Date 인스턴스가 아니다. 이전 판에서는 TimeValue 가 *NaN* 인 Date 인스턴스였다.</p>
  <p><emu-xref href="#sec-string.prototype.localecompare"></emu-xref>: ECMAScript 2015에서 `String.prototype.localeCompare` 는 Unicode 표준에 따라 정규 동등(canonical equivalence)한 문자열을 동일하게 취급해야 한다. 이전 판에서는 구현이 이를 무시하고 비트 단위 비교 사용 가능.</p>
  <p><emu-xref href="#sec-string.prototype.tolowercase"></emu-xref> 및 <emu-xref href="#sec-string.prototype.touppercase"></emu-xref>: ECMAScript 2015에서 소문자/대문자 변환 처리는 코드 포인트에 작동한다. 이전 판에서는 개별 코드 유닛에만 적용. 영향받는 코드는 Deseret 블록.</p>
  <p><emu-xref href="#sec-string.prototype.trim"></emu-xref>: ECMAScript 2015에서 `String.prototype.trim` 은 Unicode BMP 밖에 존재할 수 있는 공백 코드 포인트 인식을 정의. Unicode 7 시점에는 그런 코드 포인트 없음. 이전 판에서는 그런 코드 포인트를 공백으로 인식하지 않았을 것.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>: ECMAScript 2015에서 _pattern_ 인수가 RegExp 인스턴스이고 _flags_ 인수가 *undefined* 가 아니면 _pattern_ 의 플래그를 _flags_ 로 교체한 새로운 RegExp 인스턴스 생성. 이전 판에서는 _pattern_ 이 RegExp 인스턴스이고 _flags_ 가 *undefined* 가 아니면 *TypeError*.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref>: ECMAScript 2015에서 RegExp 프로토타입 객체는 RegExp 인스턴스가 아니다. 이전 판에서는 패턴이 빈 문자열인 RegExp 인스턴스였다.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref>: ECMAScript 2015에서 *"source"*, *"global"*, *"ignoreCase"*, *"multiline"* 은 RegExp 프로토타입 객체에 정의된 접근자 프로퍼티이다. 이전 판에서는 RegExp 인스턴스에 정의된 데이터 프로퍼티.</p>
  <p><emu-xref href="#sec-atomics.notify"></emu-xref>: ECMAScript 2019에서 `Atomics.wake` 는 `Atomics.wait` 와의 혼동을 방지하기 위해 `Atomics.notify` 로 이름 변경.</p>
  <p><emu-xref href="#sec-asyncfromsynciteratorcontinuation"></emu-xref>, <emu-xref href="#sec-asyncgeneratorresume"></emu-xref>: ECMAScript 2019에서 `await` 가 큐에 넣는 Job 수가 감소하여 `then()` 호출과 `await` 표현식 간 해석 순서의 관찰 가능 차이가 생길 수 있음.</p>
</emu-annex>

<emu-annex id="sec-bibliography" back-matter>
  <h1>참고 문헌 (Bibliography)</h1>
  <ol>
    <li>
      <dfn>IEEE 754-2019</dfn>: <i>IEEE Standard for Floating-Point Arithmetic</i>. Institute of Electrical and Electronic Engineers, New York (2019)
      <emu-note>
        <p>IEEE 754-2008 과 IEEE 754-2019 사이 ECMA-262 명세에 영향을 주는 규범적 변경은 없다.</p>
      </emu-note>
    </li>
    <li>
      <i>The Unicode Standard</i>, &lt;<a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Technical Note #5: Canonical Equivalence in Applications</i>, &lt;<a href="https://unicode.org/notes/tn5/">https://unicode.org/notes/tn5/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Technical Standard #10: Unicode Collation Algorithm</i>, &lt;<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Standard Annex #15, Unicode Normalization Forms</i>, &lt;<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Standard Annex #18: Unicode Regular Expressions</i>, &lt;<a href="https://unicode.org/reports/tr18/">https://unicode.org/reports/tr18/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Standard Annex #24: Unicode `Script` Property</i>, &lt;<a href="https://unicode.org/reports/tr24/">https://unicode.org/reports/tr24/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax</i>, &lt;<a href="https://unicode.org/reports/tr31/">https://unicode.org/reports/tr31/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Standard Annex #44: Unicode Character Database</i>, &lt;<a href="https://unicode.org/reports/tr44/">https://unicode.org/reports/tr44/</a>> 에서 이용 가능
    </li>
    <li>
      <i>Unicode Technical Standard #51: Unicode Emoji</i>, &lt;<a href="https://unicode.org/reports/tr51/">https://unicode.org/reports/tr51/</a>> 에서 이용 가능
    </li>
    <li>
      <i>IANA Time Zone Database</i>, &lt;<a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>> 에서 이용 가능
    </li>
    <li>
      ISO 8601:2004(E) <i>Data elements and interchange formats — Information interchange — Representation of dates and times</i>
    </li>
    <li>
      <i>RFC 1738 “Uniform Resource Locators (URL)”</i>, &lt;<a href="https://tools.ietf.org/html/rfc1738">https://tools.ietf.org/html/rfc1738</a>>
    </li>
    <li>
      <i>RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”</i>, &lt;<a href="https://tools.ietf.org/html/rfc2396">https://tools.ietf.org/html/rfc2396</a>>
    </li>
    <li>
      <i>RFC 3629 “UTF-8, a transformation format of ISO 10646”</i>, &lt;<a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>>
    </li>
    <li>
      <i>RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”</i>, &lt;<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>>
    </li>
  </ol>
</emu-annex>

<emu-annex id="sec-colophon" back-matter>
  <h1>콜로폰 (Colophon)</h1>
  <p>이 명세는 <a href="https://github.com/tc39/ecma262">GitHub</a> 에서 <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a> 라는 플레인텍스트 소스 포맷으로 작성된다. Ecmarkup 은 HTML 과 Markdown 방언으로, 플레인텍스트로 Ecma 명세를 작성하고 이를 본 문서의 편집 관례를 따르는 기능 완비 HTML 렌더링으로 처리하기 위한 프레임워크 및 도구 세트를 제공한다. Ecmarkup 은 구문 정의를 위한 <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a>, 알고리즘 단계를 작성하기 위한 <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> 등 여러 형식과 기술을 통합한다. 이 명세의 PDF 렌더링은 CSS Paged Media 명세를 활용하는 인쇄 스타일시트를 사용하여 생성되며 <a href="https://www.princexml.com/">PrinceXML</a> 을 사용해 변환된다.</p>
  <p>이전 판은 Word 를 사용해 작성되었으며—이 판의 기반이 된 Ecmarkup 소스 텍스트는 ECMAScript 2015 Word 문서를 자동 변환 도구로 Ecmarkup 으로 변환하여 생성되었다.</p>
</emu-annex>
