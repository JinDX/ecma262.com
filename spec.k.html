<!DOCTYPE html>
<html lang="ko">
<meta charset="utf-8">
<link rel="icon" href="img/favicon.ico">
<style>
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }

  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }

  #ecma-logo {
    width: 500px;
  }

  .corner-cell {
    position: relative;
    height: 2lh;
  }
  .corner-cell .slash {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom left, transparent calc(50% - 1px), gray, transparent calc(50% + 1px));
  }
  .corner-cell > .column {
    position: absolute;
    bottom: 0.4em;
    left: 1em;
  }
  .corner-cell > .row {
    position: absolute;
    top: 0.4em;
    right: 1em;
  }
</style>
<style media="print">
  /**
  * ECMA-262-specific hacks. Shouldn't require a ton of maintenance; audit if
  * visual inspection results in unexpected page breaks.
  *
  * For print version, the table captioned "Module fields after the initial Evaluate() call" _may_ need to set the row
  * EVALUATING-ASYNC to one cell with a colspan of 5. It typically does not fit on the page, but the cell merging is
  * not a perfectly accurate solution and will not be merged back in to the specification.
  * See https://github.com/tc39/ecma262/pull/3623#issuecomment-3029366960
  */

  /* Make sure tables are wide enough for their captions */
  table {
    min-width: 135mm;
  }

  /* 2.2 Examples of legacy/normative-optional are small enough to be aggressive against breaks */
  #sec-conformance [example],
  /* 16.2.1.xxx many tables */
  #sec-example-cyclic-module-record-graphs table {
    break-inside: avoid-page;
  }

  /* 12.10.1 long note can break wherever it wants */
  #sec-rules-of-automatic-semicolon-insertion > emu-note {
    break-before: initial;
    break-inside: initial;
  }

  /* 12.10.X Sections start with an <em> not inside a <p> */
  #sec-examples-of-automatic-semicolon-insertion > em,
  #sec-interesting-cases-of-automatic-semicolon-insertion > em,
  #sec-asi-cases-with-no-lineterminator-here > em {
    display: block;
    margin-top: 1.25ex;
  }

  /* 15.1.X missing spacing between intro and first emu-grammar */
  #sec-static-semantics-containsexpression > emu-grammar:first-of-type {
    margin-top: 2ex;
  }

  /* 15.3 A very long term combined with inline-block, nowrap, and justified text resulting in weird punctuation */
  #sec-arrow-function-definitions > p > emu-grammar {
    text-align: left;
  }

  /* 20.X legacy title */
  #sec-object\.prototype\.__proto__ > .attributes-tag {
    break-before: avoid-page;
    break-after: avoid-page;
  }

  /* 21.X table middle column is too narrow */
  #table-time-zone-identifier-record-fields > figure > table th:nth-of-type(2) {
    min-width: 19mm;
  }

  /* 29.X extremely long note */
  #sec-shared-memory-guidelines > emu-note {
    break-inside: auto;
  }

  .unicode-property-table {
    table-layout: initial;
    width: auto;
    font-size: 90%;
  }

  .unicode-property-table th:first-of-type {
    width: 33%;
  }

  .corner-cell {
    background-image: url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI0NiIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNSIgd2lkdGg9IjI0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzE1LjI2NiAzOTYuMzQzIDI0MS4zOTQgNDUuMTU1IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS4wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMxNC45MyAtMzk1LjkzNSkiLz48L3N2Zz4=);
    background-repeat: no-repeat;
    background-size: 100% 3em;
    height: 3em;
    padding: 0;
    vertical-align: inherit;
    position: static;
  }

  .corner-cell .slash {
    display: none;
  }

  .corner-cell > .column, .corner-cell > .row {
    display: block;
    position: relative;
  }

  .corner-cell > .row {
    text-align: right;
    top: -0.75em
  }

  .corner-cell > .column {
    text-align: left;
    bottom: -1.25em;
  }
</style>
<pre class="metadata">
  title: ECMAScript<sup>&reg;</sup> 2026 언어&nbsp;명세서
  shortname: ECMA-262
  status: draft
  location: https://tc39.es/ecma262/
  markEffects: true
</pre>
<p><img src="img/ecma-logo.svg" id="ecma-logo" alt="Ecma International 로고"></p>
<div id="metadata-block">
  <h1>이 명세서에 대하여</h1>
  <p><a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>에 있는 문서는 가장 정확하고 최신의 ECMAScript 명세서입니다. 이 문서에는 가장 최근 연간 스냅샷의 내용과, 그 스냅샷 이후의 <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md">완료된 제안</a>(<a href="https://tc39.es/process-document/">제안 절차</a>에서 Stage&nbsp;4에 도달하여 여러 구현에 적용되었고 다음 실질적인 개정에 포함될 제안)이 함께 담겨 있습니다.</p>
  <p>이 문서는 <a href>단일 페이지</a>와 <a href="multipage/">여러 페이지</a>로 제공됩니다.</p>
  <h1>이 명세서에 기여하기</h1>
  <p>이 명세서는 ECMAScript 커뮤니티의 도움으로 GitHub에서 개발됩니다. 명세서 개발에 기여하는 방법은 여러 가지가 있습니다:</p>
  <ul>
    <li>GitHub 저장소: <a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></li>
    <li>이슈: <a href="https://github.com/tc39/ecma262/issues">전체 이슈</a>, <a href="https://github.com/tc39/ecma262/issues/new">새 이슈 등록</a></li>
    <li>풀 리퀘스트: <a href="https://github.com/tc39/ecma262/pulls">전체 풀 리퀘스트</a>, <a href="https://github.com/tc39/ecma262/pulls/new">새 풀 리퀘스트 생성</a></li>
    <li>테스트 슈트: <a href="https://github.com/tc39/test262">Test262</a></li>
    <li>
      편집자:
      <ul>
        <li><a href="mailto:shu at rfrn dot org">Shu-yu Guo</a></li>
        <li><a href="mailto:ecma262-editor-list at michael dot ficarra dot me">Michael Ficarra</a> (<a href="https://bsky.app/profile/michael.ficarra.me">@michael.ficarra.me</a>)</li>
        <li><a href="mailto:bakkot at gmail dot com">Kevin Gibbons</a></li>
      </ul>
    </li>
    <li>
      커뮤니티:
      <ul>
        <li>디스코스: <a href="https://es.discourse.group">https://es.discourse.group/</a></li>
        <li>채팅: <a href="https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md">Matrix</a></li>
        <li>이메일 <emu-not-ref>목록</emu-not-ref> 아카이브: <a href="https://esdiscuss.org">https://esdiscuss.org/</a></li>
      </ul>
    </li>
  </ul>
  <p>이 문서가 어떻게 작성되는지 더 자세한 내용은 <emu-xref href="#sec-colophon">colophon</emu-xref>을 참고하세요.</p>
</div>

<emu-intro id="sec-intro">
  <h1>소개</h1>
  <p>이 Ecma 표준은 ECMAScript 2026 언어를 정의합니다. 이는 ECMAScript 언어 명세서의 열일곱 번째 판입니다. 1997년 첫 판이 발표된 이후 ECMAScript는 세계에서 가장 널리 사용되는 범용 프로그래밍 언어 중 하나로 성장했습니다. 웹 브라우저에 내장된 언어로 가장 잘 알려져 있지만, 서버 및 임베디드 애플리케이션에서도 널리 채택되었습니다.</p>
  <p>ECMAScript는 여러 기술에서 유래했으며, 그 중 가장 잘 알려진 것은 JavaScript(Netscape)와 JScript(Microsoft)입니다. 이 언어는 Netscape의 Brendan Eich가 발명하였으며, 최초로 해당 회사의 Navigator 2.0 브라우저에 등장했습니다. 이후 Netscape의 모든 브라우저와 Microsoft의 Internet Explorer 3.0부터 모든 브라우저에 포함되었습니다.</p>
  <p>ECMAScript 언어 명세서의 개발은 1996년 11월에 시작되었습니다. 이 Ecma 표준의 첫 번째 판은 1997년 6월 Ecma 총회에서 채택되었습니다.</p>
  <p>그 Ecma 표준은 ISO/IEC JTC 1에 신속 채택 절차(fast-track procedure)를 통해 제출되었고, 1998년 4월 국제 표준 ISO/IEC 16262로 승인되었습니다. 1998년 6월 Ecma 총회에서 ECMA-262 두 번째 판이 승인되어 ISO/IEC 16262와 완전히 일치하게 되었습니다. 첫 번째 판과 두 번째 판의 변경 사항은 편집상의 변화입니다.</p>
  <p>표준의 세 번째 판에서는 강력한 정규 표현식, 향상된 문자열 처리, 새로운 제어문, try/catch 예외 처리, 오류 정의 강화, 숫자 출력 형식 지정, 그리고 향후 언어 성장을 대비한 소규모 변경 사항이 도입되었습니다. ECMAScript 표준의 세 번째 판은 1999년 12월 Ecma 총회에서 채택되었고, 2002년 6월 ISO/IEC 16262:2002로 출판되었습니다.</p>
  <p>세 번째 판이 출판된 이후 ECMAScript는 월드 와이드 웹과 결합되어 거의 모든 웹 브라우저에서 지원되는 프로그래밍 언어로 대규모로 채택되기에 이르렀습니다. ECMAScript의 네 번째 판 개발을 위한 많은 작업이 이루어졌지만 완전히 완료되지 않았고, ECMAScript의 네 번째 판으로 출판되지 않았습니다. 하지만 그 중 일부는 여섯 번째 판 개발에 통합되었습니다.</p>
  <p>ECMAScript 다섯 번째 판(ECMA-262 5<sup>판</sup>으로 출판)은 브라우저 구현에서 일반적으로 사용되는 언어 명세서의 사실상 해석을 표준화하고, 세 번째 판 출판 이후 등장한 새로운 기능 지원을 추가했습니다. 이러한 기능에는 접근자 속성, 객체의 반사적 생성 및 검사, 속성 속성의 프로그램 제어, 추가 배열 조작 함수, JSON 객체 인코딩 형식 지원, 향상된 오류 검사와 프로그램 보안을 제공하는 엄격 모드 등이 포함됩니다. 다섯 번째 판은 2009년 12월 Ecma 총회에서 채택되었습니다.</p>
  <p>다섯 번째 판은 ISO/IEC JTC 1에 신속 채택 절차로 제출되어 국제 표준 ISO/IEC 16262:2011로 승인되었습니다. ECMAScript 표준의 5.1 판은 소규모 수정이 통합되었고, ISO/IEC 16262:2011과 동일한 텍스트입니다. 5.1 판은 2011년 6월 Ecma 총회에서 채택되었습니다.</p>
  <p>여섯 번째 판의 집중적인 개발은 2009년에 시작되었으며, 다섯 번째 판이 출판 준비 중이던 시점입니다. 하지만 이는 1999년 세 번째 판 출판 이후 진행된 상당한 실험과 언어 개선 설계 노력에 선행되었습니다. 실제로 여섯 번째 판 완성은 15년의 노력의 결실이라 할 수 있습니다. 이 판의 목표에는 대규모 애플리케이션 지원 강화, 라이브러리 제작, 그리고 ECMAScript를 다른 언어의 컴파일 대상로 사용하는 데의 지원 강화가 포함되었습니다. 주요 개선 사항으로는 모듈, 클래스 선언, 렉시컬 블록 스코핑, 이터레이터와 제너레이터, 비동기 프로그래밍을 위한 프로미스, 구조 분해 패턴, proper tail call 등이 있습니다. ECMAScript 내장 라이브러리는 맵, 셋, 바이너리 숫자값 배열과 같은 추가 데이터 추상화를 지원하도록 확장되었고, 문자열과 정규 표현식에서 유니코드 보조 문자 지원이 강화되었습니다. 내장 객체는 서브클래싱을 통해 확장 가능해졌습니다. 여섯 번째 판은 정기적이고 점진적인 언어 및 라이브러리 개선의 기반을 제공합니다. 여섯 번째 판은 2015년 6월 총회에서 채택되었습니다.</p>
  <p>ECMAScript 2016은 Ecma TC39의 새로운 연간 릴리스 주기 및 공개 개발 프로세스 하에 발표된 최초의 ECMAScript 판입니다. 평문 소스 문서가 ECMAScript 2015 소스 문서에서 구축되어 GitHub에서의 추가 개발의 기반이 되었습니다. 이 표준의 개발 기간 동안 수백 건의 풀 리퀘스트와 이슈가 제출되었으며, 이는 수천 건의 버그 수정, 편집적 수정, 기타 개선사항을 대표합니다. 또한 Ecmarkup, Ecmarkdown, Grammarkdown 등 개발을 지원하는 다양한 소프트웨어 도구가 개발되었습니다. ES2016에는 새로운 거듭제곱 연산자와 `Array.prototype`에 `includes`라는 새로운 메소드가 추가되었습니다.</p>
  <p>ECMAScript 2017에서는 Async 함수, Shared Memory, Atomics가 도입되었고, 소규모 언어 및 라이브러리 개선, 버그 수정, 편집적 업데이트가 이루어졌습니다. Async 함수는 프로미스를 반환하는 함수에 대한 문법을 제공하여 비동기 프로그래밍 경험을 향상합니다. Shared Memory와 Atomics는 멀티 에이전트 프로그램이 병렬 CPU 환경에서도 잘 정의된 실행 순서를 보장하는 원자적 연산을 사용하여 통신할 수 있는 새로운 메모리 모델을 도입합니다. 또한 Object에 새로운 정적 메소드인 `Object.values`, `Object.entries`, `Object.getOwnPropertyDescriptors`가 추가되었습니다.</p>
  <p>ECMAScript 2018에서는 async 이터레이터 프로토콜과 async 제너레이터를 통한 비동기 이터레이션 지원이 도입되었습니다. 또한 네 가지 새로운 정규 표현식 기능(`dotAll` 플래그, 명명된 캡처 그룹, 유니코드 속성 이스케이프, 후행 어설션)을 추가하였고, 객체의 rest 및 spread 속성도 포함되었습니다.</p>
  <p>ECMAScript 2019에서는 몇 가지 새로운 내장 함수가 도입되었습니다: 배열 평탄화를 위한 `Array.prototype`의 `flat` 및 `flatMap`, `Object.entries`의 반환값을 바로 새 객체로 변환하는 `Object.fromEntries`, 더 적절한 이름의 `String.prototype.trimStart`와 `trimEnd`(비표준 내장인 `String.prototype.trimLeft`와 `trimRight`의 대안). 또한 구문 및 의미론에 일부 소규모 업데이트가 있었습니다. 업데이트된 구문에는 catch 바인딩 매개변수 선택적 사용, JSON에 맞추어 문자열 리터럴에서 U+2028(줄 구분자) 및 U+2029(단락 구분자) 허용 등이 있습니다. 기타 업데이트로는 `Array.prototype.sort`의 안정 정렬 요구, `JSON.stringify`의 입력과 관계없이 올바른 UTF-8 반환 요구, `Function.prototype.toString`의 명확화(원본 소스 텍스트 또는 표준 플레이스홀더 반환 요구) 등이 있습니다.</p>
  <p>ECMAScript 2020, 11<sup>판</sup>에서는 문자열의 모든 매치 객체를 반복자로 반환하는 `matchAll` 메소드, 동적 지정자를 통해 모듈을 비동기적으로 import할 수 있는 `import()` 구문, 임의 정밀도의 정수 작업을 위한 새로운 숫자 원시 타입인 `BigInt`, 단락 회로 없이 동작하는 새로운 Promise 결합자인 `Promise.allSettled`, 전역 `this` 값을 보편적으로 접근하는 방법인 `globalThis`, 모듈 내에서 사용할 수 있는 `export * as ns from 'module'` 구문, `for-in` 열거 순서의 표준화 강화, 모듈 내에서 컨텍스트 정보를 담을 수 있는 호스트가 채워주는 객체인 `import.meta`, 그리고 nullish 값(*undefined* 또는 *null*)을 다루기 위한 두 가지 구문(nullish 병합 연산자와 옵셔널 체이닝)이 추가되었습니다.</p>
  <p>ECMAScript 2021, 12<sup>판</sup>에서는 문자열의 `replaceAll` 메소드, 입력 값이 이행될 때 단락 회로가 발생하는 Promise 결합자인 `Promise.any`, 여러 오류를 한 번에 표현하는 새로운 오류 타입인 `AggregateError`, 논리 할당 연산자(`??=`, `&&=`, `||=`), 객체를 가비지 컬렉션에서 보호하지 않고 참조할 수 있는 `WeakRef`와 가비지 컬렉션 시 정리 작업 등록 및 해제를 관리하는 `FinalizationRegistry`, 숫자 리터럴 구분자(`1_000`), 그리고 `Array.prototype.sort`의 동작을 더 정확하게 하여 구현 정의 정렬 순서 발생을 줄였습니다.</p>
  <p>ECMAScript 2022, 13<sup>판</sup>에서는 모듈 최상위에서 `await` 키워드를 사용할 수 있게 되었고, 클래스 내에 새로운 요소(공개 및 비공개 인스턴스 필드, 공개 및 비공개 정적 필드, 비공개 인스턴스 메소드 및 접근자, 비공개 정적 메소드 및 접근자), 클래스 내부에서 평가 초기화를 위한 정적 블록, 객체의 비공개 필드 존재를 테스트하는 `#x in obj` 구문, 정규 표현식의 매치 인덱스를 제공하는 `/d` 플래그, 오류의 인과 관계를 기록하는 `Error` 객체의 `cause` 속성, 상대 인덱싱을 가능하게 하는 문자열/배열/TypedArray의 `at` 메소드, 그리고 `Object.hasOwn`(기존 `Object.prototype.hasOwnProperty`의 간편 대안)이 도입되었습니다.</p>
  <p>ECMAScript 2023, 14<sup>판</sup>에서는 `Array.prototype` 및 `TypedArray.prototype`의 `toSorted`, `toReversed`, `with`, `findLast`, `findLastIndex` 메소드, 그리고 `Array.prototype`의 `toSpliced` 메소드가 도입되었습니다. 파일 시작 부분에 `#!` 주석을 허용하여 실행 가능한 ECMAScript 파일 지원이 강화되었고, 대부분의 Symbol을 weak collection의 키로 사용할 수 있게 되었습니다.</p>
  <p>ECMAScript 2024, 15<sup>판</sup>에서는 ArrayBuffer와 SharedArrayBuffer의 크기 조정 및 전송 기능, 문자열 집합 작업을 위한 고급 기능을 가진 RegExp `/v` 플래그, Promise를 쉽게 생성하기 위한 `Promise.withResolvers` 메소드, 데이터 집계용 `Object.groupBy` 및 `Map.groupBy` 메소드, 공유 메모리 변경을 비동기적으로 기다리는 `Atomics.waitAsync` 메소드, 문자열이 올바른 유니코드만 포함하는지 확인/보장하는 `String.prototype.isWellFormed` 및 `String.prototype.toWellFormed` 메소드가 도입되었습니다.</p>
  <p>ECMAScript 2025, 16<sup>판</sup>에서는 이터레이터 작업을 위한 새로운 전역 `Iterator`와 관련 정적 및 프로토타입 메소드, `Set.prototype`의 셋 작업용 메소드, JSON 모듈 import 및 import된 모듈의 속성 선언 구문, 정규 표현식 안전 문자열 이스케이프를 위한 `RegExp.escape` 메소드, 정규 표현식 내에서 인라인 플래그 활성/비활성화 구문, 함수가 Promise를 반환하든 아니든 항상 Promise를 반환하게 하는 `Promise.try` 메소드, 새로운 TypedArray 종류인 `Float16Array`와 관련된 `DataView.prototype.getFloat16`, `DataView.prototype.setFloat16`, `Math.f16round` 메소드가 추가되었습니다.</p>
  <p>Ecma TC39 내에서 많은 단체를 대표하는 수십 명의 개인이 이번 판뿐만 아니라 이전 판의 개발에도 매우 중요한 기여를 했습니다. 또한 TC39의 ECMAScript 활동을 지원하는 활발한 커뮤니티가 성장했습니다. 이 커뮤니티는 수많은 초안 검토, 수천 건의 버그 리포트 제출, 구현 실험, 테스트 슈트 기여, ECMAScript에 대해 전 세계 개발자 커뮤니티를 교육하는 역할을 했습니다. 유감스럽게도 이 노력에 기여한 모든 개인과 단체를 식별하고 인정하는 것은 불가능합니다.</p>
  <p>
    Allen Wirfs-Brock<br>
    ECMA-262, 프로젝트 편집자, 6<sup>판</sup>
  </p>
  <p>
    Brian Terlson<br>
    ECMA-262, 프로젝트 편집자, 7<sup>판</sup> ~ 10<sup>판</sup>
  </p>
  <p>
    Jordan Harband<br>
    ECMA-262, 프로젝트 편집자, 10<sup>판</sup> ~ 12<sup>판</sup>
  </p>
  <p>
    Shu-yu Guo<br>
    ECMA-262, 프로젝트 편집자, 12<sup>판</sup> ~ 16<sup>판</sup>
  </p>
  <p>
    Michael Ficarra<br>
    ECMA-262, 프로젝트 편집자, 12<sup>판</sup> ~ 16<sup>판</sup>
  </p>
  <p>
    Kevin Gibbons<br>
    ECMA-262, 프로젝트 편집자, 12<sup>판</sup> ~ 16<sup>판</sup>
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>범위</h1>
  <p>이 표준은 ECMAScript 2026 범용 프로그래밍 언어를 정의합니다.</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>적합성</h1>
  <p>ECMAScript의 적합한 구현은 이 명세서에 기술된 모든 타입, 값, 객체, 프로퍼티, 함수, 프로그램 문법과 의미를 제공하고 지원해야 합니다.</p>
  <p>ECMAScript의 적합한 구현은 최신 버전의 유니코드 표준과 ISO/IEC 10646에 따라 소스 텍스트 입력을 해석해야 합니다.</p>
  <p>여러 인간 언어와 국가에서 사용되는 언어적, 문화적 관습에 적응해야 하는 프로그램을 지원하는 응용 프로그램 프로그래밍 인터페이스(API)를 제공하는 ECMAScript의 적합한 구현은, 이 명세서와 호환되는 가장 최근 판의 ECMA-402에서 정의된 인터페이스를 구현해야 합니다.</p>
  <p>ECMAScript의 적합한 구현은 이 명세서에 기술된 것 외에도 추가적인 타입, 값, 객체, 프로퍼티, 함수 등을 제공할 수 있습니다. 특히, 이 명세서에 기술된 객체에 대해 명세서에 기술되지 않은 프로퍼티와 해당 프로퍼티의 값을 제공할 수 있습니다.</p>
  <p>ECMAScript의 적합한 구현은 이 명세서에 기술되지 않은 프로그램 및 정규 표현식 문법을 지원할 수 있습니다. 특히, 이 명세서의 <emu-xref href="#sec-keywords-and-reserved-words"></emu-xref> 하위절에 언급된 “future reserved words”를 사용하는 프로그램 문법을 지원할 수 있습니다.</p>
  <p>ECMAScript의 적합한 구현은 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 하위절에 금지 확장(Forbidden Extension)으로 명시된 어떤 확장도 구현해서는 안 됩니다.</p>
  <p>ECMAScript의 적합한 구현은 구현 정의(implementation-defined), 구현 근사(implementation-approximated), 또는 호스트 정의(host-defined)가 아닌 어떠한 기능도 재정의해서는 안 됩니다.</p>
  <p>ECMAScript의 적합한 구현은, 별도의 지시가 없는 한 <dfn>정규적 선택 사항(Normative Optional)</dfn> 하위절을 구현하거나 구현하지 않을 수 있습니다. 웹 브라우저는 일반적으로 모든 정규적 선택 사항 하위절을 구현해야 합니다. (부록 <emu-xref href="#sec-additional-ecmascript-features-for-web-browsers"></emu-xref> 참조.) 만약 어떤 정규적 선택 사항 동작이 구현된다면, 해당 정규적 선택 사항 절에 포함된 모든 동작이 구현되어야 합니다. 정규적 선택 사항 절은 본 명세서에서 아래와 같이 색상 상자에 "Normative Optional"이라는 문구로 표시됩니다.</p>

  <emu-clause id="sec-conformance-normative-optional" oldids="sec-conformance.normative-optional" example normative-optional>
    <h1>정규적 선택 사항 예시 절 제목</h1>
    <p>예시 절 내용.</p>
  </emu-clause>
  <p>ECMAScript의 적합한 구현은 정규적 선택 사항으로도 표시되지 않는 한 <dfn>레거시(Legacy)</dfn> 하위절을 구현해야 합니다. 레거시 하위절에 명시된 모든 언어 기능과 동작은 하나 이상의 바람직하지 않은 특성을 가지고 있습니다. 하지만 기존 애플리케이션에서 계속 사용되고 있기 때문에 이 명세서에서 제거할 수 없습니다. 이러한 기능은 ECMAScript 핵심 언어의 일부로 간주되지 않습니다. 프로그래머는 새로운 ECMAScript 코드를 작성할 때 이러한 기능과 동작을 사용하거나 존재를 가정해서는 안 됩니다.</p>

  <emu-clause id="sec-conformance-legacy" example legacy>
    <h1>레거시 예시 절 제목</h1>
    <p>예시 절 내용.</p>
  </emu-clause>

  <emu-clause id="sec-conformance-legacy-normative-optional" example legacy normative-optional>
    <h1>레거시 정규적 선택 사항 예시 절 제목</h1>
    <p>예시 절 내용.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>정규 참조</h1>
  <p>아래에 참조된 문서는 이 문서의 적용에 필수적입니다. 날짜가 명시된 참조는 해당 판만을 적용합니다. 날짜가 명시되지 않은 참조는 해당 문서의 최신 판(수정 포함)을 적용합니다.</p>
  <p>IEEE 754-2019, <i>IEEE 부동소수점 산술 표준</i>.</p>
  <p>
    유니코드 표준.<br>
    <a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>
  </p>
  <p>ISO/IEC 10646, <i>정보 기술 — 범용 다중 바이트 문자 집합(UCS)</i> 및 Amendment 1:2005, Amendment 2:2006, Amendment 3:2008, Amendment 4:2008, 그리고 추가 개정 및 정정 또는 후속 문서.</p>
  <p>
    ECMA-402, <i>ECMAScript 국제화 API 명세서</i>, 본 명세서와 대응되는 연간 판.<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-402/">https://www.ecma-international.org/publications-and-standards/standards/ecma-402/</a>
  </p>
  <p>
    ECMA-404, <i>JSON 데이터 교환 형식</i>.<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>
  </p>
</emu-clause>

<emu-clause id="sec-overview">
  <h1>개요</h1>
  <p>이 절은 ECMAScript 언어에 대한 비정규적 개요를 포함합니다.</p>
  <p>ECMAScript는 객체 지향 프로그래밍 언어로, 호스트 환경 내에서 계산을 수행하고 계산 객체를 조작합니다. 여기 정의된 ECMAScript는 계산적으로 자급자족하도록 설계된 것이 아니며, 외부 데이터 입력이나 계산 결과 출력에 대한 규정이 없습니다. 대신 ECMAScript 프로그램의 계산 환경은 이 명세서에 기술된 객체와 기타 기능뿐만 아니라 환경 특화 객체도 제공하는 것이 기대되며, 이들의 설명 및 동작은 이 명세서 범위를 벗어나지만 ECMAScript 프로그램에서 접근 가능한 프로퍼티와 호출 가능한 함수가 있을 수 있음을 나타냅니다.</p>
  <p>ECMAScript는 원래 스크립트 언어로 설계되었지만, 현재는 범용 프로그래밍 언어로 널리 사용됩니다. <em>스크립트 언어</em>란 기존 시스템의 기능을 조작, 맞춤화, 자동화하는 데 사용하는 프로그래밍 언어입니다. 이러한 시스템에서는 이미 사용자 인터페이스를 통해 유용한 기능이 제공되며, 스크립트 언어는 해당 기능을 프로그램 제어로 노출하는 역할을 합니다. 이처럼 기존 시스템은 객체와 기능을 제공하는 호스트 환경을 구성하며, 이는 스크립트 언어의 기능을 완성합니다. 스크립트 언어는 전문 프로그래머와 비전문 프로그래머 모두 사용할 수 있도록 설계되었습니다.</p>
  <p>ECMAScript는 원래 <em>웹 스크립트 언어</em>로 설계되어, 브라우저에서 웹 페이지에 생동감을 더하고 웹 기반 클라이언트-서버 아키텍처의 일부로 서버 계산을 수행하는 메커니즘을 제공했습니다. ECMAScript는 현재 다양한 호스트 환경에서 핵심 스크립트 기능을 제공합니다. 따라서 핵심 언어는 특정 호스트 환경과 분리되어 이 문서에서 정의됩니다.</p>
  <p>ECMAScript 사용은 단순한 스크립팅을 넘어 다양한 환경과 규모에서 전체 프로그래밍 작업 영역으로 확장되었습니다. 사용이 늘어남에 따라 ECMAScript가 제공하는 기능과 시설도 확대되었습니다. ECMAScript는 이제 완전한 기능의 범용 프로그래밍 언어입니다.</p>

  <emu-clause id="sec-web-scripting">
    <h1>웹 스크립팅</h1>
    <p>웹 브라우저는 클라이언트 측 계산을 위한 ECMAScript 호스트 환경을 제공합니다. 예를 들어, 창, 메뉴, 팝업, 대화 상자, 텍스트 영역, 앵커, 프레임, 히스토리, 쿠키, 입출력 등을 나타내는 객체를 포함합니다. 또한 호스트 환경은 포커스 변경, 페이지/이미지 로딩 및 언로드, 오류 및 중단, 선택, 폼 제출, 마우스 동작과 같은 이벤트에 스크립트 코드를 연결할 수 있는 수단을 제공합니다. 스크립트 코드는 HTML 내에 나타나며, 표시되는 페이지는 UI 요소와 고정 및 계산된 텍스트/이미지의 조합입니다. 스크립트 코드는 사용자 상호작용에 반응하며, 메인 프로그램이 필요하지 않습니다.</p>
    <p>웹 서버는 서버 측 계산을 위한 다른 호스트 환경을 제공하며, 요청, 클라이언트, 파일을 나타내는 객체와 데이터 잠금/공유 메커니즘을 포함합니다. 브라우저 측과 서버 측 스크립팅을 함께 사용하면, 클라이언트와 서버 간에 계산을 분산시키면서 웹 기반 애플리케이션에 맞춤화된 사용자 인터페이스를 제공할 수 있습니다.</p>
    <p>ECMAScript를 지원하는 각 웹 브라우저와 서버는 자체 호스트 환경을 제공하며, 이것이 ECMAScript 실행 환경을 완성합니다.</p>
  </emu-clause>

  <emu-clause id="sec-hosts-and-implementations">
    <h1>호스트와 구현체</h1>
    <p>ECMAScript를 호스트 환경에 통합하기 위해, 이 명세서는 일부 기능(예: 추상 연산)의 정의를 전적으로 또는 부분적으로 명세서 외부 소스에 위임합니다. 편집상, 이 명세서는 다음과 같은 위임 종류를 구분합니다.</p>
    <p><em id="implementation">구현체</em>란 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열된 시설이나 구현 정의 또는 구현 근사로 표시된 시설을 추가적으로 정의하는 외부 소스를 의미합니다. 비공식적으로 구현체는 특정 웹 브라우저와 같은 구체적인 산출물을 가리킵니다.</p>
    <p><dfn id="implementation-defined">구현 정의</dfn> 시설은 외부 소스에 정의를 위임하며 추가적인 자격을 두지 않습니다. 이 명세서는 특정 동작에 대해 권고하지 않으며, 적합한 구현은 명세서가 제시한 제한 내에서 자유롭게 동작을 선택할 수 있습니다.</p>
    <p><dfn id="implementation-approximated">구현 근사</dfn> 시설은 외부 소스에 정의를 위임하면서 이상적인 동작을 권장합니다. 적합한 구현은 명세서의 제한 내에서 자유롭게 동작을 선택할 수 있지만, 이상적인 동작을 최대한 근사하도록 권장됩니다. 예를 들어 <emu-xref href="#sec-math.exp"><code>Math.exp</code></emu-xref>와 같은 수학 연산이 구현 근사입니다.</p>
    <p><dfn id="host" variants="hosts">호스트</dfn>는 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열된 시설을 추가적으로 정의하지만, 기타 구현 정의 또는 구현 근사 시설은 추가적으로 정의하지 않는 외부 소스입니다. 비공식적으로 호스트는 이 명세서와 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>를 통해 동일하게 인터페이스하는 모든 웹 브라우저 집합 등, 모든 구현체 집합을 의미합니다. 호스트는 종종 WHATWG HTML(<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>)과 같은 외부 명세서입니다. 즉, 호스트 정의 시설은 종종 외부 명세서에서 추가적으로 정의됩니다.</p>
    <p><dfn id="host-hook" variants="host hooks">호스트 후크</dfn>는 전적으로 또는 부분적으로 외부 소스에 의해 정의되는 추상 연산입니다. 모든 호스트 후크는 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열되어야 합니다. 호스트 후크는 최소한 다음 요구 사항을 충족해야 합니다:</p>
    <ul>
      <li>정상 완료 또는 throw 완료 중 하나를 반환해야 합니다.</li>
    </ul>
    <p><dfn id="host-defined">호스트 정의</dfn> 시설은 추가적인 자격 없이 외부 소스에 정의를 위임하며, 부록 <emu-xref href="#sec-host-layering-points"></emu-xref>에 나열되어 있습니다. 호스트가 아닌 구현체도 호스트 정의 시설에 대한 정의를 제공할 수 있습니다.</p>
    <p><dfn id="host-environment" variants="host environments">호스트 환경</dfn>은 모든 호스트 정의 시설에 대한 선택적 정의입니다. 호스트 환경에는 일반적으로 입력을 얻거나 출력을 제공하는 객체나 함수가 포함되어 있으며, 전역 객체의 호스트 정의 프로퍼티로 제공됩니다.</p>
    <p>이 명세서는 항상 가장 구체적인 용어를 사용하는 편집 관례를 따릅니다. 예를 들어, 어떤 시설이 호스트 정의인 경우 구현 정의로 지칭하지 않습니다.</p>
    <p>호스트와 구현체 모두 이 명세서에서 정의된 언어 타입, 명세 타입, 추상 연산, 문법 생성, 내장 객체, 내장 심볼을 통해 이 명세서와 인터페이스할 수 있습니다.</p>
  </emu-clause>

  <emu-clause id="sec-ecmascript-overview">
    <h1>ECMAScript 개요</h1>
    <p>아래는 ECMAScript에 대한 비공식 개요이며, 언어의 모든 부분이 기술된 것은 아닙니다. 이 개요는 표준의 일부가 아닙니다.</p>
    <p>ECMAScript는 객체 기반입니다. 기본 언어와 호스트 기능은 객체로 제공되며, ECMAScript 프로그램은 상호 통신하는 객체 집합입니다. ECMAScript에서 <em>객체</em>란 0개 이상의 <em>프로퍼티</em>로 구성되어 있으며, 각 프로퍼티에는 프로퍼티의 사용 방법을 결정하는 <em>특성</em>이 있습니다. 예를 들어, 어떤 프로퍼티의 Writable 특성이 *false*로 설정된 경우, ECMAScript 코드가 해당 프로퍼티에 다른 값을 할당하려고 하면 실패합니다. 프로퍼티는 다른 객체, <em>원시값</em> 또는 <em>함수</em>를 담는 컨테이너입니다. 원시값은 내장 타입 <b>Undefined</b>, <b>Null</b>, <b>Boolean</b>, <b>Number</b>, <b>BigInt</b>, <b>String</b>, <b>Symbol;</b> 중 하나의 멤버입니다. 객체는 내장 타입 <b>Object</b>의 멤버이며, 함수는 호출 가능한 객체입니다. 객체의 프로퍼티에 연결된 함수는 <em>메서드</em>라고 부릅니다.</p>
    <p>ECMAScript는 ECMAScript 엔티티 정의를 완성하는 <em>내장 객체</em> 집합을 정의합니다. 내장 객체에는 전역 객체, 언어의 런타임 의미에 필수적인 `Object`, `Function`, `Boolean`, `Symbol` 및 다양한 `Error` 객체, 숫자값을 나타내고 조작하는 `Math`, `Number`, `Date` 객체, 텍스트 처리를 위한 `String` 및 `RegExp` 객체, 값을 인덱싱하는 컬렉션인 `Array`와 9가지 Typed Array, 키 기반 컬렉션인 `Map`과 `Set` 객체, 구조화 데이터를 지원하는 `JSON` 객체, `ArrayBuffer`, `SharedArrayBuffer`, `DataView`, 제어 추상화를 지원하는 제너레이터 함수와 `Promise` 객체, 그리고 리플렉션을 위한 `Proxy` 및 `Reflect` 객체가 포함됩니다.</p>
    <p>ECMAScript는 <em>내장 연산자</em> 집합도 정의합니다. ECMAScript 연산자에는 다양한 단항 연산, 곱셈 연산자, 덧셈 연산자, 비트 이동 연산자, 관계 연산자, 동등 연산자, 이진 비트 연산자, 이진 논리 연산자, 할당 연산자, 쉼표 연산자가 포함됩니다.</p>
    <p>대규모 ECMAScript 프로그램은 <em>모듈</em>을 통해 여러 문/선언 시퀀스로 분할될 수 있습니다. 각 모듈은 다른 모듈에서 제공해야 하는 선언과 다른 모듈에서 사용할 수 있는 자신의 선언을 명확히 식별합니다.</p>
    <p>ECMAScript 문법은 의도적으로 Java 문법과 유사하게 설계되었습니다. ECMAScript 문법은 스크립트 언어로 쉽게 사용할 수 있도록 완화되어 있습니다. 예를 들어, 변수에 타입 선언이 필요하지 않으며, 프로퍼티에 타입이 연결되지 않고, 함수 선언이 호출보다 먼저 나타나야 할 필요도 없습니다.</p>

    <emu-clause id="sec-objects">
      <h1>객체</h1>
      <p>ECMAScript는 클래스 정의 문법을 포함하지만, ECMAScript 객체는 C++, Smalltalk, Java와 같은 클래스 기반 언어처럼 근본적으로 클래스 기반이 아닙니다. 객체는 리터럴 표기 또는 객체를 생성하고 프로퍼티의 초기값을 할당하는 <em>생성자</em>를 통해 여러 방식으로 생성될 수 있습니다. 각 생성자는 *"prototype"*이라는 프로퍼티를 가진 함수로, <em>프로토타입 기반 상속</em>과 <em>공유 프로퍼티</em>를 구현하는 데 사용됩니다. <b>new</b> 표현식으로 생성자를 사용하면 객체가 생성됩니다. 예를 들어, `new Date(2009, 11)`은 새로운 Date 객체를 만듭니다. 생성자를 <b>new</b> 없이 호출하면 생성자마다 다른 결과가 발생합니다. 예를 들어, `Date()`는 객체가 아닌 현재 날짜와 시간의 문자열 표현을 반환합니다.</p>
      <p>생성자로 생성된 모든 객체는 암시적으로 자신이 속한 생성자의 *"prototype"* 프로퍼티 값에 대한 참조(객체의 <em>프로토타입</em>이라 부름)를 갖습니다. 또한 프로토타입은 자신만의 non-*null* 암시적 참조를 가질 수 있으며, 이를 <em>프로토타입 체인</em>이라 부릅니다. 객체에서 프로퍼티에 대한 참조가 발생하면, 해당 이름의 프로퍼티를 가진 프로토타입 체인에서 첫 번째 객체의 프로퍼티가 참조됩니다. 즉, 먼저 직접 지정된 객체에서 해당 프로퍼티가 있는지 확인하고, 있으면 그 프로퍼티가 참조 대상이 됩니다. 없으면 해당 객체의 프로토타입을 다음으로 검사하고, 계속 반복합니다.</p>
      <emu-figure id="figure-1" caption="객체/프로토타입 관계">
        <img alt="박스와 화살표가 많은 이미지." height="354" src="img/figure-1.svg" width="719">
      </emu-figure>
      <p>클래스 기반 객체 지향 언어에서는 일반적으로 상태는 인스턴스가, 메서드는 클래스가 담당하며, 상속은 구조와 동작에만 적용됩니다. ECMAScript에서는 상태와 메서드가 객체에 담기며, 구조, 동작, 상태 모두가 상속됩니다.</p>
      <p>프로토타입에 특정 프로퍼티가 있고, 객체에 직접 해당 프로퍼티가 포함되지 않은 모든 객체는 그 프로퍼티와 값을 공유합니다. 그림 1은 이를 보여줍니다:</p>
      <p><b>CF</b>는 생성자(동시에 객체)입니다. <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b> 등 5개의 객체가 `new` 표현식으로 생성되었습니다. 각 객체에는 *"q1"*, *"q2"* 프로퍼티가 있습니다. 점선은 암시적 프로토타입 관계를 나타냅니다. 예를 들어, <b>cf<sub>3</sub></b>의 프로토타입은 <b>CF<sub>p</sub></b>입니다. 생성자인 <b>CF</b>는 *"P1"*, *"P2"*라는 두 개의 프로퍼티를 갖지만, <b>CF<sub>p</sub></b>, <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b>에서는 보이지 않습니다. <b>CF<sub>p</sub></b>의 *"CFP1"* 프로퍼티는 <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b>에서 공유됩니다(<b>CF</b>에서는 공유되지 않음). <b>CF<sub>p</sub></b>의 암시적 프로토타입 체인에 있는 다른 프로퍼티도 *"q1"*, *"q2"*, *"CFP1"*이 아닌 경우 공유됩니다. <b>CF</b>와 <b>CF<sub>p</sub></b> 사이에는 암시적 프로토타입 링크가 없습니다.</p>
      <p>대부분의 클래스 기반 객체 언어와 달리, 객체에는 값을 할당함으로써 동적으로 프로퍼티를 추가할 수 있습니다. 즉, 생성자는 생성된 객체의 모든 프로퍼티를 반드시 명명하거나 값을 할당할 필요가 없습니다. 위 그림에서 <b>cf<sub>1</sub></b>, <b>cf<sub>2</sub></b>, <b>cf<sub>3</sub></b>, <b>cf<sub>4</sub></b>, <b>cf<sub>5</sub></b>에 대해 <b>CF<sub>p</sub></b>에 새 값을 할당함으로써 새로운 공유 프로퍼티를 추가할 수 있습니다.</p>
      <p>ECMAScript 객체는 본질적으로 클래스 기반이 아니지만, 생성자 함수, 프로토타입 객체, 메서드의 공통 패턴에 기반하여 클래스 유사 추상을 정의하는 것이 편리할 때가 많습니다. ECMAScript 내장 객체도 이런 클래스 유사 패턴을 따릅니다. ECMAScript 2015부터는 내장 객체가 사용하는 동일한 클래스 유사 추상 패턴에 맞는 객체를 간결하게 정의할 수 있는 문법적 클래스 정의가 도입되었습니다.</p>
    </emu-clause>

    <emu-clause id="sec-strict-variant-of-ecmascript">
      <h1>ECMAScript의 엄격 변종</h1>
      <p>ECMAScript 언어는 일부 사용자가 언어에서 제공되는 특정 기능 사용을 제한하고자 할 수 있음을 인식합니다. 이는 보안, 오류 발생 가능성이 높은 기능 회피, 오류 검사 강화 또는 기타 사용자의 목적을 위해서일 수 있습니다. 이런 가능성을 지원하기 위해 ECMAScript는 언어의 엄격 변종을 정의합니다. 엄격 변종은 일반 ECMAScript 언어의 일부 구문 및 의미론적 기능을 제외하고, 일부 기능의 상세 의미론을 수정합니다. 엄격 변종은 비엄격 언어 형식에서는 오류로 지정되지 않은 상황에서도 오류 예외를 반드시 던져야 하는 추가 오류 조건을 명시합니다.</p>
      <p>ECMAScript의 엄격 변종은 언어의 <em>엄격 모드</em>로 일반적으로 불립니다. 엄격 모드의 선택과 엄격 모드 구문 및 의미론 사용은 개별 ECMAScript 소스 텍스트 단위 수준에서 명시적으로 결정됩니다(<emu-xref href="#sec-strict-mode-code"></emu-xref> 참조). 엄격 모드는 구문적 소스 텍스트 단위 수준에서 선택되므로, 제한은 해당 소스 텍스트 단위 내에서만 국지적으로 적용됩니다. 엄격 모드는 여러 소스 텍스트 단위에 걸쳐 일관되게 동작해야 하는 ECMAScript 의미론의 어떤 측면도 제한하거나 수정하지 않습니다. 전체 ECMAScript 프로그램은 엄격 모드와 비엄격 모드 소스 텍스트 단위로 구성될 수 있으며, 이 경우 엄격 모드는 실제로 엄격 모드 소스 텍스트 단위 내에서 정의된 코드를 실행할 때만 적용됩니다.</p>
      <p>이 명세서에 적합하려면 ECMAScript 구현은 이 명세서에서 정의한 완전한 비제한 ECMAScript 언어와 엄격 변종을 모두 구현해야 합니다. 또한, 구현체는 비제한 모드와 엄격 모드 소스 텍스트 단위를 단일 복합 프로그램으로 조합하는 기능을 지원해야 합니다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-terms-and-definitions">
    <h1>용어와 정의</h1>
    <p>이 문서의 목적상, 아래 용어와 정의가 적용됩니다.</p>

    <emu-clause id="sec-terms-and-definitions-implementation-approximated">
      <h1>구현 근사</h1>
      <p>구현 근사 시설은 전체 또는 일부가 외부 소스에 의해 정의되지만, 이 명세서에서 권장되는 이상적 동작을 갖습니다.</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-implementation-defined">
      <h1>구현 정의</h1>
      <p>구현 정의 시설은 전체 또는 일부가 이 명세서 외부 소스에 의해 정의됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-host-defined">
      <h1>호스트 정의</h1>
      <p>구현 정의와 동일함</p>
      <emu-note>
        <p>편집상, <emu-xref href="#sec-hosts-and-implementations"></emu-xref> 절 참조.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-type">
      <h1>타입</h1>
      <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 절에서 정의된 데이터 값 집합</p>
    </emu-clause>

    <emu-clause id="sec-primitive-value">
      <h1>원시값</h1>
      <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 절에서 정의된 Undefined, Null, Boolean, Number, BigInt, Symbol, String 타입 중 하나의 멤버</p>
      <emu-note>
        <p>원시값은 언어 구현의 가장 낮은 수준에서 직접 표현되는 데이터입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-object">
      <h1>객체</h1>
      <p>Object 타입의 멤버</p>
      <emu-note>
        <p>객체는 프로퍼티 집합이며, 하나의 프로토타입 객체를 가집니다. 프로토타입은 *null*일 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-constructor">
      <h1>생성자</h1>
      <p>객체를 생성하고 초기화하는 함수 객체</p>
      <emu-note>
        <p>생성자의 *"prototype"* 프로퍼티 값은 상속 및 공유 프로퍼티 구현에 사용되는 프로토타입 객체입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-prototype">
      <h1>프로토타입</h1>
      <p>다른 객체를 위한 공유 프로퍼티를 제공하는 객체</p>
      <emu-note>
        <p>생성자가 객체를 생성할 때, 해당 객체는 프로퍼티 참조 해결을 위해 생성자의 *"prototype"* 프로퍼티를 암시적으로 참조합니다. 생성자의 *"prototype"* 프로퍼티는 <code><var>constructor</var>.prototype</code> 표현식으로 참조할 수 있으며, 프로토타입에 추가된 프로퍼티는 프로토타입을 공유하는 모든 객체에 상속을 통해 공유됩니다. 또는 `Object.create` 내장 함수를 사용하여 명시적으로 지정된 프로토타입으로 새 객체를 만들 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinary-object">
      <h1>일반 객체</h1>
      <p>모든 객체가 반드시 지원해야 하는 기본 내부 메서드에 대한 기본 동작을 갖는 객체</p>
    </emu-clause>

    <emu-clause id="sec-exotic-object">
      <h1>특수 객체</h1>
      <p>하나 이상의 필수 내부 메서드에 대해 기본 동작을 갖지 않는 객체</p>
      <emu-note>
        <p>일반 객체가 아닌 모든 객체는 특수 객체입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-standard-object">
      <h1>표준 객체</h1>
      <p>이 명세서에서 의미가 정의된 객체</p>
    </emu-clause>

    <emu-clause id="sec-built-in-object">
      <h1>내장 객체</h1>
      <p>ECMAScript 구현체에 의해 지정되고 제공되는 객체</p>
      <emu-note>
        <p>표준 내장 객체는 이 명세서에서 정의됩니다. ECMAScript 구현체는 추가적인 내장 객체 종류를 지정하고 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-undefined-value">
      <h1>undefined 값</h1>
      <p>변수에 값이 할당되지 않았을 때 사용되는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-undefined-type">
      <h1>Undefined 타입</h1>
      <p>유일한 값이 *undefined*인 타입</p>
    </emu-clause>

    <emu-clause id="sec-null-value">
      <h1>null 값</h1>
      <p>어떠한 객체 값도 의도적으로 없음을 나타내는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-null-type">
      <h1>Null 타입</h1>
      <p>유일한 값이 *null*인 타입</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-value">
      <h1>Boolean 값</h1>
      <p>Boolean 타입의 멤버</p>
      <emu-note>
        <p>Boolean 값은 *true*, *false* 두 가지 뿐입니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-type">
      <h1>Boolean 타입</h1>
      <p>원시값 *true*와 *false*로 구성된 타입</p>
    </emu-clause>

    <emu-clause id="sec-boolean-object">
      <h1>Boolean 객체</h1>
      <p>표준 내장 Boolean 생성자의 인스턴스인 Object 타입의 멤버</p>
      <emu-note>
        <p>Boolean 객체는 Boolean 생성자를 `new` 표현식으로 사용할 때 생성되며, Boolean 값을 인자로 제공합니다. 결과 객체는 내부 슬롯에 Boolean 값이 저장됩니다. Boolean 객체는 Boolean 값으로 강제 변환될 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-value">
      <h1>String 값</h1>
      <p>0개 이상의 16비트 부호 없는 정수값으로 이루어진 유한 순서의 원시값</p>
      <emu-note>
        <p>String 값은 String 타입의 멤버입니다. 시퀀스 내 각 정수값은 일반적으로 UTF-16 텍스트의 16비트 단위를 나타냅니다. 단, ECMAScript는 값에 대해 16비트 부호 없는 정수라는 점 외에 제한이나 요구 사항을 두지 않습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-type">
      <h1>String 타입</h1>
      <p>모든 가능한 String 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-string-object">
      <h1>String 객체</h1>
      <p>표준 내장 String 생성자의 인스턴스인 Object 타입의 멤버</p>
      <emu-note>
        <p>String 객체는 String 생성자를 `new` 표현식으로 사용할 때 생성되며, String 값을 인자로 제공합니다. 결과 객체는 내부 슬롯에 String 값이 저장됩니다. String 객체는 String 생성자를 함수처럼 호출하면 String 값으로 강제 변환될 수 있습니다(<emu-xref href="#sec-string-constructor-string-value"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-value">
      <h1>Number 값</h1>
      <p>배정밀도 64비트 이진 형식 IEEE 754-2019 값에 해당하는 원시값</p>
      <emu-note>
        <p>Number 값은 Number 타입의 멤버이며, 숫자를 직접 나타냅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-type">
      <h1>Number 타입</h1>
      <p>*NaN* (“not a number”), *+∞*<sub>𝔽</sub> (양의 무한대), *-∞*<sub>𝔽</sub> (음의 무한대)를 포함한 모든 가능한 Number 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-number-object">
      <h1>Number 객체</h1>
      <p>표준 내장 Number 생성자의 인스턴스인 Object 타입의 멤버</p>
      <emu-note>
        <p>Number 객체는 Number 생성자를 `new` 표현식으로 사용할 때 생성되며, Number 값을 인자로 제공합니다. 결과 객체는 내부 슬롯에 Number 값이 저장됩니다. Number 객체는 Number 생성자를 함수처럼 호출하면 Number 값으로 강제 변환될 수 있습니다(<emu-xref href="#sec-number-constructor-number-value"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-infinity">
      <h1>Infinity</h1>
      <p>양의 무한대 Number 값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-nan">
      <h1>NaN</h1>
      <p>IEEE 754-2019 NaN (“not a number”) 값인 Number 값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-value">
      <h1>BigInt 값</h1>
      <p>임의 정밀도의 정수값에 해당하는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-type">
      <h1>BigInt 타입</h1>
      <p>모든 가능한 BigInt 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-bigint-object">
      <h1>BigInt 객체</h1>
      <p>표준 내장 BigInt 생성자의 인스턴스인 Object 타입의 멤버</p>
    </emu-clause>

    <emu-clause id="sec-symbol-value">
      <h1>Symbol 값</h1>
      <p>고유한, 문자열이 아닌 Object 프로퍼티 키를 나타내는 원시값</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-symbol-type">
      <h1>Symbol 타입</h1>
      <p>모든 가능한 Symbol 값의 집합</p>
    </emu-clause>

    <emu-clause id="sec-symbol-object">
      <h1>Symbol 객체</h1>
      <p>표준 내장 Symbol 생성자의 인스턴스인 Object 타입의 멤버</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-function">
      <h1>함수</h1>
      <p>서브루틴으로 호출될 수 있는 Object 타입의 멤버</p>
      <emu-note>
        <p>함수는 프로퍼티 외에도 코드와 상태를 포함하며, 호출 시 동작을 결정합니다. 함수의 코드는 ECMAScript로 작성되었을 수도, 아닐 수도 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function">
      <h1>내장 함수</h1>
      <p>함수인 내장 객체</p>
      <emu-note>
        <p>내장 함수의 예로 `parseInt`, `Math.exp` 등이 있습니다. 호스트나 구현체는 이 명세서에 기술되지 않은 추가 내장 함수를 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-constructor">
      <h1>내장 생성자</h1>
      <p>생성자인 내장 함수</p>
      <emu-note>
        <p>내장 생성자의 예로 `Object`, `Function` 등이 있습니다. 호스트나 구현체는 이 명세서에 기술되지 않은 추가 내장 생성자를 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-property">
      <h1>프로퍼티</h1>
      <p>키(문자열 값 또는 Symbol 값)와 값을 연결하는 객체의 일부</p>
      <emu-note>
        <p>프로퍼티 형태에 따라 값은 데이터 값(원시값, 객체, 함수 객체)으로 직접 표현되거나, 접근자 함수 쌍으로 간접적으로 표현될 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-method">
      <h1>메서드</h1>
      <p>프로퍼티 값인 함수</p>
      <emu-note>
        <p>함수가 객체의 메서드로 호출될 때, 해당 객체가 *this* 값으로 함수에 전달됩니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-method">
      <h1>내장 메서드</h1>
      <p>내장 함수인 메서드</p>
      <emu-note>
        <p>표준 내장 메서드는 이 명세서에서 정의됩니다. 호스트나 구현체는 이 명세서에 기술되지 않은 추가 내장 메서드를 제공할 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-attribute">
      <h1>특성</h1>
      <p>프로퍼티의 특성을 정의하는 내부 값</p>
    </emu-clause>

    <emu-clause id="sec-own-property">
      <h1>자체 프로퍼티</h1>
      <p>객체에 직접 포함된 프로퍼티</p>
    </emu-clause>

    <emu-clause id="sec-inherited-property">
      <h1>상속 프로퍼티</h1>
      <p>객체의 자체 프로퍼티가 아니지만, 객체의 프로토타입(자체 또는 상속 프로퍼티)의 프로퍼티인 프로퍼티</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-organization-of-this-specification">
    <h1>이 명세서의 구성</h1>
    <p>이후 명세서는 아래와 같이 구성됩니다:</p>
    <p><emu-xref href="#sec-notational-conventions"></emu-xref> 절은 명세서 전반에서 사용되는 표기 관례를 정의합니다.</p>
    <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> ~ <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 절은 ECMAScript 프로그램이 동작하는 실행 환경을 정의합니다.</p>
    <p><emu-xref href="#sec-ecmascript-language-source-code"></emu-xref> ~ <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 절은 ECMAScript 프로그래밍 언어의 실제 문법 인코딩과 모든 언어 기능의 실행 의미를 정의합니다.</p>
    <p><emu-xref href="#sec-ecmascript-standard-built-in-objects"></emu-xref> ~ <emu-xref href="#sec-reflection"></emu-xref> 절은 ECMAScript 표준 라이브러리를 정의하며, 실행 중 ECMAScript 프로그램에서 사용할 수 있는 모든 표준 객체의 정의를 포함합니다.</p>
    <p><emu-xref href="#sec-memory-model"></emu-xref> 절은 SharedArrayBuffer 기반 메모리 접근 및 Atomics 객체의 메서드에 대한 메모리 일관성 모델을 설명합니다.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>표기 관례</h1>

  <emu-clause id="sec-syntactic-and-lexical-grammars">
    <h1>구문 및 렉시컬 문법</h1>

    <emu-clause id="sec-context-free-grammars">
      <h1>문맥 자유 문법</h1>
      <p><em>문맥 자유 문법</em>은 여러 개의 <em>생산식</em>으로 구성됩니다. 각 생산식에는 <em>비단말기</em>라 불리는 추상 기호가 <em>좌변</em>에, 0개 이상의 비단말기와 <em>단말기</em> 기호가 <em>우변</em>에 나열됩니다. 각 문법에서 단말기 기호는 지정된 알파벳에서 선택됩니다.</p>
      <p><dfn variants="chain productions">체인 생산식</dfn>은 우변에 단 하나의 비단말기 기호와 0개 이상의 단말기 기호가 있는 생산식입니다.</p>
      <p>단일 특수 비단말기로 구성된 문장에서 시작하여, 주어진 문맥 자유 문법은 <em>언어</em>를 정의합니다. 즉, 비단말기를 해당 비단말기가 좌변인 생산식의 우변으로 반복적으로 치환함으로써 생성될 수 있는 단말기 기호의 (아마도 무한한) 가능한 시퀀스 집합입니다.</p>
    </emu-clause>

    <emu-clause id="sec-lexical-and-regexp-grammars">
      <h1>렉시컬 및 정규식 문법</h1>
      <p>ECMAScript의 <em>렉시컬 문법</em>은 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref> 절에 있습니다. 이 문법의 단말기 기호는 <emu-xref href="#sec-source-text"></emu-xref>에서 정의된 |SourceCharacter| 규칙을 따르는 유니코드 코드 포인트입니다. 목표 기호 |InputElementDiv|, |InputElementTemplateTail|, |InputElementRegExp|, |InputElementRegExpOrTemplateTail|, 또는 |InputElementHashbangOrRegExp|에서 시작하여, 이러한 코드 포인트 시퀀스를 입력 요소 시퀀스로 변환하는 방법을 설명하는 생산식 집합을 정의합니다.</p>
      <p>공백과 주석을 제외한 입력 요소는 ECMAScript의 구문 문법의 단말기 기호를 구성하며, ECMAScript <em>토큰</em>이라고 합니다. 이 토큰은 ECMAScript 언어의 예약어, 식별자, 리터럴, 구두점입니다. 또한 줄 종결자는 토큰으로 간주되지 않지만 입력 요소 스트림의 일부가 되어 자동 세미콜론 삽입 과정(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)을 안내합니다. 단순 공백과 한 줄 주석은 버려져서 구문 문법의 입력 요소 스트림에 나타나지 않습니다. |MultiLineComment|(`/*`…`*/` 형태의 주석, 줄을 넘나들든 아니든 관계 없음)도 줄 종결자가 포함되지 않았다면 단순히 버려집니다. 하지만 줄 종결자가 하나 이상 포함된 경우, 단일 줄 종결자로 대체되어 구문 문법의 입력 요소 스트림에 포함됩니다.</p>
      <p>ECMAScript의 <em>정규식 문법</em>은 <emu-xref href="#sec-patterns"></emu-xref>에 있습니다. 이 문법 역시 단말기 기호로 |SourceCharacter|에서 정의된 코드 포인트를 사용합니다. 목표 기호 |Pattern|에서 시작하여, 코드 포인트 시퀀스를 정규 표현식 패턴으로 변환하는 생산식 집합을 정의합니다.</p>
      <p>렉시컬 및 정규식 문법의 생산식은 구분 기호로 두 개의 콜론 “<b>::</b>”을 사용해 구분됩니다. 렉시컬 문법과 정규식 문법은 일부 생산식을 공유합니다.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-string-grammar">
      <h1>숫자 문자열 문법</h1>
      <p><em>숫자 문자열 문법</em>은 <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>에 나옵니다. 단말기 기호로 |SourceCharacter|를 가지며, 목표 기호 |StringNumericLiteral|에서 시작하여 문자열을 숫자 값으로 변환하는 데 사용됩니다(이는 <emu-xref href="#sec-literals-numeric-literals">숫자 리터럴의 렉시컬 문법</emu-xref>과 유사하지만 다릅니다).</p>
      <p>숫자 문자열 문법의 생산식은 세 개의 콜론 “<b>:::</b>”을 구분 기호로 가지며, 소스 텍스트 파싱에는 사용되지 않습니다.</p>
    </emu-clause>

    <emu-clause id="sec-syntactic-grammar">
      <h1>구문 문법</h1>
      <p>ECMAScript의 <em>구문 문법</em>은 <emu-xref href="#sec-ecmascript-language-expressions"></emu-xref> 절부터 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref> 절까지 제시되어 있습니다. 이 문법의 단말기 기호는 렉시컬 문법에서 정의된 ECMAScript 토큰입니다(<emu-xref href="#sec-lexical-and-regexp-grammars"></emu-xref>). 목표 기호 |Script|와 |Module| 두 가지에서 시작하여, 토큰 시퀀스가 ECMAScript 프로그램의 구문적으로 올바른 독립된 구성 요소를 형성하는 방법을 설명하는 생산식 집합을 정의합니다.</p>
      <p>코드 포인트 스트림을 ECMAScript |Script| 또는 |Module|로 파싱하려면, 먼저 렉시컬 문법을 반복적으로 적용하여 입력 요소 스트림으로 변환합니다. 그 후 입력 요소 스트림을 구문 문법을 단일 적용으로 파싱합니다. 입력 스트림의 토큰이 목표 비단말기(|Script| 또는 |Module|)의 단일 인스턴스로 파싱될 수 없거나 토큰이 남는다면 구문 오류입니다.</p>
      <p>파싱이 성공하면 <em>파스 트리</em>가 구성되며, 트리의 각 노드는 <dfn variants="Parse Nodes">파스 노드</dfn>입니다. 각 파스 노드는 문법 기호의 <em>인스턴스</em>이며, 해당 기호에서 유도할 수 있는 소스 텍스트의 범위를 나타냅니다. 파스 트리의 루트 노드는 전체 소스 텍스트를 나타내며, 파싱의 목표 기호의 인스턴스입니다. 파스 노드가 비단말기의 인스턴스라면, 해당 비단말기를 좌변으로 하는 생산식 인스턴스이기도 합니다. 그리고 우변의 각 기호마다 <em>자식</em>을 하나씩 가집니다. 각 자식은 해당 기호의 인스턴스인 파스 노드입니다.</p>
      <p>새로운 파스 노드는 파서가 호출될 때마다 인스턴스화되며, 동일한 소스 텍스트를 파싱하더라도 파싱 간에 재사용되지 않습니다. 파스 노드는 동일한 소스 텍스트 범위를 나타내고, 동일한 문법 기호의 인스턴스이며, 동일한 파서 호출에서 생성된 경우에만 <dfn>동일한 파스 노드</dfn>로 간주됩니다.</p>
      <emu-note>
        <p>같은 문자열을 여러 번 파싱하면 서로 다른 파스 노드가 생성됩니다. 예를 들어:</p>
        <pre><code class="javascript">
          let str = "1 + 1;";
          eval(str);
          eval(str);
        </code></pre>
        <p>`eval`을 호출할 때마다 str의 값을 ECMAScript 소스 텍스트로 변환하고, 각각 독립적으로 자신만의 파스 노드 트리를 생성합니다. 이 트리들은 각각의 파싱이 동일한 문자열 값에서 유도된 소스 텍스트를 대상으로 하더라도 서로 다릅니다.</p>
      </emu-note>
      <emu-note>파스 노드는 명세상의 산출물이며, 실제 구현에서는 유사한 데이터 구조를 사용할 필요가 없습니다.</emu-note>
      <p>구문 문법의 생산식은 구분 기호로 한 개의 콜론 “<b>:</b>”만을 사용합니다.</p>
      <p><emu-xref href="#sec-ecmascript-language-expressions"></emu-xref>부터 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref>까지 제시된 구문 문법은 ECMAScript |Script| 또는 |Module|로서 올바르게 받아들여지는 토큰 시퀀스를 완전히 설명한 것은 아닙니다. 추가적인 토큰 시퀀스도 허용되며, 예를 들어 일부 위치(줄 종결자 앞 등)에 세미콜론만 추가하면 문법에서 기술될 토큰 시퀀스가 허용됩니다. 또한, 일부 위치에 줄 종결자가 나타나면 문법에서 기술된 토큰 시퀀스라 해도 허용되지 않을 수 있습니다.</p>
      <p>일부 경우, 모호성을 피하기 위해 구문 문법은 유효한 ECMAScript |Script| 또는 |Module|을 형성하지 않는 토큰 시퀀스를 허용하는 일반화된 생산식을 사용합니다. 예를 들어, 객체 리터럴 및 객체 구조 분해 패턴에 이 기법이 사용됩니다. 이런 경우, 더 제한적인 <em>보조 문법</em>이 제공되어 허용되는 토큰 시퀀스를 추가로 제한합니다. 일반적으로, 초기 오류 규칙은 특정 문맥에서 "_P_ <dfn id="must-cover">는 반드시 _N_을 커버해야 한다</dfn>"고 명시합니다. 여기서 _P_는 파스 노드(일반화된 생산식의 인스턴스), _N_은 보조 문법의 비단말기입니다. 이는 다음을 의미합니다:</p>
      <ol>
        <li>_P_가 원래 일치시킨 토큰 시퀀스를 _N_을 목표 기호로 하여 다시 파싱합니다. _N_에 문법적 매개변수가 있다면, _P_가 처음 파싱될 때 사용된 값으로 설정합니다.</li>
        <li>토큰 시퀀스를 토큰 남김 없이 _N_의 단일 인스턴스로 파싱할 수 있다면:
          <ol>
            <li>해당 _N_ 인스턴스(특정 _P_에 대해 유일한 파스 노드)를 "_P_가 커버하는 _N_"이라고 합니다.</li>
            <li>_N_ 및 그 파생 생산식에 대한 모든 Early Error 규칙은 _P_가 커버하는 _N_에도 적용됩니다.</li>
          </ol>
        </li>
        <li>그렇지 않으면(파싱이 실패하면), 이는 초기 구문 오류입니다.</li>
      </ol>
    </emu-clause>

    <emu-clause id="sec-grammar-notation" namespace="grammar-notation">
      <h1>문법 표기법</h1>

      <emu-clause id="sec-terminal-symbols">
        <h1>단말기 기호</h1>
        <p>ECMAScript 문법에서 일부 단말기 기호는 `고정폭` 글꼴로 표시됩니다. 이는 소스 텍스트에 정확히 표시된 대로 나타나야 함을 의미합니다. 이렇게 지정된 모든 단말기 기호 코드 포인트는 다른 유사한 유니코드 범위가 아니라 기본 라틴 블록의 적절한 유니코드 코드 포인트로 이해해야 합니다. 단말기 기호의 코드 포인트는 `\\` |UnicodeEscapeSequence|로 표현할 수 없습니다.</p>
        <p>단말기 기호가 개별 유니코드 코드 포인트인 문법(즉, 렉시컬, 정규식, 숫자 문자열 문법)에서는 생산식에 여러 개의 고정폭 코드 포인트가 연속해서 나타날 때, 이는 동일한 시퀀스를 독립된 단말기 기호로 쓴 것과 같습니다.</p>
        <p>예를 들어, 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0x` HexDigits
        </emu-grammar>
        <p>이는 사실 다음과 같은 약어입니다:</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0` `x` HexDigits
        </emu-grammar>
        <p>반면, 구문 문법에서는 고정폭 코드 포인트가 연속해서 나타날 경우 단일 단말기 기호로 취급됩니다.</p>
        <p>단말기 기호는 두 가지 다른 형태도 있습니다:</p>
        <ul>
          <li>렉시컬 및 정규식 문법에서, 일반적인 인쇄 표현이 없는 유니코드 코드 포인트는 "&lt;ABBREV>" 형태로 표시됩니다. 여기서 "ABBREV"는 코드 포인트 또는 코드 포인트 집합의 기억법입니다. 이러한 형태는 <emu-xref href="#sec-unicode-format-control-characters" title></emu-xref>, <emu-xref href="#sec-white-space" title></emu-xref>, <emu-xref href="#sec-line-terminators" title></emu-xref>에서 정의됩니다.</li>
          <li>구문 문법에서는 특정 단말기 기호(예: |IdentifierName|, |RegularExpressionLiteral|)가 이탤릭체로 표시되며, 이는 렉시컬 문법의 동일한 이름의 비단말기를 참조함을 의미합니다.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-nonterminal-symbols-and-productions">
        <h1>비단말기 기호와 생산식</h1>
        <p>비단말기 기호는 <i>이탤릭체</i>로 표시됩니다. 비단말기 정의(생산식이라고도 함)는 정의되는 비단말기 이름 다음에 하나 이상의 콜론이 옵니다. (콜론의 개수는 생산식이 속한 문법을 나타냅니다.) 이어서 비단말기의 하나 이상의 대체 우변이 각각의 줄에 나옵니다. 예를 들어, 다음과 같은 구문 정의가 있습니다:</p>
        <emu-grammar type="definition" example>
          WhileStatement :
            `while` `(` Expression `)` Statement
        </emu-grammar>
        <p>이는 비단말기 |WhileStatement|가 토큰 `while` 다음에 왼쪽 괄호 토큰, |Expression|, 오른쪽 괄호 토큰, |Statement|가 차례로 오는 것을 의미합니다. |Expression|과 |Statement|도 각각 비단말기입니다. 또 다른 예로, 다음과 같은 구문 정의가 있습니다:</p>
        <emu-grammar type="definition" example>
          ArgumentList :
            AssignmentExpression
            ArgumentList `,` AssignmentExpression
        </emu-grammar>
        <p>이는 |ArgumentList|가 단일 |AssignmentExpression| 또는 |ArgumentList|, 쉼표, |AssignmentExpression|로 나타날 수 있음을 의미합니다. 이 |ArgumentList| 정의는 자기 참조적(재귀적)이며, 자신에 대한 정의로 이루어져 있습니다. 결과적으로 |ArgumentList|는 콤마로 구분된 모든 양의 개수의 인자, 각 인자 표현식은 |AssignmentExpression|이 될 수 있습니다. 이러한 비단말기의 재귀적 정의는 흔합니다.</p>
      </emu-clause>

      <emu-clause id="sec-optional-symbols">
        <h1>선택적 기호</h1>
        <p>단말기 또는 비단말기 뒤에 첨자 “<sub>opt</sub>”가 붙으면 선택적 기호임을 나타냅니다. 선택적 기호가 포함된 대안은 실제로 두 가지 우변을 명시합니다. 하나는 선택적 요소를 생략한 것이고, 하나는 포함한 것입니다. 즉,</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer?
        </emu-grammar>
        <p>는 다음의 편리한 약어입니다:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <p>는 다음의 편리한 약어입니다:</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression? `)` Statement
        </emu-grammar>
        <p>이는 다시 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` `)` Statement
            `for` `(` LexicalDeclaration `;` Expression `)` Statement
            `for` `(` LexicalDeclaration Expression `;` `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
        </emu-grammar>
        <p>따라서 이 예시에서 비단말기 |ForStatement|는 실제로 네 가지 대체 우변을 갖습니다.</p>
      </emu-clause>

      <emu-clause id="sec-grammatical-parameters">
        <h1>문법적 매개변수</h1>
        <p>생산식은 첨자 형태의 “<sub>[parameters]</sub>” 주석으로 매개변수화될 수 있으며, 이는 생산식이 정의하는 비단말기 기호 뒤에 접미사로 나타납니다. “<sub>parameters</sub>”는 단일 이름 또는 컴마로 구분된 이름 목록일 수 있습니다. 매개변수화된 생산식은 매개변수 이름 조합마다 해당 비단말기 기호에 언더스코어를 붙여서 정의하는 생산식 집합의 약어입니다. 즉,</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 편리한 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          StatementList[Return, In] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement

          StatementList_In :
            ReturnStatement
            ExpressionStatement

          StatementList_Return_In :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>여러 매개변수가 있으면 조합 수만큼 생산식이 생성되며, 모든 경우가 완전한 문법에서 참조되는 것은 아닙니다.</p>
        <p>생산식의 우변에 있는 비단말기 참조 역시 매개변수화될 수 있습니다. 예를 들어:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[+In]
        </emu-grammar>
        <p>는 다음과 동일합니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement_In
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[~In]
        </emu-grammar>
        <p>는 다음과 동일합니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>비단말기 참조에는 매개변수 목록과 “<sub>opt</sub>” 첨자가 모두 있을 수 있습니다. 예를 들어:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer[+In]?
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>우변 비단말기 참조에 매개변수 이름 앞에 “<sub>?</sub>”가 있으면, 그 매개변수 값은 현재 생산식 좌변의 비단말기 참조에 해당 매개변수 이름이 나타나는지에 따라 결정됩니다. 예를 들어:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration[In] :
            BindingIdentifier Initializer[?In]
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer

          VariableDeclaration_In :
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>우변 대안 앞에 “[+parameter]”가 있으면, 해당 대안은 생산식의 비단말기 기호 참조에 지정된 매개변수가 있을 때만 사용 가능합니다. “[~parameter]”가 있으면, 해당 대안은 지정된 매개변수가 <em>없을 때만</em> 사용 가능합니다. 즉,</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [+Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>그리고:</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [~Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>는 다음의 약어입니다:</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ExpressionStatement
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-one-of">
        <h1>one of</h1>
        <p>문법 정의에서 콜론 다음에 “<b>one of</b>”가 나오면, 다음 줄 또는 여러 줄에 있는 각 단말기 기호가 대체 정의임을 의미합니다. 예를 들어 ECMAScript의 렉시컬 문법에는 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          NonZeroDigit :: one of
            `1` `2` `3` `4` `5` `6` `7` `8` `9`
        </emu-grammar>
        <p>이는 다음과 같은 약어일 뿐입니다:</p>
        <emu-grammar type="definition" example>
          NonZeroDigit ::
            `1`
            `2`
            `3`
            `4`
            `5`
            `6`
            `7`
            `8`
            `9`
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-empty">
        <h1>[empty]</h1>
        <p>생산식의 우변에 “[empty]”가 나타나면, 해당 생산식의 우변이 단말기나 비단말기 기호를 전혀 포함하지 않음을 의미합니다.</p>
      </emu-clause>

      <emu-clause id="sec-lookahead-restrictions">
        <h1>앞보기 제한</h1>
        <p>생산식의 우변에 “[lookahead = _seq_]”가 나타나면, 해당 생산식은 토큰 시퀀스 _seq_가 바로 뒤따르는 입력 토큰 시퀀스의 접두사일 때만 사용될 수 있음을 의미합니다. 마찬가지로 “[lookahead ∈ _set_]”에서 _set_은 유한하고 비어 있지 않은 토큰 시퀀스 집합일 때, 집합의 어떤 요소가 바로 뒤따르는 토큰 시퀀스의 접두사일 때만 사용될 수 있음을 의미합니다. 편의상 집합을 비단말기로 쓸 수도 있는데, 이 경우 해당 비단말기가 확장할 수 있는 모든 토큰 시퀀스 집합을 나타냅니다. 비단말기가 무한히 많은 서로 다른 토큰 시퀀스로 확장될 수 있다면 이는 편집 오류로 간주합니다.</p>
        <p>이 조건들은 부정될 수도 있습니다. “[lookahead ≠ _seq_]”는 해당 생산식이 _seq_가 바로 뒤따르는 입력 토큰 시퀀스의 접두사가 <em>아니어야만</em> 사용할 수 있음을 의미하고, “[lookahead ∉ _set_]”는 집합의 어떤 요소도 바로 뒤따르는 토큰 시퀀스의 접두사가 <em>되어서는 안 될 때만</em> 사용될 수 있음을 의미합니다.</p>
        <p>예시로, 다음과 같은 정의를 보면:</p>
        <emu-grammar type="definition" example>
          DecimalDigit :: one of
            `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

          DecimalDigits ::
            DecimalDigit
            DecimalDigits DecimalDigit
        </emu-grammar>
        <p>다음과 같은 정의가 있습니다:</p>
        <emu-grammar type="definition" example>
          LookaheadExample ::
            `n` [lookahead &notin; { `1`, `3`, `5`, `7`, `9` }] DecimalDigits
            DecimalDigit [lookahead &notin; DecimalDigit]
        </emu-grammar>
        <p>이는 문자 `n` 다음에 첫 번째가 짝수인 하나 이상의 십진수 숫자가 오거나, 십진수 숫자 다음에 또 다른 십진수 숫자가 오지 않는 경우를 일치시킵니다.</p>
        <p>이러한 문구가 구문 문법에서 사용될 때, 바로 뒤따르는 토큰 시퀀스를 명확히 식별하는 것이 불가능할 수 있습니다. 이는 이후 토큰을 결정하려면 이후 위치에서 사용할 렉시컬 목표 기호를 알아야 하기 때문입니다. 그러므로 구문 문법에서 이러한 제한이 사용될 때, 토큰 시퀀스 _seq_가 접두사 제한에 나타나면(집합의 일부로 포함된 경우도 포함), 이후 사용할 렉시컬 목표 기호 선택에 따라 _seq_가 실제로 접두사가 되는지 여부가 바뀔 수 있다면, 이는 편집 오류로 간주합니다.</p>
      </emu-clause>

      <emu-clause id="sec-no-lineterminator-here">
        <h1>[여기 |LineTerminator| 없음]</h1>
        <p>구문 문법의 생산식 우변에 “[no |LineTerminator| here]”가 나타나면, 해당 생산식은 <em>제한 생산식</em>이며, 해당 위치에 입력 스트림에서 |LineTerminator|가 나타나면 사용할 수 없습니다. 예를 들어 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          ThrowStatement :
            `throw` [no LineTerminator here] Expression `;`
        </emu-grammar>
        <p>이는 스크립트에서 `throw` 토큰과 |Expression| 사이에 |LineTerminator|가 있으면 해당 생산식을 사용할 수 없음을 의미합니다.</p>
        <p>제한 생산식에서 |LineTerminator|의 존재가 금지되지 않는 한, 입력 요소 스트림의 연속된 두 토큰 사이에는 |LineTerminator|가 아무리 많이 있어도 스크립트의 구문적 허용성에 영향을 주지 않습니다.</p>
      </emu-clause>

      <emu-clause id="sec-but-not">
        <h1>but not</h1>
        <p>생산식의 우변에 “<b>but not</b>” 문구가 오면, 뒤이어 제외할 확장을 명시하여 특정 확장이 허용되지 않음을 나타냅니다. 예를 들어 다음과 같은 생산식이 있습니다:</p>
        <emu-grammar type="definition" example>
          Identifier ::
            IdentifierName but not ReservedWord
        </emu-grammar>
        <p>이는 비단말기 |Identifier|가 |IdentifierName|을 대체할 수 있는 코드 포인트 시퀀스 중, 동일한 시퀀스가 |ReservedWord|를 대체할 수 없는 경우에만 사용할 수 있음을 의미합니다.</p>
      </emu-clause>

      <emu-clause id="sec-descriptive-phrases">
        <h1>서술적 구문</h1>
        <p>마지막으로 일부 비단말기 기호는 모든 대안을 나열하는 것이 비현실적인 경우 산세리프체로 서술적 문구로 설명됩니다:</p>
        <emu-grammar type="definition" example>
          SourceCharacter ::
            &gt; any Unicode code point
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-algorithm-conventions">
    <h1>알고리즘 관례</h1>
    <p>이 명세서는 알고리즘 단계 지정을 위해 주로 번호가 매겨진 목록을 사용합니다. 이러한 알고리즘은 ECMAScript 언어 구성 요소의 요구 의미론을 정확하게 명시하는 데 사용됩니다. 알고리즘이 특정 구현 기법의 사용을 암시하는 것은 아닙니다. 실제로, 주어진 기능을 더 효율적으로 구현할 수 있는 알고리즘이 있을 수 있습니다.</p>
    <p>알고리즘은 명시적으로 순서가 있는 쉼표로 구분된 별칭 이름 시퀀스로 매개변수화될 수 있으며, 알고리즘 단계 내에서 해당 위치에 전달된 인자를 참조하는 데 사용할 수 있습니다. 선택적 매개변수는 대괄호([ , _name_ ])로 나타내며, 알고리즘 단계 내에서는 필수 매개변수와 차이가 없습니다. 나머지 매개변수(rest parameter)는 매개변수 리스트 끝에 ..._name_ 형태로 나타내며, 필수 및 선택적 매개변수 뒤에 전달된 모든 인자를 List로 수집합니다. 추가 인자가 없는 경우 해당 List는 비어 있습니다.</p>
    <p>알고리즘 단계는 순차적 하위 단계로 세분화될 수 있습니다. 하위 단계는 들여쓰기되며, 그 자체로 더 들여쓰기된 하위 단계로 나뉠 수 있습니다. 개요 번호 매기기 규칙은 첫 번째 하위 단계는 소문자 알파벳, 두 번째 하위 단계는 소문자 로마 숫자를 사용합니다. 세 단계보다 더 깊은 단계가 필요할 경우, 네 번째 단계부터는 숫자를 사용합니다. 예시:</p>
    <emu-alg example>
      1. 최상위 단계
        1. 하위 단계.
        1. 하위 단계.
          1. 하위 하위 단계.
            1. 하위 하위 하위 단계
              1. 하위 하위 하위 하위 단계
                1. 하위 하위 하위 하위 하위 단계
    </emu-alg>
    <p>단계나 하위 단계는 "if" 조건문으로 작성될 수 있으며, 이 경우 조건이 true일 때만 하위 단계를 적용합니다. 단계나 하위 단계가 "else"로 시작하면, 해당 단계는 같은 수준의 직전 “if” 조건문의 부정이 됩니다.</p>
    <p>단계는 하위 단계의 반복적 적용을 지정할 수 있습니다.</p>
    <p>"<dfn id="assert">Assert</dfn>:"로 시작하는 단계는 알고리즘의 불변 조건을 단언합니다. 이러한 단언은 암묵적일 수 있는 알고리즘 불변 조건을 명시적으로 만듭니다. 이러한 단언은 추가적인 의미 요구사항을 더하지 않으므로 구현에서는 검사할 필요가 없습니다. 단순히 알고리즘을 명확히 하기 위해 사용됩니다.</p>
    <p>알고리즘 단계에서는 "Let _x_ be _someValue_" 형식으로 어떤 값에 대한 별칭을 선언할 수 있습니다. 이 별칭은 참조와 유사하여 _x_와 _someValue_가 동일한 데이터에 연결되며, 둘 중 하나를 수정하면 모두에 반영됩니다. 참조와 유사한 동작을 피하고 싶으면, 오른쪽 값을 명시적으로 복사하도록 "Let _x_ be a copy of _someValue_"를 사용합니다. 이는 _someValue_의 얕은 복사를 만듭니다.</p>
    <p>별칭이 선언된 이후에는 모든 이후 단계에서 참조할 수 있으며, 선언 이전 단계에서 참조해서는 안 됩니다. 별칭은 "Set _x_ to _someOtherValue_" 형태로 수정할 수 있습니다.</p>

    <emu-clause id="sec-algorithm-conventions-abstract-operations">
      <h1>추상 연산</h1>
      <p>이 명세서의 여러 부분에서 사용할 수 있도록, 일부 알고리즘(추상 연산)은 이름을 붙이고 매개변수화된 함수 형태로 작성되며, 다른 알고리즘 내에서 이름으로 참조될 수 있습니다. 추상 연산은 일반적으로 함수 호출 형태(OperationName(_arg1_, _arg2_))로 참조됩니다. 일부 추상 연산은 클래스와 유사한 명세 추상화의 다형적 메서드로 취급됩니다. 이러한 메서드형 추상 연산은 _someValue_.OperationName(_arg1_, _arg2_)와 같은 메서드 호출 형태로 참조됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-algorithm-conventions-syntax-directed-operations">
      <h1>구문 지향 연산</h1>
      <p><dfn variants="syntax-directed operations">구문 지향 연산</dfn>은 이름이 붙은 연산으로, 각 연산은 ECMAScript 문법의 하나 이상의 생산식과 연결된 알고리즘으로 정의됩니다. 여러 대안 정의가 있는 생산식은 일반적으로 각 대안마다 별도의 알고리즘을 가집니다. 알고리즘이 문법 생산식과 연결되어 있을 때, 해당 생산식의 단말기와 비단말기 기호를 알고리즘의 매개변수처럼 참조할 수 있습니다. 이때 비단말기 기호는 소스 텍스트를 파싱할 때 실제로 일치된 대안 정의를 참조합니다. <dfn oldids="sec-static-semantics-sourcetext">문법 생산식 또는 그로부터 파생된 파스 노드가 일치시킨 소스 텍스트</dfn>는 일치에 참여한 첫 번째 단말기에서 시작하여 마지막 단말기에서 끝나는 소스 텍스트의 부분입니다.</p>
      <p>알고리즘이 생산식 대안과 연결될 때, 대안은 일반적으로 “[ ]” 문법 주석 없이 표시됩니다. 이러한 주석은 대안의 구문 인식에만 영향을 주며, 연결된 의미에는 영향을 주지 않습니다.</p>
      <p>구문 지향 연산은 파스 노드와 필요에 따라 추가 매개변수를 넘겨 호출합니다. 다음 알고리즘의 <emu-xref href="#step-sdo-invocation-example-1"></emu-xref>, <emu-xref href="#step-sdo-invocation-example-2"></emu-xref>, <emu-xref href="#step-sdo-invocation-example-3"></emu-xref> 단계를 참고하세요:</p>
      <emu-alg example>
        1. [id="step-sdo-invocation-example-1"] Let _status_ be SyntaxDirectedOperation of |SomeNonTerminal|.
        1. Let _someParseNode_ be the parse of some source text.
        1. [id="step-sdo-invocation-example-2"] Perform SyntaxDirectedOperation of _someParseNode_.
        1. [id="step-sdo-invocation-example-3"] Perform SyntaxDirectedOperation of _someParseNode_ with argument *"value"*.
      </emu-alg>
      <p>별도로 명시되지 않는 한, 모든 체인 생산식은 해당 좌변 비단말기에 적용될 수 있는 모든 연산에 대해 암시적 정의를 가집니다. 암시적 정의는 동일한 연산을 동일한 매개변수로 체인 생산식의 유일한 우변 비단말기에 다시 적용한 다음 그 결과를 반환합니다. 예를 들어, 어떤 알고리즘에 “Return Evaluation of |Block|”이라는 단계가 있고, 다음과 같은 생산식이 있다고 가정합니다:</p>
      <emu-grammar example>
        Block :
          `{` StatementList `}`
      </emu-grammar>
      <p>Evaluation 연산이 해당 생산식과 연결된 알고리즘을 갖지 않는 경우, Evaluation 연산은 다음과 같은 연결을 암시적으로 포함합니다:</p>
      <p><b>런타임 의미론: Evaluation</b></p>
      <emu-grammar example>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg example>
        1. Return Evaluation of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics">
      <h1>런타임 의미론</h1>
      <p>런타임에 호출되어야 하는 의미론을 명시하는 알고리즘을 <dfn>런타임 의미론</dfn>이라고 합니다. 런타임 의미론은 추상 연산 또는 구문 지향 연산으로 정의됩니다.</p>

      <emu-clause id="sec-completion-ao" type="abstract operation">
        <h1>
          Completion (
            _completionRecord_: a Completion Record,
          ): a Completion Record
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>Completion Record를 반환함을 강조하기 위해 사용됩니다.</dd>
          <dt>return 검사 생략</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: _completionRecord_는 Completion Record이다.
          1. _completionRecord_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throw-an-exception">
        <h1>예외 던지기</h1>
        <p>알고리즘 단계에서 예외를 던지라고 명시된 경우(예:</p>
        <emu-alg example>
          1. *TypeError* 예외를 던진다.
        </emu-alg>
        <p>)는 다음과 동일한 의미입니다:</p>
        <emu-alg example>
          1. Return ThrowCompletion(새로 생성된 *TypeError* 객체).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt" aoid="ReturnIfAbrupt">
        <h1>ReturnIfAbrupt</h1>
        <p>다음과 같이 명시된 알고리즘 단계:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_argument_).
        </emu-alg>
        <p>는 다음과 동일합니다:</p>
        <emu-alg example>
          1. Assert: _argument_는 Completion Record이다.
          1. _argument_가 abrupt completion이면 Completion(_argument_)를 반환한다.
          1. 그렇지 않으면, _argument_를 _argument_.[[Value]]로 설정한다.
        </emu-alg>
        <p>다음과 같이 명시된 알고리즘 단계:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(AbstractOperation()).
        </emu-alg>
        <p>는 다음과 동일합니다:</p>
        <emu-alg example>
          1. Let _hygienicTemp_ be AbstractOperation().
          1. Assert: _hygienicTemp_는 Completion Record이다.
          1. _hygienicTemp_가 abrupt completion이면 Completion(_hygienicTemp_)를 반환한다.
          1. 그렇지 않으면, _hygienicTemp_를 _hygienicTemp_.[[Value]]로 설정한다.
        </emu-alg>
        <p>여기서 _hygienicTemp_는 일시적이며, ReturnIfAbrupt 관련 단계에서만 보입니다.</p>
        <p>다음과 같이 명시된 알고리즘 단계:</p>
        <emu-alg example>
          1. Let _result_ be AbstractOperation(ReturnIfAbrupt(_argument_)).
        </emu-alg>
        <p>는 다음과 동일합니다:</p>
        <emu-alg example>
          1. Assert: _argument_는 Completion Record이다.
          1. _argument_가 abrupt completion이면 Completion(_argument_)를 반환한다.
          1. 그렇지 않으면, _argument_를 _argument_.[[Value]]로 설정한다.
          1. Let _result_ be AbstractOperation(_argument_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt-shorthands">
        <h1>ReturnIfAbrupt 축약 표기</h1>
        <p>추상 연산 및 구문 지향 연산의 호출 앞에 `?`가 붙으면, 결과 Completion Record에 ReturnIfAbrupt를 적용해야 함을 나타냅니다. 예를 들어:</p>
        <emu-alg example>
          1. ? OperationName().
        </emu-alg>
        <p>는 다음 단계와 같습니다:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(OperationName()).
        </emu-alg>
        <p>메서드 호출 형태에서도 마찬가지로 다음 단계:</p>
        <emu-alg example>
          1. ? _someValue_.OperationName().
        </emu-alg>
        <p>는 다음과 같습니다:</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_someValue_.OperationName()).
        </emu-alg>
        <p>마찬가지로, `!`를 앞에 붙이면, 해당 추상 또는 구문 지향 연산이 abrupt completion을 반환하지 않음을 의미하며, 결과 Completion Record의 [[Value]] 필드를 연산의 반환값으로 사용함을 나타냅니다. 예를 들어:</p>
        <emu-alg example>
          1. Let _val_ be ! OperationName().
        </emu-alg>
        <p>는 다음 단계와 같습니다:</p>
        <emu-alg example>
          1. Let _val_ be OperationName().
          1. Assert: _val_은 정상 completion이다.
          1. _val_을 _val_.[[Value]]로 설정한다.
        </emu-alg>
        <p>런타임 의미론용 구문 지향 연산에서는 이 축약 표기를 사용하여 연산 호출 앞에 `!` 또는 `?`를 둡니다:</p>
        <emu-alg example>
          1. Perform ! SyntaxDirectedOperation of |NonTerminal|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-implicit-normal-completion" oldids="sec-implicit-completion-values">
        <h1>암시적 정상 Completion</h1>
        <p>Completion Record를 반환하도록 선언된 추상 연산 내부 알고리즘과 모든 내장 함수에서는 반환값이 먼저 NormalCompletion에 전달되고, 그 결과가 대신 사용됩니다. 이 규칙은 Completion 알고리즘 내부 또는 반환되는 값이 해당 단계에서 Completion Record로 명확히 표시된 경우에는 적용되지 않습니다. 적용 예시는 다음과 같습니다:</p>
        <ul>
          <li>Completion, NormalCompletion, ThrowCompletion, ReturnCompletion을 적용한 결과를 바로 반환할 때</li>
          <li>Completion Record를 생성한 결과를 바로 반환할 때</li>
        </ul>
        <p>이러한 추상 연산에서 다른 방식으로 Completion Record를 반환하면 편집 오류입니다. 예를 들어, 다음과 같은 경우,</p>
        <emu-alg example>
          1. Return *true*.
        </emu-alg>
        <p>는 다음 중 아무거나와 동일합니다:</p>
        <emu-alg example>
          1. Return NormalCompletion(*true*).
        </emu-alg>
        <p>또는</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*).
          1. Return Completion(_completion_).
        </emu-alg>
        <p>또는</p>
        <emu-alg example>
          1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: *true*, [[Target]]: ~empty~ }.
        </emu-alg>
        <p>ReturnIfAbrupt 확장에 따라, 다음 예시는 허용됩니다. 확장된 단계 내에서는 Completion 적용 결과가 abrupt인 경우 바로 반환되고, normal인 경우 unwrapping 후 암시적 NormalCompletion이 적용됩니다.</p>
        <emu-alg example>
          1. Return ? _completion_.
        </emu-alg>
        <p>다음 예시는 Completion Record가 해당 단계에서 명시되지 않은 채 반환되므로 편집 오류입니다.</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*).
          1. Return _completion_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-static-semantic-rules">
      <h1>정적 의미론</h1>
      <p>문맥 자유 문법만으로는 입력 요소 스트림이 평가 가능한 ECMAScript |Script| 또는 |Module|로서 유효한지를 정의하는 모든 규칙을 표현할 수 없습니다. 일부 상황에서는 ECMAScript 알고리즘 관례나 산문 요구사항을 활용해서 추가 규칙을 명시해야 하며, 이러한 규칙은 항상 문법의 생산식과 연결되어 <dfn>해당 생산식의 정적 의미론</dfn>이라 불립니다.</p>
      <p>정적 의미론 규칙에는 이름이 있으며, 일반적으로 알고리즘으로 정의됩니다. 이름이 붙은 정적 의미론 규칙은 문법 생산식과 연결되며, 여러 대안 정의가 있는 생산식은 각 대안마다 해당 규칙에 대해 별도의 알고리즘을 가집니다.</p>
      <p>정적 의미론 규칙의 특별한 종류가 <dfn id="early-error-rule">초기 오류 규칙(Early Error Rule)</dfn>입니다. 초기 오류 규칙은 특정 문법 생산식과 연결된 초기 오류 조건을 정의하며(<emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 참조), 대부분의 초기 오류 규칙은 이 명세서 알고리즘에서 명시적으로 호출되지 않습니다. 적합한 구현체는 |Script| 또는 |Module|을 최초로 평가하기 전에, 해당 |Script| 또는 |Module|을 파싱하는 데 사용된 모든 생산식의 초기 오류 규칙을 반드시 검증해야 합니다. 초기 오류 규칙이 하나라도 위반되면 |Script| 또는 |Module|은 유효하지 않으며 평가될 수 없습니다.</p>
    </emu-clause>

    <emu-clause id="sec-mathematical-operations">
      <h1>수학 연산</h1>
      <p>이 명세서에서 참조하는 숫자값 종류는 다음과 같습니다:</p>
      <ul>
        <li><dfn id="mathematical-value" variants="mathematical value,mathematical values">수학적 값</dfn>: 임의의 실수. 기본 숫자 타입으로 사용됨.</li>
        <li><dfn id="extended-mathematical-value" variants="extended mathematical value,extended mathematical values">확장 수학적 값</dfn>: 수학적 값과 +∞, -∞ 포함.</li>
        <li><em>Numbers</em>: IEEE 754-2019 binary64(배정밀도 부동소수점) 값.</li>
        <li><em>BigInts</em>: ECMAScript 언어값으로, 임의의 정수와 일대일 대응됨.</li>
      </ul>

      <p>이 명세서에서 숫자값은 첨자 표기로 종류를 구분합니다. 첨자 <sub>𝔽</sub>는 Numbers를, <sub>ℤ</sub>는 BigInts를 나타냅니다. 첨자 없는 숫자값은 수학적 값을 의미합니다. 대부분의 숫자값은 10진수로 표기되며, 0x로 시작하고 0-9 또는 A-F로 이어지는 값은 16진수로 사용됩니다.</p>
      <p>명세서에서 "the length of _y_"나 "the integer represented by the four hexadecimal digits ..."와 같이 명시적 숫자 종류 없이 숫자값을 언급하면, 이는 수학적 값을 의미합니다. Number나 BigInt 값을 명시할 경우, "the Number value for ..." 또는 "the BigInt value for ..."와 같이 명시적으로 구분합니다.</p>
      <p><dfn id="integer" oldids="mathematical integer" variants="integers">integer</dfn>라는 용어는 별도 명시가 없는 한, 정수 집합에 속하는 수학적 값을 의미합니다. <dfn id="integral-number" oldids="sec-isintegralnumber,sec-isinteger" variants="integral Numbers">integral Number</dfn>라는 용어는 수학적으로 정수 집합에 속하는 유한한 Number 값을 의미합니다.</p>
      <p>+, ×, =, ≥ 등 숫자 연산자는 피연산자의 타입에 따라 연산이 결정됩니다. 수학적 값에 적용하면 일반 수학 연산을, 확장 수학적 값에 적용하면 확장 실수에 대한 연산을 의미합니다. 정의되지 않은 형태는 사용해서는 안 되며, 명세서에 사용되면 편집 오류입니다. Numbers에 적용하면 IEEE 754-2019에 따른 연산을, BigInts에 적용하면 BigInt의 수학적 값에 대한 연산을 의미합니다. 타입이 혼합된(예: Number와 수학적 값) 피연산자에 대한 숫자 연산은 정의되지 않으며, 명세서에서 사용되면 편집 오류입니다.</p>
      <p>수학적 값과 Number 또는 BigInt 간의 변환은 항상 명시적으로 나타납니다. 수학적 값 또는 확장 수학적 값 _x_를 Number로 변환하면 "the Number value for _x_" 또는 <emu-eqn id="𝔽" aoid="𝔽">𝔽(_x_)</emu-eqn>로 표기하며, <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>에서 정의됩니다. 정수 _x_를 BigInt로 변환하면 "the <dfn id="bigint-value-for">BigInt value for</dfn> _x_" 또는 <emu-eqn id="ℤ" aoid="ℤ">ℤ(_x_)</emu-eqn>로 표기합니다. Number 또는 BigInt _x_를 수학적 값으로 변환하면 "the <dfn id="mathematical-value-of">mathematical value of</dfn> _x_" 또는 <emu-eqn id="ℝ" aoid="ℝ">ℝ(_x_)</emu-eqn>로 표기합니다. *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>의 수학적 값은 0입니다. 비유한 값의 수학적 값은 정의되지 않습니다. <dfn id="extended-mathematical-value-of">extended mathematical value of</dfn> _x_는 유한 값에는 수학적 값, *+∞*<sub>𝔽</sub>와 *-∞*<sub>𝔽</sub>에는 각각 +∞, -∞가 되며, *NaN*에는 정의되지 않습니다.</p>
      <p>수학 함수 <emu-eqn id="eqn-abs" aoid="abs">abs(_x_)</emu-eqn>는 _x_의 절댓값을 반환하며, _x_ &lt; 0이면 <emu-eqn>-_x_</emu-eqn>, 그렇지 않으면 _x_ 자체입니다.</p>
      <p>수학 함수 <emu-eqn id="eqn-min" aoid="min">min(_x1_, _x2_, … , _xN_)</emu-eqn>은 <emu-eqn>_x1_</emu-eqn> ~ <emu-eqn>_xN_</emu-eqn> 중 가장 작은 값을 반환합니다. <emu-eqn id="eqn-max" aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn>은 가장 큰 값을 반환합니다. 이 수학 함수의 정의역과 값의 범위는 확장 수학적 값입니다.</p>
      <p>“<emu-eqn id="eqn-modulo" aoid="modulo">_x_ modulo _y_</emu-eqn>”(_y_는 유한하고 0이 아니어야 함)은 _y_와 같은 부호(또는 0)를 가진 값 _k_를 계산하며, <emu-eqn>abs(_k_) &lt; abs(_y_) and _x_ - _k_ = _q_ × _y_</emu-eqn>를 만족하는 정수 _q_가 존재합니다.</p>
      <p>"the result of <dfn id="clamping">clamping</dfn> _x_ between _lower_ and _upper_"(_x_는 확장 수학적 값, _lower_, _upper_는 _lower_ ≤ _upper_인 수학적 값)란, _x_ &lt; _lower_면 _lower_, _x_ > _upper_면 _upper_, 아니면 _x_를 반환합니다.</p>
      <p>수학 함수 <emu-eqn id="eqn-floor" aoid="floor">floor(_x_)</emu-eqn>는 _x_보다 크지 않은 가장 큰 정수(가장 +∞에 가까운)를 반환합니다.</p>
      <emu-note>
        <p><emu-eqn>floor(_x_) = _x_ - (_x_ modulo 1)</emu-eqn>.</p>
      </emu-note>
      <p>수학 함수 <emu-eqn id="eqn-truncate" aoid="truncate">truncate(_x_)</emu-eqn>는 _x_의 소수 부분을 제거하며, _x_ &lt; 0이면 <emu-eqn>-floor(-_x_)</emu-eqn>, 아니면 <emu-eqn>floor(_x_)</emu-eqn>를 반환합니다.</p>
      <p>min, max, abs, floor, truncate 함수는 Numbers와 BigInts에는 정의되지 않으며, 수학적 값이 아닌 인자를 사용하는 경우 명세서에서 편집 오류입니다.</p>
      <p>하한 _a_ ~ 상한 _b_의 <dfn id="interval">구간</dfn>은 동일 숫자 타입의 값 집합이며, 무한 혹은 빈 집합일 수 있습니다. 각 구간의 경계는 포함 또는 제외로 표시되나, 둘 다는 아닙니다. 구간 종류는 다음 네 가지입니다:</p>
      <ul>
        <li>_a_ (포함) ~ _b_ (포함) 구간(<dfn id="inclusive-interval">inclusive interval</dfn>)은 _a_ ≤ _x_ ≤ _b_인 값만 포함합니다.</li>
        <li>_a_ (포함) ~ _b_ (제외) 구간은 _a_ ≤ _x_ &lt; _b_인 값만 포함합니다.</li>
        <li>_a_ (제외) ~ _b_ (포함) 구간은 _a_ &lt; _x_ ≤ _b_인 값만 포함합니다.</li>
        <li>_a_ (제외) ~ _b_ (제외) 구간은 _a_ &lt; _x_ &lt; _b_인 값만 포함합니다.</li>
      </ul>
      <p>예를 들어 1(포함) ~ 2(제외) 구간은 1 이상 2 미만의 모든 수학적 값을 포함하며, 1은 포함, 2는 포함하지 않습니다. 구간 정의에서 *-0*<sub>𝔽</sub> &lt; *+0*<sub>𝔽</sub>이므로, 하한이 *+0*<sub>𝔽</sub>인 포함 구간은 *+0*<sub>𝔽</sub>는 포함하나 *-0*<sub>𝔽</sub>는 포함하지 않습니다. *NaN*은 절대 구간에 포함되지 않습니다.</p>
    </emu-clause>

    <emu-clause id="sec-value-notation">
      <h1>값 표기법</h1>
      <p>이 명세서에서 ECMAScript 언어값은 *굵게* 표시됩니다. 예시로 *null*, *true*, *"hello"* 등이 있으며, `Function.prototype.apply`나 `let n = 42;`처럼 ECMAScript 소스 텍스트와 구분됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-identity">
      <h1>동일성</h1>
      <p>이 명세서에서는 명세 값과 ECMAScript 언어값 모두 동등성 비교를 합니다. 동등성 비교 시 값은 두 가지 범주로 나뉩니다. <dfn variants="values without identity,value without identity">동일성 없는 값</dfn>은 모든 고유 특성이 동일하면 서로 동등합니다(예: 정수 크기나 시퀀스 길이). 이러한 값은 특성만으로 참조 없이 나타낼 수 있습니다. 반면 <dfn variants="values with identity">동일성 있는 값</dfn>은 유일하며 자기 자신과만 동등합니다. 동일성 있는 값은 동일성 없는 값과 같으나, <em>동일성</em>이라는 추정 불가, 변경 불가, 전역적으로 유일한 특성을 추가로 가집니다. 기존 동일성 있는 값 참조는 특성 설명만으로 나타낼 수 없으며, 반드시 값을 명시적으로 전달해야 합니다. 일부 동일성 있는 값은 변경 가능하여, 동일성 외 특성이 변하면 모든 참조자가 변경을 관찰합니다. 동일성 없는 값은 동일성 있는 값과 결코 동등하지 않습니다.</p>
      <p>명세 관점에서 “is”는 두 값을 동등 비교하는 데 사용되며(예: “If _bool_ is *true*, then ...”), “contains”는 리스트 내 값을 동등 비교로 찾는 데 사용됩니다(예: "If _list_ contains a Record _r_ such that _r_.[[Foo]] is *true*, then ..."). 값의 <em>명세 동일성</em>이 비교 결과를 결정하며, 이는 명세적으로 자명합니다.</p>
      <p>ECMAScript 언어 관점에서는 언어값을 SameValue 추상 연산 및 그 하위 추상 연산으로 비교합니다. 이 비교 추상 연산 알고리즘이 ECMAScript 언어값의 <em>언어 동일성</em>을 결정합니다.</p>
      <p>명세 값 중 동일성 없는 예시는: 수학적 값과 확장 수학적 값, ECMAScript 소스 텍스트, surrogate pair, Directive Prologue 등, UTF-16 코드 유닛, 유니코드 코드 포인트, enum, 추상 연산(구문 지향 연산, host hook 등), 정렬된 쌍 등이 있습니다. 동일성 있는 예시는: Property Descriptor, PrivateElement 등 다양한 Record, Parse Node, List, <emu-xref href="#sec-set-and-relation-specification-type">Set</emu-xref>과 Relation, Abstract Closure, Data Block, Private Name, 실행 컨텍스트 및 스택, agent signifier, WaiterList Record 등이 있습니다.</p>
      <p>명세 동일성은 ECMAScript 언어값 중 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>로 생성된 Symbol을 제외하고 언어 동일성과 일치합니다. 명세 동일성 및 언어 동일성 모두 없는 ECMAScript 언어값은 <emu-xref href="#sec-ecmascript-language-types-undefined-type">*undefined*</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-null-type">*null*</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-boolean-type">Boolean</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-string-type">String</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-number-type">Number</emu-xref>, <emu-xref href="#sec-ecmascript-language-types-bigint-type">BigInt</emu-xref>입니다. 명세 동일성과 언어 동일성을 모두 가지는 ECMAScript 언어값은 <emu-xref href="#sec-ecmascript-language-types-symbol-type">Symbol</emu-xref>(단, <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 생성이 아닌 경우) 및 <emu-xref href="#sec-object-type">Object</emu-xref>입니다. <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>로 생성된 Symbol은 명세 동일성은 있으나 언어 동일성은 없습니다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript 데이터 타입과 값</h1>
  <p>이 명세서의 알고리즘은 각각 타입이 연관된 값을 다룹니다. 가능한 값의 타입은 이 절에서 정의된 것들만 해당합니다. 타입은 ECMAScript 언어 타입과 명세 타입으로 분류됩니다.</p>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript 언어 타입</h1>
    <p><dfn variants="ECMAScript language types">ECMAScript 언어 타입</dfn>은 ECMAScript 프로그래머가 ECMAScript 언어를 통해 직접 다루는 값에 해당합니다. ECMAScript 언어 타입에는 Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object가 있습니다. <dfn variants="ECMAScript language values">ECMAScript 언어 값</dfn>은 ECMAScript 언어 타입에 의해 특징지어지는 값입니다.</p>

    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>Undefined 타입</h1>
      <p>Undefined 타입은 *undefined*라는 단 하나의 값만을 가집니다. 값이 할당되지 않은 변수는 *undefined* 값을 가집니다.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>Null 타입</h1>
      <p>Null 타입은 *null*이라는 단 하나의 값만을 가집니다.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>Boolean 타입</h1>
      <p><dfn variants="is a Boolean,is not a Boolean">Boolean 타입</dfn>은 *true*와 *false*라는 두 값을 가지는 논리적 개체를 나타냅니다.</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>String 타입</h1>
      <p><dfn variants="is a String,is not a String">String 타입</dfn>은 0개 이상의 16비트 부호 없는 정수값(“요소”)으로 이루어진 모든 순서 있는 시퀀스의 집합이며, 최대 길이는 2<sup>53</sup> - 1 요소까지입니다. String 타입은 일반적으로 ECMAScript 프로그램에서 텍스트 데이터를 표현하는 데 사용되며, 이 경우 String의 각 요소는 UTF-16 코드 유닛 값으로 간주됩니다. 각 요소는 시퀀스 내에서 위치를 가지며, 이 위치는 0 이상의 정수 인덱스로 지정됩니다. 첫 번째 요소(존재한다면)는 인덱스 0, 그 다음 요소는 인덱스 1 등입니다. String의 길이는 그 안에 포함된 요소(즉, 16비트 값)의 개수입니다. 빈 문자열은 길이가 0이며, 요소가 존재하지 않습니다.</p>
      <p>String 내용을 해석하지 않는 ECMAScript 연산은 추가 의미를 적용하지 않습니다. String 값을 해석하는 연산은 각 요소를 단일 UTF-16 코드 유닛으로 취급합니다. 그러나 ECMAScript는 이 코드 유닛의 값이나 관계를 제한하지 않으므로, 추가적으로 String 내용을 UTF-16로 인코딩된 유니코드 코드 포인트 시퀀스로 해석하는 연산은 잘못된 하위 시퀀스를 고려해야 합니다. 이러한 연산은 다음 규칙에 따라 0xD800~0xDBFF(유니코드 표준에서 <dfn id="leading-surrogate" variants="leading surrogates">선행 서러게이트</dfn>, 또는 <dfn id="high-surrogate-code-unit" variants="high-surrogate code units">high-surrogate 코드 유닛</dfn>)와 0xDC00~0xDFFF(<dfn id="trailing-surrogate" variants="trailing surrogates">후행 서러게이트</dfn>, 또는 <dfn id="low-surrogate-code-unit" variants="low-surrogate code units">low-surrogate 코드 유닛</dfn>) 값을 특별 처리합니다:</p>
      <ul>
        <li>
          선행 서러게이트도 아니고 후행 서러게이트도 아닌 코드 유닛은 동일한 값의 코드 포인트로 해석됩니다.
        </li>
        <li>
          첫 번째 코드 유닛 _c1_이 선행 서러게이트이고 두 번째 코드 유닛 _c2_가 후행 서러게이트인 두 개의 코드 유닛 시퀀스는 <dfn id="surrogate-pair" variants="surrogate pairs">서러게이트 페어</dfn>이며, (_c1_ - 0xD800) × 0x400 + (_c2_ - 0xDC00) + 0x10000 값의 코드 포인트로 해석됩니다. (<emu-xref href="#sec-utf16decodesurrogatepair"></emu-xref> 참고)
        </li>
        <li>
          서러게이트 페어의 일부가 아닌 선행 서러게이트 또는 후행 서러게이트 코드 유닛은 동일한 값의 코드 포인트로 해석됩니다.
        </li>
      </ul>
      <p>`String.prototype.normalize` 함수(<emu-xref href="#sec-string.prototype.normalize"></emu-xref>)는 String 값을 명시적으로 정규화하는 데 사용할 수 있습니다. `String.prototype.localeCompare`(<emu-xref href="#sec-string.prototype.localecompare"></emu-xref>)는 내부적으로 String 값을 정규화하지만, 다른 연산은 암묵적으로 문자열을 정규화하지 않습니다. 연산 결과가 언어 또는 로케일에 민감하지 않음이 별도로 명시되지 않는 한 적용됩니다.</p>
      <emu-note>
        <p>이 설계의 취지는 문자열 구현을 최대한 단순하고 고성능으로 유지하는 것이었습니다. ECMAScript 소스 텍스트가 Normalized Form C인 경우, 문자열 리터럴은 유니코드 이스케이프 시퀀스를 포함하지 않는 한 정규화가 보장됩니다.</p>
      </emu-note>
      <p>이 명세서에서 "the <dfn id="string-concatenation">string-concatenation</dfn> of _A_, _B_, ..."라는 구문(각 인자가 String 값, 코드 유닛, 또는 코드 유닛 시퀀스임)은 인자 각각의 코드 유닛을 차례로 이어붙인 시퀀스로 구성된 String 값을 의미합니다.</p>
      <p>"the <dfn id="substring">substring</dfn> of _S_ from _inclusiveStart_ to _exclusiveEnd_"(여기서 _S_는 String 값 또는 코드 유닛 시퀀스, _inclusiveStart_와 _exclusiveEnd_는 정수)라는 구문은 _inclusiveStart_ 인덱스에서 시작하여 _exclusiveEnd_ 바로 앞까지 연속된 코드 유닛으로 구성된 String 값을 의미합니다(_inclusiveStart_ = _exclusiveEnd_이면 빈 문자열). "to" 접미사가 생략된 경우, _S_의 길이가 _exclusiveEnd_로 사용됩니다.</p>
      <p>
        "<dfn id="ASCII-word-characters">ASCII word characters</dfn>"라는 구문은 다음 String 값을 의미하며, 이는 유니코드 Basic Latin 블록 내 모든 문자와 숫자, U+005F(LOW LINE)만으로 구성됩니다:<br>
        *"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"*.<br>
        역사적 이유로 여러 알고리즘에서 의미를 가집니다.
      </p>

      <emu-clause id="sec-stringindexof" type="abstract operation">
        <h1>
          StringIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer 또는 ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _string_의 길이를 _len_으로 한다.
          1. _searchValue_가 빈 문자열이고 _fromIndex_ ≤ _len_이면 _fromIndex_를 반환한다.
          1. _searchValue_의 길이를 _searchLen_으로 한다.
          1. _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_인 각 정수 _i_에 대해 오름차순으로,
            1. _string_의 _i_에서 _i_ + _searchLen_까지의 substring을 _candidate_로 한다.
            1. _candidate_가 _searchValue_와 같다면 _i_를 반환한다.
          1. ~not-found~를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_searchValue_가 빈 문자열이고 _fromIndex_ ≤ _string_의 길이면 이 알고리즘은 _fromIndex_를 반환합니다. 빈 문자열은 문자열 내 모든 위치(마지막 코드 유닛 뒤 포함)에서 발견된 것으로 간주됩니다.</p>
        </emu-note>
        <emu-note>
          <p>_fromIndex_ + _searchValue_의 길이 > _string_의 길이이면 이 알고리즘은 항상 ~not-found~를 반환합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-stringlastindexof" type="abstract operation">
        <h1>
          StringLastIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer 또는 ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _string_의 길이를 _len_으로 한다.
          1. _searchValue_의 길이를 _searchLen_으로 한다.
          1. Assert: _fromIndex_ + _searchLen_ ≤ _len_.
          1. 0 ≤ _i_ ≤ _fromIndex_인 각 정수 _i_에 대해 내림차순으로,
            1. _string_의 _i_에서 _i_ + _searchLen_까지의 substring을 _candidate_로 한다.
            1. _candidate_가 _searchValue_와 같다면 _i_를 반환한다.
          1. ~not-found~를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_searchValue_가 빈 문자열이면 이 알고리즘은 _fromIndex_를 반환합니다. 빈 문자열은 문자열 내 모든 위치(마지막 코드 유닛 뒤 포함)에서 발견된 것으로 간주됩니다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>Symbol 타입</h1>
      <p><dfn variants="is a Symbol,is not a Symbol">Symbol 타입</dfn>은 Object 프로퍼티의 키로 사용될 수 있는 모든 String이 아닌 값의 집합입니다(<emu-xref href="#sec-object-type"></emu-xref> 참고).</p>
      <p>각 Symbol은 고유하며 변하지 않습니다.</p>
      <p>각 Symbol에는 불변의 [[Description]] 내부 슬롯이 있으며, 그 값은 String 또는 *undefined*입니다.</p>

      <emu-clause id="sec-well-known-symbols">
        <h1>잘 알려진 심볼들</h1>
        <p>잘 알려진 심볼은 이 명세서 알고리즘에서 명시적으로 참조되는 내장 Symbol 값입니다. 일반적으로 이 값들은 명세 알고리즘의 확장 지점 역할을 하는 프로퍼티의 키로 사용됩니다. 별도 명시가 없는 한, 잘 알려진 심볼 값은 모든 realm에서 공유됩니다(<emu-xref href="#sec-code-realms"></emu-xref> 참고).</p>
        <p>이 명세서에서는 잘 알려진 심볼을 <emu-xref href="#sec-well-known-intrinsic-objects">intrinsic 표기법</emu-xref>으로 표기하며, intrinsic은 <emu-xref href="#table-well-known-symbols"></emu-xref>에 나열된 값 중 하나입니다.</p>
        <emu-note>이전 명세 판에서는 @@name 형식의 표기를 사용하였으며, 현재 판에서는 `%Symbol.name%`을 사용합니다. 특히 다음 이름들이 사용되었습니다: @@asyncIterator, @@hasInstance, @@isConcatSpreadable, @@<emu-not-ref>iterator</emu-not-ref>, @@match, @@matchAll, @@replace, @@search, @@species, @@split, @@toPrimitive, @@toStringTag, @@unscopables.</emu-note>
        <emu-table id="table-well-known-symbols" caption="잘 알려진 심볼" oldids="table-1">
          <table>
            <thead>
              <tr>
                <th>
                  명세 이름
                </th>
                <th>
                  [[Description]]
                </th>
                <th>
                  값 및 용도
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                <dfn>%Symbol.asyncIterator%</dfn>
              </td>
              <td>
                *"Symbol.asyncIterator"*
              </td>
              <td>
                객체의 기본 비동기 이터레이터를 반환하는 메서드. `for`-`await`-`of` 구문의 의미론에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.hasInstance%</dfn>
              </td>
              <td>
                *"Symbol.hasInstance"*
              </td>
              <td>
                생성자 객체가 특정 객체를 자신의 인스턴스로 인식하는지 결정하는 메서드. `instanceof` 연산자 의미론에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.isConcatSpreadable%</dfn>
              </td>
              <td>
                *"Symbol.isConcatSpreadable"*
              </td>
              <td>
                값이 true면, 객체가 <emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref>에 의해 배열 요소로 평탄화되어야 함을 나타내는 Boolean 프로퍼티.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.iterator%</dfn>
              </td>
              <td>
                *"Symbol.iterator"*
              </td>
              <td>
                객체의 기본 이터레이터를 반환하는 메서드. for-of 구문의 의미론에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.match%</dfn>
              </td>
              <td>
                *"Symbol.match"*
              </td>
              <td>
                정규 표현식을 문자열과 매칭하는 정규식 메서드. <emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.matchAll%</dfn>
              </td>
              <td>
                *"Symbol.matchAll"*
              </td>
              <td>
                정규 표현식을 문자열과 매칭하여 이터레이터로 반환하는 정규식 메서드. <emu-xref href="#sec-string.prototype.matchall">`String.prototype.matchAll`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.replace%</dfn>
              </td>
              <td>
                *"Symbol.replace"*
              </td>
              <td>
                문자열의 매칭된 부분을 교체하는 정규식 메서드. <emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.search%</dfn>
              </td>
              <td>
                *"Symbol.search"*
              </td>
              <td>
                정규 표현식과 매칭되는 문자열 내의 인덱스를 반환하는 정규식 메서드. <emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.species%</dfn>
              </td>
              <td>
                *"Symbol.species"*
              </td>
              <td>
                파생 객체를 생성하는 데 사용되는 생성자 함수값 프로퍼티.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.split%</dfn>
              </td>
              <td>
                *"Symbol.split"*
              </td>
              <td>
                정규 표현식과 매칭되는 인덱스에서 문자열을 분할하는 정규식 메서드. <emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref> 메서드에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toPrimitive%</dfn>
              </td>
              <td>
                *"Symbol.toPrimitive"*
              </td>
              <td>
                객체를 해당 원시값으로 변환하는 메서드. ToPrimitive 추상 연산에 의해 호출됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toStringTag%</dfn>
              </td>
              <td>
                *"Symbol.toStringTag"*
              </td>
              <td>
                객체의 기본 문자열 설명을 생성하는 데 사용되는 String 값 프로퍼티. <emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref> 내장 메서드에서 접근됨.
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.unscopables%</dfn>
              </td>
              <td>
                *"Symbol.unscopables"*
              </td>
              <td>
                자신의 프로퍼티명과 상속된 프로퍼티명이 해당 객체의 `with` 환경 바인딩에서 제외되는 객체 값 프로퍼티.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-numeric-types">
      <h1>숫자 타입</h1>
      <p>ECMAScript에는 두 가지 내장 숫자 타입(Number와 BigInt)이 있습니다. 아래 추상 연산들은 이 숫자 타입에 대해 정의되어 있습니다. "결과(Result)" 열은 반환 타입과, 일부 연산 호출이 abrupt completion을 반환할 수 있는지 여부를 나타냅니다.</p>
      <emu-table id="table-numeric-type-ops" caption="숫자 타입 연산">
        <table>
          <thead>
            <tr>
              <th>
                연산
              </th>
              <th>
                예시 소스
              </th>
              <th>
                평가 의미론에서 호출되는 위치
              </th>
              <th>
                결과
              </th>
            </tr>
          </thead>

          <tr>
            <td>
              Number::unaryMinus
            </td>
            <td rowspan="2">
              `-x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unary-minus-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unaryMinus
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseNOT
            </td>
            <td rowspan="2">
              `~x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-bitwise-not-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseNOT
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::exponentiate
            </td>
            <td rowspan="2">
              `x&nbsp;**&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-exp-operator" title></emu-xref>
              및 <emu-xref href="#sec-math.pow" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::exponentiate
            </td>
            <td>
              정상 완료(BigInt) 또는 throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::multiply
            </td>
            <td rowspan="2">
              `x&nbsp;*&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::multiply
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::divide
            </td>
            <td rowspan="2">
              `x&nbsp;/&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::divide
            </td>
            <td>
              정상 완료(BigInt) 또는 throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::remainder
            </td>
            <td rowspan="2">
              `x&nbsp;%&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::remainder
            </td>
            <td>
              정상 완료(BigInt) 또는 throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::add
            </td>
            <td rowspan="2">
              `x ++`<br>
              `++ x`<br>
              `x&nbsp;+&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-addition-operator-plus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::add
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::subtract
            </td>
            <td rowspan="2">
              `x --`<br>
              `-- x`<br>
              `x&nbsp;-&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-subtraction-operator-minus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::subtract
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::leftShift
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&lt;&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-left-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::leftShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::signedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-signed-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::signedRightShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::unsignedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unsigned-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unsignedRightShift
            </td>
            <td>
              throw completion
            </td>
          </tr>

          <tr>
            <td>
              Number::lessThan
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&nbsp;y`<br>
              `x&nbsp;>&nbsp;y`<br>
              `x&nbsp;&lt;=&nbsp;y`<br>
              `x&nbsp;>=&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-relational-operators" title></emu-xref>,
              <emu-xref href="#sec-islessthan" title></emu-xref>
            </td>
            <td>
              Boolean 또는 *undefined* (비정렬 입력)
            </td>
          </tr>

          <tr>
            <td>
              BigInt::lessThan
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::equal
            </td>
            <td rowspan="2">
              `x&nbsp;==&nbsp;y`<br>
              `x&nbsp;!=&nbsp;y`<br>
              `x&nbsp;===&nbsp;y`<br>
              `x&nbsp;!==&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-equality-operators" title></emu-xref>,
              <emu-xref href="#sec-isstrictlyequal" title></emu-xref>
            </td>
            <td rowspan="2">
              Boolean
            </td>
          </tr>
          <tr>
            <td>
              BigInt::equal
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValue
            </td>
            <td>
              `Object.is(x, y)`
            </td>
            <td>
              객체 내부 메서드,
              <emu-xref href="#sec-samevalue" title></emu-xref>를 통해,
              정확한 값 동등성 검사
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValueZero
            </td>
            <td>
              `[x].includes(y)`
            </td>
            <td>
              <emu-xref href="#sec-samevaluezero" title></emu-xref>를 통해,
              값 동등성 검사, Array, Map, Set 메서드에서 *+0*<sub>𝔽</sub>과 *-0*<sub>𝔽</sub> 차이 무시
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseAND
            </td>
            <td rowspan="2">
              `x&nbsp;&amp;&nbsp;y`
            </td>
            <td rowspan="6">
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseAND
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseXOR
            </td>
            <td rowspan="2">
              `x&nbsp;^&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseXOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseOR
            </td>
            <td rowspan="2">
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::toString
            </td>
            <td rowspan="2">
              `String(x)`
            </td>
            <td rowspan="2">
              다양한 표현식 및 내장 함수, <emu-xref href="#sec-tostring" title></emu-xref>를 통해
            </td>
            <td rowspan="2">
              String
            </td>
          </tr>
          <tr>
            <td>
              BigInt::toString
            </td>
          </tr>
        </table>
      </emu-table>
      <p>숫자 타입들은 일반적으로 정밀도 손실이나 절단 없이 변환될 수 없으므로, ECMAScript 언어는 이러한 타입들 간의 암시적 변환을 제공하지 않습니다. 프로그래머는 다른 타입이 필요한 함수를 호출할 때 타입 간 변환을 위해 반드시 `Number`와 `BigInt` 함수를 명시적으로 호출해야 합니다.</p>
      <emu-note>
        <p>ECMAScript의 최초 및 이후 판들은 일부 연산자에 대해 정밀도 손실이나 절단이 발생할 수 있는 암시적 숫자 변환을 제공해왔습니다. 이러한 기존 암시적 변환은 하위 호환성을 위해 유지되지만, BigInt에는 제공되지 않아 프로그래머의 오류 가능성을 최소화하고, 미래 판에서 일반화된 <em>값 타입</em> 옵션을 열어두기 위함입니다.</p>
      </emu-note>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>Number 타입</h1>
        <p><dfn variants="is a Number,is not a Number">Number 타입</dfn>은 정확히 18,437,736,874,454,810,627개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>)의 값을 가지며, 이는 IEEE 이진 부동소수점 산술 표준(IEEE 754-2019)의 binary64의 배정밀도 부동소수점 값을 나타냅니다. 단, IEEE 표준의 9,007,199,254,740,990개(즉, <emu-eqn>2<sup>53</sup> - 2</emu-eqn>)의 NaN 값들은 ECMAScript에서 하나의 특별한 *NaN* 값으로 표현됩니다. (*NaN* 값은 프로그램 표현식 `NaN`에 의해 생성됩니다.) 일부 구현에서는 외부 코드가 다양한 NaN 값을 구분할 수 있지만, 그러한 동작은 구현 정의입니다. ECMAScript 코드에서는 모든 *NaN* 값이 서로 구분되지 않습니다.</p>
        <emu-note>
          <p>Number 값이 ArrayBuffer(<emu-xref href="#sec-arraybuffer-objects"></emu-xref>) 또는 SharedArrayBuffer(<emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>)에 저장된 후 관찰될 수 있는 비트 패턴은 ECMAScript 구현이 내부적으로 사용하는 Number 값의 표현과 반드시 같지는 않습니다.</p>
        </emu-note>
        <p>또 다른 두 개의 특별한 값, *양의 무한대*와 *음의 무한대*가 있습니다. 간결하게 하기 위해, 이 값들은 설명상 각각 *+∞*<sub>𝔽</sub> 및 *-∞*<sub>𝔽</sub> 기호로도 불립니다. (이 두 무한대 Number 값은 프로그램 표현식 `+Infinity`(또는 단순히 `Infinity`) 및 `-Infinity`에 의해 생성됩니다.)</p>
        <p>나머지 18,437,736,874,454,810,624개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup></emu-eqn>)의 값들은 <dfn id="finite">유한</dfn> 숫자라고 불립니다. 이 중 절반은 양수이고, 절반은 음수입니다. 모든 유한 양의 Number 값에는 같은 크기를 가진 음수 값이 대응됩니다.</p>
        <p>양의 0과 음의 0이 모두 존재함을 유의하세요. 설명상 이 값들은 각각 *+0*<sub>𝔽</sub> 및 *-0*<sub>𝔽</sub> 기호로도 불립니다. (이 두 다른 0 Number 값은 프로그램 표현식 `+0`(또는 단순히 `0`) 및 `-0`에 의해 생성됩니다.)</p>
        <p>18,437,736,874,454,810,622개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>)의 유한 0이 아닌 값들은 두 종류로 나뉩니다:</p>
        <p>18,428,729,675,200,069,632개(즉, <emu-eqn>2<sup>64</sup> - 2<sup>54</sup></emu-eqn>)는 정규화된 형태로, 다음과 같습니다</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>여기서 _s_는 1 또는 -1, _m_은 2<sup>52</sup>(포함)에서 2<sup>53</sup>(제외) 사이의 정수, _e_는 -1074에서 971(포함) 사이의 정수입니다.</p>
        <p>나머지 9,007,199,254,740,990개(즉, <emu-eqn>2<sup>53</sup> - 2</emu-eqn>) 값은 비정규화된 형태로, 다음과 같습니다</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>여기서 _s_는 1 또는 -1, _m_은 0(제외)에서 2<sup>52</sup>(제외) 사이의 정수, _e_는 -1074입니다.</p>
        <p>크기가 2<sup>53</sup> 이하인 모든 양의 및 음의 정수가 Number 타입으로 표현 가능합니다. 정수 0은 Number 타입에서 *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub> 두 가지 표현을 가집니다.</p>
        <p>유한 숫자는 0이 아니며 위에 나타난 두 가지 방식 중 한 가지로 표현될 때 정수 _m_이 홀수이면 <em>홀수 시그니피컨드</em>를 가집니다. 그렇지 않으면 <em>짝수 시그니피컨드</em> 입니다.</p>
        <p>본 명세에서 “<dfn id="number-value-for" oldids="number-value">_x_의 Number 값</dfn>”이라는 구절은 _x_가 정확한 실수 수량(π와 같은 무리수일 수도 있음)을 나타내는 경우, 다음 방식으로 선택된 Number 값을 의미합니다. Number 타입의 모든 유한 값 집합을 고려하고, *-0*<sub>𝔽</sub>를 제거하며, Number 타입으로 표현할 수 없는 두 값을 추가합니다: 2<sup>1024</sup>(즉, <emu-eqn>+1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>) 및 <emu-eqn>-2<sup>1024</sup></emu-eqn>(즉, <emu-eqn>-1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>). 이 집합에서 _x_와 가장 가까운 값을 선택합니다. 두 값이 동일하게 가까우면 짝수 시그니피컨드를 가진 값을 선택합니다; 이때 두 추가 값 2<sup>1024</sup> 및 <emu-eqn>-2<sup>1024</sup></emu-eqn>은 짝수 시그니피컨드를 가진 것으로 간주합니다. 마지막으로, 선택된 값이 2<sup>1024</sup>이면 *+∞*<sub>𝔽</sub>로, <emu-eqn>-2<sup>1024</sup></emu-eqn>이면 *-∞*<sub>𝔽</sub>로, *+0*<sub>𝔽</sub>이면 _x_ &lt; 0일 때만 *-0*<sub>𝔽</sub>로 바꿉니다; 그 밖의 값은 그대로 사용합니다. 결과가 _x_의 Number 값입니다. (이 절차는 IEEE 754-2019의 roundTiesToEven 모드와 정확히 일치합니다.)</p>
        <p>+∞의 Number 값은 *+∞*<sub>𝔽</sub>, -∞의 Number 값은 *-∞*<sub>𝔽</sub>입니다.</p>
        <p>일부 ECMAScript 연산자는 <emu-eqn>-2<sup>31</sup></emu-eqn>에서 <emu-eqn>2<sup>31</sup> - 1</emu-eqn>까지와 같이 특정 범위의 정수만 처리합니다. 이러한 연산자는 Number 타입의 임의 값을 받아들이지만, 먼저 해당 값을 예상 범위의 정수 값으로 변환합니다. 숫자 변환 연산에 대한 설명은 <emu-xref href="#sec-type-conversion"></emu-xref>에서 확인하세요.</p>

        <emu-clause id="sec-numeric-types-number-unaryMinus" type="numeric method">
          <h1>
            Number::unaryMinus (
              _x_: a Number,
            ): a Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면, *NaN*을 반환한다.
            1. _x_의 부호를 반전시킨 Number를 반환한다. 즉, 같은 크기이지만 부호가 반대인 Number를 계산한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseNOT" type="numeric method">
          <h1>
            Number::bitwiseNOT (
              _x_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _oldValue_를 ! ToInt32(_x_)로 한다.
            1. _oldValue_의 비트 보수를 반환한다. 결과의 수학적 값은 32비트 2의 보수 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-exponentiate" type="numeric method" oldids="sec-applying-the-exp-operator">
          <h1>
            Number::exponentiate (
              _base_: a Number,
              _exponent_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_base_에 _exponent_ 제곱을 한 결과를 구현에 따라 근사한 값을 반환한다.</dd>
          </dl>
          <emu-alg>
            1. _exponent_가 *NaN*이면, *NaN*을 반환한다.
            1. _exponent_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면, *1*<sub>𝔽</sub>을 반환한다.
            1. _base_가 *NaN*이면, *NaN*을 반환한다.
            1. _base_가 *+∞*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면 *+∞*<sub>𝔽</sub> 반환; 그렇지 않으면 *+0*<sub>𝔽</sub> 반환.
            1. _base_가 *-∞*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면,
                1. _exponent_가 홀수 정수 Number이면 *-∞*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
              1. 그렇지 않으면,
                1. _exponent_가 홀수 정수 Number이면 *-0*<sub>𝔽</sub> 반환; 아니면 *+0*<sub>𝔽</sub> 반환.
            1. _base_가 *+0*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
            1. _base_가 *-0*<sub>𝔽</sub>이면,
              1. _exponent_ > *+0*<sub>𝔽</sub>이면,
                1. _exponent_가 홀수 정수 Number이면 *-0*<sub>𝔽</sub> 반환; 아니면 *+0*<sub>𝔽</sub> 반환.
              1. 그렇지 않으면,
                1. _exponent_가 홀수 정수 Number이면 *-∞*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
            1. 단언: _base_는 유한하며 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>가 아니다.
            1. _exponent_가 *+∞*<sub>𝔽</sub>이면,
              1. abs(ℝ(_base_)) > 1이면 *+∞*<sub>𝔽</sub> 반환.
              1. abs(ℝ(_base_)) = 1이면 *NaN* 반환.
              1. abs(ℝ(_base_)) &lt; 1이면 *+0*<sub>𝔽</sub> 반환.
            1. _exponent_가 *-∞*<sub>𝔽</sub>이면,
              1. abs(ℝ(_base_)) > 1이면 *+0*<sub>𝔽</sub> 반환.
              1. abs(ℝ(_base_)) = 1이면 *NaN* 반환.
              1. abs(ℝ(_base_)) &lt; 1이면 *+∞*<sub>𝔽</sub> 반환.
            1. 단언: _exponent_는 유한하며 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>가 아니다.
            1. _base_ &lt; *-0*<sub>𝔽</sub>이고 _exponent_가 정수 Number가 아니면 *NaN* 반환.
            1. ℝ(_base_)의 ℝ(_exponent_) 제곱을 구현에 따라 근사한 Number 값으로 반환.
          </emu-alg>
          <emu-note>
            <p>_base_가 *1*<sub>𝔽</sub> 또는 *-1*<sub>𝔽</sub>이고 _exponent_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>일 때, 혹은 _base_가 *1*<sub>𝔽</sub>이고 _exponent_가 *NaN*일 때, _base_ `**` _exponent_의 결과는 IEEE 754-2019와 다릅니다. ECMAScript 1판은 이 연산에 대해 *NaN* 결과를 명시했으나, 이후 IEEE 754 개정판은 *1*<sub>𝔽</sub>을 명시했습니다. 호환성을 위해 기존 ECMAScript 동작을 유지합니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-multiply" type="numeric method" oldids="sec-applying-the-mul-operator">
          <h1>
            Number::multiply (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>IEEE 754-2019 배정밀도 이진 산술 규칙에 따라 곱셈을 수행하며, _x_와 _y_의 곱을 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ 또는 _y_가 *NaN*이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면,
              1. _y_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _y_ > *+0*<sub>𝔽</sub>이면 _x_ 반환.
              1. -_x_ 반환.
            1. _y_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면,
              1. _x_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _x_ > *+0*<sub>𝔽</sub>이면 _y_ 반환.
              1. -_y_ 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이면,
              1. _y_가 *-0*<sub>𝔽</sub> 또는 _y_ &lt; *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환.
              1. 아니면 *-0*<sub>𝔽</sub> 반환.
            1. _y_가 *-0*<sub>𝔽</sub>이면,
              1. _x_ &lt; *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환.
              1. 아니면 *-0*<sub>𝔽</sub> 반환.
            1. 𝔽(ℝ(_x_) × ℝ(_y_)) 반환.
          </emu-alg>
          <emu-note>
            <p>유한 정밀 곱셈은 교환법칙은 성립하지만 항상 결합법칙이 성립하지는 않습니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-divide" type="numeric method" oldids="sec-applying-the-div-operator">
          <h1>
            Number::divide (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>IEEE 754-2019 배정밀도 이진 산술 규칙에 따라 나눗셈을 수행하며, _x_는 피제수, _y_는 제수로써 몫을 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ 또는 _y_가 *NaN*이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면,
              1. _y_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _y_가 *+0*<sub>𝔽</sub> 또는 _y_ > *+0*<sub>𝔽</sub>이면 _x_ 반환.
              1. -_x_ 반환.
            1. _y_가 *+∞*<sub>𝔽</sub>이면,
              1. _x_가 *+0*<sub>𝔽</sub> 또는 _x_ > *+0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub> 반환; 아니면 *-0*<sub>𝔽</sub> 반환.
            1. _y_가 *-∞*<sub>𝔽</sub>이면,
              1. _x_가 *+0*<sub>𝔽</sub> 또는 _x_ > *+0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub> 반환; 아니면 *+0*<sub>𝔽</sub> 반환.
            1. _x_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면,
              1. _y_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
              1. _y_ > *+0*<sub>𝔽</sub>이면 _x_ 반환.
              1. -_x_ 반환.
            1. _y_가 *+0*<sub>𝔽</sub>이면,
              1. _x_ > *+0*<sub>𝔽</sub>이면 *+∞*<sub>𝔽</sub> 반환; 아니면 *-∞*<sub>𝔽</sub> 반환.
            1. _y_가 *-0*<sub>𝔽</sub>이면,
              1. _x_ > *+0*<sub>𝔽</sub>이면 *-∞*<sub>𝔽</sub> 반환; 아니면 *+∞*<sub>𝔽</sub> 반환.
            1. 𝔽(ℝ(_x_) / ℝ(_y_)) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-remainder" type="numeric method" oldids="sec-applying-the-mod-operator">
          <h1>
            Number::remainder (
              _n_: a Number,
              _d_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>피제수 _n_과 제수 _d_의 암시적 나눗셈에서 나머지를 반환합니다.</dd>
          </dl>
          <emu-alg>
            1. _n_ 또는 _d_가 *NaN*이면 *NaN* 반환.
            1. _n_이 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _d_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 _n_ 반환.
            1. _d_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _n_이 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 _n_ 반환.
            1. 단언: _n_과 _d_는 유한하며 0이 아니다.
            1. _quotient_를 ℝ(_n_) / ℝ(_d_)로 한다.
            1. _q_를 truncate(_quotient_)로 한다.
            1. _r_를 ℝ(_n_) - (ℝ(_d_) × _q_)로 한다.
            1. _r_ = 0이고 _n_ &lt; *-0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub> 반환.
            1. 𝔽(_r_) 반환.
          </emu-alg>
          <emu-note>
            <p>C 및 C++에서 나머지 연산자는 정수 피연산자만 허용하지만, ECMAScript에서는 부동소수점 피연산자도 허용합니다.</p>
          </emu-note>
          <emu-note>부동소수점 나머지 연산의 결과는 IEEE 754-2019의 “remainder” 연산과 다릅니다. IEEE 754-2019 “remainder” 연산은 반올림 나눗셈에서 나머지를 계산하며, 일반적인 <emu-not-ref>정수</emu-not-ref> 나머지 연산자와는 유사하지 않습니다. ECMAScript는 부동소수점 연산에서 `%`가 Java의 <emu-not-ref>정수</emu-not-ref> 나머지 연산자와 유사하게 동작하도록 정의합니다; 이는 C 라이브러리 함수 fmod와 비교할 수 있습니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-add" type="numeric method" oldids="sec-applying-the-additive-operators-to-numbers">
          <h1>
            Number::add (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>IEEE 754-2019 배정밀도 이진 산술 규칙에 따라 덧셈을 수행하며, 두 인자의 합을 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ 또는 _y_가 *NaN*이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub>이고 _y_가 *-∞*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _x_가 *-∞*<sub>𝔽</sub>이고 _y_가 *+∞*<sub>𝔽</sub>이면 *NaN* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 _x_ 반환.
            1. _y_가 *+∞*<sub>𝔽</sub> 또는 *-∞*<sub>𝔽</sub>이면 _y_ 반환.
            1. 단언: _x_와 _y_는 모두 유한하다.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub> 반환.
            1. 𝔽(ℝ(_x_) + ℝ(_y_)) 반환.
          </emu-alg>
          <emu-note>
            <p>유한 정밀 덧셈은 교환법칙은 성립하지만 항상 결합법칙이 성립하지는 않습니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-subtract" type="numeric method">
          <h1>
            Number::subtract (
              _x_: a Number,
              _y_: a Number,
            ): a Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>뺄셈을 수행하며, _x_는 피감수, _y_는 감수로써 차를 생성합니다.</dd>
          </dl>
          <emu-alg>
            1. Number::add(_x_, Number::unaryMinus(_y_))를 반환한다.
          </emu-alg>
          <emu-note>
            <p>항상 `x - y`의 결과는 `x + (-y)`의 결과와 같습니다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-leftShift" type="numeric method">
          <h1>
            Number::leftShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToInt32(_x_)로 한다.
            1. _rNum_을 ! ToUint32(_y_)로 한다.
            1. _shiftCount_를 ℝ(_rNum_) mod 32로 한다.
            1. _lNum_을 _shiftCount_ 비트만큼 왼쪽으로 시프트한 결과를 반환한다. 결과의 수학적 값은 32비트 2의 보수 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-signedRightShift" type="numeric method">
          <h1>
            Number::signedRightShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToInt32(_x_)로 한다.
            1. _rNum_을 ! ToUint32(_y_)로 한다.
            1. _shiftCount_를 ℝ(_rNum_) mod 32로 한다.
            1. _lNum_을 _shiftCount_ 비트만큼 부호 확장 우측 시프트한 결과를 반환한다. 최상위 비트가 전파된다. 결과의 수학적 값은 32비트 2의 보수 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-unsignedRightShift" type="numeric method">
          <h1>
            Number::unsignedRightShift (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToUint32(_x_)로 한다.
            1. _rNum_을 ! ToUint32(_y_)로 한다.
            1. _shiftCount_를 ℝ(_rNum_) mod 32로 한다.
            1. _lNum_을 _shiftCount_ 비트만큼 0으로 채우며 우측 시프트한 결과를 반환한다. 비워진 비트는 0으로 채워진다. 결과의 수학적 값은 32비트 부호 없는 비트 문자열로 정확히 표현된다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-lessThan" type="numeric method">
          <h1>
            Number::lessThan (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean or *undefined*
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면 *undefined* 반환.
            1. _y_가 *NaN*이면 *undefined* 반환.
            1. _x_가 _y_와 같으면 *false* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *+∞*<sub>𝔽</sub>이면 *false* 반환.
            1. _y_가 *+∞*<sub>𝔽</sub>이면 *true* 반환.
            1. _y_가 *-∞*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *-∞*<sub>𝔽</sub>이면 *true* 반환.
            1. 단언: _x_와 _y_는 유한하다.
            1. ℝ(_x_) &lt; ℝ(_y_)이면 *true* 반환; 아니면 *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-equal" type="numeric method">
          <h1>
            Number::equal (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면 *false* 반환.
            1. _y_가 *NaN*이면 *false* 반환.
            1. _x_가 _y_와 같으면 *true* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *true* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValue" type="numeric method">
          <h1>
            Number::sameValue (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_와 _y_가 모두 *NaN*이면 *true* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *false* 반환.
            1. _x_가 _y_와 같으면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValueZero" type="numeric method">
          <h1>
            Number::sameValueZero (
              _x_: a Number,
              _y_: a Number,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_와 _y_가 모두 *NaN*이면 *true* 반환.
            1. _x_가 *+0*<sub>𝔽</sub>이고 _y_가 *-0*<sub>𝔽</sub>이면 *true* 반환.
            1. _x_가 *-0*<sub>𝔽</sub>이고 _y_가 *+0*<sub>𝔽</sub>이면 *true* 반환.
            1. _x_가 _y_와 같으면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numberbitwiseop" type="abstract operation">
          <h1>
            NumberBitwiseOp (
              _op_: `&amp;`, `^`, 또는 `|`,
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _lNum_을 ! ToInt32(_x_)로 한다.
            1. _rNum_을 ! ToInt32(_y_)로 한다.
            1. _lBits_를 ℝ(_lNum_)을 표현하는 32비트 2의 보수 비트 문자열로 한다.
            1. _rBits_를 ℝ(_rNum_)을 표현하는 32비트 2의 보수 비트 문자열로 한다.
            1. _op_이 `&amp;`이면,
              1. _result_를 _lBits_와 _rBits_에 대해 비트 AND 연산한 결과로 한다.
            1. 아니고 _op_이 `^`이면,
              1. _result_를 _lBits_와 _rBits_에 대해 비트 XOR 연산한 결과로 한다.
            1. 그렇지 않으면,
              1. 단언: _op_은 `|`이다.
              1. _result_를 _lBits_와 _rBits_에 대해 비트 OR 연산한 결과로 한다.
            1. _result_가 표현하는 32비트 2의 보수 비트 문자열의 정수에 대한 Number 값을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseAND" type="numeric method">
          <h1>
            Number::bitwiseAND (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`&amp;`, _x_, _y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseXOR" type="numeric method">
          <h1>
            Number::bitwiseXOR (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`^`, _x_, _y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseOR" type="numeric method">
          <h1>
            Number::bitwiseOR (
              _x_: a Number,
              _y_: a Number,
            ): an integral Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. NumberBitwiseOp(`|`, _x_, _y_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-tostring" type="numeric method" oldids="sec-tostring-applied-to-the-number-type">
          <h1>
            Number::toString (
              _x_: a Number,
              _radix_: an integer in the inclusive interval from 2 to 36,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_를 진법 _radix_를 사용한 위치 기수 체계로 문자열로 표현합니다. 진법 _r_을 사용할 때 사용되는 숫자들은 *"0123456789abcdefghijklmnopqrstuvwxyz"*의 앞에서 _r_개 코드 유닛을 차례로 사용합니다. 크기가 *1*<sub>𝔽</sub> 이상인 숫자의 표현에는 결코 앞에 0이 포함되지 않습니다.</dd>
          </dl>
          <emu-alg>
            1. _x_가 *NaN*이면 *"NaN"* 반환.
            1. _x_가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *"0"* 반환.
            1. _x_ &lt; *-0*<sub>𝔽</sub>이면 *"-"*와 Number::toString(-_x_, _radix_)를 연결한 문자열 반환.
            1. _x_가 *+∞*<sub>𝔽</sub>이면 *"Infinity"* 반환.
            1. [id="step-number-tostring-intermediate-values"] _n_, _k_, _s_를 다음 조건을 만족하는 정수로 한다: _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>)가 _x_이고, _k_가 가능한 한 작다. _k_는 _s_의 _radix_ 표현에서 자릿수이고, _s_는 _radix_로 나누어떨어지지 않으며, 최소 자리수가 반드시 결정되는 것은 아니다.
            1. _radix_ ≠ 10이거나 _n_이 -5에서 21 사이이면,
              1. _n_ ≥ _k_이면,
                1. 다음을 연결한 문자열 반환:
                  * _s_의 _radix_ 표현에서 _k_개의 자릿수
                  * _n_ - _k_번 반복된 코드 유닛 0x0030(DIGIT ZERO)
              1. _n_ > 0이면,
                1. 다음을 연결한 문자열 반환:
                  * _s_의 _radix_ 표현에서 가장 높은 _n_개의 자릿수
                  * 코드 유닛 0x002E(FULL STOP)
                  * 남은 _k_ - _n_개의 자릿수
              1. 그렇지 않으면,
                1. 단언: _n_ ≤ 0이다.
                1. 다음을 연결한 문자열 반환:
                  * 코드 유닛 0x0030(DIGIT ZERO)
                  * 코드 유닛 0x002E(FULL STOP)
                  * -_n_번 반복된 코드 유닛 0x0030(DIGIT ZERO)
                  * _s_의 _radix_ 표현에서 _k_개의 자릿수
            1. 참고: 이 경우 입력은 과학적 E 표기법으로 표현됩니다(예: `1.2e+3`).
            1. 단언: _radix_는 10이다.
            1. _n_ &lt; 0이면,
              1. _exponentSign_을 코드 유닛 0x002D(HYPHEN-MINUS)로 한다.
            1. 그렇지 않으면,
              1. _exponentSign_을 코드 유닛 0x002B(PLUS SIGN)로 한다.
            1. _k_ = 1이면,
              1. 다음을 연결한 문자열 반환:
                * _s_의 한 자릿수 코드 유닛
                * 코드 유닛 0x0065(LATIN SMALL LETTER E)
                * _exponentSign_
                * abs(_n_ - 1)의 10진수 표현 코드 유닛
            1. 다음을 연결한 문자열 반환:
              * _s_의 10진수 표현에서 가장 높은 자릿수 코드 유닛
              * 코드 유닛 0x002E(FULL STOP)
              * 남은 _k_ - 1개의 10진수 표현 코드 유닛
              * 코드 유닛 0x0065(LATIN SMALL LETTER E)
              * _exponentSign_
              * abs(_n_ - 1)의 10진수 표현 코드 유닛
          </emu-alg>
          <emu-note>
            <p>다음 관찰은 구현 지침으로 유용할 수 있으나, 본 표준의 규범적 요구 사항은 아닙니다:</p>
            <ul>
              <li>
                x가 *-0*<sub>𝔽</sub>을 제외한 모든 Number 값이면 ToNumber(ToString(x))는 x이다.
              </li>
              <li>
                s의 최소 자리수는 항상 명시된 요구 조건에 따라 고유하게 결정되는 것은 아니다(위 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 참조).
              </li>
            </ul>
          </emu-note>
          <emu-note>
            <p>더 정확한 변환을 제공하는 구현의 경우, 아래 대안 버전의 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 단계를 구현 지침으로 사용하는 것을 권장합니다:</p>
            <emu-alg replaces-step="step-number-tostring-intermediate-values">
              1. _n_, _k_, _s_를 다음 조건을 만족하는 정수로 한다: _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>)가 _x_이고, _k_가 가능한 한 작다. 여러 가능성이 있으면, ℝ(_x_)에 근접한 값을 가지는 _s_를 선택한다. 두 가지 가능성이 있으면 짝수 값을 선택한다. _k_는 _s_의 _radix_ 표현에서 자릿수이며, _s_는 _radix_로 나누어떨어지지 않는다.
            </emu-alg>
          </emu-note>
          <emu-note>
            <p>ECMAScript 구현자는 David M. Gay가 작성한 부동소수점 숫자의 이진-10진 변환 관련 논문과 코드를 참고할 수 있습니다:</p>
            <p>
              Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). 1990년 11월 30일.<br>
              <a href="https://ampl.com/_archive/first-website/REFS/rounding.pdf">https://ampl.com/_archive/first-website/REFS/rounding.pdf</a>. 관련 코드:<br>
              <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> 및<br>
              <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a> 그리고 여러 `netlib` 미러 사이트에서 확인 가능.
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>BigInt 타입</h1>
        <p><dfn variants="is a BigInt,is not a BigInt">BigInt 타입</dfn>은 정수 값을 나타냅니다. 값의 크기는 제한이 없으며 특정 비트 폭에 제한되지 않습니다. 별도 언급이 없는 한, 연산들은 일반적으로 정확한 수학적 결과를 반환하도록 설계되었습니다. 이항 연산에서 BigInt는 2의 보수 이진 문자열처럼 동작하며, 음수는 비트가 왼쪽으로 무한히 설정된 것으로 취급됩니다.</p>

        <emu-clause id="sec-numeric-types-bigint-unaryMinus" type="numeric method">
          <h1>
            BigInt::unaryMinus (
              _x_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = *0*<sub>ℤ</sub>이면, *0*<sub>ℤ</sub>를 반환한다.
            1. -_x_를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseNOT" type="numeric method">
          <h1>
            BigInt::bitwiseNOT (
              _x_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_의 1의 보수를 반환합니다.</dd>
          </dl>
          <emu-alg>
            1. -_x_ - *1*<sub>ℤ</sub>를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-exponentiate" type="numeric method">
          <h1>
            BigInt::exponentiate (
              _base_: a BigInt,
              _exponent_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _exponent_ &lt; *0*<sub>ℤ</sub>이면, *RangeError* 예외를 throw한다.
            1. _base_ = *0*<sub>ℤ</sub>이고 _exponent_ = *0*<sub>ℤ</sub>이면, *1*<sub>ℤ</sub>를 반환한다.
            1. _base_의 _exponent_ 제곱을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-multiply" type="numeric method">
          <h1>
            BigInt::multiply (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ × _y_를 반환한다.
          </emu-alg>
          <emu-note>결과가 입력보다 훨씬 큰 비트 폭을 갖더라도, 정확한 수학적 결과가 반환됩니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-divide" type="numeric method">
          <h1>
            BigInt::divide (
              _x_: a BigInt,
              _y_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _y_ = *0*<sub>ℤ</sub>이면, *RangeError* 예외를 throw한다.
            1. _quotient_를 ℝ(_x_) / ℝ(_y_)로 한다.
            1. ℤ(truncate(_quotient_))를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-remainder" type="numeric method">
          <h1>
            BigInt::remainder (
              _n_: a BigInt,
              _d_: a BigInt,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _d_ = *0*<sub>ℤ</sub>이면, *RangeError* 예외를 throw한다.
            1. _n_ = *0*<sub>ℤ</sub>이면, *0*<sub>ℤ</sub>를 반환한다.
            1. _quotient_를 ℝ(_n_) / ℝ(_d_)로 한다.
            1. _q_를 ℤ(truncate(_quotient_))로 한다.
            1. _n_ - (_d_ × _q_)를 반환한다.
          </emu-alg>
          <emu-note>결과의 부호는 피제수의 부호와 같습니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-add" type="numeric method">
          <h1>
            BigInt::add (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ + _y_를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-subtract" type="numeric method">
          <h1>
            BigInt::subtract (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ - _y_를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-leftShift" type="numeric method">
          <h1>
            BigInt::leftShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _y_ &lt; *0*<sub>ℤ</sub>이면,
              1. ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>))를 반환한다.
            1. _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>를 반환한다.
          </emu-alg>
          <emu-note>이 의미는 BigInt를 무한 길이 2의 보수 이진 숫자열로 취급하여 비트 시프트와 동등해야 합니다.</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-signedRightShift" type="numeric method">
          <h1>
            BigInt::signedRightShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigInt::leftShift(_x_, -_y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-unsignedRightShift" type="numeric method">
          <h1>
            BigInt::unsignedRightShift (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. *TypeError* 예외를 throw한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-lessThan" type="numeric method">
          <h1>
            BigInt::lessThan (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ℝ(_x_) &lt; ℝ(_y_)이면 *true* 반환; 아니면 *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-equal" type="numeric method" oldids="sec-numeric-types-bigint-sameValue,sec-numeric-types-bigint-sameValueZero">
          <h1>
            BigInt::equal (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. ℝ(_x_) = ℝ(_y_)이면 *true* 반환; 아니면 *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryand" type="abstract operation">
          <h1>
            BinaryAnd (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1이고 _y_ = 1이면 1을 반환한다.
            1. 아니면 0을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryor" type="abstract operation">
          <h1>
            BinaryOr (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1이거나 _y_ = 1이면 1을 반환한다.
            1. 아니면 0을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryxor" type="abstract operation">
          <h1>
            BinaryXor (
              _x_: 0 or 1,
              _y_: 0 or 1,
            ): 0 or 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_ = 1이고 _y_ = 0이면 1을 반환한다.
            1. 아니면 _x_ = 0이고 _y_ = 1이면 1을 반환한다.
            1. 아니면 0을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-bigintbitwiseop" type="abstract operation">
          <h1>
            BigIntBitwiseOp (
              _op_: `&amp;`, `^`, or `|`,
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _x_를 ℝ(_x_)로 설정한다.
            1. _y_를 ℝ(_y_)로 설정한다.
            1. _result_를 0으로 설정한다.
            1. _shift_를 0으로 설정한다.
            1. (_x_ = 0 또는 _x_ = -1)이고 (_y_ = 0 또는 _y_ = -1)일 때까지 반복한다.
              1. _xDigit_를 _x_ mod 2로 한다.
              1. _yDigit_를 _y_ mod 2로 한다.
              1. _op_이 `&amp;`이면,
                1. _result_를 _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_)로 설정한다.
              1. 아니고 _op_이 `|`이면,
                1. _result_를 _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_)로 설정한다.
              1. 그렇지 않으면,
                1. 단언: _op_은 `^`이다.
                1. _result_를 _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_)로 설정한다.
              1. _shift_를 _shift_ + 1로 설정한다.
              1. _x_를 (_x_ - _xDigit_) / 2로 설정한다.
              1. _y_를 (_y_ - _yDigit_) / 2로 설정한다.
            1. _op_이 `&amp;`이면,
              1. _tmp_를 BinaryAnd(_x_ mod 2, _y_ mod 2)로 한다.
            1. 아니고 _op_이 `|`이면,
              1. _tmp_를 BinaryOr(_x_ mod 2, _y_ mod 2)로 한다.
            1. 그렇지 않으면,
              1. 단언: _op_은 `^`이다.
              1. _tmp_를 BinaryXor(_x_ mod 2, _y_ mod 2)로 한다.
            1. _tmp_ ≠ 0이면,
              1. _result_를 _result_ - 2<sup>_shift_</sup>로 설정한다.
              1. 참고: 이는 부호 확장입니다.
            1. _result_에 대한 BigInt 값을 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseAND" type="numeric method">
          <h1>
            BigInt::bitwiseAND (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`&amp;`, _x_, _y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseXOR" type="numeric method">
          <h1>
            BigInt::bitwiseXOR (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`^`, _x_, _y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseOR" type="numeric method">
          <h1>
            BigInt::bitwiseOR (
              _x_: a BigInt,
              _y_: a BigInt,
            ): a BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. BigIntBitwiseOp(`|`, _x_, _y_)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-tostring" type="numeric method">
          <h1>
            BigInt::toString (
              _x_: a BigInt,
              _radix_: an integer in the inclusive interval from 2 to 36,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_x_를 진법 _radix_를 사용한 위치 기수 체계로 문자열로 표현합니다. 진법 _r_을 사용할 때 사용되는 숫자들은 *"0123456789abcdefghijklmnopqrstuvwxyz"*의 앞에서 _r_개 코드 유닛을 차례로 사용합니다. *0*<sub>ℤ</sub>을 제외한 BigInt의 표현에는 결코 앞에 0이 포함되지 않습니다.</dd>
          </dl>
          <emu-alg>
            1. _x_ &lt; *0*<sub>ℤ</sub>이면 *"-"*와 BigInt::toString(-_x_, _radix_)를 연결한 문자열을 반환한다.
            1. _x_를 _radix_로 표현한 문자열 값을 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-type">
      <h1>Object 타입</h1>
      <p><dfn variants="is an Object,is not an Object">Object 타입</dfn>의 각 인스턴스(간단히 “객체”라고도 함)는 프로퍼티들의 집합을 나타냅니다. 각 프로퍼티는 데이터 프로퍼티 또는 접근자 프로퍼티입니다:</p>
      <ul>
        <li>
          <dfn variants="data properties">데이터 프로퍼티</dfn>는 키 값과 ECMAScript 언어 값, 그리고 불리언 속성 집합을 연관시킵니다.
        </li>
        <li>
          <dfn variants="accessor properties">접근자 프로퍼티</dfn>는 키 값과 하나 또는 두 개의 접근자 함수, 그리고 불리언 속성 집합을 연관시킵니다. 접근자 함수는 해당 프로퍼티에 연관된 ECMAScript 언어 값을 저장하거나 가져오는 데 사용됩니다.
        </li>
      </ul>
      <p>객체의 프로퍼티는 프로퍼티 키를 사용하여 고유하게 식별됩니다. <dfn id="property-key" variants="property keys" oldids="sec-ispropertykey">프로퍼티 키</dfn>는 문자열 또는 심볼입니다. 모든 문자열과 심볼(빈 문자열 포함)은 프로퍼티 키로 유효합니다. <dfn id="property-name">프로퍼티 이름</dfn>은 문자열인 프로퍼티 키입니다.</p>
      <p><dfn id="integer-index" variants="integer indices,integer-indexed">정수 인덱스</dfn>는 CanonicalNumericIndexString(_n_)이 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>53</sup> - 1)까지(포함)의 정수 Number를 반환하는 프로퍼티 이름 _n_입니다. <dfn id="array-index" variants="array indices">배열 인덱스</dfn>는 CanonicalNumericIndexString(_n_)이 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>32</sup> - 2)까지(포함)의 정수 Number를 반환하는 정수 인덱스 _n_입니다.</p>
      <emu-note>
        <p>모든 음수가 아닌 안전한 정수는 해당하는 정수 인덱스를 가집니다. 32비트 부호 없는 정수 중 <emu-eqn>2<sup>32</sup> - 1</emu-eqn>을 제외한 모든 값은 해당하는 배열 인덱스를 가집니다. *"-0"*은 정수 인덱스도 배열 인덱스도 아닙니다.</p>
      </emu-note>
      <p>프로퍼티 키는 프로퍼티와 그 값을 접근하는 데 사용됩니다. 프로퍼티 접근 방식에는 값을 가져오는 <em>get</em>과 값을 할당하는 <em>set</em> 두 가지가 있습니다. get과 set 접근으로 접근 가능한 프로퍼티에는 객체의 직접적인 일부인 <em>자체 프로퍼티</em>와 프로퍼티 상속 관계를 통해 다른 연관 객체로부터 제공받는 <em>상속 프로퍼티</em>가 포함됩니다. 상속 프로퍼티는 연관 객체의 자체 프로퍼티 또는 상속 프로퍼티일 수 있습니다. 각 객체의 자체 프로퍼티는 해당 객체의 다른 자체 프로퍼티의 키 값과 구별되는 키 값을 가져야 합니다.</p>
      <p>모든 객체는 논리적으로 프로퍼티의 집합이지만, 프로퍼티 접근과 조작의 의미론이 다른 여러 형태의 객체가 존재합니다. 여러 형태의 객체 정의는 <emu-xref href="#sec-object-internal-methods-and-internal-slots"></emu-xref>를 참고하세요.</p>
      <p>또한 일부 객체는 호출 가능하며, 이러한 객체를 함수 또는 함수 객체라고 하며 아래에서 추가로 설명합니다. ECMAScript의 모든 함수는 Object 타입의 멤버입니다.</p>

      <emu-clause id="sec-property-attributes">
        <h1>프로퍼티 속성</h1>
        <p>속성은 <emu-xref href="#table-object-property-attributes"></emu-xref>에 설명된 Object 프로퍼티의 상태를 정의하고 설명하는 데 사용됩니다. 명시적으로 지정되지 않는 한, 각 속성의 초기값은 기본값입니다.</p>
        <emu-table id="table-object-property-attributes" caption="Object 프로퍼티의 속성" oldids="table-2,table-3,table-4,table-data-property-attributes,table-accessor-property-attributes,table-default-attribute-values">
          <table>
            <thead>
              <tr>
                <th>속성 이름</th>
                <th>해당되는 프로퍼티 종류</th>
                <th>값 도메인</th>
                <th>기본값</th>
                <th>설명</th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                데이터 프로퍼티
              </td>
              <td>
                ECMAScript 언어 값
              </td>
              <td>
                *undefined*
              </td>
              <td>
                get 접근으로 프로퍼티에서 가져오는 값입니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                데이터 프로퍼티
              </td>
              <td>
                불리언
              </td>
              <td>
                *false*
              </td>
              <td>
                *false*인 경우, ECMAScript 코드가 [[Set]]을 사용하여 [[Value]] 속성을 변경하려고 해도 성공하지 않습니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                접근자 프로퍼티
              </td>
              <td>
                Object 또는 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                값이 Object인 경우, 반드시 함수 객체여야 합니다. get 접근 시마다 해당 함수의 [[Call]] 내부 메소드(<emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>)가 빈 인자 리스트로 호출되어 프로퍼티 값을 가져옵니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                접근자 프로퍼티
              </td>
              <td>
                Object 또는 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                값이 Object인 경우, 반드시 함수 객체여야 합니다. set 접근 시마다 해당 함수의 [[Call]] 내부 메소드(<emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>)가 할당 값을 유일한 인자로 포함하는 인자 리스트로 호출됩니다. 프로퍼티의 [[Set]] 내부 메소드 효과는, 반드시 그런 것은 아니지만, 이후 [[Get]] 내부 메소드 호출에서 반환되는 값에 영향을 줄 수 있습니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                데이터 프로퍼티 또는 접근자 프로퍼티
              </td>
              <td>
                불리언
              </td>
              <td>
                *false*
              </td>
              <td>
                *true*인 경우, for-in 열거(see <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>)에 의해 프로퍼티가 열거됩니다. 그렇지 않으면 비열거 프로퍼티라고 합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                데이터 프로퍼티 또는 접근자 프로퍼티
              </td>
              <td>
                불리언
              </td>
              <td>
                *false*
              </td>
              <td>
                *false*인 경우, 프로퍼티 삭제, 데이터 프로퍼티에서 접근자 프로퍼티로의 변경 또는 그 반대, 속성 변경(기존 [[Value]] 교체 또는 [[Writable]]을 *false*로 설정하는 경우 제외)은 모두 실패합니다.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>Object 내부 메소드와 내부 슬롯</h1>
        <p>ECMAScript에서 객체의 실제 의미론은 <em>내부 메소드</em>라 불리는 알고리즘을 통해 지정됩니다. ECMAScript 엔진의 각 객체는 런타임 행동을 정의하는 내부 메소드 집합과 연결되어 있습니다. 이러한 내부 메소드는 ECMAScript 언어의 일부가 아닙니다. 이 명세에서는 순전히 설명 목적으로 정의됩니다. 하지만 ECMAScript 구현 내의 각 객체는 해당 객체에 연결된 내부 메소드로 지정된 대로 동작해야 합니다. 이를 구현하는 정확한 방법은 구현에 따라 결정됩니다.</p>
        <p>내부 메소드 이름은 다형적입니다. 즉, 서로 다른 객체 값이 동일한 내부 메소드 이름이 호출될 때 서로 다른 알고리즘을 실행할 수 있습니다. 내부 메소드가 호출되는 실제 객체는 호출의 “대상”입니다. 런타임에 알고리즘 구현이 객체가 지원하지 않는 내부 메소드를 사용하려 하면 *TypeError* 예외가 발생합니다.</p>
        <p>내부 슬롯은 객체, 심볼, 또는 Private Name에 연결된 내부 상태로, 여러 ECMAScript 명세 알고리즘에서 사용됩니다. 내부 슬롯은 객체 프로퍼티가 아니며 상속되지 않습니다. 내부 슬롯 명세에 따라 해당 상태는 ECMAScript 언어의 모든 타입 값이나 특정 ECMAScript 명세 타입 값일 수 있습니다. 명시적으로 달리 지정되지 않는 한, 내부 슬롯은 객체, 심볼, 또는 Private Name 생성 과정에서 할당되며 동적으로 추가할 수 없습니다. 별도 지정이 없는 한, 내부 슬롯의 초기값은 *undefined*입니다. 이 명세의 여러 알고리즘은 내부 슬롯을 가진 값을 생성합니다. 하지만 ECMAScript 언어는 내부 슬롯을 직접 조작할 방법을 제공하지 않습니다.</p>
        <p>모든 객체는 [[PrivateElements]]라는 내부 슬롯을 가지며, 이는 PrivateElements의 리스트입니다. 이 리스트는 객체의 private 필드, 메소드, 접근자의 값을 나타냅니다. 초기에는 빈 리스트입니다.</p>
        <p>내부 메소드와 내부 슬롯은 이 명세에서 [[ ]]로 둘러싼 이름으로 식별됩니다.</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref>는 ECMAScript 코드로 생성하거나 조작하는 모든 객체에 적용되는 <em>필수 내부 메소드</em>를 요약합니다. 모든 객체는 모든 필수 내부 메소드에 대한 알고리즘을 가져야 합니다. 하지만 모든 객체가 반드시 동일한 알고리즘을 사용하는 것은 아닙니다.</p>
        <p><dfn id="ordinary-object" variants="ordinary objects">일반 객체</dfn>는 다음 기준을 모두 만족하는 객체입니다:</p>
        <ul>
          <li>
            <emu-xref href="#table-essential-internal-methods"></emu-xref>에 나열된 내부 메소드에 대해 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>에 정의된 메소드를 사용합니다.
          </li>
          <li>
            객체에 [[Call]] 내부 메소드가 있으면, <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 또는 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref>에 정의된 것 중 하나를 사용합니다.
          </li>
          <li>
            객체에 [[Construct]] 내부 메소드가 있으면, <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 또는 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref>에 정의된 것 중 하나를 사용합니다.
          </li>
        </ul>
        <p><dfn id="exotic-object" variants="exotic objects">이국 객체</dfn>는 일반 객체가 아닌 객체입니다.</p>
        <p>이 명세는 내부 메소드에 따라 여러 종류의 이국 객체를 인식합니다. 특정 종류의 이국 객체(Array 이국 객체, 바운드 함수 이국 객체 등)와 행동적으로 동등하지만 해당 종류에 대해 명세된 내부 메소드 집합이 동일하지 않은 객체는 해당 종류의 이국 객체로 인식되지 않습니다.</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref> 및 유사한 표의 “서명(Signature)” 열은 각 내부 메소드의 호출 패턴을 설명합니다. 호출 패턴에는 항상 괄호로 둘러싼 설명적 매개변수 이름 목록이 포함됩니다. 매개변수 이름이 ECMAScript 타입 이름과 같다면 해당 타입의 값이어야 함을 의미합니다. 내부 메소드가 명시적으로 값을 반환하면, 매개변수 목록 뒤에 “→”와 반환 타입 이름이 따라옵니다. 서명에서 사용된 타입 이름은 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref>에서 정의된 타입에, 아래 추가 이름이 보강된 것입니다. “<em>any</em>”는 값이 ECMAScript 언어 타입 중 아무거나 될 수 있음을 의미합니다.</p>
        <p>내부 메소드는 매개변수 외에도 항상 해당 메소드 호출의 대상 객체에 접근할 수 있습니다.</p>
        <p>내부 메소드는 암시적으로 Completion Record를 반환하며, 반환 타입에 표시된 값을 감싼 정상 완료 또는 throw 완료입니다.</p>
        <emu-table id="table-essential-internal-methods" caption="필수 내부 메소드" oldids="table-5">
          <table>
            <thead>
              <tr>
                <th>
                  내부 메소드
                </th>
                <th>
                  서명(Signature)
                </th>
                <th>
                  설명
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[GetPrototypeOf]]
              </td>
              <td>
                ( ) <b>→</b> Object | Null
              </td>
              <td>
                이 객체의 상속 프로퍼티를 제공하는 객체를 결정합니다. *null* 값이면 상속 프로퍼티가 없음을 의미합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[SetPrototypeOf]]
              </td>
              <td>
                (Object | Null) <b>→</b> Boolean
              </td>
              <td>
                이 객체를 상속 프로퍼티를 제공하는 다른 객체와 연결합니다. *null*을 전달하면 상속 프로퍼티가 없음을 의미합니다. 연산이 성공적으로 완료되면 *true*, 실패하면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[IsExtensible]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                이 객체에 추가 프로퍼티를 추가할 수 있는지 결정합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[PreventExtensions]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                객체에 새 프로퍼티를 추가할 수 있는지 제어합니다. 연산이 성공하면 *true*, 실패하면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[GetOwnProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Undefined | Property Descriptor
              </td>
              <td>
                이 객체의 키가 _propertyKey_인 자체 프로퍼티에 대한 프로퍼티 설명자를 반환하거나, 해당 프로퍼티가 없으면 *undefined*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[DefineOwnProperty]]
              </td>
              <td>
                (_propertyKey_, _PropertyDescriptor_) <b>→</b> Boolean
              </td>
              <td>
                키가 _propertyKey_인 자체 프로퍼티를 생성하거나 상태를 _PropertyDescriptor_로 변경합니다. 프로퍼티가 성공적으로 생성/업데이트되면 *true*, 생성/업데이트할 수 없으면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[HasProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                이 객체에 _propertyKey_인 자체 또는 상속 프로퍼티가 이미 있는지 불리언 값으로 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                (_propertyKey_, _Receiver_) <b>→</b> <em>any</em>
              </td>
              <td>
                이 객체에서 키가 _propertyKey_인 프로퍼티의 값을 반환합니다. 프로퍼티 값을 가져오려면 ECMAScript 코드 실행이 필요할 수 있으며, 그 경우 _Receiver_가 코드 평가 시 *this* 값으로 사용됩니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                (_propertyKey_, _value_, _Receiver_) <b>→</b> Boolean
              </td>
              <td>
                키가 _propertyKey_인 프로퍼티 값을 _value_로 설정합니다. ECMAScript 코드 실행이 필요하면, _Receiver_가 *this* 값으로 사용됩니다. 값이 설정되면 *true*, 설정할 수 없으면 *false*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Delete]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                키가 _propertyKey_인 자체 프로퍼티를 객체에서 제거합니다. 프로퍼티가 삭제되지 않고 여전히 존재하면 *false*, 삭제되었거나 존재하지 않으면 *true*를 반환합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[OwnPropertyKeys]]
              </td>
              <td>
                ( ) <b>→</b> 프로퍼티 키 리스트
              </td>
              <td>
                객체에 대한 모든 자체 프로퍼티 키를 요소로 하는 리스트를 반환합니다.
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>는 함수로 호출 가능한 객체가 지원하는 추가 필수 내부 메소드를 요약합니다. <dfn id="function-object" variants="function objects">함수 객체</dfn>란 [[Call]] 내부 메소드를 지원하는 객체입니다. <dfn id="constructor" variants="constructors">생성자</dfn>란 [[Construct]] 내부 메소드를 지원하는 객체입니다. [[Construct]]를 지원하는 모든 객체는 [[Call]]도 지원해야 하며, 즉 생성자는 항상 함수 객체입니다. 따라서 생성자는 <em>생성자 함수</em> 또는 <em>생성자 함수 객체</em>라고도 부를 수 있습니다.</p>
        <emu-table id="table-additional-essential-internal-methods-of-function-objects" caption="함수 객체의 추가 필수 내부 메소드" oldids="table-6">
          <table>
            <thead>
              <tr>
                <th>
                  내부 메소드
                </th>
                <th>
                  서명(Signature)
                </th>
                <th>
                  설명
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Call]]
              </td>
              <td>
                (<em>any</em>, <em>any</em>의 리스트) <b>→</b> <em>any</em>
              </td>
              <td>
                이 객체와 연관된 코드를 실행합니다. 함수 호출 표현식으로 호출됩니다. 내부 메소드의 인자는 *this* 값과 함수 호출 표현식에서 전달된 인자를 요소로 하는 리스트입니다. 이 내부 메소드를 구현한 객체는 <em>호출 가능</em>합니다.
              </td>
            </tr>
            <tr>
              <td>
                [[Construct]]
              </td>
              <td>
                (<em>any</em>의 리스트, Object) <b>→</b> Object
              </td>
              <td>
                객체를 생성합니다. `new` 연산자나 `super` 호출로 호출됩니다. 내부 메소드의 첫 번째 인자는 생성자 호출 또는 `super` 호출의 인자 리스트이고, 두 번째 인자는 `new` 연산자가 최초로 적용된 객체입니다. 이 내부 메소드를 구현한 객체는 <em>생성자</em>입니다. 함수 객체가 반드시 생성자인 것은 아니며, 생성자가 아닌 함수 객체는 [[Construct]] 내부 메소드가 없습니다.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>일반 객체 및 표준 이국 객체의 필수 내부 메소드 의미론은 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>에서 지정됩니다. 구현에서 이국 객체의 내부 메소드 사용이 지원되지 않는 경우, 해당 사용 시 *TypeError* 예외를 throw해야 합니다.</p>
      </emu-clause>

      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1>필수 내부 메소드의 불변성</h1>
        <p>ECMAScript 엔진의 객체 내부 메소드는 아래에 명시된 불변성 목록을 준수해야 합니다. 일반 ECMAScript 객체와 이 명세의 모든 표준 이국 객체는 이 불변성을 유지합니다. ECMAScript Proxy 객체는 [[ProxyHandler]] 객체의 트랩 결과에 대한 런타임 검사를 통해 이 불변성을 유지합니다.</p>
        <p>구현에서 제공하는 이국 객체도 해당 객체에 대해 이 불변성을 유지해야 합니다. 이 불변성을 위반하면 ECMAScript 코드의 예측 불가능한 동작이나 보안 문제를 일으킬 수 있습니다. 그러나 이 불변성 위반으로 구현의 메모리 안전성이 훼손되어서는 안 됩니다.</p>
        <p>이 불변성을 필수 내부 메소드의 기능을 대체하는 대체 인터페이스를 제공하는 등 어떤 방식으로든 우회하도록 허용해서는 안 됩니다.</p>
        <h2>정의:</h2>
        <ul>
          <li>
            내부 메소드의 <em>대상(target)</em>은 내부 메소드가 호출되는 객체입니다.
          </li>
          <li>
            대상이 [[IsExtensible]] 내부 메소드에서 *false*를 반환하거나 [[PreventExtensions]] 내부 메소드에서 *true*를 반환한 것으로 관찰되면, <em>비확장 대상</em>입니다.
          </li>
          <li>
            <em>존재하지 않는(non-existent)</em> 프로퍼티는 비확장 대상에 자체 프로퍼티로 존재하지 않는 프로퍼티입니다.
          </li>
          <li>
            <em>SameValue</em>에 대한 모든 참조는 SameValue 알고리즘 정의를 따릅니다.
          </li>
        </ul>
        <h2>반환값:</h2>
        <p>모든 내부 메소드가 반환하는 값은 다음 중 하나인 Completion Record여야 합니다:</p>
        <ul>
          <li>[[Type]] = ~normal~, [[Target]] = ~empty~, 그리고 [[Value]]가 해당 내부 메소드의 “정상 반환 타입”에 표시된 값</li>
          <li>[[Type]] = ~throw~, [[Target]] = ~empty~, 그리고 [[Value]]가 ECMAScript 언어 값</li>
        </ul>
        <emu-note>
          <p>내부 메소드는 continue, break, return 완료를 반환하면 안 됩니다.</p>
        </emu-note>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Object 또는 Null입니다.
          </li>
          <li>
            대상이 비확장 상태이고 [[GetPrototypeOf]]가 값 _V_를 반환하면, 이후 [[GetPrototypeOf]] 호출은 항상 _V_와 SameValue여야 합니다.
          </li>
        </ul>
        <emu-note>
          <p>객체의 프로토타입 체인은 유한 길이를 가져야 합니다(즉, 어떤 객체에서 시작해서 [[GetPrototypeOf]] 내부 메소드를 재귀적으로 적용하면 결국 *null*에 도달해야 함). 하지만 프로토타입 체인에 일반 객체 정의를 사용하지 않는 이국 객체가 포함되면, 이 요구사항은 객체 수준 불변성으로 강제할 수 없습니다. 이런 순환 프로토타입 체인은 객체 프로퍼티 접근 시 무한 루프를 유발할 수 있습니다.</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] ( _V_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            대상이 비확장 상태면, [[SetPrototypeOf]]는 _V_가 대상의 [[GetPrototypeOf]]로 관찰된 값과 SameValue가 아니면 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            [[IsExtensible]]가 *false*를 반환하면, 이후 해당 대상에서 [[IsExtensible]]은 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            [[PreventExtensions]]가 *true*를 반환하면, 이후 해당 대상에서 [[IsExtensible]]은 반드시 *false*를 반환해야 하며, 이제 대상은 비확장 상태로 간주됩니다.
          </li>
        </ul>
        <h2>[[GetOwnProperty]] ( _P_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Property Descriptor 또는 Undefined입니다.
          </li>
          <li>
            반환값이 프로퍼티 설명자이면, 반드시 완전히 채워진 설명자여야 합니다.
          </li>
          <li>
            _P_가 비구성, 비쓰기 자체 데이터 프로퍼티로 기술된 경우, 이후 [[GetOwnProperty]] ( _P_ ) 호출은 반드시 _P_의 [[Value]]와 SameValue인 [[Value]] 속성을 가진 설명자를 반환해야 합니다.
          </li>
          <li>
            _P_의 [[Writable]], [[Value]] 외의 속성이 시간에 따라 변경될 수 있거나 프로퍼티가 삭제될 수 있으면, _P_의 [[Configurable]] 속성은 반드시 *true*여야 합니다.
          </li>
          <li>
            [[Writable]] 속성이 *false*에서 *true*로 변할 수 있다면, [[Configurable]] 속성은 반드시 *true*여야 합니다.
          </li>
          <li>
            대상이 비확장 상태이고 _P_가 존재하지 않는 프로퍼티면, 이후 해당 대상에서 [[GetOwnProperty]] (_P_)는 반드시 _P_를 존재하지 않는 것으로 기술해야 합니다(즉, [[GetOwnProperty]] (_P_)는 *undefined*를 반환해야 함).
          </li>
        </ul>
        <emu-note>
          <p>세 번째 불변성의 결과로, 데이터 프로퍼티로 기술된 프로퍼티가 시간에 따라 다른 값을 반환할 수 있으면, 다른 메소드에서 값을 변경하는 메커니즘이 노출되지 않아도 [[Writable]]과 [[Configurable]] 중 하나 또는 둘 다 반드시 *true*여야 합니다.</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] ( _P_, _Desc_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            [[DefineOwnProperty]]는 _P_가 이전에 대상의 비구성 자체 프로퍼티로 관찰된 경우, 다음 중 하나가 아니면 반드시 *false*를 반환해야 합니다:
            <ol>
              <li>
                _P_가 쓰기 가능한 데이터 프로퍼티이다. 비구성 쓰기 가능 데이터 프로퍼티는 비구성 비쓰기 데이터 프로퍼티로 변경될 수 있다.
              </li>
              <li>
                _Desc_의 모든 속성이 _P_의 속성과 SameValue이다.
              </li>
            </ol>
          </li>
          <li>
            [[DefineOwnProperty]] (_P_, _Desc_)는 대상이 비확장 상태이고 _P_가 존재하지 않는 자체 프로퍼티이면 반드시 *false*를 반환해야 합니다. 즉, 비확장 대상 객체는 새 프로퍼티로 확장될 수 없습니다.
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            _P_가 이전에 대상의 비구성 자체 데이터 또는 접근자 프로퍼티로 관찰된 경우, [[HasProperty]]는 반드시 *true*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[Get]] ( _P_, _Receiver_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 ECMAScript 언어의 어떤 타입이든 가능합니다.
          </li>
          <li>
            _P_가 대상의 비구성, 비쓰기 자체 데이터 프로퍼티로 관찰된 값 _V_이면, [[Get]]은 반드시 _V_와 SameValue를 반환해야 합니다.
          </li>
          <li>
            _P_가 대상의 비구성 자체 접근자 프로퍼티로 관찰되고 [[Get]] 속성이 *undefined*이면, [[Get]] 연산은 반드시 *undefined*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            _P_가 대상의 비구성, 비쓰기 자체 데이터 프로퍼티로 관찰된 경우, [[Set]]은 _V_가 _P_의 [[Value]] 속성과 SameValue가 아니면 반드시 *false*를 반환해야 합니다.
          </li>
          <li>
            _P_가 대상의 비구성 자체 접근자 프로퍼티로 관찰되고 [[Set]] 속성이 *undefined*이면, [[Set]] 연산은 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            정상 반환 타입은 Boolean입니다.
          </li>
          <li>
            _P_가 대상의 비구성 자체 데이터 또는 접근자 프로퍼티로 관찰된 경우, [[Delete]]는 반드시 *false*를 반환해야 합니다.
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 리스트입니다.
          </li>
          <li>
            반환된 리스트에는 중복 항목이 포함되면 안 됩니다.
          </li>
          <li>
            반환된 리스트의 각 요소는 프로퍼티 키여야 합니다.
          </li>
          <li>
            반환된 리스트에는 이전에 관찰된 모든 비구성 자체 프로퍼티의 키가 반드시 포함되어야 합니다.
          </li>
          <li>
            대상이 비확장 상태면, 반환된 리스트에는 [[GetOwnProperty]]로 관찰 가능한 대상의 모든 자체 프로퍼티 키만 포함되어야 합니다.
          </li>
        </ul>
        <h2>[[Call]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 ECMAScript 언어의 어떤 타입이든 가능합니다.
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            정상 반환 타입은 Object입니다.
          </li>
          <li>
            대상은 반드시 [[Call]] 내부 메소드도 가져야 합니다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>잘 알려진 내장 객체</h1>
        <p>잘 알려진 내장 객체는 이 명세의 알고리즘에서 명시적으로 참조되는 내장 객체이며, 일반적으로 realm별로 별도의 정체성을 가집니다. 별도 지정이 없는 한, 각 내장 객체는 실제로 realm별로 하나씩 유사한 객체 집합에 해당합니다.</p>
        <p>이 명세 내에서 %name%과 같은 참조는 현재 realm과 연결된 해당 이름의 내장 객체를 의미합니다. %name.a.b%와 같은 참조는, 어떤 ECMAScript 코드가 평가되기 전에 내장 객체 %name%의 "a" 프로퍼티 값의 "b" 프로퍼티 값에 접근한 것과 같습니다. 현재 realm 및 그 내장 객체 결정 방법은 <emu-xref href="#sec-execution-contexts"></emu-xref>에 설명되어 있습니다. 잘 알려진 내장 객체 목록은 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>에 나와 있습니다.</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="잘 알려진 내장 객체" oldids="table-7">
          <table>
            <thead>
              <tr>
                <th>
                  내장 객체 이름
                </th>
                <th>
                  글로벌 이름
                </th>
                <th>
                  ECMAScript 언어 연관
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                `AggregateError` 생성자 (<emu-xref href="#sec-aggregate-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                Array 생성자 (<emu-xref href="#sec-array-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                ArrayBuffer 생성자 (<emu-xref href="#sec-arraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Array Iterator 객체의 프로토타입 (<emu-xref href="#sec-array-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Async-from-Sync Iterator 객체의 프로토타입 (<emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                async 함수 객체의 생성자 (<emu-xref href="#sec-async-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                async generator 함수 객체의 생성자 (<emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                async generator 객체의 프로토타입 (<emu-xref href="#sec-asyncgenerator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                모든 표준 내장 async iterator 객체가 간접적으로 상속하는 객체
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                `Atomics` 객체 (<emu-xref href="#sec-atomics-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                BigInt 생성자 (<emu-xref href="#sec-bigint-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                BigInt64Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                BigUint64Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                Boolean 생성자 (<emu-xref href="#sec-boolean-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                DataView 생성자 (<emu-xref href="#sec-dataview-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                Date 생성자 (<emu-xref href="#sec-date-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                `decodeURI` 함수 (<emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                `decodeURIComponent` 함수 (<emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                `encodeURI` 함수 (<emu-xref href="#sec-encodeuri-uri"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                `encodeURIComponent` 함수 (<emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                Error 생성자 (<emu-xref href="#sec-error-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                `eval` 함수 (<emu-xref href="#sec-eval-x"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                EvalError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                FinalizationRegistry 생성자 (<emu-xref href="#sec-finalization-registry-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float16Array%
              </td>
              <td>
                `Float16Array`
              </td>
              <td>
                Float16Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                Float32Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                Float64Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                For-In Iterator 객체의 프로토타입 (<emu-xref href="#sec-for-in-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                Function 생성자 (<emu-xref href="#sec-function-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                generator 함수 객체의 생성자 (<emu-xref href="#sec-generatorfunction-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                generator 객체의 프로토타입 (<emu-xref href="#sec-generator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                Int8Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                Int16Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                Int32Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                `isFinite` 함수 (<emu-xref href="#sec-isfinite-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                `isNaN` 함수 (<emu-xref href="#sec-isnan-number"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Iterator%
              </td>
              <td>
                `Iterator`
              </td>
              <td>
                `Iterator` 생성자 (<emu-xref href="#sec-iterator-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %IteratorHelperPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator Helper 객체의 프로토타입 (<emu-xref href="#sec-%iteratorhelperprototype%-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                `JSON` 객체 (<emu-xref href="#sec-json-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                Map 생성자 (<emu-xref href="#sec-map-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Map Iterator 객체의 프로토타입 (<emu-xref href="#sec-map-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                `Math` 객체 (<emu-xref href="#sec-math-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                Number 생성자 (<emu-xref href="#sec-number-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                Object 생성자 (<emu-xref href="#sec-object-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                `parseFloat` 함수 (<emu-xref href="#sec-parsefloat-string"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                `parseInt` 함수 (<emu-xref href="#sec-parseint-string-radix"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                Promise 생성자 (<emu-xref href="#sec-promise-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                Proxy 생성자 (<emu-xref href="#sec-proxy-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                RangeError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                ReferenceError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                `Reflect` 객체 (<emu-xref href="#sec-reflect-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                RegExp 생성자 (<emu-xref href="#sec-regexp-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                RegExp String Iterator 객체의 프로토타입 (<emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                Set 생성자 (<emu-xref href="#sec-set-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Set Iterator 객체의 프로토타입 (<emu-xref href="#sec-set-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                SharedArrayBuffer 생성자 (<emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                String 생성자 (<emu-xref href="#sec-string-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                String Iterator 객체의 프로토타입 (<emu-xref href="#sec-string-iterator-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                Symbol 생성자 (<emu-xref href="#sec-symbol-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                SyntaxError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                무조건 새로운 %TypeError% 인스턴스를 throw하는 함수 객체
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                모든 typed Array 생성자의 슈퍼 클래스 (<emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                TypeError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                Uint8Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                Uint8ClampedArray 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                Uint16Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                Uint32Array 생성자 (<emu-xref href="#sec-typedarray-objects"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                URIError 생성자 (<emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                WeakMap 생성자 (<emu-xref href="#sec-weakmap-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                WeakRef 생성자 (<emu-xref href="#sec-weak-ref-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                WeakSet 생성자 (<emu-xref href="#sec-weakset-constructor"></emu-xref>)
              </td>
            </tr>
            <tr>
              <td>
                %WrapForValidIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator.from에서 반환된 래핑된 iterator 객체의 프로토타입 (<emu-xref href="#sec-%wrapforvaliditeratorprototype%-object"></emu-xref>)
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>에 추가 항목이 있습니다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript 명세 타입</h1>
    <p>명세 타입은 ECMAScript 언어 구조와 ECMAScript 언어 타입의 의미론을 설명하기 위해 알고리즘 내에서 사용되는 메타 값에 해당합니다. 명세 타입에는 Reference Record, List, Completion Record, Property Descriptor, Environment Record, Abstract Closure, Data Block이 포함됩니다. 명세 타입 값은 ECMAScript 구현 내의 특정 엔티티에 반드시 대응하지는 않는 명세 산출물입니다. 명세 타입 값은 ECMAScript 표현식 평가의 중간 결과를 설명하는 데 사용할 수 있지만, 이러한 값은 객체의 프로퍼티나 ECMAScript 언어 변수의 값으로 저장될 수 없습니다.</p>

    <emu-clause id="sec-enum-specification-type">
      <h1>Enum 명세 타입</h1>
      <p><dfn variants="enum,enums">Enum</dfn>은 명세 내부에서만 사용되며 ECMAScript 코드에서는 직접적으로 관찰할 수 없는 값입니다. Enum은 ~sans-serif~ 서체로 표시됩니다. 예를 들어, Completion Record의 [[Type]] 필드는 ~normal~, ~return~, ~throw~와 같은 값을 가집니다. Enum은 이름 이외의 특징을 가지지 않습니다. Enum의 이름은 다른 Enum과 구별하기 위함이며, 그 사용이나 의미를 암시하지 않습니다.</p>
    </emu-clause>

    <emu-clause id="sec-list-and-record-specification-type">
      <h1>List와 Record 명세 타입</h1>
      <p><dfn variants="Lists">List</dfn> 타입은 `new` 표현식, 함수 호출, 그 외 값의 단순 순서 리스트가 필요한 알고리즘에서 인자 리스트 평가를 설명하는 데 사용됩니다(<emu-xref href="#sec-argument-lists"></emu-xref> 참조). List 타입의 값은 각 개별 값을 담고 있는 리스트 요소들의 순서 있는 시퀀스입니다. 이 시퀀스는 길이에 제한이 없습니다. 리스트의 요소는 0부터 시작하는 인덱스로 임의 접근할 수 있습니다. 표기상의 편의를 위해 배열과 유사한 문법으로 List 요소에 접근할 수 있습니다. 예를 들어, _arguments_[2]는 List _arguments_의 3번째 요소를 의미합니다.</p>
      <p>알고리즘이 List의 요소를 반복할 때 순서를 지정하지 않으면 List 요소의 순서대로 사용됩니다.</p>
      <p>이 명세에서는 리터럴 문법을 사용해 새로운 List 값을 표현할 수 있습니다. 예를 들어, « 1, 2 »는 두 개의 요소를 특정 값으로 초기화한 List 값을 정의합니다. 새로운 빈 List는 « »로 표현할 수 있습니다.</p>
      <p>이 명세에서 “the <dfn id="list-concatenation">list-concatenation</dfn> of _A_, _B_, ...”(각 인자가 비어 있을 수도 있는 List)라는 표현은 각 인자(순서대로)의 요소를 이어붙인(순서대로) 새로운 List 값을 의미합니다.</p>
      <p>List가 String 요소로 구성된 경우 “sorted according to <dfn id="lexicographic-code-unit-order">lexicographic code unit order</dfn>”란, IsLessThan 추상 연산에서 설명한 대로, 짧은 문자열 길이까지 각 코드 유닛의 숫자값으로 정렬하며, 모든 코드 유닛이 같으면 짧은 문자열이 긴 문자열보다 먼저 오도록 정렬한다는 뜻입니다.</p>
      <p><dfn variants="Records">Record</dfn> 타입은 이 명세의 알고리즘 내에서 데이터 집합을 설명하는 데 사용됩니다. Record 타입 값은 하나 이상의 이름 있는 필드로 구성됩니다. 각 필드의 값은 ECMAScript 언어 값 또는 명세 값입니다. 필드 이름은 항상 [[ ]]로 둘러싸입니다(예: [[Value]]).</p>
      <p>이 명세에서는 객체 리터럴과 유사한 문법으로 Record 값을 표현할 수 있습니다. 예를 들어, { [[Field1]]: 42, [[Field2]]: *false*, [[Field3]]: ~empty~ }는 세 개의 필드가 각각 특정 값으로 초기화된 Record 값을 정의합니다. 필드 이름의 순서는 중요하지 않습니다. 명시적으로 나열되지 않은 필드는 없는 것으로 간주합니다.</p>
      <p>명세 텍스트와 알고리즘에서 점 표기법으로 Record 값의 특정 필드를 참조할 수 있습니다. 예를 들어, 위의 예시 Record R에 대해 R.[[Field2]]는 “R의 [[Field2]] 필드”를 의미합니다.</p>
      <p>자주 사용되는 Record 필드 조합에 대해 스키마 이름을 붙일 수 있으며, 그 이름을 리터럴 Record 값에 접두어로 사용해 특정 집합의 집계임을 명시할 수 있습니다. 예: PropertyDescriptor { [[Value]]: 42, [[Writable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>Set과 Relation 명세 타입</h1>
      <p><em>Set</em> 타입은 메모리 모델에서 사용될 무순서 요소 집합을 설명하는 데 사용됩니다. ECMAScript 컬렉션 타입 Set과는 다릅니다. 혼동을 피하기 위해, 명세에서는 ECMAScript 컬렉션 인스턴스를 “Set 객체”라고 일관되게 부릅니다. Set 타입 값은 중복 없는 간단한 요소 집합입니다. 요소는 추가·제거할 수 있으며, Set끼리 합집합·교집합·차집합 연산이 가능합니다.</p>
      <p><dfn variants="Relations">Relation</dfn> 타입은 Set에 대한 제약을 설명하는 데 사용됩니다. Relation 타입 값은 값 도메인에서 가져온 순서쌍의 Set입니다. 예를 들어, 이벤트에 대한 Relation은 이벤트들의 순서쌍 집합입니다. Relation _R_과 값 도메인 내 두 값 _a_, _b_에 대해 _a_ _R_ _b_는 (_a_, _b_)가 _R_의 원소임을 뜻합니다. Relation이 어떤 조건에 대해 <dfn id="least-relation">최소 Relation</dfn>임은 그 조건을 만족하는 가장 작은 Relation임을 의미합니다.</p>
      <p><dfn variants="strict partial orders">엄격 부분 순서(strict partial order)</dfn>는 다음을 만족하는 Relation 값 _R_입니다.</p>
      <ul>
        <li>
          <p>모든 _R_의 도메인 내 _a_, _b_, _c_에 대해:</p>
          <ul>
            <li>_a_ _R_ _a_는 성립하지 않으며,</li>
            <li>_a_ _R_ _b_ 및 _b_ _R_ _c_이면, _a_ _R_ _c_이다.</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>위 두 속성은 각각 반사 불가성(irreflexivity)과 추이성(transitivity)이라 부릅니다.</p>
      </emu-note>
      <p><dfn variants="strict total orders">엄격 전순서(strict total order)</dfn>는 다음을 만족하는 Relation 값 _R_입니다.</p>
      <ul>
        <li>
          <p>모든 _R_의 도메인 내 _a_, _b_, _c_에 대해:</p>
          <ul>
            <li>_a_는 _b_이거나, _a_ _R_ _b_이거나, _b_ _R_ _a_이다.</li>
            <li>_a_ _R_ _a_는 성립하지 않는다.</li>
            <li>_a_ _R_ _b_ 그리고 _b_ _R_ _c_이면, _a_ _R_ _c_이다.</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>위 세 속성은 각각 전체성(totality), 반사 불가성(irreflexivity), 추이성(transitivity)이라 부릅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-completion-record-specification-type">
      <h1>Completion Record 명세 타입</h1>
      <p><dfn variants="Completion Records">Completion Record</dfn> 명세 타입은 실행 중 값의 전달과 제어 흐름(비지역적 제어 이동을 수행하는 문장인 `break`, `continue`, `return`, `throw`의 동작 등)을 설명하는 데 사용됩니다.</p>
      <p>Completion Record는 <emu-xref href="#table-completion-record-fields"></emu-xref>에 정의된 필드를 가집니다.</p>
      <emu-table id="table-completion-record-fields" caption="Completion Record 필드" oldids="table-8">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              ~normal~, ~break~, ~continue~, ~return~, ~throw~
            </td>
            <td>
              발생한 completion의 타입
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              Completion Record가 아닌 임의 값
            </td>
            <td>
              생성된 값
            </td>
          </tr>
          <tr>
            <td>
              [[Target]]
            </td>
            <td>
              문자열 또는 ~empty~
            </td>
            <td>
              지시된 제어 이동의 대상 레이블
            </td>
          </tr>
        </table>
      </emu-table>
      <p>다음과 같은 용어들이 Completion Record를 참조할 때 종종 사용됩니다.</p>
      <ul>
        <li><dfn variants="normal completions">normal completion</dfn>은 [[Type]] 값이 ~normal~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="break completions">break completion</dfn>은 [[Type]] 값이 ~break~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="continue completions">continue completion</dfn>은 [[Type]] 값이 ~continue~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="return completions">return completion</dfn>은 [[Type]] 값이 ~return~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="throw completions">throw completion</dfn>은 [[Type]] 값이 ~throw~인 Completion Record를 의미합니다.</li>
        <li><dfn variants="abrupt completions">abrupt completion</dfn>은 [[Type]] 값이 ~normal~이 아닌 Completion Record를 의미합니다.</li>
        <li><dfn variants="normal completions containing">normal completion containing</dfn>은 [[Value]] 필드에 해당 타입의 값이 포함된 normal completion을 의미합니다.</li>
      </ul>
      <p>이 명세에서 정의된 호출 가능한 객체는 항상 normal completion이나 throw completion만 반환합니다. 그 외 Completion Record를 반환하는 것은 편집 오류로 간주합니다.</p>
      <p>구현 정의 호출 가능 객체도 normal completion 또는 throw completion만 반환해야 합니다.</p>

      <emu-clause id="sec-normalcompletion" type="abstract operation">
        <h1>
          NormalCompletion (
            _value_: Completion Record가 아닌 임의 값,
          ): normal completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throwcompletion" type="abstract operation">
        <h1>
          ThrowCompletion (
            _value_: ECMAScript 언어 값,
          ): throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returncompletion" type="abstract operation">
        <h1>
          ReturnCompletion (
            _value_: ECMAScript 언어 값,
          ): return completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-updateempty" type="abstract operation">
        <h1>
          UpdateEmpty (
            _completionRecord_: Completion Record,
            _value_: Completion Record가 아닌 임의 값,
          ): Completion Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: _completionRecord_가 return completion 또는 throw completion이면, _completionRecord_.[[Value]]는 ~empty~가 아니다.
          1. _completionRecord_.[[Value]]가 ~empty~가 아니면, ? _completionRecord_를 반환한다.
          1. Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>Reference Record 명세 타입</h1>
      <p><dfn variants="Reference Records">Reference Record</dfn> 타입은 `delete`, `typeof`, 대입 연산자, `super` 키워드 및 기타 언어 기능의 동작을 설명하는 데 사용됩니다. 예를 들어, 대입의 왼쪽 피연산자는 Reference Record를 생성해야 합니다.</p>
      <p>Reference Record는 해석된 이름 또는(아직 해석되지 않았을 수도 있는) 프로퍼티 바인딩이며, 필드는 <emu-xref href="#table-reference-record-fields"></emu-xref>에 정의되어 있습니다.</p>

      <emu-table id="table-reference-record-fields" caption="Reference Record 필드">
        <table>
          <thead>
            <tr>
              <th>필드 이름</th>
              <th>값</th>
              <th>의미</th>
            </tr>
          </thead>
          <tr>
            <td oldids="sec-getbase,ao-getbase">[[Base]]</td>
            <td>ECMAScript 언어 값, Environment Record, ~unresolvable~</td>
            <td>바인딩을 담고 있는 값 또는 Environment Record. [[Base]]가 ~unresolvable~이면 바인딩을 해석할 수 없음을 의미합니다.</td>
          </tr>
          <tr>
            <td oldids="sec-getreferencedname,ao-getreferencedname">[[ReferencedName]]</td>
            <td>ECMAScript 언어 값 또는 Private Name</td>
            <td>바인딩의 이름. [[Base]] 값이 Environment Record면 항상 문자열입니다. 그렇지 않으면, ToPropertyKey가 수행되기 전까지 문자열이나 심볼이 아닌 ECMAScript 언어 값일 수 있습니다.</td>
          </tr>
          <tr>
            <td oldids="sec-isstrictreference,ao-isstrictreference">[[Strict]]</td>
            <td>불리언</td>
            <td>Reference Record가 strict 모드 코드에서 생성되었으면 *true*, 아니면 *false*입니다.</td>
          </tr>
          <tr>
            <td>[[ThisValue]]</td>
            <td>ECMAScript 언어 값 또는 ~empty~</td>
            <td>~empty~가 아니면, Reference Record가 `super` 키워드로 표현된 프로퍼티 바인딩을 나타냅니다. 이를 <dfn id="super-reference-record" oldids="super-reference" variants="Super Reference Records">Super Reference Record</dfn>라 하며, [[Base]] 값은 Environment Record가 될 수 없습니다. 이 경우 [[ThisValue]] 필드는 Reference Record가 생성된 시점의 *this* 값을 담습니다.</td>
          </tr>
        </table>
      </emu-table>

      <p>Reference Record를 다루기 위해 명세에서 다음과 같은 추상 연산을 사용합니다:</p>

      <emu-clause id="sec-ispropertyreference" type="abstract operation" oldids="ao-ispropertyreference">
        <h1>
          IsPropertyReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[Base]]가 ~unresolvable~이면 *false* 반환.
          1. _V_.[[Base]]가 Environment Record이면 *false* 반환; 아니면 *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" type="abstract operation" oldids="ao-isunresolvablereference">
        <h1>
          IsUnresolvableReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[Base]]가 ~unresolvable~이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" type="abstract operation" oldids="ao-issuperreference">
        <h1>
          IsSuperReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[ThisValue]]가 ~empty~가 아니면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isprivatereference" type="abstract operation">
        <h1>
          IsPrivateReference (
            _V_: Reference Record,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_.[[ReferencedName]]이 Private Name이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvalue" type="abstract operation">
        <h1>
          GetValue (
            _V_: Reference Record 또는 ECMAScript 언어 값,
          ): ECMAScript 언어 값을 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_가 Reference Record가 아니면 _V_를 반환한다.
          1. IsUnresolvableReference(_V_)가 *true*이면 *ReferenceError* 예외를 throw한다.
          1. IsPropertyReference(_V_)가 *true*이면,
            1. [id="step-getvalue-toobject"] _baseObj_를 ? ToObject(_V_.[[Base]])로 한다.
            1. IsPrivateReference(_V_)가 *true*이면,
              1. ? PrivateGet(_baseObj_, _V_.[[ReferencedName]])를 반환한다.
            1. _V_.[[ReferencedName]]이 프로퍼티 키가 아니면,
              1. _V_.[[ReferencedName]]을 ? ToPropertyKey(_V_.[[ReferencedName]])로 설정한다.
            1. ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_))를 반환한다.
          1. 아니면,
            1. _base_를 _V_.[[Base]]로 한다.
            1. 단언: _base_는 Environment Record이다.
            1. ? <emu-meta effects="user-code">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]])를 반환한다(<emu-xref href="#sec-environment-records"></emu-xref> 참조).
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-getvalue-toobject"></emu-xref> 단계에서 생성되는 객체는 위 추상 연산과 ordinary object [[Get]] 내부 메소드 외부에서는 접근할 수 없습니다. 구현에서는 실제 객체 생성을 생략할 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" type="abstract operation">
        <h1>
          PutValue (
            _V_: Reference Record 또는 ECMAScript 언어 값,
            _W_: ECMAScript 언어 값,
          ): ~unused~을 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_가 Reference Record가 아니면 *ReferenceError* 예외를 throw한다.
          1. IsUnresolvableReference(_V_)가 *true*이면,
            1. _V_.[[Strict]]가 *true*이면 *ReferenceError* 예외를 throw한다.
            1. _globalObj_를 GetGlobalObject()로 한다.
            1. ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*)를 수행한다.
            1. ~unused~를 반환한다.
          1. IsPropertyReference(_V_)가 *true*이면,
            1. [id="step-putvalue-toobject"] _baseObj_를 ? ToObject(_V_.[[Base]])로 한다.
            1. IsPrivateReference(_V_)가 *true*이면,
              1. ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_)를 반환한다.
            1. _V_.[[ReferencedName]]이 프로퍼티 키가 아니면,
              1. _V_.[[ReferencedName]]을 ? ToPropertyKey(_V_.[[ReferencedName]])로 설정한다.
            1. _succeeded_를 ? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_))로 한다.
            1. _succeeded_가 *false*이고 _V_.[[Strict]]가 *true*이면 *TypeError* 예외를 throw한다.
            1. ~unused~를 반환한다.
          1. 아니면,
            1. _base_를 _V_.[[Base]]로 한다.
            1. 단언: _base_는 Environment Record이다.
            1. ? <emu-meta effects="user-code">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]])를 반환한다(<emu-xref href="#sec-environment-records"></emu-xref> 참조).
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-putvalue-toobject"></emu-xref> 단계에서 생성되는 객체는 위 추상 연산과 ordinary object [[Set]] 내부 메소드 외부에서는 접근할 수 없습니다. 구현에서는 실제 객체 생성을 생략할 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getthisvalue" type="abstract operation">
        <h1>
          GetThisValue (
            _V_: Reference Record,
          ): ECMAScript 언어 값
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: IsPropertyReference(_V_)는 *true*이다.
          1. IsSuperReference(_V_)가 *true*이면 _V_.[[ThisValue]] 반환; 아니면 _V_.[[Base]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: Reference Record,
            _W_: ECMAScript 언어 값,
          ): ~unused~을 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: IsUnresolvableReference(_V_)는 *false*이다.
          1. _base_를 _V_.[[Base]]로 한다.
          1. 단언: _base_는 Environment Record이다.
          1. ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeprivatereference" type="abstract operation">
        <h1>
          MakePrivateReference (
            _baseValue_: ECMAScript 언어 값,
            _privateIdentifier_: 문자열,
          ): Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _privateEnv_를 실행 중인 실행 컨텍스트의 PrivateEnvironment로 한다.
          1. 단언: _privateEnv_는 *null*이 아니다.
          1. _privateName_을 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)로 한다.
          1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-descriptor-specification-type">
      <h1>Property Descriptor 명세 타입</h1>
      <p><dfn variants="Property Descriptors">Property Descriptor</dfn> 타입은 Object 프로퍼티 속성의 조작과 구체화를 설명하는 데 사용됩니다. Property Descriptor는 0개 이상의 필드를 갖는 Record이며, 각 필드 이름은 속성 이름이고 값은 <emu-xref href="#sec-property-attributes"></emu-xref>에 지정된 속성 값입니다. 명세에서 Property Descriptor 레코드의 리터럴 설명을 태그하는 스키마 이름은 “PropertyDescriptor”입니다.</p>
      <p>Property Descriptor 값은 특정 필드의 존재나 사용에 따라 데이터 Property Descriptor와 접근자 Property Descriptor로 더 분류할 수 있습니다. [[Value]] 또는 [[Writable]] 필드가 있으면 데이터 Property Descriptor, [[Get]] 또는 [[Set]] 필드가 있으면 접근자 Property Descriptor입니다. 모든 Property Descriptor에는 [[Enumerable]]과 [[Configurable]] 필드가 있을 수 있습니다. 한 Property Descriptor 값은 데이터 Property Descriptor와 접근자 Property Descriptor를 동시에 가질 수 없지만, 둘 다 아닐 수도 있습니다(이 경우 generic Property Descriptor). <dfn>완전한 Property Descriptor</dfn>는 접근자 또는 데이터 Property Descriptor이면서 <emu-xref href="#table-object-property-attributes"></emu-xref>의 해당 필드를 모두 가지고 있는 것입니다.</p>
      <p>이 명세에서 Property Descriptor 값을 다루기 위해 다음 추상 연산을 사용합니다:</p>

      <emu-clause id="sec-isaccessordescriptor" type="abstract operation">
        <h1>
          IsAccessorDescriptor (
            _Desc_: Property Descriptor,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_에 [[Get]] 필드가 있으면 *true* 반환.
          1. _Desc_에 [[Set]] 필드가 있으면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdatadescriptor" type="abstract operation">
        <h1>
          IsDataDescriptor (
            _Desc_: Property Descriptor,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_에 [[Value]] 필드가 있으면 *true* 반환.
          1. _Desc_에 [[Writable]] 필드가 있으면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isgenericdescriptor" type="abstract operation">
        <h1>
          IsGenericDescriptor (
            _Desc_: Property Descriptor,
          ): Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. IsAccessorDescriptor(_Desc_)가 *true*면 *false* 반환.
          1. IsDataDescriptor(_Desc_)가 *true*면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frompropertydescriptor" type="abstract operation">
        <h1>
          FromPropertyDescriptor (
            _Desc_: Property Descriptor 또는 *undefined*,
          ): Object 또는 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Desc_가 *undefined*면 *undefined* 반환.
          1. _obj_를 OrdinaryObjectCreate(%Object.prototype%)로 한다.
          1. 단언: _obj_는 확장 가능한 ordinary object이며 자체 프로퍼티가 없다.
          1. _Desc_에 [[Value]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _Desc_.[[Value]])를 수행한다.
          1. _Desc_에 [[Writable]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"writable"*, _Desc_.[[Writable]])를 수행한다.
          1. _Desc_에 [[Get]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"get"*, _Desc_.[[Get]])를 수행한다.
          1. _Desc_에 [[Set]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"set"*, _Desc_.[[Set]])를 수행한다.
          1. _Desc_에 [[Enumerable]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"enumerable"*, _Desc_.[[Enumerable]])를 수행한다.
          1. _Desc_에 [[Configurable]] 필드가 있으면,
            1. ! CreateDataPropertyOrThrow(_obj_, *"configurable"*, _Desc_.[[Configurable]])를 수행한다.
          1. _obj_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-topropertydescriptor" type="abstract operation">
        <h1>
          ToPropertyDescriptor (
            _Obj_: ECMAScript 언어 값,
          ): Property Descriptor를 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _Obj_가 Object가 아니면 *TypeError* 예외를 throw한다.
          1. _desc_를 초기에는 필드가 없는 새로운 Property Descriptor로 한다.
          1. _hasEnumerable_을 ? HasProperty(_Obj_, *"enumerable"*)로 한다.
          1. _hasEnumerable_이 *true*면,
            1. _enumerable_을 ToBoolean(? Get(_Obj_, *"enumerable"*))로 한다.
            1. _desc_.[[Enumerable]]에 _enumerable_을 할당한다.
          1. _hasConfigurable_을 ? HasProperty(_Obj_, *"configurable"*)로 한다.
          1. _hasConfigurable_이 *true*면,
            1. _configurable_을 ToBoolean(? Get(_Obj_, *"configurable"*))로 한다.
            1. _desc_.[[Configurable]]에 _configurable_을 할당한다.
          1. _hasValue_를 ? HasProperty(_Obj_, *"value"*)로 한다.
          1. _hasValue_가 *true*면,
            1. _value_를 ? Get(_Obj_, *"value"*)로 한다.
            1. _desc_.[[Value]]에 _value_를 할당한다.
          1. _hasWritable_을 ? HasProperty(_Obj_, *"writable"*)로 한다.
          1. _hasWritable_이 *true*면,
            1. _writable_을 ToBoolean(? Get(_Obj_, *"writable"*))로 한다.
            1. _desc_.[[Writable]]에 _writable_을 할당한다.
          1. _hasGet_을 ? HasProperty(_Obj_, *"get"*)로 한다.
          1. _hasGet_이 *true*면,
            1. _getter_를 ? Get(_Obj_, *"get"*)로 한다.
            1. IsCallable(_getter_)가 *false*이고 _getter_가 *undefined*가 아니면 *TypeError* 예외를 throw한다.
            1. _desc_.[[Get]]에 _getter_를 할당한다.
          1. _hasSet_을 ? HasProperty(_Obj_, *"set"*)로 한다.
          1. _hasSet_이 *true*면,
            1. _setter_를 ? Get(_Obj_, *"set"*)로 한다.
            1. IsCallable(_setter_)가 *false*이고 _setter_가 *undefined*가 아니면 *TypeError* 예외를 throw한다.
            1. _desc_.[[Set]]에 _setter_를 할당한다.
          1. _desc_에 [[Get]] 또는 [[Set]] 필드가 있으면,
            1. _desc_에 [[Value]] 또는 [[Writable]] 필드가 있으면 *TypeError* 예외를 throw한다.
          1. _desc_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-completepropertydescriptor" type="abstract operation">
        <h1>
          CompletePropertyDescriptor (
            _Desc_: Property Descriptor,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _like_를 Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }로 한다.
          1. IsGenericDescriptor(_Desc_)가 *true*이거나 IsDataDescriptor(_Desc_)가 *true*이면,
            1. _Desc_에 [[Value]] 필드가 없으면 _Desc_.[[Value]]에 _like_.[[Value]]를 할당한다.
            1. _Desc_에 [[Writable]] 필드가 없으면 _Desc_.[[Writable]]에 _like_.[[Writable]]를 할당한다.
          1. 아니면,
            1. _Desc_에 [[Get]] 필드가 없으면 _Desc_.[[Get]]에 _like_.[[Get]]를 할당한다.
            1. _Desc_에 [[Set]] 필드가 없으면 _Desc_.[[Set]]에 _like_.[[Set]]를 할당한다.
          1. _Desc_에 [[Enumerable]] 필드가 없으면 _Desc_.[[Enumerable]]에 _like_.[[Enumerable]]를 할당한다.
          1. _Desc_에 [[Configurable]] 필드가 없으면 _Desc_.[[Configurable]]에 _like_.[[Configurable]]를 할당한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-and-environment-record-specification-types">
      <h1>Environment Record 명세 타입</h1>
      <p>Environment Record 타입은 중첩 함수와 블록에서 이름 해석 동작을 설명하는 데 사용됩니다. 이 타입과 관련 연산은 <emu-xref href="#sec-environment-records"></emu-xref>에 정의되어 있습니다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-closure">
      <h1>Abstract Closure 명세 타입</h1>
      <p><dfn variants="Abstract Closures">Abstract Closure</dfn> 명세 타입은 알고리즘 단계와 값 집합을 함께 참조하는 데 사용됩니다. Abstract Closure는 메타 값이며 함수 호출 방식(_closure_(_arg1_, _arg2_))으로 호출됩니다. 추상 연산과 마찬가지로, 호출 시 Abstract Closure에 기술된 알고리즘 단계를 수행합니다.</p>
      <p>Abstract Closure를 생성하는 알고리즘 단계에서는 "capture" 뒤에 별칭 목록으로 값을 캡처합니다. Abstract Closure가 생성될 때 각 별칭에 연관된 값을 캡처합니다. Abstract Closure가 호출될 때 수행할 알고리즘 단계에서는 캡처된 값을 캡처 당시 사용된 별칭으로 참조합니다.</p>
      <p>Abstract Closure가 Completion Record를 반환하면, 반드시 normal completion 또는 throw completion이어야 합니다.</p>
      <p>Abstract Closure는 다른 알고리즘의 일부로 인라인 생성됩니다. 예시는 다음과 같습니다.</p>
      <emu-alg example>
        1. _addend_를 41로 한다.
        1. _closure_를 매개변수(_x_)를 가지며, _addend_를 캡처하고 호출 시 다음 단계를 수행하는 새로운 Abstract Closure로 한다:
          1. _x_ + _addend_를 반환한다.
        1. _val_을 _closure_(1)로 한다.
        1. 단언: _val_은 42이다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-data-blocks">
      <h1>Data Block</h1>
      <p><dfn variants="Data Blocks">Data Block</dfn> 명세 타입은 개별적이고 변경 가능한 바이트 크기(8비트)의 숫자값 시퀀스를 설명하는 데 사용됩니다. <dfn variants="byte values">byte value</dfn>는 0부터 255(포함) 사이의 정수입니다. Data Block 값은 고정된 바이트 수로 생성되며 각 바이트의 초기값은 0입니다.</p>
      <p>이 명세에서는 배열과 유사한 문법으로 Data Block 값의 개별 바이트에 접근할 수 있습니다. 이 표기법은 Data Block 값을 0 기반 <emu-not-ref>integer-indexed</emu-not-ref> 바이트 시퀀스로 표현합니다. 예를 들어, _db_가 5바이트 Data Block 값이면 _db_[2]는 3번째 바이트에 접근할 수 있습니다.</p>
      <p>메모리 내에서 여러 agent가 동시에 참조할 수 있는 data block은 <dfn variants="Shared Data Blocks">Shared Data Block</dfn>이라 부릅니다. Shared Data Block은 <em>주소 자유(address-free)</em>의 정체성을 갖습니다(Shared Data Block 값의 동등성 검사 목적). 이는 해당 블록이 어떤 프로세스의 가상 주소에 매핑되어 있든 상관없이, 그 블록이 나타내는 메모리 위치 집합에 따라 정체성이 결정됨을 뜻합니다. 두 data block은 그 위치 집합이 같을 때만 같고, 그렇지 않으면 다르며, 위치 집합의 교집합은 비어 있습니다. 마지막으로, Shared Data Block과 Data Block은 구별할 수 있습니다.</p>
      <p>Shared Data Block의 의미론은 메모리 모델에서 Shared Data Block 이벤트를 사용해 정의됩니다. 아래 추상 연산들은 Shared Data Block 이벤트를 도입하며, 평가 의미론과 메모리 모델의 이벤트 의미론 사이의 인터페이스 역할을 합니다. 이벤트들은 후보 실행(candidate execution)을 구성하며, 메모리 모델은 후보 실행에 필터로 작동합니다. 전체 의미론은 메모리 모델을 참고하세요.</p>
      <p>Shared Data Block 이벤트는 메모리 모델에서 정의된 Record로 모델링됩니다.</p>
      <p>이 명세에서 Data Block 값을 다루기 위해 다음과 같은 추상 연산을 사용합니다:</p>

      <emu-clause id="sec-createbytedatablock" type="abstract operation">
        <h1>
          CreateByteDataBlock (
            _size_: 0 이상 정수,
          ): Data Block을 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _size_ > 2<sup>53</sup> - 1이면 *RangeError* 예외를 throw한다.
          1. _db_를 _size_ 바이트로 구성된 새로운 Data Block 값으로 한다. 생성이 불가능하면 *RangeError* 예외를 throw한다.
          1. _db_의 모든 바이트를 0으로 설정한다.
          1. _db_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createsharedbytedatablock" type="abstract operation">
        <h1>
          CreateSharedByteDataBlock (
            _size_: 0 이상 정수,
          ): Shared Data Block을 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _db_를 _size_ 바이트로 구성된 새로운 Shared Data Block 값으로 한다. 생성이 불가능하면 *RangeError* 예외를 throw한다.
          1. _execution_을 주위 agent의 Agent Record의 [[CandidateExecution]] 필드로 한다.
          1. _eventsRecord_를 _execution_.[[EventsRecords]] 중 [[AgentSignifier]]가 AgentSignifier()인 Agent Events Record로 한다.
          1. _zero_를 « 0 »으로 한다.
          1. _db_의 각 인덱스 _i_에 대해,
            1. WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ }를 _eventsRecord_.[[EventList]]에 추가한다.
          1. _db_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-copydatablockbytes" type="abstract operation">
        <h1>
          CopyDataBlockBytes (
            _toBlock_: Data Block 또는 Shared Data Block,
            _toIndex_: 0 이상 정수,
            _fromBlock_: Data Block 또는 Shared Data Block,
            _fromIndex_: 0 이상 정수,
            _count_: 0 이상 정수,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: _fromBlock_과 _toBlock_은 서로 다른 값이다.
          1. _fromSize_를 _fromBlock_의 바이트 수로 한다.
          1. 단언: _fromIndex_ + _count_ ≤ _fromSize_이다.
          1. _toSize_를 _toBlock_의 바이트 수로 한다.
          1. 단언: _toIndex_ + _count_ ≤ _toSize_이다.
          1. _count_ > 0 동안 반복한다,
            1. _fromBlock_이 Shared Data Block이면,
              1. _execution_을 주위 agent의 Agent Record의 [[CandidateExecution]] 필드로 한다.
              1. _eventsRecord_를 _execution_.[[EventsRecords]] 중 [[AgentSignifier]]가 AgentSignifier()인 Agent Events Record로 한다.
              1. _bytes_를 nondeterministically 선택된 byte value 1개만 담은 List로 한다.
              1. 참고: 구현에서 _bytes_는 기저 하드웨어에서 비원자적 읽기 명령 결과입니다. 이 nondeterminism은 하드웨어의 약한 일관성에서 관찰 가능한 행동을 설명하기 위한 메모리 모델의 의미론적 처방입니다.
              1. _readEvent_를 ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }로 한다.
              1. _readEvent_를 _eventsRecord_.[[EventList]]에 추가한다.
              1. Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ }를 _execution_.[[ChosenValues]]에 추가한다.
              1. _toBlock_이 Shared Data Block이면,
                1. WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ }를 _eventsRecord_.[[EventList]]에 추가한다.
              1. 아니면,
                1. _toBlock_[_toIndex_]를 _bytes_[0]로 설정한다.
            1. 아니면,
              1. 단언: _toBlock_은 Shared Data Block이 아니다.
              1. _toBlock_[_toIndex_]를 _fromBlock_[_fromIndex_]로 설정한다.
            1. _toIndex_를 _toIndex_ + 1로 한다.
            1. _fromIndex_를 _fromIndex_ + 1로 한다.
            1. _count_를 _count_ - 1로 한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-privateelement-specification-type">
      <h1>PrivateElement 명세 타입</h1>
      <p>PrivateElement 타입은 private 클래스 필드, 메소드, 접근자 명세에 사용되는 Record입니다. Property Descriptor는 private element에 사용되지 않지만, private 필드는 비구성·비열거·쓰기 가능한 데이터 프로퍼티와, private 메소드는 비구성·비열거·쓰기 불가능한 데이터 프로퍼티와, private 접근자는 비구성·비열거 접근자 프로퍼티와 유사하게 동작합니다.</p>
      <p>PrivateElement 타입의 값은 <emu-xref href="#table-privateelement-fields"></emu-xref>에 정의된 필드를 갖는 Record 값입니다. 이러한 값을 <dfn variants="PrivateElement">PrivateElement</dfn>라 합니다.</p>
      <emu-table id="table-privateelement-fields" caption="PrivateElement 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                [[Kind]] 필드 값이 있을 때
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Key]]
            </td>
            <td>
              전체
            </td>
            <td>
              Private Name
            </td>
            <td>
              필드, 메소드, 접근자의 이름
            </td>
          </tr>
          <tr>
            <td>
              [[Kind]]
            </td>
            <td>
              전체
            </td>
            <td>
              ~field~, ~method~, ~accessor~
            </td>
            <td>
              element의 종류
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              ~field~, ~method~
            </td>
            <td>
              ECMAScript 언어 값
            </td>
            <td>
              필드의 값
            </td>
          </tr>
          <tr>
            <td>
              [[Get]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              함수 객체 또는 *undefined*
            </td>
            <td>
              private 접근자의 getter
            </td>
          </tr>
          <tr>
            <td>
              [[Set]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              함수 객체 또는 *undefined*
            </td>
            <td>
              private 접근자의 setter
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-classfielddefinition-record-specification-type">
      <h1>ClassFieldDefinition Record 명세 타입</h1>
      <p>ClassFieldDefinition 타입은 클래스 필드 명세에 사용되는 Record입니다.</p>
      <p>ClassFieldDefinition 타입의 값은 <emu-xref href="#table-classfielddefinition-fields"></emu-xref>에 정의된 필드를 갖는 Record 값입니다. 이러한 값을 <dfn variants="ClassFieldDefinition Record">ClassFieldDefinition Record</dfn>라 합니다.</p>
      <emu-table id="table-classfielddefinition-fields" caption="ClassFieldDefinition Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Name]]
            </td>
            <td>
              Private Name, 문자열, 심볼
            </td>
            <td>
              필드의 이름
            </td>
          </tr>
          <tr>
            <td>
              [[Initializer]]
            </td>
            <td>
              ECMAScript 함수 객체 또는 ~empty~
            </td>
            <td>
              필드의 초기화 함수(있으면)
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-private-names">
      <h1>Private Name</h1>
      <p><dfn variants="Private Names">Private Name</dfn> 명세 타입은 전역적으로 고유한 값(다른 Private Name과 구별됨, 설령 구별 불가해 보여도)을 설명하는 데 사용됩니다. 이 값은 private 클래스 요소(필드, 메소드, 접근자)의 키를 나타냅니다. 각 Private Name은 불변의 [[Description]] 내부 슬롯을 가지며, 이는 문자열입니다. Private Name은 ECMAScript 객체에 PrivateFieldAdd 또는 PrivateMethodOrAccessorAdd로 설치할 수 있으며, PrivateGet과 PrivateSet을 통해 읽거나 쓸 수 있습니다.</p>
    </emu-clause>

    <emu-clause id="sec-classstaticblockdefinition-record-specification-type">
      <h1>ClassStaticBlockDefinition Record 명세 타입</h1>
      <p><dfn variants="ClassStaticBlockDefinition Records">ClassStaticBlockDefinition Record</dfn>는 클래스 static 초기화 블록의 실행 코드를 캡슐화하는 데 사용되는 Record 값입니다.</p>
      <p>ClassStaticBlockDefinition Record는 <emu-xref href="#table-classstaticblockdefinition-record-fields"></emu-xref>에 나열된 필드를 가집니다.</p>
      <emu-table id="table-classstaticblockdefinition-record-fields" caption="ClassStaticBlockDefinition Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BodyFunction]]
            </td>
            <td>
              ECMAScript 함수 객체
            </td>
            <td>
              클래스 static 초기화 시 호출되는 함수 객체
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>추상 연산(Abstract Operations)</h1>
  <p>이 연산들은 ECMAScript 언어의 일부가 아니며; ECMAScript 언어의 의미론을 명세하기 쉽게 하기 위해 여기에서만 정의됩니다. 이 명세 전반에 걸쳐 보다 특수화된 다른 추상 연산들이 정의됩니다.</p>

  <emu-clause id="sec-type-conversion">
    <h1>타입 변환(Type Conversion)</h1>
    <p>ECMAScript 언어는 필요에 따라 자동으로 암시적 타입 변환을 수행합니다. 특정 구성의 의미론을 명확히 하기 위해 일련의 변환 추상 연산을 정의하는 것이 유용합니다. 변환 추상 연산은 다형적이며; 어떤 ECMAScript 언어 타입의 값이든 받을 수 있습니다. 그러나 다른 명세 타입은 이러한 연산과 함께 사용되지 않습니다.</p>
    <p>BigInt 타입은 ECMAScript 언어에서 암시적 변환이 없습니다; 프로그래머는 다른 타입에서 값을 변환하기 위해 반드시 BigInt를 명시적으로 호출해야 합니다.</p>

    <emu-clause id="sec-toprimitive" type="abstract operation" oldids="table-9">
      <h1>
        ToPrimitive (
          _input_: ECMAScript 언어 값,
          optional _preferredType_: ~string~ 또는 ~number~,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_input_ 인수를 비-Object 타입으로 변환합니다. 객체가 둘 이상의 원시 타입으로 변환 가능하다면 선택적 힌트 _preferredType_을 사용하여 그 타입을 우선할 수 있습니다.</dd>
      </dl>
      <emu-alg>
        1. _input_이 Object이면,
          1. _exoticToPrim_을 ? GetMethod(_input_, %Symbol.toPrimitive%)로 둔다.
          1. _exoticToPrim_이 *undefined*가 아니면,
            1. _preferredType_이 존재하지 않으면,
              1. _hint_를 *"default"*로 둔다.
            1. Else if _preferredType_이 ~string~이면,
              1. _hint_를 *"string"*으로 둔다.
            1. Else,
              1. 단언: _preferredType_은 ~number~이다.
              1. _hint_를 *"number"*로 둔다.
            1. _result_를 ? Call(_exoticToPrim_, _input_, « _hint_ »)로 둔다.
            1. _result_가 Object가 아니면 _result_를 반환한다.
            1. *TypeError* 예외를 던진다.
          1. _preferredType_이 존재하지 않으면 _preferredType_을 ~number~로 둔다.
          1. ? OrdinaryToPrimitive(_input_, _preferredType_)을 반환한다.
        1. _input_을 반환한다.
      </emu-alg>
      <emu-note>
        <p>ToPrimitive가 힌트 없이 호출되면 일반적으로 힌트가 ~number~인 것처럼 동작합니다. 그러나 객체는 %Symbol.toPrimitive% 메서드를 정의하여 이 동작을 재정의할 수 있습니다. 이 명세에 정의된 객체 중 Date( <emu-xref href="#sec-date.prototype-%symbol.toprimitive%"></emu-xref> 참조 )와 Symbol 객체( <emu-xref href="#sec-symbol.prototype-%symbol.toprimitive%"></emu-xref> 참조 )만이 기본 ToPrimitive 동작을 재정의합니다. Date는 힌스가 없는 경우 힌트가 ~string~인 것처럼 취급합니다.</p>
      </emu-note>

      <emu-clause id="sec-ordinarytoprimitive" type="abstract operation">
        <h1>
          OrdinaryToPrimitive (
            _O_: Object,
            _hint_: ~string~ 또는 ~number~,
          ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _hint_가 ~string~이면,
            1. _methodNames_를 « *"toString"*, *"valueOf"* »로 둔다.
          1. Else,
            1. _methodNames_를 « *"valueOf"*, *"toString"* »으로 둔다.
          1. _methodNames_의 각 요소 _name_에 대해,
            1. _method_를 ? Get(_O_, _name_)으로 둔다.
            1. IsCallable(_method_)가 *true*이면,
              1. _result_를 ? Call(_method_, _O_)로 둔다.
              1. _result_가 Object가 아니면 _result_를 반환한다.
          1. *TypeError* 예외를 던진다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toboolean" oldids="table-toboolean-conversions,sec-IsHTMLDDA-internal-slot-to-boolean" type="abstract operation">
      <h1>
        ToBoolean (
          _argument_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 Boolean 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Boolean이면 _argument_를 반환한다.
        1. _argument_가 *undefined*, *null*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *NaN*, *0*<sub>ℤ</sub>, 또는 빈 String 중 하나이면 *false*를 반환한다.
        1. [id="step-to-boolean-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>를 지원하면,
          1. _argument_가 Object이고 [[IsHTMLDDA]] 내부 슬롯을 갖고 있으면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumeric" type="abstract operation">
      <h1>
        ToNumeric (
          _value_: ECMAScript 언어 값,
        ): Number 또는 BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_value_를 Number 또는 BigInt로 변환하여 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _primValue_를 ? ToPrimitive(_value_, ~number~)로 둔다.
        1. _primValue_가 BigInt이면 _primValue_를 반환한다.
        1. ? <emu-meta suppress-effects="user-code">ToNumber(_primValue_)</emu-meta>를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumber" oldids="table-tonumber-conversions" type="abstract operation">
      <h1>
        ToNumber (
          _argument_: ECMAScript 언어 값,
        ): Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 Number 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Number이면 _argument_를 반환한다.
        1. _argument_가 Symbol 또는 BigInt이면 *TypeError* 예외를 던진다.
        1. _argument_가 *undefined*이면 *NaN*을 반환한다.
        1. _argument_가 *null* 또는 *false*이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _argument_가 *true*이면 *1*<sub>𝔽</sub>을 반환한다.
        1. _argument_가 String이면 StringToNumber(_argument_)를 반환한다.
        1. 단언: _argument_는 Object이다.
        1. _primValue_를 ? ToPrimitive(_argument_, ~number~)로 둔다.
        1. 단언: _primValue_는 Object가 아니다.
        1. ? ToNumber(_primValue_)를 반환한다.
      </emu-alg>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>String 타입에 적용된 ToNumber</h1>
        <p>추상 연산 StringToNumber는 다음 문법을 사용하여 String 값을 Number 값으로 변환하는 방법을 지정합니다.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringNumericLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

          StrWhiteSpace :::
            StrWhiteSpaceChar StrWhiteSpace?

          StrWhiteSpaceChar :::
            WhiteSpace
            LineTerminator

          StrNumericLiteral :::
            StrDecimalLiteral
            NonDecimalIntegerLiteral[~Sep]

          StrDecimalLiteral :::
            StrUnsignedDecimalLiteral
            `+` StrUnsignedDecimalLiteral
            `-` StrUnsignedDecimalLiteral

          StrUnsignedDecimalLiteral :::
            `Infinity`
            DecimalDigits[~Sep] `.` DecimalDigits[~Sep]? ExponentPart[~Sep]?
            `.` DecimalDigits[~Sep] ExponentPart[~Sep]?
            DecimalDigits[~Sep] ExponentPart[~Sep]?
        </emu-grammar>
        <p>위에서 명시적으로 정의되지 않은 모든 문법 기호는 숫자 리터럴에 대한 어휘 문법(<emu-xref href="#sec-literals-numeric-literals"></emu-xref>)에서 사용된 정의를 갖습니다.</p>
        <emu-note>
          <p>|StringNumericLiteral|과 |NumericLiteral|의 문법에는 다음과 같은 차이가 있습니다:</p>
          <ul>
            <li>|StringNumericLiteral|은 선행 및/또는 후행 공백 및/또는 줄 종결자를 포함할 수 있습니다.</li>
            <li>십진 |StringNumericLiteral|은 선행 `0` 숫자를 임의 개수 포함할 수 있습니다.</li>
            <li>십진 |StringNumericLiteral|은 부호를 나타내기 위해 `+` 또는 `-`를 포함할 수 있습니다.</li>
            <li>비어 있거나 공백만 포함하는 |StringNumericLiteral|은 *+0*<sub>𝔽</sub>으로 변환됩니다.</li>
            <li>`Infinity` 및 `-Infinity`는 |StringNumericLiteral|로 인식되지만 |NumericLiteral|로는 인식되지 않습니다.</li>
            <li>|StringNumericLiteral|은 |BigIntLiteralSuffix|를 포함할 수 없습니다.</li>
            <li>|StringNumericLiteral|은 |NumericLiteralSeparator|를 포함할 수 없습니다.</li>
          </ul>
        </emu-note>

        <emu-clause id="sec-stringtonumber" type="abstract operation">
          <h1>
            StringToNumber (
              _str_: String,
            ): Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _literal_을 ParseText(_str_, |StringNumericLiteral|)로 둔다.
            1. _literal_이 오류들의 List이면 *NaN*을 반환한다.
            1. _literal_의 StringNumericValue를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-stringnumericvalue" type="sdo" oldids="sec-runtime-semantics-mv-s">
          <h1>런타임 의미론: StringNumericValue ( ): Number</h1>
          <dl class="header">
          </dl>
          <emu-note>
            <p>|StringNumericLiteral|을 Number 값으로 변환하는 과정은 전반적으로 |NumericLiteral|의 NumericValue 결정(<emu-xref href="#sec-literals-numeric-literals"></emu-xref>)과 유사하지만 일부 세부 사항은 다릅니다.</p>
          </emu-note>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. *+0*<sub>𝔽</sub>을 반환한다.
          </emu-alg>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. |StrNumericLiteral|의 StringNumericValue를 반환한다.
          </emu-alg>
          <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
          <emu-alg>
            1. 𝔽(MV of |NonDecimalIntegerLiteral|)을 반환한다.
          </emu-alg>
          <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
          <emu-alg>
            1. _a_를 |StrUnsignedDecimalLiteral|의 StringNumericValue로 둔다.
            1. _a_가 *+0*<sub>𝔽</sub>이면 *-0*<sub>𝔽</sub>을 반환한다.
            1. -_a_를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
          <emu-alg>
            1. *+∞*<sub>𝔽</sub>를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
          <emu-alg>
            1. _a_를 첫 번째 |DecimalDigits|의 MV로 둔다.
            1. 두 번째 |DecimalDigits|가 존재하면,
              1. _b_를 두 번째 |DecimalDigits|의 MV로 둔다.
              1. _n_을 두 번째 |DecimalDigits|의 코드 포인트 수로 둔다.
            1. Else,
              1. _b_를 0으로 둔다.
              1. _n_을 0으로 둔다.
            1. |ExponentPart|가 존재하면 _e_를 |ExponentPart|의 MV로, 아니면 _e_를 0으로 둔다.
            1. RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>)를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. _b_를 |DecimalDigits|의 MV로 둔다.
            1. |ExponentPart|가 존재하면 _e_를 |ExponentPart|의 MV로, 아니면 _e_를 0으로 둔다.
            1. _n_을 |DecimalDigits|의 코드 포인트 수로 둔다.
            1. RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>)를 반환한다.
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. _a_를 |DecimalDigits|의 MV로 둔다.
            1. |ExponentPart|가 존재하면 _e_를 |ExponentPart|의 MV로, 아니면 _e_를 0으로 둔다.
            1. RoundMVResult(_a_ × 10<sup>_e_</sup>)를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-roundmvresult" type="abstract operation">
          <h1>
            RoundMVResult (
              _n_: 수학적 값,
            ): Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>구현 정의 방식으로 _n_을 Number로 변환합니다. 이 추상 연산의 목적상, 어떤 자릿수가 0이 아니거나 그 왼쪽에 0이 아닌 자릿수가 있고 오른쪽에 0이 아닌 자릿수가 있는 경우 유효 자릿수입니다. 또한 “수학적 값을 나타내는 표현”의 수학적 값은 “수학적 값의 10진 표현”의 역입니다.</dd>
          </dl>
          <emu-alg>
            1. _n_의 10진 표현이 20개 이하의 유효 자릿수를 가지면 𝔽(_n_)을 반환한다.
            1. _option1_을: _n_의 10진 표현에서 20번째 이후 모든 유효 자릿수를 0으로 대체한 결과가 나타내는 수학적 값으로 둔다.
            1. _option2_를: _n_의 10진 표현에서 20번째 이후 모든 유효 자릿수를 0으로 대체한 다음 20번째 위치를 (필요한 자리 올림과 함께) 1 증가시킨 결과가 나타내는 수학적 값으로 둔다.
            1. _chosen_을 구현 정의로 _option1_ 또는 _option2_ 중 하나로 둔다.
            1. 𝔽(_chosen_)을 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tointegerorinfinity" type="abstract operation" oldids="sec-tointeger">
      <h1>
        ToIntegerOrInfinity (
          _argument_: ECMAScript 언어 값,
        ): 정수, +&infin; 또는 -&infin; 중 하나를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 그 Number 값에서 소수 부분을 절단한 정수로, 혹은 그 Number 값이 무한대일 경우 +∞ 또는 -∞로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 0을 반환한다.
        1. _number_가 *+∞*<sub>𝔽</sub>이면 +∞를 반환한다.
        1. _number_가 *-∞*<sub>𝔽</sub>이면 -∞를 반환한다.
        1. truncate(ℝ(_number_))를 반환한다.
      </emu-alg>
      <emu-note>
        𝔽(ToIntegerOrInfinity(_x_))는 어떤 _x_에 대해서도 *-0*<sub>𝔽</sub>을 반환하지 않습니다. 소수 부분 절단은 _x_를 수학적 값으로 변환한 후 수행됩니다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint32" type="abstract operation">
      <h1>
        ToInt32 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 𝔽(-2<sup>31</sup>)부터 𝔽(2<sup>31</sup> - 1)까지(포함) 2<sup>32</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int32bit_를 _int_ modulo 2<sup>32</sup>로 둔다.
        1. _int32bit_ ≥ 2<sup>31</sup>이면 𝔽(_int32bit_ - 2<sup>32</sup>)을, 아니면 𝔽(_int32bit_)을 반환한다.
      </emu-alg>
      <emu-note>
        <p>위 정의에 따른 ToInt32의 성질:</p>
        <ul>
          <li>ToInt32 추상 연산은 멱등성: 자신의 결과에 다시 적용해도 값은 변하지 않습니다.</li>
          <li>모든 _x_에 대해 ToInt32(ToUint32(_x_))는 ToInt32(_x_)와 동일한 값입니다. (이 후속 성질을 보존하기 위해 *+∞*<sub>𝔽</sub>와 *-∞*<sub>𝔽</sub>이 *+0*<sub>𝔽</sub>으로 매핑됩니다.)</li>
          <li>ToInt32는 *-0*<sub>𝔽</sub>을 *+0*<sub>𝔽</sub>으로 매핑합니다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-touint32" type="abstract operation">
      <h1>
        ToUint32 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>32</sup> - 1)까지(포함) 2<sup>32</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int32bit_를 _int_ modulo 2<sup>32</sup>로 둔다.
        1. [id="step-touint32-return"] 𝔽(_int32bit_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>위 정의에 따른 ToUint32의 성질:</p>
        <ul>
          <li><emu-xref href="#step-touint32-return"></emu-xref> 단계가 ToUint32와 ToInt32의 유일한 차이점입니다.</li>
          <li>ToUint32 추상 연산은 멱등성입니다.</li>
          <li>모든 _x_에 대해 ToUint32(ToInt32(_x_))는 ToUint32(_x_)와 동일합니다. (*+∞*<sub>𝔽</sub>, *-∞*<sub>𝔽</sub>이 *+0*<sub>𝔽</sub>으로 매핑되는 이유.)</li>
          <li>ToUint32는 *-0*<sub>𝔽</sub>을 *+0*<sub>𝔽</sub>으로 매핑합니다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint16" type="abstract operation">
      <h1>
        ToInt16 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 𝔽(-2<sup>15</sup>)부터 𝔽(2<sup>15</sup> - 1)까지(포함) 2<sup>16</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int16bit_를 _int_ modulo 2<sup>16</sup>으로 둔다.
        1. _int16bit_ ≥ 2<sup>15</sup>이면 𝔽(_int16bit_ - 2<sup>16</sup>)을, 아니면 𝔽(_int16bit_)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint16" type="abstract operation">
      <h1>
        ToUint16 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 𝔽(2<sup>16</sup> - 1)까지(포함) 2<sup>16</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. [id="step-touint16-mod"] _int16bit_를 _int_ modulo 2<sup>16</sup>으로 둔다.
        1. 𝔽(_int16bit_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>위 정의에 따른 ToUint16의 성질:</p>
        <ul>
          <li><emu-xref href="#step-touint16-mod"></emu-xref> 단계에서 2<sup>16</sup>을 2<sup>32</sup> 대신 사용하는 점이 ToUint32와 ToUint16의 유일한 차이입니다.</li>
          <li>ToUint16은 *-0*<sub>𝔽</sub>을 *+0*<sub>𝔽</sub>으로 매핑합니다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint8" type="abstract operation">
      <h1>
        ToInt8 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *-128*<sub>𝔽</sub>에서 *127*<sub>𝔽</sub>까지(포함) 2<sup>8</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int8bit_를 _int_ modulo 2<sup>8</sup>로 둔다.
        1. _int8bit_ ≥ 2<sup>7</sup>이면 𝔽(_int8bit_ - 2<sup>8</sup>)을, 아니면 𝔽(_int8bit_)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8" type="abstract operation">
      <h1>
        ToUint8 (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 *255*<sub>𝔽</sub>까지(포함) 2<sup>8</sup>개의 적분 Number 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 유한이 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _int_를 truncate(ℝ(_number_))로 둔다.
        1. _int8bit_를 _int_ modulo 2<sup>8</sup>로 둔다.
        1. 𝔽(_int8bit_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8clamp" type="abstract operation">
      <h1>
        ToUint8Clamp (
          _argument_: ECMAScript 언어 값,
        ): 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *+0*<sub>𝔽</sub>에서 *255*<sub>𝔽</sub>까지(포함) 2<sup>8</sup>개의 적분 Number 값 중 하나로 클램프(clamp)하고 반올림합니다.</dd>
      </dl>
      <emu-alg>
        1. _number_를 ? ToNumber(_argument_)로 둔다.
        1. _number_가 *NaN*이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. _mv_를 _number_의 확장된 수학적 값으로 둔다.
        1. _clamped_를 _mv_를 0과 255 사이로 클램프한 결과로 둔다.
        1. _f_를 floor(_clamped_)로 둔다.
        1. _clamped_ &lt; _f_ + 0.5이면 𝔽(_f_)를 반환한다.
        1. _clamped_ > _f_ + 0.5이면 𝔽(_f_ + 1)을 반환한다.
        1. _f_가 짝수이면 𝔽(_f_)를; 아니면 𝔽(_f_ + 1)을 반환한다.
      </emu-alg>
      <emu-note>
        <p>대부분 다른 ECMAScript 정수 변환 연산과 달리 ToUint8Clamp는 비정수 값을 절단(truncate)하지 않고 반올림합니다. 또한 “round half up”을 사용하는 <emu-xref href="#sec-math.round">`Math.round`</emu-xref>와 달리 “round half to even” 절충 규칙을 사용합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-tobigint" type="abstract operation">
      <h1>
        ToBigInt (
          _argument_: ECMAScript 언어 값,
        ): BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 BigInt 값으로 변환하며, Number에서의 암시적 변환이 필요하다면 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _prim_을 ? ToPrimitive(_argument_, ~number~)로 둔다.
        1. <emu-xref href="#table-tobigint"></emu-xref>의 _prim_이 대응하는 값을 반환한다.
      </emu-alg>
      <emu-table id="table-tobigint" caption="BigInt 변환">
        <table>
          <thead>
            <tr>
              <th>
                Argument 타입
              </th>
              <th>
                결과
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              _prim_이 *true*이면 `1n`, *false*이면 `0n`을 반환한다.
            </td>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              _prim_을 반환한다.
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              <emu-alg>
                1. _n_을 StringToBigInt(_prim_)로 둔다.
                1. _n_이 *undefined*이면 *SyntaxError* 예외를 던진다.
                1. _n_을 반환한다.
              </emu-alg>
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              *TypeError* 예외를 던진다.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-stringtobigint" type="abstract operation">
      <h1>
        StringToBigInt (
          _str_: String,
        ): BigInt 또는 *undefined*
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _literal_을 ParseText(_str_, |StringIntegerLiteral|)로 둔다.
        1. _literal_이 오류들의 List이면 *undefined*를 반환한다.
        1. _mv_를 _literal_의 MV로 둔다.
        1. 단언: _mv_는 정수이다.
        1. ℤ(_mv_)를 반환한다.
      </emu-alg>

      <emu-clause id="sec-stringintegerliteral-grammar">
        <h1>StringIntegerLiteral 문법</h1>
        <p>StringToBigInt는 다음 문법을 사용합니다.</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringIntegerLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?

          StrIntegerLiteral :::
            SignedInteger[~Sep]
            NonDecimalIntegerLiteral[~Sep]
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-mv-for-stringintegerliteral">
        <h1>런타임 의미론: MV</h1>
        <ul>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace?</emu-grammar>의 MV는 0이다.
          </li>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?</emu-grammar>의 MV는 |StrIntegerLiteral|의 MV이다.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tobigint64" type="abstract operation">
      <h1>
        ToBigInt64 (
          _argument_: ECMAScript 언어 값,
        ): BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 ℤ(-2<sup>63</sup>)부터 ℤ(2<sup>63</sup> - 1)까지(포함) 2<sup>64</sup>개의 BigInt 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _n_을 ? ToBigInt(_argument_)로 둔다.
        1. _int64bit_를 ℝ(_n_) modulo 2<sup>64</sup>로 둔다.
        1. _int64bit_ ≥ 2<sup>63</sup>이면 ℤ(_int64bit_ - 2<sup>64</sup>)을, 아니면 ℤ(_int64bit_)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tobiguint64" type="abstract operation">
      <h1>
        ToBigUint64 (
          _argument_: ECMAScript 언어 값,
        ): BigInt를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 *0*<sub>ℤ</sub>에서 ℤ(2<sup>64</sup> - 1)까지(포함) 2<sup>64</sup>개의 BigInt 값 중 하나로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _n_을 ? ToBigInt(_argument_)로 둔다.
        1. _int64bit_를 ℝ(_n_) modulo 2<sup>64</sup>로 둔다.
        1. ℤ(_int64bit_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tostring" oldids="table-tostring-conversions" type="abstract operation">
      <h1>
        ToString (
          _argument_: ECMAScript 언어 값,
        ): String을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 String 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 String이면 _argument_를 반환한다.
        1. _argument_가 Symbol이면 *TypeError* 예외를 던진다.
        1. _argument_가 *undefined*이면 *"undefined"*를 반환한다.
        1. _argument_가 *null*이면 *"null"*을 반환한다.
        1. _argument_가 *true*이면 *"true"*를 반환한다.
        1. _argument_가 *false*이면 *"false"*를 반환한다.
        1. _argument_가 Number이면 Number::toString(_argument_, 10)을 반환한다.
        1. _argument_가 BigInt이면 BigInt::toString(_argument_, 10)을 반환한다.
        1. 단언: _argument_는 Object이다.
        1. _primValue_를 ? ToPrimitive(_argument_, ~string~)으로 둔다.
        1. 단언: _primValue_는 Object가 아니다.
        1. ? ToString(_primValue_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-toobject" type="abstract operation" oldids="table-toobject-conversions,table-13">
      <h1>
        ToObject (
          _argument_: ECMAScript 언어 값,
        ): Object를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 Object 타입 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 *undefined* 또는 *null*이면 *TypeError* 예외를 던진다.
        1. _argument_가 Boolean이면 [[BooleanData]] 내부 슬롯이 _argument_로 설정된 새 Boolean 객체를 반환한다. Boolean 객체 설명은 <emu-xref href="#sec-boolean-objects"></emu-xref> 참조.
        1. _argument_가 Number이면 [[NumberData]] 내부 슬롯이 _argument_로 설정된 새 Number 객체를 반환한다. Number 객체 설명은 <emu-xref href="#sec-number-objects"></emu-xref> 참조.
        1. _argument_가 String이면 [[StringData]] 내부 슬롯이 _argument_로 설정된 새 String 객체를 반환한다. String 객체 설명은 <emu-xref href="#sec-string-objects"></emu-xref> 참조.
        1. _argument_가 Symbol이면 [[SymbolData]] 내부 슬롯이 _argument_로 설정된 새 Symbol 객체를 반환한다. Symbol 객체 설명은 <emu-xref href="#sec-symbol-objects"></emu-xref> 참조.
        1. _argument_가 BigInt이면 [[BigIntData]] 내부 슬롯이 _argument_로 설정된 새 BigInt 객체를 반환한다. BigInt 객체 설명은 <emu-xref href="#sec-bigint-objects"></emu-xref> 참조.
        1. 단언: _argument_는 Object이다.
        1. _argument_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-topropertykey" type="abstract operation">
      <h1>
        ToPropertyKey (
          _argument_: ECMAScript 언어 값,
        ): 프로퍼티 키를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 프로퍼티 키로 사용할 수 있는 값으로 변환합니다.</dd>
      </dl>
      <emu-alg>
        1. _key_를 ? ToPrimitive(_argument_, ~string~)으로 둔다.
        1. _key_가 Symbol이면
          1. _key_를 반환한다.
        1. ! ToString(_key_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolength" type="abstract operation">
      <h1>
        ToLength (
          _argument_: ECMAScript 언어 값,
        ): 음이 아닌 적분 Number를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_를 배열 유사 객체의 length로 사용 가능하도록 음이 아닌 적분 Number로 클램프(clamp) 및 절단(truncate)합니다.</dd>
      </dl>
      <emu-alg>
        1. _len_을 ? ToIntegerOrInfinity(_argument_)로 둔다.
        1. _len_ ≤ 0이면 *+0*<sub>𝔽</sub>을 반환한다.
        1. 𝔽(min(_len_, 2<sup>53</sup> - 1))을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalnumericindexstring" type="abstract operation">
      <h1>
        CanonicalNumericIndexString (
          _argument_: String,
        ): Number 또는 *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 *"-0"*이거나 어떤 Number 값 _n_에 대해 ToString(_n_)과 정확히 일치하면 해당 Number 값을 반환합니다. 그렇지 않으면 *undefined*를 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 *"-0"*이면 *-0*<sub>𝔽</sub>을 반환한다.
        1. _n_을 ! ToNumber(_argument_)로 둔다.
        1. ! ToString(_n_)이 _argument_이면 _n_을 반환한다.
        1. *undefined*를 반환한다.
      </emu-alg>
      <p><dfn variants="canonical numeric strings">canonical numeric string</dfn>은 CanonicalNumericIndexString 추상 연산이 *undefined*를 반환하지 않는 모든 String입니다.</p>
    </emu-clause>

    <emu-clause id="sec-toindex" type="abstract operation">
      <h1>
        ToIndex (
          _value_: ECMAScript 언어 값,
        ): 음이 아닌 정수를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_value_를 정수로 변환하고, 그 정수가 음이 아니며 정수 인덱스에 대응되면 그 정수를 반환합니다. 그렇지 않으면 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _integer_를 ? ToIntegerOrInfinity(_value_)로 둔다.
        1. _integer_가 0에서 2<sup>53</sup> - 1 (포함) 사이에 없으면 *RangeError* 예외를 던진다.
        1. _integer_를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>테스트 및 비교 연산(Testing and Comparison Operations)</h1>

    <emu-clause id="sec-requireobjectcoercible" type="abstract operation" oldids="table-requireobjectcoercible-results,table-14">
      <h1>
        RequireObjectCoercible (
          _argument_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 ToObject로 Object로 변환될 수 없는 값이면 에러를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 *undefined* 또는 *null*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isarray" type="abstract operation">
      <h1>
        IsArray (
          _argument_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _argument_가 Array 이국 객체이면 *true*를 반환한다.
        1. _argument_가 Proxy 이국 객체이면,
          1. ? ValidateNonRevokedProxy(_argument_)를 수행한다.
          1. _proxyTarget_을 _argument_.[[ProxyTarget]]으로 둔다.
          1. ? IsArray(_proxyTarget_)을 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iscallable" type="abstract operation">
      <h1>
        IsCallable (
          _argument_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 [[Call]] 내부 메소드를 가진 호출 가능 함수인지 결정합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _argument_가 [[Call]] 내부 메소드를 가지면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isconstructor" type="abstract operation">
      <h1>
        IsConstructor (
          _argument_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_argument_가 [[Construct]] 내부 메소드를 가진 함수 객체인지 결정합니다.</dd>
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _argument_가 [[Construct]] 내부 메소드를 가지면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isextensible-o" type="abstract operation">
      <h1>
        IsExtensible (
          _O_: Object,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_에 추가 프로퍼티를 더할 수 있는지 결정하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[IsExtensible]]</emu-meta>()를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isregexp" type="abstract operation">
      <h1>
        IsRegExp (
          _argument_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _argument_가 Object가 아니면 *false*를 반환한다.
        1. _matcher_를 ? Get(_argument_, %Symbol.match%)로 둔다.
        1. _matcher_가 *undefined*가 아니면 ToBoolean(_matcher_)를 반환한다.
        1. _argument_가 [[RegExpMatcher]] 내부 슬롯을 가지면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstringwellformedunicode" type="abstract operation">
      <h1>
        Static Semantics: IsStringWellFormedUnicode (
          _string_: String,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd><emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>에 설명된 대로 _string_을 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하고 이것이 <a href="http://www.unicode.org/glossary/#well_formed_code_unit_sequence">well formed</a> UTF-16 시퀀스인지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. _len_을 _string_의 길이로 둔다.
        1. _k_를 0으로 둔다.
        1. _k_ &lt; _len_ 동안 반복,
          1. _cp_를 CodePointAt(_string_, _k_)로 둔다.
          1. _cp_.[[IsUnpairedSurrogate]]가 *true*이면 *false*를 반환한다.
          1. _k_를 _k_ + _cp_.[[CodeUnitCount]]로 둔다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sametype" type="abstract operation">
      <h1>
        SameType (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>두 인수가 같은 타입인지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. _x_가 *undefined*이고 _y_가 *undefined*이면 *true*를 반환한다.
        1. _x_가 *null*이고 _y_가 *null*이면 *true*를 반환한다.
        1. _x_가 Boolean이고 _y_가 Boolean이면 *true*를 반환한다.
        1. _x_가 Number이고 _y_가 Number이면 *true*를 반환한다.
        1. _x_가 BigInt이고 _y_가 BigInt이면 *true*를 반환한다.
        1. _x_가 Symbol이고 _y_가 Symbol이면 *true*를 반환한다.
        1. _x_가 String이고 _y_가 String이면 *true*를 반환한다.
        1. _x_가 Object이고 _y_가 Object이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-samevalue" type="abstract operation">
      <h1>
        SameValue (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>두 인수가 같은 값인지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *false*이면 *false*를 반환한다.
        1. _x_가 Number이면,
          1. Number::sameValue(_x_, _y_)를 반환한다.
        1. SameValueNonNumber(_x_, _y_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 알고리즘은 모든 *NaN* 값을 동등하게 취급하고 *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>을 구분한다는 점에서 IsStrictlyEqual 알고리즘과 다릅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluezero" type="abstract operation">
      <h1>
        SameValueZero (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>두 인수가 같은 값인지 ( *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>의 차이를 무시하고 ) 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *false*이면 *false*를 반환한다.
        1. _x_가 Number이면,
          1. Number::sameValueZero(_x_, _y_)를 반환한다.
        1. SameValueNonNumber(_x_, _y_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>SameValueZero는 *+0*<sub>𝔽</sub>와 *-0*<sub>𝔽</sub>을 동일하게 취급한다는 점만 SameValue와 다릅니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" type="abstract operation" oldids="sec-samevaluenonnumeric">
      <h1>
        SameValueNonNumber (
          _x_: Number가 아닌 ECMAScript 언어 값,
          _y_: Number가 아닌 ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 단언: SameType(_x_, _y_)는 *true*이다.
        1. _x_가 *undefined* 또는 *null*이면 *true*를 반환한다.
        1. _x_가 BigInt이면
          1. BigInt::equal(_x_, _y_)를 반환한다.
        1. _x_가 String이면
          1. _x_와 _y_가 동일 길이이며 같은 위치에 동일 코드 유닛을 가지면 *true*, 아니면 *false*를 반환한다.
        1. _x_가 Boolean이면
          1. _x_와 _y_가 모두 *true* 또는 모두 *false*이면 *true*, 아니면 *false*를 반환한다.
        1. 주: 다른 모든 ECMAScript 언어 값은 동일성(identity)으로 비교된다.
        1. _x_가 _y_이면 *true*, 아니면 *false*를 반환한다.
      </emu-alg>
      <emu-note>
        설명을 위해 일부 경우는 필요 없더라도 별도로 다룹니다.
      </emu-note>
      <emu-note>
        "_x_ is _y_"의 구체적 의미는 <emu-xref href="#sec-identity"></emu-xref>에 자세히 있습니다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islessthan" type="abstract operation" oldids="sec-abstract-relational-comparison">
      <h1>
        IsLessThan (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
          _LeftFirst_: Boolean,
        ): Boolean 또는 *undefined*를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_x_ &lt; _y_ 비교의 의미론을 제공하며, *true*, *false*, 또는 (적어도 한 피연산자가 *NaN*임을 나타내는) *undefined*를 반환합니다. _LeftFirst_ 플래그는 _x_, _y_에 잠재적으로 부작용 있는 연산의 순서를 제어합니다. 이는 ECMAScript가 표현식을 좌→우로 평가하도록 규정하기 때문에 필요합니다. _LeftFirst_가 *true*이면 _x_ 매개변수는 _y_ 매개변수 표현식의 왼쪽에 오는 표현식에 해당합니다. *false*이면 반대이며 연산은 _x_ 이전에 _y_에 수행되어야 합니다.</dd>
      </dl>
      <emu-alg>
        1. _LeftFirst_가 *true*이면,
          1. _px_를 ? ToPrimitive(_x_, ~number~)로 둔다.
          1. _py_를 ? ToPrimitive(_y_, ~number~)로 둔다.
        1. Else,
          1. 주: 좌→우 평가를 보존하기 위해 평가 순서를 반전해야 한다.
          1. _py_를 ? ToPrimitive(_y_, ~number~)로 둔다.
          1. _px_를 ? ToPrimitive(_x_, ~number~)로 둔다.
        1. [id="step-arc-string-check"] _px_가 String이고 _py_가 String이면,
          1. _lx_를 _px_의 길이로 둔다.
          1. _ly_를 _py_의 길이로 둔다.
          1. 0 ≤ _i_ &lt; min(_lx_, _ly_)인 각 정수 _i_에 대해 오름차순으로,
            1. _cx_를 _px_의 인덱스 _i_ 위치 코드 유닛의 숫자 값으로 둔다.
            1. _cy_를 _py_의 인덱스 _i_ 위치 코드 유닛의 숫자 값으로 둔다.
            1. _cx_ &lt; _cy_이면 *true*를 반환한다.
            1. _cx_ > _cy_이면 *false*를 반환한다.
          1. _lx_ &lt; _ly_이면 *true*, 아니면 *false*를 반환한다.
        1. Else,
          1. _px_가 BigInt이고 _py_가 String이면,
            1. _ny_를 StringToBigInt(_py_)로 둔다.
            1. _ny_가 *undefined*이면 *undefined*를 반환한다.
            1. BigInt::lessThan(_px_, _ny_)를 반환한다.
          1. _px_가 String이고 _py_가 BigInt이면,
            1. _nx_를 StringToBigInt(_px_)로 둔다.
            1. _nx_가 *undefined*이면 *undefined*를 반환한다.
            1. BigInt::lessThan(_nx_, _py_)를 반환한다.
          1. 주: _px_, _py_는 원시 값이므로 평가 순서는 중요하지 않다.
          1. _nx_를 ? <emu-meta suppress-effects="user-code">ToNumeric(_px_)</emu-meta>로 둔다.
          1. _ny_를 ? <emu-meta suppress-effects="user-code">ToNumeric(_py_)</emu-meta>로 둔다.
          1. SameType(_nx_, _ny_)가 *true*이면,
            1. _nx_가 Number이면
              1. Number::lessThan(_nx_, _ny_)를 반환한다.
            1. Else,
              1. 단언: _nx_는 BigInt이다.
              1. BigInt::lessThan(_nx_, _ny_)를 반환한다.
          1. 단언: _nx_는 BigInt이고 _ny_는 Number, 또는 _nx_는 Number이고 _ny_는 BigInt.
          1. _nx_ 또는 _ny_가 *NaN*이면 *undefined*를 반환한다.
          1. _nx_가 *-∞*<sub>𝔽</sub>이거나 _ny_가 *+∞*<sub>𝔽</sub>이면 *true*를 반환한다.
          1. _nx_가 *+∞*<sub>𝔽</sub>이거나 _ny_가 *-∞*<sub>𝔽</sub>이면 *false*를 반환한다.
          1. ℝ(_nx_) &lt; ℝ(_ny_)이면 *true*, 아니면 *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-arc-string-check"></emu-xref> 단계는 덧셈 연산자 `+`를 처리하는 알고리즘(<emu-xref href="#sec-applystringornumericbinaryoperator"></emu-xref>)의 <emu-xref href="#step-binary-op-string-check"></emu-xref> 단계와 논리 OR 대신 논리 AND를 사용하는 점에서 다릅니다.</p>
      </emu-note>
      <emu-note>
        <p>String 비교는 UTF-16 코드 유닛 값 시퀀스에 대한 단순한 사전식(lexicographic) 순서를 사용합니다. Unicode 명세에서 정의한 더 복잡하고 의미론 지향적인 문자/문자열 동등성이나 정렬 순서를 사용하려 하지 않습니다. 따라서 Unicode 표준에 따라 정규적으로 동등하지만 정규화 형태가 다른 String 값은 불일치로 판정될 수 있습니다. 또한 surrogate pair를 포함한 String의 경우 코드 유닛 기반 사전식 순서는 코드 포인트 기반 순서와 다를 수 있습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islooselyequal" type="abstract operation" oldids="sec-abstract-equality-comparison,sec-IsHTMLDDA-internal-slot-aec">
      <h1>
        IsLooselyEqual (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`==` 연산자의 의미론을 제공합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *true*이면,
          1. IsStrictlyEqual(_x_, _y_)를 반환한다.
        1. _x_가 *null*이고 _y_가 *undefined*이면 *true*를 반환한다.
        1. _x_가 *undefined*이고 _y_가 *null*이면 *true*를 반환한다.
        1. [id="step-abstract-equality-comparison-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>를 지원하면,
          1. _x_가 Object이고 _x_가 [[IsHTMLDDA]] 내부 슬롯을 가지며 _y_가 *undefined* 또는 *null*이면 *true*를 반환한다.
          1. _x_가 *undefined* 또는 *null*이고 _y_가 Object이며 _y_가 [[IsHTMLDDA]] 내부 슬롯을 가지면 *true*를 반환한다.
        1. _x_가 Number이고 _y_가 String이면 ! IsLooselyEqual(_x_, ! ToNumber(_y_))를 반환한다.
        1. _x_가 String이고 _y_가 Number이면 ! IsLooselyEqual(! ToNumber(_x_), _y_)를 반환한다.
        1. _x_가 BigInt이고 _y_가 String이면,
          1. _n_을 StringToBigInt(_y_)로 둔다.
          1. _n_이 *undefined*이면 *false*를 반환한다.
          1. ! IsLooselyEqual(_x_, _n_)을 반환한다.
        1. _x_가 String이고 _y_가 BigInt이면 ! IsLooselyEqual(_y_, _x_)를 반환한다.
        1. _x_가 Boolean이면 ! IsLooselyEqual(! ToNumber(_x_), _y_)를 반환한다.
        1. _y_가 Boolean이면 ! IsLooselyEqual(_x_, ! ToNumber(_y_))를 반환한다.
        1. _x_가 String, Number, BigInt, Symbol 중 하나이고 _y_가 Object이면 ! IsLooselyEqual(_x_, ? ToPrimitive(_y_))를 반환한다.
        1. _x_가 Object이고 _y_가 String, Number, BigInt, Symbol 중 하나이면 ! IsLooselyEqual(? ToPrimitive(_x_), _y_)를 반환한다.
        1. _x_가 BigInt이고 _y_가 Number이거나 _x_가 Number이고 _y_가 BigInt이면,
          1. _x_ 또는 _y_가 유한이 아니면 *false*를 반환한다.
          1. ℝ(_x_) = ℝ(_y_)이면 *true*, 아니면 *false*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstrictlyequal" type="abstract operation" oldids="sec-strict-equality-comparison">
      <h1>
        IsStrictlyEqual (
          _x_: ECMAScript 언어 값,
          _y_: ECMAScript 언어 값,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`===` 연산자의 의미론을 제공합니다.</dd>
      </dl>
      <emu-alg>
        1. SameType(_x_, _y_)가 *false*이면 *false*를 반환한다.
        1. _x_가 Number이면,
          1. Number::equal(_x_, _y_)를 반환한다.
        1. SameValueNonNumber(_x_, _y_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 알고리즘은 부호 있는 0 및 NaN 처리에서 SameValue 알고리즘과 다릅니다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-objects">
    <h1>객체에 대한 연산(Operations on Objects)</h1>

    <emu-clause id="sec-makebasicobject" type="abstract operation">
      <h1>
        MakeBasicObject (
          _internalSlotsList_: 내부 슬롯 이름들의 List,
        ): Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>알고리즘적으로 생성되는 모든 ECMAScript 객체(ordinary 및 exotic 포함)의 근원입니다. 모든 객체 생성에서 사용되는 공통 단계를 분리하고 객체 생성을 중앙화합니다.</dd>
      </dl>

      <emu-alg>
        1. _internalSlotsList_를 _internalSlotsList_와 « [[PrivateElements]] »의 list-concatenation으로 설정한다.
        1. _internalSlotsList_의 각 이름에 대한 내부 슬롯을 가진 새로 생성된 객체 _obj_를 둔다.
        1. 주: <emu-xref href="#sec-object-internal-methods-and-internal-slots" title></emu-xref>에 설명된 대로 달리 지정되지 않으면 각 내부 슬롯의 초기값은 *undefined*이다.
        1. _obj_.[[PrivateElements]]를 새 빈 List로 둔다.
        1. _obj_의 essential 내부 메소드를 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>에 지정된 기본 ordinary object 정의로 설정한다.
        1. 단언: 호출자가 _obj_의 [[GetPrototypeOf]]와 [[SetPrototypeOf]] essential 내부 메소드를 모두 재정의하지 않을 경우 _internalSlotsList_는 [[Prototype]]을 포함한다.
        1. 단언: 호출자가 _obj_의 [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]] essential 내부 메소드를 모두 재정의하지 않을 경우 _internalSlotsList_는 [[Extensible]]을 포함한다.
        1. _internalSlotsList_가 [[Extensible]]을 포함하면 _obj_.[[Extensible]]를 *true*로 둔다.
        1. _obj_를 반환한다.
      </emu-alg>

      <emu-note>
        <p>이 명세 내에서 exotic 객체는 ArrayCreate, BoundFunctionCreate 같은 추상 연산에서 먼저 MakeBasicObject를 호출하여 기본 객체를 얻고 그 후 그 객체의 일부 또는 모든 내부 메소드를 재정의하여 생성됩니다. exotic 객체 생성을 캡슐화하기 위해 객체의 essential 내부 메소드는 그러한 연산 외부에서는 수정되지 않습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-o-p" type="abstract operation">
      <h1>
        Get (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 특정 프로퍼티 값을 가져오는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _O_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getv" type="abstract operation">
      <h1>
        GetV (
          _V_: ECMAScript 언어 값,
          _P_: 프로퍼티 키,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ECMAScript 언어 값의 특정 프로퍼티 값을 가져오는 데 사용됩니다. 값이 객체가 아니면 해당 타입에 적합한 래퍼 객체를 사용하여 프로퍼티 조회가 수행됩니다.</dd>
      </dl>
      <emu-alg>
        1. _O_를 ? ToObject(_V_)로 둔다.
        1. ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _V_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-set-o-p-v-throw" type="abstract operation">
      <h1>
        Set (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
          _Throw_: Boolean,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 특정 프로퍼티 값을 설정하는 데 사용됩니다. _V_는 프로퍼티의 새 값입니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? <emu-meta effects="user-code">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_)로 둔다.
        1. _success_가 *false*이고 _Throw_가 *true*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdataproperty" type="abstract operation">
      <h1>
        CreateDataProperty (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 새로운 own 프로퍼티를 생성하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _newDesc_를 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }로 둔다.
        1. ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 추상 연산은 ECMAScript 대입 연산자가 생성하는 프로퍼티와 동일 기본 속성 값을 가진 프로퍼티를 생성합니다. 일반적으로 프로퍼티는 미존재 상태입니다. 존재하고 비구성이거나 _O_가 비확장 가능이면 [[DefineOwnProperty]]는 *false*를 반환합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createdatapropertyorthrow" type="abstract operation">
      <h1>
        CreateDataPropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 새로운 own 프로퍼티를 생성하는 데 사용되며, 요청된 프로퍼티 갱신이 수행될 수 없으면 *TypeError* 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? CreateDataProperty(_O_, _P_, _V_)로 둔다.
        1. _success_가 *false*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 추상 연산은 ECMAScript 대입 연산자가 생성하는 프로퍼티와 동일 기본 속성을 가지는 프로퍼티를 생성합니다. 일반적으로 프로퍼티는 미존재 상태입니다. 존재하고 비구성이거나 _O_가 비확장 가능이면 [[DefineOwnProperty]]는 *false*를 반환하여 이 연산이 *TypeError*를 던지게 됩니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createnonenumerabledatapropertyorthrow" type="abstract operation">
      <h1>
        CreateNonEnumerableDataPropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
          _V_: ECMAScript 언어 값,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ordinary 객체의 새 비열거 own 프로퍼티를 생성하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _O_는 비구성 프로퍼티가 없는 ordinary, 확장 가능한 객체이다.
        1. _newDesc_를 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }로 둔다.
        1. ! DefinePropertyOrThrow(_O_, _P_, _newDesc_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 추상 연산은 ECMAScript 대입 연산자가 생성하는 프로퍼티와 동일 기본 속성을 가지되 열거 가능하지 않은 프로퍼티를 생성합니다. 일반적으로 프로퍼티는 미존재 상태입니다. 존재하는 경우 DefinePropertyOrThrow는 정상적으로 완료됨이 보장됩니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-definepropertyorthrow" type="abstract operation">
      <h1>
        DefinePropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
          _desc_: Property Descriptor,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 [[DefineOwnProperty]] 내부 메소드를 호출하되, 요청된 프로퍼티 갱신이 수행될 수 없으면 *TypeError* 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_)로 둔다.
        1. _success_가 *false*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-deletepropertyorthrow" type="abstract operation">
      <h1>
        DeletePropertyOrThrow (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 특정 own 프로퍼티를 제거하는 데 사용됩니다. 프로퍼티가 비구성이면 예외를 던집니다.</dd>
      </dl>
      <emu-alg>
        1. _success_를 ? <emu-meta effects="user-code">_O_.[[Delete]]</emu-meta>(_P_)로 둔다.
        1. _success_가 *false*이면 *TypeError* 예외를 던진다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getmethod" type="abstract operation">
      <h1>
        GetMethod (
          _V_: ECMAScript 언어 값,
          _P_: 프로퍼티 키,
        ): 함수 객체 또는 *undefined*를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>프로퍼티 값이 함수일 것으로 기대되는 ECMAScript 언어 값의 특정 프로퍼티 값을 얻는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _func_을 ? GetV(_V_, _P_)로 둔다.
        1. _func_이 *undefined* 또는 *null*이면 *undefined*를 반환한다.
        1. IsCallable(_func_)가 *false*이면 *TypeError* 예외를 던진다.
        1. _func_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasproperty" type="abstract operation">
      <h1>
        HasProperty (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체가 지정된 프로퍼티 키를 가진 프로퍼티(own 또는 상속)를 갖는지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. ? <emu-meta effects="user-code">_O_.[[HasProperty]]</emu-meta>(_P_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasownproperty" type="abstract operation">
      <h1>
        HasOwnProperty (
          _O_: Object,
          _P_: 프로퍼티 키,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체가 지정된 프로퍼티 키를 가진 own 프로퍼티를 갖는지 판정합니다.</dd>
      </dl>
      <emu-alg>
        1. _desc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)로 둔다.
        1. _desc_가 *undefined*이면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-call" type="abstract operation">
      <h1>
        Call (
          _F_: ECMAScript 언어 값,
          _V_: ECMAScript 언어 값,
          optional _argumentsList_: ECMAScript 언어 값들의 List,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>함수 객체의 [[Call]] 내부 메소드를 호출하는 데 사용됩니다. _F_는 함수 객체, _V_는 [[Call]]의 *this* 값, _argumentsList_는 내부 메소드의 해당 인자에 전달되는 값입니다. _argumentsList_가 없으면 새 빈 List가 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _argumentsList_가 존재하지 않으면 새 빈 List로 설정한다.
        1. IsCallable(_F_)가 *false*이면 *TypeError* 예외를 던진다.
        1. ? <emu-meta effects="user-code">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-construct" type="abstract operation">
      <h1>
        Construct (
          _F_: 생성자,
          optional _argumentsList_: ECMAScript 언어 값들의 List,
          optional _newTarget_: 생성자,
        ): Object를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>함수 객체의 [[Construct]] 내부 메소드를 호출하는 데 사용됩니다. _argumentsList_, _newTarget_은 내부 메소드에 전달될 해당 인자 값입니다. _argumentsList_가 없으면 새 빈 List가, _newTarget_이 없으면 _F_가 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _newTarget_이 존재하지 않으면 _newTarget_을 _F_로 둔다.
        1. _argumentsList_가 존재하지 않으면 새 빈 List로 둔다.
        1. ? <emu-meta effects="user-code">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>_newTarget_이 없으면 이 연산은 `new F(...argumentsList)`와 동일합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-setintegritylevel" type="abstract operation">
      <h1>
        SetIntegrityLevel (
          _O_: Object,
          _level_: ~sealed~ 또는 ~frozen~,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 own 프로퍼티 집합을 고정(fix)하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _status_를 ? _O_.[[PreventExtensions]]()로 둔다.
        1. _status_가 *false*이면 *false*를 반환한다.
        1. _keys_를 ? _O_.[[OwnPropertyKeys]]()로 둔다.
        1. _level_이 ~sealed~이면,
          1. _keys_의 각 요소 _k_에 대해
            1. ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* })를 수행한다.
        1. Else,
          1. 단언: _level_은 ~frozen~.
          1. _keys_의 각 요소 _k_에 대해
            1. _currentDesc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)로 둔다.
            1. _currentDesc_가 *undefined*가 아니면,
              1. IsAccessorDescriptor(_currentDesc_)가 *true*이면
                1. _desc_를 PropertyDescriptor { [[Configurable]]: *false* }로 둔다.
              1. Else,
                1. _desc_를 PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }로 둔다.
              1. ? DefinePropertyOrThrow(_O_, _k_, _desc_)를 수행한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-testintegritylevel" type="abstract operation">
      <h1>
        TestIntegrityLevel (
          _O_: Object,
          _level_: ~sealed~ 또는 ~frozen~,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>객체의 own 프로퍼티 집합이 고정되어 있는지 판정하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _extensible_을 ? IsExtensible(_O_)로 둔다.
        1. _extensible_이 *true*이면 *false*를 반환한다.
        1. 주: 객체가 확장이 가능하면 프로퍼티를 검사하지 않는다.
        1. _keys_를 ? _O_.[[OwnPropertyKeys]]()로 둔다.
        1. _keys_의 각 요소 _k_에 대해
          1. _currentDesc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)로 둔다.
          1. _currentDesc_가 *undefined*가 아니면,
            1. _currentDesc_.[[Configurable]]이 *true*이면 *false*를 반환한다.
            1. _level_이 ~frozen~이고 IsDataDescriptor(_currentDesc_)가 *true*이면,
              1. _currentDesc_.[[Writable]]이 *true*이면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createarrayfromlist" type="abstract operation">
      <h1>
        CreateArrayFromList (
          _elements_: ECMAScript 언어 값들의 List,
        ): Array
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>요소가 _elements_로 제공되는 Array를 생성하는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. _array_를 ! ArrayCreate(0)로 둔다.
        1. _n_을 0으로 둔다.
        1. _elements_의 각 요소 _e_에 대해
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_)를 수행한다.
          1. _n_을 _n_ + 1로 둔다.
        1. _array_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-lengthofarraylike" type="abstract operation">
      <h1>
        LengthOfArrayLike (
          _obj_: Object,
        ): 음이 아닌 정수를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>배열 유사 객체의 *"length"* 프로퍼티 값을 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. ℝ(? ToLength(? Get(_obj_, *"length"*)))를 반환한다.
      </emu-alg>
      <p><dfn variants="array-like objects">array-like object</dfn>는 이 연산이 normal completion을 반환하는 모든 객체입니다.</p>
      <emu-note>
        일반적으로 array-like object는 정수 인덱스 이름을 가진 몇몇 프로퍼티도 가집니다. 그러나 이것은 필수 조건이 아닙니다.
      </emu-note>
      <emu-note>
        Array와 String 객체가 array-like object의 예입니다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createlistfromarraylike" type="abstract operation">
      <h1>
        CreateListFromArrayLike (
          _obj_: ECMAScript 언어 값,
          optional _validElementTypes_: ~all~ 또는 ~property-key~,
        ): ECMAScript 언어 값들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_obj_의 인덱스된 프로퍼티가 제공하는 요소로 이루어진 List 값을 생성하는 데 사용됩니다. _validElementTypes_는 요소로 허용되는 값 타입을 지정합니다.</dd>
      </dl>
      <emu-alg>
        1. _validElementTypes_가 존재하지 않으면 ~all~로 설정한다.
        1. _obj_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. _len_을 ? LengthOfArrayLike(_obj_)로 둔다.
        1. _list_를 새 빈 List로 둔다.
        1. _index_를 0으로 둔다.
        1. _index_ &lt; _len_ 동안 반복,
          1. _indexName_을 ! ToString(𝔽(_index_))로 둔다.
          1. _next_를 ? Get(_obj_, _indexName_)로 둔다.
          1. _validElementTypes_가 ~property-key~이고 _next_가 프로퍼티 키가 아니면 *TypeError* 예외를 던진다.
          1. _next_를 _list_에 추가한다.
          1. _index_를 _index_ + 1로 둔다.
        1. _list_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-invoke" type="abstract operation">
      <h1>
        Invoke (
          _V_: ECMAScript 언어 값,
          _P_: 프로퍼티 키,
          optional _argumentsList_: ECMAScript 언어 값들의 List,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>ECMAScript 언어 값의 메서드 프로퍼티를 호출하는 데 사용됩니다. _V_는 프로퍼티 조회 지점이자 호출의 *this* 값입니다. _argumentsList_는 메서드에 전달되는 인자 값 리스트입니다. _argumentsList_가 없으면 새 빈 List가 사용됩니다.</dd>
      </dl>

      <emu-alg>
        1. _argumentsList_가 존재하지 않으면 새 빈 List로 둔다.
        1. _func_을 ? GetV(_V_, _P_)로 둔다.
        1. ? Call(_func_, _V_, _argumentsList_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryhasinstance" type="abstract operation">
      <h1>
        OrdinaryHasInstance (
          _C_: ECMAScript 언어 값,
          _O_: ECMAScript 언어 값,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_가 _C_가 제공한 인스턴스 객체 상속 경로를 상속하는지 여부를 결정하는 기본 알고리즘을 구현합니다.</dd>
      </dl>
      <emu-alg>
        1. IsCallable(_C_)가 *false*이면 *false*를 반환한다.
        1. _C_가 [[BoundTargetFunction]] 내부 슬롯을 가지면,
          1. _BC_를 _C_.[[BoundTargetFunction]]으로 둔다.
          1. ? InstanceofOperator(_O_, _BC_)를 반환한다.
        1. _O_가 Object가 아니면 *false*를 반환한다.
        1. _P_를 ? Get(_C_, *"prototype"*)으로 둔다.
        1. _P_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. 반복,
          1. _O_를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()로 둔다.
          1. _O_가 *null*이면 *false*를 반환한다.
          1. SameValue(_P_, _O_)가 *true*이면 *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-speciesconstructor" type="abstract operation">
      <h1>
        SpeciesConstructor (
          _O_: Object,
          _defaultConstructor_: 생성자,
        ): 생성자를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_로부터 파생된 새 객체를 생성할 때 사용해야 하는 생성자를 가져오는 데 사용됩니다. _defaultConstructor_는 _O_부터 시작하여 %Symbol.species% 프로퍼티 생성자를 찾을 수 없을 때 사용할 생성자입니다.</dd>
      </dl>
      <emu-alg>
        1. _C_를 ? Get(_O_, *"constructor"*)로 둔다.
        1. _C_가 *undefined*이면 _defaultConstructor_를 반환한다.
        1. _C_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. _S_를 ? Get(_C_, %Symbol.species%)로 둔다.
        1. _S_가 *undefined* 또는 *null*이면 _defaultConstructor_를 반환한다.
        1. IsConstructor(_S_)가 *true*이면 _S_를 반환한다.
        1. *TypeError* 예외를 던진다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-enumerableownproperties" type="abstract operation" oldids="sec-enumerableownpropertynames">
      <h1>
        EnumerableOwnProperties (
          _O_: Object,
          _kind_: ~key~, ~value~, 또는 ~key+value~,
        ): ECMAScript 언어 값들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _ownKeys_를 ? <emu-meta effects="user-code">_O_.[[OwnPropertyKeys]]</emu-meta>()로 둔다.
        1. _results_를 새 빈 List로 둔다.
        1. _ownKeys_의 각 요소 _key_에 대해
          1. _key_가 String이면,
            1. _desc_를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)로 둔다.
            1. _desc_가 *undefined*가 아니고 _desc_.[[Enumerable]]이 *true*이면,
              1. _kind_가 ~key~이면
                1. _key_를 _results_에 추가한다.
              1. Else,
                1. _value_를 ? Get(_O_, _key_)로 둔다.
                1. _kind_가 ~value~이면
                  1. _value_를 _results_에 추가한다.
                1. Else,
                  1. 단언: _kind_는 ~key+value~.
                  1. _entry_를 CreateArrayFromList(« _key_, _value_ »)로 둔다.
                  1. _entry_를 _results_에 추가한다.
        1. _results_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getfunctionrealm" type="abstract operation">
      <h1>
        GetFunctionRealm (
          _obj_: 함수 객체,
        ): Realm Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _obj_가 [[Realm]] 내부 슬롯을 가지면
          1. _obj_.[[Realm]]을 반환한다.
        1. _obj_가 bound function exotic 객체이면
          1. _boundTargetFunction_을 _obj_.[[BoundTargetFunction]]으로 둔다.
          1. ? GetFunctionRealm(_boundTargetFunction_)을 반환한다.
        1. _obj_가 Proxy 이국 객체이면
          1. ? ValidateNonRevokedProxy(_obj_)를 수행한다.
          1. _proxyTarget_을 _obj_.[[ProxyTarget]]으로 둔다.
          1. 단언: _proxyTarget_은 함수 객체이다.
          1. ? GetFunctionRealm(_proxyTarget_)을 반환한다.
        1. [id="step-getfunctionrealm-default-return"] 현재 Realm Record를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-getfunctionrealm-default-return"></emu-xref> 단계는 _obj_가 [[Realm]] 내부 슬롯이 없는 비표준 함수 이국 객체인 경우에만 도달합니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-copydataproperties" type="abstract operation">
      <h1>
        CopyDataProperties (
          _target_: Object,
          _source_: ECMAScript 언어 값,
          _excludedItems_: 프로퍼티 키들의 List,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _source_가 *undefined* 또는 *null*이면 ~unused~를 반환한다.
        1. _from_을 ! ToObject(_source_)로 둔다.
        1. _keys_를 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]</emu-meta>()로 둔다.
        1. _keys_의 각 요소 _nextKey_에 대해
          1. _excluded_를 *false*로 둔다.
          1. _excludedItems_의 각 요소 _e_에 대해
            1. SameValue(_e_, _nextKey_)가 *true*이면
              1. _excluded_를 *true*로 둔다.
          1. _excluded_가 *false*이면
            1. _desc_를 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_)로 둔다.
            1. _desc_가 *undefined*가 아니고 _desc_.[[Enumerable]]이 *true*이면
              1. _propValue_를 ? Get(_from_, _nextKey_)로 둔다.
              1. ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>여기에 전달되는 target은 항상 새로 생성된 객체이며, 오류 발생 시 직접 접근할 수 없습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-privateelementfind" type="abstract operation">
      <h1>
        PrivateElementFind (
          _O_: Object,
          _P_: Private Name,
        ): PrivateElement 또는 ~empty~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _O_.[[PrivateElements]]가 _pe_.[[Key]]가 _P_인 PrivateElement _pe_를 포함하면
          1. _pe_를 반환한다.
        1. ~empty~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatefieldadd" type="abstract operation">
      <h1>
        PrivateFieldAdd (
          _O_: Object,
          _P_: Private Name,
          _value_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 호스트가 웹 브라우저이면
          1. ? HostEnsureCanAddPrivateElement(_O_)를 수행한다.
        1. _entry_를 PrivateElementFind(_O_, _P_)로 둔다.
        1. _entry_가 ~empty~가 아니면 *TypeError* 예외를 던진다.
        1. PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ }를 _O_.[[PrivateElements]]에 추가한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatemethodoraccessoradd" type="abstract operation">
      <h1>
        PrivateMethodOrAccessorAdd (
          _O_: Object,
          _method_: PrivateElement,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 단언: _method_.[[Kind]]는 ~method~ 또는 ~accessor~이다.
        1. 호스트가 웹 브라우저이면
          1. ? HostEnsureCanAddPrivateElement(_O_)를 수행한다.
        1. _entry_를 PrivateElementFind(_O_, _method_.[[Key]])로 둔다.
        1. _entry_가 ~empty~가 아니면 *TypeError* 예외를 던진다.
        1. _method_를 _O_.[[PrivateElements]]에 추가한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p>private 메서드와 접근자의 값은 인스턴스 간에 공유됩니다. 이 연산은 메서드나 접근자의 새 복사본을 만들지 않습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostensurecanaddprivateelement" type="host-defined abstract operation">
      <h1>
        HostEnsureCanAddPrivateElement (
          _O_: Object,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>호스트 환경이 특정 호스트 정의 exotic 객체에 private element 추가를 방지할 수 있도록 합니다.</dd>
      </dl>
      <p>HostEnsureCanAddPrivateElement 구현은 다음 요구사항을 따라야 합니다:</p>
      <ul>
        <li>_O_가 호스트 정의 exotic 객체가 아니면 이 추상 연산은 NormalCompletion(~unused~)을 반환하고 다른 단계를 수행하지 않아야 합니다.</li>
        <li>같은 인수로 이 추상 연산을 두 번 호출하면 동일한 종류의 Completion Record를 반환해야 합니다.</li>
      </ul>
      <p>HostEnsureCanAddPrivateElement의 기본 구현은 NormalCompletion(~unused~)을 반환하는 것입니다.</p>
      <p>이 추상 연산은 ECMAScript 호스트가 웹 브라우저인 경우에만 호출됩니다.</p>
    </emu-clause>

    <emu-clause id="sec-privateget" type="abstract operation">
      <h1>
        PrivateGet (
          _O_: Object,
          _P_: Private Name,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _entry_를 PrivateElementFind(_O_, _P_)로 둔다.
        1. _entry_가 ~empty~이면 *TypeError* 예외를 던진다.
        1. _entry_.[[Kind]]가 ~field~ 또는 ~method~이면
          1. _entry_.[[Value]]를 반환한다.
        1. 단언: _entry_.[[Kind]]는 ~accessor~이다.
        1. _entry_.[[Get]]이 *undefined*이면 *TypeError* 예외를 던진다.
        1. _getter_를 _entry_.[[Get]]으로 둔다.
        1. ? Call(_getter_, _O_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privateset" type="abstract operation">
      <h1>
        PrivateSet (
          _O_: Object,
          _P_: Private Name,
          _value_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _entry_를 PrivateElementFind(_O_, _P_)로 둔다.
        1. _entry_가 ~empty~이면 *TypeError* 예외를 던진다.
        1. _entry_.[[Kind]]가 ~field~이면
          1. _entry_.[[Value]]를 _value_로 설정한다.
        1. Else if _entry_.[[Kind]]가 ~method~이면
          1. *TypeError* 예외를 던진다.
        1. Else,
          1. 단언: _entry_.[[Kind]]는 ~accessor~.
          1. _entry_.[[Set]]이 *undefined*이면 *TypeError* 예외를 던진다.
          1. _setter_를 _entry_.[[Set]]으로 둔다.
          1. ? Call(_setter_, _O_, « _value_ »)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definefield" type="abstract operation">
      <h1>
        DefineField (
          _receiver_: Object,
          _fieldRecord_: ClassFieldDefinition Record,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _fieldName_을 _fieldRecord_.[[Name]]으로 둔다.
        1. _initializer_를 _fieldRecord_.[[Initializer]]로 둔다.
        1. _initializer_가 ~empty~가 아니면
          1. _initValue_를 ? Call(_initializer_, _receiver_)로 둔다.
        1. Else,
          1. _initValue_를 *undefined*로 둔다.
        1. _fieldName_이 Private Name이면
          1. ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_)를 수행한다.
        1. Else,
          1. 단언: _fieldName_은 프로퍼티 키이다.
          1. ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializeinstanceelements" type="abstract operation">
      <h1>
        InitializeInstanceElements (
          _O_: Object,
          _constructor_: ECMAScript 함수 객체,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _methods_를 _constructor_.[[PrivateMethods]]로 둔다.
        1. _methods_의 각 PrivateElement _method_에 대해
          1. ? PrivateMethodOrAccessorAdd(_O_, _method_)를 수행한다.
        1. _fields_를 _constructor_.[[Fields]]로 둔다.
        1. _fields_의 각 요소 _fieldRecord_에 대해
          1. ? DefineField(_O_, _fieldRecord_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-value-to-keyed-group" type="abstract operation">
      <h1>
        AddValueToKeyedGroup (
          _groups_: 필드 [[Key]](ECMAScript 언어 값)와 [[Elements]](ECMAScript 언어 값들의 List)를 가진 Record들의 List,
          _key_: ECMAScript 언어 값,
          _value_: ECMAScript 언어 값,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _groups_의 각 Record { [[Key]], [[Elements]] } _g_에 대해
          1. SameValue(_g_.[[Key]], _key_)가 *true*이면
            1. 단언: 정확히 한 요소만 이 조건을 만족한다.
            1. _value_를 _g_.[[Elements]]에 추가한다.
            1. ~unused~를 반환한다.
        1. _group_을 Record { [[Key]]: _key_, [[Elements]]: « _value_ » }로 둔다.
        1. _group_을 _groups_에 추가한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-groupby" type="abstract operation">
      <h1>
        GroupBy (
          _items_: ECMAScript 언어 값,
          _callback_: ECMAScript 언어 값,
          _keyCoercion_: ~property~ 또는 ~collection~,
        ): 필드 [[Key]](ECMAScript 언어 값) 및 [[Elements]](ECMAScript 언어 값들의 List)를 가진 Record들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ? RequireObjectCoercible(_items_)를 수행한다.
        1. IsCallable(_callback_)이 *false*이면 *TypeError* 예외를 던진다.
        1. _groups_를 새 빈 List로 둔다.
        1. _iteratorRecord_를 ? GetIterator(_items_, ~sync~)로 둔다.
        1. _k_를 0으로 둔다.
        1. 반복,
          1. _k_ ≥ 2<sup>53</sup> - 1이면
            1. _error_를 ThrowCompletion(새로 생성된 *TypeError* 객체)로 둔다.
            1. ? IteratorClose(_iteratorRecord_, _error_)를 반환한다.
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. _groups_를 반환한다.
          1. _value_를 _next_로 둔다.
          1. _key_를 Completion(Call(_callback_, *undefined*, « _value_, 𝔽(_k_) »))로 둔다.
          1. IfAbruptCloseIterator(_key_, _iteratorRecord_).
          1. _keyCoercion_이 ~property~이면
            1. _key_를 Completion(ToPropertyKey(_key_))로 둔다.
            1. IfAbruptCloseIterator(_key_, _iteratorRecord_).
          1. Else,
            1. 단언: _keyCoercion_은 ~collection~.
            1. _key_를 CanonicalizeKeyedCollectionKey(_key_)로 둔다.
          1. AddValueToKeyedGroup(_groups_, _key_, _value_)를 수행한다.
          1. _k_를 _k_ + 1로 둔다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-SetterThatIgnoresPrototypeProperties" type="abstract operation">
      <h1>
        SetterThatIgnoresPrototypeProperties (
          _thisValue_: ECMAScript 언어 값,
          _home_: Object,
          _p_: 프로퍼티 키,
          _v_: ECMAScript 언어 값,
        ): ~unused~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _thisValue_가 Object가 아니면
          1. *TypeError* 예외를 던진다.
        1. SameValue(_thisValue_, _home_)가 *true*이면
          1. 주: 여기서 던지는 것은 strict mode 코드에서 _home_ 객체의 쓰기 불가능 데이터 프로퍼티에 대입하는 것과 유사하다.
          1. *TypeError* 예외를 던진다.
        1. _desc_를 ? _thisValue_.[[GetOwnProperty]](_p_)로 둔다.
        1. _desc_가 *undefined*이면
          1. ? CreateDataPropertyOrThrow(_thisValue_, _p_, _v_)를 수행한다.
        1. Else,
          1. ? Set(_thisValue_, _p_, _v_, *true*)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>이터레이터 객체에 대한 연산(Operations on Iterator Objects)</h1>
    <p>공통 반복 인터페이스는 <emu-xref href="#sec-iteration"></emu-xref> 참조.</p>

    <emu-clause id="sec-iterator-records">
      <h1>Iterator Record</h1>
      <p><dfn variants="Iterator Records">Iterator Record</dfn>는 이터레이터 또는 async 이터레이터와 그 `next` 메서드를 캡슐화하는 데 사용되는 Record 값입니다.</p>
      <p>Iterator Record는 <emu-xref href="#table-iterator-record-fields"></emu-xref>에 나열된 필드를 가집니다.</p>
      <emu-table id="table-iterator-record-fields" caption="Iterator Record 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Iterator]]
            </td>
            <td>
              Object
            </td>
            <td>
              이터레이터 인터페이스 또는 async 이터레이터 인터페이스를 준수하는 객체.
            </td>
          </tr>
          <tr>
            <td>
              [[NextMethod]]
            </td>
            <td>
              ECMAScript 언어 값
            </td>
            <td>
              [[Iterator]] 객체의 `next` 메서드.
            </td>
          </tr>
          <tr>
            <td>
              [[Done]]
            </td>
            <td>
              Boolean
            </td>
            <td>
              이터레이터가 완료되었거나 닫혔는지 여부.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-getiteratordirect" type="abstract operation">
      <h1>
        GetIteratorDirect (
          _obj_: Object,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _nextMethod_를 ? Get(_obj_, *"next"*)로 둔다.
        1. _iteratorRecord_를 Iterator Record { [[Iterator]]: _obj_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }로 둔다.
        1. _iteratorRecord_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorfrommethod" type="abstract operation">
      <h1>
        GetIteratorFromMethod (
          _obj_: ECMAScript 언어 값,
          _method_: 함수 객체,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _iterator_를 ? Call(_method_, _obj_)로 둔다.
        1. _iterator_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? GetIteratorDirect(_iterator_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiterator" type="abstract operation">
      <h1>
        GetIterator (
          _obj_: ECMAScript 언어 값,
          _kind_: ~sync~ 또는 ~async~,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _kind_가 ~async~이면,
          1. _method_를 ? GetMethod(_obj_, %Symbol.asyncIterator%)로 둔다.
          1. _method_가 *undefined*이면,
            1. _syncMethod_를 ? GetMethod(_obj_, %Symbol.iterator%)로 둔다.
            1. _syncMethod_가 *undefined*이면 *TypeError* 예외를 던진다.
            1. _syncIteratorRecord_를 ? GetIteratorFromMethod(_obj_, _syncMethod_)로 둔다.
            1. CreateAsyncFromSyncIterator(_syncIteratorRecord_)를 반환한다.
        1. Else,
          1. _method_를 ? GetMethod(_obj_, %Symbol.iterator%)로 둔다.
        1. _method_가 *undefined*이면 *TypeError* 예외를 던진다.
        1. ? GetIteratorFromMethod(_obj_, _method_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorflattenable" type="abstract operation">
      <h1>
        GetIteratorFlattenable (
          _obj_: ECMAScript 언어 값,
          _primitiveHandling_: ~iterate-string-primitives~ 또는 ~reject-primitives~,
        ): Iterator Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _obj_가 Object가 아니면,
          1. _primitiveHandling_이 ~reject-primitives~이면 *TypeError* 예외를 던진다.
          1. 단언: _primitiveHandling_은 ~iterate-string-primitives~.
          1. _obj_가 String이 아니면 *TypeError* 예외를 던진다.
        1. _method_를 ? GetMethod(_obj_, %Symbol.iterator%)로 둔다.
        1. _method_가 *undefined*이면
          1. _iterator_를 _obj_로 둔다.
        1. Else,
          1. _iterator_를 ? Call(_method_, _obj_)로 둔다.
        1. _iterator_가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? GetIteratorDirect(_iterator_)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratornext" type="abstract operation">
      <h1>
        IteratorNext (
          _iteratorRecord_: Iterator Record,
          optional _value_: ECMAScript 언어 값,
        ): Object를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _value_가 존재하지 않으면
          1. _result_를 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]))로 둔다.
        1. Else,
          1. _result_를 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »))로 둔다.
        1. _result_가 throw completion이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. ? _result_를 반환한다.
        1. _result_를 ! _result_로 둔다.
        1. _result_가 Object가 아니면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. *TypeError* 예외를 던진다.
        1. _result_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorcomplete" type="abstract operation">
      <h1>
        IteratorComplete (
          _iteratorResult_: Object,
        ): Boolean을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ToBoolean(? Get(_iteratorResult_, *"done"* ))을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorvalue" type="abstract operation">
      <h1>
        IteratorValue (
          _iteratorResult_: Object,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. ? Get(_iteratorResult_, *"value"*)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstep" type="abstract operation">
      <h1>
        IteratorStep (
          _iteratorRecord_: Iterator Record,
        ): Object 또는 ~done~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_iteratorRecord_.[[Iterator]]에서 _iteratorRecord_.[[NextMethod]]를 호출해 다음 값을 요청하고, 이터레이터가 끝에 도달했음을 나타내는 ~done~ 또는 다음 값을 사용할 수 있다면 IteratorResult 객체를 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _result_를 ? IteratorNext(_iteratorRecord_)로 둔다.
        1. _done_을 Completion(IteratorComplete(_result_))로 둔다.
        1. _done_이 throw completion이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. ? _done_을 반환한다.
        1. _done_을 ! _done_으로 둔다.
        1. _done_이 *true*이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
          1. ~done~을 반환한다.
        1. _result_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstepvalue" type="abstract operation">
      <h1>
        IteratorStepValue (
          _iteratorRecord_: Iterator Record,
        ): ECMAScript 언어 값 또는 ~done~을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_iteratorRecord_.[[Iterator]]에서 _iteratorRecord_.[[NextMethod]]를 호출해 다음 값을 요청하고, 끝에 도달했으면 ~done~을, 다음 값이 있으면 IteratorResult 객체의 값을 반환합니다.</dd>
      </dl>
      <emu-alg>
        1. _result_를 ? IteratorStep(_iteratorRecord_)로 둔다.
        1. _result_가 ~done~이면
          1. ~done~을 반환한다.
        1. _value_를 Completion(IteratorValue(_result_))로 둔다.
        1. _value_가 throw completion이면
          1. _iteratorRecord_.[[Done]]를 *true*로 둔다.
        1. ? _value_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorclose" type="abstract operation">
      <h1>
        IteratorClose (
          _iteratorRecord_: Iterator Record,
          _completion_: Completion Record,
        ): Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>이터레이터가 완료 상태에 도달했을 때 일반적으로 수행할 동작을 실행하도록 알리는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _iteratorRecord_.[[Iterator]]는 Object이다.
        1. _iterator_를 _iteratorRecord_.[[Iterator]]로 둔다.
        1. _innerResult_를 Completion(GetMethod(_iterator_, *"return"* ))로 둔다.
        1. _innerResult_가 normal completion이면
          1. _return_을 _innerResult_.[[Value]]로 둔다.
          1. _return_이 *undefined*이면 ? _completion_을 반환한다.
          1. _innerResult_를 Completion(Call(_return_, _iterator_))로 둔다.
        1. _completion_이 throw completion이면 ? _completion_을 반환한다.
        1. _innerResult_가 throw completion이면 ? _innerResult_를 반환한다.
        1. _innerResult_.[[Value]]가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? _completion_을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ifabruptcloseiterator" aoid="IfAbruptCloseIterator">
      <h1>IfAbruptCloseIterator ( _value_, _iteratorRecord_ )</h1>
      <p>IfAbruptCloseIterator는 Iterator Record를 사용하는 알고리즘 단계의 축약 표현입니다. 다음 형태의 알고리즘 단계:</p>
      <emu-alg>
        1. IfAbruptCloseIterator(_value_, _iteratorRecord_).
      </emu-alg>
      <p>는 다음과 동일한 의미입니다:</p>
      <emu-alg>
        1. 단언: _value_는 Completion Record이다.
        1. _value_가 abrupt completion이면 ? IteratorClose(_iteratorRecord_, _value_)를 반환한다.
        1. Else, _value_를 ! _value_로 설정한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asynciteratorclose" type="abstract operation">
      <h1>
        AsyncIteratorClose (
          _iteratorRecord_: Iterator Record,
          _completion_: Completion Record,
        ): Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>async 이터레이터가 완료 상태에 도달했을 때 일반적으로 수행할 동작을 실행하도록 알리는 데 사용됩니다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _iteratorRecord_.[[Iterator]]는 Object이다.
        1. _iterator_를 _iteratorRecord_.[[Iterator]]로 둔다.
        1. _innerResult_를 Completion(GetMethod(_iterator_, *"return"* ))로 둔다.
        1. _innerResult_가 normal completion이면
          1. _return_을 _innerResult_.[[Value]]로 둔다.
          1. _return_이 *undefined*이면 ? _completion_을 반환한다.
          1. _innerResult_를 Completion(Call(_return_, _iterator_))로 둔다.
          1. _innerResult_가 normal completion이면 _innerResult_를 Completion(Await(_innerResult_.[[Value]]))로 둔다.
        1. _completion_이 throw completion이면 ? _completion_을 반환한다.
        1. _innerResult_가 throw completion이면 ? _innerResult_를 반환한다.
        1. _innerResult_.[[Value]]가 Object가 아니면 *TypeError* 예외를 던진다.
        1. ? _completion_을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createiterresultobject" type="abstract operation">
      <h1>
        CreateIteratorResultObject (
          _value_: ECMAScript 언어 값,
          _done_: Boolean,
        ): IteratorResult 인터페이스를 준수하는 Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>IteratorResult 인터페이스를 준수하는 객체를 생성합니다.</dd>
      </dl>
      <emu-alg>
        1. _obj_를 OrdinaryObjectCreate(%Object.prototype%)로 둔다.
        1. ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_)를 수행한다.
        1. ! CreateDataPropertyOrThrow(_obj_, *"done"*, _done_)를 수행한다.
        1. _obj_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistiteratorRecord" type="abstract operation" oldids="sec-createlistiterator,sec-listiteratornext-functions,sec-listiterator-next">
      <h1>
        CreateListIteratorRecord (
          _list_: ECMAScript 언어 값들의 List,
        ): Iterator Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>[[NextMethod]]가 _list_의 연속 요소를 반환하는 Iterator Record를 생성합니다.</dd>
      </dl>
      <emu-alg>
        1. _closure_를 매개변수 없고 _list_를 캡처하며 호출 시 다음 단계를 수행하는 새 Abstract Closure로 둔다:
          1. _list_의 각 요소 _E_에 대해
            1. ? GeneratorYield(CreateIteratorResultObject(_E_, *false*))를 수행한다.
          1. NormalCompletion(*undefined*)를 반환한다.
        1. _iterator_를 CreateIteratorFromClosure(_closure_, ~empty~, %Iterator.prototype%)로 둔다.
        1. Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorPrototype.next%, [[Done]]: *false* }를 반환한다.
      </emu-alg>
      <emu-note>
        <p>list 이터레이터 객체는 ECMAScript 코드에서 직접 접근할 수 없습니다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-iteratortolist" oldids="sec-iterabletolist" type="abstract operation">
      <h1>
        IteratorToList (
          _iteratorRecord_: Iterator Record,
        ): ECMAScript 언어 값들의 List를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _values_를 새 빈 List로 둔다.
        1. 반복,
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. _values_를 반환한다.
          1. _next_를 _values_에 추가한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>구문 지향 연산(Syntax-Directed Operations)</h1>
  <p>이 절에서 정의된 것들 외에도, 특수화된 구문 지향 연산들이 이 명세 전반에 걸쳐 정의된다.</p>

  <emu-clause id="sec-evaluation" type="sdo">
    <h1>런타임 의미론: Evaluation ( ): Completion Record</h1>
    <dl class="header">
      <dt>effects</dt>
      <dd>user-code</dd>
    </dl>
    <emu-note>
      이 연산의 정의는 이 명세의 "ECMAScript Language" 절들에 분산되어 있다. 각 정의는 관련 생성규칙(production)이 정의적으로 등장한 직후에 나타난다.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>스코프 분석(Scope Analysis)</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>정적 의미론: BoundNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* 문자열은 모듈의 기본(default) export가 다른 이름을 가지지 않을 때 그 모듈의 기본 export를 위한 합성된 이름으로 이 명세 내부에서 사용된다. 모듈의 [[Environment]] 내에 그 이름으로 항목이 생성되어 해당 값을 보유하고, 모듈에 대해 <emu-xref href="#sec-resolveexport" title></emu-xref>를 호출하여 *"default"*라는 export를 해석하면 [[BindingName]]이 *"\*default\*"*인 ResolvedBinding Record를 반환하며, 이는 모듈 [[Environment]]에서 상술한 값으로 다시 해석된다. 이는 명세 편의를 위한 것이며, 익명 기본 export도 다른 export와 동일하게 해석될 수 있도록 한다. 이 *"\*default\*"* 문자열은 ECMAScript 코드나 모듈 링크 알고리즘에서 접근될 수 없다.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. |Identifier|의 StringValue만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. « *"yield"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. « *"await"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. |BindingList|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingList|의 BoundNames로 둔다.
        1. _names2_를 |LexicalBinding|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. |BindingPattern|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. _names1_을 |VariableDeclarationList|의 BoundNames로 둔다.
        1. _names2_를 |VariableDeclaration|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. |BindingPattern|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingPropertyList|의 BoundNames로 둔다.
        1. _names2_를 |BindingRestProperty|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingRestElement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingElementList|의 BoundNames로 둔다.
        1. _names2_를 |BindingRestElement|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingPropertyList|의 BoundNames로 둔다.
        1. _names2_를 |BindingProperty|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. _names1_을 |BindingElementList|의 BoundNames로 둔다.
        1. _names2_를 |BindingElisionElement|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. |BindingPattern|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. |ForBinding|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. _names1_을 |FormalParameterList|의 BoundNames로 둔다.
        1. _names2_를 |FunctionRestParameter|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. _names1_을 |FormalParameterList|의 BoundNames로 둔다.
        1. _names2_를 |FormalParameter|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_를 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ArrowFormalParameters|로 둔다.
        1. _formals_의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. _head_를 |CoverCallExpressionAndAsyncArrowHead|가 커버하는 |AsyncArrowHead|로 둔다.
        1. _head_의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
      <emu-alg>
        1. |ImportClause|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. _names1_을 |ImportedDefaultBinding|의 BoundNames로 둔다.
        1. _names2_를 |NameSpaceImport|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. _names1_을 |ImportedDefaultBinding|의 BoundNames로 둔다.
        1. _names2_를 |NamedImports|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. _names1_을 |ImportsList|의 BoundNames로 둔다.
        1. _names2_를 |ImportSpecifier|의 BoundNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. |ImportedBinding|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. |VariableStatement|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. _declarationNames_를 |HoistableDeclaration|의 BoundNames로 둔다.
        1. _declarationNames_에 *"\*default\*"* 요소가 없으면 *"\*default\*"*를 _declarationNames_에 추가한다.
        1. _declarationNames_를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. _declarationNames_를 |ClassDeclaration|의 BoundNames로 둔다.
        1. _declarationNames_에 *"\*default\*"* 요소가 없으면 *"\*default\*"*를 _declarationNames_에 추가한다.
        1. _declarationNames_를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. « *"\*default\*"* » 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-declarationpart" type="sdo">
      <h1>정적 의미론: DeclarationPart ( ): Parse Node</h1>
      <dl class="header">
      </dl>
      <emu-grammar>HoistableDeclaration : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : GeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. |GeneratorDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncFunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |AsyncFunctionDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncGeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. |AsyncGeneratorDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>Declaration : ClassDeclaration</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration|을 반환한다.
      </emu-alg>
      <emu-grammar>Declaration : LexicalDeclaration</emu-grammar>
      <emu-alg>
        1. |LexicalDeclaration|을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>정적 의미론: IsConstantDeclaration ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. |LetOrConst|의 IsConstantDeclaration을 반환한다.
      </emu-alg>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p>`export default` |AssignmentExpression|을 상수 선언으로 다룰 필요는 없다. 이는 모듈의 기본 객체를 참조하는 내부 바운드 이름에 대입을 허용하는 구문이 존재하지 않기 때문이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallydeclarednames" oldids="sec-block-static-semantics-lexicallydeclarednames,sec-switch-statement-static-semantics-lexicallydeclarednames,sec-labelled-statements-static-semantics-lexicallydeclarednames,sec-function-definitions-static-semantics-lexicallydeclarednames,sec-arrow-function-definitions-static-semantics-lexicallydeclarednames,sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames,sec-scripts-static-semantics-lexicallydeclarednames,sec-module-semantics-static-semantics-lexicallydeclarednames" type="sdo">
      <h1>정적 의미론: LexicallyDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 LexicallyDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 LexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |LabelledStatement|의 LexicallyDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _names1_을 그 LexicallyDeclaredNames로 둔다.
        1. 아니면 _names1_을 새 빈 List로 둔다.
        1. _names2_를 |DefaultClause|의 LexicallyDeclaredNames로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _names3_을 그 LexicallyDeclaredNames로 둔다.
        1. 아니면 _names3_을 새 빈 List로 둔다.
        1. _names1_, _names2_, _names3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _names1_을 |CaseClauses|의 LexicallyDeclaredNames로 둔다.
        1. _names2_를 |CaseClause|의 LexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 LexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|Script|의 최상위(top level)에서 함수 선언은 lexical 선언이 아닌 var 선언처럼 다루어진다.</p>
      </emu-note>
      <emu-note>
        <p>|Module|의 LexicallyDeclaredNames에는 모든 import된 바인딩의 이름이 포함된다.</p>
      </emu-note>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |ModuleItemList|의 LexicallyDeclaredNames로 둔다.
        1. _names2_를 |ModuleItem|의 LexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. |ImportDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration|이 `export` |VariableStatement|이면 새 빈 List를 반환한다.
        1. |ExportDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
      <emu-alg>
        1. |StatementListItem|의 LexicallyDeclaredNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|Module|의 최상위에서는 함수 선언이 var 선언이 아닌 lexical 선언처럼 다루어진다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" oldids="sec-block-static-semantics-lexicallyscopeddeclarations,sec-switch-statement-static-semantics-lexicallyscopeddeclarations,sec-labelled-statements-static-semantics-lexicallyscopeddeclarations,sec-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations,sec-scripts-static-semantics-lexicallyscopeddeclarations,sec-module-semantics-static-semantics-lexicallyscopeddeclarations,sec-exports-static-semantics-lexicallyscopeddeclarations" type="sdo">
      <h1>정적 의미론: LexicallyScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |LabelledStatement|의 LexicallyScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 DeclarationPart만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _declarations1_을 그 LexicallyScopedDeclarations로 둔다.
        1. 아니면 _declarations1_을 새 빈 List로 둔다.
        1. _declarations2_를 |DefaultClause|의 LexicallyScopedDeclarations로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _declarations3_을 그 LexicallyScopedDeclarations로 둔다.
        1. 아니면 _declarations3_을 새 빈 List로 둔다.
        1. _declarations1_, _declarations2_, _declarations3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |CaseClauses|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |CaseClause|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 LexicallyScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 LexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » 를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelLexicallyScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |ModuleItemList|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |ModuleItem|의 LexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|의 DeclarationPart만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. |HoistableDeclaration|의 DeclarationPart만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration|만을 요소로 갖는 List를 반환한다.
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 이 |ExportDeclaration|만을 요소로 갖는 List를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-vardeclarednames" oldids="sec-statement-semantics-static-semantics-vardeclarednames,sec-block-static-semantics-vardeclarednames,sec-variable-statement-static-semantics-vardeclarednames,sec-if-statement-static-semantics-vardeclarednames,sec-do-while-statement-static-semantics-vardeclarednames,sec-while-statement-static-semantics-vardeclarednames,sec-for-statement-static-semantics-vardeclarednames,sec-for-in-and-for-of-statements-static-semantics-vardeclarednames,sec-with-statement-static-semantics-vardeclarednames,sec-switch-statement-static-semantics-vardeclarednames,sec-labelled-statements-static-semantics-vardeclarednames,sec-try-statement-static-semantics-vardeclarednames,sec-function-definitions-static-semantics-vardeclarednames,sec-arrow-function-definitions-static-semantics-vardeclarednames,sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames,sec-scripts-static-semantics-vardeclarednames,sec-module-semantics-static-semantics-vardeclarednames" type="sdo">
      <h1>정적 의미론: VarDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 VarDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
      <emu-alg>
        1. |VariableDeclarationList|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _names1_을 첫 번째 |Statement|의 VarDeclaredNames로 둔다.
        1. _names2_를 두 번째 |Statement|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. _names1_을 |VariableDeclarationList|의 BoundNames로 둔다.
        1. _names2_를 |Statement|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. _names1_을 « |ForBinding| »으로 둔다.
        1. _names2_를 |Statement|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _names1_을 그 VarDeclaredNames로 둔다.
        1. 아니면 _names1_을 새 빈 List로 둔다.
        1. _names2_를 |DefaultClause|의 VarDeclaredNames로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _names3_을 그 VarDeclaredNames로 둔다.
        1. 아니면 _names3_을 새 빈 List로 둔다.
        1. _names1_, _names2_, _names3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _names1_을 |CaseClauses|의 VarDeclaredNames로 둔다.
        1. _names2_를 |CaseClause|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarDeclaredNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _names1_을 |Block|의 VarDeclaredNames로 둔다.
        1. _names2_를 |Catch|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _names1_을 |Block|의 VarDeclaredNames로 둔다.
        1. _names2_를 |Finally|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _names1_을 |Block|의 VarDeclaredNames로 둔다.
        1. _names2_를 |Catch|의 VarDeclaredNames로 둔다.
        1. _names3_을 |Finally|의 VarDeclaredNames로 둔다.
        1. _names1_, _names2_, _names3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |ModuleItemList|의 VarDeclaredNames로 둔다.
        1. _names2_를 |ModuleItem|의 VarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration|이 `export` |VariableStatement|이면 |ExportDeclaration|의 BoundNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-varscopeddeclarations" oldids="sec-statement-semantics-static-semantics-varscopeddeclarations,sec-block-static-semantics-varscopeddeclarations,sec-variable-statement-static-semantics-varscopeddeclarations,sec-if-statement-static-semantics-varscopeddeclarations,sec-do-while-statement-static-semantics-varscopeddeclarations,sec-while-statement-static-semantics-varscopeddeclarations,sec-for-statement-static-semantics-varscopeddeclarations,sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations,sec-with-statement-static-semantics-varscopeddeclarations,sec-switch-statement-static-semantics-varscopeddeclarations,sec-labelled-statements-static-semantics-varscopeddeclarations,sec-try-statement-static-semantics-varscopeddeclarations,sec-function-definitions-static-semantics-varscopeddeclarations,sec-arrow-function-definitions-static-semantics-varscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations,sec-scripts-static-semantics-varscopeddeclarations,sec-module-semantics-static-semantics-varscopeddeclarations" type="sdo">
      <h1>정적 의미론: VarScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclaration</emu-grammar>
      <emu-alg>
        1. « |VariableDeclaration| » 를 반환한다.
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |VariableDeclarationList|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 « |VariableDeclaration| »의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_을 첫 번째 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 두 번째 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |VariableDeclarationList|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. _declarations1_을 « |ForBinding| »으로 둔다.
        1. _declarations2_를 |Statement|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면 _declarations1_을 그 VarScopedDeclarations로 둔다.
        1. 아니면 _declarations1_을 새 빈 List로 둔다.
        1. _declarations2_를 |DefaultClause|의 VarScopedDeclarations로 둔다.
        1. 두 번째 |CaseClauses|가 존재하면 _declarations3_을 그 VarScopedDeclarations로 둔다.
        1. 아니면 _declarations3_을 새 빈 List로 둔다.
        1. _declarations1_, _declarations2_, _declarations3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |CaseClauses|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |CaseClause|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 VarScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |Block|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Catch|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |Block|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Finally|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |Block|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |Catch|의 VarScopedDeclarations로 둔다.
        1. _declarations3_을 |Finally|의 VarScopedDeclarations로 둔다.
        1. _declarations1_, _declarations2_, _declarations3_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |ModuleItemList|의 VarScopedDeclarations로 둔다.
        1. _declarations2_를 |ModuleItem|의 VarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. |ExportDeclaration|이 `export` |VariableStatement|이면 |VariableStatement|의 VarScopedDeclarations를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallydeclarednames" oldids="sec-block-static-semantics-toplevellexicallydeclarednames,sec-labelled-statements-static-semantics-toplevellexicallydeclarednames" type="sdo">
      <h1>정적 의미론: TopLevelLexicallyDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 TopLevelLexicallyDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 TopLevelLexicallyDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. 새 빈 List를 반환한다.
        1. |Declaration|의 BoundNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>함수나 스크립트의 최상위에서는 함수 선언이 lexical 선언이 아닌 var 선언처럼 취급된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallyscopeddeclarations" oldids="sec-block-static-semantics-toplevellexicallyscopeddeclarations,sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations" type="sdo">
      <h1>정적 의미론: TopLevelLexicallyScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 TopLevelLexicallyScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 TopLevelLexicallyScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. 새 빈 List를 반환한다.
        1. « |Declaration| » 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvardeclarednames" oldids="sec-block-static-semantics-toplevelvardeclarednames,sec-labelled-statements-static-semantics-toplevelvardeclarednames" type="sdo">
      <h1>정적 의미론: TopLevelVarDeclaredNames ( ): 문자열들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _names1_을 |StatementList|의 TopLevelVarDeclaredNames로 둔다.
        1. _names2_를 |StatementListItem|의 TopLevelVarDeclaredNames로 둔다.
        1. _names1_과 _names2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. |HoistableDeclaration|의 BoundNames를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarDeclaredNames를 반환한다.
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-note>
        <p>함수나 스크립트의 최상위에서 내부 함수 선언은 var 선언처럼 다루어진다.</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 TopLevelVarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarDeclaredNames를 반환한다.
        1. |Statement|의 VarDeclaredNames를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration|의 BoundNames를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvarscopeddeclarations" oldids="sec-block-static-semantics-toplevelvarscopeddeclarations,sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations" type="sdo">
      <h1>정적 의미론: TopLevelVarScopedDeclarations ( ): Parse Node들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _declarations1_을 |StatementList|의 TopLevelVarScopedDeclarations로 둔다.
        1. _declarations2_를 |StatementListItem|의 TopLevelVarScopedDeclarations로 둔다.
        1. _declarations1_과 _declarations2_의 list-concatenation을 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarScopedDeclarations를 반환한다.
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. |Declaration|이 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>이면
          1. _declaration_을 |HoistableDeclaration|의 DeclarationPart로 둔다.
          1. « _declaration_ » 를 반환한다.
        1. 새 빈 List를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 TopLevelVarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. |Statement|가 <emu-grammar>Statement : LabelledStatement</emu-grammar>이면 |Statement|의 TopLevelVarScopedDeclarations를 반환한다.
        1. |Statement|의 VarScopedDeclarations를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. « |FunctionDeclaration| » 를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-labels">
    <h1>레이블(Labels)</h1>

    <emu-clause id="sec-static-semantics-containsduplicatelabels" oldids="sec-statement-semantics-static-semantics-containsduplicatelabels,sec-block-static-semantics-containsduplicatelabels,sec-if-statement-static-semantics-containsduplicatelabels,sec-do-while-statement-static-semantics-containsduplicatelabels,sec-while-statement-static-semantics-containsduplicatelabels,sec-for-statement-static-semantics-containsduplicatelabels,sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels,sec-with-statement-static-semantics-containsduplicatelabels,sec-switch-statement-static-semantics-containsduplicatelabels,sec-labelled-statements-static-semantics-containsduplicatelabels,sec-try-statement-static-semantics-containsduplicatelabels,sec-function-definitions-static-semantics-containsduplicatelabels,sec-module-semantics-static-semantics-containsduplicatelabels" type="sdo">
      <h1>
        정적 의미론: ContainsDuplicateLabels (
        _labelSet_: 문자열들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |StatementList|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasDuplicate_를 첫 번째 |Statement|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicate_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면
          1. 첫 번째 |CaseClauses|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 존재하지 않으면 *false*를 반환한다.
        1. 두 번째 |CaseClauses|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |CaseClauses|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_을 |LabelIdentifier|의 StringValue로 둔다.
        1. _labelSet_이 _label_을 포함하면 *true*를 반환한다.
        1. _newLabelSet_을 _labelSet_과 « _label_ »의 list-concatenation으로 둔다.
        1. |LabelledItem|의 ContainsDuplicateLabels(_newLabelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |Block|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |Block|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsDuplicateLabels(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasDuplicates_를 |ModuleItemList|의 ContainsDuplicateLabels(_labelSet_)로 둔다.
        1. _hasDuplicates_가 *true*이면 *true*를 반환한다.
        1. |ModuleItem|의 ContainsDuplicateLabels(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedbreaktarget" oldids="sec-statement-semantics-static-semantics-containsundefinedbreaktarget,sec-block-static-semantics-containsundefinedbreaktarget,sec-if-statement-static-semantics-containsundefinedbreaktarget,sec-do-while-statement-static-semantics-containsundefinedbreaktarget,sec-while-statement-static-semantics-containsundefinedbreaktarget,sec-for-statement-static-semantics-containsundefinedbreaktarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget,sec-break-statement-static-semantics-containsundefinedbreaktarget,sec-with-statement-static-semantics-containsundefinedbreaktarget,sec-switch-statement-static-semantics-containsundefinedbreaktarget,sec-labelled-statements-static-semantics-containsundefinedbreaktarget,sec-try-statement-static-semantics-containsundefinedbreaktarget,sec-function-definitions-static-semantics-containsundefinedbreaktarget,sec-module-semantics-static-semantics-containsundefinedbreaktarget" type="sdo">
      <h1>
        정적 의미론: ContainsUndefinedBreakTarget (
        _labelSet_: 문자열들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |StatementList|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 첫 번째 |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _labelSet_이 |LabelIdentifier|의 StringValue를 포함하지 않으면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면
          1. 첫 번째 |CaseClauses|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 존재하지 않으면 *false*를 반환한다.
        1. 두 번째 |CaseClauses|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |CaseClauses|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_을 |LabelIdentifier|의 StringValue로 둔다.
        1. _newLabelSet_을 _labelSet_과 « _label_ »의 list-concatenation으로 둔다.
        1. |LabelledItem|의 ContainsUndefinedBreakTarget(_newLabelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedBreakTarget(_labelSet_)가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |ModuleItemList|의 ContainsUndefinedBreakTarget(_labelSet_)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |ModuleItem|의 ContainsUndefinedBreakTarget(_labelSet_)를 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedcontinuetarget" oldids="sec-statement-semantics-static-semantics-containsundefinedcontinuetarget,sec-block-static-semantics-containsundefinedcontinuetarget,sec-if-statement-static-semantics-containsundefinedcontinuetarget,sec-do-while-statement-static-semantics-containsundefinedcontinuetarget,sec-while-statement-static-semantics-containsundefinedcontinuetarget,sec-for-statement-static-semantics-containsundefinedcontinuetarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget,sec-continue-statement-static-semantics-containsundefinedcontinuetarget,sec-with-statement-static-semantics-containsundefinedcontinuetarget,sec-switch-statement-static-semantics-containsundefinedcontinuetarget,sec-labelled-statements-static-semantics-containsundefinedcontinuetarget,sec-try-statement-static-semantics-containsundefinedcontinuetarget,sec-function-definitions-static-semantics-containsundefinedcontinuetarget,sec-module-semantics-static-semantics-containsundefinedcontinuetarget" type="sdo">
      <h1>
        정적 의미론: ContainsUndefinedContinueTarget (
        _iterationSet_: 문자열들의 List,
        _labelSet_: 문자열들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>Statement : BlockStatement</emu-grammar>
      <emu-alg>
        1. |BlockStatement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _newIterationSet_을 _iterationSet_과 _labelSet_의 list-concatenation으로 둔다.
        1. |IterationStatement|의 ContainsUndefinedContinueTarget(_newIterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |StatementList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 첫 번째 |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 절은 부록(Annex) <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>에 의해 확장된다.</p>
      </emu-note>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _iterationSet_이 |LabelIdentifier|의 StringValue를 포함하지 않으면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. |Statement|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 첫 번째 |CaseClauses|가 존재하면
          1. 첫 번째 |CaseClauses|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 존재하지 않으면 *false*를 반환한다.
        1. 두 번째 |CaseClauses|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |CaseClauses|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. |StatementList|가 존재하면 |StatementList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_을 |LabelIdentifier|의 StringValue로 둔다.
        1. _newLabelSet_을 _labelSet_과 « _label_ »의 list-concatenation으로 둔다.
        1. |LabelledItem|의 ContainsUndefinedContinueTarget(_iterationSet_, _newLabelSet_)을 반환한다.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. |Catch|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)이 *true*이면 *true*를 반환한다.
        1. |Finally|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. _hasUndefinedLabels_를 |ModuleItemList|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)로 둔다.
        1. _hasUndefinedLabels_가 *true*이면 *true*를 반환한다.
        1. |ModuleItem|의 ContainsUndefinedContinueTarget(_iterationSet_, « »)을 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-function-name-inference">
    <h1>함수 이름 추론(Function Name Inference)</h1>

    <emu-clause id="sec-static-semantics-hasname" oldids="sec-semantics-static-semantics-hasname,sec-function-definitions-static-semantics-hasname,sec-arrow-function-definitions-static-semantics-hasname,sec-generator-function-definitions-static-semantics-hasname,sec-async-generator-function-definitions-static-semantics-hasname,sec-class-definitions-static-semantics-hasname,sec-async-function-definitions-static-semantics-HasName,sec-async-arrow-function-definitions-static-semantics-HasName" type="sdo">
      <h1>정적 의미론: HasName ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. IsFunctionDefinition of _expr_이 *false*이면 *false*를 반환한다.
        1. HasName of _expr_을 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ArrowFunction :
          ArrowParameters `=>` ConciseBody

        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

        ClassExpression :
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier ClassTail
      </emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isfunctiondefinition" oldids="sec-semantics-static-semantics-isfunctiondefinition,sec-grouping-operator-static-semantics-isfunctiondefinition,sec-static-semantics-static-semantics-isfunctiondefinition,sec-update-expressions-static-semantics-isfunctiondefinition,sec-unary-operators-static-semantics-isfunctiondefinition,sec-exp-operator-static-semantics-isfunctiondefinition,sec-multiplicative-operators-static-semantics-isfunctiondefinition,sec-additive-operators-static-semantics-isfunctiondefinition,sec-bitwise-shift-operators-static-semantics-isfunctiondefinition,sec-relational-operators-static-semantics-isfunctiondefinition,sec-equality-operators-static-semantics-isfunctiondefinition,sec-binary-bitwise-operators-static-semantics-isfunctiondefinition,sec-binary-logical-operators-static-semantics-isfunctiondefinition,sec-conditional-operator-static-semantics-isfunctiondefinition,sec-assignment-operators-static-semantics-isfunctiondefinition,sec-comma-operator-static-semantics-isfunctiondefinition,sec-function-definitions-static-semantics-isfunctiondefinition,sec-generator-function-definitions-static-semantics-isfunctiondefinition,sec-async-generator-function-definitions-static-semantics-isfunctiondefinition,sec-class-definitions-static-semantics-isfunctiondefinition,sec-async-function-definitions-static-semantics-IsFunctionDefinition" type="sdo">
      <h1>정적 의미론: IsFunctionDefinition ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. IsFunctionDefinition of _expr_을 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          RegularExpressionLiteral
          TemplateLiteral

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isanonymousfunctiondefinition" type="abstract operation">
      <h1>
        정적 의미론: IsAnonymousFunctionDefinition (
        _expr_: |AssignmentExpression| Parse Node, |Initializer| Parse Node, 또는 |Expression| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>인수가 이름을 바인딩하지 않는 함수 정의인지 판정한다.</dd>
      </dl>
      <emu-alg>
        1. IsFunctionDefinition of _expr_이 *false*이면 *false*를 반환한다.
        1. _hasName_을 HasName of _expr_으로 둔다.
        1. _hasName_이 *true*이면 *false*를 반환한다.
        1. *true*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isidentifierref" oldids="sec-semantics-static-semantics-isidentifierref,sec-static-semantics-static-semantics-isidentifierref" type="sdo">
      <h1>정적 의미론: IsIdentifierRef ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
      <emu-alg>
        1. *true*를 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
          CoverParenthesizedExpressionAndArrowParameterList

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-namedevaluation" oldids="sec-grouping-operator-runtime-semantics-namedevaluation,sec-function-definitions-runtime-semantics-namedevaluation,sec-arrow-function-definitions-runtime-semantics-namedevaluation,sec-generator-function-definitions-runtime-semantics-namedevaluation,sec-asyncgenerator-definitions-namedevaluation,sec-class-definitions-runtime-semantics-namedevaluation,sec-async-function-definitions-runtime-semantics-namedevaluation,sec-async-arrow-function-definitions-runtime-semantics-namedevaluation" type="sdo">
      <h1>
        런타임 의미론: NamedEvaluation (
        _name_: 프로퍼티 키 또는 Private Name,
        ): 함수 객체를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. _name_ 인수를 사용하여 _expr_의 NamedEvaluation을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
      <emu-alg>
        1. 단언: IsAnonymousFunctionDefinition(|Expression|)은 *true*이다.
        1. _name_ 인수를 사용하여 |Expression|의 NamedEvaluation을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |FunctionExpression|의 InstantiateOrdinaryFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |GeneratorExpression|의 InstantiateGeneratorFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |AsyncGeneratorExpression|의 InstantiateAsyncGeneratorFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |AsyncFunctionExpression|의 InstantiateAsyncFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |ArrowFunction|의 InstantiateArrowFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_ 인수를 사용하여 |AsyncArrowFunction|의 InstantiateAsyncArrowFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. _sourceText_를 |ClassExpression|이 매치한 소스 텍스트로 둔다.
        1. *undefined*, _name_, _sourceText_ 인수로 |ClassTail|의 ClassDefinitionEvaluation을 ?로 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        정적 의미론: Contains (
        _symbol_: 문법 기호,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>아래에 나열되지 않은 명세의 모든 문법 생성 규칙 대안은 암묵적으로 다음 기본 Contains 정의를 갖는다:</p>
      <emu-alg>
        1. 이 Parse Node의 각 자식 노드 _child_에 대해
          1. _child_가 _symbol_의 인스턴스이면 *true*를 반환한다.
          1. _child_가 비종결(nonterminal) 인스턴스이면
            1. _contained_를 _child_ Contains _symbol_의 결과로 둔다.
            1. _contained_가 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p>부분 구조에 의존하는 정적 의미 규칙은 일반적으로 함수 정의 내부를 들여다보지 않는다.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <emu-alg>
        1. _symbol_이 |ClassBody|이면 *true*를 반환한다.
        1. _symbol_이 |ClassHeritage|이면
          1. |ClassHeritage|가 존재하면 *true*, 아니면 *false*를 반환한다.
        1. |ClassHeritage|가 존재하면
          1. |ClassHeritage| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. |ClassBody|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-note>
        <p>부분 구조에 의존하는 정적 의미 규칙은 일반적으로 |PropertyName|을 제외하고 클래스 본문 내부를 들여다보지 않는다.</p>
      </emu-note>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-note>
        <p>부분 구조에 의존하는 정적 의미 규칙은 일반적으로 `static` 초기화 블록 내부를 들여다보지 않는다.</p>
      </emu-note>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _symbol_이 |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` 중 하나가 아니면 *false*를 반환한다.
        1. |ArrowParameters| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. |ConciseBody| Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_를 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ArrowFormalParameters|로 둔다.
        1. _formals_ Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _symbol_이 |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` 중 하나가 아니면 *false*를 반환한다.
        1. |AsyncConciseBody| Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _symbol_이 |NewTarget|, |SuperProperty|, |SuperCall|, `super`, `this` 중 하나가 아니면 *false*를 반환한다.
        1. _head_를 |CoverCallExpressionAndAsyncArrowHead|가 커버하는 |AsyncArrowHead|로 둔다.
        1. _head_ Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. |AsyncConciseBody| Contains _symbol_을 반환한다.
      </emu-alg>
      <emu-note>
        <p>Contains는 |ArrowFunction| 또는 |AsyncArrowFunction| 내에서 `new.target`, `this`, `super` 사용을 탐지하는 데 사용된다.</p>
      </emu-note>
      <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
      <emu-alg>
        1. _symbol_이 |MethodDefinition|이면 *true*를 반환한다.
        1. |MethodDefinition|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |MemberExpression| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. _symbol_이 |ReservedWord| `super`이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |CallExpression| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. |OptionalChain| Contains _symbol_이 *true*이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-computedpropertycontains" oldids="sec-object-initializer-static-semantics-computedpropertycontains,sec-method-definitions-static-semantics-computedpropertycontains,sec-generator-function-definitions-static-semantics-computedpropertycontains,sec-async-generator-function-definitions-static-semantics-computedpropertycontains,sec-class-definitions-static-semantics-computedpropertycontains,sec-async-function-definitions-static-semantics-ComputedPropertyContains" type="sdo">
      <h1>
        정적 의미론: ComputedPropertyContains (
        _symbol_: 문법 기호,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ClassElementName : PrivateIdentifier

        PropertyName : LiteralPropertyName
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
      <emu-alg>
        1. |ComputedPropertyName| Contains _symbol_의 결과를 반환한다.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _inList_를 |ClassElementList|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과로 둔다.
        1. _inList_가 *true*이면 *true*를 반환한다.
        1. |ClassElement|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|에 대해 _symbol_ 인수를 사용한 ComputedPropertyContains 결과를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>기타(Miscellaneous)</h1>
    <p>이 연산들은 명세 전반 여러 위치에서 사용된다.</p>

    <emu-clause id="sec-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |FunctionDeclaration|의 InstantiateOrdinaryFunctionObject를 반환한다.
      </emu-alg>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |GeneratorDeclaration|의 InstantiateGeneratorFunctionObject를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |AsyncGeneratorDeclaration|의 InstantiateAsyncGeneratorFunctionObject를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _env_, _privateEnv_ 인수로 |AsyncFunctionDeclaration|의 InstantiateAsyncFunctionObject를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindinginitialization" oldids="sec-identifiers-runtime-semantics-bindinginitialization,sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization" type="sdo">
      <h1>
        런타임 의미론: BindingInitialization (
        _value_: ECMAScript 언어 값,
        _environment_: Environment Record 또는 *undefined*,
        ): ~unused~를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_environment_에 *undefined*가 전달되면 초기화 값을 할당하는 데 PutValue 연산을 사용해야 함을 나타낸다. 이는 `var` 문 및 일부 non-strict 함수의 매개변수 목록( <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref> 참조)에 해당한다. 이 경우 렉시컬 바인딩은 초기화자 평가 전에 호이스팅되어 사전 초기화된다.</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. _name_을 |Identifier|의 StringValue로 둔다.
        1. ? InitializeBoundName(_name_, _value_, _environment_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. ? InitializeBoundName(*"yield"*, _value_, _environment_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. ? InitializeBoundName(*"await"*, _value_, _environment_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingPattern : ObjectBindingPattern</emu-grammar>
      <emu-alg>
        1. ? RequireObjectCoercible(_value_)를 수행한다.
        1. _value_, _environment_ 인수로 |ObjectBindingPattern|의 BindingInitialization을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingPattern : ArrayBindingPattern</emu-grammar>
      <emu-alg>
        1. _iteratorRecord_를 ? GetIterator(_value_, ~sync~)로 둔다.
        1. _result_를 (|ArrayBindingPattern|의 IteratorBindingInitialization(_iteratorRecord_, _environment_))의 Completion으로 둔다.
        1. _iteratorRecord_.[[Done]]이 *false*이면 ? IteratorClose(_iteratorRecord_, _result_)를 반환한다.
        1. ? _result_를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>
        ObjectBindingPattern :
          `{` BindingPropertyList `}`
          `{` BindingPropertyList `,` `}`
      </emu-grammar>
      <emu-alg>
        1. _value_, _environment_ 인수로 |BindingPropertyList|의 PropertyBindingInitialization을 ? 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _excludedNames_를 새 빈 List로 둔다.
        1. _value_, _environment_, _excludedNames_ 인수로 |BindingRestProperty|의 RestBindingInitialization을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. _excludedNames_를 _value_, _environment_ 인수로 |BindingPropertyList|의 PropertyBindingInitialization 결과로 둔다.
        1. _value_, _environment_, _excludedNames_ 인수로 |BindingRestProperty|의 RestBindingInitialization을 ?로 반환한다.
      </emu-alg>

      <emu-clause id="sec-initializeboundname" type="abstract operation">
        <h1>
          InitializeBoundName (
            _name_: String,
            _value_: ECMAScript 언어 값,
            _environment_: Environment Record 또는 *undefined*,
          ): ~unused~를 담는 normal completion 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _environment_가 *undefined*가 아니면
            1. ! _environment_.InitializeBinding(_name_, _value_)를 수행한다.
            1. ~unused~를 반환한다.
          1. Else,
            1. _lhs_를 ? ResolveBinding(_name_)으로 둔다.
            1. ? PutValue(_lhs_, _value_)를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        런타임 의미론: IteratorBindingInitialization (
        _iteratorRecord_: Iterator Record,
        _environment_: Environment Record 또는 *undefined*,
        ): ~unused~를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_environment_에 *undefined*가 전달되면 초기화 값 할당에 PutValue 연산을 사용해야 함을 나타낸다. 이는 non-strict 함수의 매개변수 목록에 해당한다. 그 경우 동일 이름 매개변수 가능성 때문에 사전 초기화된다.</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |Elision|이 존재하면
          1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ? 수행한다.
        1. |BindingRestElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |Elision|이 존재하면
          1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ? 수행한다.
        1. |BindingRestElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. |BindingElementList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |BindingElisionElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. |Elision|의 IteratorDestructuringAssignmentEvaluation(_iteratorRecord_)을 ? 수행한다.
        1. |BindingElement|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. _bindingId_를 |BindingIdentifier|의 StringValue로 둔다.
        1. _lhs_를 ? ResolveBinding(_bindingId_, _environment_)로 둔다.
        1. _v_를 *undefined*로 둔다.
        1. _iteratorRecord_.[[Done]]이 *false*이면
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |Initializer|가 존재하고 _v_가 *undefined*이면
          1. IsAnonymousFunctionDefinition(|Initializer|)이 *true*이면
            1. _v_를 ? NamedEvaluation(|Initializer|, _bindingId_)로 둔다.
          1. Else
            1. _defaultValue_를 ? Evaluation(|Initializer|)로 둔다.
            1. _v_를 ? GetValue(_defaultValue_)로 둔다.
        1. _environment_가 *undefined*이면 ? PutValue(_lhs_, _v_)를 반환한다.
        1. ? InitializeReferencedBinding(_lhs_, _v_)를 반환한다.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. _v_를 *undefined*로 둔다.
        1. _iteratorRecord_.[[Done]]이 *false*이면
          1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |Initializer|가 존재하고 _v_가 *undefined*이면
          1. _defaultValue_를 ? Evaluation(|Initializer|)로 둔다.
          1. _v_를 ? GetValue(_defaultValue_)로 둔다.
        1. |BindingPattern|의 BindingInitialization(_v_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. _lhs_를 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_)로 둔다.
        1. _A_를 ! ArrayCreate(0)로 둔다.
        1. _n_을 0으로 둔다.
        1. 반복,
          1. _next_를 ~done~으로 둔다.
          1. _iteratorRecord_.[[Done]]이 *false*이면
            1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. _environment_가 *undefined*이면 ? PutValue(_lhs_, _A_)를 반환한다.
            1. ? InitializeReferencedBinding(_lhs_, _A_)를 반환한다.
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)를 수행한다.
          1. _n_을 _n_ + 1로 둔다.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. _A_를 ! ArrayCreate(0)로 둔다.
        1. _n_을 0으로 둔다.
        1. 반복,
          1. _next_를 ~done~으로 둔다.
          1. _iteratorRecord_.[[Done]]이 *false*이면
            1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
          1. _next_가 ~done~이면
            1. |BindingPattern|의 BindingInitialization(_A_, _environment_)을 ?로 반환한다.
          1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)를 수행한다.
          1. _n_을 _n_ + 1로 둔다.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |FunctionRestParameter|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ? 수행한다.
        1. |FormalParameter|의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. _v_를 *undefined*로 둔다.
        1. 단언: _iteratorRecord_.[[Done]]는 *false*이다.
        1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
        1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |BindingIdentifier|의 BindingInitialization(_v_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_를 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ArrowFormalParameters|로 둔다.
        1. _formals_의 IteratorBindingInitialization(_iteratorRecord_, _environment_)을 ?로 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. _v_를 *undefined*로 둔다.
        1. 단언: _iteratorRecord_.[[Done]]는 *false*이다.
        1. _next_를 ? IteratorStepValue(_iteratorRecord_)로 둔다.
        1. _next_가 ~done~이 아니면 _v_를 _next_로 둔다.
        1. |BindingIdentifier|의 BindingInitialization(_v_, _environment_)을 ?로 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-assignmenttargettype" oldids="sec-identifiers-static-semantics-assignmenttargettype,sec-identifiers-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype,sec-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-grouping-operator-static-semantics-assignmenttargettype,sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget,sec-static-semantics-static-semantics-assignmenttargettype,sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-update-expressions-static-semantics-assignmenttargettype,sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget,sec-unary-operators-static-semantics-assignmenttargettype,sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget,sec-exp-operator-static-semantics-assignmenttargettype,sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget,sec-multiplicative-operators-static-semantics-assignmenttargettype,sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget,sec-additive-operators-static-semantics-assignmenttargettype,sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget,sec-bitwise-shift-operators-static-semantics-assignmenttargettype,sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget,sec-relational-operators-static-semantics-assignmenttargettype,sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget,sec-equality-operators-static-semantics-assignmenttargettype,sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-bitwise-operators-static-semantics-assignmenttargettype,sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-logical-operators-static-semantics-assignmenttargettype,sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-conditional-operator-static-semantics-assignmenttargettype,sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget,sec-assignment-operators-static-semantics-assignmenttargettype,sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget,sec-comma-operator-static-semantics-assignmenttargettype,sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" type="sdo">
      <h1>정적 의미론: AssignmentTargetType ( ): ~simple~, ~web-compat~, 또는 ~invalid~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. IsStrict(this |IdentifierReference|)가 *true*이고 |Identifier|의 StringValue가 *"eval"*, *"arguments"* 중 하나이면 ~invalid~를 반환한다.
        1. ~simple~을 반환한다.
      </emu-alg>
      <emu-grammar>
        IdentifierReference :
          `yield`
          `await`

        CallExpression :
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MemberExpression `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. ~simple~을 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          CoverParenthesizedExpressionAndArrowParameterList
      </emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. _expr_의 AssignmentTargetType을 반환한다.
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. [id="step-assignmenttargettype-web-compat", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-runtime-errors-for-function-call-assignment-targets" title></emu-xref>를 지원하고 IsStrict(this |CallExpression|)이 *false*이면
          1. ~web-compat~을 반환한다.
        1. ~invalid~를 반환한다.
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral

        CallExpression :
          SuperCall
          ImportCall
          CallExpression TemplateLiteral

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression TemplateLiteral
          `new` MemberExpression Arguments

        NewTarget :
          `new` `.` `target`

        ImportMeta :
          `import` `.` `meta`

        LeftHandSideExpression :
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. ~invalid~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-propname" oldids="sec-object-initializer-static-semantics-propname,sec-method-definitions-static-semantics-propname,sec-generator-function-definitions-static-semantics-propname,sec-async-generator-function-definitions-static-semantics-propname,sec-class-definitions-static-semantics-propname,sec-async-function-definitions-static-semantics-PropName" type="sdo">
      <h1>정적 의미론: PropName ( ): String 또는 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
      <emu-alg>
        1. |IdentifierReference|의 StringValue를 반환한다.
      </emu-alg>
      <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. |PropertyName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : IdentifierName

        AttributeKey : IdentifierName
      </emu-grammar>
      <emu-alg>
        1. |IdentifierName|의 StringValue를 반환한다.
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : StringLiteral

        AttributeKey : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. |StringLiteral|의 SV를 반환한다.
      </emu-alg>
      <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
      <emu-alg>
        1. _nbr_를 |NumericLiteral|의 NumericValue로 둔다.
        1. ! ToString(_nbr_)을 반환한다.
      </emu-alg>
      <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. |ClassElementName|의 PropName을 반환한다.
      </emu-alg>
      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. ~empty~를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>실행 가능한 코드와 실행 컨텍스트(Executable Code and Execution Contexts)</h1>

  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>Environment Record</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn>는 ECMAScript 코드의 렉시컬 중첩 구조를 기반으로 |Identifier|들을 특정 변수와 함수에 연계(association)하기 위해 사용되는 명세 타입이다. 보통 Environment Record는 |FunctionDeclaration|, |BlockStatement|, |TryStatement|의 |Catch| 절과 같은 ECMAScript 코드의 특정 구문 구조와 연관된다. 그러한 코드가 실행될 때마다 그 코드가 생성하는 식별자 바인딩을 기록하기 위해 새로운 Environment Record가 생성된다.</p>
    <p>모든 Environment Record는 [[OuterEnv]] 필드를 가지며, 이는 *null*이거나 바깥(Environment Record) 환경 레코드에 대한 참조이다. 이는 Environment Record 값들의 논리적 중첩을 모델링하는 데 사용된다. (내부) Environment Record의 바깥 참조는 논리적으로 그 내부 Environment Record를 둘러싸는 Environment Record에 대한 참조이다. 바깥 Environment Record 역시 자체의 바깥 Environment Record를 가질 수 있다. 하나의 Environment Record는 여러 내부 Environment Record의 바깥 환경으로 사용될 수 있다. 예를 들어, 어떤 |FunctionDeclaration|이 두 개의 중첩된 |FunctionDeclaration|을 포함한다면 각각의 중첩 함수 Environment Record의 바깥 Environment Record는 둘러싼 함수의 현재 평가에 대한 Environment Record가 된다.</p>
    <p>Environment Record는 순수히 명세 메커니즘이며 ECMAScript 구현의 특정한 실체(artefact)에 대응할 필요는 없다. ECMAScript 프로그램이 그러한 값을 직접 접근하거나 조작하는 것은 불가능하다.</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>Environment Record 타입 계층(The Environment Record Type Hierarchy)</h1>
      <p>Environment Record는 단순한 객체 지향 계층에 존재한다고 생각할 수 있는데, Environment Record 자체가 추상 클래스이고 세 개의 구체 하위 클래스(Declarative Environment Record, Object Environment Record, Global Environment Record)가 있다. Function Environment Record와 Module Environment Record는 Declarative Environment Record의 하위 클래스이다.</p>
      <ul>
        <li>
          <p>Environment Record (abstract)</p>
          <ul>
            <li>
              <p><em>Declarative Environment Record</em>는 |FunctionDeclaration|, |VariableDeclaration|, |Catch| 절처럼 식별자 바인딩을 ECMAScript 언어 값과 직접 연관시키는 ECMAScript 언어 구문 요소들의 효과를 정의하는 데 사용된다.</p>
              <ul>
                <li>
                  <p><em>Function Environment Record</em>는 ECMAScript 함수 객체의 호출에 대응하며 함수 내 최상위 선언들에 대한 바인딩을 포함한다. 새로운 `this` 바인딩을 설정할 수 있고 `super` 메서드 호출을 지원하기 위한 상태도 포착한다.</p>
                </li>
                <li>
                  <p><em>Module Environment Record</em>는 |Module|의 최상위 선언 바인딩을 포함한다. 또한 |Module|이 명시적으로 import한 바인딩을 포함한다. 그 [[OuterEnv]]는 Global Environment Record이다.</p>
                </li>
              </ul>
            </li>
            <li>
              <p><em>Object Environment Record</em>는 |WithStatement|처럼 식별자 바인딩을 어떤 객체의 프로퍼티와 연관시키는 ECMAScript 요소들의 효과를 정의하는 데 사용된다.</p>
            </li>
            <li>
              <p><em>Global Environment Record</em>는 |Script| 전역 선언에 사용된다. 바깥 환경을 가지지 않으며 [[OuterEnv]]는 *null*이다. 사전 채워진 식별자 바인딩을 가질 수 있고 관련된 전역 객체를 포함하며 그 전역 객체의 프로퍼티는 일부 전역 환경 식별자 바인딩을 제공한다. ECMAScript 코드가 실행되면서 전역 객체에 프로퍼티가 추가될 수 있고 초기 프로퍼티가 수정될 수 있다.</p>
            </li>
          </ul>
        </li>
      </ul>

      <p>Environment Record 추상 클래스는 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>에 정의된 추상 명세 메서드를 포함한다. 이 추상 메서드들은 각 구체 하위 클래스마다 구별되는 구체 알고리즘을 가진다.</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Environment Record의 추상 메서드(Abstract Methods of Environment Records)" oldids="table-15">
        <table>
          <thead>
            <tr>
              <th>
                메서드(Method)
              </th>
              <th>
                목적(Purpose)
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Environment Record가 문자열 값 _N_에 대한 바인딩을 가지는지 결정한다. 있다면 *true*, 없으면 *false*를 반환.
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Environment Record에 새이지만 아직 초기화되지 않은 변경 가능(mutable) 바인딩을 생성한다. 문자열 값 _N_은 바운드 이름 텍스트다. Boolean 인자 _D_가 *true*이면 해당 바인딩은 이후 삭제될 수 있다.
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Environment Record에 새이지만 아직 초기화되지 않은 변경 불가능(immutable) 바인딩을 생성한다. 문자열 값 _N_은 바운드 이름 텍스트다. _S_가 *true*이면 초기화 후 설정하려는 모든 시도는 (참조하는 연산의 strict 모드 설정과 무관하게) 항상 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              Environment Record 내 이미 존재하지만 초기화되지 않은 바인딩의 값을 설정한다. 문자열 값 _N_은 바운드 이름 텍스트. _V_는 바인딩에 대한 값이며 임의의 ECMAScript 언어 타입 값이다.
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              이미 존재하는 mutable 바인딩의 값을 설정한다. 문자열 값 _N_은 바운드 이름 텍스트, _V_는 값, _S_는 Boolean 플래그. _S_가 *true*이고 바인딩을 설정할 수 없다면 *TypeError* 예외를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              이미 존재하는 바인딩의 값을 반환한다. 문자열 값 _N_은 바운드 이름 텍스트. _S_는 strict 모드 코드에서 기원했거나 strict 모드 참조语 의미를 요구하는지 식별하는 데 사용된다. _S_가 *true*이고 바인딩이 존재하지 않으면 *ReferenceError*를 던진다. 바인딩이 존재하지만 초기화되지 않았다면 _S_ 값과 무관하게 *ReferenceError*를 던진다.
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              바인딩을 삭제한다. 문자열 값 _N_은 바운드 이름 텍스트. _N_에 대한 바인딩이 존재하면 제거하고 *true* 반환. 존재하지만 제거 불가하면 *false* 반환. 존재하지 않으면 *true* 반환.
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              Environment Record가 `this` 바인딩을 설정하는지 결정. 그렇다면 *true*, 아니면 *false*.
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              Environment Record가 `super` 메서드 바인딩을 설정하는지 결정. 그렇다면 *true*, 아니면 *false*. *true*이면 해당 Environment Record는 Function Environment Record임을 시사하지만, 그 역은 성립하지 않는다.
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              이 Environment Record가 `with` 문과 연관되면 with 객체를 반환. 아니면 *undefined* 반환.
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>Declarative Environment Record</h1>
        <p>각 <dfn variants="Declarative Environment Records">Declarative Environment Record</dfn>는 변수, constant, let, class, module, import 그리고/또는 function 선언을 포함하는 ECMAScript 프로그램 스코프와 연관된다. Declarative Environment Record는 그 스코프에 포함된 선언들이 정의한 식별자 집합을 바인딩한다.</p>

        <emu-clause id="sec-declarative-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean을 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>인수 식별자가 이 레코드에 의해 바인딩된 식별자 중 하나인지 판정한다.</dd>
          </dl>
          <emu-alg>
            1. _envRec_이 _N_에 대한 바인딩을 가지고 있으면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~를 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 이름 _N_에 대한 새로운 mutable 바인딩을 생성한다. 이미 존재해서는 안 된다. _D_가 *true*이면 삭제 대상 표시.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 이미 _N_ 바인딩을 갖지 않는다.
            1. _envRec_ 안에 _N_에 대한 초기화되지 않은 mutable 바인딩을 생성하고 _D_가 *true*이면 이후 DeleteBinding 호출로 삭제 가능함을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: String,
              _S_: Boolean,
            ): ~unused~를 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 이름 _N_에 대한 immutable 바인딩을 생성. 이미 존재해서는 안 된다. _S_가 *true*이면 strict 바인딩으로 표시.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 이미 _N_ 바인딩을 갖지 않는다.
            1. _envRec_에 _N_ immutable 바인딩을 생성하고 초기화되지 않았음을 기록. _S_가 *true*이면 strict 바인딩임을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
            ): ~unused~를 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이미 존재하는 식별자 _N_의 현재 바인딩 값(bound value)을 _V_로 설정한다. _N_에 대한 초기화되지 않은 바인딩이 이미 있어야 한다.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 _N_에 대한 초기화되지 않은 바인딩을 가져야 한다.
            1. _envRec_에서 _N_의 바운드 값을 _V_로 설정.
            1. <emu-not-ref>Record</emu-not-ref> _envRec_의 _N_ 바인딩이 초기화되었음을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 현재 바인딩 값을 _V_로 변경 시도. 보통 바인딩은 이미 존재하지만 드물게 없을 수도 있다. 바인딩이 immutable이고 _S_가 *true*이면 *TypeError*.</dd>
          </dl>
          <emu-alg>
            1. [id="step-setmutablebinding-missing-binding"] _envRec_에 _N_ 바인딩이 없다면
              1. _S_가 *true*이면 *ReferenceError* 예외.
              1. ! _envRec_.CreateMutableBinding(_N_, *true*) 수행.
              1. ! _envRec_.InitializeBinding(_N_, _V_) 수행.
              1. ~unused~ 반환.
            1. _envRec_에서 _N_ 바인딩이 strict 바인딩이면 _S_를 *true*로 설정.
            1. _envRec_에서 _N_ 바인딩이 아직 초기화되지 않았다면 *ReferenceError* 예외.
            1. Else if _envRec_에서 _N_ 바인딩이 mutable이면
              1. 그 값을 _V_로 변경.
            1. Else
              1. 단언: immutable 바인딩 값을 변경하려는 시도.
              1. _S_가 *true*이면 *TypeError* 예외.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>단계 <emu-xref href="#step-setmutablebinding-missing-binding"></emu-xref>에서 바인딩이 누락되는 ECMAScript 코드 예:</p>
            <pre><code class="javascript">function f() { eval("var x; x = (delete x, 0);"); }</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이름이 _N_인 바인딩된 식별자의 값을 반환. 바인딩이 존재하지만 초기화되지 않았으면 _S_와 무관하게 *ReferenceError*.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 _N_ 바인딩을 가진다.
            1. _envRec_의 _N_ 바인딩이 초기화되지 않았다면 *ReferenceError* 예외.
            1. 현재 _envRec_에 _N_으로 바인딩된 값을 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean을 담는 normal completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>삭제 대상으로 명시적으로 지정된 바인딩만 삭제할 수 있다.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 _N_ 바인딩을 가진다.
            1. _envRec_의 _N_ 바인딩이 삭제 불가라면 *false* 반환.
            1. _envRec_에서 _N_ 바인딩 제거.
            1. *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>일반 Declarative Environment Record(즉 Function Environment Record나 Module Environment Record가 아닌 것)는 `this` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>일반 Declarative Environment Record는 `super` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>Object Environment Record</h1>
        <p>각 <dfn variants="Object Environment Records">Object Environment Record</dfn>는 <em>binding object</em>라 불리는 객체와 연관된다. Object Environment Record는 그 binding object의 프로퍼티 이름과 직접 대응하는 문자열 식별자 이름 집합을 바인딩한다. |IdentifierName| 형태가 아닌 프로퍼티 키는 포함되지 않는다. own 및 상속 프로퍼티 모두 [[Enumerable]] 속성과 무관하게 포함된다. 객체에 프로퍼티가 동적으로 추가/삭제될 수 있으므로 Object Environment Record가 바인딩하는 식별자 집합은 프로퍼티를 추가/삭제하는 어떤 연산의 부수 효과로 잠재적으로 변화할 수 있다. 그러한 부수 효과로 생성된 바인딩은 대응 프로퍼티의 Writable 속성이 *false*일지라도 mutable 바인딩으로 간주된다. Object Environment Record에는 immutable 바인딩이 존재하지 않는다.</p>
        <p>`with` 문(<emu-xref href="#sec-with-statement"></emu-xref>)에 대해 생성된 Object Environment Record는 함수 호출에서 사용할 암묵적 *this* 값을 그 binding object로 제공할 수 있다. 이 기능은 Boolean [[IsWithEnvironment]] 필드로 제어된다.</p>
        <p>Object Environment Record는 <emu-xref href="#table-additional-fields-of-object-environment-records"></emu-xref>에 나열된 추가 상태 필드를 가진다.</p>
        <emu-table id="table-additional-fields-of-object-environment-records" caption="Object Environment Record의 추가 필드(Additional Fields of Object Environment Records)">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름(Field Name)
                </th>
                <th>
                  값(Value)
                </th>
                <th>
                  의미(Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[BindingObject]]
              </td>
              <td>
                객체(Object)
              </td>
              <td>
                이 Environment Record의 바인딩 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[IsWithEnvironment]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                이 Environment Record가 `with` 문을 위해 생성되었는지 여부.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-object-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>연관된 binding object가 이름 _N_인 프로퍼티를 가지는지 판정한다.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. _foundBinding_을 ? HasProperty(_bindingObject_, _N_)로 둔다.
            1. _foundBinding_이 *false*이면 *false* 반환.
            1. _envRec_.[[IsWithEnvironment]]가 *false*이면 *true* 반환.
            1. _unscopables_를 ? Get(_bindingObject_, %Symbol.unscopables%)로 둔다.
            1. _unscopables_가 Object이면
              1. _blocked_를 ToBoolean(? Get(_unscopables_, _N_))로 둔다.
              1. _blocked_가 *true*이면 *false* 반환.
            1. *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>Environment Record의 binding object에 이름 _N_ 프로퍼티를 생성하고 값을 *undefined*로 초기화. _D_가 *true*이면 새 프로퍼티 [[Configurable]]을 *true*, 아니면 *false*.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }) 수행.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>보통 _envRec_은 _N_ 바인딩을 갖지 않지만 갖고 있다면 DefinePropertyOrThrow 의미론이 기존 바인딩을 교체/섀도우하거나 abrupt completion을 유발할 수 있다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>Object Environment Record의 CreateImmutableBinding 구체 메서드는 이 명세 내에서 사용되지 않는다.</p>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이름 _N_인 바인딩 객체 프로퍼티의 값을 _V_로 설정.</dd>
          </dl>
          <emu-alg>
            1. ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>이 명세에서 Object Environment Record에 대한 모든 CreateMutableBinding 사용은 같은 이름에 대한 InitializeBinding 호출로 즉시 이어지므로, 초기화 상태를 명시적으로 추적하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>연관된 binding object의 프로퍼티 _N_ 값을 _V_로 설정 시도. 보통 존재하지만 없거나 쓰기 불가능이면 _S_에 따라 오류 처리.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. _stillExists_를 ? HasProperty(_bindingObject_, _N_)로 둔다.
            1. _stillExists_가 *false*이고 _S_가 *true*이면 *ReferenceError* 예외.
            1. ? Set(_bindingObject_, _N_, _V_, _S_) 수행.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>binding object의 이름 _N_ 프로퍼티 값을 반환. 존재하지 않을 경우 _S_에 따라 결과 결정.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. _value_를 ? HasProperty(_bindingObject_, _N_)로 둔다.
            1. _value_가 *false*이면
              1. _S_가 *false*이면 *undefined* 반환; 아니면 *ReferenceError* 예외.
            1. ? Get(_bindingObject_, _N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>[[Configurable]]이 *true*인 환경 객체 프로퍼티에 대응되는 바인딩만 삭제 가능.</dd>
          </dl>
          <emu-alg>
            1. _bindingObject_를 _envRec_.[[BindingObject]]로 둔다.
            1. ? <emu-meta effects="user-code">_bindingObject_.[[Delete]]</emu-meta>(_N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>Object Environment Record는 `this` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>Object Environment Record는 `super` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): Object 또는 *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[IsWithEnvironment]]가 *true*이면 _envRec_.[[BindingObject]] 반환.
            1. 아니면 *undefined* 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records" oldids="function-environment">
        <h1>Function Environment Record</h1>
        <p><dfn variants="Function Environment Records">Function Environment Record</dfn>는 함수의 최상위 스코프를 나타내는 Declarative Environment Record이며 함수가 |ArrowFunction|이 아니면 `this` 바인딩을 제공한다. 함수가 |ArrowFunction|이 아니고 `super`를 참조하는 경우 그 Function Environment Record는 함수 내에서 `super` 메서드 호출을 수행하는 데 사용되는 상태도 포함한다.</p>
        <p>Function Environment Record는 <emu-xref href="#table-additional-fields-of-function-environment-records"></emu-xref>에 나열된 추가 상태 필드를 가진다.</p>
        <emu-table id="table-additional-fields-of-function-environment-records" caption="Function Environment Record의 추가 필드(Additional Fields of Function Environment Records)" oldids="table-16">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                ECMAScript 언어 값
              </td>
              <td>
                이 함수 호출에 사용되는 *this* 값.
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                ~lexical~, ~initialized~, 또는 ~uninitialized~
              </td>
              <td>
                값이 ~lexical~이면 이는 |ArrowFunction|이며 로컬 *this* 값이 없다.
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                ECMAScript 함수 객체
              </td>
              <td>
                이 Environment Record를 생성한 호출의 대상 함수 객체.
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                생성자 또는 *undefined*
              </td>
              <td>
                [[Construct]] 내부 메서드로 생성되었다면 [[Construct]] _newTarget_ 매개변수의 값; 아니면 *undefined*.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>Function Environment Record는 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>에 나열된 모든 Declarative Environment Record 메서드를 지원하고 HasThisBinding 및 HasSuperBinding을 제외한 명세는 동일하다. 추가로 <emu-xref href="#table-additional-methods-of-function-environment-records"></emu-xref>에 나열된 메서드를 지원한다:</p>
        <emu-table id="table-additional-methods-of-function-environment-records" caption="Function Environment Record의 추가 메서드(Additional Methods of Function Environment Records)" oldids="table-17">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                이 Environment Record의 `this` 바인딩 값을 반환. 초기화되지 않았으면 *ReferenceError*.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-bindthisvalue" type="abstract operation">
          <h1>
            BindThisValue (
              _envRec_: Function Environment Record,
              _V_: ECMAScript 언어 값,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_envRec_.[[ThisValue]]를 설정하고 초기화되었음을 기록한다.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_.[[ThisBindingStatus]]는 ~lexical~이 아니다.
            1. _envRec_.[[ThisBindingStatus]]가 ~initialized~이면 *ReferenceError* 예외.
            1. _envRec_.[[ThisValue]]를 _V_로 설정.
            1. _envRec_.[[ThisBindingStatus]]를 ~initialized~로 설정.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): Boolean</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[ThisBindingStatus]]가 ~lexical~이면 *false*, 아니면 *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): Boolean</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[ThisBindingStatus]]가 ~lexical~이면 *false* 반환.
            1. _envRec_.[[FunctionObject]].[[HomeObject]]가 *undefined*이면 *false*, 아니면 *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): ECMAScript 언어 값 또는 throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_.[[ThisBindingStatus]]는 ~lexical~이 아니다.
            1. _envRec_.[[ThisBindingStatus]]가 ~uninitialized~이면 *ReferenceError* 예외.
            1. _envRec_.[[ThisValue]] 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getsuperbase" type="abstract operation">
          <h1>
            GetSuperBase (
              _envRec_: Function Environment Record,
            ): Object, *null*, 또는 *undefined*
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_envRec_에 바인딩된 `super` 프로퍼티 접근의 기반 객체를 반환한다. *undefined* 값은 그러한 접근이 런타임 오류를 낼 것임을 나타낸다.</dd>
          </dl>
          <emu-alg>
            1. _home_을 _envRec_.[[FunctionObject]].[[HomeObject]]로 둔다.
            1. _home_이 *undefined*이면 *undefined* 반환.
            1. 단언: _home_은 ordinary object.
            1. ! _home_.[[GetPrototypeOf]]() 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>Global Environment Record</h1>
        <p><dfn variants="Global Environment Records">Global Environment Record</dfn>는 공통 realm에서 처리되는 모든 ECMAScript |Script| 요소가 공유하는 가장 바깥 스코프를 나타낸다. Global Environment Record는 내장(global) 전역(<emu-xref href="#sec-global-object"></emu-xref> 절), 전역 객체의 프로퍼티 및 |Script| 내 모든 최상위 선언(<emu-xref href="#sec-static-semantics-toplevellexicallyscopeddeclarations"></emu-xref>, <emu-xref href="#sec-static-semantics-toplevelvarscopeddeclarations"></emu-xref>)의 바인딩을 제공한다.</p>
        <p>Global Environment Record는 논리적으로 단일 레코드이지만 Object Environment Record와 Declarative Environment Record를 캡슐화한 합성체로 명세된다. Object Environment Record는 관련 Realm Record의 전역 객체를 기본 객체로 가진다. 이 전역 객체는 Global Environment Record의 GetThisBinding 구체 메서드가 반환하는 값이다. Global Environment Record의 Object Environment Record 구성 요소는 모든 내장 전역(<emu-xref href="#sec-global-object"></emu-xref>)과 전역 코드에 포함된 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableStatement|이 도입한 바인딩을 포함한다. 전역 코드의 다른 ECMAScript 선언에 대한 바인딩은 Global Environment Record의 Declarative Environment Record 구성 요소에 들어 있다.</p>
        <p>프로퍼티는 전역 객체에 직접 생성될 수 있다. 따라서 Global Environment Record의 Object Environment Record 구성 요소는 선언에 의해 명시적으로 생성된 바인딩과 전역 객체의 프로퍼티로 암묵적으로 생성된 바인딩을 모두 포함할 수 있다. 어느 바인딩이 선언을 통해 명시적으로 생성되었는지 식별하기 위해 Global Environment Record는 CreateGlobalVarBinding 및 CreateGlobalFunctionBinding 추상 연산을 사용해 바인딩된 이름 목록을 유지한다.</p>
        <p>Global Environment Record는 <emu-xref href="#table-additional-fields-of-global-environment-records"></emu-xref>에 나열된 추가 필드와 <emu-xref href="#table-additional-methods-of-global-environment-records"></emu-xref>에 나열된 추가 메서드를 가진다.</p>
        <emu-table id="table-additional-fields-of-global-environment-records" caption="Global Environment Record의 추가 필드(Additional Fields of Global Environment Records)" oldids="table-18">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ObjectRecord]]
              </td>
              <td>
                Object Environment Record
              </td>
              <td>
                바인딩 객체는 전역 객체. 관련 realm의 전역 코드 내 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableDeclaration| 바인딩과 전역 내장 바인딩을 포함.
              </td>
            </tr>
            <tr>
              <td>
                [[GlobalThisValue]]
              </td>
              <td>
                Object
              </td>
              <td>
                전역 스코프에서 `this`가 반환하는 값. 호스트는 임의의 ECMAScript Object 값을 제공할 수 있다.
              </td>
            </tr>
            <tr>
              <td>
                [[DeclarativeRecord]]
              </td>
              <td>
                Declarative Environment Record
              </td>
              <td>
                <emu-not-ref>Contains</emu-not-ref> 전역 코드 선언 중 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|, |VariableDeclaration|을 제외한 모든 선언 바인딩.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-additional-methods-of-global-environment-records" caption="Global Environment Record의 추가 메서드(Additional Methods of Global Environment Records)" oldids="table-19">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                이 Environment Record의 `this` 바인딩 값을 반환.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-global-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>인수 식별자가 레코드에 의해 바인딩된 식별자 중 하나인지 판정.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면 *true* 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.HasBinding</emu-meta>(_N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: String,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 _N_ mutable 바인딩을 새로 생성. 관련 DeclarativeRecord에 생성. 이미 존재하면 안 됨. _D_가 *true*면 삭제 가능 표시.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면 *TypeError* 예외.
            1. ! _DclRec_.CreateMutableBinding(_N_, _D_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: String,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>초기화되지 않은 _N_ immutable 바인딩 생성. 이미 존재하면 안 됨. _S_가 *true*이면 strict 바인딩.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면 *TypeError* 예외.
            1. ! _DclRec_.CreateImmutableBinding(_N_, _S_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 현재 바인딩 값을 _V_로 설정. _N_에 대한 초기화되지 않은 바인딩이 이미 존재해야 한다.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ! _DclRec_.InitializeBinding(_N_, _V_) 반환.
            1. 단언: 바인딩이 존재한다면 Object Environment Record에 있다.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: String,
              _V_: ECMAScript 언어 값,
              _S_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 현재 바인딩 값을 _V_로 변경 시도. immutable 바인딩이고 _S_가 *true*이면 *TypeError*. 프로퍼티 _N_은 보통 존재하지만 없거나 현재 writable이 아닐 수도 있으며 이는 _S_에 따라 처리.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ? _DclRec_.SetMutableBinding(_N_, _V_, _S_) 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>식별자 _N_의 값을 반환. 바인딩이 초기화되지 않았으면 *ReferenceError*. 프로퍼티 _N_은 보통 존재하지만 없거나 writable이 아닐 수도 있는데 이는 _S_에 따라 처리.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ? _DclRec_.GetBindingValue(_N_, _S_) 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. ? <emu-meta effects="user-code">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>삭제 대상으로 명시된 바인딩만 삭제 가능.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_)이 *true*이면
              1. ! _DclRec_.DeleteBinding(_N_) 반환.
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? HasOwnProperty(_globalObject_, _N_)로 둔다.
            1. _existingProp_이 *true*이면
              1. ? <emu-meta effects="user-code">_ObjRec_.DeleteBinding</emu-meta>(_N_) 반환.
            1. *true* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *true* 반환.
          </emu-alg>
          <emu-note>
            <p>Global Environment Record는 항상 `this` 바인딩을 제공한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *false* 반환.
          </emu-alg>
          <emu-note>
            <p>Global Environment Record는 `super` 바인딩을 제공하지 않는다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): Object를 담는 normal completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. _envRec_.[[GlobalThisValue]] 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-haslexicaldeclaration" type="abstract operation">
          <h1>
            HasLexicalDeclaration (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>인수 식별자가 _envRec_에서 |LexicalDeclaration| 또는 |ClassDeclaration| 같은 렉시컬 선언을 사용해 생성된 바인딩을 가지는지 판정.</dd>
          </dl>
          <emu-alg>
            1. _DclRec_을 _envRec_.[[DeclarativeRecord]]로 둔다.
            1. ! _DclRec_.HasBinding(_N_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasrestrictedglobalproperty" type="abstract operation">
          <h1>
            HasRestrictedGlobalProperty (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>인수 식별자가 전역 객체의, 전역 렉시컬 바인딩으로 섀도우 되어서는 안 되는 프로퍼티 이름인지 판정.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)로 둔다.
            1. _existingProp_이 *undefined*이면 *false* 반환.
            1. _existingProp_.[[Configurable]]이 *true*이면 *false* 반환.
            1. *true* 반환.
          </emu-alg>
          <emu-note>
            <p>프로퍼티는 var나 function 선언 대신 직접 전역 객체에 존재할 수도 있다. 글로벌 렉시컬 바인딩은 전역 객체의 non-configurable 프로퍼티와 같은 이름으로 생성될 수 없다. *"undefined"* 전역 프로퍼티가 예.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalvar" type="abstract operation">
          <h1>
            CanDeclareGlobalVar (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>같은 _N_으로 CreateGlobalVarBinding 호출이 성공할지 여부 결정. 중복 var 선언 및 기존 전역 객체 프로퍼티에 대한 var 선언 허용.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _hasProperty_를 ? HasOwnProperty(_globalObject_, _N_)로 둔다.
            1. _hasProperty_가 *true*이면 *true* 반환.
            1. ? IsExtensible(_globalObject_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalfunction" type="abstract operation">
          <h1>
            CanDeclareGlobalFunction (
              _envRec_: Global Environment Record,
              _N_: String,
            ): Boolean 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>같은 _N_으로 CreateGlobalFunctionBinding 호출이 성공할지 여부 결정.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)로 둔다.
            1. _existingProp_이 *undefined*이면 ? IsExtensible(_globalObject_) 반환.
            1. _existingProp_.[[Configurable]]이 *true*이면 *true* 반환.
            1. IsDataDescriptor(_existingProp_)가 *true*이고 _existingProp_ 속성 값이 { [[Writable]]: *true*, [[Enumerable]]: *true* }이면 *true* 반환.
            1. *false* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalvarbinding" type="abstract operation">
          <h1>
            CreateGlobalVarBinding (
              _envRec_: Global Environment Record,
              _N_: String,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>연관된 Object Environment Record에 mutable 바인딩을 생성·초기화. 이미 존재하면 재사용되고 초기화된 것으로 간주.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _hasProperty_를 ? HasOwnProperty(_globalObject_, _N_)로 둔다.
            1. _extensible_을 ? IsExtensible(_globalObject_)로 둔다.
            1. _hasProperty_가 *false*이고 _extensible_이 *true*이면
              1. ? <emu-meta effects="user-code">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_) 수행.
              1. ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalfunctionbinding" type="abstract operation">
          <h1>
            CreateGlobalFunctionBinding (
              _envRec_: Global Environment Record,
              _N_: String,
              _V_: ECMAScript 언어 값,
              _D_: Boolean,
            ): ~unused~ 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>연관된 Object Environment Record에 mutable 바인딩을 생성·초기화. 이미 존재하면 대체.</dd>
          </dl>
          <emu-alg>
            1. _ObjRec_을 _envRec_.[[ObjectRecord]]로 둔다.
            1. _globalObject_를 _ObjRec_.[[BindingObject]]로 둔다.
            1. _existingProp_을 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)로 둔다.
            1. _existingProp_이 *undefined*이거나 _existingProp_.[[Configurable]]이 *true*이면
              1. _desc_를 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }로 둔다.
            1. Else
              1. _desc_를 PropertyDescriptor { [[Value]]: _V_ }로 둔다.
            1. ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_) 수행.
            1. [id="step-createglobalfunctionbinding-set"] ? Set(_globalObject_, _N_, _V_, *false*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
          <emu-note>
            <p>전역 함수 선언은 항상 전역 객체의 own 프로퍼티로 표현된다. 가능하면 기존 own 프로퍼티가 표준 속성 집합으로 재구성된다. 단계 <emu-xref href="#step-createglobalfunctionbinding-set"></emu-xref>은 InitializeBinding 구체 메서드 호출과 동등하며 _globalObject_가 Proxy이면 동일한 Proxy 트랩 호출 순서를 만든다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-module-environment-records" oldids="module-environment">
        <h1>Module Environment Record</h1>
        <p><dfn variants="Module Environment Records">Module Environment Record</dfn>는 ECMAScript |Module|의 바깥 스코프를 나타내는 Declarative Environment Record이며, 일반 mutable/immutable 바인딩 외에 다른 Environment Record에 존재하는 대상 바인딩에 간접 접근을 제공하는 immutable import 바인딩도 제공한다.</p>
        <p>Module Environment Record는 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref>에 나열된 모든 Declarative Environment Record 메서드를 지원하며 GetBindingValue, DeleteBinding, HasThisBinding, GetThisBinding을 제외하고 동일한 명세를 공유한다. 추가로 <emu-xref href="#table-additional-methods-of-module-environment-records"></emu-xref>에 나열된 메서드를 지원한다:</p>
        <emu-table id="table-additional-methods-of-module-environment-records" caption="Module Environment Record의 추가 메서드(Additional Methods of Module Environment Records)" oldids="table-20">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                이 Environment Record의 `this` 바인딩 값을 반환.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-module-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: String,
              _S_: Boolean,
            ): ECMAScript 언어 값 또는 throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>

            <dt>description</dt>
            <dd>이름 _N_인 바인딩된 식별자 값을 반환. 간접 바인딩이면 대상 바인딩 값을 반환. 바인딩이 존재하지만 초기화되지 않았으면 *ReferenceError*.</dd>
          </dl>
          <emu-alg>
            1. 단언: _S_는 *true*.
            1. 단언: _envRec_은 _N_ 바인딩을 가진다.
            1. _N_에 대한 바인딩이 간접 바인딩이면
              1. 이 _N_ 바인딩 생성 시 제공된 간접 값 _M_, _N2_를 둔다.
              1. _targetEnv_를 _M_.[[Environment]]로 둔다.
              1. _targetEnv_가 ~empty~이면 *ReferenceError* 예외.
              1. ? <emu-meta effects="user-code">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*) 반환.
            1. _envRec_의 _N_ 바인딩이 초기화되지 않았으면 *ReferenceError* 예외.
            1. 현재 _envRec_에 _N_으로 바인딩된 값을 반환.
          </emu-alg>
          <emu-note>
            <p>_S_는 항상 *true*인데 |Module|은 항상 strict 모드 코드이기 때문이다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>Module Environment Record의 DeleteBinding 구체 메서드는 이 명세 내에서 사용되지 않는다.</p>
          <emu-note>
            <p>Module Environment Record는 strict 코드 내에서만 사용되고 초기 에러 규칙이 strict 코드에서 delete 연산자가 Module Environment Record 바인딩으로 해석될 Reference Record에 적용되는 것을 방지한다. <emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref> 참조.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *true* 반환.
          </emu-alg>
          <emu-note>
            <p>Module Environment Record는 항상 `this` 바인딩을 제공한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): *undefined*를 담는 normal completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. *undefined* 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createimportbinding" type="abstract operation">
          <h1>
            CreateImportBinding (
              _envRec_: Module Environment Record,
              _N_: String,
              _M_: Module Record,
              _N2_: String,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>이름 _N_에 대한 새로 초기화된 immutable 간접 바인딩을 생성. _envRec_에 _N_ 바인딩이 이미 존재해서는 안 됨. _N2_는 _M_의 Module Environment Record에 존재하는 바인딩 이름. 새 바인딩의 값 접근은 대상 바인딩 값을 간접적으로 접근.</dd>
          </dl>
          <emu-alg>
            1. 단언: _envRec_은 이미 _N_ 바인딩을 갖지 않는다.
            1. 단언: _M_.[[Environment]]가 인스턴스화될 때 _N2_에 대한 direct 바인딩을 가진다.
            1. _envRec_에 _N_ immutable 간접 바인딩을 생성하여 _M_, _N2_를 대상 바인딩으로 참조하고 초기화되었음을 기록.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>Environment Record 연산(Environment Record Operations)</h1>
      <p>다음 추상 연산들은 명세에서 Environment Record를 조작하기 위해 사용된다:</p>

      <emu-clause id="sec-getidentifierreference" type="abstract operation">
        <h1>
          GetIdentifierReference (
            _env_: Environment Record 또는 *null*,
            _name_: String,
            _strict_: Boolean,
          ): Reference Record 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _env_가 *null*이면
            1. Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 반환.
          1. _exists_를 ? <emu-meta effects="user-code">_env_.HasBinding</emu-meta>(_name_)로 둔다.
          1. _exists_가 *true*이면
            1. Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 반환.
          1. Else
            1. _outer_를 _env_.[[OuterEnv]]로 둔다.
            1. ? GetIdentifierReference(_outer_, _name_, _strict_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newdeclarativeenvironment" type="abstract operation">
        <h1>
          NewDeclarativeEnvironment (
            _E_: Environment Record 또는 *null*,
          ): Declarative Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 바인딩이 없는 새 Declarative Environment Record _env_를 만든다.
          1. _env_.[[OuterEnv]]를 _E_로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newobjectenvironment" type="abstract operation">
        <h1>
          NewObjectEnvironment (
            _O_: Object,
            _W_: Boolean,
            _E_: Environment Record 또는 *null*,
          ): Object Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 새 Object Environment Record _env_ 생성.
          1. _env_.[[BindingObject]]를 _O_로 설정.
          1. _env_.[[IsWithEnvironment]]를 _W_로 설정.
          1. _env_.[[OuterEnv]]를 _E_로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" type="abstract operation">
        <h1>
          NewFunctionEnvironment (
            _F_: ECMAScript 함수 객체,
            _newTarget_: Object 또는 *undefined*,
          ): Function Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 바인딩이 없는 새 Function Environment Record _env_ 생성.
          1. _env_.[[FunctionObject]]를 _F_로 설정.
          1. _F_.[[ThisMode]]가 ~lexical~이면 _env_.[[ThisBindingStatus]]를 ~lexical~로 설정.
          1. Else _env_.[[ThisBindingStatus]]를 ~uninitialized~로 설정.
          1. _env_.[[NewTarget]]를 _newTarget_으로 설정.
          1. _env_.[[OuterEnv]]를 _F_.[[Environment]]로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newglobalenvironment" type="abstract operation">
        <h1>
          NewGlobalEnvironment (
            _G_: Object,
            _thisValue_: Object,
          ): Global Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _objRec_을 NewObjectEnvironment(_G_, *false*, *null*)로 둔다.
          1. _dclRec_를 NewDeclarativeEnvironment(*null*)로 둔다.
          1. 새 Global Environment Record _env_ 생성.
          1. _env_.[[ObjectRecord]]를 _objRec_로 설정.
          1. _env_.[[GlobalThisValue]]를 _thisValue_로 설정.
          1. _env_.[[DeclarativeRecord]]를 _dclRec_로 설정.
          1. _env_.[[OuterEnv]]를 *null*로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" type="abstract operation">
        <h1>
          NewModuleEnvironment (
            _E_: Environment Record,
          ): Module Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 바인딩이 없는 새 Module Environment Record _env_ 생성.
          1. _env_.[[OuterEnv]]를 _E_로 설정.
          1. _env_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-privateenvironment-records">
    <h1>PrivateEnvironment 레코드(PrivateEnvironment Records)</h1>
    <p><dfn id="privateenvironment-record" variants="PrivateEnvironment Records">PrivateEnvironment Record</dfn>는 ECMAScript 코드에서 |ClassDeclaration| 및 |ClassExpression|의 렉시컬 중첩 구조를 기반으로 Private Name들을 추적하기 위해 사용되는 명세 메커니즘이다. 이는 Environment Record와 유사하지만 별개의 것이다. 각 PrivateEnvironment Record는 하나의 |ClassDeclaration| 또는 |ClassExpression|에 연결된다. 그러한 클래스가 평가될 때마다, 그 클래스가 선언한 Private Name들을 기록하기 위해 새로운 PrivateEnvironment Record가 생성된다.</p>
    <p>각 PrivateEnvironment Record는 <emu-xref href="#table-privateenvironment-records"></emu-xref>에 정의된 필드들을 가진다.</p>
    <emu-table id="table-privateenvironment-records" caption="PrivateEnvironment Record 필드(PrivateEnvironment Record Fields)">
      <table>
        <thead>
          <tr>
            <th>
              필드 이름(Field Name)
            </th>
            <th>
              값 타입(Value Type)
            </th>
            <th>
              의미(Meaning)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[OuterPrivateEnvironment]]
          </td>
          <td>
            PrivateEnvironment Record 또는 *null*
          </td>
          <td>
            가장 가까운 둘러싸는 클래스의 PrivateEnvironment Record. 이 PrivateEnvironment Record가 연결된 클래스가 다른 어떤 클래스에도 포함되지 않았다면 *null*.
          </td>
        </tr>
        <tr>
          <td>
            [[Names]]
          </td>
          <td>
            Private Name들의 List
          </td>
          <td>
            이 클래스가 선언한 Private Name들.
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-privateenvironment-record-operations">
      <h1>PrivateEnvironment Record 연산(PrivateEnvironment Record Operations)</h1>
      <p>다음 추상 연산들은 이 명세에서 PrivateEnvironment Record에 대해 동작하기 위해 사용된다:</p>

      <emu-clause id="sec-newprivateenvironment" type="abstract operation">
        <h1>
          NewPrivateEnvironment (
            _outerPrivateEnv_: PrivateEnvironment Record 또는 *null*,
          ): PrivateEnvironment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _names_를 새 빈 List로 둔다.
          1. PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivateEnv_, [[Names]]: _names_ } 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-resolve-private-identifier" type="abstract operation">
        <h1>
          ResolvePrivateIdentifier (
            _privateEnv_: PrivateEnvironment Record,
            _identifier_: String,
          ): Private Name
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _names_를 _privateEnv_.[[Names]]로 둔다.
          1. _names_의 각 Private Name _pn_에 대해
            1. _pn_.[[Description]]이 _identifier_이면
              1. _pn_을 반환한다.
          1. _outerPrivateEnv_를 _privateEnv_.[[OuterPrivateEnvironment]]로 둔다.
          1. 단언: _outerPrivateEnv_는 *null*이 아니다.
          1. ResolvePrivateIdentifier(_outerPrivateEnv_, _identifier_)를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realm들(Realms)</h1>
    <p>평가되기 전에 모든 ECMAScript 코드는 하나의 <dfn id="realm" variants="realms">realm</dfn>과 연계되어야 한다. 개념적으로 realm은 일련의 intrinsic 객체, ECMAScript 전역 환경, 그 전역 환경의 범위 내에서 로드된 모든 ECMAScript 코드, 그리고 기타 관련 상태 및 자원으로 구성된다.</p>
    <p>realm은 이 명세에서 <emu-xref href="#table-realm-record-fields"></emu-xref>에 지정된 필드를 가진 <dfn id="realm-record" variants="Realm Records">Realm Record</dfn>로 표현된다:</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record 필드(Realm Record Fields)" oldids="table-21">
      <table>
        <thead>
          <tr>
            <th>
              필드 이름(Field Name)
            </th>
            <th>
              값(Value)
            </th>
            <th>
              의미(Meaning)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[AgentSignifier]]
          </td>
          <td>
            에이전트 식별자(agent signifier)
          </td>
          <td>
            이 realm을 소유하는 에이전트
          </td>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td>
            필드 이름이 intrinsic key이고 값이 객체인 Record
          </td>
          <td>
            이 realm에 연계된 코드가 사용하는 intrinsic 값들
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            이 realm의 전역 객체
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td>
            Global Environment Record
          </td>
          <td>
            이 realm의 전역 환경
          </td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td>
            필드 [[Site]] (|TemplateLiteral| Parse Node) 및 [[Array]] (Array)를 갖는 Record들의 List
          </td>
          <td>
            <p>템플릿 객체들은 각 realm별로 그 Realm Record의 [[TemplateMap]]을 사용하여 정규화(canonicalize)된다. 각 [[Site]] 값은 |TemplateLiteral| 인 Parse Node이다. 연계된 [[Array]] 값은 태그 함수에 전달되는 해당 템플릿 객체이다.</p>
            <emu-note>어떤 Parse Node가 도달 불가능(unreachable)이 되면, 대응하는 [[Array]] 또한 도달 불가능해지며, 구현이 그 쌍을 [[TemplateMap]] 리스트에서 제거하더라도 관측 불가능하다.</emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[LoadedModules]]
          </td>
          <td>
            LoadedModuleRequest Record들의 List
          </td>
          <td>
            <p>이 realm이 import한 명세자(specifier) 문자열에서 해석된 Module Record로의 매핑. 리스트에는 ModuleRequestsEqual(_r1_, _r2_)가 *true*인 서로 다른 Record _r1_, _r2_ 두 개가 존재하지 않는다.</p>
            <emu-note>
              HostLoadImportedModule (<emu-xref href="#note-HostLoadImportedModule-referrer-Realm-Record"></emu-xref>)에서 언급했듯이, Realm Record의 [[LoadedModules]]는 활성 스크립트나 모듈이 없는 문맥에서 `import()` 표현식을 실행할 때만 사용된다.
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            임의(anything) (*undefined*가 기본값)
          </td>
          <td>
            호스트가 Realm Record와 추가 정보를 연계할 필요가 있을 때 사용하기 위한 예약 필드.
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-initializehostdefinedrealm" type="abstract operation" oldids="sec-createrealm,sec-setrealmglobalobject">
      <h1>InitializeHostDefinedRealm ( ): ~unused~를 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _realm_을 새로운 Realm Record로 둔다.
        1. CreateIntrinsics(_realm_)를 수행한다.
        1. _realm_.[[AgentSignifier]]를 AgentSignifier()로 설정한다.
        1. _realm_.[[TemplateMap]]을 새 빈 List로 설정한다.
        1. _newContext_를 새 실행 컨텍스트로 둔다.
        1. _newContext_의 Function을 *null*로 설정한다.
        1. _newContext_의 Realm을 _realm_으로 설정한다.
        1. _newContext_의 ScriptOrModule을 *null*로 설정한다.
        1. 실행 컨텍스트 스택에 _newContext_를 push한다; 이제 _newContext_가 실행 중(running) 실행 컨텍스트다.
        1. 호스트가 _realm_의 전역 객체로서 익조틱(exotic) 객체 사용을 요구한다면
          1. _global_을 호스트 정의 방식으로 생성된 그러한 객체로 둔다.
        1. Else,
          1. _global_을 OrdinaryObjectCreate(_realm_.[[Intrinsics]].[[%Object.prototype%]])로 둔다.
        1. 호스트가 _realm_ 전역 스코프의 `this` 바인딩이 전역 객체와 다른 객체를 반환하도록 요구한다면
          1. _thisValue_를 호스트 정의 방식으로 생성된 그러한 객체로 둔다.
        1. Else,
          1. _thisValue_를 _global_로 둔다.
        1. _realm_.[[GlobalObject]]를 _global_로 설정한다.
        1. _realm_.[[GlobalEnv]]를 NewGlobalEnvironment(_global_, _thisValue_)로 설정한다.
        1. ? SetDefaultGlobalBindings(_realm_)를 수행한다.
        1. 호스트 정의 전역 객체 프로퍼티들을 _global_에 생성한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createintrinsics" type="abstract operation">
      <h1>
        CreateIntrinsics (
          _realmRec_: Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _realmRec_.[[Intrinsics]]를 새 Record로 설정한다.
        1. [declared="steps,name,length,slots,prototype"] _realmRec_.[[Intrinsics]]의 필드들을 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>에 나열된 값으로 설정한다. 필드 이름은 테이블 첫 번째 열의 이름들이다. 각 필드 값은 <emu-xref href="#sec-global-object"></emu-xref>부터 <emu-xref href="#sec-reflection"></emu-xref>까지의 각 객체 명세에 따라 그 프로퍼티 값으로 완전하고 재귀적으로 채워진 새 객체 값이다. 모든 객체 프로퍼티 값은 새로 생성된 객체 값이다. 내장 함수 객체인 모든 값은 CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_)을 수행하여 생성되는데, 여기서 _steps_는 이 명세가 제공하는 그 함수의 정의, _name_은 함수의 초기 *"name"* 프로퍼티 값, _length_는 함수의 초기 *"length"* 프로퍼티 값, _slots_는 (있다면) 함수의 지정된 내부 슬롯 이름들의 리스트, _prototype_은 함수 [[Prototype]] 내부 슬롯의 지정된 값이다. intrinsic과 그 프로퍼티 생성은 아직 생성되지 않은 객체에 대한 의존성이 없도록 순서가 정해져야 한다.
        1. AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setdefaultglobalbindings" type="abstract operation">
      <h1>
        SetDefaultGlobalBindings (
          _realmRec_: Realm Record,
        ): ~unused~를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _global_을 _realmRec_.[[GlobalObject]]로 둔다.
        1. <emu-xref href="#sec-global-object"></emu-xref> 절에 지정된 전역 객체의 각 프로퍼티에 대해
          1. _name_을 그 프로퍼티 이름의 String 값으로 둔다.
          1. _desc_를 그 프로퍼티에 대해 지정된 속성들을 포함하는 완전히 채워진 데이터 프로퍼티 디스크립터로 둔다. <emu-xref href="#sec-function-properties-of-the-global-object"></emu-xref>, <emu-xref href="#sec-constructor-properties-of-the-global-object"></emu-xref>, 또는 <emu-xref href="#sec-other-properties-of-the-global-object"></emu-xref>에 나열된 프로퍼티의 경우 [[Value]] 속성 값은 _realmRec_의 해당 intrinsic 객체이다.
          1. ? DefinePropertyOrThrow(_global_, _name_, _desc_)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>실행 컨텍스트들(Execution Contexts)</h1>
    <p><dfn variants="execution contexts">execution context</dfn>는 ECMAScript 구현이 코드의 런타임 평가를 추적하기 위해 사용하는 명세 장치이다. 어느 시점에도 코드 실행 중인 에이전트당 실제로 코드를 실행하는 실행 컨텍스트는 최대 하나이다. 이는 그 에이전트의 <dfn id="running-execution-context" variants="running execution contexts">running execution context</dfn>로 알려져 있다. 이 명세에서 running execution context에 대한 모든 언급은 둘러싼 에이전트의 running execution context를 가리킨다.</p>
    <p><dfn id="execution-context-stack" variants="execution context stacks">execution context stack</dfn>은 실행 컨텍스트들을 추적하는 데 사용된다. running execution context는 항상 이 스택의 최상단 요소이다. 현재 running execution context에 연계된 실행 가능한 코드로부터 그 실행 컨텍스트와 연계되지 않은 실행 가능한 코드로 제어가 이전될 때마다 새로운 실행 컨텍스트가 생성된다. 새로 생성된 실행 컨텍스트는 스택에 push되며 running execution context가 된다.</p>
    <p>실행 컨텍스트는 그 연계된 코드의 실행 진행을 추적하는 데 필요한 구현별 상태를 포함한다. 각 실행 컨텍스트는 최소한 <emu-xref href="#table-state-components-for-all-execution-contexts"></emu-xref>에 나열된 상태 구성 요소들을 가진다.</p>
    <emu-table id="table-state-components-for-all-execution-contexts" caption="모든 실행 컨텍스트의 상태 구성 요소(State Components for All Execution Contexts)" oldids="table-22">
      <table>
        <thead>
          <tr>
            <th>
              구성 요소(Component)
            </th>
            <th>
              목적(Purpose)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            code evaluation state
          </td>
          <td>
            이 실행 컨텍스트와 연계된 코드의 평가 수행, 일시중단, 재개에 필요한 모든 상태.
          </td>
        </tr>
        <tr>
          <td>
            Function
          </td>
          <td>
            이 실행 컨텍스트가 함수 객체의 코드를 평가 중이면 이 구성 요소 값은 그 함수 객체이고, |Script| 또는 |Module|의 코드를 평가 중이면 값은 *null*.
          </td>
        </tr>
        <tr>
          <td>
            Realm
          </td>
          <td>
            연계된 코드가 ECMAScript 자원에 접근하는 데 사용하는 Realm Record.
          </td>
        </tr>
        <tr>
          <td>
            ScriptOrModule
          </td>
          <td>
            연계된 코드가 기원한 Module Record 또는 Script Record. 원래 실행 컨텍스트(InitializeHostDefinedRealm에서 생성된)처럼 기원 스크립트나 모듈이 없는 경우 값은 *null*.
          </td>
        </tr>
      </table>
    </emu-table>
    <p>running execution context에 의한 코드 평가는 이 명세에 정의된 여러 지점에서 일시중단(suspend)될 수 있다. 한 번 running execution context가 일시중단되면, 다른 실행 컨텍스트가 running execution context가 되어 자신의 코드를 평가하기 시작할 수 있다. 이후 어느 시점에 일시중단된 실행 컨텍스트가 다시 running execution context가 되어 이전에 일시중단된 지점부터 자신의 코드를 계속 평가할 수 있다. running execution context 상태의 전환은 보통 스택과 같은 후입선출(LIFO) 방식으로 발생하지만, 일부 ECMAScript 기능은 비 LIFO 전환을 요구한다.</p>
    <p>running execution context의 Realm 구성 요소 값은 <dfn id="current-realm">current Realm Record</dfn>라고도 한다. running execution context의 Function 구성 요소 값은 <dfn id="active-function-object">active function object</dfn>라고도 한다.</p>
    <p><dfn id="ecmascript-code-execution-context" variants="ECMAScript code execution context">ECMAScript 코드 실행 컨텍스트</dfn>는 <emu-xref href="#table-additional-state-components-for-ecmascript-code-execution-contexts"></emu-xref>에 나열된 추가 상태 구성 요소를 가진다.</p>
    <emu-table id="table-additional-state-components-for-ecmascript-code-execution-contexts" caption="ECMAScript 코드 실행 컨텍스트의 추가 상태 구성 요소(Additional State Components for ECMAScript Code Execution Contexts)" oldids="table-23">
      <table>
        <thead>
          <tr>
            <th>
              구성 요소(Component)
            </th>
            <th>
              목적(Purpose)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            이 실행 컨텍스트 내 코드가 수행하는 식별자 참조를 해석하는 데 사용되는 Environment Record를 식별.
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            이 실행 컨텍스트 내 |VariableStatement|에 의해 생성된 바인딩을 보유하는 Environment Record를 식별.
          </td>
        </tr>
        <tr>
          <td>
            PrivateEnvironment
          </td>
          <td>
            가장 가까운 둘러싸는 클래스의 |ClassElement|들이 생성한 Private Name들을 보유하는 PrivateEnvironment Record를 식별. 둘러싸는 클래스가 없으면 *null*.
          </td>
        </tr>
      </table>
    </emu-table>
    <p>실행 컨텍스트의 LexicalEnvironment 및 VariableEnvironment 구성 요소는 항상 Environment Record이다.</p>
    <p>Generator 평가를 나타내는 실행 컨텍스트는 <emu-xref href="#table-additional-state-components-for-generator-execution-contexts"></emu-xref>에 나열된 추가 상태 구성 요소를 가진다.</p>
    <emu-table id="table-additional-state-components-for-generator-execution-contexts" caption="Generator 실행 컨텍스트의 추가 상태 구성 요소(Additional State Components for Generator Execution Contexts)" oldids="table-24">
      <table>
        <thead>
          <tr>
            <th>
              구성 요소(Component)
            </th>
            <th>
              목적(Purpose)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Generator
          </td>
          <td>
            이 실행 컨텍스트가 평가 중인 Generator.
          </td>
        </tr>
      </table>
    </emu-table>
    <p>대부분의 상황에서 이 명세의 알고리즘이 직접 조작하는 것은 running execution context(실행 컨텍스트 스택의 최상단)이다. 따라서 “LexicalEnvironment”, “VariableEnvironment”라는 용어가 한정 없이 사용될 때 그것들은 running execution context의 해당 구성 요소를 의미한다.</p>
    <p>실행 컨텍스트는 순수한 명세 메커니즘이며 ECMAScript 구현의 특정한 실체에 대응할 필요가 없다. ECMAScript 코드는 실행 컨텍스트를 직접 접근하거나 관찰할 수 없다.</p>

    <emu-clause id="sec-getactivescriptormodule" type="abstract operation">
      <h1>GetActiveScriptOrModule ( ): Script Record, Module Record, 또는 *null*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>running execution context를 기반으로 실행 중인 스크립트 또는 모듈을 결정하는 데 사용된다.</dd>
      </dl>

      <emu-alg>
        1. 실행 컨텍스트 스택이 비어 있으면 *null*을 반환한다.
        1. _ec_를 실행 컨텍스트 스택의 최상단에서 ScriptOrModule 구성 요소가 *null*이 아닌 실행 컨텍스트로 둔다.
        1. 그러한 실행 컨텍스트가 없으면 *null*을 반환하고; 그렇지 않으면 _ec_의 ScriptOrModule을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvebinding" type="abstract operation">
      <h1>
        ResolveBinding (
          _name_: String,
          optional _env_: Environment Record 또는 *undefined*,
        ): Reference Record를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_name_의 바인딩을 결정하는 데 사용된다. _env_는 검색할 Environment Record를 명시적으로 제공하는 데 사용할 수 있다.</dd>
      </dl>
      <emu-alg>
        1. _env_가 제공되지 않았거나 _env_가 *undefined*이면
          1. _env_를 running execution context의 LexicalEnvironment로 설정한다.
        1. 단언: _env_는 Environment Record이다.
        1. _strict_를 (평가 중인) 구문 생성 규칙에 대한 IsStrict의 결과로 둔다.
        1. ? GetIdentifierReference(_env_, _name_, _strict_)를 반환한다.
      </emu-alg>
      <emu-note>
        <p>ResolveBinding의 결과는 항상 [[ReferencedName]] 필드가 _name_인 Reference Record이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getthisenvironment" type="abstract operation">
      <h1>GetThisEnvironment ( ): Environment Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>현재 `this` 키워드의 바인딩을 제공하는 Environment Record를 찾는다.</dd>
      </dl>
      <emu-alg>
        1. _env_를 running execution context의 LexicalEnvironment로 둔다.
        1. [id="step-getthisenvironment-loop"] 반복,
          1. _exists_를 _env_.HasThisBinding()으로 둔다.
          1. _exists_가 *true*이면 _env_를 반환한다.
          1. _outer_를 _env_.[[OuterEnv]]로 둔다.
          1. 단언: _outer_는 *null*이 아니다.
          1. _env_를 _outer_로 설정한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-getthisenvironment-loop"></emu-xref> 단계의 루프는 환경들의 리스트가 항상 `this` 바인딩을 가진 전역 환경으로 끝나므로 반드시 종료된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-resolvethisbinding" type="abstract operation">
      <h1>ResolveThisBinding ( ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>running execution context의 LexicalEnvironment를 사용하여 `this` 키워드의 바인딩을 결정한다.</dd>
      </dl>
      <emu-alg>
        1. _envRec_를 GetThisEnvironment()로 둔다.
        1. ? _envRec_.GetThisBinding()을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getnewtarget" type="abstract operation">
      <h1>GetNewTarget ( ): Object 또는 *undefined*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>running execution context의 LexicalEnvironment를 사용하여 NewTarget 값을 결정한다.</dd>
      </dl>
      <emu-alg>
        1. _envRec_를 GetThisEnvironment()로 둔다.
        1. 단언: _envRec_는 [[NewTarget]] 필드를 가진다.
        1. _envRec_.[[NewTarget]]을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getglobalobject" type="abstract operation">
      <h1>GetGlobalObject ( ): Object</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>현재 running execution context가 사용하는 전역 객체를 반환한다.</dd>
      </dl>
      <emu-alg>
        1. _currentRealm_을 current Realm Record로 둔다.
        1. _currentRealm_.[[GlobalObject]]를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-jobs" oldids="sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue">
    <h1>잡과 잡을 대기열에 넣기 위한 호스트 연산(Jobs and Host Operations to Enqueue Jobs)</h1>
    <p><dfn id="job" variants="Jobs">Job</dfn>은 파라미터가 없는 추상 클로저(Abstract Closure)로, 다른 ECMAScript 계산이 현재 진행 중이지 않을 때 ECMAScript 계산을 개시한다.</p>
    <p>잡은 특정 에이전트 내에서 ECMAScript 호스트 환경에 의해 실행이 스케줄된다. 이 명세는 잡을 스케줄하기 위해 HostEnqueueGenericJob, HostEnqueueFinalizationRegistryCleanupJob, HostEnqueuePromiseJob, HostEnqueueTimeoutJob 호스트 훅을 기술한다. 이 명세의 호스트 훅들은 잡 스케줄링에 추가로 부과되는 제약들에 따라 조직되어 있다. 호스트는 잡을 스케줄하는 추가적인 추상 연산을 정의할 수 있다. 그러한 연산은 Job 추상 클로저와 realm(Realm Record 또는 *null*)을 인자로 받는다. Realm Record가 제공되면, 그 연산들은 해당 realm을 소유한 에이전트에서 미래의 어느 시점에 그 realm 안에서 잡이 수행되도록 스케줄한다. realm이 대신 *null*로 제공되면, 그 잡은 ECMAScript 코드를 평가하지 않는다. 구현은 다음 요구 사항을 따라야 한다:</p>

    <ul>
      <li>미래의 어떤 시점에, 그 잡이 스케줄된 에이전트에 실행 중인 컨텍스트가 없고 그 에이전트의 실행 컨텍스트 스택이 비어 있을 때, 구현은 반드시:
        <ol>
          <li>호스트 정의 준비 단계를 수행한다.</li>
          <li><emu-not-ref>Invoke</emu-not-ref> Job 추상 클로저를 호출한다.</li>
          <li>호스트 정의 정리 단계를 수행하며, 그 후 실행 컨텍스트 스택은 비어 있어야 한다.</li>
        </ol>
      </li>
      <li>어느 시점에도 하나의 에이전트에서 동시에 평가 중인 Job은 하나만 존재할 수 있다.</li>
      <li>Job의 평가가 시작되면, 그 에이전트에서 다른 어떤 Job의 평가가 시작되기 전에 완료까지 실행되어야 한다(run to completion).</li>
      <li>추상 클로저는 오류 처리를 자체적으로 구현하여 정상 완료(normal completion)를 반환해야 한다.</li>
    </ul>

    <emu-note>
      호스트 환경은 스케줄링 측면에서 모든 Job을 동일하게 취급할 필요가 없다. 예를 들어, 웹 브라우저와 Node.js는 Promise 처리 잡을 다른 작업보다 더 높은 우선순위로 다룬다; 향후 기능은 그렇게 높은 우선순위로 다루어지지 않는 잡을 추가할 수 있다.
    </emu-note>

    <p>어떤 특정 시점에, 다음 모든 조건이 참이라면 _scriptOrModule_(Script Record, Module Record, 또는 *null*)은 <dfn id="job-activescriptormodule">active script or module(활성 스크립트 또는 모듈)</dfn>이다:</p>
    <ul>
      <li>GetActiveScriptOrModule() 결과가 _scriptOrModule_이다.</li>
      <li>_scriptOrModule_이 Script Record 또는 Module Record라면, _ec_를 실행 컨텍스트 스택의 최상단에서 ScriptOrModule 구성 요소가 _scriptOrModule_인 실행 컨텍스트로 둔다. _ec_의 Realm 구성 요소는 _scriptOrModule_.[[Realm]]이다.</li>
    </ul>

    <p>어떤 특정 시점에, 다음 모든 조건이 참이면 실행은 <dfn id="job-preparedtoevaluatecode">ECMAScript 코드를 평가할 준비가 되었다(prepared to evaluate ECMAScript code)</dfn>고 한다:</p>
    <ul>
      <li>실행 컨텍스트 스택이 비어 있지 않다.</li>
      <li>실행 컨텍스트 스택 최상단 실행 컨텍스트의 Realm 구성 요소가 Realm Record이다.</li>
    </ul>

    <emu-note>
      <p>호스트 환경은 실행 컨텍스트들을 실행 컨텍스트 스택에 push하여 코드를 평가할 준비를 시킬 수 있다. 구체적인 단계는 구현 정의이다.</p>
      <p>Realm의 구체적 선택은 호스트 환경에 달려 있다. 이 초기 실행 컨텍스트와 Realm은 어떤 콜백 함수가 호출되기 전까지만 사용된다. Promise 핸들러 같은 잡 관련 콜백 함수가 호출되면, 그 호출은 자체 실행 컨텍스트와 Realm을 push한다.</p>
    </emu-note>

    <p>특정 종류의 Job은 추가적인 적합성 요구 사항을 가진다.</p>

    <emu-clause id="sec-jobcallback-records">
      <h1>JobCallback 레코드(JobCallback Records)</h1>
      <p><dfn variants="JobCallback Records">JobCallback Record</dfn>는 함수 객체와 호스트 정의 값을 저장하기 위해 사용되는 Record 값이다. 호스트가 대기열에 넣은 Job을 통해 호출되는 함수 객체는 추가적인 호스트 정의 컨텍스트를 가질 수 있다. 이 상태를 전파하기 위해, Job 추상 클로저는 함수 객체를 직접 캡처하고 호출하지 않아야 한다. 대신 HostMakeJobCallback 및 HostCallJobCallback을 사용한다.</p>
      <emu-note>
        <p>예를 들어 WHATWG HTML 명세(<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>)는 Promise 콜백에 대해 incumbent settings object를 전파하기 위해 호스트 정의 값을 사용한다.</p>
      </emu-note>
      <p>JobCallback Record는 <emu-xref href="#table-jobcallback-records"></emu-xref>에 나열된 필드를 가진다.</p>
      <emu-table id="table-jobcallback-records" caption="JobCallback Record 필드(JobCallback Record Fields)">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름(Field Name)
              </th>
              <th>
                값(Value)
              </th>
              <th>
                의미(Meaning)
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Callback]]
            </td>
            <td>
              함수 객체
            </td>
            <td>
              Job이 호출될 때 호출할 함수.
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (기본값은 ~empty~)
            </td>
            <td>
              호스트 사용을 위한 예약 필드.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-hostmakejobcallback" type="host-defined abstract operation">
      <h1>
        HostMakeJobCallback (
          _callback_: 함수 객체,
        ): JobCallback Record
      </h1>
      <dl class="header">
      </dl>
      <p>HostMakeJobCallback 구현은 다음 요구 사항을 따라야 한다:</p>
      <ul>
        <li>[[Callback]] 필드가 _callback_인 JobCallback Record를 반환해야 한다.</li>
      </ul>
      <p>HostMakeJobCallback의 기본 구현은 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }를 반환한다.
      </emu-alg>
      <p>웹 브라우저가 아닌 ECMAScript 호스트는 HostMakeJobCallback의 기본 구현을 사용해야 한다.</p>
      <emu-note>
        <p>이는 콜백이 궁극적으로 스케줄되고 실행되도록 책임지는 함수에 콜백이 전달되는 시점에 호출된다. 예를 들어, `promise.then(thenAction)`은 반응 Job이 스케줄되는 시점이 아니라 `Promise.prototype.then`을 호출하는 시점에 `thenAction`에 대해 MakeJobCallback을 호출한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostcalljobcallback" type="host-defined abstract operation">
      <h1>
        HostCallJobCallback (
          _jobCallback_: JobCallback Record,
          _V_: ECMAScript 언어 값,
          _argumentsList_: ECMAScript 언어 값들의 List,
        ): ECMAScript 언어 값을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <p>HostCallJobCallback 구현은 다음 요구 사항을 따라야 한다:</p>
      <ul>
        <li>Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)의 결과를 수행하고 반환해야 한다.</li>
      </ul>
      <emu-note>
        <p>이 요구 사항은 호스트가 이 명세에서 정의된 함수 객체의 [[Call]] 동작을 변경할 수 없음을 의미한다.</p>
      </emu-note>
      <p>HostCallJobCallback의 기본 구현은 호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. 단언: IsCallable(_jobCallback_.[[Callback]])가 *true*이다.
        1. ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)를 반환한다.
      </emu-alg>
      <p>웹 브라우저가 아닌 ECMAScript 호스트는 HostCallJobCallback의 기본 구현을 사용해야 한다.</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuegenericjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueGenericJob (
          _job_: Job 추상 클로저,
          _realm_: Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_realm_.[[AgentSignifier]]로 표시된 에이전트에서 _realm_ 내에 _job_을 미래의 어느 시점에 수행하도록 스케줄한다. 이 알고리즘과 함께 사용되는 추상 클로저는 우선순위나 순서 같은 추가 제약 없이 스케줄되는 것을 의도한다.</dd>
      </dl>
      <p>HostEnqueueGenericJob 구현은 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항을 따라야 한다.</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuepromisejob" type="host-defined abstract operation">
      <h1>
        HostEnqueuePromiseJob (
          _job_: Job 추상 클로저,
          _realm_: Realm Record 또는 *null*,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_job_을 미래의 어느 시점에 수행하도록 스케줄한다. 이 알고리즘과 함께 사용되는 추상 클로저는 Promise 처리와 관련이 있거나 그렇지 않더라도 Promise 처리 연산과 동일한 우선순위로 스케줄되는 것을 의도한다.</dd>
      </dl>

      <p>HostEnqueuePromiseJob 구현은 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항과 아래 사항을 따라야 한다:</p>
      <ul>
        <li>_realm_이 *null*이 아니면, _job_이 호출될 때마다 구현은 _job_ 호출 시점에 실행이 ECMAScript 코드를 평가할 준비가 되도록 구현 정의 단계를 수행해야 한다.</li>
        <li>HostEnqueuePromiseJob이 호출되는 시점에 _scriptOrModule_을 GetActiveScriptOrModule()으로 둔다. _realm_이 *null*이 아니면, _job_이 호출될 때마다 구현은 _scriptOrModule_이 _job_ 호출 시점에 활성 스크립트 또는 모듈이 되도록 구현 정의 단계를 수행해야 한다.</li>
        <li>잡은 그들을 스케줄한 HostEnqueuePromiseJob 호출과 동일한 순서로 실행되어야 한다.</li>
      </ul>

      <emu-note>
        <p>NewPromiseResolveThenableJob이 반환한 잡의 _realm_은 보통 _then_ 함수 객체에 대해 GetFunctionRealm을 호출한 결과이다. NewPromiseReactionJob이 반환한 잡의 _realm_은 핸들러가 *undefined*가 아니면 보통 핸들러에 대해 GetFunctionRealm을 호출한 결과이다. 핸들러가 *undefined*이면 _realm_은 *null*이다. 두 종류의 잡 모두에서 GetFunctionRealm이 비정상적으로 완료(예: 철회된 Proxy에 대해 호출)되면 _realm_은 GetFunctionRealm 호출 시점의 현재 Realm Record이다. _realm_이 *null*이면 어떤 사용자 ECMAScript 코드도 평가되지 않고 새로운 ECMAScript 객체(예: Error 객체)도 생성되지 않는다. WHATWG HTML 명세(<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>)는 예를 들어 _realm_을 사용하여 스크립트 실행 가능 여부와 <a href="https://html.spec.whatwg.org/#entry">entry</a> 개념을 확인한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostenqueuetimeoutjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueTimeoutJob (
          _timeoutJob_: Job 추상 클로저,
          _realm_: Realm Record,
          _milliseconds_: 음이 아닌 유한 Number,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_realm_.[[AgentSignifier]]로 표시된 에이전트에서 _realm_ 내에 _timeoutJob_을 최소 _milliseconds_ 밀리초 후에 수행되도록 스케줄한다.</dd>
      </dl>
      <p>HostEnqueueTimeoutJob 구현은 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항을 따라야 한다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agents">
    <h1>에이전트(Agents)</h1>

    <p><dfn id="agent" variants="agents">agent</dfn>는 ECMAScript 실행 컨텍스트 집합, 실행 컨텍스트 스택, 실행 중 실행 컨텍스트(running execution context), <dfn id="agent-record" variants="Agent Records">Agent Record</dfn>, 그리고 <dfn id="executing-thread" variants="executing threads">executing thread</dfn>로 구성된다. executing thread를 제외한 구성 요소들은 오직 그 에이전트에만 속한다.</p>
    <p>에이전트의 executing thread는 다른 에이전트와 독립적으로 그 에이전트의 실행 컨텍스트들에 대해 알고리즘 단계를 실행한다. 단, 여러 에이전트가 하나의 executing thread를 공유할 수 있는데, 그 공유하는 에이전트 중 어느 것도 Agent Record의 [[CanBlock]] 필드가 *true*이면 안 된다.</p>
    <emu-note>
      <p>예를 들어 일부 웹 브라우저는 서로 관계없는 여러 탭이 단일 executing thread를 공유한다.</p>
    </emu-note>
    <p>에이전트의 executing thread가 알고리즘 단계를 실행하는 동안, 그 에이전트는 그 단계들의 <dfn id="surrounding-agent" variants="surrounding agents">surrounding agent(둘러싼 에이전트)</dfn>이다. 그 단계들은 둘러싼 에이전트를 사용하여 에이전트가 보유한 명세 수준 실행 객체—실행 중 실행 컨텍스트, 실행 컨텍스트 스택, Agent Record의 필드—에 접근한다.</p>
    <p><dfn variants="agent signifiers">agent signifier(에이전트 식별자)</dfn>는 에이전트를 식별하기 위해 사용되는 전역적으로 고유한 불투명 값이다.</p>
    <emu-table id="table-agent-record" caption="Agent Record 필드(Agent Record Fields)">
      <table>
        <thead>
          <tr>
            <th>필드 이름(Field Name)</th>
            <th>값(Value)</th>
            <th>의미(Meaning)</th>
          </tr>
        </thead>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>Boolean</td>
          <td>알고리즘 GetValueFromBuffer 및 SetValueInBuffer가 필요할 때 <em>isLittleEndian</em> 파라미터에 대해 계산되는 기본 값. 선택은 구현 정의이며 구현에 가장 효율적인 대안을 사용해야 한다. 한 번 관측된 후에는 변경될 수 없다.</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>Boolean</td>
          <td>에이전트가 블록(block)될 수 있는지 여부를 결정.</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>agent signifier</td>
          <td>에이전트를 그 에이전트 클러스터 내에서 고유하게 식별.</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>Boolean</td>
          <td>1-<emu-not-ref>byte 값</emu-not-ref>에 대한 원자적 연산이 lock-free이면 *true*, 아니면 *false*.</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>Boolean</td>
          <td>2-<emu-not-ref>byte 값</emu-not-ref>에 대한 원자적 연산이 lock-free이면 *true*, 아니면 *false*.</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>Boolean</td>
          <td>8-<emu-not-ref>byte 값</emu-not-ref>에 대한 원자적 연산이 lock-free이면 *true*, 아니면 *false*.</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>candidate execution Record</td>
          <td>메모리 모델 참조.</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>Objects 또는 Symbols 중 하나의 List</td>
          <td>초기에는 새 빈 List로, 현재 Job 끝까지 유지(kept alive)되어야 하는 객체 및/또는 심볼들의 목록.</td>
        </tr>
        <tr>
          <td>[[ModuleAsyncEvaluationCount]]</td>
          <td>정수</td>
          <td>초기값 0. 비동기 또는 비동기 의존성을 가진 모듈들의 [[AsyncEvaluationOrder]] 필드에 고유 증가값을 할당하는 데 사용.</td>
        </tr>
      </table>
    </emu-table>

    <p>[[Signifier]], [[IsLockFree1]], [[IsLockFree2]]의 값은 에이전트 클러스터의 어떤 에이전트에 의해 관측된 후에는 변경될 수 없다.</p>

    <emu-note>
      <p>[[IsLockFree1]]과 [[IsLockFree2]]의 값은 반드시 하드웨어에 의해 결정되는 것은 아니며, 시간에 따라 또는 ECMAScript 구현 간에 달라질 수 있는 구현 선택을 반영할 수도 있다.</p>

      <p>[[IsLockFree4]] 필드는 없다: 4-byte 원자 연산은 항상 lock-free이다.</p>

      <p>실제로 어떤 종류의 락을 사용해 원자 연산이 구현된다면 그 연산은 lock-free가 아니다. Lock-free는 wait-free를 의미하지 않는다: lock-free 원자 연산을 완료하는 데 필요한 기계 단계 수에 상한은 없다.</p>

      <p>크기 <em>n</em>의 원자 접근이 lock-free라고 해서 크기 <em>n</em>의 비원자(non-atomic) 접근의 (인지된) 원자성에 대해 아무것도 의미하지 않는다. 특히 비원자 접근은 여전히 여러 개의 별도 메모리 접근 시퀀스로 수행될 수 있다. 세부 사항은 ReadSharedMemory와 WriteSharedMemory 참조.</p>
    </emu-note>

    <emu-note>
      <p>에이전트는 명세 메커니즘이며 ECMAScript 구현의 특정 실체에 대응할 필요가 없다.</p>
    </emu-note>

    <emu-clause id="sec-agentsignifier" type="abstract operation">
      <h1>AgentSignifier ( ): agent signifier</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_를 둘러싼 에이전트의 Agent Record로 둔다.
        1. _AR_.[[Signifier]]를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-agentcansuspend" type="abstract operation">
      <h1>AgentCanSuspend ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_를 둘러싼 에이전트의 Agent Record로 둔다.
        1. _AR_.[[CanBlock]]를 반환한다.
      </emu-alg>
      <emu-note>
        <p>일부 환경에서는 특정 에이전트가 일시중단(suspend)되는 것이 타당하지 않을 수 있다. 예를 들어 웹 브라우저 환경에서는 문서의 메인 이벤트 처리 스레드를 일시중단하지 않는 것이 합리적일 수 있지만 워커의 이벤트 처리 스레드는 가능하게 할 수 있다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-IncrementModuleAsyncEvaluationCount" type="abstract operation">
      <h1>IncrementModuleAsyncEvaluationCount ( ): 정수</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _AR_를 둘러싼 에이전트의 Agent Record로 둔다.
        1. _count_를 _AR_.[[ModuleAsyncEvaluationCount]]로 둔다.
        1. _AR_.[[ModuleAsyncEvaluationCount]]를 _count_ + 1로 설정한다.
        1. _count_를 반환한다.
      </emu-alg>
      <emu-note>
        <p>이 값은 보류 중(pending) 모듈 사이의 상대적 평가 순서를 추적하기 위해서만 사용된다. 보류 중인 모듈이 없다면 구현은 관측 불가능하게 [[ModuleAsyncEvaluationCount]]를 0으로 재설정할 수 있다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agent-clusters">
    <h1>에이전트 클러스터(Agent Clusters)</h1>

    <p><dfn variants="agent clusters">agent cluster</dfn>는 공유 메모리를 조작함으로써 통신할 수 있는 에이전트들의 최대 집합이다.</p>

    <emu-note>
      <p>서로 다른 에이전트 내의 프로그램들은 명시되지 않은 수단으로 메모리를 공유할 수 있다. 최소한 SharedArrayBuffers의 백업 메모리는 클러스터의 에이전트들 간에 공유될 수 있다.</p>

      <p>메시지 전달로 통신할 수 있지만 메모리를 공유할 수 없는 에이전트들도 있을 수 있으며, 그들은 절대 같은 에이전트 클러스터에 속하지 않는다.</p>
    </emu-note>

    <p>모든 에이전트는 정확히 하나의 에이전트 클러스터에 속한다.</p>

    <emu-note>
      <p>클러스터의 에이전트들이 어떤 특정 시점에 모두 살아 있을 필요는 없다. 에이전트 <b>A</b>가 다른 에이전트 <b>B</b>를 생성하고, 그 후 <b>A</b>가 종료되고 <b>B</b>가 에이전트 <b>C</b>를 생성한다면, <b>A</b>가 <b>B</b>와 일부 메모리를 공유할 수 있었고 <b>B</b>가 <b>C</b>와 일부 메모리를 공유할 수 있었다면 세 에이전트는 같은 클러스터에 속한다.</p>
    </emu-note>

    <p>클러스터 내 모든 에이전트는 각각의 Agent Record에서 [[LittleEndian]] 필드에 대해 동일한 값을 가져야 한다.</p>

    <emu-note>
      <p>에이전트 클러스터 내의 에이전트들이 [[LittleEndian]] 값이 서로 다르다면, 다중 바이트 데이터에 대해 공유 메모리를 사용하는 것이 어려워진다.</p>
    </emu-note>

    <p>클러스터 내 모든 에이전트는 [[IsLockFree1]] 필드에 대해 동일한 값을 가져야 하며 [[IsLockFree2]] 필드도 마찬가지이다.</p>

    <p>클러스터 내 모든 에이전트는 각각의 Agent Record에서 [[Signifier]] 필드에 대해 서로 다른 값을 가져야 한다.</p>

    <p>임베딩은 에이전트의 지식이나 협력 없이 에이전트를 비활성화(진행 중단)하거나 활성화(진행 재개)할 수 있다. 임베딩이 그렇게 한다면, 클러스터 내 일부 에이전트만 활성 상태로 남기고 다른 에이전트들을 무기한 비활성화된 상태로 두어서는 안 된다.</p>

    <emu-note>
      <p>위 제한의 목적은 어떤 에이전트가 다른 에이전트가 비활성화되었기 때문에 데드락 또는 기아(starvation)에 빠지는 상황을 피하기 위함이다. 예를 들어, 창 윈도우의 어떤 문서에도 독립적인 수명(lifetime)을 가진 HTML 공유 워커가 그런 독립 문서의 전용(dedicated) 워커와 메모리를 공유할 수 있고, 그 후 문서와 전용 워커가 (예: 문서가 히스토리에 들어가면서) 비활성화되었으며 전용 워커가 락을 보유한 상태이고, 공유 워커가 락을 획득하려 하면 공유 워커는 전용 워커가 다시 활성화될 때까지(혹은 영원히) 블록된다. 그동안 다른 윈도우에서 공유 워커에 접근하려는 다른 워커들은 기아 상태에 빠진다.</p>

      <p>이 제한의 함의는 임베딩 내에서 동일한 suspend/wake 집합에 속하지 않는 에이전트들 사이에서는 메모리를 공유할 수 없다는 것이다.</p>
    </emu-note>

    <p>임베딩은 에이전트 클러스터의 다른 에이전트의 사전 지식이나 협력 없이 에이전트를 종료할 수 있다. 에이전트가 자체 또는 클러스터 내 다른 에이전트의 프로그래밍 동작이 아니라 클러스터 외부의 힘에 의해 종료된다면, 임베딩은 두 전략 중 하나를 선택해야 한다: 클러스터의 모든 에이전트를 종료하거나, 클러스터의 에이전트들이 협력하여 종료를 감지할 수 있도록 신뢰 가능한 API를 제공하되, 종료 데이터는 종료된 에이전트를 식별하기에 충분한 정보를 포함해야 한다.</p>

    <emu-note>
      <p>그러한 종료 유형의 예로는: 별도 프로세스에서 실행 중인 에이전트를 운영체제나 사용자가 종료하는 경우; per-agent 자원 계정이 에이전트가 runaway임을 나타낼 때 같은 프로세스에서 다른 에이전트와 함께 실행 중인 에이전트를 임베딩 자체가 종료하는 경우 등이 있다.</p>
    </emu-note>

    <p>다음 명세 값 각각과 그들로부터 추이적으로 도달 가능한 값들은 정확히 하나의 에이전트 클러스터에 속한다.</p>
    <ul>
      <li>candidate execution Record</li>
      <li>Shared Data Block</li>
      <li>WaiterList Record</li>
    </ul>

    <p>클러스터 내 어떤 에이전트가 ECMAScript 코드를 평가하기 이전에, 클러스터의 모든 에이전트에 대한 Agent Record의 [[CandidateExecution]] 필드는 초기 candidate execution으로 설정된다. 초기 candidate execution은 비어 있는 candidate execution으로, 그 [[EventsRecords]] 필드는 각 에이전트에 대해 [[AgentSignifier]] 필드가 그 에이전트의 agent signifier이고 [[EventList]] 및 [[AgentSynchronizesWith]] 필드가 빈 List인 Agent Events Record를 포함하는 List이다.</p>

    <emu-note>
      <p>에이전트 클러스터의 모든 에이전트는 Agent Record의 [[CandidateExecution]] 필드에서 동일한 candidate execution을 공유한다. candidate execution은 메모리 모델에서 사용되는 명세 메커니즘이다.</p>
    </emu-note>

    <emu-note>
      <p>에이전트 클러스터는 명세 메커니즘이며 ECMAScript 구현의 특정 실체에 대응할 필요가 없다.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forward-progress">
    <h1>Forward Progress</h1>
    <p>에이전트가 <em>forward progress를 만든다(make forward progress)</em>는 것은 이 명세에 따라 평가 단계(evaluation step)를 수행하는 것이다.</p>
    <p>에이전트의 실행 중 실행 컨텍스트가 외부 이벤트를 동기적으로 무기한 기다릴 때, 그 에이전트는 <em>blocked</em>가 된다. Agent Record의 [[CanBlock]] 필드가 *true*인 에이전트만 이런 의미에서 blocked 상태가 될 수 있다. <em>unblocked</em> 에이전트는 blocked가 아닌 에이전트이다.</p>

    <p>구현은 다음을 보장해야 한다:</p>
    <ul>
      <li>전용 executing thread를 가진 모든 unblocked 에이전트는 결국 forward progress를 만든다.</li>
      <li>executing thread를 공유하는 에이전트 집합에서는 하나의 에이전트가 결국 forward progress를 만든다.</li>
      <li>에이전트는 차단(blocking)을 제공하는 명시적 API를 통한 경우를 제외하고 다른 에이전트를 blocked 상태로 만들지 않는다.</li>
    </ul>

    <emu-note>
      <p>이는 메모리 모델의 liveness 보장과 함께 모든 ~seq-cst~ 쓰기가 결국 모든 에이전트에 관측 가능해짐을 보장한다.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-weakref-processing-model">
    <h1>WeakRef 및 FinalizationRegistry 대상 처리 모델(Processing Model of WeakRef and FinalizationRegistry Targets)</h1>

    <emu-clause id="sec-weakref-invariants">
      <h1>목표(Objectives)</h1>

      <p>이 명세는 어떤 객체나 심볼이 가비지 컬렉션될 것이라는 보장을 제공하지 않는다. live가 아닌 객체나 심볼은 긴 시간이 지난 후 해제되거나 전혀 해제되지 않을 수 있다. 이런 이유로 본 명세는 가비지 컬렉션에 의해 트리거되는 동작을 설명할 때 "may"라는 용어를 사용한다.</p>

      <p>WeakRef와 FinalizationRegistry의 의미론은 특정 시점에 발생하는 두 연산에 기반한다:</p>

      <ul>
        <li>
          `WeakRef.prototype.deref`가 호출될 때, ( *undefined* 가 반환되지 않는 경우) 참조 대상(referent)은 이후의 동기적 접근에서 동일한 값을 반환할 수 있도록 살아 있게 유지된다. 이 목록(list)은 ClearKeptObjects 추상 연산을 사용해 동기 작업이 완료될 때 리셋된다.
        </li>

        <li>
          FinalizationRegistry에 등록된 객체나 심볼이 도달 불가능(unreachable)이 되면, FinalizationRegistry의 cleanup 콜백 호출이 동기 ECMAScript 실행이 완료된 후 언젠가 수행될 수 있다. FinalizationRegistry 정리는 CleanupFinalizationRegistry 추상 연산으로 수행된다.
        </li>
      </ul>

      <p>이 두 동작(ClearKeptObjects 또는 CleanupFinalizationRegistry)은 동기 ECMAScript 실행을 중단(interrupt)해서는 안 된다. 호스트는 더 긴 동기 ECMAScript 실행 구간을 구성할 수 있으므로, 이 명세는 ClearKeptObjects와 CleanupFinalizationRegistry의 스케줄링을 호스트 환경에 위임한다.</p>

      <p>일부 ECMAScript 구현에는 ECMAScript가 유휴(idle) 상태일 때를 포함해 백그라운드로 실행되는 가비지 컬렉터 구현이 포함되어 있다. 호스트 환경이 CleanupFinalizationRegistry를 스케줄하도록 하면, 구현이 파이널라이저 작업을 실행하기 위해 ECMAScript 실행을 재개하여 유지 중인 값을 해제함으로써 전체 메모리 사용량을 줄일 수 있다.</p>
    </emu-clause>

    <emu-clause id="sec-liveness">
      <h1>Liveness</h1>

      <p>객체 및/또는 심볼의 집합 _S_에 대해 <dfn>hypothetical WeakRef-oblivious(가설적 WeakRef-무관)</dfn> 실행이란, _S_의 요소인 참조 대상을 가진 WeakRef의 WeakRefDeref 추상 연산이 항상 *undefined*를 반환하는 실행을 말한다.</p>

      <emu-note>
        WeakRef-obliviousness와 liveness는 두 개념을 함께 포착한다. 첫째, WeakRef 자체는 그 참조 대상을 살아 있게 유지하지 않는다. 둘째, liveness에서의 사이클이 값이 live임을 의미하지는 않는다. 구체적으로, _v_의 liveness 결정이 WeakRef referent _r_의 liveness 결정에 의존한다면, _r_의 liveness는 _v_의 liveness를 가정할 수 없는데, 이는 순환 논리이기 때문이다.
      </emu-note>
      <emu-note>
        WeakRef-obliviousness는 사이클을 고려하기 위해 개별 값이 아닌 객체 또는 심볼 집합에 대해 정의된다. 개별 값에 대해 정의된다면, 사이클 내 WeakRef referent는 사이클 내 다른 WeakRef referent를 통해서만 그 정체성이 관측되더라도 live로 간주될 것이다.
      </emu-note>
      <emu-note>
        구어적으로는, 어떤 개별 객체나 심볼이 속한 모든 집합이 live이면 그 객체나 심볼을 live라고 말한다.
      </emu-note>

      <p>평가 도중 어느 시점에서든, 객체 및/또는 심볼 집합 _S_가 아래 조건 중 하나를 만족하면 <dfn>live</dfn>로 간주한다:</p>

      <ul>
        <li>
          _S_의 어떤 요소라도 어떤 에이전트의 [[KeptAlive]] List에 포함된다.
        </li>
        <li>
          _S_에 대한 어떤 유효한 미래의 가설적 WeakRef-oblivious 실행이 _S_ 내 값의 정체성을 관측한다.
        </li>
      </ul>
      <emu-note>
        두 번째 조건은 값의 정체성이 WeakRef 이외의 수단으로 관측 가능하다면 그 값이 live라는 직관을 포착하려는 것이다. 값의 정체성은 엄격 동등성 비교를 관측하거나 Map의 키로 사용되는 값을 관측함으로써 관측될 수 있다.
      </emu-note>
      <emu-note>
        <p>필드, 내부 슬롯, 프로퍼티 내 객체 또는 심볼의 존재는 그 값이 live임을 의미하지 않는다. 예를 들어 해당 값이 프로그램에 다시 전달되지 않는다면 관측될 수 없다.</p>

        <p>이는 WeakMap의 키, WeakSet의 멤버, 그리고 FinalizationRegistry Cell record의 [[WeakRefTarget]] 및 [[UnregisterToken]] 필드에 해당한다.</p>

        <p>위 정의는 WeakMap에서 어떤 키가 live가 아니면 그에 대응하는 값도 반드시 live일 필요는 없음을 의미한다.</p>
      </emu-note>
      <emu-note>
        Liveness는 엔진이 비워서는 안 되는 WeakRef에 대해 보장해야 하는 하한(lower bound)이다. 여기 정의된 Liveness는 결정 불가능(undecidable)하다. 실제로 엔진은 도달 가능성 같은 보수적 근사(approximation)를 사용한다. 구현 재량의 폭이 크다.
        <p></p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-execution">
      <h1>Execution</h1>

      <p>어느 시점에서든 객체 및/또는 심볼 집합 _S_가 live가 아니라면, ECMAScript 구현은 다음 단계를 원자적으로 수행할 수 있다:</p>

      <emu-alg>
        1. _S_의 각 요소 _value_에 대해
          1. _ref_.[[WeakRefTarget]]이 _value_인 각 WeakRef _ref_에 대해
            1. _ref_.[[WeakRefTarget]]을 ~empty~로 설정한다.
          1. _fg_.[[Cells]]가 [[WeakRefTarget]]이 _value_인 Record _cell_을 포함하는 각 FinalizationRegistry _fg_에 대해
            1. _cell_.[[WeakRefTarget]]을 ~empty~로 설정한다.
            1. 선택적으로 HostEnqueueFinalizationRegistryCleanupJob(_fg_)를 수행한다.
          1. _map_.[[WeakMapData]]가 [[Key]]가 _value_인 Record _r_을 포함하는 각 WeakMap _map_에 대해
            1. _r_.[[Key]]를 ~empty~로 설정한다.
            1. _r_.[[Value]]를 ~empty~로 설정한다.
          1. _set_.[[WeakSetData]]가 _value_를 포함하는 각 WeakSet _set_에 대해
            1. 값이 _value_인 _set_.[[WeakSetData]]의 요소를 값이 ~empty~인 요소로 교체한다.
      </emu-alg>

      <emu-note>
        <p>Liveness 정의와 함께, 본 절은 구현이 WeakRef에 관해 적용할 수 있는 최적화들을 규정한다.</p>

        <p>객체의 정체성을 관측하지 않고 객체에 접근하는 것이 가능하다. 정체성이 관측되지 않는, escape하지 않는 객체의 프로퍼티에 대해 dead variable elimination, scalar replacement 같은 최적화는 허용된다. 그러한 최적화는 해당 객체를 가리키는 WeakRef들을 관측 가능하게 비울 수 있다.</p>

        <p>반면 객체의 정체성이 관측 가능하고 그 객체가 WeakRef의 [[WeakRefTarget]] 내부 슬롯에 있다면, WeakRef를 관측 가능하게 비워 버리는 rematerialization 같은 최적화는 금지된다.</p>

        <p>HostEnqueueFinalizationRegistryCleanupJob 호출이 선택적이므로, FinalizationRegistry에 등록된 객체는 반드시 그 FinalizationRegistry를 live로 유지하지 않는다. 구현은 FinalizationRegistry 자체가 dead가 되었거나 애플리케이션이 종료 중인 경우 등 어떤 이유로든 FinalizationRegistry 콜백을 생략할 수 있다.</p>
      </emu-note>
      <emu-note>
        <p>구현은 live가 아닌 객체나 심볼의 최대 집합에 대해 WeakRef를 반드시 비울 필요는 없다.</p>
        <p>구현이 WeakRef를 비울 live가 아닌 집합 _S_를 선택한다면, 이 정의는 _S_ 내 모든 값에 대한 WeakRef를 동시에 비우도록 요구한다. 즉, 값 _v_를 가리키는 WeakRef 하나를 비우면서, 비워지지 않았다면 _v_의 값을 관측할 수도 있는 다른 WeakRef를 비우지 않은 채 두는 것은 적합(conformant)하지 않다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-host-hooks">
      <h1>호스트 훅(Host Hooks)</h1>

      <emu-clause id="sec-host-cleanup-finalization-registry" type="host-defined abstract operation">
        <h1>
          HostEnqueueFinalizationRegistryCleanupJob (
            _finalizationRegistry_: FinalizationRegistry,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <p>_finalizationRegistry_를 캡처하고 호출 시 다음 단계를 수행하는, 파라미터 없는 새 Job 추상 클로저 _cleanupJob_을 둔다:</p>
        <emu-alg>
          1. _cleanupResult_를 Completion(CleanupFinalizationRegistry(_finalizationRegistry_))로 둔다.
          1. _cleanupResult_가 abrupt completion이면 오류 보고를 위한 호스트 정의 단계를 수행한다.
          1. ~unused~를 반환한다.
        </emu-alg>
        <p>HostEnqueueFinalizationRegistryCleanupJob 구현은 가능하다면 미래의 어느 시점에 _cleanupJob_이 수행되도록 스케줄한다. 또한 <emu-xref href="#sec-jobs"></emu-xref>의 요구 사항을 따라야 한다.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-clear-kept-objects" type="abstract operation">
    <h1>ClearKeptObjects ( ): ~unused~</h1>
    <dl class="header">
      <dt>description</dt>
      <dd>ECMAScript 구현은 동기적인 ECMAScript 실행 시퀀스가 완료될 때 ClearKeptObjects를 호출하는 것이 기대된다.</dd>
    </dl>
    <emu-alg>
      1. _agentRecord_를 둘러싼 에이전트의 Agent Record로 둔다.
      1. _agentRecord_.[[KeptAlive]]를 새 빈 List로 설정한다.
      1. ~unused~를 반환한다.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-addtokeptobjects" type="abstract operation">
    <h1>
      AddToKeptObjects (
        _value_: an Object or a Symbol,
      ): ~unused~
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. _agentRecord_를 둘러싼 에이전트의 Agent Record로 둔다.
      1. _agentRecord_.[[KeptAlive]]에 _value_를 추가(Append)한다.
      1. ~unused~를 반환한다.
    </emu-alg>
    <emu-note>
      추상 연산 AddToKeptObjects가 어떤 대상 객체나 심볼과 함께 호출되면, ClearKeptObjects가 호출될 때까지 그 대상을 강하게 참조하는 목록에 대상을 추가한다.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-cleanup-finalization-registry" type="abstract operation">
    <h1>
      CleanupFinalizationRegistry (
        _finalizationRegistry_: a FinalizationRegistry,
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. 단언: _finalizationRegistry_는 [[Cells]] 및 [[CleanupCallback]] 내부 슬롯을 가진다.
      1. _callback_을 _finalizationRegistry_.[[CleanupCallback]]로 둔다.
      1. _finalizationRegistry_.[[Cells]]가 [[WeakRefTarget]]이 ~empty~인 Record _cell_을 포함하는 동안, 구현은 다음 단계를 수행할 수 있다:
        1. 그러한 _cell_ 중 임의의 하나를 선택한다.
        1. _finalizationRegistry_.[[Cells]]에서 _cell_을 제거한다.
        1. ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »)를 수행한다.
      1. ~unused~를 반환한다.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-canbeheldweakly" type="abstract operation">
    <h1>
      CanBeHeldWeakly (
        _v_: an ECMAScript language value,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>_v_가 약한 참조(weak reference)에 사용하기에 적합한 경우에만 *true*를 반환한다. 약한 참조에 사용하기에 적합한 값만이 WeakMap의 키, WeakSet의 요소, WeakRef의 target, 또는 FinalizationRegistry의 target들 중 하나가 될 수 있다.</dd>
    </dl>
    <emu-alg>
      1. _v_가 Object이면 *true*를 반환한다.
      1. _v_가 Symbol이고 KeyForSymbol(_v_)이 *undefined*이면 *true*를 반환한다.
      1. *false*를 반환한다.
    </emu-alg>
    <emu-note>
      <p><emu-xref href="#sec-identity">언어 정체성(language identity)</emu-xref>이 없는 언어 값은 사전 참조 없이도 나타날 수 있으며 약한 참조로 사용하기에 부적합하다. <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref>로 생성된 Symbol 값은 다른 Symbol 값과 달리 언어 정체성이 없으므로 약한 참조로 사용하기에 부적합하다. <emu-xref href="#sec-well-known-symbols">Well-known symbols</emu-xref>는 수집되지 않을 가능성이 높지만, 그 수가 제한되어 있고 다양한 구현 방식으로 관리 가능하므로 약한 참조로 사용하기에 적합한 것으로 간주된다. 그러나 live한 WeakMap 안의 well-known symbol에 연관된 어떤 값도 수집되지 않아 메모리 자원이 “누수”될 가능성이 있다.</p>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>일반(Ordinary) 및 이그조틱(Exotic) 객체 동작</h1>

  <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
    <h1>일반 객체의 내부 메서드와 내부 슬롯(Ordinary Object Internal Methods and Internal Slots)</h1>
    <p>모든 일반 객체는 [[Prototype]]이라 불리는 내부 슬롯을 가진다. 이 내부 슬롯의 값은 *null* 혹은 객체이며 상속을 구현하는 데 사용된다. 일반 객체 _O_ 에 속성 _P_ 가 없지만 그 객체의 [[Prototype]] 객체에는 존재한다고 가정하자. _P_ 가 [[Prototype]] 객체의 데이터 프로퍼티를 가리키면 _O_ 는 get 접근에 대해 그것을 상속하여 _P_ 가 마치 _O_ 의 자체 프로퍼티인 것처럼 동작한다. _P_ 가 [[Prototype]] 객체의 쓰기 가능한(writable) 데이터 프로퍼티를 가리키면 _O_ 에서 _P_ 에 대한 set 접근은 _O_ 에 이름이 _P_ 인 새로운 데이터 프로퍼티를 생성한다. _P_ 가 [[Prototype]] 객체의 쓰기 불가능한(non-writable) 데이터 프로퍼티를 가리키면 _O_ 에서 _P_ 에 대한 set 접근은 실패한다. _P_ 가 [[Prototype]] 객체의 접근자(accessor) 프로퍼티를 가리키면 그 접근자는 get 과 set 둘 다에 대해 _O_ 에 상속된다.</p>
    <p>모든 일반 객체는 Boolean 값을 갖는 [[Extensible]] 내부 슬롯을 가지며 이는 <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 에 명시된 확장성 관련 내부 메서드 불변식을 충족하는 데 사용된다. 즉, 객체의 [[Extensible]] 내부 슬롯 값이 *false* 로 설정되면 더 이상 그 객체에 새로운 프로퍼티를 추가하거나 객체의 [[Prototype]] 내부 슬롯 값을 수정하거나 이후 [[Extensible]] 값을 *true* 로 되돌릴 수 없다.</p>
    <p>이하의 알고리즘 설명에서 _O_ 는 일반 객체, _P_ 는 프로퍼티 키 값, _V_ 는 임의의 ECMAScript 언어 값, _Desc_ 는 프로퍼티 디스크립터(Property Descriptor) 레코드라고 가정한다.</p>
    <p>각 일반 객체 내부 메서드는 동일하거나 유사한 이름의 추상 연산에 위임한다. 그러한 추상 연산이 또 다른 내부 메서드에 의존하는 경우, 동일 이름의 추상 연산을 직접 호출하지 않고 _O_ 에 그 내부 메서드를 호출한다. 이러한 의미론은 일반 객체 내부 메서드가 이그조틱 객체에 적용될 때 해당 이그조틱 객체가 재정의한 내부 메서드가 호출되도록 보장한다.</p>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): 객체 또는 *null* 을 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryGetPrototypeOf(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarygetprototypeof" type="abstract operation">
        <h1>
          OrdinaryGetPrototypeOf (
            _O_: an Object,
          ): an Object or *null*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Prototype]] 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): Boolean 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinarySetPrototypeOf(_O_, _V_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarysetprototypeof" type="abstract operation">
        <h1>
          OrdinarySetPrototypeOf (
            _O_: an Object,
            _V_: an Object or *null*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ 를 _O_.[[Prototype]] 로 둔다.
          1. SameValue(_V_, _current_) 가 *true* 이면 *true* 를 반환한다.
          1. _extensible_ 을 _O_.[[Extensible]] 로 둔다.
          1. _extensible_ 이 *false* 이면 *false* 를 반환한다.
          1. _p_ 를 _V_ 로 둔다.
          1. _done_ 을 *false* 로 둔다.
          1. [id="step-ordinarysetprototypeof-loop"] _done_ 이 *false* 인 동안 반복한다,
            1. _p_ 가 *null* 이면
              1. _done_ 을 *true* 로 설정한다.
            1. 아니고 SameValue(_p_, _O_) 가 *true* 이면
              1. *false* 를 반환한다.
            1. 그 밖의 경우,
              1. _p_.[[GetPrototypeOf]] 가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref> 에 정의된 일반 객체 내부 메서드가 아니면 _done_ 을 *true* 로 설정한다.
              1. 아니면 _p_ 를 _p_.[[Prototype]] 로 설정한다.
          1. _O_.[[Prototype]] 을 _V_ 로 설정한다.
          1. *true* 를 반환한다.
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-ordinarysetprototypeof-loop"></emu-xref> 단계의 루프는 [[GetPrototypeOf]] 와 [[SetPrototypeOf]] 에 대한 일반 객체 정의만 사용하는 객체들로 이루어진 어떤 프로토타입 체인에도 순환이 생기지 않도록 보장한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): Boolean 을 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryIsExtensible(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryisextensible" type="abstract operation">
        <h1>
          OrdinaryIsExtensible (
            _O_: an Object,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Extensible]] 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): *true* 를 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryPreventExtensions(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarypreventextensions" type="abstract operation">
        <h1>
          OrdinaryPreventExtensions (
            _O_: an Object,
          ): *true*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_.[[Extensible]] 를 *false* 로 설정한다.
          1. *true* 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): Property Descriptor 또는 *undefined* 를 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryGetOwnProperty(_O_, _P_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarygetownproperty" type="abstract operation">
        <h1>
          OrdinaryGetOwnProperty (
            _O_: an Object,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_ 가 키 _P_ 인 자체 프로퍼티를 갖지 않으면 *undefined* 를 반환한다.
          1. 필드가 없는 새 프로퍼티 디스크립터 _D_ 를 생성한다.
          1. _X_ 를 키 _P_ 인 _O_ 의 자체 프로퍼티로 둔다.
          1. _X_ 가 데이터 프로퍼티라면
            1. _D_.[[Value]] 를 _X_ 의 [[Value]] 속성 값으로 설정한다.
            1. _D_.[[Writable]] 을 _X_ 의 [[Writable]] 속성 값으로 설정한다.
          1. 그렇지 않으면
            1. 단언: _X_ 는 접근자 프로퍼티이다.
            1. _D_.[[Get]] 을 _X_ 의 [[Get]] 속성 값으로 설정한다.
            1. _D_.[[Set]] 을 _X_ 의 [[Set]] 속성 값으로 설정한다.
          1. _D_.[[Enumerable]] 을 _X_ 의 [[Enumerable]] 속성 값으로 설정한다.
          1. _D_.[[Configurable]] 을 _X_ 의 [[Configurable]] 속성 값으로 설정한다.
          1. _D_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarydefineownproperty" type="abstract operation">
        <h1>
          OrdinaryDefineOwnProperty (
            _O_: an Object,
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _current_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _extensible_ 을 ? IsExtensible(_O_) 로 둔다.
          1. ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iscompatiblepropertydescriptor" type="abstract operation">
        <h1>
          IsCompatiblePropertyDescriptor (
            _Extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _Current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. ValidateAndApplyPropertyDescriptor(*undefined*, *""*, _Extensible_, _Desc_, _Current_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateandapplypropertydescriptor" type="abstract operation">
        <h1>
          ValidateAndApplyPropertyDescriptor (
            _O_: an Object or *undefined*,
            _P_: a property key,
            _extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_Desc_ 가 지정된 _extensibility_ 와 현재 프로퍼티 _current_ 를 가진 객체의 프로퍼티로 ( <emu-xref href="#sec-invariants-of-the-essential-internal-methods">불변식</emu-xref> 을 유지하면서) 적용될 수 있을 때에만 *true* 를 반환한다. 적용 가능하고 _O_ 가 *undefined* 가 아니면 이름이 _P_ 인 프로퍼티(필요 시 생성됨)에 대해 실제로 적용한다.</dd>
        </dl>
        <emu-alg>
          1. 단언: _P_ 는 프로퍼티 키이다.
          1. _current_ 가 *undefined* 이면
            1. _extensible_ 이 *false* 이면 *false* 반환.
            1. _O_ 가 *undefined* 이면 *true* 반환.
            1. IsAccessorDescriptor(_Desc_) 가 *true* 이면
              1. 객체 _O_ 에 이름 _P_ 인 자체 접근자 프로퍼티를 생성하되 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 그 속성의 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 으로 설정.
            1. 그렇지 않으면
              1. 객체 _O_ 에 이름 _P_ 인 자체 데이터 프로퍼티를 생성하되 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 그 속성의 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 으로 설정.
            1. *true* 반환.
          1. 단언: _current_ 는 완전히 채워진(Property Descriptor 모든 필드 보유) 프로퍼티 디스크립터이다.
          1. _Desc_ 가 어떤 필드도 갖지 않으면 *true* 반환.
          1. _current_.[[Configurable]] 이 *false* 이면
            1. _Desc_ 에 [[Configurable]] 필드가 있고 _Desc_.[[Configurable]] 이 *true* 이면 *false* 반환.
            1. _Desc_ 에 [[Enumerable]] 필드가 있고 _Desc_.[[Enumerable]] 이 _current_.[[Enumerable]] 와 다르면 *false* 반환.
            1. IsGenericDescriptor(_Desc_) 가 *false* 이고 IsAccessorDescriptor(_Desc_) 가 IsAccessorDescriptor(_current_) 와 다르면 *false* 반환.
            1. IsAccessorDescriptor(_current_) 가 *true* 이면
              1. _Desc_ 에 [[Get]] 필드가 있고 SameValue(_Desc_.[[Get]], _current_.[[Get]]) 가 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Set]] 필드가 있고 SameValue(_Desc_.[[Set]], _current_.[[Set]]) 가 *false* 이면 *false* 반환.
            1. Else if _current_.[[Writable]] 이 *false* 이면
              1. _Desc_ 에 [[Writable]] 필드가 있고 _Desc_.[[Writable]] 이 *true* 이면 *false* 반환.
              1. NOTE: SameValue 는 *NaN* 에 대해 *true* 를 반환한다. 여기서 반환하면 기존 프로퍼티가 수정되지 않음을 보장한다.
              1. _Desc_ 에 [[Value]] 필드가 있으면 SameValue(_Desc_.[[Value]], _current_.[[Value]]) 를 반환.
          1. _O_ 가 *undefined* 가 아니면
            1. IsDataDescriptor(_current_) 가 *true* 이고 IsAccessorDescriptor(_Desc_) 가 *true* 이면
              1. _Desc_ 에 [[Configurable]] 필드가 있으면 _configurable_ 을 그 값으로, 아니면 _current_.[[Configurable]] 로 둔다.
              1. _Desc_ 에 [[Enumerable]] 필드가 있으면 _enumerable_ 을 그 값으로, 아니면 _current_.[[Enumerable]] 로 둔다.
              1. 객체 _O_ 의 이름 _P_ 인 프로퍼티를 접근자 프로퍼티로 교체하되 [[Configurable]] 과 [[Enumerable]] 은 각각 _configurable_, _enumerable_ 로, [[Get]], [[Set]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 로 설정.
            1. Else if IsAccessorDescriptor(_current_) 가 *true* 이고 IsDataDescriptor(_Desc_) 가 *true* 이면
              1. _Desc_ 에 [[Configurable]] 필드가 있으면 _configurable_ 을 그 값으로, 아니면 _current_.[[Configurable]] 로 둔다.
              1. _Desc_ 에 [[Enumerable]] 필드가 있으면 _enumerable_ 을 그 값으로, 아니면 _current_.[[Enumerable]] 로 둔다.
              1. 객체 _O_ 의 이름 _P_ 인 프로퍼티를 데이터 프로퍼티로 교체하되 [[Configurable]] 과 [[Enumerable]] 은 각각 _configurable_, _enumerable_ 로, [[Value]], [[Writable]] 은 _Desc_ 에 해당 필드가 있으면 그 값, 아니면 <emu-xref href="#table-object-property-attributes">기본값</emu-xref> 로 설정.
            1. Else
              1. _Desc_ 의 각 필드에 대해 객체 _O_ 의 이름 _P_ 인 프로퍼티의 대응 속성을 그 필드 값으로 설정.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryHasProperty(_O_, _P_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryhasproperty" type="abstract operation">
        <h1>
          OrdinaryHasProperty (
            _O_: an Object,
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _hasOwn_ 을 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _hasOwn_ 이 *undefined* 가 아니면 *true* 반환.
          1. _parent_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
          1. _parent_ 가 *null* 이 아니면
            1. ? <emu-meta effects="user-code">_parent_.[[HasProperty]]</emu-meta>(_P_) 를 반환한다.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>

      <emu-alg>
        1. ? OrdinaryGet(_O_, _P_, _Receiver_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryget" type="abstract operation">
        <h1>
          OrdinaryGet (
            _O_: an Object,
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면
            1. _parent_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
            1. _parent_ 가 *null* 이면 *undefined* 반환.
            1. ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_) 를 반환한다.
          1. IsDataDescriptor(_desc_) 가 *true* 이면 _desc_.[[Value]] 를 반환한다.
          1. 단언: IsAccessorDescriptor(_desc_) 는 *true* 이다.
          1. _getter_ 를 _desc_.[[Get]] 로 둔다.
          1. _getter_ 가 *undefined* 이면 *undefined* 반환.
          1. ? Call(_getter_, _Receiver_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinarySet(_O_, _P_, _V_, _Receiver_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryset" type="abstract operation">
        <h1>
          OrdinarySet (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _ownDesc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarysetwithowndescriptor" type="abstract operation">
        <h1>
          OrdinarySetWithOwnDescriptor (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
            _ownDesc_: a Property Descriptor or *undefined*,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _ownDesc_ 가 *undefined* 이면
            1. _parent_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
            1. _parent_ 가 *null* 이 아니면
              1. ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_) 를 반환한다.
            1. 그렇지 않으면
              1. _ownDesc_ 를 PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } 로 설정한다.
          1. IsDataDescriptor(_ownDesc_) 가 *true* 이면
            1. _ownDesc_.[[Writable]] 이 *false* 이면 *false* 반환.
            1. _Receiver_ 가 객체가 아니면 *false* 반환.
            1. _existingDescriptor_ 를 ? <emu-meta effects="user-code">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
            1. _existingDescriptor_ 가 *undefined* 가 아니면
              1. IsAccessorDescriptor(_existingDescriptor_) 가 *true* 이면 *false* 반환.
              1. _existingDescriptor_.[[Writable]] 이 *false* 이면 *false* 반환.
              1. _valueDesc_ 를 PropertyDescriptor { [[Value]]: _V_ } 로 둔다.
              1. ? <emu-meta effects="user-code">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_) 를 반환한다.
            1. 그렇지 않으면
              1. 단언: _Receiver_ 는 현재 프로퍼티 _P_ 를 갖지 않는다.
              1. ? CreateDataProperty(_Receiver_, _P_, _V_) 를 반환한다.
          1. 단언: IsAccessorDescriptor(_ownDesc_) 는 *true* 이다.
          1. _setter_ 를 _ownDesc_.[[Set]] 로 둔다.
          1. _setter_ 가 *undefined* 이면 *false* 반환.
          1. ? Call(_setter_, _Receiver_, « _V_ ») 를 수행한다.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): Boolean 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. ? OrdinaryDelete(_O_, _P_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinarydelete" type="abstract operation">
        <h1>
          OrdinaryDelete (
            _O_: an Object,
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면 *true* 반환.
          1. _desc_.[[Configurable]] 이 *true* 이면
            1. 이름 _P_ 인 자체 프로퍼티를 _O_ 에서 제거한다.
            1. *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>일반 객체 _O_</dd>
      </dl>
      <emu-alg>
        1. OrdinaryOwnPropertyKeys(_O_) 를 반환한다.
      </emu-alg>

      <emu-clause id="sec-ordinaryownpropertykeys" type="abstract operation">
        <h1>
          OrdinaryOwnPropertyKeys (
            _O_: an Object,
          ): a List of property keys
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. _keys_ 를 새 빈 List 로 둔다.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 배열 인덱스인 것들을 숫자 인덱스 오름차순으로 순회하며
            1. _keys_ 에 _P_ 를 추가한다.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 String 이고 배열 인덱스가 아닌 것들을 생성 시점의 시간 순(chronological order) 오름차순으로 순회하며
            1. _keys_ 에 _P_ 를 추가한다.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 Symbol 인 것들을 생성 시점의 시간 순 오름차순으로 순회하며
            1. _keys_ 에 _P_ 를 추가한다.
          1. _keys_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinaryobjectcreate" type="abstract operation" oldids="sec-objectcreate">
      <h1>
        OrdinaryObjectCreate (
          _proto_: an Object or *null*,
          optional _additionalInternalSlotsList_: a List of names of internal slots,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>새 일반 객체를 런타임에 생성하는 과정을 명세하는 데 사용된다. _additionalInternalSlotsList_ 는 [[Prototype]] 과 [[Extensible]] 외에 객체 일부로 정의되어야 하는 추가 내부 슬롯 이름을 담는다. _additionalInternalSlotsList_ 가 제공되지 않으면 새 빈 List 를 사용한다.</dd>
      </dl>
      <emu-alg>
        1. _internalSlotsList_ 를 « [[Prototype]], [[Extensible]] » 로 둔다.
        1. _additionalInternalSlotsList_ 가 주어지면 _internalSlotsList_ 를 그 뒤에 _additionalInternalSlotsList_ 를 이어붙인(list-concatenation) 리스트로 갱신한다.
        1. _O_ 를 MakeBasicObject(_internalSlotsList_) 로 둔다.
        1. _O_.[[Prototype]] 을 _proto_ 로 설정한다.
        1. _O_ 를 반환한다.
      </emu-alg>

      <emu-note>
        <p>OrdinaryObjectCreate 는 MakeBasicObject 호출 외에 많은 일을 하지 않지만, 이를 사용함으로써 이그조틱이 아닌 “일반 객체” 를 만들고자 함을 전달한다. 따라서 이 명세에서 결과 객체의 내부 메서드를 비일반적으로 만들 방식으로 이후 수정하는 어떤 알고리즘도 이를 호출하지 않는다. 이그조틱 객체를 생성하는 연산은 MakeBasicObject 를 직접 호출한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinarycreatefromconstructor" type="abstract operation">
      <h1>
        OrdinaryCreateFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
          optional _internalSlotsList_: a List of names of internal slots,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>생성자의 *"prototype"* 프로퍼티가 존재하면 거기서 가져온 값을 [[Prototype]] 으로 하는 일반 객체를 생성한다. 그렇지 않으면 _intrinsicDefaultProto_ 로 명명된 intrinsic 이 [[Prototype]] 으로 사용된다. _internalSlotsList_ 는 객체 일부로 정의되어야 하는 추가 내부 슬롯 이름을 담으며 제공되지 않으면 새 빈 List 를 사용한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _intrinsicDefaultProto_ 는 이 명세에서 정의한 intrinsic 객체의 이름이다. 해당 객체는 다른 객체의 [[Prototype]] 값으로 사용되도록 의도된 intrinsic 이어야 한다.
        1. _proto_ 를 ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_) 로 둔다.
        1. _internalSlotsList_ 가 존재하면 _slotsList_ 를 _internalSlotsList_ 로 둔다.
        1. 아니면 _slotsList_ 를 새 빈 List 로 둔다.
        1. OrdinaryObjectCreate(_proto_, _slotsList_) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getprototypefromconstructor" type="abstract operation">
      <h1>
        GetPrototypeFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>특정 생성자에 대응하는 객체를 만들 때 사용할 [[Prototype]] 값을 결정한다. 생성자의 *"prototype"* 프로퍼티가 존재하면 그 값이 사용되고, 그렇지 않으면 _intrinsicDefaultProto_ 로 명명된 intrinsic 이 [[Prototype]] 으로 사용된다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _intrinsicDefaultProto_ 는 이 명세에서 정의한 intrinsic 객체의 이름이다. 해당 객체는 객체의 [[Prototype]] 값으로 사용되도록 의도된 intrinsic 이어야 한다.
        1. _proto_ 를 ? Get(_constructor_, *"prototype"*) 로 둔다.
        1. _proto_ 가 객체가 아니면
          1. _realm_ 을 ? GetFunctionRealm(_constructor_) 로 둔다.
          1. _proto_ 를 _realm_ 의 _intrinsicDefaultProto_ 라는 이름의 intrinsic 객체로 설정한다.
        1. _proto_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>_constructor_ 가 [[Prototype]] 값을 제공하지 않으면 사용되는 기본값은 실행 중인 실행 컨텍스트가 아니라 _constructor_ 함수의 realm 에서 얻는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-requireinternalslot" type="abstract operation">
      <h1>
        RequireInternalSlot (
          _O_: an ECMAScript language value,
          _internalSlot_: an internal slot name,
        ): ~unused~ 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_O_ 가 객체가 아니거나 지정된 내부 슬롯을 가지지 않으면 예외를 던진다.</dd>
      </dl>
      <emu-alg>
        1. _O_ 가 객체가 아니면 *TypeError* 예외를 던진다.
        1. _O_ 에 _internalSlot_ 내부 슬롯이 없으면 *TypeError* 예외를 던진다.
        1. ~unused~ 를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript 함수 객체(ECMAScript Function Objects)</h1>
    <p>ECMAScript 함수 객체는 렉시컬 환경을 클로즈(over)한 매개변수화된 ECMAScript 코드를 캡슐화하며 그 코드를 동적으로 평가할 수 있게 해준다. ECMAScript 함수 객체는 일반 객체(ordinary object)이며 다른 일반 객체와 동일한 내부 슬롯과 내부 메서드를 가진다. ECMAScript 함수 객체의 코드는 strict 모드 코드(<emu-xref href="#sec-strict-mode-code"></emu-xref>) 또는 비 strict 코드일 수 있다. 코드가 strict 모드 코드인 ECMAScript 함수 객체를 <dfn id="strict-function" variants="strict functions">strict 함수</dfn>라 한다. 코드가 strict 모드 코드가 아닌 것을 <dfn id="non-strict-function" variants="non-strict functions">non‑strict 함수</dfn>라 한다.</p>
    <p>[[Extensible]] 및 [[Prototype]] 외에도, ECMAScript 함수 객체는 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>에 나열된 내부 슬롯을 추가로 가진다.</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="ECMAScript 함수 객체의 내부 슬롯(Internal Slots of ECMAScript Function Objects)" oldids="table-27">
      <table>
        <thead>
          <tr>
            <th>Internal Slot</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tr>
          <td>[[Environment]]</td>
          <td>an Environment Record</td>
          <td>함수가 클로즈한 Environment Record. 함수 코드 평가 시 외부 환경(outer environment)으로 사용.</td>
        </tr>
        <tr>
          <td>[[PrivateEnvironment]]</td>
          <td>a PrivateEnvironment Record or *null*</td>
          <td>함수가 클로즈한 Private Name 용 PrivateEnvironment Record. 함수가 문법적으로 어떤 클래스 내부에도 포함되지 않았다면 *null*. 함수 코드 평가 시 내부 클래스들의 외부 PrivateEnvironment로 사용.</td>
        </tr>
        <tr>
          <td>[[FormalParameters]]</td>
          <td>a Parse Node</td>
          <td>함수의 형식 매개변수 목록을 정의하는 소스 텍스트의 루트 Parse Node.</td>
        </tr>
        <tr>
          <td>[[ECMAScriptCode]]</td>
          <td>a Parse Node</td>
          <td>함수 본문을 정의하는 소스 텍스트의 루트 Parse Node.</td>
        </tr>
        <tr>
          <td>[[ConstructorKind]]</td>
          <td>~base~ or ~derived~</td>
          <td>함수가 파생 클래스 생성자인지 여부.</td>
        </tr>
        <tr>
          <td>[[Realm]]</td>
          <td>a Realm Record</td>
          <td>함수가 생성된 realm이며 함수 평가 시 접근되는 intrinsic 객체들을 제공.</td>
        </tr>
        <tr>
          <td>[[ScriptOrModule]]</td>
          <td>a Script Record or a Module Record</td>
          <td>함수가 생성된 스크립트 또는 모듈.</td>
        </tr>
        <tr>
          <td>[[ThisMode]]</td>
          <td>~lexical~, ~strict~, or ~global~</td>
          <td>`this` 참조가 형식 매개변수 및 함수 본문 내에서 어떻게 해석되는지 정의. ~lexical~ 은 `this` 가 렉시컬로 둘러싼 함수의 *this* 값을 가리킴. ~strict~ 은 *this* 값이 호출 시 제공된 그대로 사용됨. ~global~ 은 *undefined* 또는 *null* 인 *this* 값을 전역 객체 참조로 해석하고, 다른 *this* 값은 먼저 ToObject 적용.</td>
        </tr>
        <tr>
          <td>[[Strict]]</td>
          <td>a Boolean</td>
          <td>*true* 이면 strict 함수, *false* 이면 non‑strict 함수.</td>
        </tr>
        <tr>
          <td>[[HomeObject]]</td>
          <td>an Object</td>
          <td>함수가 `super`를 사용한다면, `super` 프로퍼티 조회의 시작점을 제공하는 [[GetPrototypeOf]] 대상 객체.</td>
        </tr>
        <tr>
          <td>[[SourceText]]</td>
          <td>a sequence of Unicode code points</td>
          <td>함수를 정의하는 <emu-xref href="#sec-source-text">소스 텍스트</emu-xref>.</td>
        </tr>
        <tr>
          <td>[[Fields]]</td>
          <td>a List of ClassFieldDefinition Records</td>
          <td>함수가 클래스라면, 비정적 필드 및 그 초기화자를 나타내는 Record들의 목록.</td>
        </tr>
        <tr>
          <td>[[PrivateMethods]]</td>
          <td>a List of PrivateElements</td>
          <td>함수가 클래스라면, 비정적 private 메서드 및 접근자들을 나타내는 목록.</td>
        </tr>
        <tr>
          <td>[[ClassFieldInitializerName]]</td>
          <td>a String, a Symbol, a Private Name, or ~empty~</td>
          <td>함수가 클래스 필드 초기화자로 생성된 경우, 필드의 NamedEvaluation에 사용할 이름; 그렇지 않으면 ~empty~.</td>
        </tr>
        <tr>
          <td>[[IsClassConstructor]]</td>
          <td>a Boolean</td>
          <td>함수가 클래스 생성자인지 나타냄. (*true* 이면 함수의 [[Call]] 호출은 즉시 *TypeError* 예외 throw).</td>
        </tr>
      </table>
    </emu-table>
    <p>모든 ECMAScript 함수 객체는 여기 정의된 [[Call]] 내부 메서드를 가진다. 동시에 생성자인 ECMAScript 함수는 추가로 [[Construct]] 내부 메서드를 가진다.</p>

    <emu-clause id="sec-ecmascript-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>ECMAScript 함수 객체 _F_</dd>
      </dl>
      <emu-alg>
        1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _calleeContext_ 를 PrepareForOrdinaryCall(_F_, *undefined*) 로 둔다.
        1. 단언: _calleeContext_ 가 이제 실행 중 실행 컨텍스트.
        1. _F_.[[IsClassConstructor]] 가 *true* 이면
          1. 새 *TypeError* 객체 _error_ 를 생성한다.
          1. NOTE: _error_ 는 _calleeContext_ 에서 _F_ 의 Realm Record 로 생성된다.
          1. 실행 컨텍스트 스택에서 _calleeContext_ 를 제거하고 _callerContext_ 를 실행 중 실행 컨텍스트로 복원한다.
          1. ThrowCompletion(_error_) 를 반환한다.
        1. OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_) 를 수행한다.
        1. _result_ 를 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)) 로 둔다.
        1. [id="step-call-pop-context-stack"] 실행 컨텍스트 스택에서 _calleeContext_ 를 제거하고 _callerContext_ 를 실행 중 실행 컨텍스트로 복원한다.
        1. _result_ 가 return completion 이면 _result_.[[Value]] 반환.
        1. 단언: _result_ 는 throw completion.
        1. ? _result_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>단계 <emu-xref href="#step-call-pop-context-stack"></emu-xref> 에서 _calleeContext_ 가 스택에서 제거될 때 접근 가능한 Generator 에 의해 나중 재개를 위해 suspend 및 보존된 경우 파괴되면 안 된다.</p>
      </emu-note>

      <emu-clause id="sec-prepareforordinarycall" type="abstract operation">
        <h1>
          PrepareForOrdinaryCall (
            _F_: an ECMAScript function object,
            _newTarget_: an Object or *undefined*,
          ): an execution context
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
          1. _calleeContext_ 를 새 ECMAScript 코드 실행 컨텍스트로 둔다.
          1. _calleeContext_ 의 Function 을 _F_ 로 설정.
          1. _calleeRealm_ 을 _F_.[[Realm]] 로 둔다.
          1. _calleeContext_ 의 Realm 을 _calleeRealm_ 으로 설정.
          1. _calleeContext_ 의 ScriptOrModule 을 _F_.[[ScriptOrModule]] 로 설정.
          1. _localEnv_ 를 NewFunctionEnvironment(_F_, _newTarget_) 로 둔다.
          1. _calleeContext_ 의 LexicalEnvironment 를 _localEnv_ 로 설정.
          1. _calleeContext_ 의 VariableEnvironment 를 _localEnv_ 로 설정.
          1. _calleeContext_ 의 PrivateEnvironment 를 _F_.[[PrivateEnvironment]] 로 설정.
          1. _callerContext_ 가 아직 suspend 되어 있지 않다면 suspend 한다.
          1. _calleeContext_ 를 실행 컨텍스트 스택에 push; _calleeContext_ 가 이제 실행 중 실행 컨텍스트.
          1. NOTE: 이 지점 이후 생성되는 모든 예외 객체는 _calleeRealm_ 과 연관됨.
          1. _calleeContext_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallbindthis" type="abstract operation">
        <h1>
          OrdinaryCallBindThis (
            _F_: an ECMAScript function object,
            _calleeContext_: an execution context,
            _thisArgument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _thisMode_ 를 _F_.[[ThisMode]] 로 둔다.
          1. _thisMode_ 가 ~lexical~ 이면 ~unused~ 반환.
          1. _calleeRealm_ 을 _F_.[[Realm]] 로 둔다.
          1. _localEnv_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
          1. _thisMode_ 가 ~strict~ 이면
            1. _thisValue_ 를 _thisArgument_ 로 둔다.
          1. 그렇지 않으면
            1. _thisArgument_ 가 *undefined* 또는 *null* 이면
              1. _globalEnv_ 를 _calleeRealm_.[[GlobalEnv]] 로 둔다.
              1. 단언: _globalEnv_ 는 Global Environment Record.
              1. _thisValue_ 를 _globalEnv_.[[GlobalThisValue]] 로 둔다.
            1. 아니면
              1. _thisValue_ 를 ! ToObject(_thisArgument_) 로 둔다.
              1. NOTE: ToObject 는 _calleeRealm_ 을 사용하여 wrapper 객체를 생성.
          1. 단언: _localEnv_ 는 Function Environment Record.
          1. 단언: 다음 단계는 _localEnv_.[[ThisBindingStatus]] 가 ~initialized~ 가 아니므로 abrupt completion 을 반환하지 않는다.
          1. ! BindThisValue(_localEnv_, _thisValue_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-evaluatebody" type="sdo">
        <h1>
          Runtime Semantics: EvaluateBody (
            _functionObject_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header"></dl>
        <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
        <emu-alg>
          1. |FunctionBody| 의 EvaluateFunctionBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. |ConciseBody| 의 EvaluateConciseBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |GeneratorBody| 의 EvaluateGeneratorBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>AsyncGeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |AsyncGeneratorBody| 의 EvaluateAsyncGeneratorBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>AsyncFunctionBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. |AsyncFunctionBody| 의 EvaluateAsyncFunctionBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. |AsyncConciseBody| 의 EvaluateAsyncConciseBody (인수 _functionObject_, _argumentsList_) ? 를 반환.
        </emu-alg>
        <emu-grammar>
          Initializer :
            `=` AssignmentExpression
        </emu-grammar>
        <emu-alg>
          1. 단언: _argumentsList_ 는 비어 있다.
          1. 단언: _functionObject_.[[ClassFieldInitializerName]] 는 ~empty~ 가 아니다.
            1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이면
              1. _value_ 를 |Initializer| 의 NamedEvaluation (인수 _functionObject_.[[ClassFieldInitializerName]]) ? 로 둔다.
            1. 그렇지 않으면
              1. _rhs_ 를 |AssignmentExpression| 의 Evaluation ? 로 둔다.
              1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. ReturnCompletion(_value_) 를 반환.
        </emu-alg>
        <emu-note>
          <p>필드 초기화자는 함수 경계를 형성하지만 FunctionDeclarationInstantiation 호출은 관측 가능한 효과가 없으므로 생략된다.</p>
        </emu-note>
        <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
        <emu-alg>
          1. 단언: _argumentsList_ 는 비어 있다.
          1. |ClassStaticBlockBody| 의 EvaluateClassStaticBlockBody (인수 _functionObject_) ? 를 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallevaluatebody" type="abstract operation">
        <h1>
          OrdinaryCallEvaluateBody (
            _F_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _F_.[[ECMAScriptCode]] 의 EvaluateBody (인수 _F_, _argumentsList_) ? 를 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>ECMAScript 함수 객체 _F_</dd>
      </dl>
      <emu-alg>
        1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _kind_ 를 _F_.[[ConstructorKind]] 로 둔다.
        1. _kind_ 가 ~base~ 이면
          1. _thisArgument_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*) 로 둔다.
        1. _calleeContext_ 를 PrepareForOrdinaryCall(_F_, _newTarget_) 로 둔다.
        1. 단언: _calleeContext_ 가 이제 실행 중 실행 컨텍스트.
        1. _kind_ 가 ~base~ 이면
          1. OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_) 수행.
          1. _initializeResult_ 를 Completion(InitializeInstanceElements(_thisArgument_, _F_)) 로 둔다.
          1. _initializeResult_ 가 abrupt completion 이면
            1. 실행 컨텍스트 스택에서 _calleeContext_ 제거 후 _callerContext_ 복원.
            1. ? _initializeResult_ 반환.
        1. _constructorEnv_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
        1. _result_ 를 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)) 로 둔다.
        1. 실행 컨텍스트 스택에서 _calleeContext_ 제거 후 _callerContext_ 복원.
        1. _result_ 가 throw completion 이면
          1. ? _result_ 반환.
        1. 단언: _result_ 는 return completion.
        1. _result_.[[Value]] 가 객체이면 그 값 반환.
        1. _kind_ 가 ~base~ 이면 _thisArgument_ 반환.
        1. _result_.[[Value]] 가 *undefined* 가 아니면 *TypeError* 예외 throw.
        1. _thisBinding_ 을 ? _constructorEnv_.GetThisBinding() 로 둔다.
        1. 단언: _thisBinding_ 은 객체.
        1. _thisBinding_ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" type="abstract operation" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>
        OrdinaryFunctionCreate (
          _functionPrototype_: an Object,
          _sourceText_: a sequence of Unicode code points,
          _ParameterList_: a Parse Node,
          _Body_: a Parse Node,
          _thisMode_: ~lexical-this~ or ~non-lexical-this~,
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>기본 [[Call]] 내부 메서드만 있고 [[Construct]] 내부 메서드는 없는(단, 이후 MakeConstructor 같은 연산으로 추가될 수 있음) 새 함수를 런타임에 생성하는 과정을 명세한다. _sourceText_ 는 생성할 함수 문법 정의의 소스 텍스트.</dd>
      </dl>
      <emu-alg>
        1. _internalSlotsList_ 를 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 나열된 내부 슬롯으로 둔다.
        1. _F_ 를 OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_) 로 둔다.
        1. _F_.[[Call]] 을 <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 에 명시된 정의로 설정.
        1. _F_.[[SourceText]] 를 _sourceText_ 로 설정.
        1. _F_.[[FormalParameters]] 를 _ParameterList_ 로 설정.
        1. _F_.[[ECMAScriptCode]] 를 _Body_ 로 설정.
        1. _Strict_ 를 IsStrict(_Body_) 로 둔다.
        1. _F_.[[Strict]] 를 _Strict_ 로 설정.
        1. _thisMode_ 가 ~lexical-this~ 이면 _F_.[[ThisMode]] 를 ~lexical~ 로 설정.
        1. Else if _Strict_ 가 *true* 이면 _F_.[[ThisMode]] 를 ~strict~ 로 설정.
        1. Else _F_.[[ThisMode]] 를 ~global~ 로 설정.
        1. _F_.[[IsClassConstructor]] 를 *false* 로 설정.
        1. _F_.[[Environment]] 를 _env_ 로 설정.
        1. _F_.[[PrivateEnvironment]] 를 _privateEnv_ 로 설정.
        1. _F_.[[ScriptOrModule]] 를 GetActiveScriptOrModule() 로 설정.
        1. _F_.[[Realm]] 을 current Realm Record 로 설정.
        1. _F_.[[HomeObject]] 를 *undefined* 로 설정.
        1. _F_.[[Fields]] 를 새 빈 List 로 설정.
        1. _F_.[[PrivateMethods]] 를 새 빈 List 로 설정.
        1. _F_.[[ClassFieldInitializerName]] 를 ~empty~ 로 설정.
        1. _len_ 을 _ParameterList_ 의 ExpectedArgumentCount 로 둔다.
        1. SetFunctionLength(_F_, _len_) 수행.
        1. _F_ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addrestrictedfunctionproperties" type="abstract operation">
      <h1>
        AddRestrictedFunctionProperties (
          _F_: a function object,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 단언: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] 가 존재하며 초기화됨.
        1. _thrower_ 를 _realm_.[[Intrinsics]].[[%ThrowTypeError%]] 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"caller"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ! DefinePropertyOrThrow(_F_, *"arguments"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>

      <emu-clause id="sec-%throwtypeerror%">
        <h1>%ThrowTypeError% ( )</h1>
        <p>이 함수는 <dfn>%ThrowTypeError%</dfn> intrinsic 객체이다.</p>
        <p>각 realm 마다 한 번 정의되는 익명 내장 함수 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *TypeError* 예외를 throw 한다.
        </emu-alg>
        <p>이 함수의 [[Extensible]] 내부 슬롯 값은 *false* 이다.</p>
        <p>이 함수의 *"length"* 프로퍼티 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <p>이 함수의 *"name"* 프로퍼티 속성은 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-makeconstructor" type="abstract operation">
      <h1>
        MakeConstructor (
          _F_: an ECMAScript function object or a built-in function object,
          optional _writablePrototype_: a Boolean,
          optional _prototype_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 를 생성자로 변환한다.</dd>
      </dl>
      <emu-alg>
        1. _F_ 가 ECMAScript 함수 객체이면
          1. 단언: IsConstructor(_F_) 는 *false*.
          1. 단언: _F_ 는 *"prototype"* 자체 프로퍼티가 없는 extensible 객체.
          1. _F_.[[Construct]] 를 <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 에 명시된 정의로 설정.
        1. 그렇지 않으면
          1. _F_.[[Construct]] 를 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 에 명시된 정의로 설정.
        1. _F_.[[ConstructorKind]] 를 ~base~ 로 설정.
        1. _writablePrototype_ 이 제공되지 않았다면 *true* 로 설정.
        1. _prototype_ 이 제공되지 않았다면
          1. _prototype_ 을 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ! DefinePropertyOrThrow(_prototype_, *"constructor"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeclassconstructor" type="abstract operation">
      <h1>
        MakeClassConstructor (
          _F_: an ECMAScript function object,
        ): ~unused~
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 단언: _F_.[[IsClassConstructor]] 는 *false*.
        1. _F_.[[IsClassConstructor]] 를 *true* 로 설정.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" type="abstract operation">
      <h1>
        MakeMethod (
          _F_: an ECMAScript function object,
          _homeObject_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 를 메서드로 구성한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _homeObject_ 는 일반 객체.
        1. _F_.[[HomeObject]] 를 _homeObject_ 로 설정.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definemethodproperty" oldids="sec-createmethodproperty" type="abstract operation">
      <h1>
        DefineMethodProperty (
          _homeObject_: an Object,
          _key_: a property key or Private Name,
          _closure_: a function object,
          _enumerable_: a Boolean,
        ): PrivateElement 또는 ~unused~ 를 담는 normal completion 또는 abrupt completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 단언: _homeObject_ 는 ordinary 이며 extensible 한 객체.
        1. _key_ 가 Private Name 이면
          1. PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ } 를 반환.
        1. 그렇지 않으면
          1. _desc_ 를 PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* } 로 둔다.
          1. ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_) 수행.
          1. NOTE: _key_ 가 *"prototype"* 인 class static method 정의 시에만 abrupt completion 반환 가능.
          1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionname" type="abstract operation">
      <h1>
        SetFunctionName (
          _F_: a function object,
          _name_: a property key or Private Name,
          optional _prefix_: a String,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 에 *"name"* 프로퍼티를 추가한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _F_ 는 *"name"* 자체 프로퍼티가 없는 extensible 객체.
        1. _name_ 이 Symbol 이면
          1. _description_ 을 _name_.[[Description]] 로 둔다.
          1. _description_ 이 *undefined* 이면 _name_ 을 빈 문자열로 설정.
          1. 그렇지 않으면 _name_ 을 *"["*, _description_, *"]"* 의 문자열 연결로 설정.
        1. Else if _name_ 이 Private Name 이면
          1. _name_ 을 _name_.[[Description]] 로 설정.
        1. _F_ 가 [[InitialName]] 내부 슬롯을 가진다면
          1. _F_.[[InitialName]] 를 _name_ 으로 설정.
        1. _prefix_ 가 존재하면
          1. _name_ 을 (_prefix_ + 0x0020(SPACE) + _name_) 문자열 연결로 설정.
          1. _F_ 가 [[InitialName]] 내부 슬롯을 가진다면
            1. NOTE: 다음 선택은 이 Abstract Operation 이 호출될 때마다 독립적으로 이루어짐.
            1. 선택적으로 _F_.[[InitialName]] 를 _name_ 으로 설정.
        1. ! DefinePropertyOrThrow(_F_, *"name"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionlength" type="abstract operation">
      <h1>
        SetFunctionLength (
          _F_: a function object,
          _length_: a non-negative integer or +&infin;,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_F_ 에 *"length"* 프로퍼티를 추가한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _F_ 는 *"length"* 자체 프로퍼티가 없는 extensible 객체.
        1. ! DefinePropertyOrThrow(_F_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-functiondeclarationinstantiation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): ~unused~ 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ 는 실행 컨텍스트를 설정 중인 함수 객체이다.</dd>
      </dl>
      <emu-note>
        <p>ECMAScript 함수를 평가하기 위한 실행 컨텍스트가 설정될 때 새로운 Function Environment Record 가 생성되고 각 형식 매개변수에 대한 바인딩이 그 Environment Record 에서 인스턴스화된다. 함수 본문 내 모든 선언도 인스턴스화된다. 함수의 형식 매개변수에 기본값 초기화자가 없으면 본문 선언들은 매개변수와 동일한 Environment Record 에서 인스턴스화된다. 기본값 매개변수 초기화자가 있으면 본문 선언을 위한 두 번째 Environment Record 가 생성된다. 형식 매개변수와 함수들은 FunctionDeclarationInstantiation 의 일부로 초기화된다. 다른 모든 바인딩은 함수 본문 평가 중 초기화된다.</p>
      </emu-note>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _calleeContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _code_ 를 _func_.[[ECMAScriptCode]] 로 둔다.
        1. _strict_ 를 _func_.[[Strict]] 로 둔다.
        1. _formals_ 를 _func_.[[FormalParameters]] 로 둔다.
        1. _parameterNames_ 를 _formals_ 의 BoundNames 로 둔다.
        1. _parameterNames_ 가 중복 항목을 가지면 _hasDuplicates_ 를 *true*, 아니면 *false* 로 둔다.
        1. _simpleParameterList_ 를 IsSimpleParameterList of _formals_ 로 둔다.
        1. _hasParameterExpressions_ 를 ContainsExpression of _formals_ 로 둔다.
        1. _varNames_ 를 _code_ 의 VarDeclaredNames 로 둔다.
        1. _varDeclarations_ 를 _code_ 의 VarScopedDeclarations 로 둔다.
        1. _lexicalNames_ 를 _code_ 의 LexicallyDeclaredNames 로 둔다.
        1. _functionNames_ 를 새 빈 List 로 둔다.
        1. _functionsToInitialize_ 를 새 빈 List 로 둔다.
        1. _varDeclarations_ 의 각 요소 _d_ 에 대해 (역순으로):
          1. _d_ 가 |VariableDeclaration|, |ForBinding|, |BindingIdentifier| 가 아니면
            1. 단언: _d_ 는 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| 중 하나.
            1. _fn_ 을 _d_ 의 BoundNames 의 유일한 요소로 둔다.
            1. _functionNames_ 가 _fn_ 을 포함하지 않으면
              1. _fn_ 을 _functionNames_ 의 첫 요소로 삽입.
              1. NOTE: 동일 이름 함수 선언이 여러 개면 마지막 선언 사용.
              1. _d_ 를 _functionsToInitialize_ 의 첫 요소로 삽입.
        1. _argumentsObjectNeeded_ 를 *true* 로 둔다.
        1. _func_.[[ThisMode]] 가 ~lexical~ 이면
          1. NOTE: 화살표 함수는 arguments 객체를 갖지 않는다.
          1. _argumentsObjectNeeded_ 를 *false* 로 설정.
        1. Else if _parameterNames_ 가 *"arguments"* 를 포함하면
          1. _argumentsObjectNeeded_ 를 *false* 로.
        1. Else if _hasParameterExpressions_ 가 *false* 이면
          1. _functionNames_ 가 *"arguments"* 를 포함하거나 _lexicalNames_ 가 *"arguments"* 를 포함하면
            1. _argumentsObjectNeeded_ 를 *false* 로.
        1. _strict_ 이 *true* 이거나 _hasParameterExpressions_ 가 *false* 이면
          1. NOTE: strict 모드 eval 은 외부에서 보이는 새 바인딩을 만들 수 없으므로 매개변수에 단일 Environment Record 만 필요.
          1. _env_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
        1. Else
          1. NOTE: 형식 매개변수 리스트 내 direct eval 이 만든 바인딩이 매개변수 선언 환경 밖에 위치하도록 분리된 Environment Record 필요.
          1. _calleeEnv_ 를 _calleeContext_ 의 LexicalEnvironment 로 둔다.
          1. _env_ 를 NewDeclarativeEnvironment(_calleeEnv_) 로 둔다.
          1. 단언: _calleeContext_ 의 VariableEnvironment 와 _calleeEnv_ 는 동일한 Environment Record.
          1. _calleeContext_ 의 LexicalEnvironment 를 _env_ 로 설정.
        1. _parameterNames_ 의 각 String _paramName_ 에 대해
          1. _alreadyDeclared_ 를 ! _env_.HasBinding(_paramName_) 로 둔다.
          1. NOTE: 중복 매개변수 이름은 기본값/나머지 매개변수 없는 non‑strict 함수에만 가능(초기 에러 규칙).
          1. _alreadyDeclared_ 가 *false* 이면
            1. ! _env_.CreateMutableBinding(_paramName_, *false*) 수행.
            1. _hasDuplicates_ 가 *true* 이면
              1. ! _env_.InitializeBinding(_paramName_, *undefined*) 수행.
        1. _argumentsObjectNeeded_ 가 *true* 이면
          1. _strict_ 이 *true* 이거나 _simpleParameterList_ 가 *false* 이면
            1. _ao_ 를 CreateUnmappedArgumentsObject(_argumentsList_) 로 둔다.
          1. Else
            1. NOTE: mapped arguments 객체는 rest, 기본값, 구조분해 매개변수 없는 non‑strict 함수에만 제공.
            1. _ao_ 를 CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_) 로 둔다.
          1. _strict_ 이 *true* 이면
            1. ! _env_.CreateImmutableBinding(*"arguments"*, *false*) 수행.
            1. NOTE: strict 코드에서는 이 바인딩에 할당 시도 자체가 조기 에러로 금지되어 불변성 관측 불가.
          1. Else
            1. ! _env_.CreateMutableBinding(*"arguments"*, *false*) 수행.
          1. ! _env_.InitializeBinding(*"arguments"*, _ao_) 수행.
          1. _parameterBindings_ 를 _parameterNames_ 와 « *"arguments"* » 의 리스트 연결로 둔다.
        1. Else
          1. _parameterBindings_ 를 _parameterNames_ 로 둔다.
        1. _iteratorRecord_ 를 CreateListIteratorRecord(_argumentsList_) 로 둔다.
        1. _hasDuplicates_ 가 *true* 이면
          1. _usedEnv_ 를 *undefined* 로 둔다.
        1. Else
          1. _usedEnv_ 를 _env_ 로 둔다.
        1. NOTE: 다음 단계는 표현식 위치에서 |YieldExpression| 사용으로만 ReturnCompletion 이 가능하나 파라미터 리스트에서 조기 에러로 금지됨.
        1. ? IteratorBindingInitialization of _formals_ (인수 _iteratorRecord_, _usedEnv_) 수행.
        1. _hasParameterExpressions_ 가 *false* 이면
          1. NOTE: 매개변수와 최상위 var 에 단일 Environment Record 사용.
          1. _instantiatedVarNames_ 를 _parameterBindings_ 복사본으로 둔다.
          1. _varNames_ 의 각 _n_ 에 대해
            1. _instantiatedVarNames_ 가 _n_ 을 포함하지 않으면
              1. _instantiatedVarNames_ 에 _n_ 추가.
              1. ! _env_.CreateMutableBinding(_n_, *false*) 수행.
              1. ! _env_.InitializeBinding(_n_, *undefined*) 수행.
          1. _varEnv_ 를 _env_ 로 둔다.
        1. Else
          1. NOTE: 형식 매개변수 표현식이 만든 클로저가 함수 본문 선언을 보지 못하도록 별도 Environment Record 필요.
          1. _varEnv_ 를 NewDeclarativeEnvironment(_env_) 로 둔다.
          1. _calleeContext_ 의 VariableEnvironment 를 _varEnv_ 로 설정.
          1. _instantiatedVarNames_ 를 새 빈 List 로 둔다.
          1. _varNames_ 의 각 _n_ 에 대해
            1. _instantiatedVarNames_ 가 _n_ 을 포함하지 않으면
              1. _instantiatedVarNames_ 에 _n_ 추가.
              1. ! _varEnv_.CreateMutableBinding(_n_, *false*) 수행.
              1. (_parameterBindings_ 가 _n_ 을 포함하지 않거나 _functionNames_ 가 _n_ 을 포함하면)
                1. _initialValue_ 를 *undefined* 로 둔다.
              1. Else
                1. _initialValue_ 를 ! _env_.GetBindingValue(_n_, *false*) 로 둔다.
              1. ! _varEnv_.InitializeBinding(_n_, _initialValue_) 수행.
              1. NOTE: 형식 매개변수와 같은 이름의 var 는 초기에는 해당 매개변수 초기화 값과 동일.
        1. _strict_ 이 *true* 이면
          1. _lexEnv_ 를 _varEnv_ 로 둔다.
        1. Else
          1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
            1. _code_ Contains _x_ 가 *true* 인 어떤 |Block|, |CaseClause|, |DefaultClause| _x_ 의 |StatementList| 에 직접 포함된 각 |FunctionDeclaration| _f_ 에 대해
              1. _F_ 를 _f_ 의 |BindingIdentifier| 의 StringValue 로 둔다.
              1. |FunctionDeclaration| _f_ 를 _F_ 를 |BindingIdentifier| 로 갖는 |VariableStatement| 로 대체해도 _func_ 에 대해 Early Errors 가 발생하지 않고 _parameterNames_ 가 _F_ 를 포함하지 않으면
                1. NOTE: _F_ 에 대한 var 바인딩은 VarDeclaredName 이 아니고 형식 매개변수 이름도 아니며 다른 |FunctionDeclaration| 도 아닐 때만 여기서 인스턴스화.
                1. _instantiatedVarNames_ 가 _F_ 를 포함하지 않고 _F_ 가 *"arguments"* 가 아니면
                  1. ! _varEnv_.CreateMutableBinding(_F_, *false*) 수행.
                  1. ! _varEnv_.InitializeBinding(_F_, *undefined*) 수행.
                  1. _instantiatedVarNames_ 에 _F_ 추가.
                1. [id="step-functiondeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ 평가 시 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 의 Evaluation 알고리즘 대신 다음 수행:
                  1. _fEnv_ 를 실행 중 실행 컨텍스트의 VariableEnvironment 로 둔다.
                  1. _bEnv_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
                  1. _fObj_ 를 ! _bEnv_.GetBindingValue(_F_, *false*) 로 둔다.
                  1. ! _fEnv_.SetMutableBinding(_F_, _fObj_, *false*) 수행.
                  1. ~unused~ 반환.
          1. _lexEnv_ 를 NewDeclarativeEnvironment(_varEnv_) 로 둔다.
          1. NOTE: non‑strict 함수는 direct eval 이 생성한 var 스코프 선언과 기존 최상위 lexical 선언 충돌 여부를 판단할 수 있도록 top-level lexical 선언에 별도의 Environment Record 사용. strict 함수는 항상 새 Environment Record 사용하므로 불필요.
        1. _calleeContext_ 의 LexicalEnvironment 를 _lexEnv_ 로 설정.
        1. _lexDeclarations_ 를 _code_ 의 LexicallyScopedDeclarations 로 둔다.
        1. _lexDeclarations_ 의 각 _d_ 에 대해
          1. NOTE: lexical 선언 이름은 함수/제너레이터 선언, 형식 매개변수, var 이름과 같을 수 없으며 여기서 인스턴스화만 되고 초기화는 안 됨.
          1. _d_ 의 BoundNames 각 _dn_ 에 대해
            1. IsConstantDeclaration of _d_ 가 *true* 이면
              1. ! _lexEnv_.CreateImmutableBinding(_dn_, *true*) 수행.
            1. Else
              1. ! _lexEnv_.CreateMutableBinding(_dn_, *false*) 수행.
        1. _privateEnv_ 를 _calleeContext_ 의 PrivateEnvironment 로 둔다.
        1. _functionsToInitialize_ 의 각 Parse Node _f_ 에 대해
          1. _fn_ 을 _f_ 의 BoundNames 유일 요소로 둔다.
          1. _fo_ 를 InstantiateFunctionObject of _f_ (인수 _lexEnv_, _privateEnv_) 로 둔다.
          1. ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-function-objects">
    <h1>내장 함수 객체(Built-in Function Objects)</h1>
    <p>내장 함수 객체는 일반 객체이며; <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>에 규정된 일반 객체 요건을 만족해야 한다.</p>
    <p>모든 일반 객체에 요구되는 내부 슬롯(<emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 참조)에 더해, 내장 함수 객체는 다음 내부 슬롯도 가져야 한다:</p>
    <ul>
      <li>[[Realm]]: 함수가 생성된 realm 을 나타내는 Realm Record.</li>
      <li>[[InitialName]]: 함수의 초기 이름인 String. <emu-xref href="#sec-function.prototype.tostring"></emu-xref>에서 사용된다.</li>
    </ul>
    <p>명시적으로 달리 지정되지 않은 한, 내장 함수 객체의 [[Prototype]] 내부 슬롯 초기 값은 %Function.prototype% 이다.</p>
    <p>내장 함수 객체는 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref>의 정의에 부합하는 [[Call]] 내부 메서드를 가져야 한다.</p>
    <p>내장 함수 객체는 “constructor”로 기술되었거나 이 명세의 어떤 알고리즘이 그 [[Construct]] 내부 메서드를 명시적으로 설정한 경우에만 [[Construct]] 내부 메서드를 가진다. 그러한 [[Construct]] 내부 메서드는 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref>의 정의를 준수해야 한다.</p>
    <p>구현은 이 명세에 정의되지 않은 추가 내장 함수 객체를 제공할 수 있다.</p>

    <emu-clause id="sec-built-in-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>내장 함수 객체 _F_</dd>
      </dl>
      <emu-alg>
        1. ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*) 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-built-in-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 객체 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>내장 함수 객체 _F_ (이 메서드가 존재할 때)</dd>
      </dl>
      <emu-alg>
        1. _result_ 를 ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_) 로 둔다.
        1. 단언: _result_ 는 Object.
        1. _result_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-builtincallorconstruct" type="abstract operation">
      <h1>
        BuiltinCallOrConstruct (
          _F_: a built-in function object,
          _thisArgument_: an ECMAScript language value or ~uninitialized~,
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor or *undefined*,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. _callerContext_ 를 실행 중 실행 컨텍스트로 둔다.
        1. _callerContext_ 가 아직 suspend 되어 있지 않다면 suspend 한다.
        1. _calleeContext_ 를 새 실행 컨텍스트로 둔다.
        1. _calleeContext_ 의 Function 을 _F_ 로 설정한다.
        1. _calleeRealm_ 을 _F_.[[Realm]] 로 둔다.
        1. _calleeContext_ 의 Realm 을 _calleeRealm_ 로 설정한다.
        1. _calleeContext_ 의 ScriptOrModule 을 *null* 로 설정한다.
        1. 구현 정의된 필요 초기화를 _calleeContext_ 에 수행한다.
        1. _calleeContext_ 를 실행 컨텍스트 스택에 push; 이제 _calleeContext_ 가 실행 중 실행 컨텍스트이다.
        1. [id="step-call-builtin-function-result"] _result_ 를 _F_ 의 명세에 부합하는 방식으로 _F_ 를 평가하여 얻은 Completion Record 로 둔다. _thisArgument_ 가 ~uninitialized~ 이면 *this* 값은 초기화되지 않은 상태이며; 그렇지 않으면 _thisArgument_ 가 *this* 값을 제공한다. _argumentsList_ 는 명명된 매개변수들을 제공한다. _newTarget_ 은 NewTarget 값을 제공한다.
        1. NOTE: _F_ 가 이 문서에서 정의된 경우 “the specification of _F_” 는 알고리즘 단계 등으로 기술된 그 동작을 의미한다.
        1. 실행 컨텍스트 스택에서 _calleeContext_ 를 제거하고 _callerContext_ 를 실행 중 실행 컨텍스트로 복원한다.
        1. ? _result_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>_calleeContext_ 가 실행 컨텍스트 스택에서 제거될 때 접근 가능한 Generator 에 의해 suspend 및 보존되어 후속 재개가 예정된 경우 파괴되어서는 안 된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createbuiltinfunction" type="abstract operation">
      <h1>
        CreateBuiltinFunction (
          _behaviour_: an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification,
          _length_: a non-negative integer or +&infin;,
          _name_: a property key or a Private Name,
          _additionalInternalSlotsList_: a List of names of internal slots,
          optional _realm_: a Realm Record,
          optional _prototype_: an Object or *null*,
          optional _prefix_: a String,
        ): a built-in function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_additionalInternalSlotsList_ 는 객체 일부로 정의되어야 하는 추가 내부 슬롯 이름을 담는다. 이 연산은 내장 함수 객체를 생성한다.</dd>
      </dl>
      <emu-alg>
        1. _realm_ 이 제공되지 않았다면 current Realm Record 로 설정한다.
        1. _prototype_ 이 제공되지 않았다면 _prototype_ 을 _realm_.[[Intrinsics]].[[%Function.prototype%]] 로 설정한다.
        1. _internalSlotsList_ 를 곧 생성할 내장 함수 객체에 대해 <emu-xref href="#sec-built-in-function-objects"></emu-xref>가 요구하는 모든 내부 슬롯 이름을 담는 List 로 둔다.
        1. _additionalInternalSlotsList_ 의 요소들을 _internalSlotsList_ 에 추가(Append)한다.
        1. _func_ 를 새 내장 함수 객체로 두되, 호출 시 _behaviour_ 가 지정한 매개변수에 제공 인수를 값으로 하여 _behaviour_ 에 기술된 동작을 수행한다. 새 함수 객체는 _internalSlotsList_ 요소 이름의 내부 슬롯과 [[InitialName]] 내부 슬롯을 가진다.
        1. _func_.[[Prototype]] 을 _prototype_ 으로 설정한다.
        1. _func_.[[Extensible]] 를 *true* 로 설정한다.
        1. _func_.[[Realm]] 을 _realm_ 으로 설정한다.
        1. _func_.[[InitialName]] 을 *null* 로 설정한다.
        1. SetFunctionLength(_func_, _length_) 를 수행한다.
        1. _prefix_ 가 제공되지 않았다면
          1. SetFunctionName(_func_, _name_) 를 수행한다.
        1. 그렇지 않으면
          1. SetFunctionName(_func_, _name_, _prefix_) 를 수행한다.
        1. _func_ 를 반환한다.
      </emu-alg>
      <p>이 명세에 정의된 각 내장 함수는 CreateBuiltinFunction 추상 연산을 호출하여 생성된다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>내장 이그조틱 객체의 내부 메서드와 슬롯(Built-in Exotic Object Internal Methods and Slots)</h1>
    <p>이 명세는 여러 종류의 내장 이그조틱 객체를 정의한다. 이 객체들은 특정한 몇몇 상황을 제외하면 일반 객체와 유사하게 동작한다. 다음 이그조틱 객체들은 아래에서 명시적으로 달리 지정된 경우를 제외하고 일반 객체 내부 메서드를 사용한다:</p>

    <emu-clause id="sec-bound-function-exotic-objects">
      <h1>바운드 함수 이그조틱 객체(Bound Function Exotic Objects)</h1>
      <p>바운드 함수 이그조틱 객체는 다른 함수 객체를 감싸는 이그조틱 객체이다. 바운드 함수 이그조틱 객체는 호출 가능(callable)하며([[Call]] 내부 메서드를 가지며 필요 시 [[Construct]] 내부 메서드도 가질 수 있음), 호출하면 보통 감싼 함수가 호출된다.</p>

      <p>객체의 [[Call]] 및 (해당하는 경우) [[Construct]] 내부 메서드가 아래 구현을 사용하고, 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>의 정의를 사용한다면 그 객체는 <dfn id="bound-function-exotic-object" variants="bound function exotic objects">바운드 함수 이그조틱 객체</dfn>이다. 이러한 메서드는 BoundFunctionCreate 에서 설치된다.</p>

      <p>바운드 함수 이그조틱 객체는 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>에 나열된 ECMAScript 함수 객체의 내부 슬롯을 가지지 않는다. 대신 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref>에 나열된 내부 슬롯을 [[Prototype]], [[Extensible]]와 더불어 가진다.</p>
      <emu-table id="table-internal-slots-of-bound-function-exotic-objects" caption="바운드 함수 이그조틱 객체의 내부 슬롯(Internal Slots of Bound Function Exotic Objects)" oldids="table-28">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[BoundTargetFunction]]</td>
            <td>a callable Object</td>
            <td>감싸진(wrapped) 함수 객체.</td>
          </tr>
          <tr>
            <td>[[BoundThis]]</td>
            <td>an ECMAScript language value</td>
            <td>감싸진 함수를 호출할 때 항상 *this* 값으로 전달되는 값.</td>
          </tr>
          <tr>
            <td>[[BoundArguments]]</td>
            <td>a List of ECMAScript language values</td>
            <td>감싸진 함수 호출 시 선행 인수로 사용되는 값들의 리스트.</td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-bound-function-exotic-objects-call-thisargument-argumentslist" type="internal method">
        <h1>
          [[Call]] (
            _thisArgument_: an ECMAScript language value,
            _argumentsList_: a List of ECMAScript language values,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>바운드 함수 이그조틱 객체 _F_</dd>
        </dl>
        <emu-alg>
          1. _target_ 을 _F_.[[BoundTargetFunction]] 로 둔다.
          1. _boundThis_ 를 _F_.[[BoundThis]] 로 둔다.
          1. _boundArgs_ 를 _F_.[[BoundArguments]] 로 둔다.
          1. _args_ 를 _boundArgs_ 와 _argumentsList_ 의 리스트 연결(list-concatenation)으로 둔다.
          1. ? Call(_target_, _boundThis_, _args_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bound-function-exotic-objects-construct-argumentslist-newtarget" type="internal method">
        <h1>
          [[Construct]] (
            _argumentsList_: a List of ECMAScript language values,
            _newTarget_: a constructor,
          ): 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>바운드 함수 이그조틱 객체 _F_</dd>
        </dl>
        <emu-alg>
          1. _target_ 을 _F_.[[BoundTargetFunction]] 로 둔다.
          1. 단언: IsConstructor(_target_) 는 *true*.
          1. _boundArgs_ 를 _F_.[[BoundArguments]] 로 둔다.
          1. _args_ 를 _boundArgs_ 와 _argumentsList_ 의 리스트 연결로 둔다.
          1. SameValue(_F_, _newTarget_) 가 *true* 이면 _newTarget_ 을 _target_ 으로 설정한다.
          1. ? Construct(_target_, _args_, _newTarget_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundfunctioncreate" type="abstract operation">
        <h1>
          BoundFunctionCreate (
            _targetFunction_: a function object,
            _boundThis_: an ECMAScript language value,
            _boundArgs_: a List of ECMAScript language values,
          ): 함수 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 바운드 함수 이그조틱 객체 생성을 명세하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _proto_ 를 ? <emu-meta effects="user-code">_targetFunction_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
          1. _internalSlotsList_ 를 « [[Prototype]], [[Extensible]] » 와 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref>에 나열된 내부 슬롯의 리스트 연결로 둔다.
          1. _obj_ 를 MakeBasicObject(_internalSlotsList_) 로 둔다.
          1. _obj_.[[Prototype]] 을 _proto_ 로 설정한다.
          1. _obj_.[[Call]] 을 <emu-xref href="#sec-bound-function-exotic-objects-call-thisargument-argumentslist"></emu-xref>에 기술된 대로 설정한다.
          1. IsConstructor(_targetFunction_) 가 *true* 이면
            1. _obj_.[[Construct]] 를 <emu-xref href="#sec-bound-function-exotic-objects-construct-argumentslist-newtarget"></emu-xref>에 기술된 대로 설정한다.
          1. _obj_.[[BoundTargetFunction]] 을 _targetFunction_ 으로 설정한다.
          1. _obj_.[[BoundThis]] 를 _boundThis_ 로 설정한다.
          1. _obj_.[[BoundArguments]] 를 _boundArgs_ 로 설정한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-exotic-objects">
      <h1>배열(Array) 이그조틱 객체(Array Exotic Objects)</h1>
      <p>Array 는 배열 인덱스 프로퍼티 키(<emu-xref href="#sec-object-type"></emu-xref> 참조)에 특별 취급을 제공하는 이그조틱 객체이다. 프로퍼티 이름이 배열 인덱스인 프로퍼티를 <em>element</em> 라고도 부른다. 모든 Array 는 재정의 불가(non-configurable) *"length"* 프로퍼티를 가지며 그 값은 2<sup>32</sup> 보다 작은 0 이상 정수 Number 이다. *"length"* 프로퍼티 값은 이름이 배열 인덱스인 모든 자체 프로퍼티 이름보다 수치적으로 크다; Array 의 자체 프로퍼티가 생성되거나 변경될 때마다 이 불변식을 유지하도록 다른 프로퍼티들이 필요 시 조정된다. 구체적으로 배열 인덱스 이름의 자체 프로퍼티가 추가되면 *"length"* 값은 필요 시 그 인덱스의 수치 값보다 1 큰 값으로 변경되고; *"length"* 값이 변경되면 새 length 보다 크거나 같았던 배열 인덱스 이름의 모든 자체 프로퍼티는 삭제된다. 이 제약은 Array 의 자체 프로퍼티에만 적용되며 프로토타입에서 상속될 수 있는 *"length"* 또는 배열 인덱스 프로퍼티에는 영향받지 않는다.</p>

      <p>객체의 [[DefineOwnProperty]] 내부 메서드가 아래 구현을 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>의 정의를 사용하면 그 객체는 <dfn id="array-exotic-object" variants="Array exotic objects">Array 이그조틱 객체</dfn>(간단히 Array)이다. 이러한 메서드는 ArrayCreate 에서 설치된다.</p>

      <emu-clause id="sec-array-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>Array 이그조틱 객체 _A_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 *"length"* 이면
            1. ? ArraySetLength(_A_, _Desc_) 를 반환한다.
          1. Else if _P_ 가 배열 인덱스이면
            1. _lengthDesc_ 를 OrdinaryGetOwnProperty(_A_, *"length"*) 로 둔다.
            1. 단언: _lengthDesc_ 는 *undefined* 가 아님.
            1. 단언: IsDataDescriptor(_lengthDesc_) 는 *true*.
            1. 단언: _lengthDesc_.[[Configurable]] 는 *false*.
            1. _length_ 를 _lengthDesc_.[[Value]] 로 둔다.
            1. 단언: _length_ 는 0 이상 정수 Number.
            1. _index_ 를 ! ToUint32(_P_) 로 둔다.
            1. _index_ ≥ _length_ 이고 _lengthDesc_.[[Writable]] 이 *false* 이면 *false* 반환.
            1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_) 로 둔다.
            1. _succeeded_ 가 *false* 이면 *false* 반환.
            1. _index_ ≥ _length_ 이면
              1. _lengthDesc_.[[Value]] 를 _index_ + *1*<sub>𝔽</sub> 로 설정.
              1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _lengthDesc_) 로 설정.
              1. 단언: _succeeded_ 는 *true*.
            1. *true* 반환.
          1. ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraycreate" type="abstract operation">
        <h1>
          ArrayCreate (
            _length_: a non-negative integer,
            optional _proto_: an Object,
          ): Array 이그조틱 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 Array 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _length_ > 2<sup>32</sup> - 1 이면 *RangeError* 예외 throw.
          1. _proto_ 가 제공되지 않았다면 _proto_ 를 %Array.prototype% 으로 설정.
          1. _A_ 를 MakeBasicObject(« [[Prototype]], [[Extensible]] ») 로 둔다.
          1. _A_.[[Prototype]] 을 _proto_ 로 설정.
          1. _A_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>에 지정된 대로 설정.
          1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arrayspeciescreate" type="abstract operation">
        <h1>
          ArraySpeciesCreate (
            _originalArray_: an Object,
            _length_: a non-negative integer,
          ): 객체 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_originalArray_ 에서 파생된 constructor 함수를 사용하여 새 Array 또는 유사 객체를 생성하는 과정을 명세한다. constructor 가 반드시 Array 를 반환하도록 강제하지 않는다.</dd>
        </dl>
        <emu-alg>
          1. _isArray_ 를 ? IsArray(_originalArray_) 로 둔다.
          1. _isArray_ 가 *false* 이면 ? ArrayCreate(_length_) 반환.
          1. _C_ 를 ? Get(_originalArray_, *"constructor"*) 로 둔다.
          1. IsConstructor(_C_) 가 *true* 이면
            1. _thisRealm_ 을 current Realm Record 로 둔다.
            1. _realmC_ 를 ? GetFunctionRealm(_C_) 로 둔다.
            1. _thisRealm_ 과 _realmC_ 가 동일 Realm Record 가 아니면
              1. SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) 가 *true* 이면 _C_ 를 *undefined* 로 설정.
          1. _C_ 가 Object 이면
            1. _C_ 를 ? Get(_C_, %Symbol.species%) 로 설정.
            1. _C_ 가 *null* 이면 _C_ 를 *undefined* 로 설정.
          1. _C_ 가 *undefined* 이면 ? ArrayCreate(_length_) 반환.
          1. IsConstructor(_C_) 가 *false* 이면 *TypeError* 예외 throw.
          1. ? Construct(_C_, « 𝔽(_length_) ») 반환.
        </emu-alg>
        <emu-note>
          <p>_originalArray_ 가 실행 중 실행 컨텍스트의 realm 이 아닌 realm 의 표준 내장 Array 생성자로 생성되었다면, 실행 중 실행 컨텍스트 realm 을 사용하여 새 Array 가 생성된다. 이는 ArraySpeciesCreate 로 정의된 `Array.prototype` 메서드들에 대해 역사적으로 그러한 동작을 가진 웹 브라우저와의 호환성을 유지한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-arraysetlength" type="abstract operation">
        <h1>
          ArraySetLength (
            _A_: an Array,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _Desc_ 가 [[Value]] 필드를 가지지 않으면
            1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _Desc_) 반환.
          1. _newLenDesc_ 를 _Desc_ 의 복사본으로 둔다.
          1. [id="step-arraysetlength-newlen"] _newLen_ 을 ? ToUint32(_Desc_.[[Value]]) 로 둔다.
          1. [id="step-arraysetlength-numberlen"] _numberLen_ 을 ? ToNumber(_Desc_.[[Value]]) 로 둔다.
          1. SameValueZero(_newLen_, _numberLen_) 가 *false* 이면 *RangeError* 예외 throw.
          1. _newLenDesc_.[[Value]] 를 _newLen_ 으로 설정.
          1. _oldLenDesc_ 를 OrdinaryGetOwnProperty(_A_, *"length"*) 로 둔다.
          1. 단언: _oldLenDesc_ 는 *undefined* 아님.
          1. 단언: IsDataDescriptor(_oldLenDesc_) 는 *true*.
          1. 단언: _oldLenDesc_.[[Configurable]] 는 *false*.
          1. _oldLen_ 을 _oldLenDesc_.[[Value]] 로 둔다.
          1. _newLen_ ≥ _oldLen_ 이면
            1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) 반환.
          1. _oldLenDesc_.[[Writable]] 이 *false* 이면 *false* 반환.
          1. _newLenDesc_ 가 [[Writable]] 필드를 가지지 않거나 _newLenDesc_.[[Writable]] 이 *true* 이면
            1. _newWritable_ 를 *true* 로 둔다.
          1. Else
            1. NOTE: 어떤 element 를 삭제할 수 없는 경우를 대비하여 [[Writable]] 을 *false* 로 설정하는 것을 지연.
            1. _newWritable_ 를 *false* 로 둔다.
            1. _newLenDesc_.[[Writable]] 을 *true* 로 설정.
          1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) 로 둔다.
          1. _succeeded_ 가 *false* 이면 *false* 반환.
          1. _A_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 배열 인덱스이고 ! ToUint32(_P_) ≥ _newLen_ 인 것들을 내림차순 숫자 인덱스 순으로 순회하며
            1. _deleteSucceeded_ 를 ! _A_.[[Delete]](_P_) 로 둔다.
            1. _deleteSucceeded_ 가 *false* 이면
              1. _newLenDesc_.[[Value]] 를 ! ToUint32(_P_) + *1*<sub>𝔽</sub> 로 설정.
              1. _newWritable_ 이 *false* 이면 _newLenDesc_.[[Writable]] 을 *false* 로 설정.
              1. ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_) 수행.
              1. *false* 반환.
          1. _newWritable_ 이 *false* 이면
            1. _succeeded_ 를 ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Writable]]: *false* }) 로 설정.
            1. 단언: _succeeded_ 는 *true*.
          1. *true* 반환.
        </emu-alg>
        <emu-note>
          <p><emu-xref href="#step-arraysetlength-newlen"></emu-xref> 및 <emu-xref href="#step-arraysetlength-numberlen"></emu-xref> 단계에서 _Desc_.[[Value]] 가 객체이면 그 `valueOf` 메서드는 두 번 호출된다. 이는 명세 2<sup>판</sup>부터 이런 효과로 규정된 레거시 동작이다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-exotic-objects">
      <h1>문자열(String) 이그조틱 객체(String Exotic Objects)</h1>
      <p>String 객체는 String 값을 캡슐화하고 그 String 값의 개별 코드 유닛 요소에 해당하는 가상 정수 인덱스 데이터 프로퍼티를 노출하는 이그조틱 객체이다. String 이그조틱 객체는 캡슐화된 String 값 길이를 값으로 갖는 *"length"* 데이터 프로퍼티를 항상 가진다. 코드 유닛 데이터 프로퍼티와 *"length"* 프로퍼티 모두 쓰기 불가능 및 재정의 불가이다.</p>

      <p>객체의 [[GetOwnProperty]], [[DefineOwnProperty]], [[OwnPropertyKeys]] 내부 메서드가 아래 구현을 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 정의를 사용하면 그 객체는 <dfn id="string-exotic-object" variants="String exotic objects">String 이그조틱 객체</dfn>(간단히 String 객체)이다. 이러한 메서드는 StringCreate 에서 설치된다.</p>

      <p>String 이그조틱 객체는 일반 객체와 동일한 내부 슬롯을 갖는다. 추가로 [[StringData]] 내부 슬롯을 가진다.</p>

      <emu-clause id="sec-string-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String 이그조틱 객체 _S_</dd>
        </dl>
        <emu-alg>
          1. _desc_ 를 OrdinaryGetOwnProperty(_S_, _P_) 로 둔다.
          1. _desc_ 가 *undefined* 가 아니면 _desc_ 반환.
          1. StringGetOwnProperty(_S_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String 이그조틱 객체 _S_</dd>
        </dl>
        <emu-alg>
          1. _stringDesc_ 를 StringGetOwnProperty(_S_, _P_) 로 둔다.
          1. _stringDesc_ 가 *undefined* 가 아니면
            1. _extensible_ 을 _S_.[[Extensible]] 로 둔다.
            1. IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_) 반환.
          1. ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>String 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _keys_ 를 새 빈 List 로 둔다.
          1. _str_ 을 _O_.[[StringData]] 로 둔다.
          1. 단언: _str_ 은 String.
          1. _len_ 을 _str_ 의 길이로 둔다.
          1. 0 ≤ _i_ < _len_ 인 각 정수 _i_ 에 대해 오름차순으로
            1. ! ToString(𝔽(_i_)) 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 배열 인덱스이며 ! ToIntegerOrInfinity(_P_) ≥ _len_ 인 것들을 숫자 인덱스 오름차순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 String 이고 배열 인덱스가 아닌 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 Symbol 인 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _keys_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringcreate" type="abstract operation">
        <h1>
          StringCreate (
            _value_: a String,
            _prototype_: an Object,
          ): String 이그조틱 객체
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 String 이그조틱 객체 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _S_ 를 MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] ») 로 둔다.
          1. _S_.[[Prototype]] 을 _prototype_ 으로 설정.
          1. _S_.[[StringData]] 를 _value_ 로 설정.
          1. _S_.[[GetOwnProperty]] 를 <emu-xref href="#sec-string-exotic-objects-getownproperty-p"></emu-xref>에 지정된 대로 설정.
          1. _S_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-string-exotic-objects-defineownproperty-p-desc"></emu-xref>에 지정된 대로 설정.
          1. _S_.[[OwnPropertyKeys]] 를 <emu-xref href="#sec-string-exotic-objects-ownpropertykeys"></emu-xref>에 지정된 대로 설정.
          1. _length_ 를 _value_ 길이로 둔다.
          1. ! DefinePropertyOrThrow(_S_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. _S_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringgetownproperty" type="abstract operation">
        <h1>
          StringGetOwnProperty (
            _S_: an Object that has a [[StringData]] internal slot,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _P_ 가 String 이 아니면 *undefined* 반환.
          1. _index_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
          1. _index_ 가 정수 Number 가 아니면 *undefined* 반환.
          1. _index_ 가 *-0*<sub>𝔽</sub> 이거나 _index_ < *-0*<sub>𝔽</sub> 이면 *undefined* 반환.
          1. _str_ 을 _S_.[[StringData]] 로 둔다.
          1. 단언: _str_ 은 String.
          1. _len_ 을 _str_ 길이로 둔다.
          1. ℝ(_index_) ≥ _len_ 이면 *undefined* 반환.
          1. _resultStr_ 을 _str_ 의 ℝ(_index_) 부터 ℝ(_index_) + 1 까지 부분 문자열로 둔다.
          1. PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* } 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arguments-exotic-objects">
      <h1>Arguments 이그조틱 객체(Arguments Exotic Objects)</h1>

      <p>대부분의 ECMAScript 함수는 코드에서 사용할 수 있는 arguments 객체를 제공한다. 함수 정의 특성에 따라 그 arguments 객체는 일반 객체이거나 arguments 이그조틱 객체가 된다. arguments 이그조틱 객체는 배열 인덱스 프로퍼티들이 관련 ECMAScript 함수 호출의 형식 매개변수 바인딩에 매핑되는 이그조틱 객체이다.</p>

      <p>객체의 내부 메서드가 아래 구현을 사용하고 여기 명시되지 않은 메서드는 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>의 정의를 사용하면 그 객체는 <dfn id="arguments-exotic-object" variants="arguments exotic objects">arguments 이그조틱 객체</dfn>이다. 이러한 메서드는 CreateMappedArgumentsObject 에서 설치된다.</p>

      <emu-note>
        <p>CreateUnmappedArgumentsObject 는 이 절에 묶여 있지만, 이그조틱이 아닌 일반 객체를 생성한다.</p>
      </emu-note>

      <p>Arguments 이그조틱 객체는 일반 객체와 동일한 내부 슬롯을 가지며 추가로 [[ParameterMap]] 내부 슬롯을 가진다. 일반 arguments 객체 또한 값이 항상 *undefined* 인 [[ParameterMap]] 내부 슬롯을 갖는다. 일반 arguments 객체의 [[ParameterMap]] 내부 슬롯은 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>)이 그것을 식별하는 데만 사용된다.</p>

      <emu-note>
        <p>arguments 이그조틱 객체 중 숫자 이름 값이 대응 함수 객체의 형식 매개변수 수보다 작은 정수 인덱스 데이터 프로퍼티는 초기에는 함수 실행 컨텍스트의 해당 인자 바인딩과 값을 공유한다. 즉 프로퍼티를 바꾸면 매개변수 바인딩 값도 바뀌며 그 반대도 같다. 이 대응 관계는 그러한 프로퍼티가 삭제 후 재정의되거나 접근자 프로퍼티로 바뀌면 끊어진다. arguments 객체가 일반 객체인 경우 그 프로퍼티 값은 단지 전달된 인자의 복사이며 동적 연결은 없다.</p>
      </emu-note>
      <emu-note>
        <p>ParameterMap 객체와 그 프로퍼티 값들은 arguments 객체와 인자 바인딩 간의 대응 관계를 명세하기 위한 장치이다. ParameterMap 객체와 그 프로퍼티 값 객체들은 ECMAScript 코드에서 직접 관측될 수 없다. 구현은 명세된 의미론을 위해 실제로 이러한 객체를 생성하거나 사용할 필요가 없다.</p>
      </emu-note>
      <emu-note>
        <p>일반 arguments 객체는 접근 시 *TypeError* 예외를 throw 하는 재정의 불가 accessor 프로퍼티 *"callee"* 를 정의한다. *"callee"* 프로퍼티는 non‑strict 함수 일부에 대해서만 생성되는 arguments 이그조틱 객체에서 더 구체적 의미를 가진다. 일반 변형에서의 정의는 적합한 구현이 다른 방식으로 정의하지 못하도록 하기 위함이다.</p>
      </emu-note>
      <emu-note>
        <p>역사적으로 arguments 이그조틱 객체 구현은 *"caller"* 라는 accessor 프로퍼티를 포함했다. ECMAScript 2017 이전 명세는 일반 arguments 객체에 throwing *"caller"* 프로퍼티 정의를 포함했다. 구현이 더 이상 이 확장을 포함하지 않으므로 ECMAScript 2017 은 throwing *"caller"* accessor 요구를 제거했다.</p>
      </emu-note>

      <emu-clause id="sec-arguments-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _desc_ 를 OrdinaryGetOwnProperty(_args_, _P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면 *undefined* 반환.
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _isMapped_ 가 *true* 이면
            1. _desc_.[[Value]] 를 ! Get(_map_, _P_) 로 설정.
          1. _desc_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _newArgDesc_ 를 _Desc_ 로 둔다.
          1. _isMapped_ 가 *true* 이고 IsDataDescriptor(_Desc_) 가 *true* 이면
            1. _Desc_ 가 [[Value]] 필드를 갖지 않고 [[Writable]] 필드를 가지며 그 값이 *false* 이면
              1. _newArgDesc_ 를 _Desc_ 복사본으로 둔다.
              1. _newArgDesc_.[[Value]] 를 ! Get(_map_, _P_) 로 설정.
          1. _allowed_ 를 ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_) 로 둔다.
          1. _allowed_ 가 *false* 이면 *false* 반환.
          1. _isMapped_ 가 *true* 이면
            1. IsAccessorDescriptor(_Desc_) 가 *true* 이면
              1. ! _map_.[[Delete]](_P_) 수행.
            1. Else
              1. _Desc_ 가 [[Value]] 필드를 가지면
                1. 단언: arguments 객체가 매핑한 형식 매개변수는 항상 writable 이므로 Set 성공.
                1. ! Set(_map_, _P_, _Desc_.[[Value]], *false*) 수행.
              1. _Desc_ 가 [[Writable]] 필드를 가지고 그 값이 *false* 이면
                1. ! _map_.[[Delete]](_P_) 수행.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _isMapped_ 가 *false* 이면
            1. ? OrdinaryGet(_args_, _P_, _Receiver_) 반환.
          1. Else
            1. 단언: _map_ 은 _P_ 에 대한 형식 매개변수 매핑을 포함.
            1. ! Get(_map_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. SameValue(_args_, _Receiver_) 가 *false* 이면
            1. _isMapped_ 를 *false* 로 둔다.
          1. Else
            1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
            1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _isMapped_ 가 *true* 이면
            1. 단언: 아래 Set 은 성공 (매핑된 형식 매개변수는 항상 writable).
            1. ! Set(_map_, _P_, _V_, *false*) 수행.
          1. ? OrdinarySet(_args_, _P_, _V_, _Receiver_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 이그조틱 객체 _args_</dd>
        </dl>
        <emu-alg>
          1. _map_ 을 _args_.[[ParameterMap]] 로 둔다.
          1. _isMapped_ 를 ! HasOwnProperty(_map_, _P_) 로 둔다.
          1. _result_ 를 ? OrdinaryDelete(_args_, _P_) 로 둔다.
          1. _result_ 가 *true* 이고 _isMapped_ 가 *true* 이면
            1. ! _map_.[[Delete]](_P_) 수행.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createunmappedargumentsobject" type="abstract operation">
        <h1>
          CreateUnmappedArgumentsObject (
            _argumentsList_: a List of ECMAScript language values,
          ): an ordinary object
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _len_ 을 _argumentsList_ 요소 개수로 둔다.
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] ») 로 둔다.
          1. _obj_.[[ParameterMap]] 을 *undefined* 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. _index_ 를 0 으로 둔다.
          1. _index_ < _len_ 인 동안 반복
            1. _val_ 를 _argumentsList_[_index_] 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_) 수행.
            1. _index_ 를 _index_ + 1 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. _obj_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createmappedargumentsobject" type="abstract operation">
        <h1>
          CreateMappedArgumentsObject (
            _func_: an Object,
            _formals_: a Parse Node,
            _argumentsList_: a List of ECMAScript language values,
            _env_: an Environment Record,
          ): an arguments exotic object
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 단언: _formals_ 는 rest 매개변수, 바인딩 패턴, 초기화자를 포함하지 않는다. 중복 식별자는 있을 수 있다.
          1. _len_ 을 _argumentsList_ 요소 개수로 둔다.
          1. _obj_ 를 MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] ») 로 둔다.
          1. _obj_.[[GetOwnProperty]] 를 <emu-xref href="#sec-arguments-exotic-objects-getownproperty-p"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-arguments-exotic-objects-defineownproperty-p-desc"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Get]] 를 <emu-xref href="#sec-arguments-exotic-objects-get-p-receiver"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Set]] 를 <emu-xref href="#sec-arguments-exotic-objects-set-p-v-receiver"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Delete]] 를 <emu-xref href="#sec-arguments-exotic-objects-delete-p"></emu-xref>에 지정된 대로 설정.
          1. _obj_.[[Prototype]] 을 %Object.prototype% 으로 설정.
          1. _map_ 을 OrdinaryObjectCreate(*null*) 로 둔다.
          1. _obj_.[[ParameterMap]] 을 _map_ 으로 설정.
          1. _parameterNames_ 를 _formals_ 의 BoundNames 로 둔다.
          1. _numberOfParameters_ 를 _parameterNames_ 요소 개수로 둔다.
          1. _index_ 를 0 으로 둔다.
          1. _index_ < _len_ 인 동안 반복
            1. _val_ 를 _argumentsList_[_index_] 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_) 수행.
            1. _index_ 를 _index_ + 1 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. _mappedNames_ 를 새 빈 List 로 둔다.
          1. _index_ 를 _numberOfParameters_ - 1 로 설정.
          1. _index_ ≥ 0 인 동안 반복
            1. _name_ 을 _parameterNames_[_index_] 로 둔다.
            1. _mappedNames_ 가 _name_ 을 포함하지 않으면
              1. _mappedNames_ 에 _name_ 추가.
              1. _index_ < _len_ 이면
                1. _g_ 를 MakeArgGetter(_name_, _env_) 로 둔다.
                1. _p_ 를 MakeArgSetter(_name_, _env_) 로 둔다.
                1. ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
            1. _index_ 를 _index_ - 1 로 설정.
          1. ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }) 수행.
          1. _obj_ 반환.
        </emu-alg>

        <emu-clause id="sec-makearggetter" type="abstract operation">
          <h1>
            MakeArgGetter (
              _name_: a String,
              _env_: an Environment Record,
            ): a function object
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>실행 시 _env_ 에서 _name_ 에 바인딩된 값을 반환하는 내장 함수 객체를 생성한다.</dd>
          </dl>
          <emu-alg>
            1. _getterClosure_ 를 매개변수 없고 _name_, _env_ 를 캡처하며 호출 시 다음 단계를 수행하는 새 Abstract Closure 로 둔다:
              1. NormalCompletion(! _env_.GetBindingValue(_name_, *false*)) 반환.
            1. _getter_ 를 CreateBuiltinFunction(_getterClosure_, 0, *""*, « ») 로 둔다.
            1. NOTE: _getter_ 는 ECMAScript 코드에서 직접 접근 불가.
            1. _getter_ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-makeargsetter" type="abstract operation">
          <h1>
            MakeArgSetter (
              _name_: a String,
              _env_: an Environment Record,
            ): a function object
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>실행 시 _env_ 에서 _name_ 에 바인딩된 값을 설정하는 내장 함수 객체를 생성한다.</dd>
          </dl>
          <emu-alg>
            1. _setterClosure_ 를 매개변수 (_value_) 를 가지며 _name_, _env_ 를 캡처하고 호출 시 다음을 수행하는 새 Abstract Closure 로 둔다:
              1. NormalCompletion(! _env_.SetMutableBinding(_name_, _value_, *false*)) 반환.
            1. _setter_ 를 CreateBuiltinFunction(_setterClosure_, 1, *""*, « ») 로 둔다.
            1. NOTE: _setter_ 는 ECMAScript 코드에서 직접 접근 불가.
            1. _setter_ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-exotic-objects" oldids="sec-integer-indexed-exotic-objects">
      <h1>TypedArray 이그조틱 객체(TypedArray Exotic Objects)</h1>
      <p>TypedArray 는 정규화 수치 문자열(canonical numeric string) 프로퍼티 키를 특별 처리하고 그 중 경계 내(in-bounds) 정수 인덱스를 균일 타입 요소에 매핑하며 나머지는 프로토타입 체인 탐색 없이 부재로 유지하는 이그조틱 객체이다.</p>
      <emu-note>
        <p>임의의 Number _n_ 에 대해 ToString(_n_)이 정규화 수치 문자열이므로, 구현은 실제 문자열 변환 없이 Number 를 TypedArray 프로퍼티 키로 다룰 수 있다.</p>
      </emu-note>
      <p>TypedArray 는 일반 객체와 동일한 내부 슬롯을 가지며 추가로 [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] 내부 슬롯을 가진다.</p>
      <p>객체의 [[PreventExtensions]], [[GetOwnProperty]], [[HasProperty]], [[DefineOwnProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]] 내부 메서드가 이 절의 정의를 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 정의를 사용하면 그 객체는 <dfn id="typedarray" oldids="integer-indexed-exotic-object" variants="TypedArrays">TypedArray</dfn> 이다. 이러한 메서드는 TypedArrayCreate 에 의해 설치된다.</p>

      <emu-clause id="sec-typedarray-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): Boolean 을 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. NOTE: <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref>에 규정된 확장성 관련 불변식은 _O_ 가 프로퍼티를 얻거나(또는 잃고 다시 얻을) 수 있는 경우 *true* 를 반환하지 못하게 한다; 이는 underlying buffer 가 resize 될 때 정수 인덱스 이름 프로퍼티에서 발생할 수 있다.
          1. IsTypedArrayFixedLength(_O_) 가 *false* 이면 *false* 반환.
          1. OrdinaryPreventExtensions(_O_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-getownproperty" oldids="sec-integer-indexed-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. _value_ 를 TypedArrayGetElement(_O_, _numericIndex_) 로 둔다.
              1. _value_ 가 *undefined* 이면 *undefined* 반환.
              1. PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* } 반환.
          1. OrdinaryGetOwnProperty(_O_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-hasproperty" oldids="sec-integer-indexed-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면 IsValidIntegerIndex(_O_, _numericIndex_) 반환.
          1. ? OrdinaryHasProperty(_O_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-defineownproperty" oldids="sec-integer-indexed-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. IsValidIntegerIndex(_O_, _numericIndex_) 가 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Configurable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Enumerable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
              1. IsAccessorDescriptor(_Desc_) 가 *true* 이면 *false* 반환.
              1. _Desc_ 에 [[Writable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
              1. _Desc_ 에 [[Value]] 필드가 있으면 ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]]) 수행.
              1. *true* 반환.
          1. ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-get" oldids="sec-integer-indexed-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. TypedArrayGetElement(_O_, _numericIndex_) 반환.
          1. ? OrdinaryGet(_O_, _P_, _Receiver_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-set" oldids="sec-integer-indexed-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. SameValue(_O_, _Receiver_) 가 *true* 이면
                1. ? TypedArraySetElement(_O_, _numericIndex_, _V_) 수행.
                1. *true* 반환.
              1. IsValidIntegerIndex(_O_, _numericIndex_) 가 *false* 이면 *true* 반환.
          1. ? OrdinarySet(_O_, _P_, _V_, _Receiver_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-delete" oldids="sec-integer-indexed-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 String 이면
            1. _numericIndex_ 를 CanonicalNumericIndexString(_P_) 로 둔다.
            1. _numericIndex_ 가 *undefined* 가 아니면
              1. IsValidIntegerIndex(_O_, _numericIndex_) 가 *false* 이면 *true* 반환; else *false* 반환.
          1. ! OrdinaryDelete(_O_, _P_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-ownpropertykeys" oldids="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. _taRecord_ 를 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~) 로 둔다.
          1. _keys_ 를 새 빈 List 로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *false* 이면
            1. _length_ 를 TypedArrayLength(_taRecord_) 로 둔다.
            1. 0 ≤ _i_ < _length_ 인 각 정수 _i_ 에 대해 오름차순으로
              1. ! ToString(𝔽(_i_)) 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 String 이고 정수 인덱스가 아닌 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _O_ 의 각 자체 프로퍼티 키 _P_ 중 _P_ 가 Symbol 인 것들을 생성 시점 시간 순으로
            1. _P_ 를 _keys_ 에 추가.
          1. _keys_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-with-buffer-witness-records" oldids="sec-integer-indexed-object-with-buffer-witness-records">
        <h1>버퍼 증인 레코드가 있는 TypedArray (TypedArray With Buffer Witness Records)</h1>
        <p><dfn variants="TypedArray With Buffer Witness Records">TypedArray With Buffer Witness Record</dfn> 는 TypedArray 와, 보기 버퍼(viewed buffer)의 캐시된 byte length 를 함께 캡슐화하는 Record 값이다. growable SharedArrayBuffer 를 보는 경우 byte length 데이터 블록에 대한 단일 공유 메모리 읽기 이벤트를 보장하는 데 사용된다.</p>
        <p>TypedArray With Buffer Witness Record 는 <emu-xref href="#table-typedarray-with-buffer-witness-record-fields"></emu-xref>에 나온 필드를 가진다.</p>
        <emu-table id="table-typedarray-with-buffer-witness-record-fields" oldids="table-integer-indexed-object-with-buffer-witness-record-fields" caption="TypedArray With Buffer Witness Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Object]]</td>
              <td>a TypedArray</td>
              <td>버퍼 byte length 가 로드된 TypedArray.</td>
            </tr>
            <tr>
              <td>[[CachedBufferByteLength]]</td>
              <td>a non-negative integer or ~detached~</td>
              <td>Record 생성 시 객체의 [[ViewedArrayBuffer]] byte length.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-maketypedarraywithbufferwitnessrecord" oldids="sec-makeintegerindexedobjectwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeTypedArrayWithBufferWitnessRecord (
            _obj_: a TypedArray,
            _order_: ~seq-cst~ or ~unordered~,
          ): a TypedArray With Buffer Witness Record
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _buffer_ 를 _obj_.[[ViewedArrayBuffer]] 로 둔다.
          1. IsDetachedBuffer(_buffer_) 가 *true* 이면
            1. _byteLength_ 를 ~detached~ 로 둔다.
          1. Else
            1. _byteLength_ 를 ArrayBufferByteLength(_buffer_, _order_) 로 둔다.
          1. TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ } 를 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraycreate" oldids="sec-integerindexedobjectcreate" type="abstract operation">
        <h1>
          TypedArrayCreate (
            _prototype_: an Object,
          ): a TypedArray
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 TypedArray 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _internalSlotsList_ 를 « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] » 로 둔다.
          1. _A_ 를 MakeBasicObject(_internalSlotsList_) 로 둔다.
          1. _A_.[[PreventExtensions]] 를 <emu-xref href="#sec-typedarray-preventextensions"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[GetOwnProperty]] 를 <emu-xref href="#sec-typedarray-getownproperty"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[HasProperty]] 를 <emu-xref href="#sec-typedarray-hasproperty"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[DefineOwnProperty]] 를 <emu-xref href="#sec-typedarray-defineownproperty"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Get]] 를 <emu-xref href="#sec-typedarray-get"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Set]] 를 <emu-xref href="#sec-typedarray-set"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Delete]] 를 <emu-xref href="#sec-typedarray-delete"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[OwnPropertyKeys]] 를 <emu-xref href="#sec-typedarray-ownpropertykeys"></emu-xref>에 지정된 대로 설정.
          1. _A_.[[Prototype]] 을 _prototype_ 으로 설정.
          1. _A_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraybytelength" oldids="sec-integerindexedobjectbytelength" type="abstract operation">
        <h1>
          TypedArrayByteLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *true* 이면 0 반환.
          1. _length_ 를 TypedArrayLength(_taRecord_) 로 둔다.
          1. _length_ = 0 이면 0 반환.
          1. _O_ 를 _taRecord_.[[Object]] 로 둔다.
          1. _O_.[[ByteLength]] 이 ~auto~ 가 아니면 _O_.[[ByteLength]] 반환.
          1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
          1. _length_ × _elementSize_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraylength" oldids="sec-integerindexedobjectlength" type="abstract operation">
        <h1>
          TypedArrayLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 단언: IsTypedArrayOutOfBounds(_taRecord_) 는 *false*.
          1. _O_ 를 _taRecord_.[[Object]] 로 둔다.
          1. _O_.[[ArrayLength]] 이 ~auto~ 가 아니면 _O_.[[ArrayLength]] 반환.
          1. 단언: IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) 는 *false*.
          1. _byteOffset_ 을 _O_.[[ByteOffset]] 로 둔다.
          1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
          1. _byteLength_ 를 _taRecord_.[[CachedBufferByteLength]] 로 둔다.
          1. 단언: _byteLength_ 는 ~detached~ 아님.
          1. floor((_byteLength_ - _byteOffset_) / _elementSize_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayoutofbounds" oldids="sec-isintegerindexedobjectoutofbounds" type="abstract operation">
        <h1>
          IsTypedArrayOutOfBounds (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>객체의 어떤 수치 프로퍼티라도 underlying buffer 범위를 벗어난 인덱스 값을 참조하는지 검사한다.</dd>
        </dl>
        <emu-alg>
          1. _O_ 를 _taRecord_.[[Object]] 로 둔다.
          1. _bufferByteLength_ 를 _taRecord_.[[CachedBufferByteLength]] 로 둔다.
          1. 단언: IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 는 _bufferByteLength_ 가 ~detached~ 일 때 그리고 그럴 때에만 *true*.
          1. _bufferByteLength_ 가 ~detached~ 이면 *true* 반환.
          1. _byteOffsetStart_ 를 _O_.[[ByteOffset]] 로 둔다.
          1. _O_.[[ArrayLength]] 이 ~auto~ 이면
            1. _byteOffsetEnd_ 를 _bufferByteLength_ 로 둔다.
          1. Else
            1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
            1. _byteOffsetEnd_ 를 _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_ 로 둔다.
          1. _byteOffsetStart_ > _bufferByteLength_ 또는 _byteOffsetEnd_ > _bufferByteLength_ 이면 *true* 반환.
          1. NOTE: 길이 0 TypedArray 는 out-of-bounds 로 간주되지 않는다.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayfixedlength" type="abstract operation">
        <h1>
          IsTypedArrayFixedLength (
            _O_: a TypedArray,
          ): a Boolean
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _O_.[[ArrayLength]] 이 ~auto~ 이면 *false* 반환.
          1. _buffer_ 를 _O_.[[ViewedArrayBuffer]] 로 둔다.
          1. IsFixedLengthArrayBuffer(_buffer_) 가 *false* 이고 IsSharedArrayBuffer(_buffer_) 가 *false* 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isvalidintegerindex" type="abstract operation">
        <h1>
          IsValidIntegerIndex (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Boolean
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 가 *true* 이면 *false* 반환.
          1. _index_ 가 정수 Number 가 아니면 *false* 반환.
          1. _index_ 가 *-0*<sub>𝔽</sub> 이거나 _index_ < *-0*<sub>𝔽</sub> 이면 *false* 반환.
          1. _taRecord_ 를 MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~) 로 둔다.
          1. NOTE: _O_ 의 버퍼가 growable SharedArrayBuffer 일 때 경계 검사(bound check)는 동기화 연산이 아니다.
          1. IsTypedArrayOutOfBounds(_taRecord_) 가 *true* 이면 *false* 반환.
          1. _length_ 를 TypedArrayLength(_taRecord_) 로 둔다.
          1. ℝ(_index_) ≥ _length_ 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraygetelement" oldids="sec-integerindexedelementget" type="abstract operation">
        <h1>
          TypedArrayGetElement (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Number, a BigInt, or *undefined*
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. IsValidIntegerIndex(_O_, _index_) 가 *false* 이면 *undefined* 반환.
          1. _offset_ 을 _O_.[[ByteOffset]] 로 둔다.
          1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
          1. _byteIndexInBuffer_ 를 (ℝ(_index_) × _elementSize_) + _offset_ 으로 둔다.
          1. _elementType_ 을 TypedArrayElementType(_O_) 로 둔다.
          1. GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraysetelement" oldids="sec-integerindexedelementset" type="abstract operation">
        <h1>
          TypedArraySetElement (
            _O_: a TypedArray,
            _index_: a Number,
            _value_: an ECMAScript language value,
          ): ~unused~ 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _O_.[[ContentType]] 가 ~bigint~ 이면 _numValue_ 를 ? ToBigInt(_value_) 로 둔다.
          1. 아니면 _numValue_ 를 ? ToNumber(_value_) 로 둔다.
          1. IsValidIntegerIndex(_O_, _index_) 가 *true* 이면
            1. _offset_ 을 _O_.[[ByteOffset]] 로 둔다.
            1. _elementSize_ 를 TypedArrayElementSize(_O_) 로 둔다.
            1. _byteIndexInBuffer_ 를 (ℝ(_index_) × _elementSize_) + _offset_ 으로 둔다.
            1. _elementType_ 을 TypedArrayElementType(_O_) 로 둔다.
            1. SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-note>
          <p>이 연산은 항상 성공하는 것처럼 보이나, TypedArray 끝을 넘어 쓰거나 분리(detached)된 ArrayBuffer 기반 TypedArray 에 쓰려 할 때는 효과가 없다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation">
        <h1>
          IsArrayBufferViewOutOfBounds (
            _O_: a TypedArray or a DataView,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>TypedArray 의 수치 프로퍼티 또는 DataView 메서드가 underlying data block 범위를 벗어난 인덱스 값을 참조할 수 있는지 검사한다. 상위(spec) 명세 편의를 위해 존재.</dd>
        </dl>
        <emu-alg>
          1. _O_ 가 [[DataView]] 내부 슬롯을 가지면
            1. _viewRecord_ 를 MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~) 로 둔다.
            1. IsViewOutOfBounds(_viewRecord_) 반환.
          1. _taRecord_ 를 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~) 로 둔다.
          1. IsTypedArrayOutOfBounds(_taRecord_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-module-namespace-exotic-objects">
      <h1>모듈 네임스페이스 이그조틱 객체(Module Namespace Exotic Objects)</h1>
      <p>모듈 네임스페이스 이그조틱 객체는 ECMAScript |Module|에서 export 된 바인딩을 노출하는 이그조틱 객체이다(<emu-xref href="#sec-exports"></emu-xref> 참조). 모듈 네임스페이스 이그조틱 객체의 String-keyed 자체 프로퍼티와 |Module| 이 export 한 바인딩 이름 사이엔 1:1 대응이 있다. export 된 바인딩에는 `export *` 로 간접 export 된 바인딩도 포함된다. 각 String 값인 자체 프로퍼티 키는 해당 export 바인딩 이름의 StringValue 이다. 이들이 모듈 네임스페이스 이그조틱 객체의 유일한 String-keyed 프로퍼티이다. 각 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* } 속성을 가진다. 모듈 네임스페이스 이그조틱 객체는 비확장(extensible 아님)이다.</p>
      <p>객체의 [[GetPrototypeOf]], [[SetPrototypeOf]], [[IsExtensible]], [[PreventExtensions]], [[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]], [[Set]], [[Delete]], [[OwnPropertyKeys]] 내부 메서드가 이 절의 정의를 사용하고 그 외 핵심 내부 메서드가 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 정의를 사용하면 그 객체는 <dfn id="module-namespace-exotic-object" variants="module namespace exotic objects">모듈 네임스페이스 이그조틱 객체</dfn>이다. 이러한 메서드는 ModuleNamespaceCreate 에 의해 설치된다.</p>
      <p>모듈 네임스페이스 이그조틱 객체는 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref>에 정의된 내부 슬롯을 가진다.</p>
      <emu-table id="table-internal-slots-of-module-namespace-exotic-objects" caption="모듈 네임스페이스 이그조틱 객체의 내부 슬롯(Internal Slots of Module Namespace Exotic Objects)" oldids="table-29">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[Module]]</td>
            <td>a Module Record</td>
            <td>이 네임스페이스가 export 를 노출하는 Module Record.</td>
          </tr>
          <tr>
            <td>[[Exports]]</td>
            <td>a List of Strings</td>
            <td>이 객체의 자체 프로퍼티로 노출되는 export 이름들의 String 값 요소를 가진 List. 코드 유닛 사전식 순서로 정렬됨.</td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-module-namespace-exotic-objects-getprototypeof" type="internal method">
        <h1>[[GetPrototypeOf]] ( ): *null* 을 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *null* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. ! SetImmutablePrototype(_O_, _V_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-isextensible" type="internal method">
        <h1>[[IsExtensible]] ( ): *false* 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): *true* 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): Property Descriptor 또는 *undefined* 를 담는 normal completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면 OrdinaryGetOwnProperty(_O_, _P_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하지 않으면 *undefined* 반환.
          1. _value_ 를 ? _O_.[[Get]](_P_, _O_) 로 둔다.
          1. PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* } 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면 ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_) 반환.
          1. _current_ 를 ? _O_.[[GetOwnProperty]](_P_) 로 둔다.
          1. _current_ 가 *undefined* 이면 *false* 반환.
          1. _Desc_ 에 [[Configurable]] 필드가 있고 그 값이 *true* 이면 *false* 반환.
          1. _Desc_ 에 [[Enumerable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
          1. IsAccessorDescriptor(_Desc_) 가 *true* 이면 *false* 반환.
          1. _Desc_ 에 [[Writable]] 필드가 있고 그 값이 *false* 이면 *false* 반환.
          1. _Desc_ 에 [[Value]] 필드가 있으면 SameValue(_Desc_.[[Value]], _current_.[[Value]]) 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면 ! OrdinaryHasProperty(_O_, _P_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면
            1. ! OrdinaryGet(_O_, _P_, _Receiver_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하지 않으면 *undefined* 반환.
          1. _m_ 을 _O_.[[Module]] 로 둔다.
          1. _binding_ 을 _m_.ResolveExport(_P_) 로 둔다.
          1. 단언: _binding_ 은 ResolvedBinding Record.
          1. _targetModule_ 을 _binding_.[[Module]] 로 둔다.
          1. 단언: _targetModule_ 은 *undefined* 가 아님.
          1. _binding_.[[BindingName]] 이 ~namespace~ 이면
            1. GetModuleNamespace(_targetModule_) 반환.
          1. _targetEnv_ 를 _targetModule_.[[Environment]] 로 둔다.
          1. _targetEnv_ 가 ~empty~ 이면 *ReferenceError* 예외 throw.
          1. ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*) 반환.
        </emu-alg>
        <emu-note>
          <p>ResolveExport 는 부작용이 없다. 특정 _exportName_, _resolveSet_ 인수 쌍으로 이 연산을 호출할 때마다 동일 결과를 반환해야 한다. 구현은 각 모듈 네임스페이스 이그조틱 객체의 [[Exports]] 에 대한 ResolveExport 결과를 미리 계산하거나 캐시할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): *false* 를 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체</dd>
        </dl>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): Boolean 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _P_ 가 Symbol 이면
            1. ! OrdinaryDelete(_O_, _P_) 반환.
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _exports_ 가 _P_ 를 포함하면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>모듈 네임스페이스 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. _exports_ 를 _O_.[[Exports]] 로 둔다.
          1. _symbolKeys_ 를 OrdinaryOwnPropertyKeys(_O_) 로 둔다.
          1. _exports_ 와 _symbolKeys_ 의 리스트 연결(list-concatenation) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulenamespacecreate" type="abstract operation">
        <h1>
          ModuleNamespaceCreate (
            _module_: a Module Record,
            _exports_: a List of Strings,
          ): a module namespace exotic object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>새 모듈 네임스페이스 이그조틱 객체 생성 명세에 사용된다.</dd>
        </dl>
        <emu-alg>
          1. 단언: _module_.[[Namespace]] 는 ~empty~.
          1. _internalSlotsList_ 를 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref>에 나열된 내부 슬롯으로 둔다.
          1. _M_ 을 MakeBasicObject(_internalSlotsList_) 로 둔다.
          1. _M_ 의 핵심 내부 메서드를 <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref>에 지정된 정의로 설정.
          1. _M_.[[Module]] 을 _module_ 로 설정.
          1. _sortedExports_ 를 _exports_ 요소를 코드 유닛 사전식 순서로 정렬한 List 로 둔다.
          1. _M_.[[Exports]] 를 _sortedExports_ 로 설정.
          1. <emu-xref href="#sec-module-namespace-objects"></emu-xref>에 정의된 대로 _M_ 의 자체 프로퍼티를 생성.
          1. _module_.[[Namespace]] 를 _M_ 으로 설정.
          1. _M_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-immutable-prototype-exotic-objects">
      <h1>불변 프로토타입 이그조틱 객체(Immutable Prototype Exotic Objects)</h1>
      <p>불변 프로토타입 이그조틱 객체는 초기화 이후 변경되지 않는 [[Prototype]] 내부 슬롯을 가진 이그조틱 객체이다.</p>

      <p>객체의 [[SetPrototypeOf]] 내부 메서드가 아래 구현을 사용한다면 그 객체는 <dfn id="immutable-prototype-exotic-object" variants="immutable prototype exotic objects">불변 프로토타입 이그조틱 객체</dfn>이다. (그 외 핵심 내부 메서드는 구체적 객체에 따라 임의 구현을 사용할 수 있다.)</p>

      <emu-note>
        <p>다른 이그조틱 객체와 달리 불변 프로토타입 이그조틱 객체를 위한 전용 생성 추상 연산은 제공되지 않는다. 이는 %Object.prototype% 및 호스트 환경에서만 사용되고, 호스트 환경에서는 관련 객체들이 다른 방식으로도 이그조틱일 수 있어 자체 전용 생성 연산이 필요하기 때문이다.</p>
      </emu-note>

      <emu-clause id="sec-immutable-prototype-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>불변 프로토타입 이그조틱 객체 _O_</dd>
        </dl>
        <emu-alg>
          1. ? SetImmutablePrototype(_O_, _V_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set-immutable-prototype" type="abstract operation">
        <h1>
          SetImmutablePrototype (
            _O_: an Object,
            _V_: an Object or *null*,
          ): Boolean 또는 throw completion 을 담는 normal completion
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. _current_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
          1. SameValue(_V_, _current_) 가 *true* 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
    <h1>Proxy 객체의 내부 메서드와 내부 슬롯(Proxy Object Internal Methods and Internal Slots)</h1>
    <p>Proxy 객체는 필수 내부 메서드가 ECMAScript 코드로 일부 구현된 이그조틱 객체이다. 모든 Proxy 객체는 [[ProxyHandler]] 라는 내부 슬롯을 가진다. [[ProxyHandler]] 의 값은 프록시의 <em>handler object</em> 라 불리는 객체이거나 *null* 이다. 핸들러 객체의 메서드들(<emu-xref href="#table-proxy-handler-methods"></emu-xref> 참조)은 하나 이상 Proxy 객체 내부 메서드 구현을 확장(augment)하는 데 사용될 수 있다. 모든 Proxy 객체는 또한 [[ProxyTarget]] 이라 불리는 내부 슬롯을 가지며 그 값은 객체 또는 *null* 이다. 이 객체를 프록시의 <em>target object</em> 라고 한다.</p>

    <p>객체의 (해당한다면 [[Call]] 및 [[Construct]] 포함) 필수 내부 메서드가 이 절의 정의를 사용한다면 그 객체는 <dfn id="proxy-exotic-object" variants="Proxy exotic objects">Proxy 이그조틱 객체</dfn>이다. 이러한 내부 메서드는 ProxyCreate 에서 설치된다.</p>

    <emu-table id="table-proxy-handler-methods" caption="Proxy Handler Methods" oldids="table-30">
      <table>
        <thead>
          <tr>
            <th>
              Internal Method
            </th>
            <th>
              Handler Method
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[GetPrototypeOf]]
          </td>
          <td>
            `getPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[SetPrototypeOf]]
          </td>
          <td>
            `setPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[IsExtensible]]
          </td>
          <td>
            `isExtensible`
          </td>
        </tr>
        <tr>
          <td>
            [[PreventExtensions]]
          </td>
          <td>
            `preventExtensions`
          </td>
        </tr>
        <tr>
          <td>
            [[GetOwnProperty]]
          </td>
          <td>
            `getOwnPropertyDescriptor`
          </td>
        </tr>
        <tr>
          <td>
            [[DefineOwnProperty]]
          </td>
          <td>
            `defineProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[HasProperty]]
          </td>
          <td>
            `has`
          </td>
        </tr>
        <tr>
          <td>
            [[Get]]
          </td>
          <td>
            `get`
          </td>
        </tr>
        <tr>
          <td>
            [[Set]]
          </td>
          <td>
            `set`
          </td>
        </tr>
        <tr>
          <td>
            [[Delete]]
          </td>
          <td>
            `deleteProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[OwnPropertyKeys]]
          </td>
          <td>
            `ownKeys`
          </td>
        </tr>
        <tr>
          <td>
            [[Call]]
          </td>
          <td>
            `apply`
          </td>
        </tr>
        <tr>
          <td>
            [[Construct]]
          </td>
          <td>
            `construct`
          </td>
        </tr>
      </table>
    </emu-table>
    <p>프록시 객체 내부 메서드 구현을 제공하기 위해 핸들러 메서드가 호출될 때 핸들러 메서드에는 프록시의 target 객체가 매개변수로 전달된다. 프록시의 핸들러 객체가 모든 필수 내부 메서드에 대응하는 메서드를 반드시 가질 필요는 없다. 프록시에서 내부 메서드를 호출했을 때 핸들러 객체가 해당 내부 트랩에 대응하는 메서드를 가지지 않으면 프록시 target 객체의 대응 내부 메서드가 호출된다.</p>
    <p>Proxy 객체의 [[ProxyHandler]] 와 [[ProxyTarget]] 내부 슬롯은 객체 생성 시 항상 초기화되며 일반적으로 수정될 수 없다. 일부 Proxy 객체는 이후 <em>revoked</em> 될 수 있는 방식으로 생성된다. 프록시가 철회(revoke)되면 그 [[ProxyHandler]] 및 [[ProxyTarget]] 내부 슬롯이 *null* 로 설정되어 이후 그 Proxy 객체의 내부 메서드 호출은 *TypeError* 예외를 던진다.</p>
    <p>Proxy 객체는 내부 메서드 구현을 임의의 ECMAScript 코드로 제공할 수 있게 하므로, <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 에 정의된 불변식을 위반하는 핸들러 메서드를 가진 Proxy 객체를 정의할 가능성이 있다. <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 에 정의된 내부 메서드 불변식 중 일부는 필수 무결성 불변식이며, 이들은 이 절에 명시된 Proxy 객체 내부 메서드에 의해 명시적으로 강제된다. ECMAScript 구현은 모든 가능한 불변식 위반 존재 시에도 견고해야 한다.</p>
    <p>이하 알고리즘 설명에서 _O_ 는 ECMAScript Proxy 객체, _P_ 는 프로퍼티 키 값, _V_ 는 임의의 ECMAScript 언어 값, _Desc_ 는 Property Descriptor 레코드라고 가정한다.</p>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): Object 또는 *null* 을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 를 수행한다.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"getPrototypeOf"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() 를 반환한다.
        1. _handlerProto_ 를 ? Call(_trap_, _handler_, « _target_ ») 로 둔다.
        1. _handlerProto_ 가 Object 도 아니고 *null* 도 아니면 *TypeError* 예외 throw.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _extensibleTarget_ 이 *true* 이면 _handlerProto_ 반환.
        1. _targetProto_ 를 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
        1. SameValue(_handlerProto_, _targetProto_) 가 *false* 이면 *TypeError* 예외 throw.
        1. _handlerProto_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[GetPrototypeOf]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[GetPrototypeOf]] 결과는 Object 또는 *null* 이어야 한다.</li>
          <li>target 객체가 비확장(non-extensible) 이면 Proxy 객체에 적용한 [[GetPrototypeOf]] 는 target 객체에 적용한 [[GetPrototypeOf]] 와 동일 값을 반환해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"setPrototypeOf"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_V_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _extensibleTarget_ 이 *true* 이면 *true* 반환.
        1. _targetProto_ 를 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>() 로 둔다.
        1. SameValue(_V_, _targetProto_) 가 *false* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[SetPrototypeOf]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[SetPrototypeOf]] 의 결과는 Boolean 값이다.</li>
          <li>target 객체가 비확장이라면 인수 값은 target 객체에 적용한 [[GetPrototypeOf]] 결과와 동일해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): Boolean 을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"isExtensible"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? IsExtensible(_target_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_ »)) 로 둔다.
        1. _targetResult_ 를 ? IsExtensible(_target_) 로 둔다.
        1. _booleanTrapResult_ 가 _targetResult_ 와 다르면 *TypeError* 예외 throw.
        1. _booleanTrapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[IsExtensible]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[IsExtensible]] 결과는 Boolean 값이다.</li>
          <li>Proxy 객체에 적용한 [[IsExtensible]] 결과는 동일 인수로 target 객체에 적용한 [[IsExtensible]] 결과와 동일해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): Boolean 을 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"preventExtensions"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta> 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *true* 이면
          1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
          1. _extensibleTarget_ 이 *true* 이면 *TypeError* 예외 throw.
        1. _booleanTrapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[PreventExtensions]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[PreventExtensions]] 결과는 Boolean 값이다.</li>
          <li>Proxy 객체에 적용한 [[PreventExtensions]] 가 *true* 를 반환하는 경우는 target 객체에 적용한 [[IsExtensible]] 가 *false* 일 때뿐이다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): Property Descriptor 또는 *undefined* 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"getOwnPropertyDescriptor"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 반환.
        1. _trapResultObj_ 를 ? Call(_trap_, _handler_, « _target_, _P_ ») 로 둔다.
        1. _trapResultObj_ 가 Object 도 아니고 *undefined* 도 아니면 *TypeError* 예외 throw.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _trapResultObj_ 가 *undefined* 이면
          1. _targetDesc_ 가 *undefined* 이면 *undefined* 반환.
          1. _targetDesc_.[[Configurable]] 이 *false* 이면 *TypeError* 예외 throw.
          1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
          1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
          1. *undefined* 반환.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _resultDesc_ 를 ? ToPropertyDescriptor(_trapResultObj_) 로 둔다.
        1. CompletePropertyDescriptor(_resultDesc_) 수행.
        1. _valid_ 를 IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_) 로 둔다.
        1. _valid_ 가 *false* 이면 *TypeError* 예외 throw.
        1. _resultDesc_.[[Configurable]] 이 *false* 이면
          1. _targetDesc_ 가 *undefined* 이거나 _targetDesc_.[[Configurable]] 이 *true* 이면
            1. *TypeError* 예외 throw.
          1. _resultDesc_ 에 [[Writable]] 필드가 있고 _resultDesc_.[[Writable]] 이 *false* 이면
            1. 단언: _targetDesc_ 는 [[Writable]] 필드를 가진다.
            1. _targetDesc_.[[Writable]] 이 *true* 이면 *TypeError* 예외 throw.
        1. _resultDesc_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[GetOwnProperty]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[GetOwnProperty]] 결과는 Object 또는 *undefined* 여야 한다.</li>
          <li>target 객체에 비구성 가능(non-configurable) 자체 프로퍼티로 존재하면 그 프로퍼티를 비존재로 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 자체 프로퍼티로 존재하면 비존재로 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 target 에 자체 프로퍼티로 존재하지 않으면 존재한다고 보고할 수 없다.</li>
          <li>target 객체에 대응 비구성 가능 자체 프로퍼티가 없으면 프로퍼티를 비구성 가능으로 보고할 수 없다.</li>
          <li>target 객체에 대응 비구성 가능·비쓰기(non-writable) 자체 프로퍼티가 없으면 프로퍼티를 동시에 비구성 가능 & 비쓰기라고 보고할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"defineProperty"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_) 반환.
        1. _descObj_ 를 FromPropertyDescriptor(_Desc_) 로 둔다.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _Desc_ 에 [[Configurable]] 필드가 있고 _Desc_.[[Configurable]] 이 *false* 이면
          1. _settingConfigFalse_ 를 *true* 로 둔다.
        1. Else
          1. _settingConfigFalse_ 를 *false* 로 둔다.
        1. _targetDesc_ 가 *undefined* 이면
          1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
          1. _settingConfigFalse_ 가 *true* 이면 *TypeError* 예외 throw.
        1. Else
          1. IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) 가 *false* 이면 *TypeError* 예외 throw.
          1. _settingConfigFalse_ 가 *true* 이고 _targetDesc_.[[Configurable]] 이 *true* 이면 *TypeError* 예외 throw.
          1. IsDataDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Configurable]] 이 *false* 이며 _targetDesc_.[[Writable]] 이 *true* 이면
            1. _Desc_ 에 [[Writable]] 필드가 있고 _Desc_.[[Writable]] 이 *false* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[DefineOwnProperty]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[DefineOwnProperty]] 결과는 Boolean 값이다.</li>
          <li>target 객체가 비확장이라면 프로퍼티를 추가할 수 없다.</li>
          <li>target 객체에 대응 비구성 가능 자체 프로퍼티가 없으면 프로퍼티를 비구성 가능으로 만들 수 없다.</li>
          <li>대응 비구성 가능·비쓰기 자체 프로퍼티가 없으면 비구성 가능 프로퍼티를 비쓰기 상태로 만들 수 없다.</li>
          <li>프로퍼티에 대응하는 target 프로퍼티가 존재한다면 그 프로퍼티의 Descriptor 를 target 에 [[DefineOwnProperty]] 로 적용해도 예외가 발생하지 않아야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"has"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_P_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면
          1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _targetDesc_ 가 *undefined* 가 아니면
            1. _targetDesc_.[[Configurable]] 이 *false* 이면 *TypeError* 예외 throw.
            1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
            1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
        1. _booleanTrapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[HasProperty]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[HasProperty]] 결과는 Boolean 값이다.</li>
          <li>target 객체에 비구성 가능 자체 프로퍼티로 존재하면 비존재로 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 자체 프로퍼티로 존재하면 비존재로 보고할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"get"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_P_, _Receiver_) 반환.
        1. _trapResult_ 를 ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ ») 로 둔다.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _targetDesc_ 가 *undefined* 가 아니고 _targetDesc_.[[Configurable]] 이 *false* 이면
          1. IsDataDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Writable]] 이 *false* 이면
            1. SameValue(_trapResult_, _targetDesc_.[[Value]]) 가 *false* 이면 *TypeError* 예외 throw.
          1. IsAccessorDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Get]] 이 *undefined* 이면
            1. _trapResult_ 가 *undefined* 가 아니면 *TypeError* 예외 throw.
        1. _trapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[Get]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>target 객체 프로퍼티가 비쓰기·비구성 가능 자체 데이터 프로퍼티라면 보고되는 값은 target 프로퍼티 값과 동일해야 한다.</li>
          <li>target 객체 프로퍼티가 [[Get]] 이 *undefined* 인 비구성 가능 자체 접근자 프로퍼티라면 보고되는 값은 *undefined* 이어야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"set"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _targetDesc_ 가 *undefined* 가 아니고 _targetDesc_.[[Configurable]] 이 *false* 이면
          1. IsDataDescriptor(_targetDesc_) 가 *true* 이고 _targetDesc_.[[Writable]] 이 *false* 이면
            1. SameValue(_V_, _targetDesc_.[[Value]]) 가 *false* 이면 *TypeError* 예외 throw.
          1. IsAccessorDescriptor(_targetDesc_) 가 *true* 이면
            1. _targetDesc_.[[Set]] 이 *undefined* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[Set]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[Set]] 결과는 Boolean 값이다.</li>
          <li>대응 target 프로퍼티가 비쓰기·비구성 가능 자체 데이터 프로퍼티라면 그 값을 다른 값으로 바꿀 수 없다.</li>
          <li>대응 target 프로퍼티가 [[Set]] 이 *undefined* 인 비구성 가능 자체 접근자 프로퍼티라면 값을 설정할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): Boolean 을 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"deleteProperty"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_P_) 반환.
        1. _booleanTrapResult_ 를 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)) 로 둔다.
        1. _booleanTrapResult_ 가 *false* 이면 *false* 반환.
        1. _targetDesc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
        1. _targetDesc_ 가 *undefined* 이면 *true* 반환.
        1. _targetDesc_.[[Configurable]] 이 *false* 이면 *TypeError* 예외 throw.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _extensibleTarget_ 이 *false* 이면 *TypeError* 예외 throw.
        1. *true* 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[Delete]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[Delete]] 결과는 Boolean 값이다.</li>
          <li>target 객체에 비구성 가능 자체 프로퍼티로 존재하면 삭제되었다고 보고할 수 없다.</li>
          <li>target 객체가 비확장이고 해당 프로퍼티가 자체 프로퍼티로 존재하면 삭제되었다고 보고할 수 없다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 프로퍼티 키 List 를 담는 normal completion 또는 throw completion</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"ownKeys"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> 반환.
        1. _trapResultArray_ 를 ? Call(_trap_, _handler_, « _target_ ») 로 둔다.
        1. _trapResult_ 를 ? CreateListFromArrayLike(_trapResultArray_, ~property-key~) 로 둔다.
        1. _trapResult_ 가 중복 항목을 포함하면 *TypeError* 예외 throw.
        1. _extensibleTarget_ 을 ? IsExtensible(_target_) 로 둔다.
        1. _targetKeys_ 를 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
        1. 단언: _targetKeys_ 는 프로퍼티 키들의 List.
        1. 단언: _targetKeys_ 는 중복 항목이 없다.
        1. _targetConfigurableKeys_ 를 새 빈 List 로 둔다.
        1. _targetNonconfigurableKeys_ 를 새 빈 List 로 둔다.
        1. _targetKeys_ 의 각 요소 _key_ 에 대해
          1. _desc_ 를 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
          1. _desc_ 가 *undefined* 가 아니고 _desc_.[[Configurable]] 이 *false* 이면
            1. _targetNonconfigurableKeys_ 에 _key_ 추가.
          1. Else
            1. _targetConfigurableKeys_ 에 _key_ 추가.
        1. _extensibleTarget_ 이 *true* 이고 _targetNonconfigurableKeys_ 가 비어 있으면
          1. _trapResult_ 반환.
        1. _uncheckedResultKeys_ 를 _trapResult_ 요소들로 구성된 List 로 둔다.
        1. _targetNonconfigurableKeys_ 의 각 _key_ 에 대해
          1. _uncheckedResultKeys_ 가 _key_ 를 포함하지 않으면 *TypeError* 예외 throw.
          1. _uncheckedResultKeys_ 에서 _key_ 제거.
        1. _extensibleTarget_ 이 *true* 이면 _trapResult_ 반환.
        1. _targetConfigurableKeys_ 의 각 _key_ 에 대해
          1. _uncheckedResultKeys_ 가 _key_ 를 포함하지 않으면 *TypeError* 예외 throw.
          1. _uncheckedResultKeys_ 에서 _key_ 제거.
        1. _uncheckedResultKeys_ 가 비어 있지 않으면 *TypeError* 예외 throw.
        1. _trapResult_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 객체의 [[OwnPropertyKeys]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[OwnPropertyKeys]] 결과는 List 이다.</li>
          <li>반환된 List 에는 중복 항목이 없다.</li>
          <li>반환 List 의 각 요소는 프로퍼티 키이다.</li>
          <li>결과 List 는 target 객체의 모든 비구성 가능 자체 프로퍼티의 키를 포함해야 한다.</li>
          <li>target 객체가 비확장이라면 결과 List 는 target 객체 자체 프로퍼티의 모든 키만 포함해야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): ECMAScript 언어 값 또는 throw completion 을 담는 normal completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"apply"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? Call(_target_, _thisArgument_, _argumentsList_) 반환.
        1. _argArray_ 를 CreateArrayFromList(_argumentsList_) 로 둔다.
        1. ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ ») 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 이그조틱 객체는 [[ProxyTarget]] 내부 슬롯 초기 값이 [[Call]] 내부 메서드를 가진 객체인 경우에만 [[Call]] 내부 메서드를 가진다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): Object 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Proxy exotic object _O_</dd>
      </dl>
      <emu-alg>
        1. ? ValidateNonRevokedProxy(_O_) 수행.
        1. _target_ 을 _O_.[[ProxyTarget]] 로 둔다.
        1. 단언: IsConstructor(_target_) 는 *true*.
        1. _handler_ 를 _O_.[[ProxyHandler]] 로 둔다.
        1. 단언: _handler_ 는 Object.
        1. _trap_ 을 ? GetMethod(_handler_, *"construct"*) 로 둔다.
        1. _trap_ 이 *undefined* 이면
          1. ? Construct(_target_, _argumentsList_, _newTarget_) 반환.
        1. _argArray_ 를 CreateArrayFromList(_argumentsList_) 로 둔다.
        1. _newObj_ 를 ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ ») 로 둔다.
        1. _newObj_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. _newObj_ 반환.
      </emu-alg>
      <emu-note>
        <p>Proxy 이그조틱 객체는 [[ProxyTarget]] 내부 슬롯 초기 값이 [[Construct]] 내부 메서드를 가진 객체인 경우에만 [[Construct]] 내부 메서드를 가진다.</p>
      </emu-note>
      <emu-note>
        <p>Proxy 객체의 [[Construct]] 는 다음 불변식을 강제한다:</p>
        <ul>
          <li>[[Construct]] 결과는 Object 이어야 한다.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-validatenonrevokedproxy" type="abstract operation">
      <h1>
        ValidateNonRevokedProxy (
          _proxy_: a Proxy exotic object,
        ): ~unused~ 를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_proxy_ 가 revoke 되었다면 *TypeError* 예외를 던진다.</dd>
      </dl>
      <emu-alg>
        1. _proxy_.[[ProxyTarget]] 이 *null* 이면 *TypeError* 예외 throw.
        1. 단언: _proxy_.[[ProxyHandler]] 는 *null* 이 아님.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-proxycreate" type="abstract operation">
      <h1>
        ProxyCreate (
          _target_: an ECMAScript language value,
          _handler_: an ECMAScript language value,
        ): Proxy 이그조틱 객체를 담는 normal completion 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>새 Proxy 객체 생성 과정을 명세하는 데 사용된다.</dd>
      </dl>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외 throw.
        1. _handler_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. _P_ 를 MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] ») 로 둔다.
        1. _P_ 의 핵심 내부 메서드( [[Call]], [[Construct]] 제외)를 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots"></emu-xref> 에 지정된 정의로 설정.
        1. IsCallable(_target_) 이 *true* 이면
          1. _P_.[[Call]] 을 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist"></emu-xref> 에서 지정된 대로 설정.
          1. IsConstructor(_target_) 이 *true* 이면
            1. _P_.[[Construct]] 를 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget"></emu-xref> 에서 지정된 대로 설정.
        1. _P_.[[ProxyTarget]] 을 _target_ 으로 설정.
        1. _P_.[[ProxyHandler]] 를 _handler_ 로 설정.
        1. _P_ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-source-code">
  <h1>ECMAScript 언어: 소스 텍스트(ECMAScript Language: Source Text)</h1>

  <emu-clause id="sec-source-text">
    <h1>소스 텍스트(Source Text)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SourceCharacter ::
        &gt; any Unicode code point
    </emu-grammar>
    <p><dfn>ECMAScript source text</dfn>는 유니코드 코드 포인트들의 시퀀스이다. ECMAScript 문법이 허용하는 위치에서는 U+0000 부터 U+10FFFF 까지의 모든 유니코드 코드 포인트 값(서러게이트 코드 포인트 포함)이 ECMAScript 소스 텍스트에 나타날 수 있다. ECMAScript 소스 텍스트를 저장·교환하는 실제 인코딩은 이 명세와 무관하다. 외부 소스 텍스트 인코딩이 무엇이든, 적합한 ECMAScript 구현은 소스 텍스트를 동등한 |SourceCharacter| 값들의 시퀀스로 처리하며, 각 |SourceCharacter| 는 하나의 유니코드 코드 포인트이다. 적합한 ECMAScript 구현은 소스 텍스트에 대해 어떤 정규화(normalization)를 수행할 필요도 없으며 정규화를 수행하는 것처럼 동작할 필요도 없다.</p>
    <p>결합 문자 시퀀스(combining character sequence)의 구성 요소들은 사용자가 전체를 단일 문자로 생각할지라도 개별 유니코드 코드 포인트로 취급된다.</p>
    <emu-note>
      <p>문자열 리터럴, 정규 표현식 리터럴, 템플릿 리터럴 및 식별자에서 모든 유니코드 코드 포인트는 해당 코드 포인트의 수치 값을 명시적으로 표현하는 유니코드 이스케이프 시퀀스로도 표현할 수 있다. 주석 안에서는 그러한 이스케이프 시퀀스는 주석 일부로서 사실상 무시된다.</p>
      <p>ECMAScript 는 유니코드 이스케이프 시퀀스 동작에서 Java 프로그래밍 언어와 다르다. 예를 들어 Java 프로그램에서 유니코드 이스케이프 시퀀스 `\\u000A` 가 단일 행 주석 내에 나타나면 그것은 행 종결자(유니코드 코드 포인트 U+000A 는 LINE FEED (LF))로 해석되어 다음 코드 포인트는 더 이상 주석의 일부가 아니다. 마찬가지로 Java 프로그램의 문자열 리터럴에 `\\u000A` 가 나타나면 그것 역시 행 종결자로 해석되며 문자열 리터럴 내부에는 허용되지 않는다—문자열 값에 LINE FEED (LF)를 포함하려면 `\\u000A` 대신 `\\n` 을 써야 한다. ECMAScript 프로그램에서는 주석 내부에 나타나는 유니코드 이스케이프 시퀀스가 절대 해석되지 않으며 따라서 주석 종료에 기여할 수 없다. 유사하게 ECMAScript 프로그램의 문자열 리터럴 내부에 나타나는 유니코드 이스케이프 시퀀스는 항상 리터럴의 일부로 기여하고 결코 행 종결자나 문자열 리터럴을 종료시킬 수 있는 코드 포인트로 해석되지 않는다.</p>
    </emu-note>

    <emu-clause id="sec-utf16encodecodepoint" type="abstract operation" oldids="sec-utf16encoding,sec-codepointtoutf16codeunits">
      <h1>
        정적 의미론(Static Semantics): UTF16EncodeCodePoint (
        _cp_: a Unicode code point,
        ): a String
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 단언: 0 ≤ _cp_ ≤ 0x10FFFF.
        1. _cp_ ≤ 0xFFFF 이면, 수치 값이 _cp_ 인 코드 유닛으로 구성된 String 값을 반환한다.
        1. _cu1_ 를 수치 값이 floor((_cp_ - 0x10000) / 0x400) + 0xD800 인 코드 유닛으로 둔다.
        1. _cu2_ 를 수치 값이 ((_cp_ - 0x10000) modulo 0x400) + 0xDC00 인 코드 유닛으로 둔다.
        1. _cu1_ 과 _cu2_ 의 문자열 연결(string-concatenation)을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointstostring" type="abstract operation" oldids="sec-utf16encode">
      <h1>
        정적 의미론(Static Semantics): CodePointsToString (
        _text_: a sequence of Unicode code points,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>이는 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 설명된 대로 _text_ 를 String 값으로 변환한다.</dd>
      </dl>
      <emu-alg>
        1. _result_ 를 빈 문자열로 둔다.
        1. _text_ 의 각 코드 포인트 _cp_ 에 대해
          1. _result_ 를 _result_ 와 UTF16EncodeCodePoint(_cp_) 의 문자열 연결로 설정한다.
        1. _result_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-utf16decodesurrogatepair" type="abstract operation" oldids="sec-utf16decode,utf16decodesurrogatepair">
      <h1>
        정적 의미론(Static Semantics): UTF16SurrogatePairToCodePoint (
        _lead_: a code unit,
        _trail_: a code unit,
        ): a code point
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>UTF-16 서로게이트 쌍을 이루는 두 코드 유닛을 코드 포인트로 변환한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _lead_ 는 선행 서로게이트이고 _trail_ 은 후행 서로게이트이다.
        1. _cp_ 를 (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000 으로 둔다.
        1. 코드 포인트 _cp_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointat" type="abstract operation">
      <h1>
        정적 의미론(Static Semantics): CodePointAt (
        _string_: a String,
        _position_: a non-negative integer,
        ): a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd><emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 설명된 대로 _string_ 을 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하고, 인덱스 _position_ 에 있는 코드 유닛에서 시작하는 단일 코드 포인트를 읽는다.</dd>
      </dl>
      <emu-alg>
        1. _size_ 를 _string_ 길이로 둔다.
        1. 단언: _position_ ≥ 0 그리고 _position_ &lt; _size_.
        1. _first_ 를 _string_ 내 인덱스 _position_ 의 코드 유닛으로 둔다.
        1. _cp_ 를 수치 값이 _first_ 의 수치 값인 코드 포인트로 둔다.
        1. _first_ 가 선행 서로게이트도 후행 서로게이트도 아니면
          1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* } 를 반환한다.
        1. _first_ 가 후행 서로게이트이거나 _position_ + 1 = _size_ 이면
          1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* } 를 반환한다.
        1. _second_ 를 _string_ 내 인덱스 _position_ + 1 의 코드 유닛으로 둔다.
        1. _second_ 가 후행 서로게이트가 아니면
          1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* } 를 반환한다.
        1. _cp_ 를 UTF16SurrogatePairToCodePoint(_first_, _second_) 로 설정한다.
        1. Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* } 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-stringtocodepoints" type="abstract operation" oldids="sec-utf16decodestring">
      <h1>
        정적 의미론(Static Semantics): StringToCodePoints (
        _string_: a String,
        ): a List of code points
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd><emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 설명된 대로 _string_ 을 UTF-16 인코딩된 유니코드 텍스트로 해석하여 얻어지는 유니코드 코드 포인트 시퀀스를 반환한다.</dd>
      </dl>
      <emu-alg>
        1. _codePoints_ 를 새 빈 List 로 둔다.
        1. _size_ 를 _string_ 길이로 둔다.
        1. _position_ 을 0 으로 둔다.
        1. _position_ &lt; _size_ 인 동안 반복,
          1. _cp_ 를 CodePointAt(_string_, _position_) 로 둔다.
          1. _cp_.[[CodePoint]] 를 _codePoints_ 에 추가한다.
          1. _position_ 을 _position_ + _cp_.[[CodeUnitCount]] 로 설정한다.
        1. _codePoints_ 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parsetext" type="abstract operation">
      <h1>
        정적 의미론(Static Semantics): ParseText (
        _sourceText_: a String or a sequence of Unicode code points,
        _goalSymbol_: a nonterminal in one of the ECMAScript grammars,
        ): a Parse Node or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _sourceText_ 가 String 이면 _sourceText_ 를 StringToCodePoints(_sourceText_) 로 설정한다.
        1. _goalSymbol_ 을 목표 심볼(goal symbol)로 사용하여 _sourceText_ 를 파싱하고, 파싱 결과를 조기 오류(early error) 조건이 있는지 분석한다. 파싱과 조기 오류 검출은 구현 정의 방식으로 상호 교차(interleaved)될 수 있다.
        1. 파싱이 성공했고 조기 오류가 발견되지 않았다면, 파싱에서 생성된 파스 트리의 루트에 있는 Parse Node ( _goalSymbol_ 의 인스턴스) 를 반환한다.
        1. 그렇지 않으면, 파싱 오류 및/또는 조기 오류를 나타내는 하나 이상의 *SyntaxError* 객체들의 List 를 반환한다. 둘 이상의 파싱 오류 또는 조기 오류가 있을 경우, 리스트 내 오류 객체의 수와 순서는 구현 정의이지만 최소 하나는 있어야 한다.
      </emu-alg>
      <emu-note>
        <p>특정 지점에 조기 오류가 있고 이후 지점에 구문 오류가 있는 텍스트를 생각해보자. 파싱 후 조기 오류 패스를 수행하는 구현은 구문 오류를 보고하고 조기 오류 패스로 진행하지 않을 수 있다. 두 활동을 교차 수행하는 구현은 조기 오류를 보고하고 구문 오류 탐지를 진행하지 않을 수 있다. 세 번째 구현은 두 오류를 모두 보고할 수 있다. 이 모든 동작은 적합하다.</p>
      </emu-note>
      <emu-note>
        <p><emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 절도 참조.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-types-of-source-code">
    <h1>소스 코드의 유형(Types of Source Code)</h1>
    <p>ECMAScript 코드는 네 가지 유형이 있다:</p>
    <ul>
      <li>
        <dfn>Global code</dfn> 는 ECMAScript |Script| 로 취급되는 소스 텍스트이다. 특정 |Script| 의 global code 는 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| 의 일부로 파싱되는 어떤 소스 텍스트도 포함하지 않는다.
      </li>
      <li>
        <dfn>Eval code</dfn> 는 내장 `eval` 함수에 제공되는 소스 텍스트이다. 더 정확히 말해 내장 `eval` 함수의 매개변수가 String 이면 ECMAScript |Script| 로 취급된다. 특정 `eval` 호출에 대한 eval code 는 그 |Script| 의 global code 부분이다.
      </li>
      <li>
        <p><dfn>Function code</dfn> 는 ECMAScript 함수 객체의 [[ECMAScriptCode]] 및 [[FormalParameters]] 내부 슬롯 값( <emu-xref href="#sec-ecmascript-function-objects"></emu-xref> 참조 )을 제공하기 위해 파싱되는 소스 텍스트이다. 특정 ECMAScript 함수의 function code 는 중첩된 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| 의 function code 로 파싱되는 어떤 소스 텍스트도 포함하지 않는다.</p>
        <p>추가로, 위에서 언급한 소스 텍스트가 다음으로 파싱되는 경우:</p>
        <ul>
          <li>|FunctionDeclaration| 또는 |FunctionExpression| 의 |FormalParameters| 및 |FunctionBody|,</li>
          <li>|GeneratorDeclaration| 또는 |GeneratorExpression| 의 |FormalParameters| 및 |GeneratorBody|,</li>
          <li>|AsyncFunctionDeclaration| 또는 |AsyncFunctionExpression| 의 |FormalParameters| 및 |AsyncFunctionBody|, 또는</li>
          <li>|AsyncGeneratorDeclaration| 또는 |AsyncGeneratorExpression| 의 |FormalParameters| 및 |AsyncGeneratorBody|,</li>
        </ul>
        <p>그 선언 또는 표현식의 |BindingIdentifier| (있다면) 에 매치되는 소스 텍스트 역시 해당 함수의 function code 에 포함된다.</p>
      </li>
      <li>
        <dfn>Module code</dfn> 는 |ModuleBody| 로 제공되는 소스 텍스트이다. 이는 모듈이 초기화될 때 직접 평가되는 코드이다. 특정 모듈의 module code 는 중첩된 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction|, |ClassDeclaration|, |ClassExpression| 의 일부로 파싱되는 어떤 소스 텍스트도 포함하지 않는다.
      </li>
    </ul>
    <emu-note>
      <p>Function code 는 일반적으로 Function Definitions (<emu-xref href="#sec-function-definitions"></emu-xref>), Arrow Function Definitions (<emu-xref href="#sec-arrow-function-definitions"></emu-xref>), Method Definitions (<emu-xref href="#sec-method-definitions"></emu-xref>), Generator Function Definitions (<emu-xref href="#sec-generator-function-definitions"></emu-xref>), Async Function Definitions (<emu-xref href="#sec-async-function-definitions"></emu-xref>), Async Generator Function Definitions (<emu-xref href="#sec-async-generator-function-definitions"></emu-xref>), Async Arrow Functions (<emu-xref href="#sec-async-arrow-function-definitions"></emu-xref>) 의 본문으로 제공된다. Function code 는 또한 Function 생성자 (<emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>), GeneratorFunction 생성자 (<emu-xref href="#sec-generatorfunction"></emu-xref>), AsyncFunction 생성자 (<emu-xref href="#sec-async-function-constructor-arguments"></emu-xref>), AsyncGeneratorFunction 생성자 (<emu-xref href="#sec-asyncgeneratorfunction"></emu-xref>) 의 인자에서 파생된다.</p>
    </emu-note>
    <emu-note>
      <p>function code 에 |BindingIdentifier| 를 포함하는 실질적 효과는 주변 코드가 strict 모드 코드가 아니더라도 함수 본문에 "use strict" 지시문을 포함하는 함수 이름인 |BindingIdentifier| 에 strict 모드 코드의 Early Errors 가 적용되게 한다.</p>
    </emu-note>

    <emu-clause id="sec-directive-prologues-and-the-use-strict-directive">
      <h1>지시문 프로로그와 Use Strict 지시문(Directive Prologues and the Use Strict Directive)</h1>
      <p><dfn id="directive-prologue" variants="Directive Prologues">Directive Prologue</dfn> 는 |FunctionBody|, |ScriptBody|, 또는 |ModuleBody| 의 처음 |StatementListItem| 들 또는 |ModuleItem| 들로 발생하는 |ExpressionStatement| 들의 가장 긴 시퀀스로서, 그 시퀀스의 각 |ExpressionStatement| 가 완전히 |StringLiteral| 토큰 뒤에 세미콜론이 따라오는 형태로만 구성된다. 세미콜론은 명시적으로 나타나거나 자동 세미콜론 삽입(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)에 의해 삽입될 수 있다. Directive Prologue 는 빈 시퀀스일 수 있다.</p>
      <p><dfn id="use-strict-directive" variants="Use Strict Directives">Use Strict Directive</dfn> 는 |StringLiteral| 이 정확히 `"use strict"` 또는 `'use strict'` 코드 포인트 시퀀스인 Directive Prologue 내의 |ExpressionStatement| 이다. Use Strict Directive 는 |EscapeSequence| 또는 |LineContinuation| 을 포함할 수 없다.</p>
      <p>Directive Prologue 는 둘 이상의 Use Strict Directive 를 포함할 수 있다. 단, 구현은 이 경우 경고를 발행할 수 있다.</p>
      <emu-note>
        <p>Directive Prologue 의 |ExpressionStatement| 들은 포함하는 생성물(production)을 평가하는 동안 정상적으로 평가된다. 구현은 Use Strict Directive 가 아니면서 Directive Prologue 에 등장하는 |ExpressionStatement| 에 대해 구현별 의미를 정의할 수 있다. 적절한 통지 메커니즘이 존재한다면, 구현은 Directive Prologue 에서 Use Strict Directive 가 아니고 구현이 정의한 의미도 가지지 않는 |ExpressionStatement| 를 발견할 경우 경고를 발행해야 한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-strict-mode-code">
      <h1>Strict 모드 코드(Strict Mode Code)</h1>
      <p>ECMAScript 구문 단위는 비제한(unrestricted) 또는 strict 모드 문법과 의미론(<emu-xref href="#sec-strict-variant-of-ecmascript"></emu-xref>)을 사용하여 처리될 수 있다. 다음 상황에서 코드는 <dfn>strict mode code</dfn> 로 해석된다:</p>
      <ul>
        <li>
          Global code 는 Use Strict Directive 를 포함하는 Directive Prologue 로 시작하면 strict mode code 이다.
        </li>
        <li>
          Module code 는 항상 strict mode code 이다.
        </li>
        <li>
          |ClassDeclaration| 또는 |ClassExpression| 의 모든 부분은 strict mode code 이다.
        </li>
        <li>
          Eval code 는 Use Strict Directive 를 포함하는 Directive Prologue 로 시작하거나 호출되는 `eval` 이 strict mode code 에 포함된 direct eval 이면 strict mode code 이다.
        </li>
        <li>
          Function code 는 연관된 |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |MethodDefinition|, |ArrowFunction|, |AsyncArrowFunction| 이 strict mode code 에 포함되거나 그 함수의 [[ECMAScriptCode]] 내부 슬롯 값을 생성하는 코드가 Use Strict Directive 를 포함하는 Directive Prologue 로 시작하면 strict mode code 이다.
        </li>
        <li>
          내장 Function, Generator, AsyncFunction, AsyncGenerator 생성자에 인자로 제공되는 Function code 는 마지막 인자가 String 이고 그것을 처리했을 때 |FunctionBody| 가 Use Strict Directive 를 포함하는 Directive Prologue 로 시작한다면 strict mode code 이다.
        </li>
      </ul>
      <p>strict mode code 가 아닌 ECMAScript 코드는 <dfn id="non-strict-code">non-strict code</dfn> 라고 한다.</p>

      <emu-clause id="sec-isstrict" type="abstract operation">
        <h1>
          정적 의미론(Static Semantics): IsStrict (
          _node_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _node_ 가 매치한 소스 텍스트가 strict mode code 이면 *true* 반환; 그렇지 않으면 *false* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-non-ecmascript-functions">
      <h1>비 ECMAScript 함수(Non-ECMAScript Functions)</h1>
      <p>ECMAScript 구현은 평가 동작이 ECMAScript 소스 텍스트가 아닌 호스트 정의 실행 가능 코드 형태로 표현된 함수 이그조틱 객체의 평가를 지원할 수 있다. 함수 객체가 ECMAScript 코드 내에서 정의되었는지 또는 내장 함수인지 여부는 그러한 함수 객체를 호출하거나 그에 의해 호출되는 ECMAScript 코드의 관점에서는 관측할 수 없다.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-lexical-grammar">
  <h1>ECMAScript 언어: 어휘 문법( Lexical Grammar )</h1>
  <p>ECMAScript |Script| 또는 |Module| 의 소스 텍스트는 먼저 입력 요소들의 시퀀스로 변환되는데, 이는 토큰(token), 줄 종결자(line terminator), 주석(comment), 또는 공백(white space)이다. 소스 텍스트는 왼쪽에서 오른쪽으로 스캔되며, 매번 가능한 한 가장 긴 코드 포인트 시퀀스를 다음 입력 요소로 선택한다.</p>
  <p>입력 요소를 소비하는 구문 문법(syntactic grammar) 문맥에 따라 어휘 입력 요소 식별이 민감하게 달라지는 여러 상황이 있다. 이는 어휘 문법에 여러 목표 심볼(lexical goal symbol)이 필요한 이유이다. |InputElementHashbangOrRegExp| 목표는 |Script| 또는 |Module| 의 시작에서 사용된다. |InputElementRegExpOrTemplateTail| 목표는 |RegularExpressionLiteral|, |TemplateMiddle| 또는 |TemplateTail| 이 허용되는 구문 문맥에서 사용된다. |InputElementRegExp| 목표 심볼은 |RegularExpressionLiteral| 이 허용되지만 |TemplateMiddle| 과 |TemplateTail| 은 허용되지 않는 모든 구문 문맥에서 사용된다. |InputElementTemplateTail| 목표는 |TemplateMiddle| 또는 |TemplateTail| 이 허용되지만 |RegularExpressionLiteral| 은 허용되지 않는 모든 구문 문맥에서 사용된다. 그 외 모든 문맥에서는 |InputElementDiv| 가 어휘 목표 심볼로 사용된다.</p>
  <emu-note>
    <p>여러 어휘 목표를 사용하는 것은 자동 세미콜론 삽입에 영향을 주는 어휘적 모호성이 없도록 보장한다. 예를 들어 선행 division 또는 division-assignment 와 선행 |RegularExpressionLiteral| 이 동시에 허용되는 구문 문맥은 존재하지 않는다. 이는 세미콜론 삽입 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) 에 의해 영향을 받지 않는다. 다음 예와 같이:</p>
    <pre><code class="javascript">
      a = b
      /hi/g.exec(c).map(d);
    </code></pre>
    <p>|LineTerminator| 뒤의 첫 공백·주석이 아닌 코드 포인트가 U+002F (SOLIDUS) 이고, 구문 문맥이 division 또는 division-assignment 를 허용한다면, 해당 |LineTerminator| 위치에는 세미콜론이 삽입되지 않는다. 즉, 위 예는 다음과 동일하게 해석된다:</p>
    <pre><code class="javascript">
      a = b / hi / g.exec(c).map(d);
    </code></pre>
  </emu-note>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    InputElementDiv ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      RightBracePunctuator

    InputElementRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RightBracePunctuator
      RegularExpressionLiteral

    InputElementRegExpOrTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RegularExpressionLiteral
      TemplateSubstitutionTail

    InputElementTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      TemplateSubstitutionTail

    InputElementHashbangOrRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      HashbangComment
      RegularExpressionLiteral
  </emu-grammar>

  <emu-clause id="sec-unicode-format-control-characters">
    <h1>유니코드 서식 제어 문자(Unicode Format-Control Characters)</h1>
    <p>유니코드 서식 제어 문자(즉, 유니코드 문자 데이터베이스 범주 “Cf” 에 속하는 LEFT-TO-RIGHT MARK, RIGHT-TO-LEFT MARK 등)는 상위 수준 프로토콜(예: 마크업 언어)이 없는 상황에서 텍스트 범위 서식을 제어하는 데 사용하는 제어 코드이다.</p>
    <p>소스 텍스트에서 편집 및 표시를 용이하게 하기 위해 서식 제어 문자를 허용하는 것이 유용하다. 모든 서식 제어 문자는 주석 내부, 그리고 문자열 리터럴, 템플릿 리터럴, 정규 표현식 리터럴 내부에 사용할 수 있다.</p>
    <p>U+FEFF (ZERO WIDTH NO-BREAK SPACE)는 주로 텍스트 시작 부분에서 해당 텍스트가 유니코드임을 표시하고 인코딩과 바이트 순서를 감지할 수 있도록 하는 서식 제어 문자이다. 이 목적을 위한 &lt;ZWNBSP> 문자가 파일을 연결(concatenate)한 결과 등으로 텍스트 시작 이후에 나타나는 경우도 있다. ECMAScript 소스 텍스트에서 &lt;ZWNBSP> 코드 포인트는 주석, 문자열 리터럴, 템플릿 리터럴, 정규 표현식 리터럴 밖에서는 공백 문자(<emu-xref href="#sec-white-space"></emu-xref> 참조)로 취급된다.</p>
  </emu-clause>

  <emu-clause id="sec-white-space">
    <h1>공백(White Space)</h1>
    <p>공백 코드 포인트는 소스 텍스트 가독성을 높이고 토큰(분할 불가능한 어휘 단위)들을 분리하기 위해 사용되며, 그 외에는 의미가 없다. 공백 코드 포인트는 임의의 두 토큰 사이 및 입력 시작과 끝에 나타날 수 있다. 공백 코드 포인트는 |StringLiteral|, |RegularExpressionLiteral|, |Template|, |TemplateSubstitutionTail| 내부에 나타날 수 있으며 그 경우 리터럴 값의 일부를 구성하는 의미 있는(code point)로 간주된다. |Comment| 내부에도 나타날 수 있지만 그 밖의 다른 종류의 토큰 내부에는 나타날 수 없다.</p>
    <p>ECMAScript 공백 코드 포인트는 <emu-xref href="#table-white-space-code-points"></emu-xref>에 나열되어 있다.</p>
    <emu-table id="table-white-space-code-points" caption="White Space Code Points" oldids="table-32">
      <table>
        <thead>
          <tr>
            <th>
              Code Points
            </th>
            <th>
              Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+0009`
          </td>
          <td>
            CHARACTER TABULATION
          </td>
          <td>
            &lt;TAB>
          </td>
        </tr>
        <tr>
          <td>
            `U+000B`
          </td>
          <td>
            LINE TABULATION
          </td>
          <td>
            &lt;VT>
          </td>
        </tr>
        <tr>
          <td>
            `U+000C`
          </td>
          <td>
            FORM FEED (FF)
          </td>
          <td>
            &lt;FF>
          </td>
        </tr>
        <tr>
          <td>
            `U+FEFF`
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP>
          </td>
        </tr>
        <tr>
          <td>
            any code point in general category “Space_Separator”
          </td>
          <td>
          </td>
          <td>
            &lt;USP>
          </td>
        </tr>
      </table>
    </emu-table>
    <emu-note>
      <p>U+0020 (SPACE) 과 U+00A0 (NO-BREAK SPACE) 코드 포인트는 &lt;USP> 에 속한다.</p>
    </emu-note>
    <emu-note>
      <p><emu-xref href="#table-white-space-code-points"></emu-xref> 에 나열된 코드 포인트를 제외하고 ECMAScript |WhiteSpace| 는 “White_Space” 유니코드 속성을 가지지만 일반 범주 “Space_Separator”(“Zs”) 에 속하지 않는 모든 코드 포인트를 의도적으로 제외한다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WhiteSpace ::
        &lt;TAB&gt;
        &lt;VT&gt;
        &lt;FF&gt;
        &lt;ZWNBSP&gt;
        &lt;USP&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-line-terminators">
    <h1>줄 종결자(Line Terminators)</h1>
    <p>공백 코드 포인트와 마찬가지로 줄 종결자 코드 포인트는 소스 텍스트 가독성을 높이고 토큰을 서로 분리한다. 그러나 공백 코드 포인트와 달리 줄 종결자는 구문 문법 동작에 일부 영향을 준다. 일반적으로 줄 종결자는 임의의 두 토큰 사이에 나타날 수 있지만, 구문 문법이 금지하는 몇몇 위치에는 나타날 수 없다. 줄 종결자는 자동 세미콜론 삽입 과정(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)에도 영향을 준다. 줄 종결자는 |StringLiteral|, |Template|, |TemplateSubstitutionTail| 을 제외한 어떤 토큰 내부에도 나타날 수 없다. &lt;LF> 및 &lt;CR> 줄 종결자는 |LineContinuation| 의 일부가 아닌 한 |StringLiteral| 토큰 내부에 나타날 수 없다.</p>
    <p>줄 종결자는 |MultiLineComment| 내부에 나타날 수 있지만 |SingleLineComment| 내부에는 나타날 수 없다.</p>
    <p>줄 종결자는 정규 표현식에서 `\\s` 클래스가 매칭하는 공백 코드 포인트 집합에 포함된다.</p>
    <p>ECMAScript 줄 종결자 코드 포인트는 <emu-xref href="#table-line-terminator-code-points"></emu-xref>에 나열되어 있다.</p>
    <emu-table id="table-line-terminator-code-points" caption="Line Terminator Code Points" oldids="table-33">
      <table>
        <thead>
          <tr>
            <th>
              Code Point
            </th>
            <th>
              Unicode Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+000A`
          </td>
          <td>
            LINE FEED (LF)
          </td>
          <td>
            &lt;LF>
          </td>
        </tr>
        <tr>
          <td>
            `U+000D`
          </td>
          <td>
            CARRIAGE RETURN (CR)
          </td>
          <td>
            &lt;CR>
          </td>
        </tr>
        <tr>
          <td>
            `U+2028`
          </td>
          <td>
            LINE SEPARATOR
          </td>
          <td>
            &lt;LS>
          </td>
        </tr>
        <tr>
          <td>
            `U+2029`
          </td>
          <td>
            PARAGRAPH SEPARATOR
          </td>
          <td>
            &lt;PS>
          </td>
        </tr>
      </table>
    </emu-table>
    <p><emu-xref href="#table-line-terminator-code-points"></emu-xref> 의 유니코드 코드 포인트만 줄 종결자로 취급된다. 다른 개행(new line) 또는 줄 분리(line breaking) 유니코드 코드 포인트는 줄 종결자로 취급되지 않지만 <emu-xref href="#table-white-space-code-points"></emu-xref> 에 명시된 요구를 만족하면 공백으로 취급된다. 시퀀스 &lt;CR>&lt;LF> 는 일반적으로 하나의 줄 종결자로 사용된다. 행 번호 보고 목적으로는 단일 |SourceCharacter| 로 간주해야 한다.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LineTerminator ::
        &lt;LF&gt;
        &lt;CR&gt;
        &lt;LS&gt;
        &lt;PS&gt;

      LineTerminatorSequence ::
        &lt;LF&gt;
        &lt;CR&gt; [lookahead != &lt;LF&gt;]
        &lt;LS&gt;
        &lt;PS&gt;
        &lt;CR&gt; &lt;LF&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-comments">
    <h1>주석(Comments)</h1>
    <p>주석은 단일 행 또는 다중 행일 수 있다. 다중 행 주석은 중첩될 수 없다.</p>
    <p>단일 행 주석은 |LineTerminator| 코드 포인트를 제외한 임의의 유니코드 코드 포인트를 포함할 수 있고, 토큰은 항상 가능한 한 가장 길게 인식된다는 일반 규칙 때문에, 단일 행 주석은 `//` 마커로부터 그 줄 끝까지의 모든 코드 포인트로 구성된다. 단, 줄 끝의 |LineTerminator| 는 단일 행 주석의 일부로 간주되지 않으며 어휘 문법에 의해 별도로 인식되어 구문 문법을 위한 입력 요소 스트림의 일부가 된다. 이 점은 단일 행 주석의 존재 여부가 자동 세미콜론 삽입 과정 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) 에 영향을 주지 않음을 의미하므로 매우 중요하다.</p>
    <p>주석은 공백처럼 동작하며 폐기되지만, |MultiLineComment| 가 줄 종결자 코드 포인트를 포함하면 구문 문법이 파싱할 때 전체 주석이 |LineTerminator| 로 간주된다.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Comment ::
        MultiLineComment
        SingleLineComment

      MultiLineComment ::
        `/*` MultiLineCommentChars? `*/`

      MultiLineCommentChars ::
        MultiLineNotAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      PostAsteriskCommentChars ::
        MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      MultiLineNotAsteriskChar ::
        SourceCharacter but not `*`

      MultiLineNotForwardSlashOrAsteriskChar ::
        SourceCharacter but not one of `/` or `*`

      SingleLineComment ::
        `//` SingleLineCommentChars?

      SingleLineCommentChars ::
        SingleLineCommentChar SingleLineCommentChars?

      SingleLineCommentChar ::
        SourceCharacter but not LineTerminator
    </emu-grammar>
    <p>이 절의 다수 생성물은 <emu-xref href="#sec-html-like-comments"></emu-xref> 절에서 대체 정의를 가진다.</p>
  </emu-clause>

  <emu-clause id="sec-hashbang">
    <h1>Hashbang 주석(Hashbang Comments)</h1>

    <p>Hashbang 주석은 위치에 민감하며 다른 종류의 주석처럼 구문 문법 입력 요소 스트림에서 제거(discard)된다.</p>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      HashbangComment ::
        `#!` SingleLineCommentChars?
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-tokens">
    <h1>토큰(Tokens)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CommonToken ::
        IdentifierName
        PrivateIdentifier
        Punctuator
        NumericLiteral
        StringLiteral
        Template
    </emu-grammar>
    <emu-note>
      <p>|DivPunctuator|, |RegularExpressionLiteral|, |RightBracePunctuator|, |TemplateSubstitutionTail| 생성물은 |CommonToken| 생성물에 포함되지 않는 추가 토큰을 도출한다.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-names-and-keywords">
    <h1>이름과 키워드(Names and Keywords)</h1>
    <p>|IdentifierName| 과 |ReservedWord| 는 Unicode Standard Annex #31 (Identifier and Pattern Syntax)에 규정된 기본 식별자 문법(Default Identifier Syntax)을 (소규모 수정과 함께) 따른 토큰이다. |ReservedWord| 는 |IdentifierName| 의 열거된 부분집합이다. 구문 문법은 |Identifier| 를 |IdentifierName| 이면서 |ReservedWord| 가 아닌 것으로 정의한다. 유니코드 식별자 문법은 유니코드 표준이 규정한 문자 속성에 기반한다. 최신 유니코드 표준 버전에 지정된 범주의 유니코드 코드 포인트는 모든 적합 ECMAScript 구현에서 그 범주에 속한 것으로 취급되어야 한다. ECMAScript 구현은 추후판 유니코드 표준에서 정의된 식별자 코드 포인트를 추가로 인식할 수 있다.</p>
    <emu-note>
      <p>본 표준은 특정 코드 포인트 추가를 지정한다: U+0024 (DOLLAR SIGN) 과 U+005F (LOW LINE)는 |IdentifierName| 내 어디서든 허용된다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrivateIdentifier ::
        `#` IdentifierName

      IdentifierName ::
        IdentifierStart
        IdentifierName IdentifierPart

      IdentifierStart ::
        IdentifierStartChar
        `\` UnicodeEscapeSequence

      IdentifierPart ::
        IdentifierPartChar
        `\` UnicodeEscapeSequence

      IdentifierStartChar ::
        UnicodeIDStart
        `$`
        `_`

      IdentifierPartChar ::
        UnicodeIDContinue
        `$`

      // emu-format ignore
      AsciiLetter :: one of
        `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
        `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

      UnicodeIDStart ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;

      UnicodeIDContinue ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;
    </emu-grammar>
    <p>비단말 |UnicodeEscapeSequence| 의 정의는 <emu-xref href="#sec-literals-string-literals"></emu-xref>에 있다.</p>
    <emu-note>
      <p>비단말 |IdentifierPart| 는 |UnicodeIDContinue| 를 통해 `_` 를 도출한다.</p>
    </emu-note>
    <emu-note>
      <p>유니코드 속성 “ID_Start” 와 “ID_Continue” 를 가진 코드 포인트 집합은 각각 “Other_ID_Start” 및 “Other_ID_Continue” 속성의 코드 포인트를 포함한다.</p>
    </emu-note>

    <emu-clause id="sec-identifier-names">
      <h1>식별자 이름(Identifier Names)</h1>
      <p>유니코드 이스케이프 시퀀스는 |IdentifierName| 내에서 허용되며 해당 |UnicodeEscapeSequence| 의 IdentifierCodePoint 와 동일한 단일 유니코드 코드 포인트를 기여한다. |UnicodeEscapeSequence| 앞의 `\\` 는 어떠한 코드 포인트도 기여하지 않는다. |UnicodeEscapeSequence| 는 원래라면 무효인 코드 포인트를 |IdentifierName| 에 기여하는 데 사용할 수 없다. 즉 `\\` |UnicodeEscapeSequence| 시퀀스를 그것이 기여하는 |SourceCharacter| 로 치환해도 결과는 동일한 |SourceCharacter| 시퀀스를 가지는 여전히 유효한 |IdentifierName| 이어야 한다. 본 명세에서 |IdentifierName| 의 해석은 특정 코드 포인트가 이스케이프로 입력되었는지 여부와 관계없이 실제 코드 포인트에 기반한다.</p>
      <p>유니코드 표준에 따라 정규적으로 등가(canonically equivalent)인 두 |IdentifierName| 은 각 |UnicodeEscapeSequence| 를 치환한 뒤 정확히 동일한 코드 포인트 시퀀스로 표현되지 않는 한 <em>동일하지 않다</em>.</p>

      <emu-clause id="sec-identifier-names-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>IdentifierStart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>|UnicodeEscapeSequence| 의 IdentifierCodePoint 가 |IdentifierStartChar| 어휘 문법 생성물에 매칭되는 유니코드 코드 포인트가 아니면 Syntax Error.</li>
        </ul>
        <emu-grammar>IdentifierPart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>|UnicodeEscapeSequence| 의 IdentifierCodePoint 가 |IdentifierPartChar| 어휘 문법 생성물에 매칭되는 유니코드 코드 포인트가 아니면 Syntax Error.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoints" type="sdo">
        <h1>정적 의미론: IdentifierCodePoints ( ): 코드 포인트 List</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierName :: IdentifierStart</emu-grammar>
        <emu-alg>
          1. _cp_ 를 |IdentifierStart| 의 IdentifierCodePoint 로 둔다.
          1. « _cp_ » 반환.
        </emu-alg>
        <emu-grammar>IdentifierName :: IdentifierName IdentifierPart</emu-grammar>
        <emu-alg>
          1. _cps_ 를 파생된 |IdentifierName| 의 IdentifierCodePoints 로 둔다.
          1. _cp_ 를 |IdentifierPart| 의 IdentifierCodePoint 로 둔다.
          1. _cps_ 와 « _cp_ » 의 리스트 연결을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoint" type="sdo">
        <h1>정적 의미론: IdentifierCodePoint ( ): 코드 포인트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierStartChar| 가 매칭한 코드 포인트 반환.
        </emu-alg>
        <emu-grammar>IdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. |IdentifierPartChar| 가 매칭한 코드 포인트 반환.
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. |Hex4Digits| 의 MV 인 수치 값을 가진 코드 포인트 반환.
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. |CodePoint| 의 MV 인 수치 값을 가진 코드 포인트 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-keywords-and-reserved-words" oldids="sec-reserved-words,sec-keywords,sec-future-reserved-words">
      <h1>키워드와 예약어(Keywords and Reserved Words)</h1>
      <p><dfn variants="keywords">키워드(keyword)</dfn> 는 |IdentifierName| 에 매칭되면서 구문적 용도를 가지는 토큰, 즉 어떤 구문 생성물에 고정폭(`fixed width`) 글꼴로 문자 그대로 등장하는 토큰이다. ECMAScript 키워드에는 `if`, `while`, `async`, `await` 등 다수가 포함된다.</p>
      <p><dfn variants="reserved words">예약어(reserved word)</dfn> 는 식별자로 사용할 수 없는 |IdentifierName| 이다. 다수 키워드는 예약어이지만 아닌 것도 있으며 어떤 것은 특정 문맥에서만 예약된다. `if`, `while` 은 항상 예약어이다. `await` 는 async 함수 및 모듈 내부에서만 예약된다. `async` 는 예약되지 않으며 제한 없이 변수 이름이나 레이블로 사용할 수 있다.</p>
      <p>이 명세는 문법 생성물과 조기 오류 규칙을 조합하여 어떤 이름이 유효한 식별자이고 어떤 것이 예약어인지 지정한다. 아래 |ReservedWord| 목록의 모든 토큰( `await`, `yield` 제외)은 무조건 예약된다. `await`, `yield` 예외는 매개변수화된 구문 생성물을 사용하는 <emu-xref href="#sec-identifiers"></emu-xref> 에서 지정된다. 마지막으로 여러 조기 오류 규칙이 유효한 식별자 집합을 제한한다. <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-let-and-const-declarations-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-class-definitions-static-semantics-early-errors"></emu-xref> 참조. 요약하면 식별자 이름은 다섯 범주로 나뉜다:</p>
      <ul>
        <li>
          <p>`Math`, `window`, `toString`, `_` 처럼 항상 식별자로 허용되고 키워드가 아닌 것;</p>
        </li>
        <li>
          <p>`await`, `yield` 를 제외한 아래 |ReservedWord| 들처럼 결코 식별자로 허용되지 않는 것;</p>
        </li>
        <li>
          <p>`await`, `yield` 처럼 문맥적으로 식별자로 허용되는 것;</p>
        </li>
        <li>
          <p>strict 모드 코드에서 문맥적으로 식별자로 허용되지 않는 것: `let`, `static`, `implements`, `interface`, `package`, `private`, `protected`, `public`;</p>
        </li>
        <li>
          <p>`as`, `async`, `from`, `get`, `meta`, `of`, `set`, `target` 처럼 항상 식별자로 허용되지만 특정 구문 생성물 안에서 |Identifier| 가 허용되지 않는 위치에 키워드로 나타나기도 하는 것.</p>
        </li>
      </ul>
      <p><dfn variants="conditional keywords">조건부 키워드</dfn> 또는 <dfn variants="contextual keywords">문맥적 키워드(contextual keyword)</dfn> 라는 용어는 마지막 세 범주에 속해 어떤 문맥에서는 식별자, 다른 문맥에서는 키워드로 쓰일 수 있는 키워드를 가리킬 때 사용되기도 한다.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        // emu-format ignore
        ReservedWord :: one of
          `await`
          `break`
          `case` `catch` `class` `const` `continue`
          `debugger` `default` `delete` `do`
          `else` `enum` `export` `extends`
          `false` `finally` `for` `function`
          `if` `import` `in` `instanceof`
          `new` `null`
          `return`
          `super` `switch`
          `this` `throw` `true` `try` `typeof`
          `var` `void`
          `while` `with`
          `yield`
      </emu-grammar>
      <emu-note>
        <p><emu-xref href="#sec-grammar-notation"></emu-xref> 에 따라 문법의 키워드는 특정 |SourceCharacter| 요소들의 리터럴 시퀀스에 매칭된다. 키워드 내 코드 포인트는 `\\` |UnicodeEscapeSequence| 로 표현될 수 없다.</p>
        <p>|IdentifierName| 은 `\\` |UnicodeEscapeSequence| 를 포함할 수 있지만 `els\u{65}` 처럼 작성하여 이름이 "else" 인 변수를 선언할 수는 없다. <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref> 의 조기 오류 규칙이 예약어와 StringValue 가 동일한 식별자를 배제한다.</p>
      </emu-note>
      <emu-note>
        <p>`enum` 은 현재 본 명세에서 키워드로 사용되지 않는다. 이는 향후 언어 확장을 위해 예약된 <em>미래 예약어</em> (future reserved word)이다.</p>
        <p>마찬가지로 `implements`, `interface`, `package`, `private`, `protected`, `public` 는 strict 모드 코드에서 미래 예약어이다.</p>
      </emu-note>
      <emu-note>
        <p>`arguments` 와 `eval` 은 키워드는 아니지만 strict 모드 코드에서 몇 가지 제약을 받는다. <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-static-semantics-assignmenttargettype"></emu-xref>, <emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-function-definitions-static-semantics-early-errors"></emu-xref> 참조.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-punctuators">
    <h1>구두점 기호(Punctuators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Punctuator ::
        OptionalChainingPunctuator
        OtherPunctuator

      OptionalChainingPunctuator ::
        `?.` [lookahead &notin; DecimalDigit]

      // emu-format ignore
      OtherPunctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||` `??`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `&amp;&amp;=` `||=` `??=`
        `=&gt;`

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-ecmascript-language-lexical-grammar-literals">
    <h1>리터럴(Literals)</h1>

    <emu-clause id="sec-null-literals">
      <h1>null 리터럴(Null Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NullLiteral ::
          `null`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-boolean-literals">
      <h1>Boolean 리터럴(Boolean Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BooleanLiteral ::
          `true`
          `false`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-literals-numeric-literals" oldids="sec-additional-syntax-numeric-literals">
      <h1>숫자 리터럴(Numeric Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NumericLiteralSeparator ::
          `_`

        NumericLiteral ::
          DecimalLiteral
          DecimalBigIntegerLiteral
          NonDecimalIntegerLiteral[+Sep]
          NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
          LegacyOctalIntegerLiteral

        DecimalBigIntegerLiteral ::
          `0` BigIntLiteralSuffix
          NonZeroDigit DecimalDigits[+Sep]? BigIntLiteralSuffix
          NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

        NonDecimalIntegerLiteral[Sep] ::
          BinaryIntegerLiteral[?Sep]
          OctalIntegerLiteral[?Sep]
          HexIntegerLiteral[?Sep]

        BigIntLiteralSuffix ::
          `n`

        DecimalLiteral ::
          DecimalIntegerLiteral `.` DecimalDigits[+Sep]? ExponentPart[+Sep]?
          `.` DecimalDigits[+Sep] ExponentPart[+Sep]?
          DecimalIntegerLiteral ExponentPart[+Sep]?

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit
          NonZeroDigit NumericLiteralSeparator? DecimalDigits[+Sep]
          NonOctalDecimalIntegerLiteral

        DecimalDigits[Sep] ::
          DecimalDigit
          DecimalDigits[?Sep] DecimalDigit
          [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`

        ExponentPart[Sep] ::
          ExponentIndicator SignedInteger[?Sep]

        ExponentIndicator :: one of
          `e` `E`

        SignedInteger[Sep] ::
          DecimalDigits[?Sep]
          `+` DecimalDigits[?Sep]
          `-` DecimalDigits[?Sep]

        BinaryIntegerLiteral[Sep] ::
          `0b` BinaryDigits[?Sep]
          `0B` BinaryDigits[?Sep]

        BinaryDigits[Sep] ::
          BinaryDigit
          BinaryDigits[?Sep] BinaryDigit
          [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

        BinaryDigit :: one of
          `0` `1`

        OctalIntegerLiteral[Sep] ::
          `0o` OctalDigits[?Sep]
          `0O` OctalDigits[?Sep]

        OctalDigits[Sep] ::
          OctalDigit
          OctalDigits[?Sep] OctalDigit
          [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

        LegacyOctalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalIntegerLiteral OctalDigit

        NonOctalDecimalIntegerLiteral ::
          `0` NonOctalDigit
          LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
          NonOctalDecimalIntegerLiteral DecimalDigit

        LegacyOctalLikeDecimalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalLikeDecimalIntegerLiteral OctalDigit

        OctalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7`

        NonOctalDigit :: one of
          `8` `9`

        HexIntegerLiteral[Sep] ::
          `0x` HexDigits[?Sep]
          `0X` HexDigits[?Sep]

        HexDigits[Sep] ::
          HexDigit
          HexDigits[?Sep] HexDigit
          [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

        // emu-format ignore
        HexDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`
      </emu-grammar>
      <p>|NumericLiteral| 바로 뒤 |SourceCharacter| 는 |IdentifierStart| 또는 |DecimalDigit| 이면 안 된다.</p>
      <emu-note>
        <p>예: `3in` 은 오류이며 `3` 과 `in` 두 입력 요소가 아니다.</p>
      </emu-note>

      <emu-clause id="sec-numeric-literals-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          NumericLiteral :: LegacyOctalIntegerLiteral

          DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
        </emu-grammar>
        <ul>
          <li>IsStrict(this production) 이 *true* 이면 Syntax Error.</li>
        </ul>
        <emu-note>비 strict 코드에서 이 문법은 레거시이다.</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-mv" oldids="sec-additional-syntax-numeric-literals-status-semantics">
        <h1>정적 의미론: MV</h1>
        <p>숫자 리터럴은 Number 타입 또는 BigInt 타입의 값을 나타낸다.</p>
        <ul>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits</emu-grammar> 의 MV 는 |DecimalIntegerLiteral| 의 MV + (|DecimalDigits| 의 MV × 10<sup>-_n_</sup>) 이며 여기서 _n_ 은 |NumericLiteralSeparator| 를 모두 제외한 |DecimalDigits| 의 코드 포인트 수.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart</emu-grammar> 의 MV 는 |DecimalIntegerLiteral| 의 MV × 10<sup>_e_</sup> 이며 _e_ 는 |ExponentPart| 의 MV.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart</emu-grammar> 의 MV 는 (|DecimalIntegerLiteral| MV + (|DecimalDigits| MV × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits</emu-grammar> 의 MV 는 |DecimalDigits| MV × 10<sup>-_n_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits ExponentPart</emu-grammar> 의 MV 는 |DecimalDigits| MV × 10<sup>_e_ - _n_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral ExponentPart</emu-grammar> 의 MV 는 |DecimalIntegerLiteral| MV × 10<sup>_e_</sup>.
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: `0`</emu-grammar> 의 MV 는 0.
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparator? DecimalDigits</emu-grammar> 의 MV 는 (|NonZeroDigit| MV × 10<sup>_n_</sup>) + |DecimalDigits| MV.
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits DecimalDigit</emu-grammar> 의 MV 는 (|DecimalDigits| MV × 10) + |DecimalDigit| MV.
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit</emu-grammar> 의 MV 도 위와 동일.
          </li>
          <li>
            <emu-grammar>ExponentPart :: ExponentIndicator SignedInteger</emu-grammar> 의 MV 는 |SignedInteger| MV.
          </li>
          <li>
            <emu-grammar>SignedInteger :: `-` DecimalDigits</emu-grammar> 의 MV 는 |DecimalDigits| MV 의 음수.
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `0`</emu-grammar>, <emu-grammar>HexDigit :: `0`</emu-grammar>, <emu-grammar>OctalDigit :: `0`</emu-grammar>, <emu-grammar>LegacyOctalEscapeSequence :: `0`</emu-grammar>, <emu-grammar>BinaryDigit :: `0`</emu-grammar> 의 MV 는 0.
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `1`</emu-grammar> 등 동일 패턴으로 1.
          </li>
          <li>
            (2~9, a~f, A~F 등에 대한 MV 서술은 원문과 동일 규칙 반복 — 이하 각각 명시된 값.)
          </li>
          <li>
            <emu-grammar>BinaryDigits :: BinaryDigits BinaryDigit</emu-grammar> MV = (이전 × 2) + 새 |BinaryDigit| MV.
          </li>
          <li>
            NumericLiteralSeparator 가 있는 Binary / Octal / HexDigits 경우도 동일 방식.
          </li>
          <li>
            Legacy / NonOctal / HexDigits 조합의 MV 는 표기된 진법에 따라 누적 계산(8 또는 10 또는 16 배) + 새 자리 MV.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-numericvalue" type="sdo">
        <h1>정적 의미론: NumericValue ( ): Number 또는 BigInt</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NumericLiteral :: DecimalLiteral</emu-grammar>
        <emu-alg>
          1. RoundMVResult(|DecimalLiteral| MV) 반환.
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 𝔽(|NonDecimalIntegerLiteral| MV) 반환.
        </emu-alg>
        <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 𝔽(|LegacyOctalIntegerLiteral| MV) 반환.
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. |NonDecimalIntegerLiteral| MV 에 대한 BigInt 값 반환.
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: `0` BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. *0*<sub>ℤ</sub> 반환.
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. |NonZeroDigit| MV 에 대한 BigInt 값 반환.
        </emu-alg>
        <emu-grammar>
          DecimalBigIntegerLiteral ::
            NonZeroDigit DecimalDigits BigIntLiteralSuffix
            NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
        </emu-grammar>
        <emu-alg>
          1. _n_ = |DecimalDigits| 에서 |NumericLiteralSeparator| 제외한 코드 포인트 수.
          1. _mv_ = (|NonZeroDigit| MV × 10<sup>_n_</sup>) + |DecimalDigits| MV.
          1. ℤ(_mv_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-string-literals" oldids="sec-additional-syntax-string-literals">
      <h1>문자열 리터럴(String Literals)</h1>
      <emu-note>
        <p>문자열 리터럴은 작은따옴표 또는 큰따옴표로 둘러싸인 0개 이상의 유니코드 코드 포인트이다. 유니코드 코드 포인트는 이스케이프 시퀀스로도 표현할 수 있다. 닫는 따옴표 코드 포인트, U+005C (REVERSE SOLIDUS), U+000D (CR), U+000A (LF)를 제외한 모든 코드 포인트는 문자열 리터럴 안에 그대로 나타날 수 있다. 어떤 코드 포인트든 이스케이프 시퀀스 형태로 나타날 수 있다. 문자열 리터럴은 ECMAScript String 값을 평가 결과로 가진다. 이러한 String 값을 생성할 때 유니코드 코드 포인트는 <emu-xref href="#sec-utf16encodecodepoint"></emu-xref> 에 정의된 대로 UTF-16 으로 인코딩된다. 기본 다국어 평면(BMP)의 코드 포인트는 하나의 코드 유닛으로, 그 밖의 코드 포인트는 두 코드 유닛으로 인코딩된다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        StringLiteral ::
          `"` DoubleStringCharacters? `"`
          `'` SingleStringCharacters? `'`

        DoubleStringCharacters ::
          DoubleStringCharacter DoubleStringCharacters?

        SingleStringCharacters ::
          SingleStringCharacter SingleStringCharacters?

        DoubleStringCharacter ::
          SourceCharacter but not one of `"` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        SingleStringCharacter ::
          SourceCharacter but not one of `'` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        LineContinuation ::
          `\` LineTerminatorSequence

        EscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          LegacyOctalEscapeSequence
          NonOctalDecimalEscapeSequence
          HexEscapeSequence
          UnicodeEscapeSequence

        CharacterEscapeSequence ::
          SingleEscapeCharacter
          NonEscapeCharacter

        SingleEscapeCharacter :: one of
          `'` `"` `\` `b` `f` `n` `r` `t` `v`

        NonEscapeCharacter ::
          SourceCharacter but not one of EscapeCharacter or LineTerminator

        EscapeCharacter ::
          SingleEscapeCharacter
          DecimalDigit
          `x`
          `u`

        LegacyOctalEscapeSequence ::
          `0` [lookahead &isin; { `8`, `9` }]
          NonZeroOctalDigit [lookahead &notin; OctalDigit]
          ZeroToThree OctalDigit [lookahead &notin; OctalDigit]
          FourToSeven OctalDigit
          ZeroToThree OctalDigit OctalDigit

        NonZeroOctalDigit ::
          OctalDigit but not `0`

        ZeroToThree :: one of
          `0` `1` `2` `3`

        FourToSeven :: one of
          `4` `5` `6` `7`

        NonOctalDecimalEscapeSequence :: one of
          `8` `9`

        HexEscapeSequence ::
          `x` HexDigit HexDigit

        UnicodeEscapeSequence ::
          `u` Hex4Digits
          `u{` CodePoint `}`

        Hex4Digits ::
          HexDigit HexDigit HexDigit HexDigit
      </emu-grammar>
      <p>비단말 |HexDigit| 정의는 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>, |SourceCharacter| 는 <emu-xref href="#sec-source-text"></emu-xref> 에 있다.</p>
      <emu-note>
        <p>&lt;LF>, &lt;CR> 은 |LineContinuation| 일부가 아닌 한 문자열 리터럴 내에 나타날 수 없다(빈 코드 포인트 시퀀스 생성). 문자열 값에 포함하려면 `\\n` 또는 `\\u000A` 같은 이스케이프를 사용해야 한다.</p>
      </emu-note>

      <emu-clause id="sec-string-literals-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          EscapeSequence ::
            LegacyOctalEscapeSequence
            NonOctalDecimalEscapeSequence
        </emu-grammar>
        <ul>
          <li>IsStrict(this production) 이 *true* 이면 Syntax Error.</li>
        </ul>
        <emu-note>비 strict 코드에서 이 문법은 레거시.</emu-note>
        <emu-note>
          <p>문자열 리터럴이 뒤따르는 Use Strict Directive 를 통해 strict 모드가 되는 경우가 있으므로 구현은 위 규칙을 철저히 적용해야 한다. 예:</p>
          <pre><code class="javascript">
            function invalid() { "\7"; "use strict"; }
          </code></pre>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sv" oldids="sec-string-literals-static-semantics-stringvalue,sec-additional-syntax-string-literals-static-semantics" type="sdo">
        <h1>정적 의미론: SV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            <p>문자열 리터럴은 String 타입 값에 해당한다. SV 는 문자열 리터럴의 여러 부분에 재귀 적용되어 String 값을 생성한다. 이 과정에서 문자열 리터럴 내 일부 유니코드 코드 포인트는 아래 또는 <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 에 설명된 대로 수학적 값을 가진 것으로 해석된다.</p>
          </dd>
        </dl>
        <ul>
          <li><emu-grammar>StringLiteral :: `"` `"`</emu-grammar> 의 SV 는 빈 문자열.</li>
          <li><emu-grammar>StringLiteral :: `'` `'`</emu-grammar> 의 SV 는 빈 문자열.</li>
          <li><emu-grammar>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters</emu-grammar> 의 SV 는 두 SV 의 문자열 연결.</li>
          <li><emu-grammar>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters</emu-grammar> 도 동일.</li>
          <li><emu-grammar>DoubleStringCharacter :: SourceCharacter but not one of `"` or `\` or LineTerminator</emu-grammar> 의 SV 는 해당 |SourceCharacter| 코드 포인트 UTF16EncodeCodePoint 결과.</li>
          <li><emu-grammar>DoubleStringCharacter :: &lt;LS&gt;</emu-grammar> SV = 코드 유닛 0x2028.</li>
          <li><emu-grammar>DoubleStringCharacter :: &lt;PS&gt;</emu-grammar> SV = 코드 유닛 0x2029.</li>
          <li><emu-grammar>DoubleStringCharacter :: LineContinuation</emu-grammar> SV = 빈 문자열.</li>
          <li>SingleStringCharacter 변형도 동일 규칙.</li>
          <li><emu-grammar>EscapeSequence :: `0`</emu-grammar> SV = 코드 유닛 0x0000.</li>
          <li><emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> SV 는 대응 표 (<emu-xref href="#table-string-single-character-escape-sequences"></emu-xref>)의 코드 유닛.</li>
        </ul>
        <emu-table id="table-string-single-character-escape-sequences" caption="String Single Character Escape Sequences" oldids="table-34">
          <table>
            <thead>
              <tr>
                <th>
                  Escape Sequence
                </th>
                <th>
                  Code Unit Value
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Symbol
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `\\b`
              </td>
              <td>
                `0x0008`
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                &lt;BS>
              </td>
            </tr>
            <tr>
              <td>
                `\\t`
              </td>
              <td>
                `0x0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `\\n`
              </td>
              <td>
                `0x000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `\\v`
              </td>
              <td>
                `0x000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `\\f`
              </td>
              <td>
                `0x000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `\\r`
              </td>
              <td>
                `0x000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
            <tr>
              <td>
                `\\"`
              </td>
              <td>
                `0x0022`
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `"`
              </td>
            </tr>
            <tr>
              <td>
                `\\'`
              </td>
              <td>
                `0x0027`
              </td>
              <td>
                APOSTROPHE
              </td>
              <td>
                `'`
              </td>
            </tr>
            <tr>
              <td>
                `\\\\`
              </td>
              <td>
                `0x005C`
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\`
              </td>
            </tr>
          </table>
        </emu-table>
        <ul>
          <li><emu-grammar>NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator</emu-grammar> SV = UTF16EncodeCodePoint 결과.</li>
          <li><emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> SV = |LegacyOctalEscapeSequence| MV 값 코드 유닛.</li>
          <li><emu-grammar>NonOctalDecimalEscapeSequence :: `8`</emu-grammar> SV = 코드 유닛 0x0038.</li>
          <li><emu-grammar>NonOctalDecimalEscapeSequence :: `9`</emu-grammar> SV = 코드 유닛 0x0039.</li>
          <li><emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> SV = MV 에 해당 코드 유닛.</li>
          <li><emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> SV = MV 코드 유닛.</li>
          <li><emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> SV = |CodePoint| MV UTF16EncodeCodePoint.</li>
          <li><emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> SV = 코드 유닛 0x0000.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-string-literals-static-semantics-mv">
        <h1>정적 의미론: MV</h1>
        <ul>
          <li><emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit</emu-grammar> MV = (8 × |ZeroToThree| MV) + |OctalDigit| MV.</li>
          <li><emu-grammar>LegacyOctalEscapeSequence :: FourToSeven OctalDigit</emu-grammar> MV = (8 × |FourToSeven| MV) + |OctalDigit| MV.</li>
          <li><emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit</emu-grammar> MV = (64 × |ZeroToThree| MV) + (8 × 첫 |OctalDigit| MV) + 둘째 |OctalDigit| MV.</li>
          <li><emu-grammar>ZeroToThree :: `0`</emu-grammar> MV = 0.</li>
          <li><emu-grammar>ZeroToThree :: `1`</emu-grammar> MV = 1. (2,3 동일 패턴)</li>
          <li><emu-grammar>FourToSeven :: `4`</emu-grammar> MV = 4. (5,6,7 동일 패턴)</li>
          <li><emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> MV = (16 × 첫 |HexDigit| MV) + 둘째 |HexDigit| MV.</li>
          <li><emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> MV = (0x1000 × 첫) + (0x100 × 둘째) + (0x10 × 셋째) + 넷째.</li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-regular-expression-literals">
      <h1>정규 표현식 리터럴(Regular Expression Literals)</h1>
      <emu-note>
        <p>정규 표현식 리터럴은 평가될 때마다 RegExp 객체 (<emu-xref href="#sec-regexp-regular-expression-objects"></emu-xref>) 로 변환되는 입력 요소이다. 동일한 내용을 가진 두 리터럴이라도 서로 `===` 비교에서 같지 않다. 런타임에 `new RegExp` 또는 RegExp 생성자 호출 (<emu-xref href="#sec-regexp-constructor"></emu-xref>) 로도 생성할 수 있다.</p>
      </emu-note>
      <p>아래 생성물은 정규 표현식 리터럴의 구문을 기술하며 입력 요소 스캐너가 리터럴 끝을 찾는 데 사용된다. |RegularExpressionBody| 와 |RegularExpressionFlags| 를 이루는 소스 텍스트는 이후 더 엄격한 ECMAScript 정규식 문법 (<emu-xref href="#sec-patterns"></emu-xref>) 으로 다시 파싱된다.</p>
      <p>구현은 <emu-xref href="#sec-patterns"></emu-xref> 의 ECMAScript 정규식 문법을 확장할 수 있으나 아래 |RegularExpressionBody|, |RegularExpressionFlags| 생성물 및 그 종속 생성물은 확장할 수 없다.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        RegularExpressionLiteral ::
          `/` RegularExpressionBody `/` RegularExpressionFlags

        RegularExpressionBody ::
          RegularExpressionFirstChar RegularExpressionChars

        RegularExpressionChars ::
          [empty]
          RegularExpressionChars RegularExpressionChar

        RegularExpressionFirstChar ::
          RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionChar ::
          RegularExpressionNonTerminator but not one of `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionBackslashSequence ::
          `\` RegularExpressionNonTerminator

        RegularExpressionNonTerminator ::
          SourceCharacter but not LineTerminator

        RegularExpressionClass ::
          `[` RegularExpressionClassChars `]`

        RegularExpressionClassChars ::
          [empty]
          RegularExpressionClassChars RegularExpressionClassChar

        RegularExpressionClassChar ::
          RegularExpressionNonTerminator but not one of `]` or `\`
          RegularExpressionBackslashSequence

        RegularExpressionFlags ::
          [empty]
          RegularExpressionFlags IdentifierPartChar
      </emu-grammar>
      <emu-note>
        <p>정규 표현식 리터럴은 비어 있을 수 없다. `//` 는 빈 정규식이 아니라 단일 행 주석 시작이다. 빈 정규식을 지정하려면 `/(?:)/` 사용.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-bodytext" type="sdo">
        <h1>정적 의미론: BodyText ( ): 소스 텍스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. |RegularExpressionBody| 로 인식된 소스 텍스트 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-flagtext" type="sdo">
        <h1>정적 의미론: FlagText ( ): 소스 텍스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. |RegularExpressionFlags| 로 인식된 소스 텍스트 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literal-lexical-components">
      <h1>템플릿 리터럴 어휘 구성 요소(Template Literal Lexical Components)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Template ::
          NoSubstitutionTemplate
          TemplateHead

        NoSubstitutionTemplate ::
          ``` TemplateCharacters? ```

        TemplateHead ::
          ``` TemplateCharacters? `${`

        TemplateSubstitutionTail ::
          TemplateMiddle
          TemplateTail

        TemplateMiddle ::
          `}` TemplateCharacters? `${`

        TemplateTail ::
          `}` TemplateCharacters? ```

        TemplateCharacters ::
          TemplateCharacter TemplateCharacters?

        TemplateCharacter ::
          `$` [lookahead != `{`]
          `\` TemplateEscapeSequence
          `\` NotEscapeSequence
          LineContinuation
          LineTerminatorSequence
          SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

        TemplateEscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          UnicodeEscapeSequence

        NotEscapeSequence ::
          `0` DecimalDigit
          DecimalDigit but not `0`
          `x` [lookahead &notin; HexDigit]
          `x` HexDigit [lookahead &notin; HexDigit]
          `u` [lookahead &notin; HexDigit] [lookahead != `{`]
          `u` HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` `{` [lookahead &notin; HexDigit]
          `u` `{` NotCodePoint [lookahead &notin; HexDigit]
          `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]

        NotCodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| > 0x10FFFF]

        CodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| &le; 0x10FFFF]
      </emu-grammar>
      <emu-note>
        <p>|TemplateSubstitutionTail| 은 |InputElementTemplateTail| 대안 어휘 목표에서 사용된다.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-tv" type="sdo" oldids="sec-static-semantics-tv-and-trv">
        <h1>정적 의미론: TV ( ): String 또는 *undefined*</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>템플릿 리터럴 구성 요소는 TV 에 의해 String 타입 값으로 해석된다(TV 는 템플릿 객체의 인덱스된 값 목록—template values—구성에 사용). TV 에서는 이스케이프 시퀀스가 해당 유니코드 코드 포인트의 UTF-16 코드 유닛(들)로 치환된다.</dd>
        </dl>
        <ul>
          <li><emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateHead :: ``` `${`</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateTail :: `}` ```</emu-grammar> TV = 빈 문자열.</li>
          <li><emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> TV 는 어느 하나라도 *undefined* 이면 *undefined*, 아니면 둘의 문자열 연결.</li>
          <li><emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> TV = UTF16EncodeCodePoint 결과.</li>
          <li><emu-grammar>TemplateCharacter :: `$`</emu-grammar> TV = 코드 유닛 0x0024.</li>
          <li><emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> TV = |TemplateEscapeSequence| SV.</li>
          <li><emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> TV = *undefined*.</li>
          <li><emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> TV = |LineTerminatorSequence| TRV.</li>
          <li><emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> TV = 빈 문자열.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-trv" type="sdo">
        <h1>정적 의미론: TRV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>템플릿 리터럴 구성 요소는 TRV 에 의해 String 값으로 해석(템플릿 raw 값 구성). TRV 는 TV 와 유사하지만 이스케이프 시퀀스를 그대로(문자열 상 표기 그대로) 반영한다.</dd>
        </dl>
        <ul>
          <li>
            The TRV of <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateTail :: `}` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> is the string-concatenation of the TRV of |TemplateCharacter| and the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `$`</emu-grammar> is the String value consisting of the code unit 0x0024 (DOLLAR SIGN).
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |TemplateEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |NotEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> is the String value consisting of the code unit 0x0030 (DIGIT ZERO).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `0` DecimalDigit</emu-grammar> is the string-concatenation of the code unit 0x0030 (DIGIT ZERO) and the TRV of |DecimalDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` [lookahead &notin; HexDigit]</emu-grammar> is the String value consisting of the code unit 0x0078 (LATIN SMALL LETTER X).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X) and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` [lookahead &notin; HexDigit] [lookahead != `{`]</emu-grammar> is the String value consisting of the code unit 0x0075 (LATIN SMALL LETTER U).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first |HexDigit|, and the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first |HexDigit|, the TRV of the second |HexDigit|, and the TRV of the third |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the code unit 0x007B (LEFT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` NotCodePoint [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of |NotCodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of |CodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>DecimalDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> is the SV of |NonEscapeCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>SingleEscapeCharacter :: one of `'` `"` `\` `b` `f` `n` `r` `t` `v`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is the string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X), the TRV of the first |HexDigit|, and the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of |Hex4Digits|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), the TRV of |CodePoint|, and the code unit 0x007D (RIGHT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is the string-concatenation of the TRV of the first |HexDigit|, the TRV of the second |HexDigit|, the TRV of the third |HexDigit|, and the TRV of the fourth |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> is the string-concatenation of the TRV of |HexDigits| and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LF&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LS&gt;</emu-grammar> is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;PS&gt;</emu-grammar> is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt; &lt;LF&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
        </ul>
        <emu-note>
          <p>TV 는 |LineContinuation| 의 코드 유닛을 제외하지만 TRV 는 포함한다. &lt;CR>&lt;LF>, &lt;CR> 줄 종결 시퀀스는 TV 와 TRV 모두에서 &lt;LF> 로 정규화된다. &lt;CR> 또는 &lt;CR>&lt;LF> 를 원형(raw) 그대로 포함하려면 명시적 |TemplateEscapeSequence| 가 필요하다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>자동 세미콜론 삽입(Automatic Semicolon Insertion)</h1>
    <p>대부분의 ECMAScript 문과 선언은 세미콜론으로 종료되어야 하며, 그 세미콜론은 항상 소스에 명시적으로 쓸 수 있다. 편의를 위해 특정 상황에서는 세미콜론을 생략할 수 있으며, 이 상황에서는 세미콜론이 소스 코드 토큰 스트림에 자동 삽입된다고 기술한다.</p>

    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace="asi-rules">
      <h1>자동 세미콜론 삽입 규칙(Rules of Automatic Semicolon Insertion)</h1>
      <p>다음 규칙에서 “토큰(token)” 은 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref> 에 설명된 현재 어휘 목표 심볼을 사용해 실제로 인식된 어휘 토큰을 뜻한다.</p>
      <p>세 가지 기본 규칙은 다음과 같다:</p>
      <ol>
        <li>
          <p>왼쪽에서 오른쪽으로 파싱 중 문법의 어떤 생성물에도 허용되지 않는 토큰(“오류 토큰(offending token)”)을 만났을 때, 아래 조건 중 하나 이상이 참이면 그 토큰 앞에 세미콜론을 자동 삽입한다:</p>
          <ul>
            <li>오류 토큰이 이전 토큰과 하나 이상의 |LineTerminator| 로 분리되어 있음.</li>
            <li>오류 토큰이 `}` 임.</li>
            <li>이전 토큰이 `)` 이고 삽입된 세미콜론이 do-while 문(<emu-xref href="#sec-do-while-statement"></emu-xref>) 종료 세미콜론으로 파싱될 수 있음.</li>
          </ul>
        </li>
        <li>
          입력 토큰 스트림 끝에 도달했고 파서가 목표 비단말의 단일 인스턴스로 파싱할 수 없다면 입력 스트림 끝에 세미콜론을 자동 삽입.
        </li>
        <li>
          문법 생성물 중 <em>제한 생성물(restricted production)</em> 에 허용되는 토큰이지만 생성물 내 “[no |LineTerminator| here]” 주석 바로 뒤 등장할 수 있는 첫 토큰(제한 토큰)이며 그 제한 토큰이 이전 토큰과 하나 이상의 |LineTerminator| 로 분리되어 있다면 제한 토큰 앞에 세미콜론 자동 삽입.
        </li>
      </ol>
      <p>그러나 추가 최우선 조건이 있다: 세미콜론이 빈 문(empty statement)으로 파싱되거나 `for` 문의 두 세미콜론 중 하나가 되게 하는 경우에는 자동 삽입되지 않는다 (<emu-xref href="#sec-for-statement"></emu-xref> 참조).</p>
      <emu-note>
        <p>문법 내 유일한 제한 생성물은 다음과 같다:</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          YieldExpression[In, Await] :
            `yield`
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

          AsyncFunctionDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
            [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncFunctionExpression :
            `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncMethod[Yield, Await] :
            `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncGeneratorDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
            [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorExpression :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorMethod[Yield, Await] :
            `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncArrowFunction[In, Yield, Await] :
            `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
            CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

          AsyncArrowHead :
            `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
        </emu-grammar>
        <p>실질적 효과:</p>
        <ul>
          <li>`++` / `--` 가 후위(postfix)로 해석될 위치에서 그 앞에 |LineTerminator| 가 있으면 앞에 세미콜론 삽입.</li>
          <li>`continue`, `break`, `return`, `throw`, `yield` 뒤에 |LineTerminator| 있으면 해당 토큰 뒤에 세미콜론 삽입.</li>
          <li>화살표 함수 매개변수 끝과 `=>` 사이에 |LineTerminator| 있으면 세미콜론 삽입 후 구문 오류.</li>
          <li>`async` 뒤 `function` / 식별자 / `(` 전에 |LineTerminator| 있으면 세미콜론 삽입, 이후 토큰과 같은 구성요소로 간주되지 않음.</li>
          <li>`async` 뒤 `*` 전에 |LineTerminator| 있으면 세미콜론 삽입 후 구문 오류.</li>
        </ul>
        <p>프로그래머를 위한 요약:</p>
        <ul>
          <li>후위 `++` / `--` 는 피연산자와 같은 줄에 둔다.</li>
          <li>`return`, `throw`, `yield` 뒤 표현식은 같은 줄에서 시작.</li>
          <li>`break`, `continue` 뒤 |LabelIdentifier| 는 같은 줄.</li>
          <li>화살표 함수 매개변수와 `=>` 는 같은 줄.</li>
          <li>비동기 함수/메서드 앞 `async` 는 바로 뒤 토큰과 같은 줄.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>자동 세미콜론 삽입 예(Examples of Automatic Semicolon Insertion)</h1>
      <em>본 절은 비규범적이다.</em>
      <p>다음 소스</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>는 자동 삽입 규칙이 있어도 유효한 ECMAScript 문장이 아니다. 반면:</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>역시 유효하지 않지만 자동 삽입으로 다음으로 변환된다:</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>이는 유효한 문장이다.</p>
      <p>다음 소스</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>는 유효하지 않으며 `for` 문 헤더 세미콜론은 자동 삽입되지 않으므로 변경되지 않는다.</p>
      <p>다음 소스</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>는 다음으로 변환된다:</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>`a + b` 는 |LineTerminator| 로 인해 `return` 반환 값이 아니다.</p>
      </emu-note>
      <p>다음 소스</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>는 다음으로 변환된다:</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>`++` 는 `b` 의 후위 연산자가 아니다 (줄 종결자 존재).</p>
      </emu-note>
      <p>다음 소스</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>는 유효하지 않으며 `else` 앞에 자동 삽입되지 않는다 (그 위치 삽입 시 빈 문 생성).</p>
      <p>다음 소스</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p>는 변환되지 않는다. 괄호로 시작하는 두 번째 줄은 함수 호출 인수 목록으로 해석될 수 있기 때문이다:</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>할당문이 왼쪽 괄호로 시작해야 한다면 이전 문 끝에 명시적으로 세미콜론을 쓰는 것이 좋다.</p>
    </emu-clause>

    <emu-clause id="sec-interesting-cases-of-automatic-semicolon-insertion">
      <h1>흥미로운 자동 세미콜론 삽입 사례(Interesting Cases of Automatic Semicolon Insertion)</h1>
      <em>본 절은 비규범적이다.</em>
      <p>프로그래머는 자동 세미콜론 삽입에 의존하여 매우 적은 세미콜론으로 프로그램을 작성할 수 있다. 위에서 설명했듯 세미콜론은 모든 줄바꿈마다 삽입되지 않으며 줄 종결자를 넘어 여러 토큰에 의존할 수 있다.</p>

      <p>새 구문 기능이 추가되면서 기존 자동 삽입에 의존하던 줄이 다른 방식으로 파싱될 수 있는 추가 생성물이 도입될 수 있다.</p>

      <p>이 절에서는 앞선 소스 텍스트에 따라 세미콜론이 삽입될 수도/안 될 수도 있는 위치를 ‘흥미로운’ 사례로 본다. 이하에서는 이 ECMAScript 버전의 그러한 사례들을 기술한다.</p>

      <emu-clause id="sec-asi-interesting-cases-in-statement-lists">
        <h1>문 목록에서의 흥미로운 사례(Statement Lists)</h1>
        <p>|StatementList| 에서 다수 |StatementListItem| 은 세미콜론으로 끝나며 자동 삽입으로 생략 가능하다. 그 결과 표현식이 끝나는 줄의 다음 줄이 아래 중 하나로 시작하면 끝에 세미콜론이 필요하다:</p>
        <ul>
          <li><strong>여는 괄호 (<code>(</code>)</strong>: 없으면 두 줄이 |CallExpression| 으로 결합.</li>
          <li><strong>여는 대괄호 (<code>[</code>)</strong>: 없으면 속성 접근으로 간주 (|ArrayLiteral| 또는 |ArrayAssignmentPattern| 아님).</li>
          <li><strong>템플릿 리터럴 (<code>`</code>)</strong>: 없으면 태그드 템플릿으로 해석(앞 표현식이 |MemberExpression|).</li>
          <li><strong>단항 <code>+</code> 또는 <code>-</code></strong>: 없으면 이항 연산 조합으로 해석될 수 있음.</li>
          <li><strong>정규 표현식 리터럴</strong>: 없으면 `/` 가 |MultiplicativeOperator| 로 해석될 여지.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-asi-cases-with-no-lineterminator-here">
        <h1>“[no |LineTerminator| here]” 관련 사례</h1>
        <em>본 절은 비규범적이다.</em>
        <p>ECMAScript 는 “[no |LineTerminator| here]” 를 포함하는 문법 생성물을 가진다. 이는 종종 문법에서 선택적 피연산자를 두기 위한 수단이다. 해당 위치에 |LineTerminator| 를 넣으면 선택적 피연산자가 없는 다른 생성물로 해석이 바뀐다.</p>

        <p>이 절의 나머지 부분은 본 ECMAScript 버전의 이러한 생성물 사례들을 나열한다.</p>

        <emu-clause id="sec-no-lineterminator-here-automatic-semicolon-insertion-list">
          <h1>선택적 피연산자와 “[no |LineTerminator| here]” 를 가진 생성물 목록</h1>
          <ul>
            <li>|UpdateExpression|.</li>
            <li>|ContinueStatement|.</li>
            <li>|BreakStatement|.</li>
            <li>|ReturnStatement|.</li>
            <li>|YieldExpression|.</li>
            <li>Async Function Definitions ( <emu-xref href="#sec-async-function-definitions"></emu-xref> ) 과 Function Definitions (<emu-xref href="#sec-function-definitions"></emu-xref>) 관계.</li>
          </ul>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript 언어: 표현식(Expressions)</h1>

  <emu-clause id="sec-identifiers">
    <h1>식별자(Identifiers)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IdentifierReference[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      BindingIdentifier[Yield, Await] :
        Identifier
        `yield`
        `await`

      LabelIdentifier[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      Identifier :
        IdentifierName but not ReservedWord
    </emu-grammar>

    <emu-note>
      <p>`yield` 와 `await` 는 문법상 |BindingIdentifier| 로 허용되며, 아래 정적 의미론에서 금지되어 다음과 같은 경우의 자동 세미콜론 삽입을 막는다:</p>
      <pre><code class="javascript">
        let
        await 0;
      </code></pre>
    </emu-note>

    <emu-clause id="sec-identifiers-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Early Errors)</h1>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <ul>
        <li>
          IsStrict(this production) 가 *true* 이고 |Identifier| 의 StringValue 가 *"arguments"* 또는 *"eval"* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(this production) 가 *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          구문 문법의 목표 심볼이 |Module| 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `yield`
      </emu-grammar>
      <ul>
        <li>
          이 생성물이 <sub>[Yield]</sub> 매개변수를 가지면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `await`
      </emu-grammar>
      <ul>
        <li>
          이 생성물이 <sub>[Await]</sub> 매개변수를 가지면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference[Yield, Await] : Identifier

        BindingIdentifier[Yield, Await] : Identifier

        LabelIdentifier[Yield, Await] : Identifier
      </emu-grammar>
      <ul>
        <li>
          이 생성물이 <sub>[Yield]</sub> 매개변수를 가지고 |Identifier| 의 StringValue 가 *"yield"* 이면 Syntax Error.
        </li>
        <li>
          이 생성물이 <sub>[Await]</sub> 매개변수를 가지고 |Identifier| 의 StringValue 가 *"await"* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <ul>
        <li>
          IsStrict(this phrase) 가 *true* 이고 |IdentifierName| 의 StringValue 가 *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"*, *"yield"* 중 하나이면 Syntax Error.
        </li>
        <li>
          구문 문법의 목표 심볼이 |Module| 이고 |IdentifierName| 의 StringValue 가 *"await"* 이면 Syntax Error.
        </li>
        <li>
          |IdentifierName| 의 StringValue 가 `yield`, `await` 를 제외한 어느 |ReservedWord| 의 StringValue 와 같으면 Syntax Error.
        </li>
      </ul>
      <emu-note>
        <p>|IdentifierName| 의 StringValue 는 |IdentifierName| 내 유니코드 escape 시퀀스를 정규화하므로, 그러한 escape 로 |ReservedWord| 와 동일한 코드 포인트 시퀀스를 가진 |Identifier| 를 작성할 수 없다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-stringvalue" oldids="sec-identifiers-static-semantics-stringvalue,sec-identifier-names-static-semantics-stringvalue" type="sdo">
      <h1>정적 의미론: StringValue ( ): String</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        IdentifierName ::
          IdentifierStart
          IdentifierName IdentifierPart
      </emu-grammar>
      <emu-alg>
        1. _idTextUnescaped_ 를 |IdentifierName| 의 IdentifierCodePoints 로 둔다.
        1. CodePointsToString(_idTextUnescaped_) 를 반환한다.
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <emu-alg>
        1. *"yield"* 를 반환한다.
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <emu-alg>
        1. *"await"* 를 반환한다.
      </emu-alg>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <emu-alg>
        1. |IdentifierName| 의 StringValue 를 반환한다.
      </emu-alg>
      <emu-grammar>
        PrivateIdentifier ::
          `#` IdentifierName
      </emu-grammar>
      <emu-alg>
        1. 0x0023 (NUMBER SIGN) 과 |IdentifierName| 의 StringValue 의 문자열 연결을 반환한다.
      </emu-alg>
      <emu-grammar>
        ModuleExportName : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. |StringLiteral| 의 SV 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Evaluation)</h1>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(StringValue of |Identifier|) 를 반환한다.
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(*"yield"*) 를 반환한다.
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. ? ResolveBinding(*"await"*) 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|IdentifierReference| 평가 결과는 항상 Reference 타입 값이다.</p>
      </emu-note>
      <emu-note>
        <p>비 strict 코드에서 키워드 `yield` 는 식별자로 사용할 수 있다. |IdentifierReference| 평가 시 `yield` 바인딩을 |Identifier| 처럼 해석한다. 조기 오류 제한이 그러한 평가가 비 strict 코드에서만 일어날 수 있게 보장한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-primary-expression">
    <h1>기본 표현식(Primary Expression)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        AsyncGeneratorExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await, ~Tagged]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>보충 문법(Supplemental Syntax)</h2>
    <p>
      다음 생성물 인스턴스를 처리할 때<br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      |CoverParenthesizedExpressionAndArrowParameterList| 의 해석은 아래 문법을 사용해 정밀화된다:
    </p>
    <emu-grammar type="definition">
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-this-keyword">
      <h1>`this` 키워드(The `this` Keyword)</h1>

      <emu-clause id="sec-this-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. ? ResolveThisBinding() 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifier-reference">
      <h1>식별자 참조(Identifier Reference)</h1>
      <p>|IdentifierReference| 는 <emu-xref href="#sec-identifiers"></emu-xref> 를 참조.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-literals">
      <h1>리터럴(Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Literal :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-literals-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>Literal : NullLiteral</emu-grammar>
        <emu-alg>
          1. *null* 을 반환한다.
        </emu-alg>
        <emu-grammar>Literal : BooleanLiteral</emu-grammar>
        <emu-alg>
          1. |BooleanLiteral| 이 토큰 `false` 이면 *false* 반환.
          1. |BooleanLiteral| 이 토큰 `true` 이면 *true* 반환.
        </emu-alg>
        <emu-grammar>Literal : NumericLiteral</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 에 정의된 |NumericLiteral| 의 NumericValue 를 반환한다.
        </emu-alg>
        <emu-grammar>Literal : StringLiteral</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-static-semantics-sv"></emu-xref> 에 정의된 |StringLiteral| 의 SV 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-initializer">
      <h1>배열 이니셜라이저(Array Initializer)</h1>
      <emu-note>
        <p>|ArrayLiteral| 은 0 개 이상 표현식(각각 배열 요소를 나타냄) 리스트를 대괄호로 둘러 배열 초기화를 기술하는 표현식이다. 요소는 리터럴일 필요가 없으며 배열 이니셜라이저가 평가될 때마다 평가된다.</p>
      </emu-note>
      <p>배열 요소는 목록의 시작·중간·끝에서 생략(elide)될 수 있다. 요소 목록에서 쉼표 앞에 |AssignmentExpression| 이 없을 때(즉, 시작의 쉼표나 또 다른 쉼표 뒤) 빠진 요소는 배열 length 에 기여하며 이후 요소의 인덱스를 증가시킨다. 생략된 요소는 정의되지 않는다. 배열 끝에서 생략된 요소는 length 에 기여하지 않는다.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]
          Elision? SpreadElement[?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-arrayaccumulation" oldids="sec-static-semantics-elisionwidth" type="sdo">
        <h1>
          런타임 의미론: ArrayAccumulation (
          _array_: an Array,
          _nextIndex_: an integer,
          ): 정상 완료 시 정수 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. _len_ 을 _nextIndex_ + 1 로 둔다.
          1. ? Set(_array_, *"length"*, 𝔽(_len_), *true*) 수행.
          1. NOTE: _len_ 이 2<sup>32</sup> - 1 을 초과하면 위 단계는 throw.
          1. _len_ 을 반환한다.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. |Elision| 의 ArrayAccumulation 을 (_array_, (_nextIndex_ + 1)) 인수로 호출한 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ElementList : Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. _initResult_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _initValue_ 를 ? GetValue(_initResult_) 로 둔다.
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_) 수행.
          1. _nextIndex_ + 1 반환.
        </emu-alg>
        <emu-grammar>ElementList : Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |SpreadElement| 의 ArrayAccumulation(_array_, _nextIndex_) 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _nextIndex_ 를 |ElementList| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. _initResult_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _initValue_ 를 ? GetValue(_initResult_) 로 둔다.
          1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_) 수행.
          1. _nextIndex_ + 1 반환.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. _nextIndex_ 를 |ElementList| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |Elision| 이 존재하면
            1. _nextIndex_ 를 |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 결과로 설정 (?).
          1. |SpreadElement| 의 ArrayAccumulation(_array_, _nextIndex_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>SpreadElement : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _spreadRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _spreadObj_ 를 ? GetValue(_spreadRef_) 로 둔다.
          1. _iteratorRecord_ 를 ? GetIterator(_spreadObj_, ~sync~) 로 둔다.
          1. 반복,
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이면 _nextIndex_ 반환.
            1. ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_) 수행.
            1. _nextIndex_ 를 _nextIndex_ + 1 로 설정.
        </emu-alg>
        <emu-note>
          <p>CreateDataPropertyOrThrow 는 표준 내장 Array 프로토타입이 [[Set]] 으로 새로운 자체 프로퍼티 생성을 막도록 수정된 경우에도 자체 프로퍼티 정의를 보장하기 위해 사용된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>ArrayLiteral : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. _array_ 를 ! ArrayCreate(0) 로 둔다.
          1. |Elision| 이 존재하면
            1. |Elision| 의 ArrayAccumulation(_array_, 0) 를 ? 로 수행.
          1. _array_ 반환.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `]`</emu-grammar>
        <emu-alg>
          1. _array_ 를 ! ArrayCreate(0) 로 둔다.
          1. |ElementList| 의 ArrayAccumulation(_array_, 0) 를 ? 로 수행.
          1. _array_ 반환.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. _array_ 를 ! ArrayCreate(0) 로 둔다.
          1. _nextIndex_ 를 |ElementList| 의 ArrayAccumulation(_array_, 0) 결과 (?) 로 둔다.
          1. |Elision| 이 존재하면
            1. |Elision| 의 ArrayAccumulation(_array_, _nextIndex_) 를 ? 로 수행.
          1. _array_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>객체 이니셜라이저(Object Initializer)</h1>
      <emu-note>
        <p>객체 이니셜라이저는 리터럴과 유사한 형태로 객체 초기화를 기술하는 표현식이다. 중괄호로 둘러싸인 0 개 이상 (프로퍼티 키, 값) 쌍 목록이며 값은 리터럴일 필요가 없고 이니셜라이저 평가 시마다 평가된다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| 은 <emu-xref href="#sec-method-definitions"></emu-xref> 에 정의되어 있다.</p>
      </emu-note>
      <emu-note>
        <p>특정 문맥에서 |ObjectLiteral| 은 더 제한된 2차 문법을 덮는 cover 문법으로 사용된다. |CoverInitializedName| 생성물은 이러한 2차 문법을 완전히 덮기 위해 필요하다. 그러나 이 생성물 사용은 실제 |ObjectLiteral| 이 기대되는 일반 문맥에서 조기 Syntax Error 를 발생시킨다.</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors" oldids="sec-__proto__-property-names-in-object-initializers">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            HasDirectSuper(|MethodDefinition|) 가 *true* 이면 Syntax Error.
          </li>
          <li>
            |MethodDefinition| 의 PrivateBoundIdentifiers 가 비어있지 않으면 Syntax Error.
          </li>
        </ul>
        <p>실제 객체 이니셜라이저를 기술하는 것 외에도 |ObjectLiteral| 생성물은 |ObjectAssignmentPattern| 의 cover 문법으로 사용될 수 있으며 |CoverParenthesizedExpressionAndArrowParameterList| 의 일부로 인식될 수 있다. |ObjectLiteral| 이 |ObjectAssignmentPattern| 이 필요한 문맥에 나타나면 아래 Early Error 규칙은 적용되지 <b>않는다</b>. 또한 초기 |CoverParenthesizedExpressionAndArrowParameterList| 또는 |CoverCallExpressionAndAsyncArrowHead| 파싱 시에도 적용되지 않는다.</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            이 생성물이 어떤 소스 텍스트를 매칭하면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p>이 생성물은 |ObjectLiteral| 이 |ObjectAssignmentPattern| 의 cover 문법이 되도록 존재한다. 실제 객체 이니셜라이저에는 나타날 수 없다.</p>
        </emu-note>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <ul>
          <li>
            |PropertyDefinitionList| 의 PropertyNameList 가 *"__proto__"* 에 대한 중복 항목을 포함하고 그 중 둘 이상이 <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar> 형태 생성물에서 얻어진 경우 Syntax Error. 이 규칙은 이 |ObjectLiteral| 이 ParseJSON 용으로 파싱 중인 |Script| 에 포함된 경우 (ParseJSON 의 단계 <emu-xref href="#step-json-parse-parse"></emu-xref> 참조) 적용되지 않는다.
          </li>
        </ul>
        <emu-note>
          <p>PropertyNameList 가 반환한 List 는 |ComputedPropertyName| 으로 정의된 프로퍼티 이름을 포함하지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-iscomputedpropertykey" type="sdo">
        <h1>정적 의미론: IsComputedPropertyKey ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-propertynamelist" type="sdo">
        <h1>정적 의미론: PropertyNameList ( ): String 들의 List</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinition</emu-grammar>
        <emu-alg>
          1. _propName_ 을 |PropertyDefinition| 의 PropName 으로 둔다.
          1. _propName_ 이 ~empty~ 이면 새 빈 List 반환.
          1. « _propName_ » 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. _list_ 를 |PropertyDefinitionList| 의 PropertyNameList 로 둔다.
          1. _propName_ 을 |PropertyDefinition| 의 PropName 으로 둔다.
          1. _propName_ 이 ~empty~ 이면 _list_ 반환.
          1. _list_ 와 « _propName_ » 의 리스트 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>ObjectLiteral : `{` `}`</emu-grammar>
        <emu-alg>
          1. OrdinaryObjectCreate(%Object.prototype%) 반환.
        </emu-alg>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. |PropertyDefinitionList| 의 PropertyDefinitionEvaluation(_obj_) 를 ? 로 수행.
          1. _obj_ 반환.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. |IdentifierName| 의 StringValue 반환.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. |StringLiteral| 의 SV 반환.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. _nbr_ 을 |NumericLiteral| 의 NumericValue 로 둔다.
          1. ! ToString(_nbr_) 반환.
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. _exprValue_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _propName_ 을 ? GetValue(_exprValue_) 로 둔다.
          1. ? ToPropertyKey(_propName_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydefinitionevaluation" oldids="sec-object-initializer-runtime-semantics-propertydefinitionevaluation" type="sdo">
        <h1>
          런타임 의미론: PropertyDefinitionEvaluation (
          _object_: an Object,
          ): ~unused~ 를 담는 정상 완료 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. |PropertyDefinitionList| 의 PropertyDefinitionEvaluation(_object_) 를 ? 로 수행.
          1. |PropertyDefinition| 의 PropertyDefinitionEvaluation(_object_) 를 ? 로 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _exprValue_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _fromValue_ 를 ? GetValue(_exprValue_) 로 둔다.
          1. _excludedNames_ 를 새 빈 List 로 둔다.
          1. ? CopyDataProperties(_object_, _fromValue_, _excludedNames_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. _propName_ 을 |IdentifierReference| 의 StringValue 로 둔다.
          1. _exprValue_ 를 |IdentifierReference| Evaluation 결과 (?) 로 둔다.
          1. _propValue_ 를 ? GetValue(_exprValue_) 로 둔다.
          1. 단언: _object_ 는 비구성 불가능한 프로퍼티가 없는 보통의(extensible) 객체.
          1. ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _propKey_ 를 |PropertyName| Evaluation 결과 (?) 로 둔다.
          1. 이 |PropertyDefinition| 이 ParseJSON 평가 중인 |Script| 에 포함 (ParseJSON 단계 <emu-xref href="#step-json-parse-eval"></emu-xref>) 이면
            1. _isProtoSetter_ 를 *false* 로 둔다.
          1. Else if _propKey_ 가 *"__proto__"* 이고 |PropertyName| 의 IsComputedPropertyKey 가 *false* 이면
            1. _isProtoSetter_ 를 *true* 로 둔다.
          1. Else,
            1. _isProtoSetter_ 를 *false* 로 둔다.
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 _isProtoSetter_ 가 *false* 이면
            1. _propValue_ 를 |AssignmentExpression| 의 NamedEvaluation(_propKey_) 결과 (?) 로 둔다.
          1. Else,
            1. _exprValueRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
            1. _propValue_ 를 ? GetValue(_exprValueRef_) 로 둔다.
          1. _isProtoSetter_ 가 *true* 이면
            1. _propValue_ 가 Object 이거나 *null* 이면
              1. ! <emu-meta effects="user-code">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_) 수행.
            1. ~unused~ 반환.
          1. 단언: _object_ 는 비구성 불가능한 프로퍼티가 없는 보통의 확장 가능한 객체.
          1. ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <emu-alg>
          1. |MethodDefinition| 의 MethodDefinitionEvaluation(_object_, *true*) 를 ? 로 수행.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-defining-expressions">
      <h1>함수 정의 표현식(Function Defining Expressions)</h1>
      <p><emu-grammar>PrimaryExpression : FunctionExpression</emu-grammar> 은 <emu-xref href="#sec-function-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : GeneratorExpression</emu-grammar> 은 <emu-xref href="#sec-generator-function-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : ClassExpression</emu-grammar> 은 <emu-xref href="#sec-class-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : AsyncFunctionExpression</emu-grammar> 은 <emu-xref href="#sec-async-function-definitions"></emu-xref> 참조.</p>
      <p><emu-grammar>PrimaryExpression : AsyncGeneratorExpression</emu-grammar> 은 <emu-xref href="#sec-async-generator-function-definitions"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>정규 표현식 리터럴(Regular Expression Literals)</h1>
      <h2>Syntax</h2>
      <p><emu-xref href="#sec-literals-regular-expression-literals"></emu-xref> 참조.</p>

      <emu-clause id="sec-primary-expression-regular-expression-literals-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <ul>
          <li>
            IsValidRegularExpressionLiteral(|RegularExpressionLiteral|) 이 *false* 이면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-isvalidregularexpressionliteral" type="abstract operation">
        <h1>
          정적 의미론: IsValidRegularExpressionLiteral (
          _literal_: a |RegularExpressionLiteral| Parse Node,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>인수가 유효한 정규 표현식 리터럴인지 판정한다.</dd>
        </dl>
        <emu-alg>
          1. _flags_ 를 _literal_ 의 FlagText 로 둔다.
          1. _flags_ 가 `d`, `g`, `i`, `m`, `s`, `u`, `v`, `y` 이외 코드 포인트를 포함하거나 동일 코드 포인트를 중복 포함하면 *false* 반환.
          1. _flags_ 가 `u` 포함하면 _u_ = *true*, 아니면 *false*.
          1. _flags_ 가 `v` 포함하면 _v_ = *true*, 아니면 *false*.
          1. _patternText_ 를 _literal_ 의 BodyText 로 둔다.
          1. _u_ 가 *false* 이고 _v_ 가 *false* 이면
            1. _stringValue_ 를 CodePointsToString(_patternText_) 로 둔다.
            1. _stringValue_ 의 16비트 요소 각각을 유니코드 BMP 코드 포인트로 해석한 코드 포인트 시퀀스로 _patternText_ 재설정 (UTF-16 디코딩 미적용).
          1. _parseResult_ 를 ParsePattern(_patternText_, _u_, _v_) 로 둔다.
          1. _parseResult_ 가 Parse Node 이면 *true* 반환; 아니면 *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regular-expression-literals-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <emu-alg>
          1. _pattern_ 을 CodePointsToString(BodyText of |RegularExpressionLiteral|) 로 둔다.
          1. _flags_ 를 CodePointsToString(FlagText of |RegularExpressionLiteral|) 로 둔다.
          1. ! RegExpCreate(_pattern_, _flags_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literals">
      <h1>템플릿 리터럴(Template Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        TemplateLiteral[Yield, Await, Tagged] :
          NoSubstitutionTemplate
          SubstitutionTemplate[?Yield, ?Await, ?Tagged]

        SubstitutionTemplate[Yield, Await, Tagged] :
          TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

        TemplateSpans[Yield, Await, Tagged] :
          TemplateTail
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

        TemplateMiddleList[Yield, Await, Tagged] :
          TemplateMiddle Expression[+In, ?Yield, ?Await]
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-template-early-errors" oldids="sec-primary-expression-template-literals-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 매개변수가 설정되지 않았고 |NoSubstitutionTemplate| 가 |NotEscapeSequence| 를 포함하면 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            인수 *false* 로 한 |TemplateLiteral| 의 TemplateStrings 요소 수가 2<sup>32</sup> 이상이면 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 매개변수가 설정되지 않았고 |TemplateHead| 가 |NotEscapeSequence| 포함 시 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          TemplateSpans[Yield, Await, Tagged] : TemplateTail
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 미설정이고 |TemplateTail| 이 |NotEscapeSequence| 포함 시 Syntax Error.
          </li>
        </ul>

        <emu-grammar>
          TemplateMiddleList[Yield, Await, Tagged] :
            TemplateMiddle Expression[+In, ?Yield, ?Await]
            TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        </emu-grammar>
        <ul>
          <li>
            <sub>[Tagged]</sub> 미설정이고 |TemplateMiddle| 이 |NotEscapeSequence| 포함 시 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-templatestrings" type="sdo">
        <h1>
          정적 의미론: TemplateStrings (
          _raw_: Boolean,
          ): String 또는 *undefined* 요소들의 List
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. « TemplateString(|NoSubstitutionTemplate|, _raw_) » 반환.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _head_ 를 « TemplateString(|TemplateHead|, _raw_) » 로 둔다.
          1. _tail_ 을 |TemplateSpans| 의 TemplateStrings(_raw_) 로 둔다.
          1. _head_ 와 _tail_ 의 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. « TemplateString(|TemplateTail|, _raw_) » 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. _middle_ 을 |TemplateMiddleList| 의 TemplateStrings(_raw_) 로 둔다.
          1. _tail_ 을 « TemplateString(|TemplateTail|, _raw_) » 로 둔다.
          1. 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. « TemplateString(|TemplateMiddle|, _raw_) » 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _front_ 을 |TemplateMiddleList| 의 TemplateStrings(_raw_) 로 둔다.
          1. _last_ 를 « TemplateString(|TemplateMiddle|, _raw_) » 로 둔다.
          1. _front_ 와 _last_ 리스트 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-templatestring" type="abstract operation">
        <h1>
          정적 의미론: TemplateString (
          _templateToken_: |NoSubstitutionTemplate| / |TemplateHead| / |TemplateMiddle| / |TemplateTail| Parse Node,
          _raw_: Boolean,
          ): String 또는 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _raw_ 가 *true* 이면
            1. _string_ 을 _templateToken_ 의 TRV 로 둔다.
          1. Else
            1. _string_ 을 _templateToken_ 의 TV 로 둔다.
          1. _string_ 반환.
        </emu-alg>
        <emu-note>
          <p>_raw_ 가 *false* 이고 _templateToken_ 이 |NotEscapeSequence| 포함 시 *undefined* 반환. 그 외에는 String 반환.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-gettemplateobject" type="abstract operation">
        <h1>
          GetTemplateObject (
            _templateLiteral_: Parse Node,
          ): Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _realm_ 을 현재 Realm Record 로 둔다.
          1. _templateRegistry_ 를 _realm_.[[TemplateMap]] 로 둔다.
          1. _templateRegistry_ 의 각 요소 _e_ 에 대해
            1. _e_.[[Site]] 가 _templateLiteral_ 과 같은 Parse Node 이면
              1. _e_.[[Array]] 반환.
          1. _rawStrings_ 를 _templateLiteral_ 의 TemplateStrings(*true*) 로 둔다.
          1. 단언: _rawStrings_ 는 String 들의 List.
          1. _cookedStrings_ 를 _templateLiteral_ 의 TemplateStrings(*false*) 로 둔다.
          1. _count_ 를 _cookedStrings_ 요소 수로 둔다.
          1. 단언: _count_ ≤ 2<sup>32</sup> - 1.
          1. _template_ 를 ! ArrayCreate(_count_) 로 둔다.
          1. _rawObj_ 를 ! ArrayCreate(_count_) 로 둔다.
          1. _index_ 를 0 으로 둔다.
          1. _index_ &lt; _count_ 동안 반복,
            1. _prop_ 를 ! ToString(𝔽(_index_)) 로 둔다.
            1. _cookedValue_ 를 _cookedStrings_[_index_] 로 둔다.
            1. ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }) 수행.
            1. _rawValue_ 를 _rawStrings_[_index_] 의 String 값으로 둔다.
            1. ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }) 수행.
            1. _index_ 를 _index_ + 1 로 설정.
          1. ! SetIntegrityLevel(_rawObj_, ~frozen~) 수행.
          1. ! DefinePropertyOrThrow(_template_, *"raw"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
          1. ! SetIntegrityLevel(_template_, ~frozen~) 수행.
          1. Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } 를 _realm_.[[TemplateMap]] 에 추가.
          1. _template_ 반환.
        </emu-alg>
        <emu-note>
          <p>템플릿 객체 생성은 abrupt completion 을 일으킬 수 없다.</p>
        </emu-note>
        <emu-note>
          <p>한 realm 의 프로그램 코드 내 각 |TemplateLiteral| 은 태그드 템플릿 (<emu-xref href="#sec-template-literals-runtime-semantics-evaluation"></emu-xref>) 평가에 사용되는 고유한 템플릿 객체와 연관된다. 템플릿 객체는 freeze 되고 동일 템플릿이 평가될 때마다 같은 객체가 재사용된다. 지연 생성 또는 사전 생성 여부는 구현 선택이며 관측 불가.</p>
        </emu-note>
        <emu-note>
          <p>향후 판에서 템플릿 객체의 비열거(non-enumerable) 프로퍼티가 추가로 정의될 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-substitutionevaluation" type="sdo">
        <h1>런타임 의미론: SubstitutionEvaluation ( ): ECMAScript 값 List 를 담는 정상 완료 또는 abrupt completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. 새 빈 List 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. |TemplateMiddleList| 의 SubstitutionEvaluation 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. « _sub_ » 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _preceding_ 을 |TemplateMiddleList| 의 SubstitutionEvaluation 결과 (?) 로 둔다.
          1. _nextRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _next_ 를 ? GetValue(_nextRef_) 로 둔다.
          1. _preceding_ 과 « _next_ » 리스트 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |NoSubstitutionTemplate| 의 TV 반환.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _head_ 를 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateHead| 의 TV 로 둔다.
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. _middle_ 를 ? ToString(_sub_) 로 둔다.
          1. _tail_ 을 |TemplateSpans| Evaluation 결과 (?) 로 둔다.
          1. _head_, _middle_, _tail_ 의 문자열 연결 반환.
        </emu-alg>
        <emu-note>
          <p>|Expression| 값에 적용되는 문자열 변환 의미론은 `+` 연산자보다 `String.prototype.concat` 과 유사하다.</p>
        </emu-note>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateTail| 의 TV 반환.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. _head_ 를 |TemplateMiddleList| Evaluation 결과 (?) 로 둔다.
          1. _tail_ 을 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateTail| 의 TV 로 둔다.
          1. _head_ 와 _tail_ 문자열 연결 반환.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _head_ 를 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateMiddle| 의 TV 로 둔다.
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. _middle_ 를 ? ToString(_sub_) 로 둔다.
          1. _head_ 와 _middle_ 문자열 연결 반환.
        </emu-alg>
        <emu-note>
          <p>|Expression| 값의 문자열 변환은 `String.prototype.concat` 과 유사.</p>
        </emu-note>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. _rest_ 를 |TemplateMiddleList| Evaluation 결과 (?) 로 둔다.
          1. _middle_ 을 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 에 정의된 |TemplateMiddle| 의 TV 로 둔다.
          1. _subRef_ 를 |Expression| Evaluation 결과 (?) 로 둔다.
          1. _sub_ 를 ? GetValue(_subRef_) 로 둔다.
          1. _last_ 를 ? ToString(_sub_) 로 둔다.
          1. _rest_, _middle_, _last_ 문자열 연결 반환.
        </emu-alg>
        <emu-note>
          <p>|Expression| 값의 문자열 변환은 `String.prototype.concat` 과 유사.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-grouping-operator">
      <h1>그룹 연산자(The Grouping Operator)</h1>

      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            |CoverParenthesizedExpressionAndArrowParameterList| 는 |ParenthesizedExpression| 을 커버해야 한다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ParenthesizedExpression| 으로 둔다.
          1. _expr_ 의 Evaluation 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. |Expression| 의 Evaluation 결과를 ? 로 반환. 이는 Reference 일 수 있다.
        </emu-alg>
        <emu-note>
          <p>이 알고리즘은 |Expression| 평가에 GetValue 를 적용하지 않는다. 이는 `delete`, `typeof` 같은 연산자가 괄호 친 표현식에 적용될 수 있도록 하는 주된 동기다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>좌변 표현식(Left-Hand-Side Expressions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget
        ImportMeta

      NewTarget :
        `new` `.` `target`

      ImportMeta :
        `import` `.` `meta`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      OptionalExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

      OptionalChain[Yield, Await] :
        `?.` Arguments[?Yield, ?Await]
        `?.` `[` Expression[+In, ?Yield, ?Await] `]`
        `?.` IdentifierName
        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]
        `?.` PrivateIdentifier
        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        OptionalChain[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        OptionalChain[?Yield, ?Await] `.` IdentifierName
        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        OptionalChain[?Yield, ?Await] `.` PrivateIdentifier

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>보충 문법(Supplemental Syntax)</h2>
    <p>
      다음 생성물 인스턴스를 처리할 때<br>
      <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar><br>
      |CoverCallExpressionAndAsyncArrowHead| 의 해석은 아래 문법을 사용해 정밀화된다:
    </p>
    <emu-grammar type="definition">
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics">
      <h1>정적 의미론(Static Semantics)</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Early Errors)</h1>
        <emu-grammar>
          OptionalChain :
            `?.` TemplateLiteral
            OptionalChain TemplateLiteral
        </emu-grammar>
        <ul>
          <li>
            이 생성물이 어떤 소스 텍스트와 매칭되면 Syntax Error이다.
          </li>
        </ul>
        <emu-note>
          <p>이 생성물은 아래 코드에 대해 자동 세미콜론 삽입 규칙(<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>)이 적용되어 두 개의 유효한 문장으로 해석되는 것을 방지하기 위해 존재한다:</p>
          <pre><code class="javascript">
            a?.b
            `c`
          </code></pre>
          <p>이는 선택적 체이닝이 없는 유사 코드와의 일관성을 유지하려는 목적이다:</p>
          <pre><code class="javascript">
            a.b
            `c`
          </code></pre>
          <p>위 코드는 유효한 문장이며 자동 세미콜론 삽입이 적용되지 않는다.</p>
        </emu-note>

        <emu-grammar>
          ImportMeta :
            `import` `.` `meta`
        </emu-grammar>
        <ul>
          <li>
            구문 목표 심볼이 |Module| 이 아니면 Syntax Error이다.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-accessors">
      <h1>프로퍼티 접근자(Property Accessors)</h1>
      <emu-note>
        <p>프로퍼티는 이름으로 접근하며, 점 표기법(dot notation)을 사용할 수 있다:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|<br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>또는 대괄호 표기법(bracket notation)을 사용할 수 있다:</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`<br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>점 표기법은 다음 구문 변환으로 설명된다:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>는 동작상 다음과 동일하다:</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>비슷하게</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>도 동작상 다음과 동일하다:</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>여기서 &lt;<i>identifier-name-string</i>> 는 |IdentifierName| 의 StringValue 이다.</p>
      </emu-note>

      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |MemberExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |MemberExpression|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |MemberExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |MemberExpression|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |MemberExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_baseValue_, _fieldNameString_) 를 반환한다.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |CallExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |CallExpression|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |CallExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |CallExpression|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 |CallExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_baseValue_, _fieldNameString_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-expression-key" type="abstract operation" oldids="sec-evaluate-expression-key-property-access">
      <h1>
        EvaluatePropertyAccessWithExpressionKey (
          _baseValue_: an ECMAScript language value,
          _expression_: an |Expression| Parse Node,
          _strict_: a Boolean,
        ): 정상 완료 시 Reference Record 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _propertyNameReference_ 를 _expression_ 의 Evaluation 결과 (?) 로 둔다.
        1. _propertyNameValue_ 를 ? GetValue(_propertyNameReference_) 로 둔다.
        1. NOTE: 대부분 경우 이 단계 직후 _propertyNameValue_ 에 대해 ToPropertyKey 가 수행된다. 그러나 `a[b] = c` 의 경우 `c` 평가 이후에 수행된다.
        1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameValue_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-identifier-key" type="abstract operation" oldids="sec-evaluate-identifier-key-property-access">
      <h1>
        EvaluatePropertyAccessWithIdentifierKey (
          _baseValue_: an ECMAScript language value,
          _identifierName_: an |IdentifierName| Parse Node,
          _strict_: a Boolean,
        ): Reference Record
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _propertyNameString_ 을 _identifierName_ 의 StringValue 로 둔다.
        1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ } 를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-new-operator">
      <h1>`new` 연산자(The `new` Operator)</h1>

      <emu-clause id="sec-new-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateNew(|NewExpression|, ~empty~) 를 반환한다.
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. ? EvaluateNew(|MemberExpression|, |Arguments|) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-evaluatenew" type="abstract operation">
          <h1>
            EvaluateNew (
              _constructExpr_: a |NewExpression| Parse Node or a |MemberExpression| Parse Node,
              _arguments_: ~empty~ or an |Arguments| Parse Node,
            ): 정상 완료 시 ECMAScript 언어 값 또는 abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _ref_ 를 _constructExpr_ 의 Evaluation 결과 (?) 로 둔다.
            1. _constructor_ 를 ? GetValue(_ref_) 로 둔다.
            1. _arguments_ 가 ~empty~ 이면
              1. _argList_ 를 새 빈 List 로 둔다.
            1. Else,
              1. _argList_ 를 ? ArgumentListEvaluation(_arguments_) 로 둔다.
            1. IsConstructor(_constructor_) 가 *false* 이면 *TypeError* 예외를 throw.
            1. ? Construct(_constructor_, _argList_) 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-calls">
      <h1>함수 호출(Function Calls)</h1>

      <emu-clause id="sec-function-calls-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. _expr_ 을 |CoverCallExpressionAndAsyncArrowHead| 가 커버하는 |CallMemberExpression| 으로 둔다.
          1. _memberExpr_ 을 _expr_ 의 |MemberExpression| 으로 둔다.
          1. _arguments_ 를 _expr_ 의 |Arguments| 로 둔다.
          1. _ref_ 를 ? Evaluation(_memberExpr_) 로 둔다.
          1. _func_ 을 ? GetValue(_ref_) 로 둔다.
          1. _ref_ 가 Reference Record 이고 IsPropertyReference(_ref_) 가 *false* 이며 _ref_.[[ReferencedName]] 가 *"eval"* 이면
            1. SameValue(_func_, %eval%) 이 *true* 이면
              1. _argList_ 를 ? ArgumentListEvaluation(_arguments_) 로 둔다.
              1. _argList_ 에 요소가 없으면 *undefined* 반환.
              1. _evalArg_ 를 _argList_ 의 첫 요소로 둔다.
              1. IsStrict(this |CallExpression|) 이 *true* 이면 _strictCaller_ = *true*, 아니면 *false*.
              1. [id="step-callexpression-evaluation-direct-eval"] ? PerformEval(_evalArg_, _strictCaller_, *true*) 를 반환한다.
          1. _thisCall_ 을 this |CallExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_) 를 반환한다.
        </emu-alg>
        <p>단계 <emu-xref href="#step-callexpression-evaluation-direct-eval"></emu-xref> 를 수행한 |CallExpression| 평가는 <dfn variants="direct evals">직접 eval(direct eval)</dfn> 이다.</p>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. _ref_ 를 ? Evaluation(|CallExpression|) 로 둔다.
          1. _func_ 를 ? GetValue(_ref_) 로 둔다.
          1. _thisCall_ 을 this |CallExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluatecall" type="abstract operation" oldids="sec-evaluatedirectcall">
        <h1>
          EvaluateCall (
            _func_: an ECMAScript language value,
            _ref_: an ECMAScript language value or a Reference Record,
            _arguments_: a Parse Node,
            _tailPosition_: a Boolean,
          ): 정상 완료 시 ECMAScript 언어 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _ref_ 가 Reference Record 이면
            1. IsPropertyReference(_ref_) 가 *true* 이면
              1. _thisValue_ 를 GetThisValue(_ref_) 로 둔다.
            1. Else,
              1. _refEnv_ 를 _ref_.[[Base]] 로 둔다.
              1. 단언: _refEnv_ 는 Environment Record.
              1. _thisValue_ 를 _refEnv_.WithBaseObject() 로 둔다.
          1. Else,
            1. _thisValue_ 를 *undefined* 로 둔다.
          1. _argList_ 를 ? ArgumentListEvaluation(_arguments_) 로 둔다.
          1. _func_ 가 Object 가 아니면 *TypeError* 예외 throw.
          1. IsCallable(_func_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _tailPosition_ 이 *true* 이면 PrepareForTailCall() 수행.
          1. ? Call(_func_, _thisValue_, _argList_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-super-keyword">
      <h1>`super` 키워드(The `super` Keyword)</h1>

      <emu-clause id="sec-super-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>SuperProperty : `super` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _env_ 를 GetThisEnvironment() 로 둔다.
          1. _actualThis_ 를 ? _env_.GetThisBinding() 로 둔다.
          1. _propertyNameReference_ 를 ? Evaluation(|Expression|) 로 둔다.
          1. _propertyNameValue_ 를 ? GetValue(_propertyNameReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |SuperProperty|) 로 둔다.
          1. NOTE: 대부분 경우 이 단계 직후 _propertyNameValue_ 에 대해 ToPropertyKey 가 수행된다. 하지만 `super[b] = c` 의 경우 `c` 평가 이후 수행된다.
          1. MakeSuperPropertyReference(_actualThis_, _propertyNameValue_, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _env_ 를 GetThisEnvironment() 로 둔다.
          1. _actualThis_ 를 ? _env_.GetThisBinding() 로 둔다.
          1. _propertyKey_ 를 |IdentifierName| 의 StringValue 로 둔다.
          1. _strict_ 를 IsStrict(this |SuperProperty|) 로 둔다.
          1. MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_) 를 반환한다.
        </emu-alg>
        <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. _newTarget_ 을 GetNewTarget() 로 둔다.
          1. 단언: _newTarget_ 은 constructor.
          1. _func_ 을 GetSuperConstructor() 로 둔다.
          1. _argList_ 를 ? ArgumentListEvaluation(|Arguments|) 로 둔다.
          1. IsConstructor(_func_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _result_ 를 ? Construct(_func_, _argList_, _newTarget_) 로 둔다.
          1. _thisER_ 를 GetThisEnvironment() 로 둔다.
          1. 단언: _thisER_ 는 Function Environment Record.
          1. ? BindThisValue(_thisER_, _result_) 수행.
          1. _F_ 를 _thisER_.[[FunctionObject]] 로 둔다.
          1. 단언: _F_ 는 ECMAScript 함수 객체.
          1. ? InitializeInstanceElements(_result_, _F_) 수행.
          1. _result_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getsuperconstructor" type="abstract operation">
        <h1>GetSuperConstructor ( ): ECMAScript 언어 값</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _envRec_ 를 GetThisEnvironment() 로 둔다.
          1. 단언: _envRec_ 는 Function Environment Record.
          1. _activeFunction_ 을 _envRec_.[[FunctionObject]] 로 둔다.
          1. 단언: _activeFunction_ 은 ECMAScript 함수 객체.
          1. _superConstructor_ 를 ! _activeFunction_.[[GetPrototypeOf]]() 로 둔다.
          1. _superConstructor_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makesuperpropertyreference" type="abstract operation">
        <h1>
          MakeSuperPropertyReference (
            _actualThis_: an ECMAScript language value,
            _propertyKey_: an ECMAScript language value,
            _strict_: a Boolean,
          ): Super Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _env_ 를 GetThisEnvironment() 로 둔다.
          1. 단언: _env_.HasSuperBinding() 은 *true*.
          1. 단언: _env_ 는 Function Environment Record.
          1. _baseValue_ 를 GetSuperBase(_env_) 로 둔다.
          1. Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ } 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-argument-lists">
      <h1>인자 목록(Argument Lists)</h1>
      <emu-note>
        <p>인자 목록의 평가 결과는 값들의 List 를 생성한다.</p>
      </emu-note>

      <emu-clause id="sec-runtime-semantics-argumentlistevaluation" oldids="sec-template-literals-runtime-semantics-argumentlistevaluation,sec-argument-lists-runtime-semantics-argumentlistevaluation" type="sdo">
        <h1>런타임 의미론: ArgumentListEvaluation ( ): 정상 완료 시 ECMAScript 언어 값들의 List 또는 abrupt completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Arguments : `(` `)`</emu-grammar>
        <emu-alg>
          1. 새 빈 List 반환.
        </emu-alg>
        <emu-grammar>ArgumentList : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _ref_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _arg_ 를 ? GetValue(_ref_) 로 둔다.
          1. « _arg_ » 반환.
        </emu-alg>
        <emu-grammar>ArgumentList : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _list_ 를 새 빈 List 로 둔다.
          1. _spreadRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _spreadObj_ 를 ? GetValue(_spreadRef_) 로 둔다.
          1. _iteratorRecord_ 를 ? GetIterator(_spreadObj_, ~sync~) 로 둔다.
          1. 반복,
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이면 _list_ 반환.
            1. _list_ 에 _next_ 추가.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _precedingArgs_ 를 ? ArgumentListEvaluation(|ArgumentList|) 로 둔다.
          1. _ref_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _arg_ 를 ? GetValue(_ref_) 로 둔다.
          1. _precedingArgs_ 와 « _arg_ » 의 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. _precedingArgs_ 를 ? ArgumentListEvaluation(|ArgumentList|) 로 둔다.
          1. _spreadRef_ 를 |AssignmentExpression| Evaluation 결과 (?) 로 둔다.
          1. _iteratorRecord_ 를 ? GetIterator(? GetValue(_spreadRef_), ~sync~) 로 둔다.
          1. 반복,
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이면 _precedingArgs_ 반환.
            1. _precedingArgs_ 에 _next_ 추가.
        </emu-alg>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. _templateLiteral_ 을 this |TemplateLiteral| 로 둔다.
          1. _siteObj_ 를 GetTemplateObject(_templateLiteral_) 로 둔다.
          1. « _siteObj_ » 반환.
        </emu-alg>
        <emu-grammar>TemplateLiteral : SubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. _templateLiteral_ 을 this |TemplateLiteral| 로 둔다.
          1. _siteObj_ 를 GetTemplateObject(_templateLiteral_) 로 둔다.
          1. _remaining_ 을 ? ArgumentListEvaluation(|SubstitutionTemplate|) 로 둔다.
          1. « _siteObj_ » 와 _remaining_ 의 리스트 연결 반환.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. _firstSubRef_ 를 ? Evaluation(|Expression|) 로 둔다.
          1. _firstSub_ 를 ? GetValue(_firstSubRef_) 로 둔다.
          1. _restSub_ 를 ? SubstitutionEvaluation(|TemplateSpans|) 로 둔다.
          1. 단언: _restSub_ 는 (비어있을 수도 있는) List.
          1. « _firstSub_ » 와 _restSub_ 의 리스트 연결 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-optional-chains">
      <h1>옵셔널 체인(Optional Chains)</h1>
      <emu-note>옵셔널 체인은 하나 이상의 프로퍼티 접근과 함수 호출이 연속된 것으로, 첫 부분이 `?.` 토큰으로 시작한다.</emu-note>

      <emu-clause id="sec-optional-chaining-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>
          OptionalExpression :
            MemberExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 ? Evaluation(|MemberExpression|) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _baseValue_ 가 *undefined* 또는 *null* 이면
            1. *undefined* 반환.
          1. ? ChainEvaluation(|OptionalChain|, 인수 _baseValue_, _baseReference_) 를 반환.
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            CallExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 ? Evaluation(|CallExpression|) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _baseValue_ 가 *undefined* 또는 *null* 이면
            1. *undefined* 반환.
          1. ? ChainEvaluation(|OptionalChain|, 인수 _baseValue_, _baseReference_) 반환.
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            OptionalExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. _baseReference_ 를 ? Evaluation(|OptionalExpression|) 로 둔다.
          1. _baseValue_ 를 ? GetValue(_baseReference_) 로 둔다.
          1. _baseValue_ 가 *undefined* 또는 *null* 이면
            1. *undefined* 반환.
          1. ? ChainEvaluation(|OptionalChain|, 인수 _baseValue_, _baseReference_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-optional-chaining-chain-evaluation" type="sdo">
        <h1>
          런타임 의미론: ChainEvaluation (
          _baseValue_: an ECMAScript language value,
          _baseReference_: an ECMAScript language value or a Reference Record,
          ): 정상 완료 시 ECMAScript 언어 값 또는 Reference Record, 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>
        <emu-alg>
          1. _thisChain_ 을 this |OptionalChain| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisChain_) 로 둔다.
          1. ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_baseValue_, _fieldNameString_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _thisChain_ 을 this |OptionalChain| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisChain_) 로 둔다.
          1. ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _strict_ 를 IsStrict(this |OptionalChain|) 로 둔다.
          1. EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_) 반환.
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. _optionalChain_ 을 |OptionalChain| 으로 둔다.
          1. _newReference_ 를 ? ChainEvaluation(_optionalChain_, 인수 _baseValue_, _baseReference_) 로 둔다.
          1. _newValue_ 를 ? GetValue(_newReference_) 로 둔다.
          1. _fieldNameString_ 을 |PrivateIdentifier| 의 StringValue 로 둔다.
          1. MakePrivateReference(_newValue_, _fieldNameString_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>import 호출(Import Calls)</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. ? EvaluateImportCall(|AssignmentExpression|) 반환.
        </emu-alg>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. ? EvaluateImportCall(첫 번째 |AssignmentExpression|, 두 번째 |AssignmentExpression|) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          EvaluateImportCall (
            _specifierExpression_: a Parse Node,
            optional _optionsExpression_: a Parse Node,
          ): 정상 완료 시 Promise 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _referrer_ 를 GetActiveScriptOrModule() 로 둔다.
          1. _referrer_ 가 *null* 이면 현재 Realm Record 로 설정.
          1. _specifierRef_ 를 ? Evaluation(_specifierExpression_) 로 둔다.
          1. _specifier_ 를 ? GetValue(_specifierRef_) 로 둔다.
          1. _optionsExpression_ 이 존재하면
            1. _optionsRef_ 를 ? Evaluation(_optionsExpression_) 로 둔다.
            1. _options_ 를 ? GetValue(_optionsRef_) 로 둔다.
          1. Else,
            1. _options_ = *undefined*.
          1. _promiseCapability_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
          1. _specifierString_ 을 Completion(ToString(_specifier_)) 로 둔다.
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. _attributes_ 를 새 빈 List 로 둔다.
          1. _options_ 가 *undefined* 가 아니면
            1. _options_ 가 Object 가 아니면
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
              1. _promiseCapability_.[[Promise]] 반환.
            1. _attributesObj_ 를 Completion(Get(_options_, *"with"*)).
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_).
            1. _attributesObj_ 가 *undefined* 가 아니면
              1. _attributesObj_ 가 Object 가 아니면
                1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
                1. _promiseCapability_.[[Promise]] 반환.
              1. _entries_ 를 Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~)).
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_).
              1. _entries_ 의 각 _entry_ 에 대해
                1. _key_ = ! Get(_entry_, *"0"*).
                1. _value_ = ! Get(_entry_, *"1"*).
                1. _key_ 가 String 이면
                  1. _value_ 가 String 이 아니면
                    1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
                    1. _promiseCapability_.[[Promise]] 반환.
                  1. ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } 를 _attributes_ 에 추가.
            1. AllImportAttributesSupported(_attributes_) 가 *false* 이면
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « 새로 생성된 *TypeError* 객체 ») 수행.
              1. _promiseCapability_.[[Promise]] 반환.
            1. _attributes_ 를 각 [[Key]] 필드의 UTF-16 코드 유닛 시퀀스 사전식 순서로 정렬. (NOTE: 정렬은 호스트가 열거 순서를 기반으로 동작을 바꾸는 것을 금지하는 방식으로만 관찰 가능)
          1. _moduleRequest_ 를 새 ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_ } 로 둔다.
          1. HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_) 수행.
          1. _promiseCapability_.[[Promise]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            _promiseCapability_: a PromiseCapability Record,
            _moduleCompletion_: Module Record 를 담는 정상 completion 또는 throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd><emu-xref href="#sec-import-calls">`import()`</emu-xref> 호출로 시작된 동적 import 과정을 마무리하여, 해당 호출이 반환한 promise 를 적절히 이행(resolve) 또는 거부(reject)한다.</dd>
        </dl>
        <emu-alg>
          1. _moduleCompletion_ 이 abrupt completion 이면
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] ») 수행.
            1. ~unused~ 반환.
          1. _module_ 을 _moduleCompletion_.[[Value]] 로 둔다.
            1. _loadPromise_ 를 _module_.LoadRequestedModules() 로 둔다.
          1. _rejectedClosure_ 를 (_reason_) 매개변수를 가지며 _promiseCapability_ 를 캡처하고 호출 시:
            1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ ») 수행.
            1. NormalCompletion(*undefined*) 반환.
          1. _onRejected_ 를 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « ») 로 둔다.
          1. _linkAndEvaluateClosure_ 를 매개변수 없고 _module_, _promiseCapability_, _onRejected_ 를 캡처하며 호출 시:
            1. _link_ = Completion(_module_.Link()).
            1. _link_ 가 abrupt completion 이면
              1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] ») 수행.
              1. NormalCompletion(*undefined*) 반환.
            1. _evaluatePromise_ 를 _module_.Evaluate() 로 둔다.
            1. _fulfilledClosure_ 를 매개변수 없고 _module_, _promiseCapability_ 캡처하며 호출 시:
              1. _namespace_ = GetModuleNamespace(_module_).
              1. ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ ») 수행.
              1. NormalCompletion(*undefined*) 반환.
            1. _onFulfilled_ = CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »).
            1. PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_) 수행.
            1. ~unused~ 반환.
          1. _linkAndEvaluate_ = CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *""*, « »).
          1. PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tagged-templates">
      <h1>태그드 템플릿(Tagged Templates)</h1>
      <emu-note>
        <p>태그드 템플릿은 호출 인자가 |TemplateLiteral| (<emu-xref href="#sec-template-literals"></emu-xref>) 로부터 파생되는 함수 호출이다. 실제 인자에는 템플릿 객체(<emu-xref href="#sec-gettemplateobject"></emu-xref>)와 |TemplateLiteral| 안에 포함된 표현식들을 평가하여 얻은 값들이 포함된다.</p>
      </emu-note>

      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. _tagRef_ 를 ? Evaluation(|MemberExpression|) 로 둔다.
          1. _tagFunc_ 를 ? GetValue(_tagRef_) 로 둔다.
          1. _thisCall_ 을 this |MemberExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_) 반환.
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. _tagRef_ 를 ? Evaluation(|CallExpression|) 로 둔다.
          1. _tagFunc_ 를 ? GetValue(_tagRef_) 로 둔다.
          1. _thisCall_ 을 this |CallExpression| 으로 둔다.
          1. _tailCall_ 을 IsInTailPosition(_thisCall_) 로 둔다.
          1. ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-meta-properties">
      <h1>메타 프로퍼티(Meta Properties)</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Evaluation)</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. GetNewTarget() 반환.
        </emu-alg>

        <emu-grammar>ImportMeta : `import` `.` `meta`</emu-grammar>
        <emu-alg>
          1. _module_ 을 GetActiveScriptOrModule() 로 둔다.
          1. 단언: _module_ 은 Source Text Module Record.
          1. _importMeta_ 를 _module_.[[ImportMeta]] 로 둔다.
          1. _importMeta_ 가 ~empty~ 이면
            1. _importMeta_ 를 OrdinaryObjectCreate(*null*) 로 설정.
            1. _importMetaValues_ 를 HostGetImportMetaProperties(_module_) 로 둔다.
            1. 각 Record { [[Key]], [[Value]] } _p_ 에 대해
              1. ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]) 수행.
            1. HostFinalizeImportMeta(_importMeta_, _module_) 수행.
            1. _module_.[[ImportMeta]] 에 _importMeta_ 설정.
            1. _importMeta_ 반환.
          1. Else,
            1. 단언: _importMeta_ 는 Object.
            1. _importMeta_ 반환.
        </emu-alg>

        <emu-clause id="sec-hostgetimportmetaproperties" type="host-defined abstract operation">
          <h1>
            HostGetImportMetaProperties (
              _moduleRecord_: a Module Record,
            ): [[Key]] (property key), [[Value]] (ECMAScript 언어 값) 필드를 가진 Record 들의 List
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>호스트가 `import.meta` 로부터 반환되는 객체에 대한 프로퍼티 키와 값을 제공할 수 있게 한다.</dd>
          </dl>

          <p>HostGetImportMetaProperties 의 기본 구현은 새 빈 List 를 반환한다.</p>
        </emu-clause>

        <emu-clause id="sec-hostfinalizeimportmeta" type="host-defined abstract operation">
          <h1>
            HostFinalizeImportMeta (
              _importMeta_: an Object,
              _moduleRecord_: a Module Record,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>호스트가 `import.meta` 로부터 반환되는 객체를 ECMAScript 코드에 노출하기 전에 추가 작업을 수행할 수 있게 한다.</dd>
          </dl>

          <p>대부분 호스트는 HostGetImportMetaProperties 를 정의하고 HostFinalizeImportMeta 는 기본 동작을 그대로 둘 수 있다. 그러나 HostFinalizeImportMeta 는 노출 전에 객체를 직접 조작해야 하는 호스트를 위한 “escape hatch” 를 제공한다.</p>

          <p>HostFinalizeImportMeta 의 기본 구현은 ~unused~ 를 반환한다.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-update-expressions">
    <h1>갱신 표현식(Update Expressions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
        `++` UnaryExpression[?Yield, ?Await]
        `--` UnaryExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-update-expressions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 초기(early) Syntax Error 이다.
        </li>
      </ul>

      <emu-grammar>
        UpdateExpression :
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <ul>
        <li>
          |UnaryExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 초기(early) Syntax Error 이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-postfix-increment-operator">
      <h1>후위 증가 연산자(Postfix Increment Operator)</h1>

      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_lhs_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::add(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::add(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_lhs_, _newValue_) 수행.
          1. _oldValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-postfix-decrement-operator">
      <h1>후위 감소 연산자(Postfix Decrement Operator)</h1>

      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_lhs_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::subtract(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_lhs_, _newValue_) 수행.
          1. _oldValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-increment-operator">
      <h1>전위 증가 연산자(Prefix Increment Operator)</h1>

      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |UnaryExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::add(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::add(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_expr_, _newValue_) 수행.
          1. _newValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-decrement-operator">
      <h1>전위 감소 연산자(Prefix Decrement Operator)</h1>

      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |UnaryExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw 한다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. _newValue_ 를 Number::subtract(_oldValue_, *1*<sub>𝔽</sub>) 로 둔다.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. _newValue_ 를 BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>) 로 둔다.
          1. ? PutValue(_expr_, _newValue_) 수행.
          1. _newValue_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unary-operators">
    <h1>단항 연산자(Unary Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-delete-operator">
      <h1>`delete` 연산자(The `delete` Operator)</h1>

      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            IsStrict(the |UnaryExpression|) 가 *true* 이고 파생된 |UnaryExpression| 이 <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>, <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>, 또는 <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar> 이면 Syntax Error 이다.
          </li>
          <li>
            <p>
              파생된 |UnaryExpression| 이<br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar><br>
              이고 |CoverParenthesizedExpressionAndArrowParameterList| 가 궁극적으로, 그것을 |UnaryExpression| 대신 사용했을 때 이 규칙에 따라 Syntax Error 를 일으킬 구문을 도출한다면 Syntax Error 이다. 이 규칙은 재귀적으로 적용된다.
            </p>
          </li>
        </ul>
        <emu-note>
          <p>마지막 규칙은 `delete (((foo)))` 같은 표현식이 첫 번째 규칙의 재귀 적용으로 인해 조기 오류를 발생함을 의미한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _ref_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _ref_ 가 Reference Record 가 아니면 *true* 반환.
          1. IsUnresolvableReference(_ref_) 가 *true* 이면
            1. 단언: _ref_.[[Strict]] 는 *false*.
            1. *true* 반환.
          1. IsPropertyReference(_ref_) 가 *true* 이면
            1. 단언: IsPrivateReference(_ref_) 는 *false*.
            1. IsSuperReference(_ref_) 가 *true* 이면 *ReferenceError* 예외 throw.
            1. [id="step-delete-operator-toobject"] _baseObj_ 를 ? ToObject(_ref_.[[Base]]) 로 둔다.
            1. _ref_.[[ReferencedName]] 가 property key 가 아니면
              1. _ref_.[[ReferencedName]] 를 ? ToPropertyKey(_ref_.[[ReferencedName]]) 로 설정.
            1. _deleteStatus_ 를 ? <emu-meta effects="user-code">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]]) 로 둔다.
            1. _deleteStatus_ 가 *false* 이고 _ref_.[[Strict]] 가 *true* 이면 *TypeError* 예외 throw.
            1. _deleteStatus_ 반환.
          1. 그렇지 않으면
            1. _base_ 를 _ref_.[[Base]] 로 둔다.
            1. 단언: _base_ 는 Environment Record.
            1. ? <emu-meta effects="user-code">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]]) 반환.
        </emu-alg>
        <emu-note>
          <p>`delete` 연산자가 strict 모드 코드 안에 나타나고 그 |UnaryExpression| 이 변수, 함수 인자, 함수 이름에 대한 직접 참조이면 *SyntaxError* 예외가 발생한다. 또한 strict 모드 코드에서 `delete` 가 발생하고 삭제하려는 프로퍼티가 { [[Configurable]]: *false* } 속성을 가지거나(또는 삭제 불가) 하면 *TypeError* 예외가 발생한다.</p>
        </emu-note>
        <emu-note>
          <p><emu-xref href="#step-delete-operator-toobject"></emu-xref> 단계에서 생성될 수 있는 객체는 위 추상 연산 및 보통 객체 [[Delete]] 내부 메서드 외부에서는 접근할 수 없다. 구현은 실제 객체 생성을 회피할 수도 있다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-void-operator">
      <h1>`void` 연산자(The `void` Operator)</h1>

      <emu-clause id="sec-void-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `void` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_expr_) 수행.
          1. *undefined* 반환.
        </emu-alg>
        <emu-note>
          <p>값을 사용하지 않더라도 관찰 가능한 부수효과가 있을 수 있으므로 GetValue 는 호출되어야 한다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>`typeof` 연산자(The `typeof` Operator)</h1>

      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation" oldids="table-typeof-operator-results,sec-IsHTMLDDA-internal-slot-typeof" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _val_ 을 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _val_ 이 Reference Record 이면
            1. IsUnresolvableReference(_val_) 가 *true* 이면 *"undefined"* 반환.
          1. _val_ 을 ? GetValue(_val_) 로 설정.
          1. _val_ 이 *undefined* 이면 *"undefined"* 반환.
          1. _val_ 이 *null* 이면 *"object"* 반환.
          1. _val_ 이 String 이면 *"string"* 반환.
          1. _val_ 이 Symbol 이면 *"symbol"* 반환.
          1. _val_ 이 Boolean 이면 *"boolean"* 반환.
          1. _val_ 이 Number 이면 *"number"* 반환.
          1. _val_ 이 BigInt 이면 *"bigint"* 반환.
          1. 단언: _val_ 은 Object.
          1. [id="step-typeof-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref> 를 지원한다면
            1. _val_ 이 [[IsHTMLDDA]] 내부 슬롯을 가지면 *"undefined"* 반환.
          1. _val_ 이 [[Call]] 내부 메서드를 가지면 *"function"* 반환.
          1. *"object"* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-plus-operator">
      <h1>단항 `+` 연산자(Unary `+` Operator)</h1>
      <emu-note>
        <p>단항 + 연산자는 피연산자를 Number 타입으로 변환한다.</p>
      </emu-note>

      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? ToNumber(? GetValue(_expr_)) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-minus-operator">
      <h1>단항 `-` 연산자(Unary `-` Operator)</h1>
      <emu-note>
        <p>단항 `-` 연산자는 피연산자를 수치 값으로 변환한 뒤 부호를 반전한다. *+0*<sub>𝔽</sub> 을 부정하면 *-0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 을 부정하면 *+0*<sub>𝔽</sub> 이 된다.</p>
      </emu-note>

      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. Number::unaryMinus(_oldValue_) 반환.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. BigInt::unaryMinus(_oldValue_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-bitwise-not-operator">
      <h1>비트 NOT 연산자(Bitwise NOT Operator) ( `~` )</h1>

      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _oldValue_ 를 ? ToNumeric(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 Number 이면
            1. Number::bitwiseNOT(_oldValue_) 반환.
          1. 그렇지 않으면
            1. 단언: _oldValue_ 는 BigInt.
            1. BigInt::bitwiseNOT(_oldValue_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-logical-not-operator">
      <h1>논리 NOT 연산자(Logical NOT Operator) ( `!` )</h1>

      <emu-clause id="sec-logical-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `!` UnaryExpression</emu-grammar>
        <emu-alg>
          1. _expr_ 를 |UnaryExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _oldValue_ 를 ToBoolean(? GetValue(_expr_)) 로 둔다.
          1. _oldValue_ 가 *true* 이면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>거듭제곱 연산자(Exponentiation Operator)</h1>
    <h2>Syntax</h2>

    <emu-grammar type="definition">
      ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-multiplicative-operators">
    <h1>곱셈 연산자(Multiplicative Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MultiplicativeExpression[Yield, Await] :
        ExponentiationExpression[?Yield, ?Await]
        MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

      MultiplicativeOperator : one of
        `*` `/` `%`
    </emu-grammar>
    <emu-note>
      <ul>
        <li>`*` 연산자는 피연산자의 곱(product)을 생성하는 곱셈을 수행한다.</li>
        <li>`/` 연산자는 피연산자의 몫(quotient)을 생성하는 나눗셈을 수행한다.</li>
        <li>`%` 연산자는 암묵적 나눗셈에서 피연산자의 나머지(remainder)를 구한다.</li>
      </ul>
    </emu-note>

    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. _opText_ 를 |MultiplicativeOperator| 가 매칭한 source text 로 둔다.
        1. ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-additive-operators">
    <h1>덧셈/뺄셈 연산자(Additive Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-addition-operator-plus">
      <h1>덧셈 연산자 ( `+` ) (The Addition Operator)</h1>
      <emu-note>
        <p>덧셈 연산자는 문자열 결합 또는 수치 덧셈을 수행한다.</p>
      </emu-note>

      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-subtraction-operator-minus">
      <h1>뺄셈 연산자 ( `-` ) (The Subtraction Operator)</h1>
      <emu-note>
        <p>`-` 연산자는 피연산자의 차(difference)를 생성하는 뺄셈을 수행한다.</p>
      </emu-note>

      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bitwise-shift-operators">
    <h1>비트 시프트 연산자(Bitwise Shift Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ShiftExpression[Yield, Await] :
        AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-left-shift-operator">
      <h1>왼쪽 시프트 연산자 ( `&lt;&lt;` ) (The Left Shift Operator)</h1>
      <emu-note>
        <p>왼쪽 피연산자를 오른쪽 피연산자가 지정한 비트 수만큼 비트 왼쪽 시프트한다.</p>
      </emu-note>

      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `&lt;&lt;`, |AdditiveExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-signed-right-shift-operator">
      <h1>부호 있는 오른쪽 시프트 연산자 ( `>>` ) (The Signed Right Shift Operator)</h1>
      <emu-note>
        <p>왼쪽 피연산자를 오른쪽 피연산자가 지정한 비트 수만큼 부호 확장(bit sign-filling)하며 오른쪽 시프트한다.</p>
      </emu-note>

      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>부호 없는 오른쪽 시프트 연산자 ( `>>>` ) (The Unsigned Right Shift Operator)</h1>
      <emu-note>
        <p>왼쪽 피연산자를 오른쪽 피연산자가 지정한 비트 수만큼 0 으로 채우며 오른쪽 시프트한다.</p>
      </emu-note>

      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relational-operators">
    <h1>관계 연산자(Relational Operators)</h1>
    <emu-note>
      <p>관계 연산자 평가 결과는 항상 Boolean 타입이며, 연산자가 명명한 관계가 두 피연산자 사이에서 성립하는지를 반영한다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      RelationalExpression[In, Yield, Await] :
        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
        [+In] PrivateIdentifier `in` ShiftExpression[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p><sub>[In]</sub> 문법 매개변수는 관계 표현식에서의 `in` 연산자를 `for` 문의 `in` 연산자와 혼동하지 않도록 필요하다.</p>
    </emu-note>

    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |RelationalExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 |ShiftExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _r_ 를 ? IsLessThan(_lVal_, _rVal_, *true*) 로 둔다.
        1. _r_ 가 *undefined* 이면 *false* 반환; 그렇지 않으면 _r_ 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 위와 같이 얻는다.
        1. _r_ 를 ? IsLessThan(_rVal_, _lVal_, *false*) 로 둔다.
        1. _r_ 가 *undefined* 이면 *false* 반환; 그렇지 않으면 _r_ 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 ? IsLessThan(_rVal_, _lVal_, *false*) 로 둔다.
        1. _r_ 가 *true* 또는 *undefined* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 ? IsLessThan(_lVal_, _rVal_, *true*) 로 둔다.
        1. _r_ 가 *true* 또는 *undefined* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `instanceof` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. ? InstanceofOperator(_lVal_, _rVal_) 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _rVal_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. ? HasProperty(_rVal_, ? ToPropertyKey(_lVal_)) 반환.
      </emu-alg>
      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _privateIdentifier_ 를 |PrivateIdentifier| 의 StringValue 로 둔다.
        1. _rRef_ 를 |ShiftExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _rVal_ 가 Object 가 아니면 *TypeError* 예외 throw.
        1. _privateEnv_ 를 실행 중인 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. 단언: _privateEnv_ 는 *null* 이 아님.
        1. _privateName_ 을 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_) 로 둔다.
        1. PrivateElementFind(_rVal_, _privateName_) 이 ~empty~ 가 아니면 *true* 반환.
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-instanceofoperator" type="abstract operation">
      <h1>
        InstanceofOperator (
          _V_: an ECMAScript language value,
          _target_: an ECMAScript language value,
        ): Boolean 을 담는 정상 완료 또는 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_target_ 의 %Symbol.hasInstance% 메서드를 조회하거나, 없다면 _target_ 의 *"prototype"* 프로퍼티 값이 _V_ 의 프로토타입 체인에 존재하는지 확인하여 _V_ 가 _target_ 의 인스턴스인지 결정하는 일반 알고리즘을 구현한다.</dd>
      </dl>
      <emu-alg>
        1. _target_ 이 Object 가 아니면 *TypeError* 예외 throw.
        1. _instOfHandler_ 를 ? GetMethod(_target_, %Symbol.hasInstance%) 로 둔다.
        1. _instOfHandler_ 가 *undefined* 가 아니면
          1. ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)) 반환.
        1. [id="step-instanceof-check-function"] IsCallable(_target_) 이 *false* 이면 *TypeError* 예외 throw.
        1. [id="step-instanceof-fallback"] ? OrdinaryHasInstance(_target_, _V_) 반환.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#step-instanceof-check-function"></emu-xref> 및 <emu-xref href="#step-instanceof-fallback"></emu-xref> 단계는 %Symbol.hasInstance% 를 사용하지 않던 이전 ECMAScript 판과의 호환성을 제공한다. 객체가 %Symbol.hasInstance% 를 정의하거나 상속하지 않으면 기본 `instanceof` 의미론을 사용한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-equality-operators">
    <h1>동등 연산자(Equality Operators)</h1>
    <emu-note>
      <p>동등 연산자 평가 결과는 항상 Boolean 타입이며, 연산자가 명명한 관계가 두 피연산자 사이에서 성립하는지를 반영한다.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-equality-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>EqualityExpression : EqualityExpression `==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |EqualityExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 |RelationalExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. ? IsLooselyEqual(_rVal_, _lVal_) 반환.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!=` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 ? IsLooselyEqual(_rVal_, _lVal_) 로 둔다.
        1. _r_ 가 *true* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `===` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. IsStrictlyEqual(_rVal_, _lVal_) 반환.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. _lRef_, _lVal_, _rRef_, _rVal_ 를 얻는다.
        1. _r_ 를 IsStrictlyEqual(_rVal_, _lVal_) 로 둔다.
        1. _r_ 가 *true* 이면 *false* 반환; 그렇지 않으면 *true* 반환.
      </emu-alg>
      <emu-note>
        <p>위 동등성 정의에 따라:</p>
        <ul>
          <li>
            문자열 비교를 강제하려면: <code>\`${a}\` == \`${b}\`</code>.
          </li>
          <li>
            수치 비교를 강제하려면: <code>+a == +b</code>.
          </li>
          <li>
            Boolean 비교를 강제하려면: <code>!a == !b</code>.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>동등 연산자는 다음 불변식을 유지한다:</p>
        <ul>
          <li>
            <code>A != B</code> 는 <code>!(A == B)</code> 와 동등하다.
          </li>
          <li>
            <code>A == B</code> 는 (평가 순서 제외) <code>B == A</code> 와 동등하다.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>동등 연산자는 항상 추이적(transitive)이지는 않다. 예를 들어 동일한 String 값을 나타내는 서로 다른 두 String 객체가 있을 수 있고, 각 객체는 `==` 연산자에 의해 그 String 값과는 같지만 서로는 같지 않을 수 있다. 예:</p>
        <ul>
          <li>
            <code>new String("a") == "a"</code> 및 <code>"a" == new String("a")</code> 는 둘 다 *true*.
          </li>
          <li>
            <code>new String("a") == new String("a")</code> 는 *false*.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>문자열 비교는 코드 유닛 값 시퀀스의 단순 동등성 검사만을 사용한다. 유니코드 명세에 정의된 더 복잡하고 의미 지향적인 문자/문자열 동등성 또는 정렬 순서를 사용하지 않는다. 따라서 유니코드 표준에 따라 정규적으로 동등한 String 값이라도 서로 다르다고 나올 수 있다. 사실상 이 알고리즘은 두 String 이 이미 정규화(normalized)되어 있다고 가정한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-bitwise-operators">
    <h1>이진 비트 연산자(Binary Bitwise Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]

      BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]

      BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&amp;`, |EqualityExpression|) 반환.
      </emu-alg>
      <emu-grammar>BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|) 반환.
      </emu-alg>
      <emu-grammar>BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression</emu-grammar>
      <emu-alg>
        1. ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-logical-operators">
    <h1>이진 논리 연산자(Binary Logical Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]

      LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]

      CoalesceExpression[In, Yield, Await] :
        CoalesceExpressionHead[?In, ?Yield, ?Await] `??` BitwiseORExpression[?In, ?Yield, ?Await]

      CoalesceExpressionHead[In, Yield, Await] :
        CoalesceExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await]

      ShortCircuitExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        CoalesceExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`&amp;&amp;` 또는 `||` 연산자가 생성하는 값은 반드시 Boolean 타입일 필요가 없다. 결과 값은 항상 두 피연산자 표현식 중 하나의 값이다.</p>
    </emu-note>

    <emu-clause id="sec-binary-logical-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LogicalANDExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 이 *false* 이면 _lVal_ 반환.
        1. _rRef_ 를 |BitwiseORExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_rRef_) 반환.
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LogicalORExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 이 *true* 이면 _lVal_ 반환.
        1. _rRef_ 를 |LogicalANDExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_rRef_) 반환.
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |CoalesceExpressionHead| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _lVal_ 이 *undefined* 또는 *null* 이면
          1. _rRef_ 를 |BitwiseORExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_rRef_) 반환.
        1. 그렇지 않으면
          1. _lVal_ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-conditional-operator">
    <h1>조건부 연산자(Conditional Operator) ( `? :` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ConditionalExpression[In, Yield, Await] :
        ShortCircuitExpression[?In, ?Yield, ?Await]
        ShortCircuitExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>ECMAScript 의 |ConditionalExpression| 문법은 C 및 Java 와 약간 다르다. C 와 Java 는 두 번째 부분식을 |Expression| 으로 허용하지만 세 번째 부분식을 |ConditionalExpression| 으로 제한한다. ECMAScript 에서 이러한 차이를 둔 동기는 (1) 조건부의 어느 한 쪽 (arm) 에서도 할당 표현식을 다룰 수 있게 하고 (2) 가운데 표현식이 쉼표 표현식인 혼란스럽고 거의 쓸모없는 경우를 제거하기 위함이다.</p>
    </emu-note>

    <emu-clause id="sec-conditional-operator-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |ShortCircuitExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ToBoolean(? GetValue(_lRef_)) 로 둔다.
        1. _lVal_ 이 *true* 이면
          1. _trueRef_ 를 첫 번째 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_trueRef_) 반환.
        1. 그렇지 않으면
          1. _falseRef_ 를 두 번째 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. ? GetValue(_falseRef_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-assignment-operators">
    <h1>할당 연산자(Assignment Operators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `&amp;&amp;=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `||=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `??=` AssignmentExpression[?In, ?Yield, ?Await]

      // emu-format ignore
      AssignmentOperator : one of
        `*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`
    </emu-grammar>

    <emu-clause id="sec-assignment-operators-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면 |LeftHandSideExpression| 은 |AssignmentPattern| 을 커버해야 한다.
        </li>
        <li>
          |LeftHandSideExpression| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면, |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 Syntax Error 이다.
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 Syntax Error 이다.
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          |LeftHandSideExpression| 의 AssignmentTargetType 이 ~simple~ 이 아니면 Syntax Error 이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. |LeftHandSideExpression| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면,
          1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외를 throw.
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
            1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
            1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
          1. 그렇지 않으면
            1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
            1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
          1. [id="step-assignmentexpression-evaluation-simple-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
          1. _rVal_ 반환.
        1. _assignmentPattern_ 을 |LeftHandSideExpression| 이 커버하는 |AssignmentPattern| 으로 둔다.
        1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _assignmentPattern_ 의 DestructuringAssignmentEvaluation(_rVal_) 를 ? 로 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. |LeftHandSideExpression| 의 AssignmentTargetType 이 ~web-compat~ 이면 *ReferenceError* 예외 throw.
        1. [id="step-assignmentexpression-evaluation-compound-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. _assignmentOpText_ 를 |AssignmentOperator| 가 매칭한 소스 텍스트로 둔다.
        1. _opText_ 를 아래 표에서 _assignmentOpText_ 에 연관된 유니코드 코드 포인트 시퀀스로 둔다.
          <figure>
            <!-- emu-format ignore -->
            <table class="lightweight-table">
              <thead>
                <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>
              </thead>
              <tr><td> `**=`              </td><td> `**`           </td></tr>
              <tr><td> `*=`               </td><td> `*`            </td></tr>
              <tr><td> `/=`               </td><td> `/`            </td></tr>
              <tr><td> `%=`               </td><td> `%`            </td></tr>
              <tr><td> `+=`               </td><td> `+`            </td></tr>
              <tr><td> `-=`               </td><td> `-`            </td></tr>
              <tr><td> `&lt;&lt;=`        </td><td> `&lt;&lt;`     </td></tr>
              <tr><td> `&gt;&gt;=`        </td><td> `&gt;&gt;`     </td></tr>
              <tr><td> `&gt;&gt;&gt;=`    </td><td> `&gt;&gt;&gt;` </td></tr>
              <tr><td> `&amp;=`           </td><td> `&amp;`        </td></tr>
              <tr><td> `^=`               </td><td> `^`            </td></tr>
              <tr><td> `|=`               </td><td> `|`            </td></tr>
            </table>
          </figure>
        1. _r_ 를 ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-compound-putvalue"] ? PutValue(_lRef_, _r_) 수행.
        1. _r_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `&amp;&amp;=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-and-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 가 *false* 이면 _lVal_ 반환.
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
          1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
          1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
        1. 그렇지 않으면
          1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-and-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `||=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-or-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. ToBoolean(_lVal_) 가 *true* 이면 _lVal_ 반환.
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
          1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
          1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
        1. 그렇지 않으면
          1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-or-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `??=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |LeftHandSideExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-getvalue"] _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _lVal_ 이 *undefined* 도 *null* 도 아니면 _lVal_ 반환.
        1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이고 IsIdentifierRef(|LeftHandSideExpression|) 가 *true* 이면
          1. _lhs_ 를 |LeftHandSideExpression| 의 StringValue 로 둔다.
          1. _rVal_ 를 |AssignmentExpression| 의 NamedEvaluation(_lhs_) 결과 (?) 로 둔다.
        1. 그렇지 않으면
          1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-putvalue"] ? PutValue(_lRef_, _rVal_) 수행.
        1. _rVal_ 반환.
      </emu-alg>
      <emu-note>
        <p>이 표현식이 strict 모드 코드 내에 나타날 때 단계 <emu-xref href="#step-assignmentexpression-evaluation-simple-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-compound-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-getvalue"></emu-xref> 의 _lRef_ 가 해석 불가능한(unresolvable) reference 이면 런타임 오류이며 *ReferenceError* 예외가 발생한다. 또한 단계 <emu-xref href="#step-assignmentexpression-evaluation-compound-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-putvalue"></emu-xref> 의 _lRef_ 가 { [[Writable]]: *false* } 특성을 가진 데이터 프로퍼티, { [[Set]]: *undefined* } 특성을 가진 접근자 프로퍼티, 또는 IsExtensible 가 *false* 를 반환하는 객체의 존재하지 않는 프로퍼티라면 *TypeError* 예외가 발생한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-applystringornumericbinaryoperator" type="abstract operation">
      <h1>
        ApplyStringOrNumericBinaryOperator (
          _lVal_: an ECMAScript language value,
          _opText_: `**`, `*`, `/`, `%`, `+`, `-`, `&lt;&lt;`, `&gt;&gt;`, `&gt;&gt;&gt;`, `&amp;`, `^`, or `|`,
          _rVal_: an ECMAScript language value,
        ): 정상 완료 시 String, BigInt 또는 Number 중 하나 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _opText_ 가 `+` 이면
          1. [id="step-binary-op-toprimitive-lval"] _lPrim_ 을 ? ToPrimitive(_lVal_) 로 둔다.
          1. [id="step-binary-op-toprimitive-rval"] _rPrim_ 을 ? ToPrimitive(_rVal_) 로 둔다.
          1. [id="step-binary-op-string-check"] _lPrim_ 이 String 이거나 _rPrim_ 이 String 이면
            1. _lStr_ 을 ? ToString(_lPrim_) 로 둔다.
            1. _rStr_ 을 ? ToString(_rPrim_) 로 둔다.
            1. _lStr_ 와 _rStr_ 의 문자열 연결을 반환.
          1. _lVal_ 를 _lPrim_ 으로 설정.
          1. _rVal_ 를 _rPrim_ 으로 설정.
        1. NOTE: 이 시점부터는 수치 연산이어야 한다.
        1. _lNum_ 을 ? ToNumeric(_lVal_) 로 둔다.
        1. _rNum_ 을 ? ToNumeric(_rVal_) 로 둔다.
        1. SameType(_lNum_, _rNum_) 이 *false* 이면 *TypeError* 예외 throw.
        1. _lNum_ 이 BigInt 이면
          1. _opText_ 가 `**` 이면 ? BigInt::exponentiate(_lNum_, _rNum_) 반환.
          1. _opText_ 가 `/` 이면 ? BigInt::divide(_lNum_, _rNum_) 반환.
          1. _opText_ 가 `%` 이면 ? BigInt::remainder(_lNum_, _rNum_) 반환.
          1. _opText_ 가 `>>>` 이면 ? BigInt::unsignedRightShift(_lNum_, _rNum_) 반환.
          1. _operation_ 을 아래 표에서 _opText_ 에 연관된 추상 연산으로 둔다.
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_   </th><th> _operation_              </th></tr>
                </thead>
                <tbody>
                  <tr><td> `*`        </td><td> BigInt::multiply         </td></tr>
                  <tr><td> `+`        </td><td> BigInt::add              </td></tr>
                  <tr><td> `-`        </td><td> BigInt::subtract         </td></tr>
                  <tr><td> `&lt;&lt;` </td><td> BigInt::leftShift        </td></tr>
                  <tr><td> `&gt;&gt;` </td><td> BigInt::signedRightShift </td></tr>
                  <tr><td> `&amp;`    </td><td> BigInt::bitwiseAND       </td></tr>
                  <tr><td> `^`        </td><td> BigInt::bitwiseXOR       </td></tr>
                  <tr><td> `|`        </td><td> BigInt::bitwiseOR        </td></tr>
                </tbody>
              </table>
            </figure>
        1. 그렇지 않으면
          1. 단언: _lNum_ 은 Number.
          1. _operation_ 을 아래 표에서 _opText_ 에 연관된 추상 연산으로 둔다.
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_       </th><th> _operation_                </th></tr>
                </thead>
                <tbody>
                  <tr><td> `**`           </td><td> Number::exponentiate       </td></tr>
                  <tr><td> `*`            </td><td> Number::multiply           </td></tr>
                  <tr><td> `/`            </td><td> Number::divide             </td></tr>
                  <tr><td> `%`            </td><td> Number::remainder          </td></tr>
                  <tr><td> `+`            </td><td> Number::add                </td></tr>
                  <tr><td> `-`            </td><td> Number::subtract           </td></tr>
                  <tr><td> `&lt;&lt;`     </td><td> Number::leftShift          </td></tr>
                  <tr><td> `&gt;&gt;`     </td><td> Number::signedRightShift   </td></tr>
                  <tr><td> `&gt;&gt;&gt;` </td><td> Number::unsignedRightShift </td></tr>
                  <tr><td> `&amp;`        </td><td> Number::bitwiseAND         </td></tr>
                  <tr><td> `^`            </td><td> Number::bitwiseXOR         </td></tr>
                  <tr><td> `|`            </td><td> Number::bitwiseOR          </td></tr>
                </tbody>
              </table>
            </figure>
        1. _operation_(_lNum_, _rNum_) 반환.
      </emu-alg>
      <emu-note>
        <p>단계 <emu-xref href="#step-binary-op-toprimitive-lval"></emu-xref>, <emu-xref href="#step-binary-op-toprimitive-rval"></emu-xref> 의 ToPrimitive 호출에는 hint 가 제공되지 않는다. 표준 객체 중 Date 를 제외한 모든 객체는 hint 부재를 ~number~ 가 주어진 것처럼 처리하고 Date 는 ~string~ 처럼 처리한다. 특수(exotic) 객체는 다른 방식으로 처리할 수 있다.</p>
      </emu-note>
      <emu-note>
        <p>단계 <emu-xref href="#step-binary-op-string-check"></emu-xref> 는 IsLessThan 알고리즘의 단계 <emu-xref href="#step-arc-string-check"></emu-xref> 와 달리 논리 AND 대신 논리 OR 를 사용한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-evaluatestringornumericbinaryexpression" type="abstract operation">
      <h1>
        EvaluateStringOrNumericBinaryExpression (
          _leftOperand_: a Parse Node,
          _opText_: a sequence of Unicode code points,
          _rightOperand_: a Parse Node,
        ): 정상 완료 시 String, BigInt 또는 Number 중 하나 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _lRef_ 를 _leftOperand_ 의 Evaluation 결과 (?) 로 둔다.
        1. _lVal_ 를 ? GetValue(_lRef_) 로 둔다.
        1. _rRef_ 를 _rightOperand_ 의 Evaluation 결과 (?) 로 둔다.
        1. _rVal_ 를 ? GetValue(_rRef_) 로 둔다.
        1. ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-destructuring-assignment">
      <h1>구조 분해 할당(Destructuring Assignment)</h1>
      <h2>보충 문법(Supplemental Syntax)</h2>
      <p>
        특정 상황에서 다음 생성물 인스턴스를 처리할 때<br>
        <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar><br>
        |LeftHandSideExpression| 의 해석은 아래 문법을 사용해 정밀화된다:
      </p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-assignment-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <ul>
          <li>
            |IdentifierReference| 의 AssignmentTargetType 이 ~simple~ 이 아니면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <ul>
          <li>
            |DestructuringAssignmentTarget| 이 |ArrayLiteral| 이거나 |ObjectLiteral| 이면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>DestructuringAssignmentTarget : LeftHandSideExpression</emu-grammar>
        <ul>
          <li>
            |LeftHandSideExpression| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면 |LeftHandSideExpression| 은 |AssignmentPattern| 을 커버해야 한다.
          </li>
          <li>
            |LeftHandSideExpression| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면 AssignmentTargetType 이 ~simple~ 이 아니면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-destructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: DestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ObjectAssignmentPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>
          ObjectAssignmentPattern :
            `{` AssignmentPropertyList `}`
            `{` AssignmentPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. |AssignmentPropertyList| 의 PropertyDestructuringAssignmentEvaluation(_value_) 를 ? 로 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. _excludedNames_ 를 새 빈 List 로 둔다.
          1. |AssignmentRestProperty| 의 RestDestructuringAssignmentEvaluation(_value_, _excludedNames_) 를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentPropertyList `,` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. ? RequireObjectCoercible(_value_) 수행.
          1. _excludedNames_ 를 |AssignmentPropertyList| 의 PropertyDestructuringAssignmentEvaluation(_value_) 결과 (?) 로 둔다.
          1. |AssignmentRestProperty| 의 RestDestructuringAssignmentEvaluation(_value_, _excludedNames_) 를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)) 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. _result_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_)) 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _result_) 반환.
          1. _result_ 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. |Elision| 이 존재하면
            1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_)) 로 둔다.
            1. _status_ 가 abrupt completion 이면
              1. 단언: _iteratorRecord_.[[Done]] 는 *true*.
              1. ? _status_ 반환.
          1. _result_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentRestElement|, _iteratorRecord_)) 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _result_) 반환.
          1. _result_ 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. _result_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentElementList|, _iteratorRecord_)) 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _result_) 반환.
          1. _result_ 반환.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision? AssignmentRestElement? `]`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_ 를 ? GetIterator(_value_, ~sync~) 로 둔다.
          1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentElementList|, _iteratorRecord_)) 로 둔다.
          1. _status_ 가 abrupt completion 이면
            1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _status_) 반환.
            1. ? _status_ 반환.
          1. |Elision| 이 존재하면
            1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_)) 로 설정.
            1. _status_ 가 abrupt completion 이면
              1. 단언: _iteratorRecord_.[[Done]] 는 *true*.
              1. ? _status_ 반환.
          1. |AssignmentRestElement| 가 존재하면
            1. _status_ 를 Completion(IteratorDestructuringAssignmentEvaluation(|AssignmentRestElement|, _iteratorRecord_)) 로 설정.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면 ? IteratorClose(_iteratorRecord_, _status_) 반환.
          1. ? _status_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: PropertyDestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          ): 정상 완료 시 프로퍼티 키 List 또는 abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>모든 구조 분해된 프로퍼티 키의 목록을 수집한다.</dd>
        </dl>
        <emu-grammar>AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty</emu-grammar>
        <emu-alg>
          1. _propertyNames_ 를 |AssignmentPropertyList| 의 PropertyDestructuringAssignmentEvaluation(_value_) 결과 (?) 로 둔다.
          1. _nextNames_ 를 |AssignmentProperty| 의 PropertyDestructuringAssignmentEvaluation(_value_) 결과 (?) 로 둔다.
          1. _propertyNames_ 와 _nextNames_ 의 리스트 연결 반환.
        </emu-alg>

        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <emu-alg>
          1. _P_ 를 |IdentifierReference| 의 StringValue 로 둔다.
          1. _lRef_ 를 ? ResolveBinding(_P_) 로 둔다.
          1. _v_ 를 ? GetV(_value_, _P_) 로 둔다.
          1. |Initializer| 가 존재하고 _v_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
              1. _v_ 를 |Initializer| 의 NamedEvaluation(_P_) 결과 (?) 로 설정.
            1. 그렇지 않으면
              1. _defaultValue_ 를 |Initializer| 의 Evaluation 결과 (?) 로 둔다.
              1. _v_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. ? PutValue(_lRef_, _v_) 수행.
          1. « _P_ » 반환.
        </emu-alg>

        <emu-grammar>AssignmentProperty : PropertyName `:` AssignmentElement</emu-grammar>
        <emu-alg>
          1. _name_ 을 |PropertyName| 의 Evaluation 결과 (?) 로 둔다.
          1. |AssignmentElement| 의 KeyedDestructuringAssignmentEvaluation(_value_, _name_) 를 ? 로 수행.
          1. « _name_ » 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-restdestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: RestDestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          _excludedNames_: a List of property keys,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _restObj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ? CopyDataProperties(_restObj_, _value_, _excludedNames_) 수행.
          1. ? PutValue(_lRef_, _restObj_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: IteratorDestructuringAssignmentEvaluation (
          _iteratorRecord_: an Iterator Record,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElisionElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElementList|, _iteratorRecord_) 수행.
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElisionElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_) 수행.
          1. ? IteratorDestructuringAssignmentEvaluation(|AssignmentElement|, _iteratorRecord_) 반환.
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. _iteratorRecord_.[[Done]] 가 *false* 이면
            1. ? IteratorStep(_iteratorRecord_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. ? IteratorDestructuringAssignmentEvaluation(|Elision|, _iteratorRecord_) 수행.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면
            1. ? IteratorStep(_iteratorRecord_) 수행.
          1. ~unused~ 반환.
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _value_ 를 *undefined* 로 둔다.
          1. _iteratorRecord_.[[Done]] 가 *false* 이면
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이 아니면
              1. _value_ 를 _next_ 로 설정.
          1. |Initializer| 가 존재하고 _value_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이고 IsIdentifierRef(|DestructuringAssignmentTarget|) 가 *true* 이면
              1. _target_ 을 |DestructuringAssignmentTarget| 의 StringValue 로 둔다.
              1. _v_ 를 |Initializer| 의 NamedEvaluation(_target_) 결과 (?) 로 둔다.
            1. 그렇지 않으면
              1. _defaultValue_ 를 |Initializer| 의 Evaluation 결과 (?) 로 둔다.
              1. _v_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. 그렇지 않으면
            1. _v_ 를 _value_ 로 둔다.
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면
            1. _nestedAssignmentPattern_ 을 |DestructuringAssignmentTarget| 이 커버하는 |AssignmentPattern| 으로 둔다.
            1. ? DestructuringAssignmentEvaluation(_nestedAssignmentPattern_, _v_) 반환.
          1. ? PutValue(_lRef_, _v_) 반환.
        </emu-alg>
        <emu-note>
          <p>|DestructuringAssignmentTarget| 이 구조 분해 패턴이 아닌 경우 그것을 먼저 평가한 뒤 iterator 접근이나 |Initializer| 평가가 수행되어 좌→우 평가 순서가 유지된다.</p>
        </emu-note>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _A_ 를 ! ArrayCreate(0) 로 둔다.
          1. _n_ = 0.
          1. _iteratorRecord_.[[Done]] 가 *false* 인 동안 반복
            1. _next_ 를 ? IteratorStepValue(_iteratorRecord_) 로 둔다.
            1. _next_ 가 ~done~ 이 아니면
              1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_) 수행.
              1. _n_ = _n_ + 1.
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. ? PutValue(_lRef_, _A_) 반환.
          1. _nestedAssignmentPattern_ 을 |DestructuringAssignmentTarget| 이 커버하는 |AssignmentPattern| 으로 둔다.
          1. ? DestructuringAssignmentEvaluation(_nestedAssignmentPattern_, _A_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation" type="sdo">
        <h1>
          런타임 의미론: KeyedDestructuringAssignmentEvaluation (
          _value_: an ECMAScript language value,
          _propertyName_: a property key,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 도 |ArrayLiteral| 도 아니면
            1. _lRef_ 를 |DestructuringAssignmentTarget| 의 Evaluation 결과 (?) 로 둔다.
          1. _v_ 를 ? GetV(_value_, _propertyName_) 로 둔다.
          1. |Initializer| 가 존재하고 _v_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이고 IsIdentifierRef(|DestructuringAssignmentTarget|) 가 *true* 이면
              1. _target_ 을 |DestructuringAssignmentTarget| 의 StringValue 로 둔다.
              1. _rhsValue_ 를 |Initializer| 의 NamedEvaluation(_target_) 결과 (?) 로 둔다.
            1. 그렇지 않으면
              1. _defaultValue_ 를 |Initializer| 의 Evaluation 결과 (?) 로 둔다.
              1. _rhsValue_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. 그렇지 않으면
            1. _rhsValue_ 를 _v_ 로 둔다.
          1. |DestructuringAssignmentTarget| 이 |ObjectLiteral| 이거나 |ArrayLiteral| 이면
            1. _assignmentPattern_ 을 |DestructuringAssignmentTarget| 이 커버하는 |AssignmentPattern| 으로 둔다.
            1. ? DestructuringAssignmentEvaluation(_assignmentPattern_, _rhsValue_) 반환.
          1. ? PutValue(_lRef_, _rhsValue_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-comma-operator">
    <h1>콤마 연산자(Comma Operator) ( `,` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-comma-operator-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _lRef_ 를 |Expression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_lRef_) 수행.
        1. _rRef_ 를 |AssignmentExpression| 의 Evaluation 결과 (?) 로 둔다.
        1. ? GetValue(_rRef_) 반환.
      </emu-alg>
      <emu-note>
        <p>값을 사용하지 않더라도 관찰 가능한 부수 효과가 있을 수 있으므로 GetValue 는 호출되어야 한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript 언어: 문(Statements)과 선언(Declarations)</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    Statement[Yield, Await, Return] :
      BlockStatement[?Yield, ?Await, ?Return]
      VariableStatement[?Yield, ?Await]
      EmptyStatement
      ExpressionStatement[?Yield, ?Await]
      IfStatement[?Yield, ?Await, ?Return]
      BreakableStatement[?Yield, ?Await, ?Return]
      ContinueStatement[?Yield, ?Await]
      BreakStatement[?Yield, ?Await]
      [+Return] ReturnStatement[?Yield, ?Await]
      WithStatement[?Yield, ?Await, ?Return]
      LabelledStatement[?Yield, ?Await, ?Return]
      ThrowStatement[?Yield, ?Await]
      TryStatement[?Yield, ?Await, ?Return]
      DebuggerStatement

    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] :
      FunctionDeclaration[?Yield, ?Await, ?Default]
      GeneratorDeclaration[?Yield, ?Await, ?Default]
      AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
      AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] :
      IterationStatement[?Yield, ?Await, ?Return]
      SwitchStatement[?Yield, ?Await, ?Return]
  </emu-grammar>

  <emu-clause id="sec-statement-semantics">
    <h1>Statement 의미론</h1>

    <emu-clause id="sec-statement-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>
        HoistableDeclaration :
          GeneratorDeclaration
          AsyncFunctionDeclaration
          AsyncGeneratorDeclaration
      </emu-grammar>
      <emu-alg>
        1. ~empty~ 를 반환한다.
      </emu-alg>
      <emu-grammar>
        HoistableDeclaration : FunctionDeclaration
      </emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| 의 Evaluation 결과를 ? 로 반환한다.
      </emu-alg>
      <emu-grammar>
        BreakableStatement :
          IterationStatement
          SwitchStatement
      </emu-grammar>
      <emu-alg>
        1. _newLabelSet_ 을 새 빈 List 로 둔다.
        1. 이 |BreakableStatement| 의 LabelledEvaluation(_newLabelSet_) 결과를 ? 로 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BlockStatement[Yield, Await, Return] :
        Block[?Yield, ?Await, ?Return]

      Block[Yield, Await, Return] :
        `{` StatementList[?Yield, ?Await, ?Return]? `}`

      StatementList[Yield, Await, Return] :
        StatementListItem[?Yield, ?Await, ?Return]
        StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

      StatementListItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        Declaration[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-block-static-semantics-early-errors" oldids="sec-block-duplicates-allowed-static-semantics">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <ul>
        <li>
          <p>|StatementList| 의 LexicallyDeclaredNames 에 중복 항목이 존재하면 Syntax Error<span normative-optional> — 단, 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하고 다음 두 조건이 모두 참이면 예외:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) 이 *false*.</li>
            <li>중복 항목이 모두 FunctionDeclaration 에 의해 바인딩된다.</li>
          </ul>
        </li>
        <li>
          |StatementList| 의 LexicallyDeclaredNames 요소 중 어느 하나라도 |StatementList| 의 VarDeclaredNames 에도 나타나면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-block-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ 를 반환한다.
      </emu-alg>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. _oldEnv_ 를 실행 중인 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _blockEnv_ 를 NewDeclarativeEnvironment(_oldEnv_) 로 둔다.
        1. BlockDeclarationInstantiation(|StatementList|, _blockEnv_) 수행.
        1. 실행 컨텍스트의 LexicalEnvironment 를 _blockEnv_ 로 설정.
        1. _blockValue_ 를 Completion(|StatementList| 평가) 로 둔다.
        1. 실행 컨텍스트의 LexicalEnvironment 를 _oldEnv_ 로 되돌린다.
        1. ? _blockValue_ 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|Block| 을 어떻게 빠져나오든 LexicalEnvironment 는 항상 이전 상태로 복구된다.</p>
      </emu-note>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. _sl_ 을 |StatementList| 의 Evaluation 결과 (?) 로 둔다.
        1. _s_ 를 |StatementListItem| 평가의 Completion 으로 둔다.
        1. ? UpdateEmpty(_s_, _sl_) 를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|StatementList| 의 값은 그 안에서 마지막으로 값을 생산한 항목의 값이다. 예를 들어 아래 `eval` 호출은 모두 1을 반환한다:</p>
        <pre><code class="javascript">
          eval("1;;;;;")
          eval("1;{}")
          eval("1;var a;")
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-blockdeclarationinstantiation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ 는 블록 본문에 대응하는 Parse Node 이며, _env_ 는 바인딩이 생성될 Environment Record 이다.</dd>
      </dl>
      <emu-note>
        <p>|Block| 또는 |CaseBlock| 이 평가될 때 새 Declarative Environment Record 가 생성되고 블록 안에 선언된 블록 스코프 변수/상수/함수/클래스에 대한 바인딩이 그 Environment Record 안에서 생성된다.</p>
      </emu-note>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _declarations_ 를 _code_ 의 LexicallyScopedDeclarations 로 둔다.
        1. _privateEnv_ 를 실행 중인 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _declarations_ 의 각 요소 _d_ 에 대해
          1. _d_ 의 BoundNames 각 요소 _dn_ 에 대해
            1. IsConstantDeclaration(_d_) 가 *true* 이면
              1. ! _env_.CreateImmutableBinding(_dn_, *true*) 수행.
            1. 그렇지 않으면
              1. [id="step-blockdeclarationinstantiation-createmutablebinding", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
                1. ! _env_.HasBinding(_dn_) 이 *false* 이면
                  1. ! _env_.CreateMutableBinding(_dn_, *false*) 수행.
              1. 그렇지 않으면
                1. ! _env_.CreateMutableBinding(_dn_, *false*) 수행.
          1. _d_ 가 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| 중 하나라면
            1. _fn_ 을 _d_ 의 BoundNames 의 유일한 요소로 둔다.
            1. _fo_ 를 InstantiateFunctionObject(_d_, 인수 _env_, _privateEnv_) 로 둔다.
            1. [id="step-blockdeclarationinstantiation-initializebinding", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
              1. _env_ 에서 _fn_ 바인딩이 초기화되지 않았다면
                1. ! _env_.InitializeBinding(_fn_, _fo_) 수행.
              1. 그렇지 않으면
                1. 단언: _d_ 는 |FunctionDeclaration|.
                1. ! _env_.SetMutableBinding(_fn_, _fo_, *false*) 수행.
            1. 그렇지 않으면
              1. ! _env_.InitializeBinding(_fn_, _fo_) 수행.
        1. ~unused~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>선언과 변수 문(Variable Statement)</h1>

    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let 및 Const 선언</h1>
      <emu-note>
        <p>`let` 과 `const` 선언은 실행 중인 실행 컨텍스트의 LexicalEnvironment 에 스코프를 가지는 변수를 정의한다. 변수는 포함 Environment Record 가 초기화될 때 생성되지만 해당 변수의 |LexicalBinding| 이 평가되기 전에는 어떤 방식으로도 접근할 수 없다. |Initializer| 를 가진 |LexicalBinding| 으로 정의된 변수는 그 |LexicalBinding| 이 평가될 때 |Initializer| 의 |AssignmentExpression| 결과 값이 할당되며, 생성 시점이 아니다. `let` 선언에서 |Initializer| 가 없는 |LexicalBinding| 은 평가 시 *undefined* 가 할당된다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await] `;`

        LetOrConst :
          `let`
          `const`

        BindingList[In, Yield, Await] :
          LexicalBinding[?In, ?Yield, ?Await]
          BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]

        LexicalBinding[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <ul>
          <li>
            |BindingList| 의 BoundNames 목록에 *"let"* 이 포함되면 Syntax Error.
          </li>
          <li>
            |BindingList| 의 BoundNames 목록에 중복 항목이 있으면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <ul>
          <li>
            |Initializer| 가 없고 이 |LexicalBinding| 을 포함하는 |LexicalDeclaration| 의 IsConstantDeclaration 이 *true* 이면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. |BindingList| 평가를 ? 로 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. |BindingList| 평가를 ? 로 수행.
          1. |LexicalBinding| 평가 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 ! ResolveBinding(StringValue of |BindingIdentifier|) 로 둔다.
          1. ! InitializeReferencedBinding(_lhs_, *undefined*) 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-note>
          <p>정적 의미론 규칙은 이 형태의 |LexicalBinding| 이 `const` 선언에서는 발생하지 않음을 보장한다.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. _lhs_ 를 ! ResolveBinding(_bindingId_) 로 둔다.
          1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
            1. _value_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 결과 (?) 로 둔다.
          1. 그렇지 않으면
            1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
            1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. ! InitializeReferencedBinding(_lhs_, _value_) 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
          1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
          1. |BindingPattern| 의 BindingInitialization(_value_, _env_) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-variable-statement">
      <h1>Variable Statement</h1>
      <emu-note>
        <p>`var` 문은 실행 중인 실행 컨텍스트의 VariableEnvironment 에 스코프를 가지는 변수를 선언한다. Var 변수는 Environment Record 가 인스턴스화될 때 생성되며 생성과 동시에 *undefined* 로 초기화된다. 하나의 VariableEnvironment 스코프 내에서는 동일 |BindingIdentifier| 가 여러 |VariableDeclaration| 에 나타날 수 있으나 그것들은 하나의 변수만을 정의한다. |Initializer| 를 가진 |VariableDeclaration| 으로 정의된 변수는 선언이 실행될 때 |Initializer| 의 |AssignmentExpression| 결과 값이 할당되며, 생성 시점이 아니다.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        VariableStatement[Yield, Await] :
          `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`

        VariableDeclarationList[In, Yield, Await] :
          VariableDeclaration[?In, ?Yield, ?Await]
          VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]

        VariableDeclaration[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-variable-statement-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| 평가를 ? 로 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| 평가를 ? 로 수행.
          1. |VariableDeclaration| 평가 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. ~empty~ 반환.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. _lhs_ 를 ? ResolveBinding(_bindingId_) 로 둔다.
          1. IsAnonymousFunctionDefinition(|Initializer|) 이 *true* 이면
            1. _value_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 결과 (?) 로 둔다.
          1. 그렇지 않으면
            1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
            1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. [id="step-vardecllist-evaluation-putvalue"] ? PutValue(_lhs_, _value_) 수행.
          1. ~empty~ 반환.
        </emu-alg>
        <emu-note>
          <p>|VariableDeclaration| 이 with 문 내부에 중첩되어 있고 그 |BindingIdentifier| 가 with 문 Object Environment Record 의 바인딩 객체의 프로퍼티 이름과 같다면, 단계 <emu-xref href="#step-vardecllist-evaluation-putvalue"></emu-xref> 는 식별자의 VariableEnvironment 바인딩 대신 그 프로퍼티에 _value_ 를 할당한다.</p>
        </emu-note>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. _rhs_ 를 |Initializer| 평가 결과 (?) 로 둔다.
          1. _rVal_ 를 ? GetValue(_rhs_) 로 둔다.
          1. |BindingPattern| 의 BindingInitialization(_rVal_, *undefined*) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>구조 분해 바인딩 패턴(Destructuring Binding Patterns)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization" type="sdo">
        <h1>
          런타임 의미론: PropertyBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          ): 정상 완료 시 프로퍼티 키 List 또는 abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>바인딩된 모든 프로퍼티 이름 목록을 수집한다.</dd>
        </dl>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. _boundNames_ 를 |BindingPropertyList| 의 PropertyBindingInitialization(_value_, _environment_) 결과 (?) 로 둔다.
          1. _nextNames_ 를 |BindingProperty| 의 PropertyBindingInitialization(_value_, _environment_) 결과 (?) 로 둔다.
          1. _boundNames_ 와 _nextNames_ 의 리스트 연결을 반환.
        </emu-alg>

        <emu-grammar>BindingProperty : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. _name_ 을 |SingleNameBinding| 의 BoundNames 유일 요소로 둔다.
          1. |SingleNameBinding| 의 KeyedBindingInitialization(_value_, _environment_, _name_) 를 ? 로 수행.
          1. « _name_ » 반환.
        </emu-alg>

        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. _P_ 를 |PropertyName| 평가 결과 (?) 로 둔다.
          1. |BindingElement| 의 KeyedBindingInitialization(_value_, _environment_, _P_) 를 ? 로 수행.
          1. « _P_ » 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          런타임 의미론: RestBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          _excludedNames_: a List of property keys,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. _lhs_ 를 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_) 로 둔다.
          1. _restObj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. ? CopyDataProperties(_restObj_, _value_, _excludedNames_) 수행.
          1. _environment_ 가 *undefined* 이면 ? PutValue(_lhs_, _restObj_) 반환.
          1. ? InitializeReferencedBinding(_lhs_, _restObj_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          런타임 의미론: KeyedBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          _propertyName_: a property key,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>_environment_ 에 *undefined* 를 전달하면 값 할당에 PutValue 연산을 사용해야 함을 의미한다. 이는 비엄격 함수의 형식 매개변수 리스트 등의 경우이며, 그때는 동일 이름 매개변수 가능성 때문에 사전 초기화된다.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. _v_ 를 ? GetV(_value_, _propertyName_) 로 둔다.
          1. |Initializer| 존재하고 _v_ 가 *undefined* 이면
            1. _defaultValue_ 를 |Initializer| 평가 결과 (?) 로 둔다.
            1. _v_ 를 ? GetValue(_defaultValue_) 로 설정.
          1. |BindingPattern| 의 BindingInitialization(_v_, _environment_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. _lhs_ 를 ? ResolveBinding(_bindingId_, _environment_) 로 둔다.
          1. _v_ 를 ? GetV(_value_, _propertyName_) 로 둔다.
          1. |Initializer| 존재하고 _v_ 가 *undefined* 이면
            1. IsAnonymousFunctionDefinition(|Initializer|) *true* 이면
              1. _v_ 를 |Initializer| 의 NamedEvaluation(_bindingId_) 결과 (?) 로 둔다.
            1. 아니면
              1. _defaultValue_ 를 |Initializer| 평가 결과 (?) 로 둔다.
              1. _v_ 를 ? GetValue(_defaultValue_) 로 둔다.
          1. _environment_ 가 *undefined* 이면 ? PutValue(_lhs_, _v_) 반환.
          1. ? InitializeReferencedBinding(_lhs_, _v_) 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-empty-statement">
    <h1>Empty Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EmptyStatement :
        `;`
    </emu-grammar>

    <emu-clause id="sec-empty-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>EmptyStatement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-expression-statement">
    <h1>Expression Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ExpressionStatement[Yield, Await] :
        [lookahead &notin; { `{`, `function`, `async` [no LineTerminator here] `function`, `class`, `let` `[` }] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>|ExpressionStatement| 는 U+007B (LEFT CURLY BRACKET) 으로 시작할 수 없는데, 이는 |Block| 과의 모호성을 피하기 위해서이다. 또한 `function` 또는 `class` 로 시작할 수 없는데 그러면 |FunctionDeclaration|, |GeneratorDeclaration|, |ClassDeclaration| 과 모호하기 때문이다. `async function` 으로 시작할 수 없는 이유는 |AsyncFunctionDeclaration| 또는 |AsyncGeneratorDeclaration| 과 모호하기 때문이다. `let [` 두 토큰 시퀀스로 시작할 수 없는 이유는 첫 |LexicalBinding| 이 |ArrayBindingPattern| 인 `let` |LexicalDeclaration| 과 모호하기 때문이다.</p>
    </emu-note>

    <emu-clause id="sec-expression-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ExpressionStatement : Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
        1. ? GetValue(_exprRef_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-if-statement">
    <h1>`if` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IfStatement[Yield, Await, Return] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] [lookahead != `else`]
    </emu-grammar>
    <emu-note>lookahead 제한 [lookahead ≠ `else`] 는 고전적인 “dangling else” 문제를 통상 방식으로 해결한다. 즉 어떤 `else` 가 어느 `if` 와 연관될지 모호할 때 가장 안쪽(가장 가까운)의 `if` 와 결합된다.</emu-note>

    <emu-clause id="sec-if-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <ul>
        <li>
          첫 번째 |Statement| 에 대해 IsLabelledFunction(...) 이 *true* 이면 Syntax Error.
        </li>
        <li>
          두 번째 |Statement| 에 대해 IsLabelledFunction(...) 이 *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          |Statement| 에 대해 IsLabelledFunction(...) 이 *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-note>
        <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 에 명시된 확장이 구현된 경우에만 이 규칙을 적용하면 된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-if-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
        1. _exprValue_ 를 ToBoolean(? GetValue(_exprRef_)) 로 둔다.
        1. _exprValue_ 가 *true* 이면
          1. _stmtCompletion_ 를 첫 번째 |Statement| 평가의 Completion 으로 둔다.
        1. 그렇지 않으면
          1. _stmtCompletion_ 를 두 번째 |Statement| 평가의 Completion 으로 둔다.
        1. ? UpdateEmpty(_stmtCompletion_, *undefined*) 반환.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
        1. _exprValue_ 를 ToBoolean(? GetValue(_exprRef_)) 로 둔다.
        1. _exprValue_ 가 *false* 이면
          1. *undefined* 반환.
        1. 그렇지 않으면
          1. _stmtCompletion_ 를 |Statement| 평가의 Completion 으로 둔다.
          1. ? UpdateEmpty(_stmtCompletion_, *undefined*) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>Iteration Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IterationStatement[Yield, Await, Return] :
        DoWhileStatement[?Yield, ?Await, ?Return]
        WhileStatement[?Yield, ?Await, ?Return]
        ForStatement[?Yield, ?Await, ?Return]
        ForInOfStatement[?Yield, ?Await, ?Return]
    </emu-grammar>

    <emu-clause id="sec-iteration-statements-semantics">
      <h1>의미론</h1>

      <emu-clause id="sec-loopcontinues" type="abstract operation">
        <h1>
          LoopContinues (
            _completion_: a Completion Record,
            _labelSet_: a List of Strings,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _completion_ 이 정상 completion 이면 *true* 반환.
          1. _completion_ 이 continue completion 이 아니면 *false* 반환.
          1. _completion_.[[Target]] 이 ~empty~ 이면 *true* 반환.
          1. _labelSet_ 이 _completion_.[[Target]] 을 포함하면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
        <emu-note>
          <p>|IterationStatement| 의 |Statement| 부분 내부에서는 |ContinueStatement| 로 새 반복을 시작할 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-loopevaluation" type="sdo">
        <h1>
          런타임 의미론: LoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 언어 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>IterationStatement : DoWhileStatement</emu-grammar>
        <emu-alg>
          1. |DoWhileStatement| 의 DoWhileLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>IterationStatement : WhileStatement</emu-grammar>
        <emu-alg>
          1. |WhileStatement| 의 WhileLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>IterationStatement : ForStatement</emu-grammar>
        <emu-alg>
          1. |ForStatement| 의 ForLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>IterationStatement : ForInOfStatement</emu-grammar>
        <emu-alg>
          1. |ForInOfStatement| 의 ForIn/OfLoopEvaluation(_labelSet_) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-do-while-statement">
      <h1>`do`-`while` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        DoWhileStatement[Yield, Await, Return] :
          `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
      </emu-grammar>

      <emu-clause id="sec-do-while-statement-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-dowhileloopevaluation" oldids="sec-do-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: DoWhileLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. _V_ 를 *undefined* 로 둔다.
          1. 반복,
            1. _stmtResult_ 를 |Statement| 평가 Completion 으로 둔다.
            1. LoopContinues(_stmtResult_, _labelSet_) 가 *false* 이면 ? UpdateEmpty(_stmtResult_, _V_) 반환.
            1. _stmtResult_.[[Value]] 가 ~empty~ 가 아니면 _V_ 를 그 값으로 설정.
            1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
            1. _exprValue_ 를 ? GetValue(_exprRef_) 로 둔다.
            1. ToBoolean(_exprValue_) 가 *false* 이면 _V_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-while-statement">
      <h1>`while` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        WhileStatement[Yield, Await, Return] :
          `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-while-statement-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-whileloopevaluation" oldids="sec-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: WhileLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _V_ 를 *undefined* 로 둔다.
          1. 반복,
            1. _exprRef_ 를 |Expression| 평가 결과 (?) 로 둔다.
            1. _exprValue_ 를 ? GetValue(_exprRef_) 로 둔다.
            1. ToBoolean(_exprValue_) 가 *false* 이면 _V_ 반환.
            1. _stmtResult_ 를 |Statement| 평가 Completion 으로 둔다.
            1. LoopContinues(_stmtResult_, _labelSet_) 가 *false* 이면 ? UpdateEmpty(_stmtResult_, _V_) 반환.
            1. _stmtResult_.[[Value]] 가 ~empty~ 가 아니면 _V_ 갱신.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-statement">
      <h1>`for` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-for-statement-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>
          ForStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <ul>
          <li>
            |LexicalDeclaration| 의 BoundNames 요소 중 하나라도 |Statement| 의 VarDeclaredNames 에 나타나면 Syntax Error.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: ForLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. 첫 번째 |Expression| 존재하면
            1. _exprRef_ 를 그 평가 결과 (?) 로 둔다.
            1. ? GetValue(_exprRef_) 수행.
          1. 두 번째 |Expression| 존재하면 _test_ 를 그 |Expression| 으로, 아니면 ~empty~.
          1. 세 번째 |Expression| 존재하면 _increment_ 를 그 |Expression| 으로, 아니면 ~empty~.
          1. ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. |VariableDeclarationList| 평가를 ? 로 수행.
          1. 첫 번째 |Expression| 존재하면 _test_ 를 그 |Expression|, 아니면 ~empty~.
          1. 두 번째 |Expression| 존재하면 _increment_ 를 그 |Expression|, 아니면 ~empty~.
          1. ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_) 결과를 ? 로 반환.
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. _oldEnv_ 를 실행 컨텍스트 LexicalEnvironment 로 둔다.
          1. _loopEnv_ 를 NewDeclarativeEnvironment(_oldEnv_) 로 둔다.
          1. _isConst_ 를 |LexicalDeclaration| 의 IsConstantDeclaration 으로 둔다.
          1. _boundNames_ 를 |LexicalDeclaration| 의 BoundNames 로 둔다.
          1. 각 _dn_ ∈ _boundNames_ 에 대해
            1. _isConst_ 가 *true* 이면 ! _loopEnv_.CreateImmutableBinding(_dn_, *true*)
            1. 아니면 ! _loopEnv_.CreateMutableBinding(_dn_, *false*)
          1. 실행 컨텍스트 LexicalEnvironment 를 _loopEnv_ 로 설정.
          1. _forDcl_ 를 |LexicalDeclaration| 평가 Completion 으로 둔다.
          1. _forDcl_ 이 abrupt 면
            1. LexicalEnvironment 를 _oldEnv_ 로 복구.
            1. ? _forDcl_ 반환.
          1. _isConst_ 가 *false* 이면 _perIterationLets_ = _boundNames_; 아니면 새 빈 List.
          1. 첫 번째 |Expression| 존재하면 _test_ 그 |Expression|; 아니면 ~empty~.
          1. 두 번째 |Expression| 존재하면 _increment_ 그 |Expression|; 아니면 ~empty~.
          1. _bodyResult_ 를 Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)) 로 둔다.
          1. LexicalEnvironment 를 _oldEnv_ 로 복구.
          1. ? _bodyResult_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" type="abstract operation">
        <h1>
          ForBodyEvaluation (
            _test_: an |Expression| Parse Node or ~empty~,
            _increment_: an |Expression| Parse Node or ~empty~,
            _stmt_: a |Statement| Parse Node,
            _perIterationBindings_: a List of Strings,
            _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _V_ = *undefined*.
          1. ? CreatePerIterationEnvironment(_perIterationBindings_) 수행.
          1. 반복,
            1. _test_ 가 ~empty~ 이 아니면
              1. _testRef_ = ? _test_ 평가
              1. _testValue_ = ? GetValue(_testRef_)
              1. ToBoolean(_testValue_) 가 *false* 면 _V_ 반환.
            1. _result_ = _stmt_ 평가 Completion
            1. LoopContinues(_result_, _labelSet_) 가 *false* 면 ? UpdateEmpty(_result_, _V_) 반환.
            1. _result_.[[Value]] 가 ~empty~ 아니면 _V_ 갱신.
            1. ? CreatePerIterationEnvironment(_perIterationBindings_) 수행.
            1. _increment_ 가 ~empty~ 아니면
              1. _incRef_ = ? _increment_ 평가
              1. ? GetValue(_incRef_) 수행.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" type="abstract operation">
        <h1>
          CreatePerIterationEnvironment (
            _perIterationBindings_: a List of Strings,
          ): 정상 완료 시 ~unused~ 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _perIterationBindings_ 에 요소가 있으면
            1. _lastIterationEnv_ = 실행 컨텍스트 LexicalEnvironment
            1. _outer_ = _lastIterationEnv_.[[OuterEnv]]
            1. 단언: _outer_ != *null*
            1. _thisIterationEnv_ = NewDeclarativeEnvironment(_outer_)
            1. 각 _bn_ ∈ _perIterationBindings_ 에 대해
              1. ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*)
              1. _lastValue_ = ? _lastIterationEnv_.GetBindingValue(_bn_, *true*)
              1. ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_)
            1. 실행 컨텍스트 LexicalEnvironment = _thisIterationEnv_
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>`for`-`in`, `for`-`of`, `for`-`await`-`of` 문</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; { `let`, `async` `of` }] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await] :
          LetOrConst ForBinding[?Yield, ?Await]

        ForBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await]
          BindingPattern[?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>이 절은 부록 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 의해 확장된다.</p>
      </emu-note>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            IsLabelledFunction(|Statement|) 이 *true* 이면 Syntax Error.
          </li>
        </ul>
        <emu-note>
          <p><emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
        </emu-note>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |LeftHandSideExpression| 이 |ObjectLiteral| 또는 |ArrayLiteral| 이면 |AssignmentPattern| 을 커버해야 한다.
          </li>
          <li>
            그렇지 않으면 |LeftHandSideExpression| 의 AssignmentTargetType 이 ~invalid~ 이면 Syntax Error.
          </li>
        </ul>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            |ForDeclaration| 의 BoundNames 에 *"let"* 포함 시 Syntax Error.
          </li>
          <li>|ForDeclaration| 의 BoundNames 요소가 |Statement| 의 VarDeclaredNames 에도 나타나면 Syntax Error.</li>
          <li>|ForDeclaration| 의 BoundNames 에 중복 항목이 있으면 Syntax Error.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-isdestructuring" oldids="sec-static-semantics-static-semantics-isdestructuring,sec-for-in-and-for-of-statements-static-semantics-isdestructuring" type="sdo">
        <h1>정적 의미론: IsDestructuring ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. |PrimaryExpression| 이 |ObjectLiteral| 또는 |ArrayLiteral| 이면 *true* 반환.
          1. 그 외 *false* 반환.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            MemberExpression `.` PrivateIdentifier

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
            OptionalExpression
        </emu-grammar>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| 의 IsDestructuring 반환.
        </emu-alg>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. *false* 반환.
        </emu-alg>
        <emu-grammar>ForBinding : BindingPattern</emu-grammar>
        <emu-alg>
          1. *true* 반환.
        </emu-alg>
        <emu-note>
          <p>이 절은 부록 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 의해 확장된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginitialization" oldids="sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization" type="sdo">
        <h1>
          런타임 의미론: ForDeclarationBindingInitialization (
          _value_: an ECMAScript language value,
          _environment_: an Environment Record or *undefined*,
          ): 정상 완료 시 ~unused~ 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>_environment_ 로 *undefined* 가 전달되면 PutValue 로 초기화해야 함을 의미한다. 이는 `var` 문 및 일부 비엄격 함수의 매개변수 리스트 경우 ( <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref> 참조 )에 해당한다. 그 경우 렉시컬 바인딩이 초기화자 평가 전 호이스팅·사전 초기화된다.</p>
        </emu-note>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| 의 BindingInitialization(_value_, _environment_) 결과를 ? 로 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          런타임 의미론: ForDeclarationBindingInstantiation (
          _environment_: a Declarative Environment Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. |ForBinding| 의 BoundNames 각 _name_ 에 대해
            1. IsConstantDeclaration(|LetOrConst|) 이 *true* 이면 ! _environment_.CreateImmutableBinding(_name_, *true*)
            1. 아니면 ! _environment_.CreateMutableBinding(_name_, *false*)
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofloopevaluation" oldids="sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          런타임 의미론: ForInOfLoopEvaluation (
          _labelSet_: a List of Strings,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~)
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~)
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_) 반환.
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~)
          1. ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~) 반환.
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~) 반환.
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ = ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~)
          1. ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~) 반환.
        </emu-alg>
        <emu-note>
          <p>이 절은 부록 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 의해 확장된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofheadevaluation" type="abstract operation" oldids="sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">
        <h1>
          ForIn/OfHeadEvaluation (
            _uninitializedBoundNames_: a List of Strings,
            _expr_: an |Expression| Parse Node or an |AssignmentExpression| Parse Node,
            _iterationKind_: ~enumerate~, ~iterate~, or ~async-iterate~,
          ): 정상 완료 시 Iterator Record 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _oldEnv_ = 실행 컨텍스트 LexicalEnvironment
          1. _uninitializedBoundNames_ 가 비어있지 않다면
            1. 단언: 중복 없음
            1. _newEnv_ = NewDeclarativeEnvironment(_oldEnv_)
            1. 각 _name_ ∈ _uninitializedBoundNames_ 에 대해
              1. ! _newEnv_.CreateMutableBinding(_name_, *false*)
            1. LexicalEnvironment = _newEnv_
          1. _exprRef_ = _expr_ 평가 Completion
          1. LexicalEnvironment = _oldEnv_
          1. _exprValue_ = ? GetValue(? _exprRef_)
          1. _iterationKind_ 가 ~enumerate~ 이면
            1. _exprValue_ 가 *undefined* 또는 *null* 이면
              1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ } 반환.
            1. _obj_ = ! ToObject(_exprValue_)
            1. _iterator_ = EnumerateObjectProperties(_obj_)
            1. _nextMethod_ = ! GetV(_iterator_, *"next"*)
            1. Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* } 반환.
          1. 그렇지 않으면
            1. 단언: ~iterate~ 또는 ~async-iterate~
            1. _iteratorKind_ = (_iterationKind_ 이 ~async-iterate~ 이면 ~async~ 아니면 ~sync~)
            1. ? GetIterator(_exprValue_, _iteratorKind_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
            _lhs_: a Parse Node,
            _stmt_: a |Statement| Parse Node,
            _iteratorRecord_: an Iterator Record,
            _iterationKind_: ~enumerate~ or ~iterate~,
            _lhsKind_: ~assignment~, ~var-binding~, or ~lexical-binding~,
            _labelSet_: a List of Strings,
            optional _iteratorKind_: ~sync~ or ~async~,
          ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _iteratorKind_ 가 없으면 ~sync~ 로 설정.
          1. _oldEnv_ = 실행 컨텍스트 LexicalEnvironment
          1. _V_ = *undefined*
          1. _destructuring_ = IsDestructuring(_lhs_)
          1. _destructuring_ *true* 그리고 _lhsKind_ = ~assignment~ 이면
            1. 단언: _lhs_ 는 |LeftHandSideExpression|
            1. _assignmentPattern_ = _lhs_ 가 커버하는 |AssignmentPattern|
          1. 반복,
            1. _nextResult_ = ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]])
            1. _iteratorKind_ = ~async~ 이면 _nextResult_ = ? Await(_nextResult_)
            1. _nextResult_ 가 Object 아니면 *TypeError* throw
            1. _done_ = ? IteratorComplete(_nextResult_)
            1. _done_ *true* 이면 _V_ 반환
            1. _nextValue_ = ? IteratorValue(_nextResult_)
            1. _lhsKind_ ∈ {~assignment~, ~var-binding~} 이면
              1. _destructuring_ *true* 이면
                1. _lhsKind_ = ~assignment~ 이면
                  1. _status_ = Completion(DestructuringAssignmentEvaluation(_assignmentPattern_, _nextValue_))
                1. 아니면 (var-binding)
                  1. 단언: _lhs_ 는 |ForBinding|
                  1. _status_ = Completion(BindingInitialization(_lhs_, _nextValue_, *undefined*))
              1. _destructuring_ *false* 이면
                1. _lhsRef_ = Completion(Evaluation(_lhs_))
                1. _lhsKind_ = ~assignment~ 이고 AssignmentTargetType(_lhs_) = ~web-compat~ 이면 *ReferenceError* throw
                1. _lhsRef_ 가 abrupt 이면 _status_ = _lhsRef_
                1. 아니면 _status_ = Completion(PutValue(_lhsRef_.[[Value]], _nextValue_))
            1. 그렇지 않으면
              1. 단언: _lhsKind_ = ~lexical-binding~
              1. 단언: _lhs_ 는 |ForDeclaration|
              1. _iterationEnv_ = NewDeclarativeEnvironment(_oldEnv_)
              1. ForDeclarationBindingInstantiation(_lhs_, _iterationEnv_) 수행
              1. LexicalEnvironment = _iterationEnv_
              1. _destructuring_ *true* 이면
                1. _status_ = Completion(ForDeclarationBindingInitialization(_lhs_, _nextValue_, _iterationEnv_))
              1. 아니면
                1. 단언: 단일 이름 바인딩
                1. _lhsName_ = BoundNames(_lhs_) 의 유일 요소
                1. _lhsRef_ = ! ResolveBinding(_lhsName_)
                1. _status_ = Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_))
            1. _status_ abrupt 이면
              1. LexicalEnvironment = _oldEnv_
              1. _iteratorKind_ = ~async~ 이면 ? AsyncIteratorClose(_iteratorRecord_, _status_) 반환
              1. _iterationKind_ = ~enumerate~ 이면 ? _status_ 반환
              1. 아니면 (iterate)
                1. ? IteratorClose(_iteratorRecord_, _status_) 반환
            1. _result_ = Completion(Evaluation(_stmt_))
            1. LexicalEnvironment = _oldEnv_
            1. LoopContinues(_result_, _labelSet_) *false* 이면
              1. _iterationKind_ = ~enumerate~ 이면 ? UpdateEmpty(_result_, _V_) 반환
              1. 아니면 (iterate)
                1. _status_ = Completion(UpdateEmpty(_result_, _V_))
                1. _iteratorKind_ = ~async~ 이면 ? AsyncIteratorClose(_iteratorRecord_, _status_) 반환
                1. ? IteratorClose(_iteratorRecord_, _status_) 반환
            1. _result_.[[Value]] 가 ~empty~ 아니면 _V_ 갱신
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>
          BindingIdentifier :
            Identifier
            `yield`
            `await`
        </emu-grammar>
        <emu-alg>
          1. _bindingId_ 를 |BindingIdentifier| 의 StringValue 로 둔다.
          1. ? ResolveBinding(_bindingId_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-enumerate-object-properties" type="abstract operation">
        <h1>
          EnumerateObjectProperties (
            _O_: an Object,
          ): iterator 객체
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _O_ 의 열거 가능한 프로퍼티 중 String 키를 순회하는 `next` 메서드를 가진 iterator 객체를 반환한다. 이 객체는 ECMAScript 코드에서 직접 접근 불가하다. 순서 및 메커니즘은 아래 규칙을 준수해야 한다.
        </emu-alg>
        <p>이 iterator 의 `throw`, `return` 메서드는 *null* 이며 호출되지 않는다. `next` 메서드는 프로퍼티 키 반환 여부를 결정한다. 반환 키에는 Symbol 키 미포함. 대상 객체의 프로퍼티는 열거 중 삭제될 수 있으며 삭제된 프로퍼티는 무시된다. 열거 중 추가된 프로퍼티는 반드시 처리된다고 보장되지 않는다. 한 프로퍼티 이름은 하나의 열거에서 최대 한 번만 반환된다.</p>
        <p>대상 객체 프로퍼티 열거에는 프로토타입 사슬의 프로퍼티도 재귀적으로 포함되지만, 이미 반환된 이름과 동일한 프로토타입 프로퍼티는 무시된다. [[Enumerable]] 값 비교는 중복 판단에 사용되지 않는다. 프로토타입 객체의 열거 가능한 이름은 그 프로토타입을 인수로 EnumerateObjectProperties 를 호출하여 얻어야 한다. 대상 객체의 own keys 는 [[OwnPropertyKeys]] 내부 메서드, 속성 서술자는 [[GetOwnProperty]] 내부 메서드를 통해 얻는다.</p>
        <p>또한 _O_ 나 그 프로토타입 체인 어느 객체도 Proxy/TypedArray/module namespace/exotic (구현 정의) 객체가 아니라면, 다음 사건 중 하나가 발생할 때까지 iterator 는 CreateForInIterator(_O_) 가 준 iterator 처럼 동작해야 한다:</p>
        <ul>
          <li>_O_ 또는 프로토타입 체인 객체의 [[Prototype]] 값 변경</li>
          <li>_O_ 또는 프로토타입 체인 객체에서 프로퍼티 제거</li>
          <li>프로토타입 체인 객체에 프로퍼티 추가</li>
          <li>_O_ 또는 체인 객체 프로퍼티의 [[Enumerable]] 값 변경</li>
        </ul>

        <emu-note>
          <p>구현은 <emu-xref href="#sec-%foriniteratorprototype%.next"></emu-xref> 알고리즘을 직접 구현할 필요는 없다. 위 제약 위반 전까지 동등 동작을 유지하는 임의 구현 가능.</p>
          <p>다음은 이러한 규칙을 만족하는 ECMAScript generator 함수의 예시(정보적):</p>
          <pre><code class="javascript">
            function* EnumerateObjectProperties(obj) {
              const visited = new Set();
              for (const key of Reflect.ownKeys(obj)) {
                if (typeof key === "symbol") continue;
                const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                if (desc) {
                  visited.add(key);
                  if (desc.enumerable) yield key;
                }
              }
              const proto = Reflect.getPrototypeOf(obj);
              if (proto === null) return;
              for (const protoKey of EnumerateObjectProperties(proto)) {
                if (!visited.has(protoKey)) yield protoKey;
              }
            }
          </code></pre>
        </emu-note>
        <emu-note>
          구현이 CreateForInIterator 와 일치할 필요가 없는 exotic 객체 목록은 역사적으로 구현별 차이가 있었던 경우이며 그 외에는 합의된 경우이다.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-iterator-objects">
        <h1>For-In Iterator 객체</h1>
        <p><dfn variants="For-In Iterator object,For-In Iterator objects">For-In Iterator</dfn> 는 특정 객체에 대한 특정 반복을 나타내는 객체이다. ECMAScript 코드에서 직접 접근할 수 없으며 EnumerateObjectProperties 동작 설명용이다.</p>

        <emu-clause id="sec-createforiniterator" type="abstract operation">
          <h1>
            CreateForInIterator (
              _object_: an Object,
            ): For-In Iterator
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_object_ 의 own 및 상속된 열거 가능한 문자열 프로퍼티를 특정 순서로 순회하는 For-In Iterator 를 생성한다.</dd>
          </dl>
          <emu-alg>
            1. _iterator_ = OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »)
            1. _iterator_.[[Object]] = _object_
            1. _iterator_.[[ObjectWasVisited]] = *false*
            1. _iterator_.[[VisitedKeys]] = 새 빈 List
            1. _iterator_.[[RemainingKeys]] = 새 빈 List
            1. _iterator_ 반환
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%foriniteratorprototype%-object">
          <h1>%ForInIteratorPrototype% 객체</h1>
          <p><dfn>%ForInIteratorPrototype%</dfn> 객체:</p>
          <ul>
            <li>모든 For-In Iterator 객체가 상속하는 프로퍼티를 가진다.</li>
            <li>ordinary object 이다.</li>
            <li>[[Prototype]] 슬롯 값은 %Iterator.prototype%.</li>
            <li>ECMAScript 코드에서 직접 접근할 수 없다.</li>
            <li>다음 프로퍼티를 가진다:</li>
          </ul>

          <emu-clause id="sec-%foriniteratorprototype%.next">
            <h1>%ForInIteratorPrototype%.next ( )</h1>
            <emu-alg>
              1. _O_ 를 *this* 값으로 둔다.
              1. 단언: _O_ 는 Object.
              1. 단언: _O_ 는 For-In Iterator 인스턴스 내부 슬롯을 모두 가진다 (<emu-xref href="#sec-properties-of-for-in-iterator-instances"></emu-xref>).
              1. _object_ = _O_.[[Object]]
              1. 반복,
                1. _O_.[[ObjectWasVisited]] *false* 이면
                  1. _keys_ = ? <emu-meta effects="user-code">_object_.[[OwnPropertyKeys]]()</emu-meta>
                  1. 각 _key_ ∈ _keys_ 에 대해
                    1. _key_ 가 String 이면 _O_.[[RemainingKeys]] 에 추가
                  1. _O_.[[ObjectWasVisited]] = *true*
                1. _O_.[[RemainingKeys]] 비어있지 않은 동안 반복
                  1. _r_ = 첫 요소
                  1. 첫 요소 제거
                  1. _O_.[[VisitedKeys]] 에 _r_ 없으면
                    1. _desc_ = ? <emu-meta effects="user-code">_object_.[[GetOwnProperty]]</emu-meta>(_r_)
                    1. _desc_ != *undefined* 이면
                      1. _r_ 를 _O_.[[VisitedKeys]] 에 추가
                      1. _desc_.[[Enumerable]] *true* 이면 CreateIteratorResultObject(_r_, *false*) 반환
                1. _object_ = ? <emu-meta effects="user-code">_object_.[[GetPrototypeOf]]()</emu-meta>
                1. _O_.[[Object]] = _object_
                1. _O_.[[ObjectWasVisited]] = *false*
                1. _object_ 가 *null* 이면 CreateIteratorResultObject(*undefined*, *true*) 반환
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-properties-of-for-in-iterator-instances">
          <h1>For-In Iterator 인스턴스의 프로퍼티</h1>
          <p>For-In Iterator 인스턴스는 %ForInIteratorPrototype% 을 상속하는 ordinary 객체이다. 인스턴스는 <emu-xref href="#table-for-in-iterator-instance-slots"></emu-xref> 의 내부 슬롯을 가진다.</p>
          <emu-table id="table-for-in-iterator-instance-slots" caption="For-In Iterator 인스턴스의 내부 슬롯">
            <table>
              <thead>
                <tr>
                  <th>
                    Internal Slot
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    설명
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  [[Object]]
                </td>
                <td>
                  an Object
                </td>
                <td>
                  현재 프로퍼티를 열거 중인 객체.
                </td>
              </tr>
              <tr>
                <td>
                  [[ObjectWasVisited]]
                </td>
                <td>
                  a Boolean
                </td>
                <td>
                  iterator 가 [[OwnPropertyKeys]] 를 호출했으면 *true*, 아니면 *false*.
                </td>
              </tr>
              <tr>
                <td>
                  [[VisitedKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  지금까지 방출된 값들.
                </td>
              </tr>
              <tr>
                <td>
                  [[RemainingKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  현재 객체에서 아직 방출되지 않은 값들 (프로토타입 열거 전).
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-continue-statement">
    <h1>`continue` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ContinueStatement[Yield, Await] :
        `continue` `;`
        `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-continue-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>
        ContinueStatement :
          `continue` `;`
          `continue` LabelIdentifier `;`
      </emu-grammar>
      <ul>
        <li>
          이 |ContinueStatement| 가 (함수나 `static` 초기화 블록 경계를 넘지 않고) 직접 또는 간접적으로 |IterationStatement| 내에 중첩되지 않았다면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-continue-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ } 반환.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _label_ = |LabelIdentifier| 의 StringValue
        1. Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ } 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-break-statement">
    <h1>`break` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BreakStatement[Yield, Await] :
        `break` `;`
        `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-break-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <ul>
        <li>
          이 |BreakStatement| 가 (함수나 `static` 초기화 블록 경계를 넘지 않고) 직접 또는 간접적으로 |IterationStatement| 또는 |SwitchStatement| 안에 중첩되지 않았다면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-break-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ } 반환.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. _label_ = |LabelIdentifier| 의 StringValue
        1. Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ } 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-return-statement">
    <h1>`return` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ReturnStatement[Yield, Await] :
        `return` `;`
        `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>`return` 문은 함수를 종료하고(대부분 경우) 호출자에게 값을 반환한다. |Expression| 이 없으면 반환 값은 *undefined*. 있으면 그 표현식의 값. `return` 문이 주변 컨텍스트에 따라 실제로 호출자에게 값을 반환하지 않을 수도 있다. 예: `try` 블록 내 `return` 의 Completion Record 는 `finally` 블록 평가 중 다른 Completion Record 로 대체될 수 있다.</p>
    </emu-note>

    <emu-clause id="sec-return-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>ReturnStatement : `return` `;`</emu-grammar>
      <emu-alg>
        1. ReturnCompletion(*undefined*) 반환.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ = |Expression| 평가 결과 (?)
        1. _exprValue_ = ? GetValue(_exprRef_)
        1. GetGeneratorKind() 가 ~async~ 이면 _exprValue_ = ? Await(_exprValue_)
        1. ReturnCompletion(_exprValue_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-with-statement" legacy>
    <h1>`with` 문</h1>
    <emu-note>
      <p>레거시 `with` 문 사용은 새로운 ECMAScript 코드에서 권장되지 않는다. 엄격/비엄격 모두 허용되는 <emu-xref href="#sec-destructuring-assignment">구조 분해 할당</emu-xref> 등의 대안을 고려하라.</p>
    </emu-note>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WithStatement[Yield, Await, Return] :
        `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <emu-note>
      <p>`with` 문은 계산된 객체에 대한 Object Environment Record 를 실행 컨텍스트의 렉시컬 환경에 추가한 후 그 확장된 환경으로 문을 실행하고 마지막에 원래 환경을 복구한다.</p>
    </emu-note>

    <emu-clause id="sec-with-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          IsStrict(this production) *true* 이면 Syntax Error.
        </li>
        <li>
          IsLabelledFunction(|Statement|) *true* 이면 Syntax Error.
        </li>
      </ul>
      <emu-note>
        <p>두 번째 규칙은 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 확장이 구현된 경우에만 적용.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-with-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. _val_ = |Expression| 평가 결과 (?)
        1. _obj_ = ? ToObject(? GetValue(_val_))
        1. _oldEnv_ = 현재 LexicalEnvironment
        1. _newEnv_ = NewObjectEnvironment(_obj_, *true*, _oldEnv_)
        1. LexicalEnvironment = _newEnv_
        1. _C_ = |Statement| 평가 Completion
        1. LexicalEnvironment = _oldEnv_
        1. ? UpdateEmpty(_C_, *undefined*) 반환
      </emu-alg>
      <emu-note>
        <p>임의의 경로로 embedded |Statement| 를 빠져나와도(정상/abrupt) LexicalEnvironment 는 항상 복원된다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>`switch` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SwitchStatement[Yield, Await, Return] :
        `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]

      CaseBlock[Yield, Await, Return] :
        `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
        `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`

      CaseClauses[Yield, Await, Return] :
        CaseClause[?Yield, ?Await, ?Return]
        CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

      CaseClause[Yield, Await, Return] :
        `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?

      DefaultClause[Yield, Await, Return] :
        `default` `:` StatementList[?Yield, ?Await, ?Return]?
    </emu-grammar>

    <emu-clause id="sec-switch-statement-static-semantics-early-errors" oldids="sec-switch-duplicates-allowed-static-semantics">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <ul>
        <li>
          <p>|CaseBlock| 의 LexicallyDeclaredNames 에 중복 항목이 있으면 Syntax Error<span normative-optional> — 단, 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하고 두 조건이 모두 참이면 예외:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) *false*</li>
            <li>중복 항목이 FunctionDeclaration 에 의해서만 바인딩</li>
          </ul>
        </li>
        <li>
          |CaseBlock| 의 LexicallyDeclaredNames 요소가 |CaseBlock| 의 VarDeclaredNames 에도 나타나면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseblockevaluation" type="sdo">
      <h1>
        런타임 의미론: CaseBlockEvaluation (
        _input_: an ECMAScript language value,
        ): 정상 완료 시 ECMAScript 값 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. *undefined* 반환.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses `}`</emu-grammar>
      <emu-alg>
        1. _V_ = *undefined*
        1. _A_ = |CaseClauses| 내 |CaseClause| 리스트 (소스 순서)
        1. _found_ = *false*
        1. 각 _C_ ∈ _A_ 에 대해
          1. _found_ *false* 이면 _found_ = ? CaseClauseIsSelected(_C_, _input_)
          1. _found_ *true* 이면
            1. _R_ = _C_ 평가 Completion
            1. _R_.[[Value]] 가 ~empty~ 아니면 _V_ 갱신
            1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _V_ 반환.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _V_ = *undefined*
        1. 첫 |CaseClauses| 존재하면 _A_ = 그 |CaseClause| 리스트; 아니면 새 빈 List
        1. _found_ = *false*
        1. 각 _C_ ∈ _A_ 에 대해
          1. _found_ *false* 이면 _found_ = ? CaseClauseIsSelected(_C_, _input_)
          1. _found_ *true* 이면
            1. _R_ = _C_ 평가 Completion
            1. _R_.[[Value]] ~empty~ 아니면 _V_ 갱신
            1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _foundInB_ = *false*
        1. 두 번째 |CaseClauses| 존재하면 _B_ = 그 리스트; 아니면 빈 List
        1. _found_ *false* 이면
          1. 각 _C_ ∈ _B_ 에 대해
            1. _foundInB_ *false* 이면 _foundInB_ = ? CaseClauseIsSelected(_C_, _input_)
            1. _foundInB_ *true* 이면
              1. _R_ = _C_ 평가 Completion
              1. _R_.[[Value]] ~empty~ 아니면 _V_ 갱신
              1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _foundInB_ *true* 이면 _V_ 반환
        1. _defaultR_ = |DefaultClause| 평가 Completion
        1. _defaultR_.[[Value]] ~empty~ 아니면 _V_ 갱신
        1. _defaultR_ abrupt 이면 ? UpdateEmpty(_defaultR_, _V_) 반환
        1. (두 번째 |CaseClauses| 전체 재순회)
        1. 각 _C_ ∈ _B_ 에 대해
          1. _R_ = _C_ 평가 Completion
          1. _R_.[[Value]] ~empty~ 아니면 _V_ 갱신
          1. _R_ abrupt 이면 ? UpdateEmpty(_R_, _V_) 반환
        1. _V_ 반환
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseclauseisselected" type="abstract operation" oldids="sec-runtime-semantics-caseselectorevaluation">
      <h1>
        CaseClauseIsSelected (
          _C_: a |CaseClause| Parse Node,
          _input_: an ECMAScript language value,
        ): 정상 완료 시 Boolean 또는 abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_C_ 가 _input_ 과 일치하는지 결정한다.</dd>
      </dl>
      <emu-alg>
        1. 단언: _C_ 는 <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar> 인스턴스.
        1. _exprRef_ = _C_ 의 |Expression| 평가 결과 (?)
        1. _clauseSelector_ = ? GetValue(_exprRef_)
        1. IsStrictlyEqual(_input_, _clauseSelector_) 반환.
      </emu-alg>
      <emu-note>
        <p>이 연산은 _C_ 의 |StatementList| (있다면)를 실행하지 않는다. |CaseBlock| 알고리즘은 반환값을 사용해 어느 |StatementList| 부터 실행할지 결정한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. _exprRef_ = |Expression| 평가 결과 (?)
        1. _switchValue_ = ? GetValue(_exprRef_)
        1. _oldEnv_ = 현재 LexicalEnvironment
        1. _blockEnv_ = NewDeclarativeEnvironment(_oldEnv_)
        1. BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_) 수행
        1. LexicalEnvironment = _blockEnv_
        1. _R_ = CaseBlockEvaluation(|CaseBlock|, _switchValue_) 의 Completion
        1. LexicalEnvironment = _oldEnv_
        1. _R_ 반환
      </emu-alg>
      <emu-note>
        <p>|SwitchStatement| 를 어떻게 빠져나오든 LexicalEnvironment 는 복구된다.</p>
      </emu-note>
      <emu-grammar>CaseClause : `case` Expression `:`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList</emu-grammar>
      <emu-alg>
        1. |StatementList| 평가 결과를 ? 로 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-labelled-statements">
    <h1>Labelled Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LabelledStatement[Yield, Await, Return] :
        LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]

      LabelledItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        FunctionDeclaration[?Yield, ?Await, ~Default]
    </emu-grammar>
    <emu-note>
      <p>|Statement| 는 레이블로 접두될 수 있다. 레이블 문은 레이블된 `break`/`continue` 와 함께 사용된다. ECMAScript 에는 `goto` 가 없다. |Statement| 는 |LabelledStatement| 의 일부가 될 수 있고 이것이 또 다른 |LabelledStatement| 의 일부가 되는 식으로 중첩될 수 있다. 이렇게 도입된 레이블 집합을 개별 문 의미론에서 “current label set” 이라 부른다.</p>
    </emu-note>

    <emu-clause id="sec-labelled-statements-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>
          이 생성물에 매칭되는 소스 텍스트가 있다면 Syntax Error<span normative-optional> — 단, 그 소스가 비엄격 코드이고 호스트가 <emu-xref href="#sec-labelled-function-declarations" title></emu-xref> 를 지원하면 예외.</span>
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-islabelledfunction" type="abstract operation">
      <h1>
        정적 의미론: IsLabelledFunction (
        _stmt_: a |Statement| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. _stmt_ 가 |LabelledStatement| 아니면 *false* 반환.
        1. _item_ = _stmt_ 의 |LabelledItem|
        1. _item_ 이 <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar> 이면 *true* 반환.
        1. _subStmt_ = _item_ 의 |Statement|
        1. IsLabelledFunction(_subStmt_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 이 |LabelledStatement| 의 LabelledEvaluation(« ») 결과를 ? 로 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-labelledevaluation" oldids="sec-statement-semantics-runtime-semantics-labelledevaluation,sec-labelled-statements-runtime-semantics-labelledevaluation" type="sdo">
      <h1>
        런타임 의미론: LabelledEvaluation (
        _labelSet_: a List of Strings,
        ): 정상 완료 시 ECMAScript 값 또는 ~empty~, 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ = Completion(LoopEvaluation(|IterationStatement|, _labelSet_))
        1. _stmtResult_ 가 break completion 이고 _stmtResult_.[[Target]] 이 ~empty~ 이면
          1. _stmtResult_.[[Value]] 가 ~empty~ 이면 _stmtResult_ = NormalCompletion(*undefined*)
          1. 아니면 _stmtResult_ = NormalCompletion(_stmtResult_.[[Value]])
        1. ? _stmtResult_ 반환
      </emu-alg>
      <emu-grammar>BreakableStatement : SwitchStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ = Completion(Evaluation(|SwitchStatement|))
        1. _stmtResult_ 가 break completion 이고 _stmtResult_.[[Target]] 이 ~empty~ 이면
          1. _stmtResult_.[[Value]] ~empty~ 이면 _stmtResult_ = NormalCompletion(*undefined*) 아니면 NormalCompletion(_stmtResult_.[[Value]])
        1. ? _stmtResult_ 반환
      </emu-alg>
      <emu-note>
        <p>|BreakableStatement| 는 레이블 없는 |BreakStatement| 로 빠져나올 수 있는 문이다.</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ = |LabelIdentifier| 의 StringValue
        1. _newLabelSet_ = _labelSet_ ⧺ « _label_ »
        1. _stmtResult_ = Completion(LabelledEvaluation(|LabelledItem|, _newLabelSet_))
        1. _stmtResult_ 가 break completion 이고 _stmtResult_.[[Target]] = _label_ 이면
          1. _stmtResult_ = NormalCompletion(_stmtResult_.[[Value]])
        1. ? _stmtResult_ 반환
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. |FunctionDeclaration| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-grammar>
        Statement :
          BlockStatement
          VariableStatement
          EmptyStatement
          ExpressionStatement
          IfStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          WithStatement
          ThrowStatement
          TryStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. |Statement| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-note>
        <p>|Statement| 의 production 중 LabelledEvaluation 에 특별한 의미론을 갖는 것은 |BreakableStatement| 와 |LabelledStatement| 두 가지뿐이다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-throw-statement">
    <h1>`throw` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ThrowStatement[Yield, Await] :
        `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-throw-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>ThrowStatement : `throw` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ = |Expression| 평가 결과 (?)
        1. _exprValue_ = ? GetValue(_exprRef_)
        1. ThrowCompletion(_exprValue_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-try-statement">
    <h1>`try` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      TryStatement[Yield, Await, Return] :
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

      Catch[Yield, Await, Return] :
        `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
        `catch` Block[?Yield, ?Await, ?Return]

      Finally[Yield, Await, Return] :
        `finally` Block[?Yield, ?Await, ?Return]

      CatchParameter[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`try` 문은 런타임 오류나 `throw` 등 예외 상황이 발생할 수 있는 코드 블록을 감싼다. `catch` 절은 예외 처리 코드를 제공한다. catch 절이 예외를 잡으면 |CatchParameter| 에 그 예외 값이 바인딩된다.</p>
    </emu-note>

    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>|CatchParameter| 의 BoundNames 에 중복 요소가 있으면 Syntax Error.</li>
        <li>|CatchParameter| 의 BoundNames 요소가 |Block| 의 LexicallyDeclaredNames 에도 있으면 Syntax Error.</li>
        <li>|CatchParameter| 의 BoundNames 요소가 |Block| 의 VarDeclaredNames 에도 있으면 Syntax Error<span normative-optional> — 단, |CatchParameter| 가 <emu-grammar>CatchParameter : BindingIdentifier</emu-grammar> 이고 호스트가 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> 를 지원하면 예외.</span></li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-catchclauseevaluation" type="sdo">
      <h1>
        런타임 의미론: CatchClauseEvaluation (
        _thrownValue_: an ECMAScript language value,
        ): 정상 완료 시 ECMAScript 값 또는 ~empty~, 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. _oldEnv_ = 현재 LexicalEnvironment
        1. _catchEnv_ = NewDeclarativeEnvironment(_oldEnv_)
        1. |CatchParameter| 의 BoundNames 각 _argName_ 에 대해
          1. ! _catchEnv_.CreateMutableBinding(_argName_, *false*)
        1. LexicalEnvironment = _catchEnv_
        1. _status_ = Completion(BindingInitialization(|CatchParameter|, _thrownValue_, _catchEnv_))
        1. _status_ abrupt 이면
          1. LexicalEnvironment = _oldEnv_
          1. ? _status_ 반환
        1. _B_ = |Block| 평가 Completion
        1. LexicalEnvironment = _oldEnv_
        1. ? _B_ 반환
      </emu-alg>
      <emu-grammar>Catch : `catch` Block</emu-grammar>
      <emu-alg>
        1. |Block| 평가 결과를 ? 로 반환.
      </emu-alg>
      <emu-note>
        <p>|Block| 을 어떻게 빠져나오든 LexicalEnvironment 는 복구된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _B_ = |Block| 평가 Completion
        1. _B_ 가 throw completion 이면 _C_ = Completion(CatchClauseEvaluation(|Catch|, _B_.[[Value]])); 아니면 _C_ = _B_
        1. ? UpdateEmpty(_C_, *undefined*) 반환
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _B_ = |Block| 평가 Completion
        1. _F_ = |Finally| 평가 Completion
        1. _F_ 가 normal completion 이면 _F_ = _B_
        1. ? UpdateEmpty(_F_, *undefined*) 반환
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _B_ = |Block| 평가 Completion
        1. _B_ 가 throw completion 이면 _C_ = Completion(CatchClauseEvaluation(|Catch|, _B_.[[Value]])); 아니면 _C_ = _B_
        1. _F_ = |Finally| 평가 Completion
        1. _F_ 가 normal completion 이면 _F_ = _C_
        1. ? UpdateEmpty(_F_, *undefined*) 반환
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-debugger-statement">
    <h1>`debugger` 문</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      DebuggerStatement :
        `debugger` `;`
    </emu-grammar>

    <emu-clause id="sec-debugger-statement-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-note>
        <p>|DebuggerStatement| 를 평가하면 구현이 디버거 실행 시 중단점을 걸 수 있게 할 수 있다. 디버거가 없거나 비활성화된 경우 관찰 가능한 효과가 없다.</p>
      </emu-note>
      <emu-grammar>DebuggerStatement : `debugger` `;`</emu-grammar>
      <emu-alg>
        1. 구현 정의 디버깅 기능이 활성화되어 있으면
          1. 구현 정의 디버깅 동작 수행.
          1. 새 구현 정의 Completion Record 반환.
        1. 그렇지 않으면
          1. ~empty~ 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript 언어: 함수와 클래스(Functions and Classes)</h1>
  <emu-note>
    <p>다양한 ECMAScript 언어 요소는 ECMAScript 함수 객체(<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>)를 생성한다. 그러한 함수들의 평가(evaluation)는 그들의 [[Call]] 내부 메서드(<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>) 실행으로 시작한다.</p>
  </emu-note>

  <emu-clause id="sec-parameter-lists">
    <h1>매개변수 목록(Parameter Lists)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UniqueFormalParameters[Yield, Await] :
        FormalParameters[?Yield, ?Await]

      FormalParameters[Yield, Await] :
        [empty]
        FunctionRestParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,`
        FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]

      FormalParameterList[Yield, Await] :
        FormalParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]

      FunctionRestParameter[Yield, Await] :
        BindingRestElement[?Yield, ?Await]

      FormalParameter[Yield, Await] :
        BindingElement[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-parameter-lists-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
      <ul>
        <li>|FormalParameters| 의 BoundNames 에 중복 요소가 있으면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>FormalParameters : FormalParameterList</emu-grammar>
      <ul>
        <li>IsSimpleParameterList(|FormalParameterList|) 가 *false* 이고 BoundNames(|FormalParameterList|) 에 중복 요소가 있으면 Syntax Error 이다.</li>
      </ul>
      <emu-note>
        <p>같은 |BindingIdentifier| 의 다중 출현은 간단한(simple) 매개변수 리스트를 가지며 엄격 모드 코드에서 정의되지 않은 함수에 대해서만 허용된다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsexpression" oldids="sec-destructuring-binding-patterns-static-semantics-containsexpression,sec-function-definitions-static-semantics-containsexpression,sec-arrow-function-definitions-static-semantics-containsexpression,sec-async-arrow-function-definitions-static-semantics-ContainsExpression" type="sdo">
      <h1>정적 의미론: ContainsExpression ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectBindingPattern :
          `{` `}`
          `{` BindingRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. |BindingPropertyList| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. |BindingRestElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. |BindingElementList| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. _has_ 를 |BindingElementList| 의 ContainsExpression 결과로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingRestElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. _has_ 를 |BindingPropertyList| 의 ContainsExpression 결과로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingProperty| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. _has_ 를 |BindingElementList| 의 ContainsExpression 결과로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingElisionElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. |BindingElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. _has_ 를 IsComputedPropertyKey(|PropertyName|) 로 둔다.
        1. _has_ 가 *true* 이면 *true* 반환.
        1. |BindingElement| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. |BindingPattern| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| 의 ContainsExpression 이 *true* 이면 *true* 반환.
        1. |FunctionRestParameter| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| 의 ContainsExpression 이 *true* 이면 *true* 반환.
        1. |FormalParameter| 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ArrowFormalParameters| 로 둔다.
        1. _formals_ 의 ContainsExpression 결과 반환.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-issimpleparameterlist" oldids="sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist,sec-function-definitions-static-semantics-issimpleparameterlist,sec-arrow-function-definitions-static-semantics-issimpleparameterlist,sec-async-arrow-function-definitions-static-semantics-IsSimpleParameterList" type="sdo">
      <h1>정적 의미론: IsSimpleParameterList ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. IsSimpleParameterList(|FormalParameterList|) 가 *false* 이면 *false* 반환.
        1. IsSimpleParameterList(|FormalParameter|) 반환.
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. IsSimpleParameterList(|BindingElement|) 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ArrowFormalParameters| 로 둔다.
        1. IsSimpleParameterList(_formals_) 반환.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. _head_ 를 |CoverCallExpressionAndAsyncArrowHead| 가 커버하는 |AsyncArrowHead| 로 둔다.
        1. IsSimpleParameterList(_head_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasinitializer" oldids="sec-destructuring-binding-patterns-static-semantics-hasinitializer,sec-function-definitions-static-semantics-hasinitializer" type="sdo">
      <h1>정적 의미론: HasInitializer ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. HasInitializer(|FormalParameterList|) 가 *true* 이면 *true* 반환.
        1. HasInitializer(|FormalParameter|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-expectedargumentcount" oldids="sec-function-definitions-static-semantics-expectedargumentcount,sec-arrow-function-definitions-static-semantics-expectedargumentcount,sec-method-definitions-static-semantics-expectedargumentcount,sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount" type="sdo">
      <h1>정적 의미론: ExpectedArgumentCount ( ): 음이 아닌 정수</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FormalParameters :
          [empty]
          FunctionRestParameter
      </emu-grammar>
      <emu-alg>
        1. 0 반환.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. |FormalParameterList| 의 ExpectedArgumentCount 반환.
      </emu-alg>
      <emu-note>
        <p>|FormalParameterList| 의 ExpectedArgumentCount 는 나머지(rest) 매개변수 또는 Initializer 를 가진 첫 번째 |FormalParameter| 의 왼쪽에 있는 |FormalParameters| 의 개수이다. 초기화자가 있는 첫 매개변수 뒤에 초기화자 없는 매개변수가 올 수 있지만 그러한 매개변수들은 *undefined* 를 기본값으로 갖는 선택(optional) 매개변수로 간주된다.</p>
      </emu-note>
      <emu-grammar>FormalParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. HasInitializer(|FormalParameter|) 가 *true* 이면 0 반환.
        1. 1 반환.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. _count_ 를 |FormalParameterList| 의 ExpectedArgumentCount 로 둔다.
        1. HasInitializer(|FormalParameterList|) 가 *true* 이거나 HasInitializer(|FormalParameter|) 가 *true* 이면 _count_ 반환.
        1. _count_ + 1 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 1 반환.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _formals_ 를 |CoverParenthesizedExpressionAndArrowParameterList| 가 커버하는 |ArrowFormalParameters| 로 둔다.
        1. _formals_ 의 ExpectedArgumentCount 반환.
      </emu-alg>
      <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. HasInitializer(|FormalParameter|) 가 *true* 이면 0 반환.
        1. 1 반환.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 1 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-definitions">
    <h1>함수 정의(Function Definitions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      FunctionDeclaration[Yield, Await, Default] :
        `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionExpression :
        `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionBody[Yield, Await] :
        FunctionStatementList[?Yield, ?Await]

      FunctionStatementList[Yield, Await] :
        StatementList[?Yield, ?Await, +Return]?
    </emu-grammar>

    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          IsStrict(|FormalParameters|) 가 *true* 이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 의 조기 오류 규칙을 적용한다.
        </li>
        <li>
          |BindingIdentifier| 가 존재하고 IsStrict(|BindingIdentifier|) 가 *true* 이면 |BindingIdentifier| 의 StringValue 가 *"eval"* 이거나 *"arguments"* 인 경우 Syntax Error 이다.
        </li>
        <li>
          FunctionBodyContainsUseStrict(|FunctionBody|) 가 *true* 이고 IsSimpleParameterList(|FormalParameters|) 가 *false* 이면 Syntax Error 이다.
        </li>
        <li>
          |FormalParameters| 의 BoundNames 요소 중 어떤 것도 |FunctionBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.
        </li>
        <li>
          |FormalParameters| Contains |SuperProperty| 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          |FunctionBody| Contains |SuperProperty| 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          |FormalParameters| Contains |SuperCall| 이 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          |FunctionBody| Contains |SuperCall| 이 *true* 이면 Syntax Error 이다.
        </li>
      </ul>
      <emu-note>
        <p>|FunctionBody| 의 LexicallyDeclaredNames 는 var 혹은 function 선언으로 바인딩된 식별자를 포함하지 않는다.</p>
      </emu-note>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <ul>
        <li>
          |FunctionStatementList| 의 LexicallyDeclaredNames 에 중복 항목이 있으면 Syntax Error 이다.
        </li>
        <li>
          |FunctionStatementList| 의 LexicallyDeclaredNames 요소 중 어떤 것도 |FunctionStatementList| 의 VarDeclaredNames 에 존재하면 Syntax Error 이다.
        </li>
        <li>
          ContainsDuplicateLabels(|FunctionStatementList|, « ») 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          ContainsUndefinedBreakTarget(|FunctionStatementList|, « ») 가 *true* 이면 Syntax Error 이다.
        </li>
        <li>
          ContainsUndefinedContinueTarget(|FunctionStatementList|, « », « ») 가 *true* 이면 Syntax Error 이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-functionbodycontainsusestrict" oldids="sec-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>정적 의미론: FunctionBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. |FunctionBody| 의 Directive Prologue 에 Use Strict Directive 가 포함되어 있으면 *true* 반환; 그렇지 않으면 *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluatefunctionbody" oldids="sec-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateFunctionBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): return completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. ? |FunctionStatementList| 의 Evaluation 수행.
        1. NOTE: 이전 단계가 정상 completion 을 반환했다면 |FunctionStatementList| 끝을 통과하여 평가가 종료된 것이다.
        1. ReturnCompletion(*undefined*) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionobject" oldids="sec-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateOrdinaryFunctionObject (
        _env_: an Environment Record,
        _privateEnv_: a PrivateEnvironment Record 또는 *null*,
        ): ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _sourceText_ 를 |FunctionDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, _name_) 수행.
        1. MakeConstructor(_F_) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _sourceText_ 를 |FunctionDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, *"default"*) 수행.
        1. MakeConstructor(_F_) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-note>
        <p>익명 |FunctionDeclaration| 은 오직 `export default` 선언의 일부로만 나타날 수 있으며 그 함수 코드는 항상 strict mode 코드이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateOrdinaryFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""*.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |FunctionExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. MakeConstructor(_closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 단언: _name_ 은 존재하지 않는다.
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _outerEnv_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _funcEnv_ 를 NewDeclarativeEnvironment(_outerEnv_) 로 둔다.
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) 수행.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |FunctionExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. MakeConstructor(_closure_) 수행.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|FunctionExpression| 의 |BindingIdentifier| 는 그 |FunctionExpression| 의 |FunctionBody| 내부에서 참조되어 재귀 호출을 가능하게 한다. 그러나 |FunctionDeclaration| 과 달리 |FunctionExpression| 의 |BindingIdentifier| 는 |FunctionExpression| 을 둘러싼 외부 스코프에서 참조할 수 없고 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-note>
        <p>대체 의미론은 FunctionDeclarationInstantiation 의 단계 <emu-xref href="#step-functiondeclarationinstantiation-alt-funcdecl-eval"></emu-xref>, GlobalDeclarationInstantiation 의 단계 <emu-xref href="#step-globaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref>, EvalDeclarationInstantiation 의 단계 <emu-xref href="#step-evaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> 에서 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 에 의해 제공된다.</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>
        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |FunctionExpression| 의 InstantiateOrdinaryFunctionExpression 반환.
      </emu-alg>
      <emu-note>
        <p>|FunctionDeclaration| 또는 |FunctionExpression| 으로 정의된 모든 함수에 대해 *"prototype"* 프로퍼티가 자동으로 생성되어 그 함수가 생성자로 사용될 가능성을 허용한다.</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined* 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>화살표 함수 정의(Arrow Function Definitions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ArrowFunction[In, Yield, Await] :
        ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

      ArrowParameters[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      ConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, ~Await]
        `{` FunctionBody[~Yield, ~Await] `}`

      ExpressionBody[In, Await] :
        AssignmentExpression[?In, ~Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>
      생성물 인스턴스<br>
      <emu-grammar>ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      를 처리할 때 |CoverParenthesizedExpressionAndArrowParameterList| 의 해석은 다음 문법을 사용해 정밀화된다:
    </p>
    <emu-grammar type="definition">
      ArrowFormalParameters[Yield, Await] :
        `(` UniqueFormalParameters[?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <ul>
        <li>
          |ArrowParameters| Contains |YieldExpression| 이 *true* 이면 Syntax Error.
        </li>
        <li>
          |ArrowParameters| Contains |AwaitExpression| 이 *true* 이면 Syntax Error.
        </li>
        <li>
          ConciseBodyContainsUseStrict(|ConciseBody|) 가 *true* 이고 IsSimpleParameterList(|ArrowParameters|) 가 *false* 이면 Syntax Error.
        </li>
        <li>
          |ArrowParameters| 의 BoundNames 요소 중 어떤 것도 |ConciseBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <ul>
        <li>
          |CoverParenthesizedExpressionAndArrowParameterList| 는 |ArrowFormalParameters| 를 커버해야 한다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-concisebodycontainsusestrict" oldids="sec-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>정적 의미론: ConciseBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ConciseBody : `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. FunctionBodyContainsUseStrict(|FunctionBody|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateconcisebody" oldids="sec-arrow-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateConciseBody (
        _functionObject_: an ECMAScript function object,
        _argumentsList_: a List of ECMAScript language values,
        ): return completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. |ExpressionBody| 의 Evaluation 결과를 ? 로 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiatearrowfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateArrowFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""*.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |ArrowFunction| 이 매칭한 소스 텍스트로 둔다.
        1. [id="step-arrowfunction-evaluation-functioncreate"] _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|ArrowFunction| 은 `arguments`, `super`, `this`, `new.target` 에 대한 지역 바인딩을 정의하지 않는다. |ArrowFunction| 내부의 이러한 식별자 참조는 렉시컬 외부 환경의 바인딩으로 해석되어야 한다. 일반적으로 이는 바로 둘러싼 함수의 Function Environment 가 된다. 비록 |ArrowFunction| 이 `super` 를 포함할 수 있지만 단계 <emu-xref href="#step-arrowfunction-evaluation-functioncreate"></emu-xref> 에서 생성된 함수 객체는 MakeMethod 를 수행하여 메서드로 만들지 않는다. `super` 를 참조하는 |ArrowFunction| 은 항상 비-|ArrowFunction| 안에 포함되며, `super` 구현에 필요한 상태는 캡처된 _env_ 를 통해 접근 가능하다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가(Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. |ArrowFunction| 의 InstantiateArrowFunctionExpression 반환.
      </emu-alg>
      <emu-grammar>ExpressionBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |AssignmentExpression| 평가 결과 (?) 로 둔다.
        1. _exprValue_ 를 ? GetValue(_exprRef_) 로 둔다.
        1. ReturnCompletion(_exprValue_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>메서드 정의(Method Definitions)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MethodDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        GeneratorMethod[?Yield, ?Await]
        AsyncMethod[?Yield, ?Await]
        AsyncGeneratorMethod[?Yield, ?Await]
        `get` ClassElementName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
        `set` ClassElementName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

      PropertySetParameterList :
        FormalParameter[~Yield, ~Await]
    </emu-grammar>

    <emu-clause id="sec-method-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류(Static Semantics: Early Errors)</h1>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          FunctionBodyContainsUseStrict(|FunctionBody|) 가 *true* 이고 IsSimpleParameterList(|UniqueFormalParameters|) 가 *false* 이면 Syntax Error.
        </li>
        <li>
          |UniqueFormalParameters| 의 BoundNames 요소 중 어떤 것도 |FunctionBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error.
        </li>
      </ul>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          |PropertySetParameterList| 의 BoundNames 에 중복 요소가 있으면 Syntax Error.
        </li>
        <li>
          FunctionBodyContainsUseStrict(|FunctionBody|) 가 *true* 이고 IsSimpleParameterList(|PropertySetParameterList|) 가 *false* 이면 Syntax Error.
        </li>
        <li>
          |PropertySetParameterList| 의 BoundNames 요소 중 어떤 것도 |FunctionBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasdirectsuper" oldids="sec-method-definitions-static-semantics-hasdirectsuper,sec-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-function-definitions-static-semantics-HasDirectSuper" type="sdo">
      <h1>정적 의미론: HasDirectSuper ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |FunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |FunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. |PropertySetParameterList| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |FunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |GeneratorBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |AsyncGeneratorBody| Contains |SuperCall| 반환.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |UniqueFormalParameters| Contains |SuperCall| 이 *true* 이면 *true* 반환.
        1. |AsyncFunctionBody| Contains |SuperCall| 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-specialmethod" type="sdo">
      <h1>정적 의미론: SpecialMethod ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          GeneratorMethod
          AsyncMethod
          AsyncGeneratorMethod
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-definemethod" type="sdo">
      <h1>
        런타임 의미론: DefineMethod (
        _object_: an Object,
        optional _functionPrototype_: an Object,
        ): 정상 completion (필드 [[Key]](property key), [[Closure]](ECMAScript function object)) 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _functionPrototype_ 이 존재하면
          1. _prototype_ = _functionPrototype_
        1. 그렇지 않으면
          1. _prototype_ = %Function.prototype%
        1. _sourceText_ 를 |MethodDefinition| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. Record { [[Key]]: _propKey_, [[Closure]]: _closure_ } 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-methoddefinitionevaluation" oldids="sec-method-definitions-runtime-semantics-propertydefinitionevaluation,sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation,sec-asyncgenerator-definitions-propertydefinitionevaluation,sec-async-function-definitions-PropertyDefinitionEvaluation" type="sdo">
      <h1>
        런타임 의미론: MethodDefinitionEvaluation (
        _object_: an Object,
        _enumerable_: a Boolean,
        ): 정상 completion (PrivateElement 또는 ~unused~) 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _methodDef_ 를 |MethodDefinition| 의 DefineMethod(_object_) 결과 (?) 로 둔다.
        1. SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]) 수행.
        1. ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_) 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |MethodDefinition| 이 매칭한 소스 텍스트로 둔다.
        1. _formalParameterList_ 를 <emu-grammar>FormalParameters : [empty]</emu-grammar> 생성물 인스턴스로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_, *"get"*) 수행.
        1. _propKey_ 가 Private Name 이면
          1. PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* } 반환.
        1. 그렇지 않으면
          1. _desc_ = PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
          1. ? DefinePropertyOrThrow(_object_, _propKey_, _desc_) 수행.
          1. ~unused~ 반환.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |MethodDefinition| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_, *"set"*) 수행.
        1. _propKey_ 가 Private Name 이면
          1. PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ } 반환.
        1. 그렇지 않으면
          1. _desc_ = PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
          1. ? DefinePropertyOrThrow(_object_, _propKey_, _desc_) 수행.
          1. ~unused~ 반환.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |GeneratorMethod| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) 반환.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |AsyncGeneratorMethod| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) 반환.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _propKey_ 를 |ClassElementName| 평가 결과 (?) 로 둔다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |AsyncMethod| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. MakeMethod(_closure_, _object_) 수행.
        1. SetFunctionName(_closure_, _propKey_) 수행.
        1. ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_) 반환.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>제너레이터 함수 정의 (Generator Function Definitions)</h1>
    <h2>구문 (Syntax)</h2>
    <emu-grammar type="definition">
      GeneratorDeclaration[Yield, Await, Default] :
        `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
        [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorExpression :
        `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorMethod[Yield, Await] :
        `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorBody :
        FunctionBody[+Yield, ~Await]

      YieldExpression[In, Await] :
        `yield`
        `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`yield` 바로 뒤의 문맥은 |InputElementRegExpOrTemplateTail| 어휘 목표(lexical goal)를 사용해야 한다.</p>
    </emu-note>
    <emu-note>
      <p>|YieldExpression| 은 제너레이터 함수의 |FormalParameters| 안에서 사용할 수 없다. 그 이유는 |FormalParameters| 에 속하는 모든 표현식이, 생성된 Generator 가 재개(resumable) 가능한 상태가 되기 이전에 평가되기 때문이다.</p>
    </emu-note>
    <emu-note>
      <p>Generator 와 관련된 추상 연산은 <emu-xref href="#sec-generator-abstract-operations"></emu-xref> 에 정의되어 있다.</p>
    </emu-note>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류 (Static Semantics: Early Errors)</h1>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <ul>
        <li>|GeneratorMethod| 의 HasDirectSuper 가 *true* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|GeneratorBody|) 가 *true* 이고 IsSimpleParameterList(|UniqueFormalParameters|) 가 *false* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 의 BoundNames 요소 중 하나라도 |GeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>IsStrict(|FormalParameters|) 가 *true* 이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 에 대한 조기 오류 규칙을 적용한다.</li>
        <li>|BindingIdentifier| 가 존재하고 IsStrict(|BindingIdentifier|) 가 *true* 이면 그 StringValue 가 *"eval"* 또는 *"arguments"* 인 경우 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|GeneratorBody|) 가 *true* 이고 IsSimpleParameterList(|FormalParameters|) 가 *false* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 의 BoundNames 요소 중 하나라도 |GeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|GeneratorBody| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|GeneratorBody| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateGeneratorBody (
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값들의 List,
        ): throw completion 또는 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. _G_ 를 ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorPrototype%"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ») 로 둔다.
        1. _G_.[[GeneratorBrand]] 를 ~empty~ 로 설정한다.
        1. _G_.[[GeneratorState]] 를 ~suspended-start~ 로 설정한다.
        1. GeneratorStart(_G_, |FunctionBody|) 수행.
        1. ReturnCompletion(_G_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionobject" oldids="sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateGeneratorFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _sourceText_ 를 |GeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _sourceText_ 를 |GeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, *"default"*) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-note>
        <p>익명 |GeneratorDeclaration| 은 `export default` 선언의 일부로만 등장할 수 있으며 그 함수 코드는 항상 strict mode 코드이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateGeneratorFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""* 로 설정한다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |GeneratorExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 단언: _name_ 은 존재하지 않는다.
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 설정한다.
        1. _outerEnv_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _funcEnv_ 를 NewDeclarativeEnvironment(_outerEnv_) 로 둔다.
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) 수행.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |GeneratorExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%GeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|GeneratorExpression| 의 |BindingIdentifier| 는 그 |FunctionBody| 내부에서 참조되어 제너레이터 코드가 재귀 호출될 수 있게 한다. 그러나 |GeneratorDeclaration| 과 달리, 해당 |BindingIdentifier| 는 둘러싼 스코프에서 참조할 수 없고 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. |GeneratorExpression| 의 InstantiateGeneratorFunctionExpression 결과를 반환한다.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield`</emu-grammar>
      <emu-alg>
        1. ? Yield(*undefined*) 를 반환한다.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _exprRef_ 를 |AssignmentExpression| 평가 결과 (?) 로 둔다.
        1. _value_ 를 ? GetValue(_exprRef_) 로 둔다.
        1. ? Yield(_value_) 반환.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` `*` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. _generatorKind_ 를 GetGeneratorKind() 로 둔다.
        1. 단언: _generatorKind_ 는 ~sync~ 또는 ~async~ 이어야 한다.
        1. _exprRef_ 를 |AssignmentExpression| 평가 결과 (?) 로 둔다.
        1. _value_ 를 ? GetValue(_exprRef_) 로 둔다.
        1. _iteratorRecord_ 를 ? GetIterator(_value_, _generatorKind_) 로 둔다.
        1. _iterator_ 를 _iteratorRecord_.[[Iterator]] 로 둔다.
        1. _received_ 를 NormalCompletion(*undefined*) 로 둔다.
        1. 반복,
          1. _received_ 가 normal completion 이라면
            1. _innerResult_ 를 ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] ») 로 둔다.
            1. _generatorKind_ 가 ~async~ 이면 _innerResult_ 를 ? Await(_innerResult_) 로 둔다.
            1. _innerResult_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _done_ 을 ? IteratorComplete(_innerResult_) 로 둔다.
            1. _done_ 이 *true* 이면
              1. ? IteratorValue(_innerResult_) 반환.
            1. _generatorKind_ 가 ~async~ 이면 _received_ = Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).
            1. 아니면 _received_ = Completion(GeneratorYield(_innerResult_)).
          1. 아니고 _received_ 가 throw completion 이라면
            1. _throw_ 를 ? GetMethod(_iterator_, *"throw"*) 로 둔다.
            1. _throw_ 가 *undefined* 가 아니면
              1. _innerResult_ 를 ? Call(_throw_, _iterator_, « _received_.[[Value]] ») 로 둔다.
              1. _generatorKind_ 가 ~async~ 이면 _innerResult_ 를 ? Await(_innerResult_) 로 둔다.
              1. NOTE: 내부 iterator `throw` 메서드에서 발생한 예외는 전파되고, 정상 completion 은 내부 `next` 와 유사하게 처리된다.
              1. _innerResult_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
              1. _done_ = ? IteratorComplete(_innerResult_).
              1. _done_ 이 *true* 이면
                1. ? IteratorValue(_innerResult_) 반환.
              1. _generatorKind_ 가 ~async~ 이면 _received_ = Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).
              1. 아니면 _received_ = Completion(GeneratorYield(_innerResult_)).
            1. 그렇지 않으면
              1. NOTE: _iterator_ 에 `throw` 메서드가 없으면 본 throw 로 `yield*` 루프가 종료되며, 먼저 정리 기회를 준다.
              1. _closeCompletion_ = NormalCompletion(~empty~) 로 둔다.
              1. _generatorKind_ 가 ~async~ 이면 ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_) 수행.
              1. 아니면 ? IteratorClose(_iteratorRecord_, _closeCompletion_) 수행.
              1. NOTE: 다음 단계에서 *TypeError* 는 `yield*` 프로토콜 위반(throw 메서드 부재)을 나타낸다.
              1. *TypeError* 예외를 던진다.
          1. 그 밖의 경우
            1. 단언: _received_ 는 return completion 이다.
            1. _return_ 을 ? GetMethod(_iterator_, *"return"*) 로 둔다.
            1. _return_ 이 *undefined* 이면
              1. _value_ = _received_.[[Value]].
              1. _generatorKind_ 가 ~async~ 이면 _value_ = ? Await(_value_).
              1. ReturnCompletion(_value_) 반환.
            1. _innerReturnResult_ = ? Call(_return_, _iterator_, « _received_.[[Value]] »).
            1. _generatorKind_ 가 ~async~ 이면 _innerReturnResult_ = ? Await(_innerReturnResult_).
            1. _innerReturnResult_ 가 Object 가 아니면 *TypeError* 예외를 던진다.
            1. _done_ = ? IteratorComplete(_innerReturnResult_).
            1. _done_ 이 *true* 이면
              1. _value_ = ? IteratorValue(_innerReturnResult_).
              1. ReturnCompletion(_value_) 반환.
            1. _generatorKind_ 가 ~async~ 이면 _received_ = Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_))).
            1. 아니면 _received_ = Completion(GeneratorYield(_innerReturnResult_)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>비동기 제너레이터 함수 정의 (Async Generator Function Definitions)</h1>
    <h2>구문 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncGeneratorDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
        [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorExpression :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorMethod[Yield, Await] :
        `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorBody :
        FunctionBody[+Yield, +Await]
    </emu-grammar>
    <emu-note>
      <p>|YieldExpression| 과 |AwaitExpression| 은 async generator 함수의 |FormalParameters| 내부에서 사용할 수 없다. 이는 해당 표현식들이 AsyncGenerator 가 재개 가능한 상태가 되기 전에 평가되기 때문이다.</p>
    </emu-note>
    <emu-note>
      <p>AsyncGenerator 관련 추상 연산은 <emu-xref href="#sec-asyncgenerator-abstract-operations"></emu-xref> 에 정의되어 있다.</p>
    </emu-note>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류 (Static Semantics: Early Errors)</h1>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <ul>
        <li>|AsyncGeneratorMethod| 의 HasDirectSuper 가 *true* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 가 |AwaitExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|AsyncGeneratorBody|) 가 *true* 이고 IsSimpleParameterList(|UniqueFormalParameters|) 가 *false* 이면 Syntax Error 이다.</li>
        <li>|UniqueFormalParameters| 의 BoundNames 요소 중 하나라도 |AsyncGeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>IsStrict(|FormalParameters|) 가 *true* 이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 조기 오류 규칙을 적용한다.</li>
        <li>|BindingIdentifier| 존재 &amp; IsStrict(|BindingIdentifier|) *true* 이면 StringValue 가 *"eval"* 또는 *"arguments"* 인 경우 Syntax Error 이다.</li>
        <li>FunctionBodyContainsUseStrict(|AsyncGeneratorBody|) *true* 이고 IsSimpleParameterList(|FormalParameters|) *false* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 의 BoundNames 요소 중 하나라도 |AsyncGeneratorBody| 의 LexicallyDeclaredNames 에 존재하면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |YieldExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |AwaitExpression| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|AsyncGeneratorBody| 가 |SuperProperty| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|FormalParameters| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|AsyncGeneratorBody| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        런타임 의미론: EvaluateAsyncGeneratorBody (
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값들의 List,
        ): throw completion 또는 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_) 수행.
        1. _generator_ 를 ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorPrototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ») 로 둔다.
        1. _generator_.[[GeneratorBrand]] 를 ~empty~ 로 설정한다.
        1. _generator_.[[AsyncGeneratorState]] 를 ~suspended-start~ 로 설정한다.
        1. AsyncGeneratorStart(_generator_, |FunctionBody|) 수행.
        1. ReturnCompletion(_generator_) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionobject" oldids="sec-asyncgenerator-definitions-instantiatefunctionobject" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncGeneratorFunctionObject (
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 을 |BindingIdentifier| 의 StringValue 로 둔다.
        1. _sourceText_ 를 |AsyncGeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _sourceText_ 를 |AsyncGeneratorDeclaration| 이 매칭한 소스 텍스트로 둔다.
        1. _F_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_F_, *"default"*) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _F_ 반환.
      </emu-alg>
      <emu-note>
        <p>익명 |AsyncGeneratorDeclaration| 은 `export default` 선언에서만 나타날 수 있다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncGeneratorFunctionExpression (
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_ 이 존재하지 않으면 _name_ = *""* 로 설정한다.
        1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 |AsyncGeneratorExpression| 이 매칭한 소스 텍스트로 둔다.
        1. _closure_ 를 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ 을 OrdinaryObjectCreate(%AsyncGeneratorPrototype%) 로 둔다.
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 단언: _name_ 은 존재하지 않는다.
        1. _name_ = |BindingIdentifier| 의 StringValue.
        1. _outerEnv_ = 실행 중 실행 컨텍스트의 LexicalEnvironment.
        1. _funcEnv_ = NewDeclarativeEnvironment(_outerEnv_).
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*) 수행.
        1. _privateEnv_ = 실행 중 실행 컨텍스트의 PrivateEnvironment.
        1. _sourceText_ = |AsyncGeneratorExpression| 이 매칭한 소스 텍스트.
        1. _closure_ = OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. SetFunctionName(_closure_, _name_) 수행.
        1. _prototype_ = OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }) 수행.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_) 수행.
        1. _closure_ 반환.
      </emu-alg>
      <emu-note>
        <p>|AsyncGeneratorExpression| 의 |BindingIdentifier| 는 해당 |AsyncGeneratorBody| 내부에서 재귀 호출을 위해 참조될 수 있으나 |AsyncGeneratorDeclaration| 과 달리 둘러싼 스코프에는 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluation" type="sdo">
      <h1>런타임 의미론: 평가 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. |AsyncGeneratorExpression| 의 InstantiateAsyncGeneratorFunctionExpression 결과를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>클래스 정의 (Class Definitions)</h1>
    <h2>구문 (Syntax)</h2>
    <emu-grammar type="definition">
      ClassDeclaration[Yield, Await, Default] :
        `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ClassTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

      ClassHeritage[Yield, Await] :
        `extends` LeftHandSideExpression[?Yield, ?Await]

      ClassBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]

      ClassElementList[Yield, Await] :
        ClassElement[?Yield, ?Await]
        ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        FieldDefinition[?Yield, ?Await] `;`
        `static` FieldDefinition[?Yield, ?Await] `;`
        ClassStaticBlock
        `;`

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateIdentifier

      ClassStaticBlock :
        `static` `{` ClassStaticBlockBody `}`

      ClassStaticBlockBody :
        ClassStaticBlockStatementList

      ClassStaticBlockStatementList :
        StatementList[~Yield, +Await, ~Return]?
    </emu-grammar>
    <emu-note>
      <p>클래스 정의는 항상 strict mode 코드이다.</p>
    </emu-note>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류 (Static Semantics: Early Errors)</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>|ClassHeritage| 가 존재하지 않고 아래 알고리즘이 *true* 를 반환하면 Syntax Error 이다:</p>
          <emu-alg>
            1. _constructor_ 를 |ClassBody| 의 ConstructorMethod 로 둔다.
            1. _constructor_ 가 ~empty~ 이면 *false* 반환.
            1. HasDirectSuper(_constructor_) 반환.
          </emu-alg>
        </li>
      </ul>
      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <ul>
        <li>|ClassElementList| 의 PrototypePropertyNameList 에 *"constructor"* 가 두 번 이상 나타나면 Syntax Error 이다.</li>
        <li>|ClassElementList| 의 PrivateBoundIdentifiers 에 중복 항목이 있으면 (단, 동일 이름이 getter 1회와 setter 1회만, 그리고 둘 다 static 이거나 둘 다 non-static 인 경우를 제외) Syntax Error 이다.</li>
      </ul>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <ul>
        <li>|MethodDefinition| 의 PropName 이 *"constructor"* 가 아니면서 HasDirectSuper(|MethodDefinition|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>|MethodDefinition| 의 PropName 이 *"constructor"* 이고 SpecialMethod(|MethodDefinition|) 가 *true* 이면 Syntax Error 이다.</li>
      </ul>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <ul>
        <li>HasDirectSuper(|MethodDefinition|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>PropName(|MethodDefinition|) 이 *"prototype"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <ul>
        <li>PropName(|FieldDefinition|) 이 *"constructor"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <ul>
        <li>PropName(|FieldDefinition|) 이 *"prototype"* 또는 *"constructor"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>
        FieldDefinition :
          ClassElementName Initializer?
      </emu-grammar>
      <ul>
        <li>|Initializer| 가 존재하고 ContainsArguments(|Initializer|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>|Initializer| 가 존재하고 |Initializer| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <ul>
        <li>|PrivateIdentifier| 의 StringValue 가 *"#constructor"* 이면 Syntax Error 이다.</li>
      </ul>

      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <ul>
        <li>|ClassStaticBlockStatementList| 의 LexicallyDeclaredNames 에 중복 항목이 있으면 Syntax Error 이다.</li>
        <li>LexicallyDeclaredNames 요소 중 하나라도 VarDeclaredNames 에 존재하면 Syntax Error 이다.</li>
        <li>ContainsDuplicateLabels(|ClassStaticBlockStatementList|, « ») 가 *true* 이면 Syntax Error 이다.</li>
        <li>ContainsUndefinedBreakTarget(|ClassStaticBlockStatementList|, « ») 가 *true* 이면 Syntax Error 이다.</li>
        <li>ContainsUndefinedContinueTarget(|ClassStaticBlockStatementList|, « », « ») 가 *true* 이면 Syntax Error 이다.</li>
        <li>ContainsArguments(|ClassStaticBlockStatementList|) 가 *true* 이면 Syntax Error 이다.</li>
        <li>|ClassStaticBlockStatementList| 가 |SuperCall| 을 Contains 하여 *true* 이면 Syntax Error 이다.</li>
        <li>|ClassStaticBlockStatementList| 가 `await` 를 Contains 하여 *true* 이면 Syntax Error 이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementkind" type="sdo">
      <h1>정적 의미론: ClassElementKind ( ): ~constructor-method~, ~non-constructor-method~, 또는 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. |MethodDefinition| 의 PropName 이 *"constructor"* 이면 ~constructor-method~ 반환.
        1. ~non-constructor-method~ 반환.
      </emu-alg>
      <emu-grammar>
        ClassElement :
          `static` MethodDefinition
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. ~non-constructor-method~ 반환.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. ~non-constructor-method~ 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. ~empty~ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-constructormethod" type="sdo">
      <h1>정적 의미론: ConstructorMethod ( ): |ClassElement| Parse Node 또는 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. |ClassElement| 의 ClassElementKind 가 ~constructor-method~ 이면 |ClassElement| 반환.
        1. ~empty~ 반환.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _head_ 를 |ClassElementList| 의 ConstructorMethod 로 둔다.
        1. _head_ ≠ ~empty~ 이면 _head_ 반환.
        1. |ClassElement| 의 ClassElementKind 가 ~constructor-method~ 이면 |ClassElement| 반환.
        1. ~empty~ 반환.
      </emu-alg>
      <emu-note>
        <p>조기 오류 규칙은 이름이 *"constructor"* 인 메서드 정의가 하나뿐이며 accessor 나 generator 정의가 아님을 보장한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstatic" type="sdo">
      <h1>정적 의미론: IsStatic ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. *true* 반환.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructorelements" oldids="sec-static-semantics-nonconstructormethoddefinitions" type="sdo">
      <h1>정적 의미론: NonConstructorElements ( ): |ClassElement| Parse Node 들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. |ClassElement| 의 ClassElementKind 가 ~non-constructor-method~ 이면
          1. « |ClassElement| » 반환.
        1. 새 빈 List 반환.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _list_ 를 |ClassElementList| 의 NonConstructorElements 로 둔다.
        1. |ClassElement| 의 ClassElementKind 가 ~non-constructor-method~ 이면
          1. _list_ 끝에 |ClassElement| 추가.
        1. _list_ 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-prototypepropertynamelist" type="sdo">
      <h1>정적 의미론: PrototypePropertyNameList ( ): property key 들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. _propName_ 을 |ClassElement| 의 PropName 으로 둔다.
        1. _propName_ 이 ~empty~ 이면 새 빈 List 반환.
        1. IsStatic(|ClassElement|) 가 *true* 이면 새 빈 List 반환.
        1. « _propName_ » 반환.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. _list_ 를 |ClassElementList| 의 PrototypePropertyNameList 로 둔다.
        1. _propName_ 을 |ClassElement| 의 PropName 으로 둔다.
        1. _propName_ 이 ~empty~ 이면 _list_ 반환.
        1. IsStatic(|ClassElement|) 가 *true* 이면 _list_ 반환.
        1. _list_ 와 « _propName_ » 의 리스트 연결을 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-allprivateidentifiersvalid" type="sdo">
      <h1>
        정적 의미론: AllPrivateIdentifiersValid (
        _names_: String 들의 List,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>아래에 명시되지 않은 모든 생성물 대안은 다음 기본 정의를 암묵적으로 갖는다:</p>
      <emu-alg>
        1. 이 Parse Node 의 각 자식 노드 _child_ 에 대해
          1. _child_ 가 비단말(nonterminal) 인스턴스이면
            1. AllPrivateIdentifiersValid(_child_, _names_) 가 *false* 이면 *false* 반환.
        1. *true* 반환.
      </emu-alg>

      <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|MemberExpression|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|CallExpression|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면 *true* 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|OptionalChain|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <emu-alg>
        1. _newNames_ 를 _names_ 와 |ClassBody| 의 PrivateBoundIdentifiers 의 리스트 연결로 둔다.
        1. AllPrivateIdentifiersValid(|ClassElementList|, _newNames_) 반환.
      </emu-alg>

      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. _names_ 가 |PrivateIdentifier| 의 StringValue 를 포함하면
          1. AllPrivateIdentifiersValid(|ShiftExpression|, _names_) 반환.
        1. *false* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-privateboundidentifiers" type="sdo">
      <h1>정적 의미론: PrivateBoundIdentifiers ( ): String 들의 List</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. PrivateBoundIdentifiers(|ClassElementName|) 반환.
      </emu-alg>

      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. |PrivateIdentifier| 의 StringValue 하나만을 요소로 갖는 List 반환.
      </emu-alg>

      <emu-grammar>
        ClassElementName :
          PropertyName

        ClassElement :
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. 새 빈 List 반환.
      </emu-alg>

      <emu-grammar>
        ClassElementList : ClassElementList ClassElement
      </emu-grammar>
      <emu-alg>
        1. _names1_ = PrivateBoundIdentifiers(|ClassElementList|).
        1. _names2_ = PrivateBoundIdentifiers(|ClassElement|).
        1. 리스트 연결(_names1_, _names2_) 반환.
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. PrivateBoundIdentifiers(|ClassElementName|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsarguments" type="sdo">
      <h1>정적 의미론: ContainsArguments ( ): Boolean</h1>
      <dl class="header">
      </dl>

      <p>아래에 나열되지 않은 모든 생성물 대안은 다음 기본 정의를 갖는다:</p>
      <emu-alg>
        1. 이 Parse Node 의 각 자식 _child_ 에 대해
          1. _child_ 가 비단말 인스턴스이면
            1. ContainsArguments(_child_) 가 *true* 이면 *true* 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>
        IdentifierReference : Identifier
      </emu-grammar>
      <emu-alg>
        1. |Identifier| 의 StringValue 가 *"arguments"* 이면 *true* 반환.
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. *false* 반환.
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. ContainsArguments(|ClassElementName|) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classfielddefinitionevaluation" type="sdo">
      <h1>
        런타임 의미론: ClassFieldDefinitionEvaluation (
        _homeObject_: Object,
        ): ClassFieldDefinition Record 를 담은 정상 completion 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. _name_ 을 ? Evaluation(|ClassElementName|) 로 둔다.
        1. |Initializer| 가 존재하면
          1. _formalParameterList_ 를 <emu-grammar>FormalParameters : [empty]</emu-grammar> 의 인스턴스로 둔다.
          1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
          1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
          1. _sourceText_ 를 빈 Unicode 코드 포인트 시퀀스로 둔다.
          1. _initializer_ 를 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_) 로 둔다.
          1. MakeMethod(_initializer_, _homeObject_) 수행.
          1. _initializer_.[[ClassFieldInitializerName]] = _name_ 으로 설정.
        1. 그렇지 않으면
          1. _initializer_ = ~empty~.
        1. ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ } 반환.
      </emu-alg>
      <emu-note>
        _initializer_ 를 위해 생성된 함수는 ECMAScript 코드에서 직접 접근할 수 없다.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classstaticblockdefinitionevaluation" type="sdo">
      <h1>
        런타임 의미론: ClassStaticBlockDefinitionEvaluation (
        _homeObject_: Object,
        ): ClassStaticBlockDefinition Record
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. _lex_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
        1. _privateEnv_ 를 실행 중 실행 컨텍스트의 PrivateEnvironment 로 둔다.
        1. _sourceText_ 를 빈 Unicode 코드 포인트 시퀀스로 둔다.
        1. _formalParameters_ 를 <emu-grammar>FormalParameters : [empty]</emu-grammar> 인스턴스로 둔다.
        1. [id="step-synthetic-class-static-block-fn"] _bodyFunction_ 을 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_) 로 둔다.
        1. MakeMethod(_bodyFunction_, _homeObject_) 수행.
        1. ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ } 반환.
      </emu-alg>
      <emu-note>_bodyFunction_ 함수는 ECMAScript 코드에서 직접 접근할 수 없다.</emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        런타임 의미론: EvaluateClassStaticBlockBody (
        _functionObject_: ECMAScript 함수 객체,
        ): return completion 또는 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. 단언: _functionObject_ 는 ClassStaticBlockDefinitionEvaluation 단계 <emu-xref href="#step-synthetic-class-static-block-fn"></emu-xref> 에서 생성된 합성(synthetic) 함수이다.
        1. ! FunctionDeclarationInstantiation(_functionObject_, « ») 수행.
        1. ? Evaluation(|ClassStaticBlockStatementList|) 수행.
        1. ReturnCompletion(*undefined*) 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementevaluation" type="sdo">
      <h1>
        런타임 의미론: ClassElementEvaluation(
        _object_: 객체,
        ): 정상 완료(ClassFieldDefinition 레코드, ClassStaticBlockDefinition 레코드, PrivateElement, ~unused~ 중 하나 포함) 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ClassElement :
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. |FieldDefinition|에 대해 _object_를 인수로 하여 ClassFieldDefinitionEvaluation을 ? 반환한다.
      </emu-alg>

      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. |MethodDefinition|에 대해 _object_와 *false*를 인수로 하여 MethodDefinitionEvaluation을 ? 반환한다.
      </emu-alg>

      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. |ClassStaticBlock|에 대해 _object_를 인수로 하여 ClassStaticBlockDefinitionEvaluation을 반환한다.
      </emu-alg>

      <emu-grammar>
        ClassElement : `;`
      </emu-grammar>
      <emu-alg>
        1. ~unused~을 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        런타임 의미론: ClassDefinitionEvaluation(
        _classBinding_: String 또는 *undefined*,
        _className_: 속성 키 또는 Private Name,
        _sourceText_: ECMAScript 소스 텍스트,
        ): 함수 객체를 포함하는 정상 완료 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>명세를 쉽게 하기 위해 private 메서드와 접근자는 클래스 인스턴스의 [[PrivateElements]] 슬롯에 private 필드와 함께 포함된다. 그러나 어떤 객체든 특정 클래스가 정의한 private 메서드와 접근자를 모두 가지거나 전혀 가지지 않는다. 이 기능은 구현에서 각 메서드나 접근자를 개별적으로 추적하지 않는 전략을 선택할 수 있도록 설계되었다.</p>
        <p>예를 들어, 구현은 인스턴스 private 메서드를 해당 Private Name과 직접 연결하고, 각 객체에 대해 어떤 클래스 생성자가 그 객체를 `this` 값으로 실행했는지 추적할 수 있다. 객체에서 인스턴스 private 메서드를 조회하는 것은 해당 클래스 생성자가 객체 초기화에 사용되었는지 확인한 다음, Private Name에 연결된 메서드를 반환하는 것으로 구성된다.</p>
        <p>이는 private 필드와는 다르다. 필드 초기화자가 클래스 인스턴스화 중에 throw될 수 있으므로, 개별 객체는 해당 클래스의 일부 private 필드만을 가질 수 있으며, private 필드는 일반적으로 개별적으로 추적되어야 한다.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. _env_를 실행 중인 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _classEnv_를 NewDeclarativeEnvironment(_env_)로 둔다.
        1. _classBinding_이 *undefined*가 아니면,
          1. ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*)를 수행한다.
        1. _outerPrivateEnvironment_를 실행 중인 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _classPrivateEnvironment_를 NewPrivateEnvironment(_outerPrivateEnvironment_)로 둔다.
        1. |ClassBody|가 존재하면,
          1. |ClassBody|의 PrivateBoundIdentifiers의 각 String _dn_에 대해 다음을 수행한다:
            1. _classPrivateEnvironment_.[[Names]]가 [[Description]]이 _dn_인 Private Name _pn_을 포함하면,
              1. 단언: 이는 getter/setter 쌍에 대해서만 가능하다.
            1. 그렇지 않으면,
              1. _name_을 [[Description]]이 _dn_인 새 Private Name으로 둔다.
              1. _name_을 _classPrivateEnvironment_.[[Names]]에 추가한다.
        1. |ClassHeritage|가 존재하지 않으면,
          1. _protoParent_를 %Object.prototype%로 둔다.
          1. _constructorParent_를 %Function.prototype%로 둔다.
        1. 그렇지 않으면,
          1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _classEnv_로 설정한다.
          1. 참고: |ClassHeritage|를 평가할 때 실행 중인 실행 컨텍스트의 PrivateEnvironment는 _outerPrivateEnvironment_이다.
          1. _superclassRef_를 Completion(Evaluation of |ClassHeritage|)로 둔다.
          1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _env_로 설정한다.
          1. _superclass_를 ? GetValue(? _superclassRef_)로 둔다.
          1. _superclass_가 *null*이면,
            1. _protoParent_를 *null*로 둔다.
            1. _constructorParent_를 %Function.prototype%로 둔다.
          1. 그렇지 않고 IsConstructor(_superclass_)가 *false*이면,
            1. *TypeError* 예외를 던진다.
          1. 그렇지 않으면,
            1. _protoParent_를 ? Get(_superclass_, *"prototype"*)로 둔다.
            1. _protoParent_가 Object가 아니고 *null*도 아니면, *TypeError* 예외를 던진다.
            1. _constructorParent_를 _superclass_로 둔다.
        1. _proto_를 OrdinaryObjectCreate(_protoParent_)로 둔다.
        1. |ClassBody|가 존재하지 않으면, _constructor_를 ~empty~로 둔다.
        1. 그렇지 않으면, _constructor_를 |ClassBody|의 ConstructorMethod로 둔다.
        1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _classEnv_로 설정한다.
        1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _classPrivateEnvironment_로 설정한다.
        1. _constructor_가 ~empty~이면,
          1. _defaultConstructor_를 매개변수가 없고 아무것도 캡처하지 않는 새 Abstract Closure로 두고, 호출될 때 다음 단계를 수행하도록 한다:
            1. _args_를 [[Call]] 또는 [[Construct]]에 의해 이 함수에 전달된 인수의 List로 둔다.
            1. NewTarget이 *undefined*이면, *TypeError* 예외를 던진다.
            1. _F_를 활성 함수 객체로 둔다.
            1. _F_.[[ConstructorKind]]가 ~derived~이면,
              1. 참고: 이 분기는 `constructor(...args) { super(...args); }`와 유사하게 동작한다. 가장 주목할 만한 차이점은 앞서 언급한 ECMAScript 소스 텍스트가 `%Array.prototype%`의 %Symbol.iterator% 메서드를 관찰 가능하게 호출하는 반면, 이 함수는 그렇지 않는다는 것이다.
              1. _func_를 ! _F_.[[GetPrototypeOf]]()로 둔다.
              1. IsConstructor(_func_)가 *false*이면, *TypeError* 예외를 던진다.
              1. _result_를 ? Construct(_func_, _args_, NewTarget)로 둔다.
            1. 그렇지 않으면,
              1. 참고: 이 분기는 `constructor() {}`와 유사하게 동작한다.
              1. _result_를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*)로 둔다.
            1. ? InitializeInstanceElements(_result_, _F_)를 수행한다.
            1. NormalCompletion(_result_)를 반환한다.
          1. _F_를 CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_)로 둔다.
        1. 그렇지 않으면,
          1. _constructorInfo_를 ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_로 둔다.
          1. _F_를 _constructorInfo_.[[Closure]]로 둔다.
          1. MakeClassConstructor(_F_)를 수행한다.
          1. SetFunctionName(_F_, _className_)을 수행한다.
        1. _F_.[[SourceText]]를 _sourceText_로 설정한다.
        1. MakeConstructor(_F_, *false*, _proto_)를 수행한다.
        1. |ClassHeritage|가 존재하면, _F_.[[ConstructorKind]]를 ~derived~로 설정한다.
        1. ! DefineMethodProperty(_proto_, *"constructor"*, _F_, *false*)를 수행한다.
        1. |ClassBody|가 존재하지 않으면, _elements_를 새 빈 List로 둔다.
        1. 그렇지 않으면, _elements_를 |ClassBody|의 NonConstructorElements로 둔다.
        1. _instancePrivateMethods_를 새 빈 List로 둔다.
        1. _staticPrivateMethods_를 새 빈 List로 둔다.
        1. _instanceFields_를 새 빈 List로 둔다.
        1. _staticElements_를 새 빈 List로 둔다.
        1. _elements_의 각 |ClassElement| _e_에 대해 다음을 수행한다:
          1. _e_의 IsStatic이 *false*이면,
            1. _element_를 Completion(ClassElementEvaluation of _e_ with argument _proto_)로 둔다.
          1. 그렇지 않으면,
            1. _element_를 Completion(ClassElementEvaluation of _e_ with argument _F_)로 둔다.
          1. _element_가 abrupt completion이면,
            1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _env_로 설정한다.
            1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _outerPrivateEnvironment_로 설정한다.
            1. ? _element_를 반환한다.
          1. _element_를 ! _element_로 설정한다.
          1. _element_가 PrivateElement이면,
            1. 단언: _element_.[[Kind]]는 ~method~ 또는 ~accessor~ 중 하나이다.
            1. _e_의 IsStatic이 *false*이면, _container_를 _instancePrivateMethods_로 둔다; 그렇지 않으면, _container_를 _staticPrivateMethods_로 둔다.
            1. _container_가 [[Key]]가 _element_.[[Key]]인 PrivateElement _pe_를 포함하면,
              1. 단언: _element_.[[Kind]]와 _pe_.[[Kind]]는 모두 ~accessor~이다.
              1. _element_.[[Get]]이 *undefined*이면,
                1. _combined_를 PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }로 둔다.
              1. 그렇지 않으면,
                1. _combined_를 PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }로 둔다.
              1. _container_에서 _pe_를 _combined_로 대체한다.
            1. 그렇지 않으면,
              1. _element_를 _container_에 추가한다.
          1. 그렇지 않고 _element_가 ClassFieldDefinition Record이면,
            1. _e_의 IsStatic이 *false*이면, _element_를 _instanceFields_에 추가한다.
            1. 그렇지 않으면, _element_를 _staticElements_에 추가한다.
          1. 그렇지 않고 _element_가 ClassStaticBlockDefinition Record이면,
            1. _element_를 _staticElements_에 추가한다.
        1. 실행 중인 실행 컨텍스트의 LexicalEnvironment를 _env_로 설정한다.
        1. _classBinding_이 *undefined*가 아니면,
          1. ! _classEnv_.InitializeBinding(_classBinding_, _F_)를 수행한다.
        1. _F_.[[PrivateMethods]]를 _instancePrivateMethods_로 설정한다.
        1. _F_.[[Fields]]를 _instanceFields_로 설정한다.
        1. _staticPrivateMethods_의 각 PrivateElement _method_에 대해,
          1. ! PrivateMethodOrAccessorAdd(_F_, _method_)를 수행한다.
        1. _staticElements_의 각 요소 _elementRecord_에 대해,
          1. _elementRecord_가 ClassFieldDefinition Record이면,
            1. _result_를 Completion(DefineField(_F_, _elementRecord_))로 둔다.
          1. 그렇지 않으면,
            1. 단언: _elementRecord_는 ClassStaticBlockDefinition Record이다.
            1. _result_를 Completion(Call(_elementRecord_.[[BodyFunction]], _F_))로 둔다.
          1. _result_가 abrupt completion이면,
            1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _outerPrivateEnvironment_로 설정한다.
            1. ? _result_를 반환한다.
        1. 실행 중인 실행 컨텍스트의 PrivateEnvironment를 _outerPrivateEnvironment_로 설정한다.
        1. _F_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation" type="sdo">
      <h1>런타임 의미론: BindingClassDeclarationEvaluation ( ): 함수 객체를 포함하는 정상 완료 또는 abrupt completion</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 StringValue를 _className_으로 둔다.
        1. |ClassDeclaration|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 _className_, _className_, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 _value_로 둔다.
        1. 실행 컨텍스트의 LexicalEnvironment를 _env_로 둔다.
        1. ? InitializeBoundName(_className_, _value_, _env_)를 수행한다.
        1. _value_를 반환한다.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. |ClassDeclaration|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 *undefined*, *"default"*, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>는 |ExportDeclaration|의 일부로만 나타나며, 바인딩 생성은 해당 생성물의 평가 동작에서 처리된다. <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref> 참고.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: Evaluation</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 이 |ClassDeclaration|에 대해 ? BindingClassDeclarationEvaluation을 수행한다.
        1. ~empty~를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>는 |ExportDeclaration|의 일부로만 나타나며 직접 평가되지 않는다.</p>
      </emu-note>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. |ClassExpression|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 *undefined*, *""*, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassExpression : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. |BindingIdentifier|의 StringValue를 _className_으로 둔다.
        1. |ClassExpression|이 매칭한 소스 텍스트를 _sourceText_로 둔다.
        1. |ClassTail|에 대해 _className_, _className_, _sourceText_를 인수로 하여 ClassDefinitionEvaluation의 결과를 반환한다.
      </emu-alg>
      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. |PrivateIdentifier|의 StringValue를 _privateIdentifier_로 둔다.
        1. 실행 컨텍스트의 PrivateEnvironment를 _privateEnvRec_로 둔다.
        1. _privateEnvRec_.[[Names]]를 _names_로 둔다.
        1. 단언: _names_의 정확히 하나의 요소가 [[Description]]이 _privateIdentifier_인 Private Name임.
        1. _privateName_을 _names_ 중 [[Description]]이 _privateIdentifier_인 Private Name으로 둔다.
        1. _privateName_을 반환한다.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined*를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async 함수 정의</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      AsyncFunctionDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionExpression :
        `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncMethod[Yield, Await] :
        `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionBody :
        FunctionBody[~Yield, +Await]

      AwaitExpression[Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>

    <emu-note>
      <p>`await`는 <sub>[Await]</sub> 파라미터가 있을 때 |AwaitExpression|의 키워드로 파싱된다. <sub>[Await]</sub> 파라미터는 아래 문맥의 최상위에 있지만, |FunctionBody| 같은 비단말에 따라 부재할 수 있다:</p>
      <ul>
        <li>|AsyncFunctionBody| 내부</li>
        <li>|AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|의 |FormalParameters| 내부. 이 위치의 |AwaitExpression|은 정적 의미론에 의해 문법 오류이다.</li>
        <li>|Module| 내부</li>
      </ul>
      <p>|Script|가 구문 목표 기호일 때, <sub>[Await]</sub> 파라미터가 없으면 `await`는 식별자로 파싱될 수 있다. 해당 문맥은 다음과 같다:</p>
      <ul>
        <li>|AsyncFunctionBody| 또는 |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|의 |FormalParameters| 외부의 모든 위치</li>
        <li>|FunctionExpression|, |GeneratorExpression|, |AsyncGeneratorExpression|의 |BindingIdentifier| 내부</li>
      </ul>
    </emu-note>

    <emu-note>
      <p>|YieldExpression|과 달리 |AwaitExpression|의 피연산자를 생략하면 문법 오류이다. 반드시 await할 대상이 있어야 한다.</p>
    </emu-note>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>|AsyncFunctionBody|의 FunctionBodyContainsUseStrict가 *true*이고 |UniqueFormalParameters|의 IsSimpleParameterList가 *false*이면 문법 오류이다.</li>
        <li>|AsyncMethod|의 HasDirectSuper가 *true*이면 문법 오류이다.</li>
        <li>|UniqueFormalParameters|이 |AwaitExpression|을 포함하면 문법 오류이다.</li>
        <li>|UniqueFormalParameters|의 BoundNames 중 어떤 요소라도 |AsyncFunctionBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
      </ul>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>|AsyncFunctionBody|의 FunctionBodyContainsUseStrict가 *true*이고 |FormalParameters|의 IsSimpleParameterList가 *false*이면 문법 오류이다.</li>
        <li>|FormalParameters|이 |AwaitExpression|을 포함하면 문법 오류이다.</li>
        <li>|FormalParameters|의 IsStrict가 *true*이면 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>에 대한 조기 오류 규칙을 적용한다.</li>
        <li>|BindingIdentifier|가 존재하고 IsStrict(|BindingIdentifier|)가 *true*이면, 그 StringValue가 *"eval"* 또는 *"arguments"*인 경우 문법 오류이다.</li>
        <li>|FormalParameters|의 BoundNames 중 어떤 요소라도 |AsyncFunctionBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
        <li>|FormalParameters|이 |SuperProperty|을 포함하면 문법 오류이다.</li>
        <li>|AsyncFunctionBody|이 |SuperProperty|을 포함하면 문법 오류이다.</li>
        <li>|FormalParameters|이 |SuperCall|을 포함하면 문법 오류이다.</li>
        <li>|AsyncFunctionBody|이 |SuperCall|을 포함하면 문법 오류이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionobject" oldids="sec-async-function-definitions-InstantiateFunctionObject" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncFunctionObject(
        _env_: Environment Record,
        _privateEnv_: PrivateEnvironment Record 또는 *null*,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_을 |BindingIdentifier|의 StringValue로 둔다.
        1. _sourceText_를 |AsyncFunctionDeclaration|이 매칭한 소스 텍스트로 둔다.
        1. _F_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_F_, _name_)을 수행한다.
        1. _F_를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _sourceText_를 |AsyncFunctionDeclaration|이 매칭한 소스 텍스트로 둔다.
        1. _F_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_F_, *"default"*)를 수행한다.
        1. _F_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncFunctionExpression(
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. _name_이 없다면 _name_ = *""*로 설정한다.
        1. _env_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncFunctionExpression|이 매칭한 소스 텍스트로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 단언: _name_은 없다.
        1. _name_을 |BindingIdentifier|의 StringValue로 둔다.
        1. _outerEnv_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _funcEnv_를 NewDeclarativeEnvironment(_outerEnv_)로 둔다.
        1. ! _funcEnv_.CreateImmutableBinding(_name_, *false*)를 수행한다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncFunctionExpression|이 매칭한 소스 텍스트로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. ! _funcEnv_.InitializeBinding(_name_, _closure_)를 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
      <emu-note>
        <p>|AsyncFunctionExpression|의 |BindingIdentifier|는 그 |AsyncFunctionBody| 내부에서 참조되어 함수가 재귀적으로 자신을 호출할 수 있게 한다. 하지만 |FunctionDeclaration|과 달리 |AsyncFunctionExpression|의 |BindingIdentifier|는 외부 스코프에서 참조할 수 없고 영향을 주지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncfunctionbody" oldids="sec-async-function-definitions-EvaluateBody" type="sdo">
      <h1>
        런타임 의미론: EvaluateAsyncFunctionBody(
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값 리스트,
        ): return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. _promiseCapability_를 ! NewPromiseCapability(%Promise%)로 둔다.
        1. _completion_을 Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_))로 둔다.
        1. _completion_이 abrupt completion이면
          1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »)를 수행한다.
        1. 그렇지 않으면
          1. AsyncFunctionStart(_promiseCapability_, |FunctionBody|)를 수행한다.
        1. ReturnCompletion(_promiseCapability_.[[Promise]])를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>
        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. |AsyncFunctionExpression|의 InstantiateAsyncFunctionExpression을 반환한다.
      </emu-alg>
      <emu-grammar>
        AwaitExpression : `await` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. _exprRef_를 |UnaryExpression| 평가 결과(?)로 둔다.
        1. _value_를 ? GetValue(_exprRef_)로 둔다.
        1. ? Await(_value_)를 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-arrow-function-definitions">
    <h1>Async 화살표 함수 정의</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      AsyncArrowFunction[In, Yield, Await] :
        `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

      AsyncConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, +Await]
        `{` AsyncFunctionBody `}`

      AsyncArrowBindingIdentifier[Yield] :
        BindingIdentifier[?Yield, +Await]

      CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>
    <h2>보충 구문</h2>
    <p>
      생성물 인스턴스<br>
      <emu-grammar>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody</emu-grammar><br>
      를 처리할 때 |CoverCallExpressionAndAsyncArrowHead|의 해석은 다음 구문을 사용해 정밀화된다:
    </p>

    <emu-grammar type="definition">
      AsyncArrowHead :
        `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|AsyncArrowBindingIdentifier|의 BoundNames 중 어떤 요소라도 |AsyncConciseBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
      </ul>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|CoverCallExpressionAndAsyncArrowHead|는 반드시 |AsyncArrowHead|를 커버해야 한다.</li>
        <li>|CoverCallExpressionAndAsyncArrowHead|이 |YieldExpression|을 포함하면 문법 오류이다.</li>
        <li>|CoverCallExpressionAndAsyncArrowHead|이 |AwaitExpression|을 포함하면 문법 오류이다.</li>
        <li>|CoverCallExpressionAndAsyncArrowHead|의 BoundNames 중 어떤 요소라도 |AsyncConciseBody|의 LexicallyDeclaredNames에도 있으면 문법 오류이다.</li>
        <li>AsyncConciseBodyContainsUseStrict(|AsyncConciseBody|)가 *true*이고 IsSimpleParameterList(|CoverCallExpressionAndAsyncArrowHead|)가 *false*이면 문법 오류이다.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-asyncconcisebodycontainsusestrict" oldids="sec-async-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>정적 의미론: AsyncConciseBodyContainsUseStrict(): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>AsyncConciseBody : `{` AsyncFunctionBody `}`</emu-grammar>
      <emu-alg>
        1. FunctionBodyContainsUseStrict(|AsyncFunctionBody|)를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncconcisebody" oldids="sec-async-arrow-function-definitions-EvaluateBody" type="sdo">
      <h1>
        런타임 의미론: EvaluateAsyncConciseBody(
        _functionObject_: ECMAScript 함수 객체,
        _argumentsList_: ECMAScript 언어 값 리스트,
        ): return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. _promiseCapability_를 ! NewPromiseCapability(%Promise%)로 둔다.
        1. _completion_을 Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_))로 둔다.
        1. _completion_이 abrupt completion이면
          1. ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »)를 수행한다.
        1. 그렇지 않으면
          1. AsyncFunctionStart(_promiseCapability_, |ExpressionBody|)를 수행한다.
        1. ReturnCompletion(_promiseCapability_.[[Promise]])를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncarrowfunctionexpression" type="sdo">
      <h1>
        런타임 의미론: InstantiateAsyncArrowFunctionExpression(
        optional _name_: property key 또는 Private Name,
        ): ECMAScript 함수 객체
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_이 없으면 _name_ = *""*로 설정한다.
        1. _env_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncArrowFunction|이 매칭한 소스 텍스트로 둔다.
        1. _parameters_를 |AsyncArrowBindingIdentifier|로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. _name_이 없으면 _name_ = *""*로 설정한다.
        1. _env_를 실행 중 실행 컨텍스트의 LexicalEnvironment로 둔다.
        1. _privateEnv_를 실행 중 실행 컨텍스트의 PrivateEnvironment로 둔다.
        1. _sourceText_를 |AsyncArrowFunction|이 매칭한 소스 텍스트로 둔다.
        1. _head_를 |CoverCallExpressionAndAsyncArrowHead|가 커버하는 |AsyncArrowHead|로 둔다.
        1. _parameters_를 _head_의 |ArrowFormalParameters|로 둔다.
        1. _closure_를 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_)로 둔다.
        1. SetFunctionName(_closure_, _name_)을 수행한다.
        1. _closure_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. |AsyncArrowFunction|의 InstantiateAsyncArrowFunctionExpression을 반환한다.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>꼬리 위치 호출</h1>

    <emu-clause id="sec-isintailposition" type="abstract operation">
      <h1>
        정적 의미론: IsInTailPosition(
        _call_: |CallExpression| Parse Node 또는 |MemberExpression| Parse Node 또는 |OptionalChain| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. IsStrict(_call_)이 *false*이면 *false*를 반환한다.
        1. _call_이 |FunctionBody|, |ConciseBody|, |AsyncConciseBody| 중 어느 것에도 포함되어 있지 않으면 *false*를 반환한다.
        1. _body_를 _call_을 가장 가까이 포함하는 |FunctionBody|, |ConciseBody|, |AsyncConciseBody|로 둔다.
        1. _body_가 |GeneratorBody|의 |FunctionBody|이면 *false*를 반환한다.
        1. _body_가 |AsyncFunctionBody|의 |FunctionBody|이면 *false*를 반환한다.
        1. _body_가 |AsyncGeneratorBody|의 |FunctionBody|이면 *false*를 반환한다.
        1. _body_가 |AsyncConciseBody|이면 *false*를 반환한다.
        1. _body_의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-note>
        <p>꼬리 위치 호출은 엄격 모드 코드에서만 정의된다. 이는 비표준 언어 확장( <emu-xref href="#sec-addrestrictedfunctionproperties"></emu-xref> 참조 )으로 인해 호출자 컨텍스트 체인을 관찰할 수 있게 되기 때문이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo" oldids="sec-statement-rules,sec-expression-rules">
      <h1>
        정적 의미론: HasCallInTailPosition(
        _call_: |CallExpression| Parse Node 또는 |MemberExpression| Parse Node 또는 |OptionalChain| Parse Node,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_은 소스 텍스트의 특정 범위를 나타내는 Parse Node이다. 아래 알고리즘에서 _call_을 다른 Parse Node와 비교할 때는 둘이 동일한 소스 텍스트를 나타내는지 여부를 검사한다.</p>
      </emu-note>
      <emu-note>
        <p>return GetValue로 바로 이어지는 잠재적 꼬리 위치 호출도 꼬리 위치 호출이 될 수 있다. 함수 호출은 Reference Record를 반환할 수 없으므로, 이런 GetValue 연산은 항상 실제 함수 호출 결과와 동일한 값을 반환한다.</p>
      </emu-note>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. |StatementList|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. |StatementListItem|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        FunctionStatementList :
          [empty]

        StatementListItem :
          Declaration

        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        ReturnStatement :
          `return` `;`

        LabelledItem :
          FunctionDeclaration

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        CaseBlock :
          `{` `}`
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 첫 번째 |Statement|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |Statement|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement

        DoWhileStatement :
          `do` Statement `while` `(` Expression `)` `;`

        WhileStatement :
          `while` `(` Expression `)` Statement

        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement

        WithStatement :
          `with` `(` Expression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. |Statement|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        LabelledStatement :
          LabelIdentifier `:` LabelledItem
      </emu-grammar>
      <emu-alg>
        1. |LabelledItem|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. |Expression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. |CaseBlock|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _has_를 *false*로 둔다.
        1. 첫 번째 |CaseClauses|가 있으면, 그 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. |DefaultClause|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |CaseClauses|가 있으면, 그 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_를 반환한다.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. |CaseClauses|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. |CaseClause|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        CaseClause : `case` Expression `:` StatementList?

        DefaultClause : `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. |StatementList|가 있으면 그 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. |Catch|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        TryStatement :
          `try` Block Finally
          `try` Block Catch Finally
      </emu-grammar>
      <emu-alg>
        1. |Finally|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. |Block|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>

      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        CallExpression :
          SuperCall
          ImportCall
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        Expression :
          AssignmentExpression
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. |AssignmentExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 첫 번째 |AssignmentExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 _has_로 둔다.
        1. _has_가 *true*이면 *true*를 반환한다.
        1. 두 번째 |AssignmentExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. |BitwiseORExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. |LogicalANDExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. |BitwiseORExpression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 이 |CallExpression|이 _call_이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        OptionalExpression :
          MemberExpression OptionalChain
          CallExpression OptionalChain
          OptionalExpression OptionalChain
      </emu-grammar>
      <emu-alg>
        1. |OptionalChain|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` `[` Expression `]`
          `?.` IdentifierName
          `?.` PrivateIdentifier
          OptionalChain `[` Expression `]`
          OptionalChain `.` IdentifierName
          OptionalChain `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` Arguments
          OptionalChain Arguments
      </emu-grammar>
      <emu-alg>
        1. 이 |OptionalChain|이 _call_이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>
        MemberExpression :
          MemberExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 이 |MemberExpression|이 _call_이면 *true*를 반환한다.
        1. *false*를 반환한다.
      </emu-alg>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. _expr_을 |CoverParenthesizedExpressionAndArrowParameterList|가 커버하는 |ParenthesizedExpression|으로 둔다.
        1. _expr_의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
      <emu-grammar>
        ParenthesizedExpression :
          `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. |Expression|의 HasCallInTailPosition 결과를 _call_ 인수로 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-preparefortailcall" type="abstract operation">
      <h1>PrepareForTailCall ( ): ~unused~</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 현재 실행 컨텍스트는 이후 ECMAScript 코드 또는 내장 함수의 평가에 사용되지 않을 것임을 단언한다. 이 추상 연산 이후 Call을 호출하면 해당 평가 전에 새 실행 컨텍스트가 생성되고 push된다.
        1. 현재 실행 컨텍스트와 관련된 모든 리소스를 폐기한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <p>꼬리 위치 호출은 현재 실행 중인 함수 실행 컨텍스트와 관련된 임시 내부 리소스를 호출 대상 함수 전에 해제하거나, 해당 함수에 재사용해야 한다.</p>
      <emu-note>
        <p>예를 들어, 꼬리 위치 호출은 대상 함수의 activation record가 호출 함수의 activation record보다 커지는 만큼만 스택 크기를 증가시켜야 한다. 대상 함수의 activation record가 더 작다면, 전체 스택 크기는 줄어들어야 한다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript 언어: 스크립트와 모듈</h1>

  <emu-clause id="sec-scripts">
    <h1>스크립트</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        StatementList[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>정적 의미론: 조기 오류</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          |ScriptBody|의 LexicallyDeclaredNames가 중복 항목을 포함하면 구문 오류이다.
        </li>
        <li>
          |ScriptBody|의 LexicallyDeclaredNames의 어떤 요소가 |ScriptBody|의 VarDeclaredNames에도 나타나면 구문 오류이다.
        </li>
      </ul>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <ul>
        <li>
          `super`를 포함한 소스 텍스트가 직접 eval에 의해 처리되는 eval 코드가 아닌 한, |StatementList|가 `super`를 포함하면 구문 오류이다. 직접 eval 내의 `super`에 대한 추가 조기 오류 규칙은 <emu-xref href="#sec-performeval"></emu-xref>에 정의되어 있다.
        </li>
        <li>
          |NewTarget|을 포함한 소스 텍스트가 직접 eval에 의해 처리되는 eval 코드가 아닌 한, |StatementList|가 |NewTarget|을 포함하면 구문 오류이다. 직접 eval에서 |NewTarget|에 대한 추가 조기 오류 규칙은 <emu-xref href="#sec-performeval"></emu-xref>에 정의되어 있다.
        </li>
        <li>
          인수 « »를 사용한 |StatementList|의 ContainsDuplicateLabels가 *true*이면 구문 오류이다.
        </li>
        <li>
          인수 « »를 사용한 |StatementList|의 ContainsUndefinedBreakTarget이 *true*이면 구문 오류이다.
        </li>
        <li>
          인수 « »와 « »를 사용한 |StatementList|의 ContainsUndefinedContinueTarget이 *true*이면 구문 오류이다.
        </li>
        <li>
          |ScriptBody|를 포함한 소스 텍스트가 직접 eval에 의해 처리되는 eval 코드가 아닌 한, 인수 « »를 사용한 |StatementList|의 AllPrivateIdentifiersValid가 *false*이면 구문 오류이다.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-scriptisstrict" oldids="sec-static-semantics-isstrict" type="sdo">
      <h1>정적 의미론: ScriptIsStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Script : ScriptBody?</emu-grammar>
      <emu-alg>
        1. |ScriptBody|가 존재하고 |ScriptBody|의 Directive Prologue가 Use Strict Directive를 포함하면 *true*를 반환하고, 그렇지 않으면 *false*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>런타임 의미론: 평가</h1>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. *undefined*를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-records">
      <h1>스크립트 레코드</h1>

      <p><dfn id="script-record" variants="Script Records">스크립트 레코드</dfn>는 평가되는 스크립트에 대한 정보를 캡슐화한다. 각 스크립트 레코드는 <emu-xref href="#table-script-records"></emu-xref>에 나열된 필드를 포함한다.</p>

      <emu-table id="table-script-records" caption="스크립트 레코드 필드">
        <table>
          <thead>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              Realm Record
            </td>
            <td>
              이 스크립트가 생성된 영역.
            </td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              |Script| Parse Node
            </td>
            <td>
              이 스크립트의 소스 텍스트를 파싱한 결과.
            </td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              LoadedModuleRequest Records의 리스트
            </td>
            <td>
              이 스크립트가 가져온 지정자 문자열에서 해결된 Module Record로의 맵. 리스트는 ModuleRequestsEqual(_r1_, _r2_)이 *true*인 서로 다른 Records _r1_과 _r2_를 두 개 포함하지 않는다.
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (기본값은 ~empty~)
            </td>
            <td>
              스크립트와 추가 정보를 연결해야 하는 호스트 환경에서 사용하기 위해 예약된 필드.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript 소스 텍스트,
          _realm_: Realm Record,
          _hostDefined_: anything,
        ): Script Record 또는 *SyntaxError* 객체의 비어있지 않은 리스트
      </h1>
      <dl class="header">
        <dt>설명</dt>
        <dd>_sourceText_를 |Script|로 파싱한 결과를 기반으로 Script Record를 생성한다.</dd>
      </dl>

      <emu-alg>
        1. _script_를 ParseText(_sourceText_, |Script|)로 둔다.
        1. _script_가 오류의 리스트이면 _script_를 반환한다.
        1. Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }를 반환한다.
      </emu-alg>
      <emu-note>
        <p>구현은 해당 스크립트 소스 텍스트에 대해 ParseScript를 평가하기 전에 스크립트 소스 텍스트를 파싱하고 조기 오류 조건을 분석할 수 있다. 그러나 오류 보고는 이 명세가 실제로 해당 소스 텍스트에 대해 ParseScript를 수행하는 시점까지 연기되어야 한다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-scriptevaluation" type="abstract operation">
      <h1>
        ScriptEvaluation (
          _scriptRecord_: Script Record,
        ): ECMAScript 언어 값을 포함하는 정상 완료 또는 abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-alg>
        1. _globalEnv_를 _scriptRecord_.[[Realm]].[[GlobalEnv]]로 둔다.
        1. _scriptContext_를 새로운 ECMAScript 코드 실행 컨텍스트로 둔다.
        1. _scriptContext_의 Function을 *null*로 설정한다.
        1. _scriptContext_의 Realm을 _scriptRecord_.[[Realm]]으로 설정한다.
        1. _scriptContext_의 ScriptOrModule을 _scriptRecord_로 설정한다.
        1. _scriptContext_의 VariableEnvironment를 _globalEnv_로 설정한다.
        1. _scriptContext_의 LexicalEnvironment를 _globalEnv_로 설정한다.
        1. _scriptContext_의 PrivateEnvironment를 *null*로 설정한다.
        1. 실행 중인 실행 컨텍스트를 일시 중단한다.
        1. _scriptContext_를 실행 컨텍스트 스택에 푸시한다; _scriptContext_가 이제 실행 중인 실행 컨텍스트이다.
        1. _script_를 _scriptRecord_.[[ECMAScriptCode]]로 둔다.
        1. _result_를 Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_))로 둔다.
        1. _result_가 정상 완료이면
          1. _result_를 Completion(Evaluation of _script_)로 설정한다.
          1. _result_가 정상 완료이고 _result_.[[Value]]가 ~empty~이면
            1. _result_를 NormalCompletion(*undefined*)로 설정한다.
        1. _scriptContext_를 일시 중단하고 실행 컨텍스트 스택에서 제거한다.
        1. 단언: 실행 컨텍스트 스택이 비어있지 않다.
        1. 이제 실행 컨텍스트 스택의 맨 위에 있는 컨텍스트를 실행 중인 실행 컨텍스트로 재개한다.
        1. ? _result_를 반환한다.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-globaldeclarationinstantiation">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: |Script| Parse Node,
          _env_: Global Environment Record,
        ): ~unused~를 포함하는 정상 완료 또는 throw completion
      </h1>
      <dl class="header">
        <dt>설명</dt>
        <dd>_script_는 실행 컨텍스트가 설정되는 |Script|이다. _env_는 바인딩이 생성될 전역 환경이다.</dd>
      </dl>
      <emu-note>
        <p>스크립트 평가를 위한 실행 컨텍스트가 설정될 때, 선언은 현재 전역 환경에서 인스턴스화된다. 코드에서 선언된 각 전역 바인딩이 인스턴스화된다.</p>
      </emu-note>
      <p>호출될 때 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _lexNames_를 _script_의 LexicallyDeclaredNames로 둔다.
        1. _varNames_를 _script_의 VarDeclaredNames로 둔다.
        1. _lexNames_의 각 요소 _name_에 대해
          1. HasLexicalDeclaration(_env_, _name_)이 *true*이면 *SyntaxError* 예외를 던진다.
          1. _hasRestrictedGlobal_을 ? HasRestrictedGlobalProperty(_env_, _name_)로 둔다.
          1. 참고: 전역 `var`와 `function` 바인딩(비-strict 직접 eval에 의해 도입된 것들을 제외하고)은 non-configurable이므로 제한된 전역 속성이다.
          1. _hasRestrictedGlobal_이 *true*이면 *SyntaxError* 예외를 던진다.
        1. _varNames_의 각 요소 _name_에 대해
          1. HasLexicalDeclaration(_env_, _name_)이 *true*이면 *SyntaxError* 예외를 던진다.
        1. _varDeclarations_를 _script_의 VarScopedDeclarations로 둔다.
        1. _functionsToInitialize_를 새로운 빈 리스트로 둔다.
        1. _declaredFunctionNames_를 새로운 빈 리스트로 둔다.
        1. _varDeclarations_의 각 요소 _d_에 대해 역순으로
          1. _d_가 |VariableDeclaration|, |ForBinding|, 또는 |BindingIdentifier|가 아니면
            1. 단언: _d_는 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, 또는 |AsyncGeneratorDeclaration| 중 하나이다.
            1. 참고: 같은 이름에 대해 여러 함수 선언이 있으면 마지막 선언이 사용된다.
            1. _fn_을 _d_의 BoundNames의 유일한 요소로 둔다.
            1. _declaredFunctionNames_가 _fn_을 포함하지 않으면
              1. _fnDefinable_을 ? CanDeclareGlobalFunction(_env_, _fn_)로 둔다.
              1. _fnDefinable_이 *false*이면 *TypeError* 예외를 던진다.
              1. _fn_을 _declaredFunctionNames_에 추가한다.
              1. _d_를 _functionsToInitialize_의 첫 번째 요소로 삽입한다.
        1. _declaredVarNames_를 새로운 빈 리스트로 둔다.
        1. _varDeclarations_의 각 요소 _d_에 대해
          1. _d_가 |VariableDeclaration|, |ForBinding|, 또는 |BindingIdentifier|이면
            1. _d_의 BoundNames의 각 String _vn_에 대해
              1. _declaredFunctionNames_가 _vn_을 포함하지 않으면
                1. _vnDefinable_을 ? CanDeclareGlobalVar(_env_, _vn_)로 둔다.
                1. _vnDefinable_이 *false*이면 *TypeError* 예외를 던진다.
                1. _declaredVarNames_가 _vn_을 포함하지 않으면
                  1. _vn_을 _declaredVarNames_에 추가한다.
        1. 참고: 전역 객체가 일반 객체인 경우 이 알고리즘 단계 이후에는 비정상적인 종료가 발생하지 않는다. 그러나 전역 객체가 Proxy exotic 객체인 경우 다음 단계 중 일부에서 비정상적인 종료를 유발하는 동작을 보일 수 있다.
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point", normative-optional] 호스트가 웹 브라우저이거나 그렇지 않으면 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>를 지원하면
          1. _strict_를 _script_의 ScriptIsStrict로 둔다.
          1. _strict_가 *false*이면
            1. _declaredFunctionOrVarNames_를 _declaredFunctionNames_와 _declaredVarNames_의 리스트 연결로 둔다.
            1. _script_가 _x_를 포함하는 것이 *true*인 |Block|, |CaseClause|, 또는 |DefaultClause| _x_의 |StatementList|에 직접 포함된 각 |FunctionDeclaration| _f_에 대해
              1. _F_를 _f_의 |BindingIdentifier|의 StringValue로 둔다.
              1. |FunctionDeclaration| _f_를 _F_를 |BindingIdentifier|로 가진 |VariableStatement|로 대체하는 것이 _script_에 대해 조기 오류를 생성하지 않으면
                1. HasLexicalDeclaration(_env_, _F_)가 *false*이면
                  1. _fnDefinable_을 ? CanDeclareGlobalVar(_env_, _F_)로 둔다.
                  1. _fnDefinable_이 *true*이면
                    1. 참고: _F_에 대한 var 바인딩은 VarDeclaredName도 아니고 다른 |FunctionDeclaration|의 이름도 아닌 경우에만 여기서 인스턴스화된다.
                    1. _declaredFunctionOrVarNames_가 _F_를 포함하지 않으면
                      1. ? CreateGlobalVarBinding(_env_, _F_, *false*)를 수행한다.
                      1. _F_를 _declaredFunctionOrVarNames_에 추가한다.
                    1. [id="step-globaldeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_가 평가될 때, <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>에서 제공하는 |FunctionDeclaration| Evaluation 알고리즘 대신 다음 단계를 수행한다:
                      1. _gEnv_를 실행 중인 실행 컨텍스트의 VariableEnvironment로 둔다.
                      1. _bEnv_를 실행 중인 실행 컨텍스트의 LexicalEnvironment로 둔다.
                      1. _fObj_를 ! _bEnv_.GetBindingValue(_F_, *false*)로 둔다.
                      1. ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*)를 수행한다.
                      1. ~unused~를 반환한다.
        1. _lexDeclarations_를 _script_의 LexicallyScopedDeclarations로 둔다.
        1. _privateEnv_를 *null*로 둔다.
        1. _lexDeclarations_의 각 요소 _d_에 대해
          1. 참고: 어휘적으로 선언된 이름은 여기서만 인스턴스화되고 초기화되지 않는다.
          1. _d_의 BoundNames의 각 요소 _dn_에 대해
            1. _d_의 IsConstantDeclaration이 *true*이면
              1. ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*)를 수행한다.
            1. 그렇지 않으면
              1. ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*)를 수행한다.
        1. _functionsToInitialize_의 각 Parse Node _f_에 대해
          1. _fn_을 _f_의 BoundNames의 유일한 요소로 둔다.
          1. _fo_를 인수 _env_와 _privateEnv_를 사용한 _f_의 InstantiateFunctionObject로 둔다.
          1. ? <emu-meta effects="user-code">CreateGlobalFunctionBinding</emu-meta>(_env_, _fn_, _fo_, *false*)를 수행한다.
        1. _declaredVarNames_의 각 String _vn_에 대해
          1. ? <emu-meta effects="user-code">CreateGlobalVarBinding</emu-meta>(_env_, _vn_, *false*)를 수행한다.
        1. ~unused~를 반환한다.
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref>에 명시된 조기 오류는 function/var 선언과 let/const/class 선언 간의 이름 충돌뿐만 아니라 단일 |Script| 내에 포함된 선언에 대한 let/const/class 바인딩의 재선언을 방지한다. 그러나 둘 이상의 |Script|에 걸친 이러한 충돌과 재선언은 GlobalDeclarationInstantiation 중에 런타임 오류로 감지된다. 이러한 오류가 감지되면 스크립트에 대해 바인딩이 인스턴스화되지 않는다. 그러나 전역 객체가 Proxy exotic 객체를 사용하여 정의된 경우 충돌하는 선언에 대한 런타임 테스트가 신뢰할 수 없어 abrupt completion과 일부 전역 선언이 인스턴스화되지 않을 수 있다. 이런 경우 |Script|의 코드는 평가되지 않는다.</p>
        <p>명시적인 var 또는 function 선언과 달리, 전역 객체에서 직접 생성된 속성은 let/const/class 선언에 의해 가려질 수 있는 전역 바인딩을 만든다.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>모듈</h1>
    <h2>구문</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>모듈 의미론</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            |ModuleItemList|의 LexicallyDeclaredNames가 중복 항목을 포함하면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|의 LexicallyDeclaredNames의 어떤 요소가 |ModuleItemList|의 VarDeclaredNames에도 나타나면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|의 ExportedNames가 중복 항목을 포함하면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|의 ExportedBindings의 어떤 요소가 |ModuleItemList|의 VarDeclaredNames 또는 LexicallyDeclaredNames에 나타나지 않으면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|가 `super`를 포함하면 구문 오류이다.
          </li>
          <li>
            |ModuleItemList|가 |NewTarget|을 포함하면 구문 오류이다.
          </li>
          <li>
            인수 « »를 사용한 |ModuleItemList|의 ContainsDuplicateLabels가 *true*이면 구문 오류이다.
          </li>
          <li>
            인수 « »를 사용한 |ModuleItemList|의 ContainsUndefinedBreakTarget이 *true*이면 구문 오류이다.
          </li>
          <li>
            인수 « »와 « »를 사용한 |ModuleItemList|의 ContainsUndefinedContinueTarget이 *true*이면 구문 오류이다.
          </li>
          <li>
            인수 « »를 사용한 |ModuleItemList|의 AllPrivateIdentifiersValid가 *false*이면 구문 오류이다.
          </li>
        </ul>
        <emu-note>
          <p>중복된 ExportedNames 규칙은 |ModuleBody| 내에서 여러 `export default` |ExportDeclaration| 항목이 구문 오류임을 의미한다. 충돌하거나 중복된 선언과 관련된 추가 오류 조건은 |Module| 평가 전에 모듈 링킹 중에 확인된다. 이러한 오류가 감지되면 |Module|은 평가되지 않는다.</p>
        </emu-note>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <ul>
          <li>IsStringWellFormedUnicode(SV of |StringLiteral|)이 *false*이면 구문 오류이다.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-importedlocalnames" type="abstract operation">
        <h1>
          정적 의미론: ImportedLocalNames (
          _importEntries_: ImportEntry Records의 리스트,
          ): 문자열의 리스트
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_importEntries_에 의해 정의된 모든 로컬 이름 바인딩의 리스트를 생성한다.</dd>
        </dl>
        <emu-alg>
          1. _localNames_를 새로운 빈 리스트로 둔다.
          1. _importEntries_의 각 ImportEntry Record _i_에 대해
            1. _i_.[[LocalName]]을 _localNames_에 추가한다.
          1. _localNames_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulerequest-record">
        <h1>ModuleRequest 레코드</h1>

        <p><dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest 레코드</dfn>는 주어진 가져오기 속성을 가진 모듈을 가져오는 요청을 나타낸다. 다음 필드들로 구성된다:</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest 레코드 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                문자열
              </td>
              <td>
                모듈 지정자
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Records의 리스트
              </td>
              <td>
                가져오기 속성
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="loadedmodulerequest-record" variants="LoadedModuleRequest Records">LoadedModuleRequest 레코드</dfn>는 모듈을 가져오는 요청과 결과 Module Record를 함께 나타낸다. 표 <emu-xref href="#table-modulerequest-fields"></emu-xref>에 정의된 동일한 필드들과 [[Module]] 필드의 추가로 구성된다:</p>
        <emu-table id="table-loadedmodulerequest-fields" caption="LoadedModuleRequest 레코드 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                문자열
              </td>
              <td>
                모듈 지정자
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Records의 리스트
              </td>
              <td>
                가져오기 속성
              </td>
            </tr>
            <tr>
              <td>
                [[Module]]
              </td>
              <td>
                Module Record
              </td>
              <td>
                이 모듈 요청에 해당하는 로드된 모듈
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="importattribute-record" variants="ImportAttribute Records">ImportAttribute 레코드</dfn>는 다음 필드들로 구성된다:</p>
        <emu-table id="table-importattribute-fields" caption="ImportAttribute 레코드 필드">
          <table>
            <tr>
              <th>
                필드 이름
              </th>
              <th>
                값 타입
              </th>
              <th>
                의미
              </th>
            </tr>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                문자열
              </td>
              <td>
                속성 키
              </td>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                문자열
              </td>
              <td>
                속성 값
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ModuleRequestsEqual" type="abstract operation">
          <h1>
            ModuleRequestsEqual (
              _left_: ModuleRequest Record 또는 LoadedModuleRequest Record,
              _right_: ModuleRequest Record 또는 LoadedModuleRequest Record,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. _left_.[[Specifier]]가 _right_.[[Specifier]]와 같지 않으면 *false*를 반환한다.
            1. _leftAttrs_를 _left_.[[Attributes]]로 둔다.
            1. _rightAttrs_를 _right_.[[Attributes]]로 둔다.
            1. _leftAttrsCount_를 _leftAttrs_의 요소 개수로 둔다.
            1. _rightAttrsCount_를 _rightAttrs_의 요소 개수로 둔다.
            1. _leftAttrsCount_ ≠ _rightAttrsCount_이면 *false*를 반환한다.
            1. _leftAttrs_의 각 ImportAttribute Record _l_에 대해
              1. _rightAttrs_가 _l_.[[Key]]가 _r_.[[Key]]이고 _l_.[[Value]]가 _r_.[[Value]]인 ImportAttribute Record _r_을 포함하지 않으면 *false*를 반환한다.
            1. *true*를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo">
        <h1>정적 의미론: ModuleRequests ( ): ModuleRequest Records의 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 새로운 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. |ModuleItem|의 ModuleRequests를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _requests_를 |ModuleItemList|의 ModuleRequests로 둔다.
          1. _additionalRequests_를 |ModuleItem|의 ModuleRequests로 둔다.
          1. _additionalRequests_의 각 ModuleRequest Record _mr_에 대해
            1. _requests_가 ModuleRequestsEqual(_mr_, _mr2_)이 *true*인 ModuleRequest Record _mr2_를 포함하지 않으면
              1. _mr_을 _requests_에 추가한다.
          1. _requests_를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. 새로운 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. _attributes_를 |WithClause|의 WithClauseToAttributes로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |ModuleSpecifier|의 SV로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause `;`</emu-grammar>
        <emu-alg>
          1. _specifier_를 |ModuleSpecifier|의 SV로 둔다.
          1. _attributes_를 |WithClause|의 WithClauseToAttributes로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause WithClause `;`
        </emu-grammar>
        <emu-alg>
          1. _specifier_를 |FromClause|의 SV로 둔다.
          1. _attributes_를 |WithClause|의 WithClauseToAttributes로 둔다.
          1. ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }가 유일한 요소인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 새로운 빈 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>추상 모듈 레코드</h1>
        <p><dfn variants="Module Records">모듈 레코드</dfn>는 단일 모듈의 가져오기와 내보내기에 대한 구조적 정보를 캡슐화한다. 이 정보는 연결된 모듈 집합의 가져오기와 내보내기를 링크하는 데 사용된다. 모듈 레코드는 모듈을 평가할 때만 사용되는 네 개의 필드를 포함한다.</p>
        <p>명세 목적상 Module Record 값은 Record 명세 타입의 값이며, Module Record가 추상 클래스이고 추상 및 구체적 하위 클래스를 모두 가진 간단한 객체 지향 계층 구조에 존재하는 것으로 생각할 수 있다. 이 명세는 Cyclic Module Record라는 추상 하위 클래스와 그 구체적 하위 클래스인 Source Text Module Record를 정의한다. 다른 명세와 구현은 그들이 정의한 대안적인 모듈 정의 기능에 해당하는 추가적인 Module Record 하위 클래스를 정의할 수 있다.</p>
        <p>Module Record는 <emu-xref href="#table-module-record-fields"></emu-xref>에 나열된 필드들을 정의한다. 모든 Module Definition 하위 클래스는 적어도 이러한 필드들을 포함한다. Module Record는 또한 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>의 추상 메서드 리스트를 정의한다. 모든 Module definition 하위 클래스는 이러한 추상 메서드들의 구체적인 구현을 제공해야 한다.</p>
        <emu-table id="table-module-record-fields" caption="모듈 레코드 필드" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                Realm Record
              </td>
              <td>
                이 모듈이 생성된 Realm.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                Module Environment Record 또는 ~empty~
              </td>
              <td>
                이 모듈의 최상위 바인딩을 포함하는 Environment Record. 이 필드는 모듈이 링크될 때 설정된다.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                Object 또는 ~empty~
              </td>
              <td>
                이 모듈에 대해 생성된 Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>).
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (기본값은 *undefined*)
              </td>
              <td>
                모듈과 추가 정보를 연결해야 하는 호스트 환경에서 사용하기 위해 예약된 필드.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="모듈 레코드의 추상 메서드" oldids="table-37">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                LoadRequestedModules([_hostDefined_])
              </td>
              <td>
                <p>모든 의존성을 재귀적으로 로드하여 모듈을 링킹을 위해 준비하고 프로미스를 반환한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>이 모듈에서 직접 또는 간접적으로 내보내지는 모든 이름의 리스트를 반환한다.</p>
                <p>이 메서드를 호출하기 전에 LoadRequestedModules가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>이 모듈에서 내보낸 이름의 바인딩을 반환한다. 바인딩은 { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ } 형태의 <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn>로 표현된다. 내보내기가 어떤 모듈에서도 직접 바인딩이 없는 Module Namespace Object인 경우 [[BindingName]]은 ~namespace~로 설정된다. 이름을 해결할 수 없으면 *null*을, 여러 바인딩이 발견되면 ~ambiguous~를 반환한다.</p>
                <p>특정 _exportName_, _resolveSet_ 쌍을 인수로 이 연산을 호출할 때마다 동일한 결과를 반환해야 한다.</p>
                <p>이 메서드를 호출하기 전에 LoadRequestedModules가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>모든 모듈 의존성을 전이적으로 해결하고 Module Environment Record를 생성하여 모듈을 평가를 위해 준비한다.</p>
                <p>이 메서드를 호출하기 전에 LoadRequestedModules가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>이 모듈과 그 의존성의 평가에 대한 프로미스를 반환하며, 성공적인 평가 시 또는 이미 성공적으로 평가된 경우 해결되고, 평가 오류 시 또는 이미 성공적이지 않게 평가된 경우 거부된다. 프로미스가 거부되면 호스트는 프로미스 거부를 처리하고 평가 오류를 다시 던질 것으로 예상된다.</p>
                <p>이 메서드를 호출하기 전에 Link가 성공적으로 완료되어야 한다.</p>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-EvaluateModuleSync" type="abstract operation">
          <h1>
            EvaluateModuleSync (
              _module_: Module Record,
            ): ~unused~를 포함하는 정상 완료 또는 throw completion
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd>호출자가 _module_의 평가가 이미 정착된 프로미스를 반환할 것임을 보장하는 경우 _module_을 동기적으로 평가한다.</dd>
          </dl>

          <emu-alg>
            1. 단언: _module_은 Cyclic Module Record가 아니다.
            1. _promise_를 _module_.Evaluate()로 둔다.
            1. 단언: _promise_.[[PromiseState]]는 ~fulfilled~ 또는 ~rejected~ 중 하나이다.
            1. _promise_.[[PromiseState]]가 ~rejected~이면
              1. _promise_.[[PromiseIsHandled]]이 *false*이면 HostPromiseRejectionTracker(_promise_, *"handle"*)를 수행한다.
              1. _promise_.[[PromiseIsHandled]]을 *true*로 설정한다.
              1. ThrowCompletion(_promise_.[[PromiseResult]])를 반환한다.
            1. ~unused~를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>순환 모듈 레코드</h1>
        <p><dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn>는 Cyclic Module Record 타입의 하위 클래스인 다른 모듈들과 의존성 순환(dependency cycle)에 참여할 수 있는 모듈에 대한 정보를 표현하는 데 사용된다. Cyclic Module Record 타입의 하위 클래스가 아닌 Module Record 는 Source Text Module Record 와의 의존성 순환에 참여해서는 안 된다.</p>
        <p><emu-xref href="#table-module-record-fields"></emu-xref>에 정의된 필드들에 더해, Cyclic Module Record 는 <emu-xref href="#table-cyclic-module-fields"></emu-xref>에 나열된 추가 필드를 가진다.</p>
        <emu-table id="table-cyclic-module-fields" caption="Cyclic Module Record 의 추가 필드">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, 또는 ~evaluated~
              </td>
              <td>
                초기 값은 ~new~. 모듈 생명주기 진행에 따라 순서대로 ~unlinked~, ~linking~, ~linked~, ~evaluating~, 필요 시 ~evaluating-async~, ~evaluated~ 로 전이한다. ~evaluating-async~ 는 이 모듈이 비동기 의존성 완료 후 실행 대기열에 들어 있거나, [[HasTLA]] 필드가 *true* 이어서 실행되었고 최상위 완료를 대기 중임을 나타낸다.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                throw completion 또는 ~empty~
              </td>
              <td>
                평가 중 발생한 예외를 나타내는 throw completion. 예외가 없었거나 [[Status]]가 ~evaluated~ 가 아니면 *undefined*.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                정수 또는 ~empty~
              </td>
              <td>
                Link 및 Evaluate 동안에만 사용하는 보조 필드. [[Status]]가 ~linking~ 또는 ~evaluating~ 이면, 모듈 자신의 DFS(깊이 우선 탐색) 인덱스이거나 동일 SCC(강한 연결 요소) 내 “더 이른” 모듈의 인덱스이다.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                ModuleRequest Record 리스트
              </td>
              <td>
                이 모듈의 import 들에 연관된 ModuleRequest Record 리스트. 소스 텍스트상의 등장 순서를 따른다.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                LoadedModuleRequest Record 리스트
              </td>
              <td>
                이 Record가 표현하는 모듈이 사용한 지정자 문자열을 (상대 import 속성 집합과 함께) 해석된 Module Record 로 매핑하는 맵. ModuleRequestsEqual(_r1_, _r2_)가 *true* 인 서로 다른 Record _r1_, _r2_ 를 두 개 포함하지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                Cyclic Module Record 또는 ~empty~
              </td>
              <td>
                순환의 최초 방문 모듈, 즉 SCC 의 루트 DFS 선조. 순환에 속하지 않는 모듈이면 자기 자신. Evaluate 완료 후 모듈의 [[DFSAncestorIndex]] 는 그 [[CycleRoot]] 의 DFS 인덱스가 된다.
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                이 모듈이 개별적으로 비동기인지 여부(예: top-level await 를 포함하는 Source Text Module Record). 비동기 의존성이 있다는 사실만으로 *true* 는 아니다. 파싱 후 이 필드는 변하지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluationOrder]]
              </td>
              <td>
                ~unset~, 정수, 또는 ~done~
              </td>
              <td>
                초기 ~unset~ 이며 완전 동기 모듈은 계속 ~unset~. 자체가 비동기이거나 비동기 의존성을 가지는 모듈은 <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref> 에 의해 대기 모듈 실행이 큐잉되는 순서를 결정하는 정수로 설정된다. 대기 모듈이 실행되면 ~done~ 으로 설정.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                PromiseCapability Record 또는 ~empty~
              </td>
              <td>
                이 모듈이 어떤 순환의 [[CycleRoot]] 이고 그 순환 내 어떤 모듈에 Evaluate() 가 호출되었다면, 그 전체 평가에 대한 PromiseCapability Record. Evaluate() 추상 메서드가 반환한 Promise 객체 해결에 사용된다. 해당 순환의 의존 모듈들은 최상위 Evaluate() 가 그들에 대해 개시되지 않았다면 ~empty~.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                Cyclic Module Record 리스트
              </td>
              <td>
                이 모듈 또는 그 의존성이 [[HasTLA]] *true* 인 상태로 실행 진행 중이면, 최상위 실행 작업에 대해 이 모듈의 상위 importer 들을 추적한다. 이 부모 모듈들은 이 모듈이 성공적으로 실행 완료하기 전에는 실행을 시작하지 않는다.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                정수 또는 ~empty~
              </td>
              <td>
                비동기 의존성이 하나라도 있으면 남은 비동기 의존 모듈 수를 추적한다. 이 값이 0 이고 실행 오류가 없을 때 모듈이 실행된다.
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 메서드들에 더해 Cyclic Module Record 는 <emu-xref href="#table-cyclic-module-methods"></emu-xref> 에 나열된 추가 메서드를 가진다.</p>
        <emu-table id="table-cyclic-module-methods" caption="Cyclic Module Record 의 추가 추상 메서드">
          <table>
            <thead>
              <tr>
                <th>
                  메서드
                </th>
                <th>
                  목적
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                모든 import 된 바인딩을 해석하고 모듈의 Environment Record 를 초기화하며 실행 컨텍스트를 생성한다.
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule([_promiseCapability_])
              </td>
              <td>
                모듈의 실행 컨텍스트 내에서 코드 평가. 이 모듈이 [[HasTLA]] 가 *true* 이면 PromiseCapability Record 가 인수로 전달되며 메서드는 해당 capability 를 resolve 또는 reject 해야 한다. 이 경우 예외를 throw 하지 말고 필요 시 PromiseCapability Record 를 reject 해야 한다.
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> 는 모듈 그래프 로딩 과정에 대한 정보를 담는 Record 이다. HostLoadImportedModule 호출 이후 로딩을 계속하기 위해 사용된다. 각 GraphLoadingState Record 는 <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref> 에 정의된 필드를 가진다:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record 필드">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                PromiseCapability Record
              </td>
              <td>
                로딩 프로세스 완료 시 resolve 해야 하는 Promise.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                로딩이 아직 성공/오류 어떤 형태로도 완료되지 않았으면 *true*.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                음이 아닌 정수
              </td>
              <td>
                대기 중인 HostLoadImportedModule 호출 수를 추적.
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                Cyclic Module Record 리스트
              </td>
              <td>
                현재 로딩 과정에서 이미 로드된 Cyclic Module Record 리스트(순환 의존 무한 루프 방지).
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (기본값 ~empty~)
              </td>
              <td>
                LoadRequestedModules 호출자에서 HostLoadImportedModule 로 전달할 호스트 정의 데이터.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-cyclic-module-record-module-record-methods">
          <h1>Module Record 추상 메서드 구현</h1>

          <p>다음은 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 Module Record 추상 메서드를 구현하는 Cyclic Module Record 의 구체 메서드이다.</p>

          <emu-clause id="sec-LoadRequestedModules" type="concrete method">
            <h1>
              LoadRequestedModules (
                optional _hostDefined_: anything,
              ): Promise
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>_module_ 의 의존성 그래프 내 모든 Module Record 의 [[LoadedModules]] 를 채운다(주요 작업은 보조 함수 InnerModuleLoading 이 수행). 선택적 _hostDefined_ 는 HostLoadImportedModule 훅에 전달된다.</dd>
            </dl>

            <emu-alg>
              1. _hostDefined_ 가 없으면 _hostDefined_ 를 ~empty~ 로 둔다.
              1. _pc_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
              1. _state_ 를 GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ } 로 둔다.
              1. InnerModuleLoading(_state_, _module_) 를 수행한다.
              1. _pc_.[[Promise]] 를 반환한다.
            </emu-alg>

            <emu-note>
              _hostDefined_ 매개변수는 import 된 모듈을 가져오는 데 필요한 추가 정보를 전달하는 데 사용할 수 있다. 예를 들어 HTML 은 <code>&lt;link rel="preload" as="..."&gt;</code> 태그에 대한 올바른 fetch destination 설정에 사용한다.
              <code>import()</code> 표현식은 _hostDefined_ 를 설정하지 않는다.
            </emu-note>

            <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
              <h1>
                InnerModuleLoading (
                  _state_: GraphLoadingState Record,
                  _module_: Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>LoadRequestedModules 가 _module_ 의 의존성 그래프에 대해 실제 로딩을 재귀적으로 수행할 때 사용된다.</dd>
              </dl>

              <emu-alg>
                1. 단언: _state_.[[IsLoading]] 은 *true*.
                1. _module_ 이 Cyclic Module Record 이고, _module_.[[Status]] 가 ~new~, 그리고 _state_.[[Visited]] 가 _module_ 을 포함하지 않으면
                  1. _module_ 을 _state_.[[Visited]] 에 추가한다.
                  1. _requestedModulesCount_ 를 _module_.[[RequestedModules]] 요소 수로 둔다.
                  1. _state_.[[PendingModulesCount]] 를 _state_.[[PendingModulesCount]] + _requestedModulesCount_ 로 설정.
                  1. _module_.[[RequestedModules]] 의 각 ModuleRequest Record _request_ 에 대해
                    1. AllImportAttributesSupported(_request_.[[Attributes]]) 가 *false* 이면
                      1. _error_ 를 ThrowCompletion(새로 생성된 *SyntaxError* 객체) 로 둔다.
                      1. ContinueModuleLoading(_state_, _error_) 수행.
                    1. Else if _module_.[[LoadedModules]] 가 ModuleRequestsEqual(_record_, _request_) 가 *true* 인 LoadedModuleRequest Record _record_ 를 포함하면
                      1. InnerModuleLoading(_state_, _record_.[[Module]]) 수행.
                    1. Else,
                      1. HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_) 수행.
                      1. 참고: HostLoadImportedModule 은 FinishLoadingImportedModule 를 호출하고 이는 ContinueModuleLoading 을 통해 그래프 로딩 과정에 재진입한다.
                    1. _state_.[[IsLoading]] 이 *false* 이면 ~unused~ 반환.
                1. 단언: _state_.[[PendingModulesCount]] ≥ 1.
                1. _state_.[[PendingModulesCount]] 를 _state_.[[PendingModulesCount]] - 1 로 설정.
                1. _state_.[[PendingModulesCount]] = 0 이면
                  1. _state_.[[IsLoading]] 를 *false* 로 둔다.
                  1. _state_.[[Visited]] 의 각 Cyclic Module Record _loaded_ 에 대해
                    1. _loaded_.[[Status]] 가 ~new~ 이면 ~unlinked~ 로 설정.
                  1. ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
              <h1>
                ContinueModuleLoading (
                  _state_: GraphLoadingState Record,
                  _moduleCompletion_: Module Record 를 담은 정상 completion 또는 throw completion,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>HostLoadImportedModule 호출 후 로딩 과정에 재진입할 때 사용된다.</dd>
              </dl>

              <emu-alg>
                1. _state_.[[IsLoading]] 이 *false* 이면 ~unused~ 반환.
                1. _moduleCompletion_ 이 정상 completion 이면
                  1. InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]) 수행.
                1. Else,
                  1. _state_.[[IsLoading]] 를 *false* 로 둔다.
                  1. ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
            <h1>Link ( ): ~unused~ 를 담은 정상 completion 또는 throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>성공 시 이 모듈의 [[Status]] 를 ~unlinked~ 에서 ~linked~ 로 전이. 실패 시 예외를 던지고 [[Status]] 는 ~unlinked~ 유지. (주요 작업은 보조 함수 InnerModuleLinking 수행)</dd>
            </dl>

            <emu-alg>
              1. 단언: _module_.[[Status]] 는 ~unlinked~, ~linked~, ~evaluating-async~, ~evaluated~ 중 하나.
              1. _stack_ 을 새 빈 리스트로 둔다.
              1. _result_ 를 Completion(InnerModuleLinking(_module_, _stack_, 0)) 로 둔다.
              1. _result_ 가 abrupt completion 이면
                1. _stack_ 의 각 Cyclic Module Record _m_ 에 대해
                  1. 단언: _m_.[[Status]] 는 ~linking~.
                  1. _m_.[[Status]] 를 ~unlinked~ 로 설정.
                1. 단언: _module_.[[Status]] 는 ~unlinked~.
                1. ? _result_ 반환.
              1. 단언: _module_.[[Status]] 는 ~linked~, ~evaluating-async~, 또는 ~evaluated~ 중 하나.
              1. 단언: _stack_ 은 비어 있음.
              1. ~unused~ 반환.
            </emu-alg>

            <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
              <h1>
                InnerModuleLinking (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record 리스트,
                  _index_: 음이 아닌 정수,
                ): 음이 아닌 정수를 담은 정상 completion 또는 throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Link 가 _module_ 및 의존성 그래프의 다른 모듈들에 대해 실제 링크 과정을 수행. _stack_ 과 _index_, 그리고 모듈의 [[DFSAncestorIndex]] 는 DFS 탐색 추적에 사용. 특히 [[DFSAncestorIndex]] 로 SCC 를 발견하여 SCC 내 모든 모듈이 함께 ~linked~ 로 전이되도록 한다.</dd>
              </dl>

              <emu-alg>
                1. _module_ 이 Cyclic Module Record 가 아니면
                  1. ? _module_.Link() 수행.
                  1. _index_ 반환.
                1. _module_.[[Status]] 가 ~linking~, ~linked~, ~evaluating-async~, ~evaluated~ 중 하나이면
                  1. _index_ 반환.
                1. 단언: _module_.[[Status]] 는 ~unlinked~.
                1. _module_.[[Status]] 를 ~linking~ 으로 둔다.
                1. _moduleIndex_ 를 _index_ 로 둔다.
                1. _module_.[[DFSAncestorIndex]] 를 _index_ 로 둔다.
                1. _index_ 를 _index_ + 1 로 설정.
                1. _module_ 을 _stack_ 에 추가.
                1. _module_.[[RequestedModules]] 의 각 ModuleRequest Record _request_ 에 대해
                  1. _requiredModule_ 를 GetImportedModule(_module_, _request_) 로 둔다.
                  1. _index_ 를 ? InnerModuleLinking(_requiredModule_, _stack_, _index_) 로 설정.
                  1. _requiredModule_ 이 Cyclic Module Record 이면
                    1. 단언: _requiredModule_.[[Status]] 는 ~linking~, ~linked~, ~evaluating-async~, ~evaluated~ 중 하나.
                    1. 단언: _requiredModule_.[[Status]] 가 ~linking~ 인 것은 _stack_ 이 _requiredModule_ 을 포함함과 동치.
                    1. _requiredModule_.[[Status]] 가 ~linking~ 이면
                      1. _module_.[[DFSAncestorIndex]] 를 min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]) 로 설정.
                1. ? _module_.InitializeEnvironment() 수행.
                1. 단언: _module_ 은 _stack_ 에 정확히 한 번 등장.
                1. 단언: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
                1. _module_.[[DFSAncestorIndex]] = _moduleIndex_ 이면
                  1. _done_ 을 *false* 로 둔다.
                  1. 반복: _done_ 이 *false* 인 동안
                    1. _requiredModule_ 를 _stack_ 마지막 요소로 둔다.
                    1. 마지막 요소 제거.
                    1. 단언: _requiredModule_ 은 Cyclic Module Record.
                    1. _requiredModule_.[[Status]] 를 ~linked~ 로 설정.
                    1. _requiredModule_ 와 _module_ 이 동일 Module Record 이면 _done_ = *true*.
                1. _index_ 반환.
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduleevaluation" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>Evaluate 는 이 모듈의 [[Status]] 를 ~linked~ 에서 ~evaluating-async~ 또는 ~evaluated~ 로 전이. 동일 SCC 내에서 처음 호출될 때 Promise 를 생성해 모듈 평가 완료 시 resolve. 이 Promise 는 구성 요소 [[CycleRoot]] 의 [[TopLevelCapability]] 에 저장. 이후 SCC 내 어떤 모듈에 대한 Evaluate 호출도 동일 Promise 반환. (주요 작업은 보조 함수 InnerModuleEvaluation 수행)</dd>
            </dl>

            <emu-alg>
              1. 단언: 이 Evaluate 호출은 동일 agent 내 다른 Evaluate 호출과 동시에 일어나지 않음.
              1. 단언: _module_.[[Status]] 는 ~linked~, ~evaluating-async~, ~evaluated~ 중 하나.
              1. _module_.[[Status]] 가 ~evaluating-async~ 또는 ~evaluated~ 이면 _module_ = _module_.[[CycleRoot]].
              1. _module_.[[TopLevelCapability]] 가 ~empty~ 가 아니면
                1. _module_.[[TopLevelCapability]].[[Promise]] 반환.
              1. _stack_ 을 새 빈 리스트로 둔다.
              1. _capability_ 를 ! NewPromiseCapability(%Promise%) 로 둔다.
              1. _module_.[[TopLevelCapability]] 를 _capability_ 로 둔다.
              1. _result_ 를 Completion(InnerModuleEvaluation(_module_, _stack_, 0)) 로 둔다.
              1. _result_ 가 abrupt completion 이면
                1. _stack_ 의 각 Cyclic Module Record _m_ 에 대해
                  1. 단언: _m_.[[Status]] 는 ~evaluating~.
                  1. 단언: _m_.[[AsyncEvaluationOrder]] 는 ~unset~.
                  1. _m_.[[Status]] 를 ~evaluated~ 로.
                  1. _m_.[[EvaluationError]] 를 _result_ 로.
                1. 단언: _module_.[[Status]] 는 ~evaluated~.
                1. 단언: _module_.[[EvaluationError]] 와 _result_ 는 동일 Completion Record.
                1. ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] ») 수행.
              1. Else,
                1. 단언: _module_.[[Status]] 는 ~evaluating-async~ 또는 ~evaluated~.
                1. 단언: _module_.[[EvaluationError]] 는 ~empty~.
                1. _module_.[[Status]] 가 ~evaluated~ 이면
                  1. 참고: _module_ 평가가 동기적으로 완료되었음을 의미.
                  1. 단언: _module_.[[AsyncEvaluationOrder]] 는 ~unset~.
                  1. ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. 단언: _stack_ 은 비어 있음.
              1. _capability_.[[Promise]] 반환.
            </emu-alg>

            <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
              <h1>
                InnerModuleEvaluation (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record 리스트,
                  _index_: 음이 아닌 정수,
                ): 음이 아닌 정수를 담은 정상 completion 또는 throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Evaluate 가 _module_ 및 의존성 그래프의 다른 모듈에 대해 실제 평가 과정을 수행. _stack_, _index_, 그리고 _module_ 의 [[DFSAncestorIndex]] 사용 방식은 InnerModuleLinking 과 동일.</dd>
              </dl>

              <emu-alg>
                1. _module_ 이 Cyclic Module Record 가 아니면
                  1. ? EvaluateModuleSync(_module_) 수행.
                  1. _index_ 반환.
                1. _module_.[[Status]] 가 ~evaluating-async~ 또는 ~evaluated~ 이면
                  1. _module_.[[EvaluationError]] 가 ~empty~ 이면 _index_ 반환.
                  1. 아니면 ? _module_.[[EvaluationError]] 반환.
                1. _module_.[[Status]] 가 ~evaluating~ 이면 _index_ 반환.
                1. 단언: _module_.[[Status]] 는 ~linked~.
                1. _module_.[[Status]] 를 ~evaluating~ 으로.
                1. _moduleIndex_ = _index_.
                1. _module_.[[DFSAncestorIndex]] = _index_.
                1. _module_.[[PendingAsyncDependencies]] = 0.
                1. _index_ = _index_ + 1.
                1. _module_ 을 _stack_ 에 추가.
                1. _module_.[[RequestedModules]] 의 각 ModuleRequest Record _request_ 에 대해
                  1. _requiredModule_ = GetImportedModule(_module_, _request_).
                  1. _index_ = ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                  1. _requiredModule_ 이 Cyclic Module Record 이면
                    1. 단언: _requiredModule_.[[Status]] 는 ~evaluating~, ~evaluating-async~, ~evaluated~ 중 하나.
                    1. 단언: _requiredModule_.[[Status]] 가 ~evaluating~ 인 것은 _stack_ 이 _requiredModule_ 포함과 동치.
                    1. _requiredModule_.[[Status]] 가 ~evaluating~ 이면
                      1. _module_.[[DFSAncestorIndex]] = min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                    1. Else,
                      1. _requiredModule_ = _requiredModule_.[[CycleRoot]].
                      1. 단언: _requiredModule_.[[Status]] 는 ~evaluating-async~ 또는 ~evaluated~.
                      1. _requiredModule_.[[EvaluationError]] 가 ~empty~ 가 아니면 ? _requiredModule_.[[EvaluationError]] 반환.
                    1. _requiredModule_.[[AsyncEvaluationOrder]] 가 정수이면
                      1. _module_.[[PendingAsyncDependencies]] += 1.
                      1. _module_ 을 _requiredModule_.[[AsyncParentModules]] 에 추가.
                1. _module_.[[PendingAsyncDependencies]] > 0 또는 _module_.[[HasTLA]] 가 *true* 이면
                  1. 단언: _module_.[[AsyncEvaluationOrder]] 는 ~unset~.
                  1. _module_.[[AsyncEvaluationOrder]] = IncrementModuleAsyncEvaluationCount().
                  1. _module_.[[PendingAsyncDependencies]] = 0 이면 ExecuteAsyncModule(_module_) 수행.
                1. Else,
                  1. ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta> 수행.
                1. 단언: _module_ 은 _stack_ 에 정확히 한 번 등장.
                1. 단언: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
                1. _module_.[[DFSAncestorIndex]] = _moduleIndex_ 이면
                  1. _done_ = *false*.
                  1. 반복 (_done_ 이 *false* 인 동안)
                    1. _requiredModule_ = _stack_ 마지막 요소.
                    1. 마지막 요소 제거.
                    1. 단언: _requiredModule_ 은 Cyclic Module Record.
                    1. 단언: _requiredModule_.[[AsyncEvaluationOrder]] 는 정수 또는 ~unset~.
                    1. _requiredModule_.[[AsyncEvaluationOrder]] 가 ~unset~ 이면 _requiredModule_.[[Status]] = ~evaluated~.
                    1. 아니면 _requiredModule_.[[Status]] = ~evaluating-async~.
                    1. _requiredModule_ 와 _module_ 이 같으면 _done_ = *true*.
                    1. _requiredModule_.[[CycleRoot]] = _module_.
                1. _index_ 반환.
              </emu-alg>
              <emu-note>
                <p>모듈은 InnerModuleEvaluation 이 순회 중이면 ~evaluating~ 상태. [[HasTLA]] 가 *true* 이거나 비동기 의존성이 있으면 실행 중 ~evaluating-async~, 완료 시 ~evaluated~.</p>
              </emu-note>
              <emu-note>
                <p>비동기 순환의 모듈에 의존하는 모듈은 순환이 ~evaluating~ 이 아닐 때 [[CycleRoot]] 를 통해 루트 실행에 의존하도록 하여 순환 상태를 단일 SCC 로 취급 가능하게 한다.</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-execute-async-module" type="abstract operation">
              <h1>
                ExecuteAsyncModule (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>

              <emu-alg>
                1. 단언: _module_.[[Status]] 는 ~evaluating~ 또는 ~evaluating-async~.
                1. 단언: _module_.[[HasTLA]] 는 *true*.
                1. _capability_ = ! NewPromiseCapability(%Promise%).
                1. _fulfilledClosure_ 를 _module_ 을 캡처하고 호출 시:
                  1. AsyncModuleExecutionFulfilled(_module_) 수행.
                  1. NormalCompletion(*undefined*) 반환.
                1. _onFulfilled_ = CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »).
                1. _rejectedClosure_ 를 (_error_) 매개변수, _module_ 캡처하고 호출 시:
                  1. AsyncModuleExecutionRejected(_module_, _error_) 수행.
                  1. NormalCompletion(*undefined*) 반환.
                1. _onRejected_ = CreateBuiltinFunction(_rejectedClosure_, 0, *""*, « »).
                1. PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_) 수행.
                1. ! <emu-meta effects="user-code">_module_.ExecuteModule</emu-meta>(_capability_) 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-gather-available-ancestors" type="abstract operation">
              <h1>
                GatherAvailableAncestors (
                  _module_: Cyclic Module Record,
                  _execList_: Cyclic Module Record 리스트,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[AsyncParentModules]] 의 각 Cyclic Module Record _m_ 에 대해
                  1. _execList_ 가 _m_ 을 포함하지 않고 _m_.[[CycleRoot]].[[EvaluationError]] 가 ~empty~ 이면
                    1. 단언: _m_.[[Status]] 는 ~evaluating-async~.
                    1. 단언: _m_.[[EvaluationError]] 는 ~empty~.
                    1. 단언: _m_.[[AsyncEvaluationOrder]] 는 정수.
                    1. 단언: _m_.[[PendingAsyncDependencies]] > 0.
                    1. _m_.[[PendingAsyncDependencies]] -= 1.
                    1. _m_.[[PendingAsyncDependencies]] = 0 이면
                      1. _m_ 을 _execList_ 에 추가.
                      1. _m_.[[HasTLA]] 가 *false* 이면 GatherAvailableAncestors(_m_, _execList_) 수행.
                1. ~unused~ 반환.
              </emu-alg>
              <emu-note>
                <p>루트 _module_ 의 비동기 실행이 fulfill 될 때, 이 함수는 동시에 동기 실행 가능한 모듈 목록을 결정하여 _execList_ 에 채운다.</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-fulfilled" type="abstract operation">
              <h1>
                AsyncModuleExecutionFulfilled (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[Status]] 가 ~evaluated~ 이면
                  1. 단언: _module_.[[EvaluationError]] 는 ~empty~ 가 아님.
                  1. ~unused~ 반환.
                1. 단언: _module_.[[Status]] 는 ~evaluating-async~.
                1. 단언: _module_.[[AsyncEvaluationOrder]] 는 정수.
                1. 단언: _module_.[[EvaluationError]] 는 ~empty~.
                1. _module_.[[AsyncEvaluationOrder]] 를 ~done~ 으로.
                1. _module_.[[Status]] 를 ~evaluated~ 로.
                1. _module_.[[TopLevelCapability]] 가 ~empty~ 가 아니면
                  1. 단언: _module_.[[CycleRoot]] 와 _module_ 은 동일.
                  1. ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. _execList_ 를 새 빈 리스트로 둔다.
                1. GatherAvailableAncestors(_module_, _execList_) 수행.
                1. 단언: _execList_ 모든 요소는 [[AsyncEvaluationOrder]] 가 정수, [[PendingAsyncDependencies]] = 0, [[EvaluationError]] = ~empty~.
                1. _sortedExecList_ 를 [[AsyncEvaluationOrder]] 오름차순으로 정렬한 리스트로 둔다.
                1. _sortedExecList_ 의 각 Cyclic Module Record _m_ 에 대해
                  1. _m_.[[Status]] 가 ~evaluated~ 이면
                    1. 단언: _m_.[[EvaluationError]] 는 ~empty~ 아님.
                  1. Else if _m_.[[HasTLA]] 가 *true* 이면
                    1. ExecuteAsyncModule(_m_) 수행.
                  1. Else
                    1. _result_ = <emu-meta effects="user-code">_m_.ExecuteModule()</emu-meta>.
                    1. _result_ 가 abrupt completion 이면
                      1. AsyncModuleExecutionRejected(_m_, _result_.[[Value]]) 수행.
                    1. Else
                      1. _m_.[[AsyncEvaluationOrder]] = ~done~.
                      1. _m_.[[Status]] = ~evaluated~.
                      1. _m_.[[TopLevelCapability]] 가 ~empty~ 아니면
                        1. 단언: _m_.[[CycleRoot]] 와 _m_ 동일.
                        1. ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-rejected" type="abstract operation">
              <h1>
                AsyncModuleExecutionRejected (
                  _module_: Cyclic Module Record,
                  _error_: ECMAScript 언어 값,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. _module_.[[Status]] 가 ~evaluated~ 이면
                  1. 단언: _module_.[[EvaluationError]] 는 ~empty~ 가 아님.
                  1. ~unused~ 반환.
                1. 단언: _module_.[[Status]] 는 ~evaluating-async~.
                1. 단언: _module_.[[AsyncEvaluationOrder]] 는 정수.
                1. 단언: _module_.[[EvaluationError]] 는 ~empty~.
                1. _module_.[[EvaluationError]] = ThrowCompletion(_error_).
                1. _module_.[[Status]] = ~evaluated~.
                1. _module_.[[AsyncEvaluationOrder]] = ~done~.
                1. 참고: _module_.[[EvaluationError]] 가 ~empty~ 가 아닐 때 InnerModuleEvaluation 에서 [[AsyncEvaluationOrder]] 값은 사용되지 않는다.
                1. _module_.[[AsyncParentModules]] 의 각 Cyclic Module Record _m_ 에 대해
                  1. AsyncModuleExecutionRejected(_m_, _error_) 수행.
                1. _module_.[[TopLevelCapability]] 가 ~empty~ 아니면
                  1. 단언: _module_.[[CycleRoot]] 와 _module_ 동일.
                  1. ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ ») 수행.
                1. ~unused~ 반환.
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-example-cyclic-module-record-graphs">
          <h1>순환 모듈 레코드 그래프 예시</h1>

          <p>비규범 섹션: 몇 가지 공통 모듈 그래프의 링크 및 평가 예시와 오류 발생 양상에 초점을 둔다.</p>

          <p>먼저 다음 단순 모듈 그래프를 보자:</p>

          <emu-figure id="figure-module-graph-simple" caption="단순 모듈 그래프">
            <img alt="모듈 A 가 모듈 B 에 의존하고, 모듈 B 가 모듈 C 에 의존하는 그래프" width="60" height="198" src="img/module-graph-simple.svg">
          </emu-figure>

          <p>우선 오류 조건이 없다고 가정. 호스트가 처음 _A_.LoadRequestedModules() 를 호출하면 (가정에 따라) 성공적으로 완료하면서 _B_, _C_ 의 의존성도 재귀적으로 로드(각각 _C_ 와 없음)하고 _A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = ~unlinked~ 로 설정. 이후 _A_.Link() 호출도 성공(가정)하여 세 모듈 모두 ~linked~. 이러한 준비 단계는 언제든 수행 가능. 나중에 호스트가 모듈의 부작용 실행 시점이 되면 _A_.Evaluate() 호출 → 성공적으로 완료, *undefined* 로 resolve 되는 Promise 반환(가정), 먼저 _C_ 그다음 _B_ 를 평가. 이 시점에 각 모듈 [[Status]] 는 ~evaluated~.</p>

          <p>다음으로 링크 오류 사례: _A_.LoadRequestedModules() 성공 후 InnerModuleLinking(_C_) 는 성공하지만 그 뒤 _B_ 에서 실패(예: _C_ 가 제공하지 않는 것을 import). 그러면 원래 _A_.Link() 가 실패하고 _A_ 와 _B_ 의 [[Status]] 는 ~unlinked~ 유지. _C_ 는 ~linked~ 로 전이되어 있음.</p>

          <p>마지막으로 링크 성공 후 평가 오류: InnerModuleEvaluation(_C_) 는 성공하지만 그 뒤 _B_ 가 실패(예: _B_ 코드에서 예외). 원래 _A_.Evaluate() 는 reject 된 Promise 반환으로 실패. 예외는 _A_, _B_ 의 [[EvaluationError]] 에 기록되고 두 모듈 [[Status]] 는 ~evaluated~. _C_ 도 ~evaluated~ 되지만 예외 없이 성공 평가. 예외 저장을 통해 이후 Evaluate() 재호출 시 동일 예외 일관 제공. (호스트는 Cyclic Module Record 재사용 의무 없음; 예외 객체 노출 의무도 없음. 명세는 가능성만 제공.)</p>

          <p>이제 다른 오류 조건 유형:</p>

          <emu-figure id="figure-module-graph-missing" caption="해결 불가 모듈을 가진 그래프">
            <img alt="모듈 A 가 ??? 로 표시된 존재하지 않는 모듈에 의존" width="60" height="121" src="img/module-graph-missing.svg">
          </emu-figure>

          <p>이 시나리오에서 _A_ 는 다른 모듈을 선언적 의존하지만 해당 Module Record 가 없음 (HostLoadImportedModule 가 FinishLoadingImportedModule 호출 시 예외 전달). 리소스 부재, 혹은 존재하지만 ParseModule 이 오류 반환 등 다양한 이유. 호스트는 실패 원인을 FinishLoadingImportedModule 에 전달하는 completion 을 통해 노출 선택 가능. 이 예외로 로딩 실패 → _A_.[[Status]] 는 ~new~ 유지.</p>

          <p>로딩 / 링크 / 평가 오류 차이는 다음 특징 때문:</p>
          <ul>
            <li>평가는 부작용이 있을 수 있어 한 번만 수행해야 하므로(비성공 포함) 이미 수행 여부 기억 필요. (오류 시에도 이후 Evaluate() 마다 새로운 예외 합성 대신 기존 예외 기억이 합리적)</li>
            <li>링크는 부작용이 없으므로 실패해도 나중에 재시도 가능</li>
            <li>로딩은 호스트와 긴밀히 상호작용하므로 일부 호스트는 실패한 로드 재시도 허용이 바람직(예: 일시적 네트워크 문제)</li>
          </ul>

          <p>이제 순환이 있는 그래프:</p>

          <emu-figure id="figure-module-graph-cycle" caption="순환 모듈 그래프">
            <img alt="모듈 A 가 B, C 에 의존하고 B 가 A 에도 의존" width="181" height="121" src="img/module-graph-cycle.svg">
          </emu-figure>

          <p>엔트리 포인트가 _A_ 라 가정하고 호스트가 _A_.LoadRequestedModules() 호출 → _A_ 에 대해 InnerModuleLoading 수행. 이는 _B_, _C_ 에 대해 InnerModuleLoading 호출. 순환 때문에 다시 _A_ 에 대해 InnerModuleLoading 트리거되지만 이미 로딩 트리거 되었으므로 no-op. 그래프 모든 모듈 로딩 성공 시 [[Status]] 는 동시에 ~new~ → ~unlinked~.</p>

          <p>그 후 _A_.Link() → _A_ 에 대해 InnerModuleLinking → _B_ → 순환으로 다시 _A_ (이미 ~linking~ 이므로 no-op). _B_ 는 여전히 ~linking~ 상태에서 제어가 _A_ 로 돌아와 _C_ 에 대해 InnerModuleLinking. _C_ 가 ~linked~ 후 _A_, _B_ 가 함께 ~linking~ → ~linked~ 전이; 이는 SCC 단위 동시 전이를 설계한 것. DFS 로 그래프 순회하므로 가능.</p>

          <p>성공 사례에서 평가 단계도 유사.</p>

          <p>_A_ 에 링크 오류(예: _C_ 에 존재하지 않는 바인딩 import) 인 경우 위 단계 진행 중 두 번째 InnerModuleLinking(_A_) 조기 반환 포함. 하지만 원래 InnerModuleLinking(_A_) 로 되돌아왔을 때 InitializeEnvironment 중 (_C_.ResolveExport() 직후) 실패, *SyntaxError* 전파 → _A_.Link 에서 현재 _stack_ 에 있는(~linking~) 모듈 상태를 재설정. 따라서 _A_, _B_ 는 ~unlinked~, _C_ 는 ~linked~ 유지.</p>

          <p>유사하게 _A_ 평가 오류(예: 코드 예외) 인 경우에도 평가 시퀀스는 비슷. 두 번째 InnerModuleEvaluation(_A_) 조기 반환 후 원래 InnerModuleEvaluation(_A_) 로 돌아와 실패. 예외가 _A_.Evaluate() 로 전파되어 현재 _stack_ (여전히 ~evaluating~) 및 [[AsyncParentModules]] 체인을 따라(상위 top-level `await` 를 가진 모듈 경유) AsyncModuleExecutionRejected 알고리즘으로 전파. 결과로 _A_, _B_ 는 ~evaluated~ & 예외 기록, _C_ 는 예외 없이 ~evaluated~.</p>

          <p>마지막으로 모든 모듈이 비동기 완료하는 순환 그래프:</p>
          <emu-figure id="figure-module-graph-cycle-async" caption="비동기 순환 모듈 그래프">
            <img alt="모듈 A 가 B, C 에 의존, B 는 D, C 는 D, E 에 의존, D 는 A 에 의존" width="241" height="211" src="img/module-graph-cycle-async.svg">
          </emu-figure>
          <p>로딩과 링크는 이전과 같고 모두 [[Status]] = ~linked~.</p>

          <p>_A_.Evaluate() 는 _A_, _B_, _D_ 에 대해 InnerModuleEvaluation 수행 → 모두 ~evaluating~. 다시 _A_ 호출은 no-op. 이때 _D_.[[PendingAsyncDependencies]] = 0 → ExecuteAsyncModule(_D_) 호출 → _D_.ExecuteModule 새 PromiseCapability. _B_ 로 unwind: _B_.[[PendingAsyncDependencies]] = 1, [[AsyncEvaluationOrder]] = 1. 다시 _A_ 로: _A_.[[PendingAsyncDependencies]] = 1. 다음 _A_ 의 의존 반복에서 _C_ 평가 → _D_(no-op), _E_. _E_ 는 의존 없고 순환 아님 → ExecuteAsyncModule(_E_) 즉시 호출 & stack 에서 제거. 다시 _C_ 로 unwind: _C_.[[AsyncEvaluationOrder]] = 3. _A_ 의 의존 루프 종료 후 _A_.[[AsyncEvaluationOrder]] = 4, SCC 전체 stack 제거하며 모두 ~evaluating-async~. 이 시점 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-1"></emu-xref> 참조.</p>

          <emu-table id="table-module-graph-cycle-async-fields-1" caption="초기 Evaluate() 후 모듈 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
                <td>3</td>
                <td>0</td>
                <td>2</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>2 (_B_, _C_)</td>
                <td>1 (_D_)</td>
                <td>2 (_D_, _E_)</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>_E_ 가 먼저 실행 완료한다고 가정. AsyncModuleExecutionFulfilled 호출 → _E_.[[Status]] = ~evaluated~, _C_.[[PendingAsyncDependencies]] = 1. 업데이트 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-2"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-2" caption="_E_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_C_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_D_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>다음으로 _D_ 완료. AsyncModuleExecutionFulfilled 호출 → _D_.[[Status]] = ~evaluated~. 실행 가능한 조상은 [[AsyncEvaluationOrder]] 1 의 _B_, 3 의 _C_ → 순서상 _B_ 먼저 처리: _B_.[[PendingAsyncDependencies]] = 0 → ExecuteAsyncModule(_B_) → 실행 시작. _C_.[[PendingAsyncDependencies]] 도 0 → _C_ 실행 시작( _B_ 에 await 있다면 병렬 가능). 업데이트 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-3"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-3" caption="_D_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>1</td>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>_C_ 가 다음으로 완료. AsyncModuleExecutionFulfilled → _C_.[[Status]] = ~evaluated~, _A_.[[PendingAsyncDependencies]] = 1. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-4"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-4" caption="_C_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>그 후 _B_ 완료. AsyncModuleExecutionFulfilled → _B_.[[Status]] = ~evaluated~, _A_.[[PendingAsyncDependencies]] = 0 → ExecuteAsyncModule 호출 → 실행 시작. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-5"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-5" caption="_B_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>마지막으로 _A_ 완료. AsyncModuleExecutionFulfilled → _A_.[[Status]] = ~evaluated~, _A_.[[TopLevelCapability]] 의 Promise(resolve) → 그래프 처리 종료. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-6"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-6" caption="_A_ 실행 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>대안: _C_ 가 _B_ 완료 전 오류로 실패. AsyncModuleExecutionRejected 호출 → _C_.[[Status]] = ~evaluated~, _C_.[[EvaluationError]] = 오류. 그런 다음 AsyncParentModules 전파. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-7"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-7" caption="_C_ 오류 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>~empty~</td>
                <td>_C_ 의 평가 오류</td>
              </tr>
            </table>
          </emu-table>

          <p>_C_ 가 _A_ 에 대해 AsyncModuleExecutionRejected 호출하므로 _A_ 는 동일 오류로 reject. _A_.[[Status]] = ~evaluated~. _A_.[[TopLevelCapability]] Promise 는 reject. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-8"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-8" caption="_A_ 가 reject 된 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>

                <td>_C_ 의 Evaluation Error</td>
              </tr>
            </table>
          </emu-table>

          <p>이후 _B_ 가 오류 없이 완료. AsyncModuleExecutionFulfilled → _B_.[[Status]] = ~evaluated~. GatherAvailableAncestors(_B_) 호출. 그러나 _A_.[[CycleRoot]] = _A_, 그리고 평가 오류 존재 → _sortedExecList_ 에 추가되지 않고 추가 처리 없이 반환. 이후 _B_ 의 importer 는 cycle root _A_ 의 [[EvaluationError]] 를 통해 reject 를 해석. 필드는 <emu-xref href="#table-module-graph-cycle-async-fields-9"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-9" caption="오류 그래프에서 _B_ 완료 후 필드">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">필드</span>
                    <div class="slash">
                    </div>
                    <span class="row">모듈</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>_C_ 의 Evaluation Error</td>
                <td>~empty~</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>소스 텍스트 모듈 레코드</h1>

        <p><dfn id="sourctextmodule-record" variants="Source Text Module Records">Source Text Module Record</dfn> 는 |Module| 목표 기호로 파싱된 ECMAScript 소스 텍스트 (<emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) 로 정의된 모듈 정보를 나타내는 데 사용된다. 필드는 모듈이 import/export 하는 이름에 대한 요약 정보를 포함하고, 구체 메서드는 이 요약을 사용해 링크 및 평가를 수행한다.</p>

        <p>Source Text Module Record 는 추상 Module Record 타입의 다른 하위 클래스들과 같은 그래프에 존재할 수 있으며 Cyclic Module Record 타입의 다른 하위 클래스들과 순환에 참여할 수 있다.</p>

        <p><emu-xref href="#table-cyclic-module-fields"></emu-xref> 에 정의된 필드들 외에, Source Text Module Record 는 <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref> 에 있는 추가 필드를 가진다. 각 필드는 ParseModule 에서 초기화된다.</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="Source Text Module Record 의 추가 필드" oldids="table-38">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                Parse Node
              </td>
              <td>
                |Module| 을 목표 기호로 사용해 이 모듈 소스 텍스트를 파싱한 결과.
              </td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                ECMAScript 코드 실행 컨텍스트 또는 ~empty~
              </td>
              <td>
                이 모듈에 연결된 실행 컨텍스트. 환경 초기화 전까지 ~empty~.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                Object 또는 ~empty~
              </td>
              <td>
                `import.meta` 메타 프로퍼티로 노출되는 객체. ECMAScript 코드에서 접근 전까지 ~empty~.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                ImportEntry Record 리스트
              </td>
              <td>
                이 모듈 코드에서 도출된 ImportEntry 리스트.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                ExportEntry Record 리스트
              </td>
              <td>
                모듈 내 선언에 해당하는 export 에 대한 ExportEntry 리스트.
              </td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                ExportEntry Record 리스트
              </td>
              <td>
                모듈 내 재export(import 재export 또는 `export * as namespace`) 에 해당하는 ExportEntry 리스트.
              </td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                ExportEntry Record 리스트
              </td>
              <td>
                모듈 내 `export *` 선언(단, `export * as namespace` 제외)에 해당하는 ExportEntry 리스트.
              </td>
            </tr>
          </table>
        </emu-table>
        <p><dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> 는 단일 선언적 import 에 대한 정보를 요약한 Record. 각 ImportEntry Record 는 <emu-xref href="#table-importentry-record-fields"></emu-xref> 필드를 가진다:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record 필드" oldids="table-39">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record
              </td>
              <td>
                |ImportDeclaration| 의 |ModuleSpecifier| 및 import 속성.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String 또는 ~namespace-object~
              </td>
              <td>
                [[ModuleRequest]] 로 식별된 모듈이 해당 바인딩을 export 하는 이름. ~namespace-object~ 는 대상 모듈 네임스페이스 객체 import 요청을 의미.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String
              </td>
              <td>
                import 하는 모듈 내부에서 값에 접근할 때 사용하는 로컬 이름.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> 는 구문 import 형태를 표현하는 ImportEntry 필드 예시:</p>
          <emu-table id="table-import-forms-mapping-to-importentry-records" caption="Import 문 형태와 ImportEntry 매핑" informative oldids="table-40">
            <table>
              <thead>
                <tr>
                  <th>
                    Import 문 형태
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~namespace-object~
                </td>
                <td>
                  *"ns"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  ImportEntry Record 생성 안 됨.
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p><dfn id="exportentry-record" variants="ExportEntry Records">ExportEntry Record</dfn> 는 단일 선언적 export 정보를 요약한 Record. 각 ExportEntry Record 는 <emu-xref href="#table-exportentry-records"></emu-xref> 필드 보유:</p>
        <emu-table id="table-exportentry-records" caption="ExportEntry Record 필드" oldids="table-41">
          <table>
            <thead>
              <tr>
                <th>
                  필드 이름
                </th>
                <th>
                  값 타입
                </th>
                <th>
                  의미
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                String 또는 *null*
              </td>
              <td>
                모듈이 이 바인딩을 export 하는 이름.
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record 또는 *null*
              </td>
              <td>
                |ExportDeclaration| 의 |ModuleSpecifier| 및 import 속성을 나타내는 ModuleRequest Record. |ModuleSpecifier| 없으면 *null*.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String, *null*, ~all~, 또는 ~all-but-default~
              </td>
              <td>
                [[ModuleRequest]] 로 식별된 모듈이 해당 바인딩을 export 하는 이름. |ModuleSpecifier| 없으면 *null*. `export * as ns from "mod"` 는 ~all~, `export * from "mod"` 는 ~all-but-default~ 사용.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String 또는 *null*
              </td>
              <td>
                importer 모듈 내부에서 export 값 접근 시 사용 로컬 이름. 로컬 접근 불가면 *null*.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-export-forms-mapping-to-exportentry-records"></emu-xref> 는 구문 export 형태를 표현하는 ExportEntry 필드 예시:</p>
          <emu-table id="table-export-forms-mapping-to-exportentry-records" caption="Export 문 형태와 ExportEntry 매핑" informative oldids="table-42">
            <table>
              <thead>
                <tr>
                  <th>
                    Export 문 형태
                  </th>
                  <th>
                    [[ExportName]]
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f() {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"f"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function () {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all-but-default~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * as ns from "mod";`
                </td>
                <td>
                  *"ns"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all~
                </td>
                <td>
                  *null*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>다음 정의는 Source Text Module Record 에 필요한 구체 메서드와 기타 추상 연산을 명세한다.</p>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript 소스 텍스트,
              _realm_: Realm Record,
              _hostDefined_: anything,
            ): Source Text Module Record 또는 *SyntaxError* 객체 비어있지 않은 리스트
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_sourceText_ 를 |Module| 로 파싱한 결과에 기반하여 Source Text Module Record 생성.</dd>
          </dl>
          <emu-alg>
            1. _body_ = ParseText(_sourceText_, |Module|).
            1. _body_ 가 오류 리스트이면 _body_ 반환.
            1. _requestedModules_ = ModuleRequests(_body_).
            1. _importEntries_ = ImportEntries(_body_).
            1. _importedBoundNames_ = ImportedLocalNames(_importEntries_).
            1. _indirectExportEntries_ = 새 빈 리스트.
            1. _localExportEntries_ = 새 빈 리스트.
            1. _starExportEntries_ = 새 빈 리스트.
            1. _exportEntries_ = ExportEntries(_body_).
            1. 각 ExportEntry Record _ee_ ∈ _exportEntries_ 에 대해
              1. _ee_.[[ModuleRequest]] 가 *null* 이면
                1. _importedBoundNames_ 가 _ee_.[[LocalName]] 포함하지 않으면
                  1. _ee_ 를 _localExportEntries_ 에 추가.
                1. Else
                  1. _ie_ = [[LocalName]] 가 _ee_.[[LocalName]] 인 _importEntries_ 요소.
                  1. _ie_.[[ImportName]] 가 ~namespace-object~ 이면
                    1. 참고: import 된 모듈 네임스페이스 객체 재export.
                    1. _ee_ 를 _localExportEntries_ 에 추가.
                  1. Else
                    1. 참고: 단일 이름 재export.
                    1. ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } 를 _indirectExportEntries_ 에 추가.
              1. Else if _ee_.[[ImportName]] 가 ~all-but-default~ 이면
                1. 단언: _ee_.[[ExportName]] 는 *null*.
                1. _ee_ 를 _starExportEntries_ 에 추가.
              1. Else
                1. _ee_ 를 _indirectExportEntries_ 에 추가.
            1. _async_ = _body_ Contains `await`.
            1. Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSAncestorIndex]]: ~empty~ } 반환.
          </emu-alg>
          <emu-note>
            <p>구현은 ParseModule 평가 이전에 소스 텍스트를 파싱하고 Early Error 분석을 수행할 수 있으나 오류 보고는 실제 ParseModule 수행 시점까지 지연해야 한다.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-module-record-methods">
          <h1>Module Record 추상 메서드 구현</h1>

          <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 Module Record 추상 메서드 구현을 위한 Source Text Module Record 의 구체 메서드.</p>

          <emu-clause id="sec-getexportednames" type="concrete method">
            <h1>
              GetExportedNames (
                optional _exportStarSet_: Source Text Module Record 리스트,
              ): 문자열 리스트
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>
            <emu-alg>
              1. 단언: _module_.[[Status]] 는 ~new~ 아님.
              1. _exportStarSet_ 없으면 새 빈 리스트로 설정.
              1. _exportStarSet_ 이 _module_ 포함하면
                1. 단언: `export *` 순환의 시작점 도달.
                1. 새 빈 리스트 반환.
              1. _module_ 을 _exportStarSet_ 에 추가.
              1. _exportedNames_ = 새 빈 리스트.
              1. _module_.[[LocalExportEntries]] 각 ExportEntry Record _e_ 에 대해
                1. 단언: _module_ 이 직접 바인딩 제공.
                1. 단언: _e_.[[ExportName]] 는 *null* 아님.
                1. _e_.[[ExportName]] 를 _exportedNames_ 에 추가.
              1. _module_.[[IndirectExportEntries]] 각 _e_ 에 대해
                1. 단언: _module_ 이 특정 바인딩 import 후 재export.
                1. 단언: _e_.[[ExportName]] 는 *null* 아님.
                1. _e_.[[ExportName]] 을 _exportedNames_ 에 추가.
              1. _module_.[[StarExportEntries]] 각 _e_ 에 대해
                1. 단언: _e_.[[ModuleRequest]] 는 *null* 아님.
                1. _requestedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. _starNames_ = _requestedModule_.GetExportedNames(_exportStarSet_).
                1. 각 _n_ ∈ _starNames_ 에 대해
                  1. _n_ ≠ *"default"* 이면
                    1. _exportedNames_ 가 _n_ 포함하지 않으면 추가.
              1. _exportedNames_ 반환.
            </emu-alg>
            <emu-note>
              <p>GetExportedNames 는 모호한 star export 바인딩 이름을 필터링하거나 예외를 던지지 않는다.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: String,
                optional _resolveSet_: Record 리스트 (필드 [[Module]]: Module Record, [[ExportName]]: String),
              ): ResolvedBinding Record, *null*, 또는 ~ambiguous~
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>

              <dt>description</dt>
              <dd>
                <p>ResolveExport 는 import 된 바인딩을 실제 정의 모듈과 로컬 바인딩 이름으로 해석. 정의 모듈은 자신 또는 import 된 다른 모듈일 수 있음. _resolveSet_ 은 순환 import/export 경로 탐지를 위해 사용. 동일 Module Record 와 _exportName_ 쌍이 이미 _resolveSet_ 에 있으면 순환. 재귀 호출 전 { _module_, _exportName_ } 쌍을 추가.</p>
                <p>정의 모듈 발견 시 ResolvedBinding Record { [[Module]], [[BindingName]] } 반환(네임스페이스 export 만 있는 경우 [[BindingName]] = ~namespace~). 정의 없거나 순환이면 *null*, 모호하면 ~ambiguous~.</p>
              </dd>
            </dl>

            <emu-alg>
              1. 단언: _module_.[[Status]] 는 ~new~ 아님.
              1. _resolveSet_ 없으면 새 빈 리스트.
              1. _resolveSet_ 의 각 Record { [[Module]], [[ExportName]] } _r_ 에 대해
                1. _module_ 과 _r_.[[Module]] 동일이고 _exportName_ = _r_.[[ExportName]] 이면
                  1. 단언: 순환 import 요청.
                  1. *null* 반환.
              1. Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } 를 _resolveSet_ 에 추가.
              1. _module_.[[LocalExportEntries]] 각 ExportEntry Record _e_ 에 대해
                1. _e_.[[ExportName]] = _exportName_ 이면
                  1. 단언: 직접 바인딩 제공.
                  1. ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] } 반환.
              1. _module_.[[IndirectExportEntries]] 각 _e_ 에 대해
                1. _e_.[[ExportName]] = _exportName_ 이면
                  1. 단언: _e_.[[ModuleRequest]] ≠ *null*.
                  1. _importedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                  1. _e_.[[ImportName]] 가 ~all~ 이면
                    1. 단언: 직접 바인딩 제공 안 함.
                    1. ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ } 반환.
                  1. Else
                    1. 단언: 특정 바인딩 import 후 재export.
                    1. 단언: _e_.[[ImportName]] 는 String.
                    1. _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_) 반환.
              1. _exportName_ = *"default"* 이면
                1. 단언: 명시적 `default` export 없음.
                1. *null* 반환.
                1. NOTE: `export * from "mod"` 는 `default` export 제공 불가.
              1. _starResolution_ = *null*.
              1. _module_.[[StarExportEntries]] 각 _e_ 에 대해
                1. 단언: _e_.[[ModuleRequest]] ≠ *null*.
                1. _importedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. _resolution_ = _importedModule_.ResolveExport(_exportName_, _resolveSet_).
                1. _resolution_ = ~ambiguous~ 이면 ~ambiguous~ 반환.
                1. _resolution_ ≠ *null* 이면
                  1. 단언: _resolution_ 은 ResolvedBinding Record.
                  1. _starResolution_ 이 *null* 이면
                    1. _starResolution_ = _resolution_.
                  1. Else
                    1. 단언: 요청 이름을 포함하는 `*` import 가 하나 이상.
                    1. _resolution_.[[Module]] ≠ _starResolution_.[[Module]] 이면 ~ambiguous~ 반환.
                    1. _resolution_.[[BindingName]] ≠ _starResolution_.[[BindingName]] 이고 둘 중 하나가 ~namespace~ 이면 ~ambiguous~.
                    1. 두 [[BindingName]] 이 모두 String 이고 다르면 ~ambiguous~.
              1. _starResolution_ 반환.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-cyclic-module-record-methods">
          <h1>Cyclic Module Record 추상 메서드 구현</h1>

          <p><emu-xref href="#table-cyclic-module-methods"></emu-xref> 에 정의된 Cyclic Module Record 추상 메서드를 구현하는 Source Text Module Record 의 구체 메서드.</p>

          <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
            <h1>InitializeEnvironment ( ): ~unused~ 를 담은 정상 completion 또는 throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[IndirectExportEntries]] 의 각 ExportEntry Record _e_ 에 대해
                1. 단언: _e_.[[ExportName]] ≠ *null*.
                1. _resolution_ = _module_.ResolveExport(_e_.[[ExportName]]).
                1. _resolution_ 이 *null* 또는 ~ambiguous~ 이면 *SyntaxError* throw.
                1. 단언: _resolution_ 은 ResolvedBinding Record.
              1. 단언: _module_ 의 모든 named export 는 해석 가능.
              1. _realm_ = _module_.[[Realm]].
              1. 단언: _realm_ ≠ *undefined*.
              1. _env_ = NewModuleEnvironment(_realm_.[[GlobalEnv]]).
              1. _module_.[[Environment]] = _env_.
              1. _module_.[[ImportEntries]] 각 ImportEntry Record _in_ 에 대해
                1. _importedModule_ = GetImportedModule(_module_, _in_.[[ModuleRequest]]).
                1. _in_.[[ImportName]] 가 ~namespace-object~ 이면
                  1. _namespace_ = GetModuleNamespace(_importedModule_).
                  1. ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*) 수행.
                  1. ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_) 수행.
                1. Else
                  1. _resolution_ = _importedModule_.ResolveExport(_in_.[[ImportName]]).
                  1. _resolution_ 이 *null* 또는 ~ambiguous~ 이면 *SyntaxError* throw.
                  1. _resolution_.[[BindingName]] = ~namespace~ 이면
                    1. _namespace_ = GetModuleNamespace(_resolution_.[[Module]]).
                    1. ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                    1. ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                  1. Else
                    1. CreateImportBinding(_env_, _in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]) 수행.
              1. _moduleContext_ = 새 ECMAScript 코드 실행 컨텍스트.
              1. _moduleContext_.Function = *null*.
              1. 단언: _module_.[[Realm]] ≠ *undefined*.
              1. _moduleContext_.Realm = _module_.[[Realm]].
              1. _moduleContext_.ScriptOrModule = _module_.
              1. _moduleContext_.VariableEnvironment = _module_.[[Environment]].
              1. _moduleContext_.LexicalEnvironment = _module_.[[Environment]].
              1. _moduleContext_.PrivateEnvironment = *null*.
              1. _module_.[[Context]] = _moduleContext_.
              1. _moduleContext_ 를 실행 컨텍스트 스택에 push; 실행 중 컨텍스트.
              1. _code_ = _module_.[[ECMAScriptCode]].
              1. _varDeclarations_ = VarScopedDeclarations(_code_).
              1. _declaredVarNames_ = 새 빈 리스트.
              1. 각 _d_ ∈ _varDeclarations_ 에 대해
                1. BoundNames(_d_) 의 각 _dn_ 에 대해
                  1. _declaredVarNames_ 가 _dn_ 포함하지 않으면
                    1. ! _env_.CreateMutableBinding(_dn_, *false*).
                    1. ! _env_.InitializeBinding(_dn_, *undefined*).
                    1. _dn_ 을 _declaredVarNames_ 에 추가.
              1. _lexDeclarations_ = LexicallyScopedDeclarations(_code_).
              1. _privateEnv_ = *null*.
              1. 각 _d_ ∈ _lexDeclarations_ 에 대해
                1. BoundNames(_d_) 의 각 _dn_ 에 대해
                  1. IsConstantDeclaration(_d_) 가 *true* 이면
                    1. ! _env_.CreateImmutableBinding(_dn_, *true*).
                  1. Else
                    1. ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. _d_ 가 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration| 중 하나이면
                    1. _fo_ = InstantiateFunctionObject(_d_, _env_, _privateEnv_).
                    1. ! _env_.InitializeBinding(_dn_, _fo_).
              1. _moduleContext_ 를 실행 컨텍스트 스택에서 제거.
              1. ~unused~ 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
            <h1>
              ExecuteModule (
                optional _capability_: PromiseCapability Record,
              ): ~unused~ 를 담은 정상 completion 또는 throw completion
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _moduleContext_ = 새 ECMAScript 코드 실행 컨텍스트.
              1. _moduleContext_.Function = *null*.
              1. _moduleContext_.Realm = _module_.[[Realm]].
              1. _moduleContext_.ScriptOrModule = _module_.
              1. 단언: 모듈이 링크되었고 환경 선언 인스턴스화 완료.
              1. _moduleContext_.VariableEnvironment = _module_.[[Environment]].
              1. _moduleContext_.LexicalEnvironment = _module_.[[Environment]].
              1. 실행 중 컨텍스트 suspend.
              1. _module_.[[HasTLA]] = *false* 이면
                1. 단언: _capability_ 없음.
                1. _moduleContext_ push → 실행 중 컨텍스트.
                1. _result_ = Completion(Evaluation(_module_.[[ECMAScriptCode]]) ).
                1. _moduleContext_ suspend 및 스택에서 제거.
                1. 최상위 컨텍스트 resume.
                1. _result_ 가 abrupt completion 이면
                  1. ? _result_ 반환.
              1. Else
                1. 단언: _capability_ 는 PromiseCapability Record.
                1. AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_) 수행.
              1. ~unused~ 반환.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-synthetic-module-records">
        <h1>합성(Synthetic) 모듈 레코드</h1>

        <p><dfn variants="Synthetic Module Records">Synthetic Module Record</dfn> 는 명세가 정의하는 모듈 정보를 나타내며 export 이름은 생성 시 정적으로 정의되고 값은 SetSyntheticModuleExport 로 시간에 따라 변경될 수 있다. import 또는 의존성이 없다.</p>

        <emu-note>Synthetic Module Record 는 JSON 모듈, CSS 모듈 등 다양한 모듈 타입 정의에 사용 가능.</emu-note>

        <p><emu-xref href="#table-module-record-fields"></emu-xref> 의 필드 외에 Synthetic Module Record 는 <emu-xref href="#table-synthetic-module-record-fields"></emu-xref> 의 추가 필드를 가진다.</p>

        <emu-table id="table-synthetic-module-record-fields" caption="Synthetic Module Record 의 추가 필드">
          <table>
            <thead>
              <tr>
                <th>필드 이름</th>
                <th>값 타입</th>
                <th>의미</th>
              </tr>
            </thead>
            <tr>
              <td>[[ExportNames]]</td>
              <td>문자열 리스트</td>
              <td>모듈의 export 이름. 중복 없음.</td>
            </tr>
            <tr>
              <td>[[EvaluationSteps]]</td>
              <td>Abstract Closure</td>
              <td>모듈 평가 시 수행할 초기화 로직 (Synthetic Module Record 를 단일 인수). [[ExportNames]] 수정 금지. abrupt completion 반환 가능.</td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-create-default-export-synthetic-module" type="abstract operation">
          <h1>
            CreateDefaultExportSyntheticModule (
              _defaultExport_: ECMAScript 언어 값,
            ): Synthetic Module Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_defaultExport_ 를 기본 export 로 하는 Synthetic Module Record 생성.</dd>
          </dl>
          <emu-alg>
            1. _realm_ = 현재 Realm Record.
            1. _setDefaultExport_ = (_module_) 매개변수, _defaultExport_ 캡처하는 Abstract Closure:
              1. SetSyntheticModuleExport(_module_, *"default"*, _defaultExport_) 수행.
              1. NormalCompletion(~unused~) 반환.
            1. Synthetic Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[HostDefined]]: *undefined*, [[ExportNames]]: « *"default"* », [[EvaluationSteps]]: _setDefaultExport_ } 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parse-json-module" type="abstract operation">
          <h1>
            ParseJSONModule (
              _source_: String,
            ): Synthetic Module Record 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. _json_ = ? ParseJSON(_source_).
            1. CreateDefaultExportSyntheticModule(_json_) 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-setsyntheticmoduleexport" type="abstract operation">
          <h1>
            SetSyntheticModuleExport (
              _module_: Synthetic Module Record,
              _exportName_: String,
              _exportValue_: ECMAScript 언어 값,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Synthetic Module Record 의 기존 export 값 설정/변경.</dd>
          </dl>

          <emu-alg>
            1. 단언: _module_.[[ExportNames]] 가 _exportName_ 포함.
            1. _envRec_ = _module_.[[Environment]].
            1. 단언: _envRec_ ≠ ~empty~.
            1. _envRec_.SetMutableBinding(_exportName_, _exportValue_, *true*) 수행.
            1. ~unused~ 반환.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-smr-module-record-methods">
          <h1>Module Record 추상 메서드 구현</h1>

          <p><emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 에 정의된 Module Record 추상 메서드를 구현하는 Synthetic Module Record 의 구체 메서드.</p>

          <emu-clause id="sec-smr-LoadRequestedModules" type="concrete method">
            <h1>LoadRequestedModules ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. ! PromiseResolve(%Promise%, *undefined*) 반환.
            </emu-alg>

            <emu-note>
              Synthetic Module Record 는 의존성이 없다.
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-smr-getexportednames" type="concrete method">
            <h1>GetExportedNames ( ): 문자열 리스트</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[ExportNames]] 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: String,
              ): ResolvedBinding Record 또는 *null*
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _module_.[[ExportNames]] 가 _exportName_ 포함하지 않으면 *null* 반환.
              1. ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _exportName_ } 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Link" type="concrete method">
            <h1>Link ( ): ~unused~ 를 담은 정상 completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _realm_ = _module_.[[Realm]].
              1. _env_ = NewModuleEnvironment(_realm_.[[GlobalEnv]]).
              1. _module_.[[Environment]] = _env_.
              1. _module_.[[ExportNames]] 의 각 String _exportName_ 에 대해
                1. ! _env_.CreateMutableBinding(_exportName_, *false*).
                1. ! _env_.InitializeBinding(_exportName_, *undefined*).
              1. NormalCompletion(~unused~) 반환.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Evaluate" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. _moduleContext_ = 새 ECMAScript 코드 실행 컨텍스트.
              1. _moduleContext_.Function = *null*.
              1. _moduleContext_.Realm = _module_.[[Realm]].
              1. _moduleContext_.ScriptOrModule = _module_.
              1. _moduleContext_.VariableEnvironment = _module_.[[Environment]].
              1. _moduleContext_.LexicalEnvironment = _module_.[[Environment]].
              1. 실행 중 컨텍스트 suspend.
              1. _moduleContext_ push → 실행 중 컨텍스트.
              1. _steps_ = _module_.[[EvaluationSteps]].
              1. _result_ = Completion(_steps_(_module_)).
              1. _moduleContext_ suspend 및 스택에서 제거.
              1. 최상위 컨텍스트 resume.
              1. _pc_ = ! NewPromiseCapability(%Promise%).
              1. IfAbruptRejectPromise(_result_, _pc_).
              1. ! Call(_pc_.[[Resolve]], *undefined*, « *undefined* ») 수행.
              1. _pc_.[[Promise]] 반환.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetImportedModule" type="abstract operation">
        <h1>
          GetImportedModule (
            _referrer_: Cyclic Module Record,
            _request_: ModuleRequest Record,
          ): Module Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. [declared="r"] _records_ 를 _referrer_.[[LoadedModules]] 의 각 LoadedModuleRequest Record _r_ 중 ModuleRequestsEqual(_r_, _request_) 이 *true* 인 것들의 리스트로 둔다.
          1. 단언: LoadRequestedModules 가 사전에 성공했으므로 _records_ 는 정확히 한 요소.
          1. _record_ = _records_ 의 유일 요소.
          1. _record_.[[Module]] 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation" oldids="sec-hostresolveimportedmodule,sec-hostimportmoduledynamically">
        <h1>
          HostLoadImportedModule (
            _referrer_: Script Record, Cyclic Module Record, 또는 Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _hostDefined_: anything,
            _payload_: GraphLoadingState Record 또는 PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>웹 브라우저 호스트 예: 사용자가 아래 컨트롤을 클릭할 때</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>`import()` 표현식 실행 시 활성 스크립트나 모듈이 없을 수 있다. 더 일반적으로 호스트가 ScriptOrModule 이 *null* 인 실행 컨텍스트를 스택에 푸시하는 상황이면 Realm Record 가 _referrer_ 가 될 수 있다.</p>
        </emu-note>

        <p>HostLoadImportedModule 구현은 다음 요구사항을 따른다:</p>
        <ul>
          <li>
            호스트는 FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_) 수행해야 하며 _result_ 는 로드된 Module Record 를 담은 정상 completion 또는 throw completion (동기 또는 비동기).
          </li>
          <li>
            <p>이 연산이 동일 _referrer_ 와 ModuleRequestsEqual 가 *true* 인 두 (_referrer_, _moduleRequest_) 쌍에 대해 여러 번 호출되고, _result_ 가 정상 completion 인 FinishLoadingImportedModule 을 수행한다면, 매번 동일 _result_ 로 FinishLoadingImportedModule 을 수행해야 한다.</p>
          </li>
          <li>
            <p>_moduleRequest_.[[Attributes]] 에 _entry_.[[Key]] = *"type"*, _entry_.[[Value]] = *"json"* 인 항목이 있으면 FinishLoadingImportedModule 호출 시 _result_ 는 ParseJSONModule 호출이 반환한 Completion Record 또는 throw completion 이어야 한다.</p>
          </li>
          <li>
            연산은 _payload_ 를 FinishLoadingImportedModule 로 전달할 불투명 값으로 취급해야 한다.
          </li>
        </ul>

        <p>실제 과정은 호스트 정의이며 보통 적절한 Module Record 로드에 필요한 I/O 수행. 서로 다른 여러 (_referrer_, _moduleRequest_.[[Specifier]], _moduleRequest_.[[Attributes]]) 삼중 조합이 동일 Module Record 인스턴스에 매핑될 수 있음. 매핑 의미론은 호스트 정의이나 일반적으로 _specifier_ 정규화 포함 (상대/축약 경로 확장 등).</p>

        <emu-note>
          <p>위 텍스트는 `type: "json"` 으로 import 하면 (그리고 HostLoadImportedModule 이 정상 완료) 호스트가 JSON 모듈 지원을 요구하지만 `type: "json"` 없이 import 할 때 JSON 모듈 지원을 금지하지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" oldids="sec-finishdynamicimport">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: Script Record, Cyclic Module Record, 또는 Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _payload_: GraphLoadingState Record 또는 PromiseCapability Record,
            _result_: Module Record 를 담은 정상 completion 또는 throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. _result_가 정상 completion이면
            1. _referrer_.[[LoadedModules]]에 ModuleRequestsEqual(_record_, _moduleRequest_)가 *true*인 LoadedModuleRequest Record _record_가 있으면
              1. 단언: _record_.[[Module]]과 _result_.[[Value]]는 동일한 Module Record이다.
            1. 그렇지 않으면
              1. LoadedModuleRequest Record { [[Specifier]]: _moduleRequest_.[[Specifier]], [[Attributes]]: _moduleRequest_.[[Attributes]], [[Module]]: _result_.[[Value]] }를 _referrer_.[[LoadedModules]]에 추가한다.
          1. _payload_가 GraphLoadingState Record이면
            1. ContinueModuleLoading(_payload_, _result_)를 수행한다.
          1. 그렇지 않으면
            1. ContinueDynamicImport(_payload_, _result_)를 수행한다.
          1. ~unused~를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-AllImportAttributesSupported" type="abstract operation">
        <h1>
          AllImportAttributesSupported (
            _attributes_: ImportAttribute Records 리스트,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. _supported_를 HostGetSupportedImportAttributes()로 둔다.
          1. _attributes_의 각 ImportAttribute Record _attribute_에 대해
            1. _supported_가 _attribute_.[[Key]]를 포함하지 않으면 *false*를 반환한다.
          1. *true*를 반환한다.
        </emu-alg>

        <emu-clause id="sec-hostgetsupportedimportattributes" type="host-defined abstract operation">
          <h1>HostGetSupportedImportAttributes ( ): 문자열 리스트</h1>
          <dl class="header">
            <dt>description</dt>
            <dd>호스트 환경이 지원하는 import attribute를 지정할 수 있게 한다. 지원되는 키를 가진 attribute만 호스트에 제공된다.</dd>
          </dl>

          <p>HostGetSupportedImportAttributes의 구현은 다음 요구사항을 따라야 한다:</p>

          <ul>
            <li>지원되는 각 attribute를 나타내는 문자열의 리스트를 반환해야 한다.</li>

            <li>이 연산이 호출될 때마다 동일한 순서와 내용의 동일한 리스트를 반환해야 한다.</li>
          </ul>

          <p>HostGetSupportedImportAttributes의 기본 구현은 새 빈 리스트를 반환하는 것이다.</p>

          <emu-note>호스트가 처리할 attribute를 선택하도록 모든 attribute를 전달하는 대신 지원되는 attribute만 명시하게 하는 목적은 지원되지 않는 attribute가 서로 다른 호스트 간에도 일관되게 처리되도록 하기 위함이다.</emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-getmodulenamespace" type="abstract operation">
        <h1>
          GetModuleNamespace (
            _module_: Module Record의 구체 하위 클래스 인스턴스,
          ): Module Namespace Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_module_의 export를 나타내는 Module Namespace Object를 가져온다. 처음 요청될 때 지연 생성하여 _module_.[[Namespace]]에 저장하고 이후 재사용한다.</dd>
        </dl>

        <emu-alg>
          1. 단언: _module_이 Cyclic Module Record라면 _module_.[[Status]]는 ~new~ 또는 ~unlinked~가 아니다.
          1. _namespace_를 _module_.[[Namespace]]로 둔다.
          1. _namespace_가 ~empty~이면
            1. _exportedNames_를 _module_.GetExportedNames()로 둔다.
            1. _unambiguousNames_를 새 빈 리스트로 둔다.
            1. _exportedNames_의 각 요소 _name_에 대해
              1. _resolution_을 _module_.ResolveExport(_name_)로 둔다.
              1. _resolution_이 ResolvedBinding Record이면 _name_을 _unambiguousNames_에 추가한다.
            1. _namespace_를 ModuleNamespaceCreate(_module_, _unambiguousNames_)로 설정한다.
          1. _namespace_를 반환한다.
        </emu-alg>
        <emu-note>
          <p>GetModuleNamespace는 예외를 던지지 않는다. 대신 이 시점에서 해결할 수 없는 이름은 네임스페이스에서 제외된다. 그러한 이름들은 어딘가에서 명시적으로 요청되지 않은 모호한 star export 전부가 아닌 한 이후 실제 링크 오류로 이어진다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. *undefined*를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <emu-alg>
          1. _result_를 Completion(Evaluation of |ModuleItemList|)로 둔다.
          1. _result_가 정상 completion이고 _result_.[[Value]]가 ~empty~이면
            1. *undefined*를 반환한다.
          1. ? _result_를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _sl_을 ? Evaluation of |ModuleItemList|로 둔다.
          1. _s_를 Completion(Evaluation of |ModuleItem|)로 둔다.
          1. ? UpdateEmpty(_s_, _sl_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>|ModuleItemList|의 값은 그 |ModuleItemList| 안에서 마지막으로 값을 생성한 항목의 값이다.</p>
        </emu-note>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. ~empty~를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>가져오기(Imports)</h1>
      <h2>구문</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause WithClause? `;`
          `import` ModuleSpecifier WithClause? `;`

        ImportClause :
          ImportedDefaultBinding
          NameSpaceImport
          NamedImports
          ImportedDefaultBinding `,` NameSpaceImport
          ImportedDefaultBinding `,` NamedImports

        ImportedDefaultBinding :
          ImportedBinding

        NameSpaceImport :
          `*` `as` ImportedBinding

        NamedImports :
          `{` `}`
          `{` ImportsList `}`
          `{` ImportsList `,` `}`

        FromClause :
          `from` ModuleSpecifier

        ImportsList :
          ImportSpecifier
          ImportsList `,` ImportSpecifier

        ImportSpecifier :
          ImportedBinding
          ModuleExportName `as` ImportedBinding

        ModuleSpecifier :
          StringLiteral

        ImportedBinding :
          BindingIdentifier[~Yield, +Await]

        WithClause :
          `with` `{` `}`
          `with` `{` WithEntries `,`? `}`

        WithEntries :
          AttributeKey `:` StringLiteral
          AttributeKey `:` StringLiteral `,` WithEntries

        AttributeKey :
          IdentifierName
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <ul>
          <li>
            |ImportDeclaration| 의 BoundNames 에 중복 항목이 있으면 문법 오류이다.
          </li>
        </ul>

        <emu-grammar>WithClause : `with` `{` WithEntries `,`? `}`</emu-grammar>
        <ul>
          <li>
            |WithClause| 의 WithClauseToAttributes 결과에 _a_.[[Key]] 가 _b_.[[Key]] 와 같은 서로 다른 항목 _a_, _b_ 두 개가 있으면 문법 오류이다.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="sdo">
        <h1>정적 의미론: ImportEntries ( ): ImportEntry Record 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _entries1_ 을 |ModuleItemList| 의 ImportEntries 로 둔다.
          1. _entries2_ 를 |ModuleItem| 의 ImportEntries 로 둔다.
          1. _entries1_ 와 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ExportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. _module_ 을 |ImportDeclaration| 의 ModuleRequests 의 유일한 요소로 둔다.
          1. |ImportClause| 의 ImportEntriesForModule(_module_) 를 반환한다.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo">
        <h1>
          정적 의미론: ImportEntriesForModule (
          _module_: ModuleRequest Record,
          ): ImportEntry Record 리스트
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. _entries1_ 를 |ImportedDefaultBinding| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries2_ 를 |NameSpaceImport| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries1_ 와 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. _entries1_ 를 |ImportedDefaultBinding| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries2_ 를 |NamedImports| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _entries1_ 와 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ 을 |ImportedBinding| 의 BoundNames 의 유일한 요소로 둔다.
          1. _defaultEntry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *"default"*, [[LocalName]]: _localName_ } 로 둔다.
          1. « _defaultEntry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ 을 |ImportedBinding| 의 StringValue 로 둔다.
          1. _entry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. _specs1_ 을 |ImportsList| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _specs2_ 를 |ImportSpecifier| 의 ImportEntriesForModule(_module_) 로 둔다.
          1. _specs1_ 와 _specs2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
        <emu-alg>
          1. _localName_ 을 |ImportedBinding| 의 BoundNames 의 유일한 요소로 둔다.
          1. _entry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. _importName_ 을 |ModuleExportName| 의 StringValue 로 둔다.
          1. _localName_ 을 |ImportedBinding| 의 StringValue 로 둔다.
          1. _entry_ 를 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-withclausetoattributes" type="sdo">
        <h1>정적 의미론: WithClauseToAttributes ( ): ImportAttribute Record 리스트</h1>
        <dl class="header">
        </dl>

        <emu-grammar>
          WithClause : `with` `{` `}`
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>

        <emu-grammar>
          WithClause : `with` `{` WithEntries `,`? `}`
        </emu-grammar>
        <emu-alg>
          1. _attributes_ 를 |WithEntries| 의 WithClauseToAttributes 로 둔다.
          1. _attributes_ 의 [[Key]] 필드 값을 UTF-16 코드 유닛 시퀀스로 간주한 사전식 순서에 따라 정렬한다. 참고: 이 정렬은 호스트가 열거 순서에 따라 동작을 바꾸지 못하도록 강제한다는 점에서만 관측 가능하다.
          1. _attributes_ 를 반환한다.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral</emu-grammar>
        <emu-alg>
          1. _key_ 를 |AttributeKey| 의 PropName 으로 둔다.
          1. _entry_ 를 ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| 의 SV } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral `,` WithEntries</emu-grammar>
        <emu-alg>
          1. _key_ 를 |AttributeKey| 의 PropName 으로 둔다.
          1. _entry_ 를 ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| 의 SV } 로 둔다.
          1. _rest_ 를 |WithEntries| 의 WithClauseToAttributes 로 둔다.
          1. « _entry_ » 와 _rest_ 의 리스트 연결을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>내보내기(Exports)</h1>
      <h2>구문</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          `*` `as` ModuleExportName
          NamedExports

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>정적 의미론: 조기 오류</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            |NamedExports| 의 ReferencedBindings 에 |StringLiteral| 이 있으면 문법 오류이다.
          </li>
          <li>
            |NamedExports| 의 ReferencedBindings 에 있는 각 |IdentifierName| _n_ 에 대해: _n_ 의 StringValue 가 |ReservedWord| 이거나 *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"* 중 하나이면 문법 오류이다.
          </li>
        </ul>
        <emu-note>
          <p>위 규칙은 |NamedExports| 의 ReferencedBindings 각각이 |IdentifierReference| 로 취급됨을 의미한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportedbindings" oldids="sec-module-semantics-static-semantics-exportedbindings,sec-exports-static-semantics-exportedbindings" type="sdo">
        <h1>정적 의미론: ExportedBindings ( ): 문자열 리스트</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedBindings 는 |Module| 의 ExportedNames 와 명시적으로 연결된 로컬 바인딩 이름들이다.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ModuleItemList| 의 ExportedBindings 로 둔다.
          1. _names2_ 를 |ModuleItem| 의 ExportedBindings 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. |NamedExports| 의 ExportedBindings 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 이 |ExportDeclaration| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ExportsList| 의 ExportedBindings 로 둔다.
          1. _names2_ 를 |ExportSpecifier| 의 ExportedBindings 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 첫 번째 |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" oldids="sec-module-semantics-static-semantics-exportednames,sec-exports-static-semantics-exportednames" type="sdo">
        <h1>정적 의미론: ExportedNames ( ): 문자열 리스트</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames 는 |Module| 이 로컬 바인딩 이름 중 하나에 명시적으로 매핑하는 외부로 보이는 이름들이다.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ModuleItemList| 의 ExportedNames 로 둔다.
          1. _names2_ 를 |ModuleItem| 의 ExportedNames 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. |ExportDeclaration| 의 ExportedNames 를 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. |ExportFromClause| 의 ExportedNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. |NamedExports| 의 ExportedNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| 의 BoundNames 를 반환한다.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. « *"default"* » 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ExportsList| 의 ExportedNames 로 둔다.
          1. _names2_ 를 |ExportSpecifier| 의 ExportedNames 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 두 번째 |ModuleExportName| 의 StringValue 한 요소만 갖는 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" oldids="sec-module-semantics-static-semantics-exportentries,sec-exports-static-semantics-exportentries" type="sdo">
        <h1>정적 의미론: ExportEntries ( ): ExportEntry Record 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. _entries1_ 을 |ModuleItemList| 의 ExportEntries 로 둔다.
          1. _entries2_ 를 |ModuleItem| 의 ExportEntries 로 둔다.
          1. _entries1_ 과 _entries2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. _module_ 을 |ExportDeclaration| 의 ModuleRequests 의 유일한 요소로 둔다.
          1. |ExportFromClause| 의 ExportEntriesForModule(_module_) 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. |NamedExports| 의 ExportEntriesForModule(*null*) 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. _entries_ 를 새 빈 리스트로 둔다.
          1. _names_ 를 |VariableStatement| 의 BoundNames 로 둔다.
          1. 각 _name_ ∈ _names_ 에 대해
            1. ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } 를 _entries_ 에 추가한다.
          1. _entries_ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. _entries_ 를 새 빈 리스트로 둔다.
          1. _names_ 를 |Declaration| 의 BoundNames 로 둔다.
          1. 각 _name_ ∈ _names_ 에 대해
            1. ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } 를 _entries_ 에 추가한다.
          1. _entries_ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. _names_ 를 |HoistableDeclaration| 의 BoundNames 로 둔다.
          1. _localName_ 을 _names_ 의 유일한 요소로 둔다.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. _names_ 를 |ClassDeclaration| 의 BoundNames 로 둔다.
          1. _localName_ 을 그 유일한 요소로 둔다.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. _entry_ 를 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* 는 익명 default export 값을 위한 명세 내부의 합성 이름이다. 더 자세한 내용은 <emu-xref href="#note-star-default-star">이 노트</emu-xref> 를 참조.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentriesformodule" type="sdo">
        <h1>
          정적 의미론: ExportEntriesForModule (
          _module_: ModuleRequest Record 또는 *null*,
          ): ExportEntry Record 리스트
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. _entry_ 를 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. _exportName_ 을 |ModuleExportName| 의 StringValue 로 둔다.
          1. _entry_ 를 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ } 로 둔다.
          1. « _entry_ » 를 반환한다.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _specs1_ 을 |ExportsList| 의 ExportEntriesForModule(_module_) 로 둔다.
          1. _specs2_ 를 |ExportSpecifier| 의 ExportEntriesForModule(_module_) 로 둔다.
          1. _specs1_ 과 _specs2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. _sourceName_ 을 |ModuleExportName| 의 StringValue 로 둔다.
          1. _module_ 이 *null* 이면
            1. _localName_ = _sourceName_.
            1. _importName_ = *null*.
          1. 그렇지 않으면
            1. _localName_ = *null*.
            1. _importName_ = _sourceName_.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ } 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. _sourceName_ 을 첫 번째 |ModuleExportName| 의 StringValue 로 둔다.
          1. _exportName_ 을 두 번째 |ModuleExportName| 의 StringValue 로 둔다.
          1. _module_ 이 *null* 이면
            1. _localName_ = _sourceName_.
            1. _importName_ = *null*.
          1. 그렇지 않으면
            1. _localName_ = *null*.
            1. _importName_ = _sourceName_.
          1. 유일 요소가 새 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ } 인 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-referencedbindings" type="sdo">
        <h1>정적 의미론: ReferencedBindings ( ): Parse Node 리스트</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 새 빈 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. _names1_ 을 |ExportsList| 의 ReferencedBindings 로 둔다.
          1. _names2_ 를 |ExportSpecifier| 의 ReferencedBindings 로 둔다.
          1. _names1_ 과 _names2_ 의 리스트 연결을 반환한다.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 첫 번째 |ModuleExportName| 의 ReferencedBindings 를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleExportName : IdentifierName</emu-grammar>
        <emu-alg>
          1. 유일한 요소가 그 |IdentifierName| 인 리스트를 반환한다.
        </emu-alg>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <emu-alg>
          1. 유일한 요소가 그 |StringLiteral| 인 리스트를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo">
        <h1>런타임 의미론: 평가</h1>
        <emu-grammar>
          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
        </emu-grammar>
        <emu-alg>
          1. ~empty~ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. |VariableStatement| 의 Evaluation 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. |Declaration| 의 Evaluation 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. |HoistableDeclaration| 의 Evaluation 결과를 ? 로 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. _value_ 를 |ClassDeclaration| 의 BindingClassDeclarationEvaluation 결과(? )로 둔다.
          1. _className_ 을 |ClassDeclaration| 의 BoundNames 의 유일한 요소로 둔다.
          1. _className_ 이 *"\*default\*"* 이면
            1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
            1. ? InitializeBoundName(*"\*default\*"*, _value_, _env_) 를 수행한다.
          1. ~empty~ 를 반환한다.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. IsAnonymousFunctionDefinition(|AssignmentExpression|) 이 *true* 이면
            1. _value_ 를 ? NamedEvaluation(|AssignmentExpression|, *"default"*) 로 둔다.
          1. 그렇지 않으면
            1. _rhs_ 를 ? Evaluation(|AssignmentExpression|) 로 둔다.
            1. _value_ 를 ? GetValue(_rhs_) 로 둔다.
          1. _env_ 를 실행 중 실행 컨텍스트의 LexicalEnvironment 로 둔다.
          1. ? InitializeBoundName(*"\*default\*"*, _value_, _env_) 를 수행한다.
          1. ~empty~ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-error-handling-and-language-extensions">
  <h1>오류 처리 및 언어 확장</h1>
  <p>구현은 관련 ECMAScript 언어 구성요소가 평가될 때 대부분의 오류를 보고해야 한다. <dfn id="early-error" variants="early errors">early error(조기 오류)</dfn> 는 그 오류를 포함하는 |Script| 안의 어떤 구성요소도 평가되기 전에 검출·보고될 수 있는 오류이다. 조기 오류가 존재하면 그 구성요소의 평가가 차단된다. 구현은 ParseScript 과정에서 해당 |Script| 를 파싱하는 일부로 |Script| 의 조기 오류를 보고해야 한다. |Module| 의 조기 오류는 그 |Module| 이 평가될 지점에서 보고되며 그 |Module| 은 결코 초기화되지 않는다. <b>eval</b> 코드의 조기 오류는 `eval` 이 호출되는 시점에 보고되며 해당 <b>eval</b> 코드의 평가를 막는다. 조기 오류가 아닌 모든 오류는 런타임 오류이다.</p>
  <p>구현은 이 명세의 “Static Semantics: Early Errors” 하위 절에 열거된 조건이 발생하면 반드시 그것을 조기 오류로 보고해야 한다.</p>
  <p>구현은 (컴파일러가 어떤 구성요소가 어떤 상황에서도 오류 없이 실행될 수 없음을 입증할 수 있더라도) 다른 종류의 오류를 조기 오류로 취급해서는 안 된다. 그런 경우 구현이 조기 경고를 낼 수는 있지만, 관련 구성요소가 실제로 실행될 때까지 오류를 보고해서는 안 된다.</p>
  <p>구현은 다음과 같은 경우를 제외하고 명세된 대로 모든 오류를 보고해야 한다:</p>
  <ul>
    <li>
      <emu-xref href="#sec-forbidden-extensions"></emu-xref> 에서 제한된 경우를 제외하고 호스트 또는 구현은 |Script| 구문, |Module| 구문, 그리고 정규 표현식 패턴 또는 플래그 구문을 확장할 수 있다. 이를 허용하기 위해 *SyntaxError* 를 던질 수 있는(예: `eval` 호출, 정규 표현식 리터럴 사용, Function 또는 RegExp 생성자 사용) 모든 연산은 스크립트 구문이나 정규 표현식 패턴/플래그 구문에 대한 호스트 정의 확장을 만나면 *SyntaxError* 를 던지는 대신 호스트 정의 동작을 보일 수 있다.
    </li>
    <li>
      <emu-xref href="#sec-forbidden-extensions"></emu-xref> 에서 제한된 경우를 제외하고 호스트 또는 구현은 이 명세에 기술된 것 이외의 추가적인 타입, 값, 객체, 프로퍼티, 함수를 제공할 수 있다. 이는 (예: 전역 스코프에서 변수 조회 같은) 구성요소가 오류(예: *ReferenceError*) 를 던지는 대신 호스트 정의 동작을 갖도록 만들 수 있다.
    </li>
  </ul>

  <emu-clause id="sec-forbidden-extensions">
    <h1>금지된 확장</h1>
    <p>구현은 다음과 같은 방식으로 이 명세를 확장해서는 안 된다:</p>
    <ul>
      <li>
        strict 모드 코드에서 구문 생성자를 사용해 정의된 ECMAScript 함수 객체는 자체(own) 프로퍼티로 *"caller"*, *"arguments"* 라는 이름을 갖도록 생성되어서는 안 된다. 또한 |ArrowFunction|, |MethodDefinition|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |ClassDeclaration|, |ClassExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncArrowFunction| 으로 정의된 함수 객체 역시 정의가 strict 모드 코드 안에 있든 없든 그러한 own 프로퍼티를 가져서는 안 된다. 내장 함수, Function 생성자로 생성된 strict 함수, Generator 생성자로 생성된 generator 함수, AsyncFunction 생성자로 생성된 async 함수, `bind` 메서드로 생성된 함수 역시 그러한 own 프로퍼티를 가져서는 안 된다.
      </li>
      <li>
        구현이 어떤 함수 객체를 *"caller"* 라는 own 프로퍼티로 확장하는 경우 [[Get]] 또는 [[GetOwnProperty]] 로 관찰되는 그 프로퍼티의 값은 strict 함수 객체가 되어서는 안 된다. 그것이 접근자 프로퍼티라면 [[Get]] 특성의 값인 함수는 호출 시 strict 함수를 반환해서는 안 된다.
      </li>
      <li>
        매핑되었거나 매핑되지 않은 arguments 객체 모두 *"caller"* 라는 own 프로퍼티로 생성되어서는 안 된다.
      </li>
      <li>
        ECMA-402 에 명세된(예: `toLocaleString` 라는 이름을 가진) 내장 메서드의 동작은 ECMA-402 에서 명시된 것 이외로 확장되어서는 안 된다.
      </li>
      <li>
        <emu-xref href="#sec-patterns"></emu-xref> 및 <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> 의 RegExp 패턴 문법은 <sub>[UnicodeMode]</sub> 문법 매개변수가 존재할 때 A-Z 또는 a-z 소스 문자를 |IdentityEscape[+UnicodeMode]| 로 인식하도록 확장되어서는 안 된다.
      </li>
      <li>
        어휘 비단말 기호 |BindingIdentifier| 로 매치되는 소스 텍스트 바로 뒤에 토큰 `:` 이 올 수 있게 하는 방식으로 구문 문법을 확장해서는 안 된다.
      </li>
      <li>
        strict 모드 코드를 처리할 때 구현은 <emu-xref href="#sec-numeric-literals-early-errors"></emu-xref> 의 조기 오류 규칙을 완화해서는 안 된다.
      </li>
      <li>
        |TemplateEscapeSequence| 는 <emu-xref href="#sec-literals-string-literals"></emu-xref> 에 정의된 |LegacyOctalEscapeSequence| 또는 |NonOctalDecimalEscapeSequence| 를 포함하도록 확장되어서는 안 된다.
      </li>
      <li>
        strict 모드 코드를 처리할 때 <emu-xref href="#sec-labelled-function-declarations"></emu-xref>, <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>, <emu-xref href="#sec-functiondeclarations-in-ifstatement-statement-clauses"></emu-xref>, <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 에 정의된 확장은 지원되어서는 안 된다.
      </li>
      <li>
        |Module| 목표 심볼을 파싱할 때 <emu-xref href="#sec-html-like-comments"></emu-xref> 에 정의된 어휘(grammar) 확장은 지원되어서는 안 된다.
      </li>
      <!-- The following is so that in the future we can potentially add new arguments or support ArgumentList. -->
      <li>
        |ImportCall| 은 확장되어서는 안 된다.
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-standard-built-in-objects">
  <h1>ECMAScript 표준 내장 객체</h1>
  <p>ECMAScript |Script| 또는 |Module| 이 실행을 시작할 때 항상 이용 가능한 특정 내장 객체들이 있다. 그중 전역 객체는 실행 중인 프로그램의 전역 환경 일부이다. 다른 것들은 전역 객체의 초기 프로퍼티로서 또는 접근 가능한 내장 객체의 프로퍼티를 통해 간접적으로 접근할 수 있다.</p>
  <p>별도로 명시되지 않는 한 함수로 호출 가능한 내장 객체는 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 에 기술된 특성을 가진 내장 함수 객체이다. 별도로 명시되지 않는 한 내장 객체의 [[Extensible]] 내부 슬롯의 초기 값은 *true* 이다. 모든 내장 함수 객체는 자신이 처음 생성된 Realm 의 Realm Record 값을 가지는 [[Realm]] 내부 슬롯을 가진다.</p>
  <p>많은 내장 객체는 함수이며, 인수를 전달받아 호출될 수 있다. 그중 일부는 생성자이기도 하여 `new` 연산자와 함께 사용하도록 의도된 함수이다. 각 내장 함수에 대해 이 명세는 그 함수가 요구하는 인수와 함수 객체의 프로퍼티를 기술한다. 각 내장 생성자에 대해서는 추가로 그 생성자의 프로토타입 객체 프로퍼티 및 그 생성자를 호출하는 `new` 표현식이 반환하는 특정 객체 인스턴스의 프로퍼티를 기술한다.</p>
  <p>특정 함수의 설명에서 달리 명시되지 않는 한, 내장 함수나 생성자가 지정된 것보다 적은 인수를 받으면, 부족한 인수들을 *undefined* 값으로 채워 받은 것과 정확히 동일하게 동작해야 한다. 이러한 누락된 인수들은 “존재하지 않음” 으로 간주되며 명세 알고리즘에서 그렇게 식별될 수 있다. 특정 함수 설명에서 “*this* value” 와 “NewTarget” 용어는 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 에서 부여된 의미를 가진다.</p>
  <p>특정 함수 설명에서 달리 명시되지 않는 한, 내장 함수나 생성자가 허용된 것보다 많은 인수를 받으면 추가 인수는 평가되지만 함수는 이를 무시한다. 단, 구현은 그러한 인수에 대해 *TypeError* 예외를 단지 “추가 인수가 존재한다” 는 이유만으로 던지지 않는 한 구현 정의 동작을 규정할 수 있다.</p>
  <emu-note>
    <p>내장 함수 집합에 추가 기능을 덧붙이는 구현은 기존 함수에 새 매개변수를 추가하기보다 새 함수를 추가하는 방식으로 하는 것이 권장된다.</p>
  </emu-note>
  <p>별도로 명시되지 않는 한 모든 내장 함수 및 내장 생성자는 자신의 [[Prototype]] 내부 슬롯 값으로 Function 프로토타입 객체(표현식 `Function.prototype` 의 초기 값, <emu-xref href="#sec-properties-of-the-function-prototype-object"></emu-xref>) 를 가진다.</p>
  <p>별도로 명시되지 않는 한 모든 내장 프로토타입 객체는 (자기 자신인 Object 프로토타입 객체를 제외하고) 자신의 [[Prototype]] 내부 슬롯 값으로 Object 프로토타입 객체(표현식 `Object.prototype` 의 초기 값, <emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>) 를 가진다.</p>
  <p>이 명세가 내장 생성자의 동작을 알고리즘 단계로 정의했다면, 그것이 [[Call]] 과 [[Construct]] 양쪽 목적의 동작이다. 해당 알고리즘이 두 경우를 구분할 필요가 있으면 NewTarget 이 *undefined* 인지 검사하는데, 이는 [[Call]] 호출을 의미한다.</p>
  <p>생성자로 식별되지 않은 내장 함수 객체는 특정 함수 설명에서 별도로 명시되지 않는 한 [[Construct]] 내부 메서드를 구현하지 않는다.</p>
  <p>생성자가 아닌 내장 함수 객체는 특정 함수 설명에서 별도로 명시되지 않는 한 *"prototype"* 프로퍼티를 갖지 않는다.</p>
  <p>이 명세에 정의된 각 내장 함수는 CreateBuiltinFunction 추상 연산(<emu-xref href="#sec-createbuiltinfunction"></emu-xref>) 호출로 생성된다. _length_ 및 _name_ 매개변수의 값은 아래에서 논의되는 *"length"* 및 *"name"* 프로퍼티의 초기 값이다. _prefix_ 매개변수의 값도 유사하게 아래에서 논의된다.</p>
  <p>생성자를 포함한 모든 내장 함수 객체는 *"length"* 프로퍼티를 가지며 그 값은 0 이상의 정수 Number 이다. 별도로 명시되지 않는 한 이 값은 함수 설명 하위 절 제목에 나타난 필수 매개변수의 수이다. 선택적 매개변수와 rest 매개변수는 개수에 포함되지 않는다.</p>
  <emu-note>
    <p>예: Array 프로토타입 객체의 *"map"* 프로퍼티 초기 값인 함수 객체는 «Array.prototype.map (callback [ , thisArg])» 라는 제목 아래에 기술되며, 이름 있는 두 인수 callback 과 선택적인 thisArg 를 보여준다. 따라서 그 함수 객체의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub> 이다.</p>
  </emu-note>
  <p>별도로 명시되지 않는 한 내장 함수 객체의 *"length"* 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
  <p>생성자를 포함한 모든 내장 함수 객체는 *"name"* 프로퍼티를 가지며 그 값은 String 이다. 별도로 명시되지 않는 한 이 값은 명세에서 그 함수에 부여된 이름이다. 익명 함수로 식별된 함수들은 빈 문자열을 *"name"* 프로퍼티 값으로 사용한다. 객체의 프로퍼티로 명세된 함수의 경우 이름 값은 그 함수를 접근하는 데 쓰이는 프로퍼티 이름 문자열이다. 내장 프로퍼티의 get 또는 set 접근자 함수로 명세된 함수는 CreateBuiltinFunction 을 호출할 때 _prefix_ 매개변수로 각각 *"get"* 또는 *"set"* 을 전달한다.</p>
  <p>프로퍼티 키가 Symbol 값인 각 내장 함수에 대해 *"name"* 프로퍼티 값은 명시적으로 지정된다. 그러한 명시적 값이 접두사 *"get "* 또는 *"set "* 로 시작하고 그 함수가 내장 프로퍼티의 get 또는 set 접근자 함수라면, 접두사를 제거한 값이 _name_ 매개변수로 전달되고 *"get"* 또는 *"set"* 값이 _prefix_ 매개변수로 전달된다.</p>
  <p>별도로 명시되지 않는 한 내장 함수 객체의 *"name"* 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> 부터 <emu-xref href="#sec-reflection"></emu-xref> 절 및 부록 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> 에 기술된 다른 모든 데이터 프로퍼티는 명시적으로 달리 지정되지 않는 한 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 갖는다.</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> 부터 <emu-xref href="#sec-reflection"></emu-xref> 절 및 부록 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> 에 기술된 모든 접근자 프로퍼티는 명시적으로 달리 지정되지 않는 한 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 갖는다. get 접근자 함수만 기술된 경우 set 접근자 함수의 기본값은 *undefined* 이다. set 접근자만 기술된 경우 get 접근자의 기본값은 *undefined* 이다.</p>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>전역 객체(The Global Object)</h1>
  <p><dfn variants="global objects">전역 객체</dfn>:</p>
  <ul>
    <li>어떤 실행 컨텍스트에 제어가 진입하기 전에 생성된다.</li>
    <li>[[Construct]] 내부 메서드를 가지지 않는다; `new` 연산자로 생성자로 사용할 수 없다.</li>
    <li>[[Call]] 내부 메서드를 가지지 않는다; 함수로 호출될 수 없다.</li>
    <li>값이 호스트 정의인 [[Prototype]] 내부 슬롯을 가진다.</li>
    <li>명세에 정의된 프로퍼티 외에 호스트 정의 프로퍼티를 가질 수 있다. 여기에는 값이 전역 객체 자신인 프로퍼티가 포함될 수 있다.</li>
  </ul>

  <emu-clause id="sec-value-properties-of-the-global-object">
    <h1>전역 객체의 값(Value) 프로퍼티</h1>

    <emu-clause id="sec-globalthis">
      <h1>globalThis</h1>
      <p>Realm Record _realm_ 에서 전역 객체의 *"globalThis"* 프로퍼티 초기 값은 _realm_.[[GlobalEnv]].[[GlobalThisValue]] 이다.</p>
      <p>이 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 갖는다.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-infinity">
      <h1>Infinity</h1>
      <p>`Infinity` 의 값은 *+∞*<sub>𝔽</sub> 이다(<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 참조). 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 갖는다.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-nan">
      <h1>NaN</h1>
      <p>`NaN` 의 값은 *NaN* 이다(<emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 참조). 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 갖는다.</p>
    </emu-clause>

    <emu-clause id="sec-undefined">
      <h1>undefined</h1>
      <p>`undefined` 의 값은 *undefined* 이다(<emu-xref href="#sec-ecmascript-language-types-undefined-type"></emu-xref> 참조). 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 갖는다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>전역 객체의 함수(Function) 프로퍼티</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <p>이 함수는 <dfn>%eval%</dfn> 고유(intrinsic) 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. Return ? PerformEval(_x_, *false*, *false*).
      </emu-alg>

      <emu-clause id="sec-performeval" type="abstract operation" oldids="sec-performeval-rules-outside-functions,sec-performeval-rules-outside-methods,sec-performeval-rules-outside-constructors">
        <h1>
          PerformEval (
            _x_: ECMAScript 언어 값,
            _strictCaller_: Boolean,
            _direct_: Boolean,
          ): ECMAScript 언어 값을 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 단언: _direct_ 가 *false* 이면 _strictCaller_ 도 *false*.
          1. _x_ 가 String 이 아니면 _x_ 를 반환.
          1. _evalRealm_ 을 현재 Realm Record 로 둔다.
          1. 참고: direct eval 의 경우 _evalRealm_ 은 `eval` 호출자와 `eval` 함수 자체의 realm 이다.
          1. ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_) 수행.
          1. _inFunction_ = *false*.
          1. _inMethod_ = *false*.
          1. _inDerivedConstructor_ = *false*.
          1. _inClassFieldInitializer_ = *false*.
          1. _direct_ 가 *true* 이면
            1. _thisEnvRec_ = GetThisEnvironment().
            1. _thisEnvRec_ 가 Function Environment Record 이면
              1. _F_ = _thisEnvRec_.[[FunctionObject]].
              1. _inFunction_ = *true* 로.
              1. _inMethod_ = _thisEnvRec_.HasSuperBinding().
              1. _F_.[[ConstructorKind]] 가 ~derived~ 이면 _inDerivedConstructor_ = *true*.
              1. _classFieldInitializerName_ = _F_.[[ClassFieldInitializerName]].
              1. _classFieldInitializerName_ 이 ~empty~ 가 아니면 _inClassFieldInitializer_ = *true*.
          1. 구현 정의 순서(파싱과 오류 검출을 교차 실행 가능)로 다음 하위 단계 수행:
            1. _script_ = ParseText(_x_, |Script|).
            1. _script_ 가 오류 리스트면 *SyntaxError* 예외 throw.
            1. _script_ Contains |ScriptBody| 가 *false* 이면 *undefined* 반환.
            1. _body_ = _script_ 의 |ScriptBody|.
            1. _inFunction_ 이 *false* 이고 _body_ Contains |NewTarget| 이면 *SyntaxError* throw.
            1. _inMethod_ 이 *false* 이고 _body_ Contains |SuperProperty| 이면 *SyntaxError* throw.
            1. _inDerivedConstructor_ 가 *false* 이고 _body_ Contains |SuperCall| 이면 *SyntaxError* throw.
            1. _inClassFieldInitializer_ 가 *true* 이고 ContainsArguments(_body_) 가 *true* 이면 *SyntaxError* throw.
          1. _strictCaller_ 가 *true* 이면 _strictEval_ = *true*.
          1. Else _strictEval_ = ScriptIsStrict(_script_).
          1. _runningContext_ = 실행 중 실행 컨텍스트.
          1. 참고: _direct_ *true* 이면 호출한 컨텍스트; *false* 이면 `eval` 호출 실행 컨텍스트.
          1. _direct_ 가 *true* 이면
            1. _lexEnv_ = NewDeclarativeEnvironment(_runningContext_.LexicalEnvironment).
            1. _varEnv_ = _runningContext_.VariableEnvironment.
            1. _privateEnv_ = _runningContext_.PrivateEnvironment.
          1. Else
            1. _lexEnv_ = NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).
            1. _varEnv_ = _evalRealm_.[[GlobalEnv]].
            1. _privateEnv_ = *null*.
          1. _strictEval_ 이 *true* 이면 _varEnv_ = _lexEnv_.
          1. _runningContext_ 가 아직 suspend 상태가 아니면 suspend.
          1. _evalContext_ = 새 ECMAScript 코드 실행 컨텍스트.
          1. _evalContext_.Function = *null*.
          1. _evalContext_.Realm = _evalRealm_.
          1. _evalContext_.ScriptOrModule = _runningContext_.ScriptOrModule.
          1. _evalContext_.VariableEnvironment = _varEnv_.
          1. _evalContext_.LexicalEnvironment = _lexEnv_.
          1. _evalContext_.PrivateEnvironment = _privateEnv_.
          1. _evalContext_ 를 실행 컨텍스트 스택에 push; 현재 실행 컨텍스트.
          1. _result_ = Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)).
          1. _result_ 가 normal 이면
            1. _result_ = Completion(Evaluation(_body_)).
          1. _result_ 가 normal 이고 _result_.[[Value]] 가 ~empty~ 이면
            1. _result_ = NormalCompletion(*undefined*).
          1. _evalContext_ suspend 후 스택에서 제거.
          1. 스택 맨 위 컨텍스트 resume.
          1. Return ? _result_.
        </emu-alg>
        <emu-note>
          <p>eval 코드는 호출 컨텍스트나 eval 코드 둘 중 하나라도 strict 모드이면 호출자 변수 환경에 var/function 바인딩을 인스턴스화할 수 없다. 대신 새 VariableEnvironment 에 인스턴스화된다. `let`, `const`, `class` 선언이 도입하는 바인딩은 항상 새 LexicalEnvironment 에 인스턴스화된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostensurecancompilestrings" type="host-defined abstract operation">
        <h1>
          HostEnsureCanCompileStrings (
            _calleeRealm_: Realm Record,
            _parameterStrings_: 문자열 리스트,
            _bodyString_: String,
            _direct_: Boolean,
          ): ~unused~ 를 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>문자열을 ECMAScript 코드로 해석·평가할 수 있게 하는 특정 ECMAScript 함수를 호스트 환경이 차단할 수 있도록 한다.</dd>
        </dl>
        <p>
          _parameterStrings_ 는 함수 생성자 중 하나를 사용할 때 파라미터 목록을 구성하기 위해 연결될 문자열들을 나타낸다. _bodyString_ 은 함수 본문 또는 `eval` 에 전달된 문자열을 나타낸다.
          _direct_ 는 평가가 direct eval 인지 여부를 나타낸다.
        </p>
        <p>기본 구현은 NormalCompletion(~unused~) 을 반환한다.</p>
      </emu-clause>

      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-evaldeclarationinstantiation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: |ScriptBody| Parse Node,
            _varEnv_: Environment Record,
            _lexEnv_: Declarative Environment Record,
            _privateEnv_: PrivateEnvironment Record 또는 *null*,
            _strict_: Boolean,
          ): ~unused~ 를 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. _varNames_ = VarDeclaredNames(_body_).
          1. _varDeclarations_ = VarScopedDeclarations(_body_).
          1. _strict_ 이 *false* 이면
            1. _varEnv_ 가 Global Environment Record 이면
              1. 각 _name_ ∈ _varNames_ 에 대해
                1. HasLexicalDeclaration(_varEnv_, _name_) 가 *true* 이면 *SyntaxError* throw.
                1. 참고: `eval` 은 전역 lexical 선언에 의해 shadow 되는 전역 var 선언을 만들지 않는다.
            1. _thisEnv_ = _lexEnv_.
            1. 단언: 다음 루프는 종료한다.
            1. 반복 (_thisEnv_ 및 _varEnv_ 가 동일 Environment Record 가 아닐 동안)
              1. _thisEnv_ 가 Object Environment Record 가 아니면
                1. 참고: with 문의 환경은 lexical 선언을 포함할 수 없으므로 var/let hoisting 충돌 점검 불필요.
                1. 각 _name_ ∈ _varNames_ 에 대해
                  1. ! _thisEnv_.HasBinding(_name_) 가 *true* 이면
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> 를 지원하면
                      1. _thisEnv_ 가 |Catch| 절의 Environment Record 가 아니면 *SyntaxError* throw.
                    1. Else
                      1. *SyntaxError* throw.
                  1. 참고: direct eval 은 같은 이름의 lexical 선언 위로 var 를 hoist 하지 않는다.
              1. _thisEnv_ = _thisEnv_.[[OuterEnv]].
          1. _privateIdentifiers_ = 새 빈 리스트.
          1. _pointer_ = _privateEnv_.
          1. 반복 (_pointer_ ≠ *null*)
            1. _pointer_.[[Names]] 의 각 Private Name _binding_ 에 대해
              1. _privateIdentifiers_ 가 _binding_.[[Description]] 포함하지 않으면 append.
            1. _pointer_ = _pointer_.[[OuterPrivateEnvironment]].
          1. AllPrivateIdentifiersValid(_body_, _privateIdentifiers_) 가 *false* 이면 *SyntaxError* throw.
          1. _functionsToInitialize_ = 새 빈 리스트.
          1. _declaredFunctionNames_ = 새 빈 리스트.
          1. _varDeclarations_ 을 역순으로 순회하며 각 _d_ 에 대해
            1. _d_ 가 |VariableDeclaration|, |ForBinding|, |BindingIdentifier| 가 아니면
              1. 단언: _d_ 는 |FunctionDeclaration|, |GeneratorDeclaration|, |AsyncFunctionDeclaration|, |AsyncGeneratorDeclaration|.
              1. 참고: 같은 이름의 다수 함수 선언이 있으면 마지막 것이 사용됨.
              1. _fn_ = BoundNames(_d_) 의 유일한 요소.
              1. _declaredFunctionNames_ 가 _fn_ 포함하지 않으면
                1. _varEnv_ 가 Global Environment Record 이면
                  1. _fnDefinable_ = ? CanDeclareGlobalFunction(_varEnv_, _fn_).
                  1. _fnDefinable_ 가 *false* 이면 *TypeError* throw.
                1. _fn_ 을 _declaredFunctionNames_ 에 추가.
                1. _d_ 를 _functionsToInitialize_ 의 첫 요소로 삽입.
          1. _declaredVarNames_ = 새 빈 리스트.
          1. _varDeclarations_ 의 각 _d_ 에 대해
            1. _d_ 가 |VariableDeclaration|, |ForBinding|, |BindingIdentifier| 이면
              1. BoundNames(_d_) 의 각 String _vn_ 에 대해
                1. _declaredFunctionNames_ 가 _vn_ 포함하지 않으면
                  1. _varEnv_ 가 Global Environment Record 이면
                    1. _vnDefinable_ = ? CanDeclareGlobalVar(_varEnv_, _vn_).
                    1. _vnDefinable_ *false* 이면 *TypeError* throw.
                  1. _declaredVarNames_ 가 _vn_ 포함하지 않으면 append.
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point", normative-optional] _strict_ 이 *false* 이고 호스트가 웹 브라우저이거나 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 를 지원하면
            1. _declaredFunctionOrVarNames_ = _declaredFunctionNames_ ⋃ _declaredVarNames_ (리스트 연결).
            1. _body_ Contains _x_ 가 *true* 인 모든 |Block|, |CaseClause|, |DefaultClause| _x_ 의 |StatementList| 에 직접 포함된 각 |FunctionDeclaration| _f_ 에 대해
              1. _F_ = _f_ 의 |BindingIdentifier| StringValue.
              1. _f_ 를 _F_ 를 |BindingIdentifier| 로 하는 |VariableStatement| 로 치환해도 _body_ 에 Early Error 가 발생하지 않으면
                1. _bindingExists_ = *false*.
                1. _thisEnv_ = _lexEnv_.
                1. 단언: 루프 종료 보장.
                1. 반복 (_thisEnv_ ≠ _varEnv_)
                  1. _thisEnv_ 가 Object Environment Record 가 아니면
                    1. ! _thisEnv_.HasBinding(_F_) 가 *true* 이면
                      1. [id="step-evaldeclarationinstantiation-web-compat-bindingexists", normative-optional] 호스트가 웹 브라우저이거나 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref> 를 지원하면
                        1. _thisEnv_ 가 |Catch| 절 Environment Record 가 아니면 _bindingExists_ = *true*.
                      1. Else
                        1. _bindingExists_ = *true*.
                  1. _thisEnv_ = _thisEnv_.[[OuterEnv]].
                1. _bindingExists_ 가 *false* 이고 _varEnv_ 가 Global Environment Record 이면
                  1. HasLexicalDeclaration(_varEnv_, _F_) 가 *false* 이면
                    1. _fnDefinable_ = ? CanDeclareGlobalVar(_varEnv_, _F_).
                  1. Else
                    1. _fnDefinable_ = *false*.
                1. Else
                  1. _fnDefinable_ = *true*.
                1. _bindingExists_ *false* 이고 _fnDefinable_ *true* 이면
                  1. _declaredFunctionOrVarNames_ 가 _F_ 포함하지 않으면
                    1. _varEnv_ 가 Global Environment Record 이면
                      1. ? CreateGlobalVarBinding(_varEnv_, _F_, *true*).
                    1. Else
                      1. _bindingExists_ = ! _varEnv_.HasBinding(_F_).
                      1. _bindingExists_ *false* 이면
                        1. ! _varEnv_.CreateMutableBinding(_F_, *true*).
                        1. ! _varEnv_.InitializeBinding(_F_, *undefined*).
                    1. _F_ 를 _declaredFunctionOrVarNames_ 에 추가.
                  1. [id="step-evaldeclarationinstantiation-alt-funcdecl-eval"] |FunctionDeclaration| _f_ 평가 시 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 의 기본 알고리즘 대신:
                    1. _gEnv_ = 실행 중 컨텍스트 VariableEnvironment.
                    1. _bEnv_ = 실행 중 컨텍스트 LexicalEnvironment.
                    1. _fObj_ = ! _bEnv_.GetBindingValue(_F_, *false*).
                    1. ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*).
                    1. ~unused~ 반환.
          1. [id="step-evaldeclarationinstantiation-post-validation"] 참고: _varEnv_ 가 Global Environment Record 이고 전역 객체가 Proxy exotic object 인 경우가 아니면 이 단계 이후 비정상 종료 없음.
          1. _lexDeclarations_ = LexicallyScopedDeclarations(_body_).
          1. 각 _d_ ∈ _lexDeclarations_ 에 대해
            1. 참고: 어휘 선언된 이름은 여기서 인스턴스화만 하고 초기화하지 않음.
            1. BoundNames(_d_) 의 각 _dn_ 에 대해
              1. IsConstantDeclaration(_d_) *true* 이면
                1. ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).
              1. Else
                1. ? _lexEnv_.CreateMutableBinding(_dn_, *false*).
          1. _functionsToInitialize_ 의 각 Parse Node _f_ 에 대해
            1. _fn_ = BoundNames(_f_) 의 유일한 요소.
            1. _fo_ = InstantiateFunctionObject(_f_, _lexEnv_, _privateEnv_).
            1. _varEnv_ 가 Global Environment Record 이면
              1. ? CreateGlobalFunctionBinding(_varEnv_, _fn_, _fo_, *true*).
            1. Else
              1. _bindingExists_ = ! _varEnv_.HasBinding(_fn_).
              1. _bindingExists_ *false* 이면
                1. 참고: 앞선 검증 때문에 abrupt 발생 불가.
                1. ! _varEnv_.CreateMutableBinding(_fn_, *true*).
                1. ! _varEnv_.InitializeBinding(_fn_, _fo_).
              1. Else
                1. ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
          1. 각 String _vn_ ∈ _declaredVarNames_ 에 대해
            1. _varEnv_ 가 Global Environment Record 이면
              1. ? CreateGlobalVarBinding(_varEnv_, _vn_, *true*).
            1. Else
              1. _bindingExists_ = ! _varEnv_.HasBinding(_vn_).
              1. _bindingExists_ *false* 이면
                1. 참고: 앞선 검증으로 abrupt 불가.
                1. ! _varEnv_.CreateMutableBinding(_vn_, *true*).
                1. ! _varEnv_.InitializeBinding(_vn_, *undefined*).
          1. ~unused~ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-isfinite-number">
      <h1>isFinite ( _number_ )</h1>
      <p>이 함수는 <dfn>%isFinite%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _num_ = ? ToNumber(_number_).
        1. _num_ 이 finite 가 아니면 *false* 반환.
        1. 그렇지 않으면 *true* 반환.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isnan-number">
      <h1>isNaN ( _number_ )</h1>
      <p>이 함수는 <dfn>%isNaN%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _num_ = ? ToNumber(_number_).
        1. _num_ 이 *NaN* 이면 *true* 반환.
        1. 그렇지 않으면 *false* 반환.
      </emu-alg>
      <emu-note>
        <p>값 `X` 가 *NaN* 인지 신뢰성 있게 시험하는 ECMAScript 표현은 `X !== X` 형태이다. 결과가 *true* 이면 그리고 오직 그때만 `X` 는 *NaN* 이다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parsefloat-string">
      <h1>parseFloat ( _string_ )</h1>
      <p>이 함수는 _string_ 인수를 10진 리터럴로 해석한 결과에 따라 Number 값을 생성한다.</p>
      <p><dfn>%parseFloat%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _inputString_ = ? ToString(_string_).
        1. _trimmedString_ = ! TrimString(_inputString_, ~start~).
        1. _trimmed_ = StringToCodePoints(_trimmedString_).
        1. _trimmedPrefix_ = |StrDecimalLiteral| 문법을 만족하는(없으면 없음) 가장 긴 접두사. 없다면 *NaN* 반환.
        1. _parsedNumber_ = ParseText(_trimmedPrefix_, |StrDecimalLiteral|).
        1. 단언: _parsedNumber_ 는 Parse Node.
        1. _parsedNumber_ 의 StringNumericValue 반환.
      </emu-alg>
      <emu-note>
        <p>이 함수는 _string_ 의 선두 일부만 Number 로 해석할 수 있고, 10진 표기 일부가 될 수 없는 코드 유닛은 무시하며 무시되었다는 표시를 제공하지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parseint-string-radix">
      <h1>parseInt ( _string_, _radix_ )</h1>
      <p>이 함수는 _radix_ 에 따라 _string_ 내용을 해석하여 정수 Number 값을 생성한다. _string_ 의 선행 공백은 무시된다. _radix_ 가 0 으로 강제될 경우(예: *undefined*) 표현이 *"0x"* 또는 *"0X"* 로 시작하지 않으면 10, 그렇다면 16 으로 간주한다. _radix_ 가 16 이면 표현은 *"0x"* / *"0X"* 로 시작할 수도 있다.</p>
      <p><dfn>%parseInt%</dfn> 고유 객체이다.</p>
      <p>호출 시 다음 단계를 수행한다:</p>
      <emu-alg>
        1. _inputString_ = ? ToString(_string_).
        1. _S_ = ! TrimString(_inputString_, ~start~).
        1. _sign_ = 1.
        1. _S_ 가 비어 있지 않고 첫 코드 유닛이 0x002D 이면 _sign_ = -1.
        1. _S_ 가 비어 있지 않고 첫 코드 유닛이 0x002B 또는 0x002D 이면 _S_ = 인덱스 1 부터.
        1. _R_ = ℝ(? ToInt32(_radix_)).
        1. _stripPrefix_ = *true*.
        1. _R_ ≠ 0 이면
          1. _R_ &lt; 2 또는 _R_ > 36 이면 *NaN* 반환.
          1. _R_ ≠ 16 이면 _stripPrefix_ = *false*.
        1. Else
          1. _R_ = 10.
        1. _stripPrefix_ *true* 이면
          1. _S_ 길이 ≥ 2 이고 첫 두 코드 유닛이 *"0x"* 또는 *"0X"* 이면
            1. _S_ = 인덱스 2 부터.
            1. _R_ = 16.
        1. _S_ 가 radix-_R_ 숫자가 아닌 코드 유닛을 포함하면 _end_ = 그 첫 위치, 아니면 길이.
        1. _Z_ = _S_[0.._end_).
        1. _Z_ 가 비어 있으면 *NaN* 반환.
        1. _mathInt_ = _Z_ 가 radix-_R_ 표기에서 나타내는 정수 (규정된 근사 허용).
        1. _mathInt_ = 0 이면
          1. _sign_ = -1 이면 *-0*<sub>𝔽</sub> 반환.
          1. *+0*<sub>𝔽</sub> 반환.
        1. 𝔽(_sign_ × _mathInt_) 반환.
      </emu-alg>
      <emu-note>
        <p>이 함수는 _string_ 의 선두 일부만 정수로 해석할 수 있으며 나머지는 무시되고 무시 사실은 표시되지 않는다.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-uri-handling-functions" oldids="sec-uri-syntax-and-semantics">
      <h1>URI 처리 함수</h1>
      <p>Uniform Resource Identifier(URI)는 자원(웹 페이지, 파일 등)과 Internet 상에서 그것에 접근할 전송 프로토콜(HTTP, FTP 등)을 식별하는 String 이다. ECMAScript 자체는 이 절에 기술된 URI 인코딩·디코딩 함수 외에는 URI 사용 지원을 제공하지 않는다. `encodeURI`, `decodeURI` 는 전체 URI 에 사용하도록 의도되며 예약 문자는 특별한 의미(구분자 등)를 가정하므로 인코딩하지 않는다. `encodeURIComponent`, `decodeURIComponent` 는 URI 개별 구성 요소에 사용하도록 의도되며, 예약 문자가 텍스트를 나타낸다고 가정하고 전체 URI 의 일부가 될 때 특별한 의미를 피하기 위해 인코딩해야 한다.</p>
      <emu-note>
        <p>예약 문자 집합은 RFC 2396 에 기반하며 최신 RFC 3986 의 변경을 반영하지 않는다.</p>
      </emu-note>
      <emu-note>
        <p>많은 ECMAScript 구현은 웹 페이지를 조작하는 추가 함수·메서드를 제공하는데, 이는 표준 범위를 벗어난다.</p>
      </emu-note>

      <emu-clause id="sec-decodeuri-encodeduri">
        <h1>decodeURI ( _encodedURI_ )</h1>
        <p>이 함수는 `encodeURI` 가 도입할 수 있는 종류의 각 escape 시퀀스 및 UTF-8 인코딩을 해당 코드 포인트의 UTF-16 인코딩으로 치환한 URI 새 버전을 계산한다. `encodeURI` 가 도입할 수 없었던 escape 시퀀스는 치환하지 않는다.</p>
        <p><dfn>%decodeURI%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _uriString_ = ? ToString(_encodedURI_).
          1. _preserveEscapeSet_ = *";/?:@&=+$,#"*.
          1. Return ? Decode(_uriString_, _preserveEscapeSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodeuricomponent-encodeduricomponent">
        <h1>decodeURIComponent ( _encodedURIComponent_ )</h1>
        <p>이 함수는 `encodeURIComponent` 가 도입할 수 있는 종류의 각 escape 시퀀스 및 UTF-8 인코딩을 해당 코드 포인트의 UTF-16 인코딩으로 치환한 새 버전을 계산한다.</p>
        <p><dfn>%decodeURIComponent%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _componentString_ = ? ToString(_encodedURIComponent_).
          1. _preserveEscapeSet_ = 빈 문자열.
          1. Return ? Decode(_componentString_, _preserveEscapeSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuri-uri">
        <h1>encodeURI ( _uri_ )</h1>
        <p>이 함수는 UTF-16 인코딩(<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) 된 URI 에서 특정 코드 포인트의 각 출현을 그 코드 포인트의 UTF-8 인코딩을 나타내는 1~4개의 escape 시퀀스로 대체한 새 버전을 계산한다.</p>
        <p><dfn>%encodeURI%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _uriString_ = ? ToString(_uri_).
          1. _extraUnescaped_ = *";/?:@&=+$,#"*.
          1. Return ? Encode(_uriString_, _extraUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuricomponent-uricomponent">
        <h1>encodeURIComponent ( _uriComponent_ )</h1>
        <p>이 함수는 UTF-16 인코딩된 URI 구성 요소에서 특정 코드 포인트의 각 출현을 그 코드 포인트의 UTF-8 인코딩을 나타내는 1~4개의 escape 시퀀스로 대체한 새 버전을 계산한다.</p>
        <p><dfn>%encodeURIComponent%</dfn> 고유 객체이다.</p>
        <p>호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _componentString_ = ? ToString(_uriComponent_).
          1. _extraUnescaped_ = 빈 문자열.
          1. Return ? Encode(_componentString_, _extraUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encode" type="abstract operation">
        <h1>
          Encode (
            _string_: String,
            _extraUnescaped_: String,
          ): String 을 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_string_ 을 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 에 기술된 대로 UTF-16 인코딩된 코드 포인트 시퀀스로 해석하여 URI 인코딩·escape 를 수행한다. RFC 2396 에서 unreserved 로 식별되었거나 _extraUnescaped_ 에 등장하는 문자는 escape 하지 않는다.</dd>
        </dl>
        <emu-alg>
          1. _len_ = _string_ 길이.
          1. _R_ = 빈 문자열.
          1. _alwaysUnescaped_ = ASCII 단어 문자들과 *"-.!~\*'()"* 의 문자열 연결.
          1. _unescapedSet_ = _alwaysUnescaped_ + _extraUnescaped_.
          1. _k_ = 0.
          1. 반복 (_k_ &lt; _len_)
            1. _C_ = _string_[_k_] 코드 유닛.
            1. _unescapedSet_ 이 _C_ 포함하면
              1. _k_ = _k_ + 1.
              1. _R_ = _R_ + _C_.
            1. Else
              1. _cp_ = CodePointAt(_string_, _k_).
              1. _cp_.[[IsUnpairedSurrogate]] *true* 이면 *URIError* throw.
              1. _k_ = _k_ + _cp_.[[CodeUnitCount]].
              1. _Octets_ = _cp_.[[CodePoint]] 에 UTF-8 변환 적용한 octet 리스트.
              1. 각 _octet_ ∈ _Octets_ 에 대해
                1. _hex_ = _octet_ 의 대문자 16진 문자열.
                1. _R_ = _R_ + *"%"* + StringPad(_hex_, 2, *"0"*, ~start~).
          1. _R_ 반환.
        </emu-alg>
        <emu-note>
          <p>퍼센트 인코딩은 개별 octet 을 표현하므로 하나의 코드 포인트가 여러 연속 escape 시퀀스(각각 하나의 8비트 UTF-8 코드 유닛)에 의해 표현될 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-decode" type="abstract operation">
        <h1>
          Decode (
            _string_: String,
            _preserveEscapeSet_: String,
          ): String 을 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_preserveEscapeSet_ 에 포함된 Basic Latin 문자에 대응하는 escape 시퀀스를 보존하면서 URI unescape 및 디코딩을 수행한다.</dd>
        </dl>
        <emu-alg>
          1. _len_ = _string_ 길이.
          1. _R_ = 빈 문자열.
          1. _k_ = 0.
          1. 반복 (_k_ &lt; _len_)
            1. _C_ = _string_[_k_] 코드 유닛.
            1. _S_ = _C_.
            1. _C_ = 0x0025 ( %) 이면
              1. _k_ + 3 > _len_ 이면 *URIError* throw.
              1. _escape_ = _string_[_k_ .. _k_+3).
              1. _B_ = ParseHexOctet(_string_, _k_ + 1).
              1. _B_ 가 정수가 아니면 *URIError* throw.
              1. _k_ = _k_ + 2.
              1. _n_ = _B_ 의 선행 1 비트 개수.
              1. _n_ = 0 이면
                1. _asciiChar_ = 값이 _B_ 인 코드 유닛.
                1. _preserveEscapeSet_ 이 _asciiChar_ 포함하면 _S_ = _escape_, 아니면 _S_ = _asciiChar_.
              1. Else
                1. _n_ = 1 또는 _n_ > 4 이면 *URIError* throw.
                1. _Octets_ = « _B_ ».
                1. _j_ = 1.
                1. 반복 (_j_ &lt; _n_)
                  1. _k_ = _k_ + 1.
                  1. _k_ + 3 > _len_ 이면 *URIError* throw.
                  1. _string_[_k_] ≠ 0x0025 이면 *URIError* throw.
                  1. _continuationByte_ = ParseHexOctet(_string_, _k_ + 1).
                  1. _continuationByte_ 가 정수가 아니면 *URIError* throw.
                  1. _Octets_ 에 append(_continuationByte_).
                  1. _k_ = _k_ + 2.
                  1. _j_ = _j_ + 1.
                1. 단언: |Octets| 길이 = _n_.
                1. _Octets_ 가 유효한 UTF-8 코드 포인트 인코딩이 아니면 *URIError* throw.
                1. _V_ = UTF-8 변환을 적용해 얻은 코드 포인트.
                1. _S_ = UTF16EncodeCodePoint(_V_).
            1. _R_ = _R_ + _S_.
            1. _k_ = _k_ + 1.
          1. _R_ 반환.
        </emu-alg>
        <emu-note>
          <p>RFC 3629 는 잘못된 UTF-8 옥텟 시퀀스 디코딩을 금지한다. 예: 잘못된 시퀀스 0xC0 0x80 은 0x0000 으로 디코딩되어서는 안 된다. 구현은 그러한 시퀀스를 만나면 *URIError* 를 던져야 한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-parsehexoctet" type="abstract operation">
        <h1>
          ParseHexOctet (
            _string_: String,
            _position_: 음이 아닌 정수,
          ): 음이 아닌 정수 또는 비어있지 않은 *SyntaxError* 객체 리스트
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_string_ 의 _position_ 위치에 있는 두 개 16진 문자를 부호 없는 8비트 정수로 파싱한다.</dd>
        </dl>
        <emu-alg>
          1. _len_ = _string_ 길이.
          1. 단언: _position_ + 2 ≤ _len_.
          1. _hexDigits_ = _string_[_position_ .. _position_+2).
          1. _parseResult_ = ParseText(_hexDigits_, |HexDigits[~Sep]|).
          1. _parseResult_ 가 Parse Node 가 아니면 _parseResult_ 반환.
          1. _n_ = _parseResult_ 의 MV.
          1. 단언: 0 ≤ _n_ ≤ 255.
          1. _n_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>전역 객체의 생성자(Constructor) 프로퍼티</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-aggregate-error">
      <h1>AggregateError ( . . . )</h1>
      <p><emu-xref href="#sec-aggregate-error-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-array">
      <h1>Array ( . . . )</h1>
      <p><emu-xref href="#sec-array-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-arraybuffer">
      <h1>ArrayBuffer ( . . . )</h1>
      <p><emu-xref href="#sec-arraybuffer-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint">
      <h1>BigInt ( . . . )</h1>
      <p><emu-xref href="#sec-bigint-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint64array">
      <h1>BigInt64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-biguint64array">
      <h1>BigUint64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-boolean">
      <h1>Boolean ( . . . )</h1>
      <p><emu-xref href="#sec-boolean-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-dataview">
      <h1>DataView ( . . . )</h1>
      <p><emu-xref href="#sec-dataview-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-date">
      <h1>Date ( . . . )</h1>
      <p><emu-xref href="#sec-date-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-error">
      <h1>Error ( . . . )</h1>
      <p><emu-xref href="#sec-error-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-evalerror">
      <h1>EvalError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-finalization-registry" oldids="sec-constructor-properties-of-the-global-object-finnalization-registry">
      <h1>FinalizationRegistry ( . . . )</h1>
      <p><emu-xref href="#sec-finalization-registry-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-float16array">
      <h1>Float16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-float32array">
      <h1>Float32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-float64array">
      <h1>Float64Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-function">
      <h1>Function ( . . . )</h1>
      <p><emu-xref href="#sec-function-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-int8array">
      <h1>Int8Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-int16array">
      <h1>Int16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-int32array">
      <h1>Int32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-iterator">
      <h1>Iterator ( . . . )</h1>
      <p><emu-xref href="#sec-iterator-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-map">
      <h1>Map ( . . . )</h1>
      <p><emu-xref href="#sec-map-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-number">
      <h1>Number ( . . . )</h1>
      <p><emu-xref href="#sec-number-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-object">
      <h1>Object ( . . . )</h1>
      <p><emu-xref href="#sec-object-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-promise">
      <h1>Promise ( . . . )</h1>
      <p><emu-xref href="#sec-promise-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-proxy">
      <h1>Proxy ( . . . )</h1>
      <p><emu-xref href="#sec-proxy-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-rangeerror">
      <h1>RangeError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-referenceerror">
      <h1>ReferenceError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-regexp">
      <h1>RegExp ( . . . )</h1>
      <p><emu-xref href="#sec-regexp-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-set">
      <h1>Set ( . . . )</h1>
      <p><emu-xref href="#sec-set-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-sharedarraybuffer">
      <h1>SharedArrayBuffer ( . . . )</h1>
      <p><emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-string">
      <h1>String ( . . . )</h1>
      <p><emu-xref href="#sec-string-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-symbol">
      <h1>Symbol ( . . . )</h1>
      <p><emu-xref href="#sec-symbol-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-syntaxerror">
      <h1>SyntaxError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-typeerror">
      <h1>TypeError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint8array">
      <h1>Uint8Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint8clampedarray">
      <h1>Uint8ClampedArray ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint16array">
      <h1>Uint16Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-uint32array">
      <h1>Uint32Array ( . . . )</h1>
      <p><emu-xref href="#sec-typedarray-constructors"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-urierror">
      <h1>URIError ( . . . )</h1>
      <p><emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakmap">
      <h1>WeakMap ( . . . )</h1>
      <p><emu-xref href="#sec-weakmap-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakref">
      <h1>WeakRef ( . . . )</h1>
      <p><emu-xref href="#sec-weak-ref-constructor"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakset">
      <h1>WeakSet ( . . . )</h1>
      <p><emu-xref href="#sec-weakset-objects"></emu-xref> 참조.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-other-properties-of-the-global-object">
    <h1>전역 객체의 기타 프로퍼티</h1>

    <emu-clause id="sec-atomics">
      <h1>Atomics</h1>
      <p><emu-xref href="#sec-atomics-object"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-json">
      <h1>JSON</h1>
      <p><emu-xref href="#sec-json-object"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-math">
      <h1>Math</h1>
      <p><emu-xref href="#sec-math-object"></emu-xref> 참조.</p>
    </emu-clause>

    <emu-clause id="sec-reflect">
      <h1>Reflect</h1>
      <p><emu-xref href="#sec-reflect-object"></emu-xref> 참조.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>기본 객체 (Fundamental Objects)</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object 객체</h1>

    <emu-clause id="sec-object-constructor">
      <h1>Object 생성자</h1>
      <p>Object 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Object%</dfn> 이다.</li>
        <li>전역 객체 *"Object"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 일반(ordinary) 객체를 생성한다.</li>
        <li>생성자가 아니라 함수로 호출될 때 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다.</li>
      </ul>

      <emu-clause id="sec-object-value">
        <h1>Object ( [ _value_ ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 도 아니고 활성 함수 객체도 아니면
            1. ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*) 를 반환한다.
          1. _value_ 가 *undefined* 또는 *null* 이면 OrdinaryObjectCreate(%Object.prototype%) 를 반환한다.
          1. ! ToObject(_value_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Object 생성자의 프로퍼티</h1>
      <p>Object 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 갖는다.</li>
        <li>값이 *1*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 갖는다.</li>
        <li>다음 추가 프로퍼티들을 갖는다:</li>
      </ul>

      <emu-clause id="sec-object.assign">
        <h1>Object.assign ( _target_, ..._sources_ )</h1>
        <p>이 함수는 하나 이상의 소스 객체의 열거 가능하고 자체(own)인 모든 프로퍼티 값을 _target_ 객체로 복사한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _to_ 를 ? ToObject(_target_) 로 둔다.
          1. 인수가 하나만 전달되었다면 _to_ 를 반환한다.
          1. _sources_ 의 각 요소 _nextSource_ 에 대해
            1. _nextSource_ 가 *undefined* 도 *null* 도 아니면
              1. _from_ 을 ! ToObject(_nextSource_) 로 둔다.
              1. _keys_ 를 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
              1. _keys_ 의 각 요소 _nextKey_ 에 대해
                1. _desc_ 를 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_) 로 둔다.
                1. _desc_ 가 *undefined* 가 아니고 _desc_.[[Enumerable]] 가 *true* 이면
                  1. _propValue_ 를 ? Get(_from_, _nextKey_) 로 둔다.
                  1. ? Set(_to_, _nextKey_, _propValue_, *true*) 를 수행한다.
          1. _to_ 를 반환한다.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-object.create">
        <h1>Object.create ( _O_, _Properties_ )</h1>
        <p>이 함수는 지정된 프로토타입을 가진 새 객체를 생성한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니고 *null* 도 아니면 *TypeError* 예외를 throw 한다.
          1. _obj_ 를 OrdinaryObjectCreate(_O_) 로 둔다.
          1. _Properties_ 가 *undefined* 가 아니면
            1. ? ObjectDefineProperties(_obj_, _Properties_) 를 반환한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.defineproperties">
        <h1>Object.defineProperties ( _O_, _Properties_ )</h1>
        <p>이 함수는 객체에 자체 프로퍼티를 추가하고/또는 기존 자체 프로퍼티의 특성을 갱신한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *TypeError* 예외를 throw 한다.
          1. ? ObjectDefineProperties(_O_, _Properties_) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-objectdefineproperties" type="abstract operation">
          <h1>
            ObjectDefineProperties (
              _O_: Object,
              _Properties_: ECMAScript 언어 값,
            ): Object 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _props_ 를 ? ToObject(_Properties_) 로 둔다.
            1. _keys_ 를 ? <emu-meta effects="user-code">_props_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
            1. _descriptors_ 를 새 빈 리스트로 둔다.
            1. _keys_ 의 각 요소 _nextKey_ 에 대해
              1. _propDesc_ 를 ? <emu-meta effects="user-code">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_) 로 둔다.
              1. _propDesc_ 가 *undefined* 가 아니고 _propDesc_.[[Enumerable]] 가 *true* 이면
                1. _descObj_ 를 ? Get(_props_, _nextKey_) 로 둔다.
                1. _desc_ 를 ? ToPropertyDescriptor(_descObj_) 로 둔다.
                1. Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } 를 _descriptors_ 에 추가한다.
            1. _descriptors_ 의 각 요소 _property_ 에 대해
              1. ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]) 를 수행한다.
            1. _O_ 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.defineproperty">
        <h1>Object.defineProperty ( _O_, _P_, _Attributes_ )</h1>
        <p>이 함수는 객체에 자체 프로퍼티를 추가하고/또는 기존 자체 프로퍼티의 특성을 갱신한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *TypeError* 예외를 throw 한다.
          1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
          1. _desc_ 를 ? ToPropertyDescriptor(_Attributes_) 로 둔다.
          1. ? DefinePropertyOrThrow(_O_, _key_, _desc_) 를 수행한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.entries">
        <h1>Object.entries ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _entryList_ 를 ? EnumerableOwnProperties(_obj_, ~key+value~) 로 둔다.
          1. CreateArrayFromList(_entryList_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.freeze">
        <h1>Object.freeze ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? SetIntegrityLevel(_O_, ~frozen~) 으로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.fromentries" oldids="sec-create-data-property-on-object-functions">
        <h1>Object.fromEntries ( _iterable_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_iterable_) 를 수행한다.
          1. _obj_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. 단언: _obj_ 는 확장 가능하고 자체 프로퍼티가 없는 ordinary 객체.
          1. _closure_ 를 (_key_, _value_) 매개변수로 하고 _obj_ 를 캡처하며 호출 시 다음 단계를 수행하는 새 Abstract Closure 로 둔다:
            1. _propertyKey_ 를 ? ToPropertyKey(_key_) 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_) 를 수행한다.
            1. NormalCompletion(*undefined*) 를 반환한다.
          1. _adder_ 를 CreateBuiltinFunction(_closure_, 2, *""*, « ») 로 둔다.
          1. ? AddEntriesFromIterable(_obj_, _iterable_, _adder_) 를 반환한다.
        </emu-alg>
        <emu-note>
          _adder_ 용으로 생성된 함수는 ECMAScript 코드에서 직접 접근할 수 없다.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptor">
        <h1>Object.getOwnPropertyDescriptor ( _O_, _P_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
          1. _desc_ 를 ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
          1. FromPropertyDescriptor(_desc_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptors">
        <h1>Object.getOwnPropertyDescriptors ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _ownKeys_ 를 ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
          1. _descriptors_ 를 OrdinaryObjectCreate(%Object.prototype%) 로 둔다.
          1. _ownKeys_ 의 각 요소 _key_ 에 대해
            1. _desc_ 를 ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
            1. _descriptor_ 를 FromPropertyDescriptor(_desc_) 로 둔다.
            1. _descriptor_ 가 *undefined* 가 아니면 ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_) 를 수행한다.
          1. _descriptors_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertynames">
        <h1>Object.getOwnPropertyNames ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertysymbols">
        <h1>Object.getOwnPropertySymbols ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-getownpropertykeys" type="abstract operation">
          <h1>
            GetOwnPropertyKeys (
              _O_: ECMAScript 언어 값,
              _type_: ~string~ 또는 ~symbol~,
            ): 프로퍼티 키 리스트를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _obj_ 를 ? ToObject(_O_) 로 둔다.
            1. _keys_ 를 ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta> 로 둔다.
            1. _nameList_ 를 새 빈 리스트로 둔다.
            1. _keys_ 의 각 요소 _nextKey_ 에 대해
              1. _nextKey_ 가 Symbol 이고 _type_ 이 ~symbol~ 이거나, _nextKey_ 가 String 이고 _type_ 이 ~string~ 이면
                1. _nextKey_ 를 _nameList_ 에 추가한다.
            1. _nameList_ 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getprototypeof">
        <h1>Object.getPrototypeOf ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. ? <emu-meta effects="user-code">_obj_.[[GetPrototypeOf]]()</emu-meta> 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.groupby">
        <h1>Object.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ 은 두 개의 인수를 받는 함수여야 한다. `groupBy` 는 _items_ 의 각 요소에 대해 (오름차순으로) _callback_ 을 한 번 호출하고 새 객체를 구성한다. _callback_ 이 반환한 각 값은 프로퍼티 키로 강제 변환된다. 그러한 각 프로퍼티 키에 대해 결과 객체는 그 키를 프로퍼티 키로 가지며 값은 해당 키로 강제 변환된 _callback_ 반환 값을 가진 모든 요소를 담은 배열이다.</p>
          <p>_callback_ 은 (요소의 값, 요소의 인덱스) 두 인수로 호출된다.</p>
          <p>`groupBy` 의 반환 값은 %Object.prototype% 을 상속하지 않는 객체이다.</p>
        </emu-note>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _groups_ 를 ? GroupBy(_items_, _callback_, ~property~) 로 둔다.
          1. _obj_ 를 OrdinaryObjectCreate(*null*) 로 둔다.
          1. 각 Record { [[Key]], [[Elements]] } _g_ ∈ _groups_ 에 대해
            1. _elements_ 를 CreateArrayFromList(_g_.[[Elements]]) 로 둔다.
            1. ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_) 를 수행한다.
          1. _obj_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.hasown">
        <h1>Object.hasOwn ( _O_, _P_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
          1. ? HasOwnProperty(_obj_, _key_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.is">
        <h1>Object.is ( _value1_, _value2_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. SameValue(_value1_, _value2_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isextensible">
        <h1>Object.isExtensible ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *false* 를 반환한다.
          1. ? IsExtensible(_O_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isfrozen">
        <h1>Object.isFrozen ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *true* 를 반환한다.
          1. ? TestIntegrityLevel(_O_, ~frozen~) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.issealed">
        <h1>Object.isSealed ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 *true* 를 반환한다.
          1. ? TestIntegrityLevel(_O_, ~sealed~) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.keys">
        <h1>Object.keys ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _keyList_ 를 ? EnumerableOwnProperties(_obj_, ~key~) 로 둔다.
          1. CreateArrayFromList(_keyList_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.preventextensions">
        <h1>Object.preventExtensions ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? <emu-meta effects="user-code">_O_.[[PreventExtensions]]()</emu-meta> 로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype">
        <h1>Object.prototype</h1>
        <p>`Object.prototype` 의 초기 값은 Object 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-object.seal">
        <h1>Object.seal ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? SetIntegrityLevel(_O_, ~sealed~) 로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.setprototypeof">
        <h1>Object.setPrototypeOf ( _O_, _proto_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_O_) 를 수행한다.
          1. _proto_ 가 Object 가 아니고 *null* 도 아니면 *TypeError* 예외를 throw 한다.
          1. _O_ 가 Object 가 아니면 _O_ 를 반환한다.
          1. _status_ 를 ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_) 로 둔다.
          1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.values">
        <h1>Object.values ( _O_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _obj_ 를 ? ToObject(_O_) 로 둔다.
          1. _valueList_ 를 ? EnumerableOwnProperties(_obj_, ~value~) 로 둔다.
          1. CreateArrayFromList(_valueList_) 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-prototype-object" oldids="sec-additional-properties-of-the-object.prototype-object">
      <h1>Object 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Object 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Object.prototype%</dfn> 이다.</li>
        <li>값이 *true* 인 [[Extensible]] 내부 슬롯을 가진다.</li>
        <li>일반 객체에 대해 정의된 내부 메서드를 갖되 [[SetPrototypeOf]] 메서드는 <emu-xref href="#sec-immutable-prototype-exotic-objects-setprototypeof-v"></emu-xref> 에 정의된 대로이다. (즉, 변경 불가능한 프로토타입 특수 객체이다.)</li>
        <li>값이 *null* 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-object.prototype.constructor">
        <h1>Object.prototype.constructor</h1>
        <p>`Object.prototype.constructor` 의 초기 값은 %Object% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-object.prototype.hasownproperty">
        <h1>Object.prototype.hasOwnProperty ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. [id="step-hasownproperty-topropertykey"] _P_ 를 ? ToPropertyKey(_V_) 로 둔다.
          1. [id="step-hasownproperty-toobject"] _O_ 를 ? ToObject(*this* value) 로 둔다.
          1. ? HasOwnProperty(_O_, _P_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이전 판에서 step <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> 가 던졌을 예외가 *this* 값이 *undefined* 또는 *null* 이어도 계속 던져지도록 step 순서를 선택하였다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.isprototypeof">
        <h1>Object.prototype.isPrototypeOf ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. [id="step-isprototypeof-check-object"] _V_ 가 Object 가 아니면 *false* 반환.
          1. [id="step-isprototypeof-toobject"] _O_ 를 ? ToObject(*this* value) 로 둔다.
          1. 반복,
            1. _V_ 를 ? <emu-meta effects="user-code">_V_.[[GetPrototypeOf]]()</emu-meta> 로 둔다.
            1. _V_ 가 *null* 이면 *false* 반환.
            1. SameValue(_O_, _V_) 가 *true* 이면 *true* 반환.
        </emu-alg>
        <emu-note>
          <p>step <emu-xref href="#step-isprototypeof-check-object"></emu-xref> 와 <emu-xref href="#step-isprototypeof-toobject"></emu-xref> 순서는 _V_ 가 객체가 아니고 *this* 값이 *undefined* 또는 *null* 인 경우 이전 판 행동을 보존한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.propertyisenumerable">
        <h1>Object.prototype.propertyIsEnumerable ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. [id="step-propertyisenumerable-topropertykey"] _P_ 를 ? ToPropertyKey(_V_) 로 둔다.
          1. [id="step-propertyisenumerable-toobject"] _O_ 를 ? ToObject(*this* value) 로 둔다.
          1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_) 로 둔다.
          1. _desc_ 가 *undefined* 이면 *false* 반환.
          1. _desc_.[[Enumerable]] 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>이 메서드는 프로토타입 체인 상의 객체를 고려하지 않는다.</p>
        </emu-note>
        <emu-note>
          <p>이전 판에서 step <emu-xref href="#step-propertyisenumerable-topropertykey"></emu-xref> 가 던졌을 예외가 *this* 값이 *undefined* 또는 *null* 이어도 계속 던져지도록 순서를 선택하였다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tolocalestring">
        <h1>Object.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. ? Invoke(_O_, *"toString"*) 를 반환한다.
        </emu-alg>
        <p>이 메서드의 선택적 매개변수들은 사용되지 않지만 ECMA-402 `toLocaleString` 메서드의 매개변수 패턴과 대응하도록 의도되었다. ECMA-402 지원이 없는 구현은 그 매개변수 위치를 다른 목적으로 사용해서는 안 된다.</p>
        <emu-note>
          <p>이 메서드는 locale 에 민감한 `toString` 동작이 없는 객체를 위한 일반 `toLocaleString` 구현을 제공한다. `Array`, `Number`, `Date`, %TypedArray% 는 자체 locale 의존 `toLocaleString` 을 제공한다.</p>
        </emu-note>
        <emu-note>
          <p>ECMA-402 는 의도적으로 이 기본 구현의 대안을 제공하지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tostring">
        <h1>Object.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. *this* 값이 *undefined* 이면 *"[object Undefined]"* 를 반환한다.
          1. *this* 값이 *null* 이면 *"[object Null]"* 를 반환한다.
          1. _O_ 를 ! ToObject(*this* value) 로 둔다.
          1. _isArray_ 를 ? IsArray(_O_) 로 둔다.
          1. _isArray_ 가 *true* 이면 _builtinTag_ = *"Array"*.
          1. Else _O_ 가 [[ParameterMap]] 내부 슬롯을 가지면 _builtinTag_ = *"Arguments"*.
          1. Else _O_ 가 [[Call]] 내부 메서드를 가지면 _builtinTag_ = *"Function"*.
          1. Else _O_ 가 [[ErrorData]] 내부 슬롯을 가지면 _builtinTag_ = *"Error"*.
          1. Else _O_ 가 [[BooleanData]] 내부 슬롯을 가지면 _builtinTag_ = *"Boolean"*.
          1. Else _O_ 가 [[NumberData]] 내부 슬롯을 가지면 _builtinTag_ = *"Number"*.
          1. Else _O_ 가 [[StringData]] 내부 슬롯을 가지면 _builtinTag_ = *"String"*.
          1. Else _O_ 가 [[DateValue]] 내부 슬롯을 가지면 _builtinTag_ = *"Date"*.
          1. Else _O_ 가 [[RegExpMatcher]] 내부 슬롯을 가지면 _builtinTag_ = *"RegExp"*.
          1. Else _builtinTag_ = *"Object"*.
          1. _tag_ 를 ? Get(_O_, %Symbol.toStringTag%) 로 둔다.
          1. _tag_ 가 String 이 아니면 _tag_ = _builtinTag_.
          1. *"[object "*, _tag_, *"]"* 의 문자열 연결을 반환한다.
        </emu-alg>
        <emu-note>
          <p>과거 이 메서드는 이전 판에서 다양한 내장 객체의 공칭 타입 태그로 사용된 [[Class]] 내부 슬롯의 String 값을 얻기 위해 사용되기도 했다. 위 정의는 그러한 특정 종류의 내장 객체를 테스트하기 위해 `toString` 을 사용하는 레거시 코드와의 호환성을 유지한다. 이는 다른 종류의 내장 혹은 프로그램 정의 객체에 대해 신뢰할 수 있는 타입 테스트 메커니즘을 제공하지 않는다. 또한 프로그램은 %Symbol.toStringTag% 를 이용하여 이러한 레거시 타입 테스트의 신뢰성을 깨뜨릴 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.valueof">
        <h1>Object.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ToObject(*this* value) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype.__proto__" legacy normative-optional>
        <h1>Object.prototype.__proto__</h1>
        <p>`Object.prototype.__proto__` 는 특성 { [[Enumerable]]: *false*, [[Configurable]]: *true* } 를 가진 접근자 프로퍼티이다. [[Get]] 과 [[Set]] 특성은 다음과 같이 정의된다:</p>

        <emu-clause id="sec-get-object.prototype.__proto__">
          <h1>get Object.prototype.__proto__</h1>
          <p>[[Get]] 특성의 값은 인수를 요구하지 않는 내장 함수이다. 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-object.prototype.__proto__">
          <h1>set Object.prototype.__proto__</h1>
          <p>[[Set]] 특성의 값은 인수 _proto_ 를 받는 내장 함수이다. 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 *this* 값으로 둔다.
            1. ? RequireObjectCoercible(_O_) 를 수행한다.
            1. _proto_ 가 Object 가 아니고 *null* 도 아니면 *undefined* 를 반환한다.
            1. _O_ 가 Object 가 아니면 *undefined* 를 반환한다.
            1. _status_ 를 ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_) 로 둔다.
            1. _status_ 가 *false* 이면 *TypeError* 예외를 throw 한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.prototype-legacy-accessor-methods" legacy normative-optional>
        <h1>레거시 Object.prototype 접근자 메서드</h1>

        <emu-clause id="sec-object.prototype.__defineGetter__">
          <h1>Object.prototype.__defineGetter__ ( _P_, _getter_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. IsCallable(_getter_) 가 *false* 이면 *TypeError* 예외를 throw 한다.
            1. _desc_ 를 PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* } 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. ? DefinePropertyOrThrow(_O_, _key_, _desc_) 를 수행한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__defineSetter__">
          <h1>Object.prototype.__defineSetter__ ( _P_, _setter_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. IsCallable(_setter_) 가 *false* 이면 *TypeError* 예외를 throw 한다.
            1. _desc_ 를 PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* } 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. ? DefinePropertyOrThrow(_O_, _key_, _desc_) 를 수행한다.
            1. *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupGetter__">
          <h1>Object.prototype.__lookupGetter__ ( _P_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. 반복,
              1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
              1. _desc_ 가 *undefined* 가 아니면
                1. IsAccessorDescriptor(_desc_) 가 *true* 이면 _desc_.[[Get]] 를 반환한다.
                1. *undefined* 를 반환한다.
              1. _O_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> 로 둔다.
              1. _O_ 가 *null* 이면 *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupSetter__">
          <h1>Object.prototype.__lookupSetter__ ( _P_ )</h1>
          <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. _O_ 를 ? ToObject(*this* value) 로 둔다.
            1. _key_ 를 ? ToPropertyKey(_P_) 로 둔다.
            1. 반복,
              1. _desc_ 를 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_) 로 둔다.
              1. _desc_ 가 *undefined* 가 아니면
                1. IsAccessorDescriptor(_desc_) 가 *true* 이면 _desc_.[[Set]] 를 반환한다.
                1. *undefined* 를 반환한다.
              1. _O_ 를 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta> 로 둔다.
              1. _O_ 가 *null* 이면 *undefined* 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-object-instances">
      <h1>Object 인스턴스의 프로퍼티</h1>
      <p>Object 인스턴스는 Object 프로토타입 객체로부터 상속된 것 외의 특별한 프로퍼티를 가지지 않는다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function 객체</h1>

    <emu-clause id="sec-function-constructor">
      <h1>Function 생성자</h1>
      <p>Function 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Function%</dfn> 이다.</li>
        <li>전역 객체 *"Function"* 프로퍼티의 초기 값이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 함수 객체를 생성·초기화한다. 따라서 `Function(…)` 호출은 동일 인수를 가진 `new Function(…)` 표현식과 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 특정 Function 동작을 상속하려는 서브클래스 생성자는 내장 함수 동작에 필요한 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 Function 생성자에 `super` 호출을 포함해야 한다. 함수 객체를 정의하는 모든 ECMAScript 구문 형태는 Function 인스턴스를 생성한다. built-in GeneratorFunction, AsyncFunction, AsyncGeneratorFunction 서브클래스를 제외하고 Function 서브클래스 인스턴스를 만들 문법적 수단은 없다.</li>
      </ul>

      <emu-clause id="sec-function-p1-p2-pn-body">
        <h1>Function ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>마지막 인수(있다면)는 함수 본문(실행 코드)을 지정하며 그 앞의 인수들은 형식 매개변수를 지정한다.</p>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _C_ 를 활성 함수 객체로 둔다.
          1. _bodyArg_ 가 존재하지 않으면 빈 문자열로 설정한다.
          1. ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>각 형식 매개변수마다 하나의 인수를 두는 것은 허용되지만 필수는 아니다. 예를 들어 다음 세 표현식은 모두 동일 결과를 생성한다:</p>
          <pre><code class="javascript">
            new Function("a", "b", "c", "return a+b+c")
            new Function("a, b, c", "return a+b+c")
            new Function("a,b", "c", "return a+b+c")
          </code></pre>
        </emu-note>

        <emu-clause id="sec-createdynamicfunction" type="abstract operation" oldids="table-dynamic-function-sourcetext-prefixes">
          <h1>
            CreateDynamicFunction (
              _constructor_: 생성자,
              _newTarget_: 생성자 또는 *undefined*,
              _kind_: ~normal~, ~generator~, ~async~, 또는 ~async-generator~,
              _parameterArgs_: ECMAScript 언어 값 리스트,
              _bodyArg_: ECMAScript 언어 값,
            ): ECMAScript 함수 객체를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_constructor_ 는 이 동작을 수행 중인 생성자 함수. _newTarget_ 은 처음에 `new` 가 적용된 생성자. _parameterArgs_ 와 _bodyArg_ 는 _constructor_ 에 전달된 인수 값.</dd>
          </dl>
          <emu-alg>
            1. _newTarget_ 이 *undefined* 이면 _newTarget_ = _constructor_.
            1. _kind_ 가 ~normal~ 이면
              1. _prefix_ = *"function"*.
              1. _exprSym_ = |FunctionExpression|.
              1. _bodySym_ = |FunctionBody[~Yield, ~Await]|.
              1. _parameterSym_ = |FormalParameters[~Yield, ~Await]|.
              1. _fallbackProto_ = *"%Function.prototype%"*.
            1. Else if _kind_ = ~generator~ 이면
              1. _prefix_ = *"function\*"*.
              1. _exprSym_ = |GeneratorExpression|.
              1. _bodySym_ = |GeneratorBody|.
              1. _parameterSym_ = |FormalParameters[+Yield, ~Await]|.
              1. _fallbackProto_ = *"%GeneratorFunction.prototype%"*.
            1. Else if _kind_ = ~async~ 이면
              1. _prefix_ = *"async function"*.
              1. _exprSym_ = |AsyncFunctionExpression|.
              1. _bodySym_ = |AsyncFunctionBody|.
              1. _parameterSym_ = |FormalParameters[~Yield, +Await]|.
              1. _fallbackProto_ = *"%AsyncFunction.prototype%"*.
            1. Else
              1. 단언: _kind_ = ~async-generator~.
              1. _prefix_ = *"async function\*"*.
              1. _exprSym_ = |AsyncGeneratorExpression|.
              1. _bodySym_ = |AsyncGeneratorBody|.
              1. _parameterSym_ = |FormalParameters[+Yield, +Await]|.
              1. _fallbackProto_ = *"%AsyncGeneratorFunction.prototype%"*.
            1. _argCount_ = _parameterArgs_ 요소 수.
            1. _parameterStrings_ 를 새 빈 리스트로 둔다.
            1. _parameterArgs_ 의 각 요소 _arg_ 에 대해
              1. ? ToString(_arg_) 를 _parameterStrings_ 에 추가한다.
            1. _bodyString_ = ? ToString(_bodyArg_).
            1. _currentRealm_ = 현재 Realm Record.
            1. ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*) 수행.
            1. _P_ = 빈 문자열.
            1. _argCount_ > 0 이면
              1. _P_ = _parameterStrings_[0].
              1. _k_ = 1.
              1. 반복 (_k_ &lt; _argCount_)
                1. _nextArgString_ = _parameterStrings_[_k_].
                1. _P_ = _P_ + *","* + _nextArgString_.
                1. _k_ = _k_ + 1.
            1. _bodyParseString_ = 0x000A, _bodyString_, 0x000A 의 문자열 연결.
            1. _sourceString_ = _prefix_, *" anonymous("*, _P_, 0x000A, *") {"*, _bodyParseString_, *"}"* 의 문자열 연결.
            1. _sourceText_ = StringToCodePoints(_sourceString_).
            1. _parameters_ = ParseText(_P_, _parameterSym_).
            1. _parameters_ 가 오류 리스트이면 *SyntaxError* throw.
            1. _body_ = ParseText(_bodyParseString_, _bodySym_).
            1. _body_ 가 오류 리스트이면 *SyntaxError* throw.
            1. NOTE: 매개변수와 본문을 개별적으로 파싱하여 각각 단독으로 유효함을 보장.
            1. NOTE: 이 단계에 도달했다면 _sourceText_ 는 _exprSym_ 문법을 가져야 한다.
            1. _expr_ = ParseText(_sourceText_, _exprSym_).
            1. _expr_ 이 오류 리스트이면 *SyntaxError* throw.
            1. _proto_ = ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).
            1. _env_ = _currentRealm_.[[GlobalEnv]].
            1. _privateEnv_ = *null*.
            1. _F_ = OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_).
            1. SetFunctionName(_F_, *"anonymous"*).
            1. _kind_ = ~generator~ 이면
              1. _prototype_ = OrdinaryObjectCreate(%GeneratorPrototype%).
              1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ = ~async-generator~ 이면
              1. _prototype_ = OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
              1. ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ = ~normal~ 이면
              1. MakeConstructor(_F_) 수행.
            1. NOTE: _kind_ 이 ~async~ 인 함수는 constructable 하지 않다.
            1. _F_ 를 반환한다.
          </emu-alg>
          <emu-note>
            <p>CreateDynamicFunction 은 _kind_ 가 ~async~ 가 아닌 함수에 대해 생성자를 위해 사용할 가능성을 제공하기 위해 *"prototype"* 프로퍼티를 정의한다.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Function 생성자의 프로퍼티</h1>
      <p>Function 생성자는:</p>
      <ul>
        <li>자체가 내장 함수 객체이다.</li>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li oldids="sec-function.length">값이 *1*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-function.prototype">
        <h1>Function.prototype</h1>
        <p>`Function.prototype` 의 값은 Function 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Function 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Function 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Function.prototype%</dfn> 이다.</li>
        <li>자체가 내장 함수 객체이다.</li>
        <li>임의의 인수를 받아 호출되면 *undefined* 를 반환한다.</li>
        <li>[[Construct]] 내부 메서드를 가지지 않아 `new` 와 함께 생성자로 사용할 수 없다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>*"prototype"* 프로퍼티를 가지지 않는다.</li>
        <li>값이 *+0*<sub>𝔽</sub> 인 *"length"* 프로퍼티를 가진다.</li>
        <li>값이 빈 문자열인 *"name"* 프로퍼티를 가진다.</li>
      </ul>
      <emu-note>
        <p>Function 프로토타입 객체를 함수 객체로 지정한 것은 ECMAScript 2015 이전 코드와의 호환성을 보장하기 위함이다.</p>
      </emu-note>

      <emu-clause id="sec-function.prototype.apply">
        <h1>Function.prototype.apply ( _thisArg_, _argArray_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _func_ 을 *this* 값으로 둔다.
          1. IsCallable(_func_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _argArray_ 가 *undefined* 또는 *null* 이면
            1. PrepareForTailCall() 수행.
            1. ? Call(_func_, _thisArg_) 반환.
          1. _argList_ 를 ? CreateListFromArrayLike(_argArray_) 로 둔다.
          1. PrepareForTailCall() 수행.
          1. [id="step-function-proto-apply-call"] ? Call(_func_, _thisArg_, _argList_) 반환.
        </emu-alg>
        <emu-note>
          <p>_thisArg_ 값은 수정 없이 *this* 값으로 전달된다. 이는 3판과의 차이로, 그때는 *undefined* 또는 *null* _thisArg_ 가 전역 객체로 대체되고 다른 값에는 ToObject 가 적용되었다. 비엄격 함수는 진입 시 여전히 이러한 변환을 수행한다.</p>
        </emu-note>
        <emu-note>
          <p>_func_ 이 화살표 함수나 bound 함수 특수 객체라면 step <emu-xref href="#step-function-proto-apply-call"></emu-xref> 의 [[Call]] 에서 _thisArg_ 는 무시된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.bind">
        <h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _Target_ 을 *this* 값으로 둔다.
          1. IsCallable(_Target_) 이 *false* 이면 *TypeError* 예외 throw.
          1. _F_ 를 ? BoundFunctionCreate(_Target_, _thisArg_, _args_) 로 둔다.
          1. _L_ = 0.
          1. _targetHasLength_ = ? HasOwnProperty(_Target_, *"length"*).
          1. _targetHasLength_ *true* 이면
            1. _targetLen_ = ? Get(_Target_, *"length"*).
            1. _targetLen_ 이 Number 이면
              1. _targetLen_ = *+∞*<sub>𝔽</sub> 이면 _L_ = +∞.
              1. Else if _targetLen_ = *-∞*<sub>𝔽</sub> 이면 _L_ = 0.
              1. Else
                1. _targetLenAsInt_ = ! ToIntegerOrInfinity(_targetLen_).
                1. 단언: _targetLenAsInt_ 는 finite.
                1. _argCount_ = _args_ 요소 수.
                1. _L_ = max(_targetLenAsInt_ - _argCount_, 0).
          1. SetFunctionLength(_F_, _L_) 수행.
          1. _targetName_ = ? Get(_Target_, *"name"*).
          1. _targetName_ 이 String 이 아니면 빈 문자열로 설정.
          1. SetFunctionName(_F_, _targetName_, *"bound"*) 수행.
          1. _F_ 반환.
        </emu-alg>
        <emu-note>
          <p>`Function.prototype.bind` 로 생성된 함수 객체는 특수(exotic) 객체이며 *"prototype"* 프로퍼티를 가지지 않는다.</p>
        </emu-note>
        <emu-note>
          <p>_Target_ 이 화살표 함수나 bound 함수 특수 객체이면 이 메서드에 전달된 _thisArg_ 는 이후 _F_ 호출에서 사용되지 않는다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.call">
        <h1>Function.prototype.call ( _thisArg_, ..._args_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _func_ 을 *this* 값으로 둔다.
          1. IsCallable(_func_) *false* 이면 *TypeError* 예외 throw.
          1. PrepareForTailCall() 수행.
          1. [id="step-function-proto-call-call"] ? Call(_func_, _thisArg_, _args_) 반환.
        </emu-alg>
        <emu-note>
          <p>_thisArg_ 는 수정 없이 전달된다(3판과의 차이). 비엄격 함수는 진입 시 변환 수행.</p>
        </emu-note>
        <emu-note>
          <p>_func_ 이 화살표 또는 bound 함수 특수 객체이면 step <emu-xref href="#step-function-proto-call-call"></emu-xref> 의 [[Call]] 에서 _thisArg_ 는 무시된다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.constructor">
        <h1>Function.prototype.constructor</h1>
        <p>`Function.prototype.constructor` 의 초기 값은 %Function%.</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype.tostring">
        <h1>Function.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _func_ 을 *this* 값으로 둔다.
          1. _func_ 이 Object 이고 [[SourceText]] 내부 슬롯을 가지며 _func_.[[SourceText]] 가 유니코드 코드 포인트 시퀀스이고 HostHasSourceTextAvailable(_func_) 이 *true* 이면
            1. CodePointsToString(_func_.[[SourceText]]) 반환.
          1. _func_ 이 <emu-xref href="#sec-built-in-function-objects">내장 함수 객체</emu-xref> 이면 구현 정의 String 소스 표현을 반환한다. 표현은 |NativeFunction| 문법을 가져야 한다. 또한 _func_ 이 [[InitialName]] 내부 슬롯을 가지고 그것이 String 이면 반환된 String 중 |NativeFunctionAccessor?| |PropertyName| 에 매치될 부분은 그 값이어야 한다.
          1. _func_ 이 Object 이고 IsCallable(_func_) *true* 이면 구현 정의 String 소스 표현을 반환하며 문법은 |NativeFunction|.
          1. *TypeError* 예외 throw.
        </emu-alg>

        <emu-grammar type="definition">
          NativeFunction :
            `function` NativeFunctionAccessor? PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`

          NativeFunctionAccessor :
            `get`
            `set`
        </emu-grammar>
      </emu-clause>

      <emu-clause oldids="sec-function.prototype-@@hasinstance" id="sec-function.prototype-%symbol.hasinstance%">
        <h1>Function.prototype [ %Symbol.hasInstance% ] ( _V_ )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _F_ 를 *this* 값으로 둔다.
          1. ? OrdinaryHasInstance(_F_, _V_) 를 반환한다.
        </emu-alg>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>이것은 대부분의 함수가 상속하는 기본 `%Symbol.hasInstance%` 구현이다. `%Symbol.hasInstance%` 는 `instanceof` 연산자가 값이 특정 생성자의 인스턴스인지 판정하기 위해 호출한다. 다음 표현식은</p>
          <pre><code class="javascript">
            v instanceof F
          </code></pre>
          <p>다음과 같이 평가된다</p>
          <pre><code class="javascript">
            F[%Symbol.hasInstance%](v)
          </code></pre>
          <p>생성자 함수는 함수에 다른 `%Symbol.hasInstance%` 메서드를 노출하여 어떤 객체를 자신의 인스턴스로 인식할지 제어할 수 있다.</p>
        </emu-note>
        <p>이 프로퍼티는 bound 함수의 대상 함수를 전역적으로 노출할 수 있는 변조를 막기 위해 writable / configurable 이 아니다.</p>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.hasInstance]"* 이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-instances">
      <h1>Function 인스턴스</h1>
      <p>모든 Function 인스턴스는 ECMAScript 함수 객체이며 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 에 나열된 내부 슬롯을 가진다. `Function.prototype.bind` (<emu-xref href="#sec-function.prototype.bind"></emu-xref>) 로 생성된 함수 객체는 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 에 있는 내부 슬롯을 가진다.</p>
      <p>Function 인스턴스는 다음 프로퍼티를 가진다:</p>

      <emu-clause id="sec-function-instances-length">
        <h1>length</h1>
        <p>*"length"* 프로퍼티 값은 함수가 일반적으로 기대하는 인수 수를 나타내는 정수 Number 이다. 언어는 다른 수의 인수로 호출하는 것을 허용한다. 지정된 *"length"* 와 다른 인수 수로 호출될 때의 동작은 함수에 따라 다르다. 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-name">
        <h1>name</h1>
        <p>*"name"* 프로퍼티 값은 함수를 서술하는 String 이다. 이름은 의미론적 중요성을 갖지 않고 보통 ECMAScript 소스에서 정의 지점에서 그 함수를 참조하는 변수 또는 프로퍼티 이름이다. 이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        <p>명세에 의해 문맥적 이름이 연관되지 않은 익명 함수 객체는 빈 문자열을 *"name"* 값으로 사용한다.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-prototype">
        <h1>prototype</h1>
        <p>생성자로 사용할 수 있는 Function 인스턴스는 *"prototype"* 프로퍼티를 가진다. 그러한 Function 인스턴스가 생성될 때마다 또 다른 ordinary 객체가 생성되어 함수의 *"prototype"* 프로퍼티 초기 값이 된다. 달리 명시되지 않는 한 생성자로 그 함수가 호출될 때 생성되는 객체의 [[Prototype]] 내부 슬롯을 초기화하는 데 이 값이 사용된다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Function.prototype.bind` 로 생성되거나 |MethodDefinition| (|GeneratorMethod| 또는 |AsyncGeneratorMethod| 아님) 평가 또는 |ArrowFunction| 으로 생성된 함수 객체는 *"prototype"* 프로퍼티를 가지지 않는다.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-hosthassourcetextavailable" type="host-defined abstract operation">
      <h1>
        HostHasSourceTextAvailable (
          _func_: 함수 객체,
        ): Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>호스트 환경이 _func_ 의 소스 텍스트 제공을 차단할 수 있도록 한다.</dd>
      </dl>
      <p>HostHasSourceTextAvailable 구현은 다음 요구사항을 따른다:</p>
      <ul>
        <li>매개변수에 대해 결정적이어야 한다. 특정 _func_ 로 호출될 때마다 동일 결과를 반환해야 한다.</li>
      </ul>
      <p>기본 구현은 *true* 를 반환한다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean 객체</h1>

    <emu-clause id="sec-boolean-constructor">
      <h1>Boolean 생성자</h1>
      <p>Boolean 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Boolean%</dfn> 이다.</li>
        <li>전역 객체 *"Boolean"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 Boolean 객체를 생성·초기화한다.</li>
        <li>생성자가 아니라 함수로 호출되면 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Boolean 동작을 상속하려는 서브클래스 생성자는 [[BooleanData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 Boolean 생성자에 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-boolean-constructor-boolean-value">
        <h1>Boolean ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _b_ 를 ToBoolean(_value_) 로 둔다.
          1. NewTarget 이 *undefined* 이면 _b_ 를 반환한다.
          1. _O_ 를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Boolean.prototype%"*, « [[BooleanData]] ») 로 둔다.
          1. _O_.[[BooleanData]] = _b_ 로 설정한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Boolean 생성자의 프로퍼티</h1>
      <p>Boolean 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-boolean.prototype">
        <h1>Boolean.prototype</h1>
        <p>`Boolean.prototype` 의 초기 값은 Boolean 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Boolean 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Boolean 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Boolean.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>자체가 Boolean 객체이며 값이 *false* 인 [[BooleanData]] 내부 슬롯을 가진다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-boolean.prototype.constructor">
        <h1>Boolean.prototype.constructor</h1>
        <p>`Boolean.prototype.constructor` 의 초기 값은 %Boolean%.</p>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.tostring">
        <h1>Boolean.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _b_ 를 ? ThisBooleanValue(*this* value) 로 둔다.
          1. _b_ 가 *true* 이면 *"true"* 반환; 아니면 *"false"* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.valueof">
        <h1>Boolean.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisBooleanValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisbooleanvalue" type="abstract operation" oldids="thisbooleanvalue">
          <h1>
            ThisBooleanValue (
              _value_: ECMAScript 언어 값,
            ): Boolean 을 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 Boolean 이면 _value_ 반환.
            1. _value_ 가 Object 이고 [[BooleanData]] 내부 슬롯을 가지면
              1. _b_ 를 _value_.[[BooleanData]] 로 둔다.
              1. 단언: _b_ 는 Boolean.
              1. _b_ 반환.
            1. *TypeError* 예외 throw.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-boolean-instances">
      <h1>Boolean 인스턴스의 프로퍼티</h1>
      <p>Boolean 인스턴스는 Boolean 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. Boolean 인스턴스는 [[BooleanData]] 내부 슬롯을 가진다. [[BooleanData]] 내부 슬롯은 이 Boolean 객체가 나타내는 Boolean 값이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol 객체</h1>

    <emu-clause id="sec-symbol-constructor">
      <h1>Symbol 생성자</h1>
      <p>Symbol 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Symbol%</dfn> 이다.</li>
        <li>전역 객체 *"Symbol"* 프로퍼티의 초기 값이다.</li>
        <li>함수로 호출되면 새로운 Symbol 값을 반환한다.</li>
        <li>`new` 연산자와 함께 사용하도록 의도되지 않았다.</li>
        <li>서브클래싱을 의도하지 않는다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있으나 그에 대한 `super` 호출은 예외를 유발한다.</li>
      </ul>

      <emu-clause id="sec-symbol-description">
        <h1>Symbol ( [ _description_ ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 가 *undefined* 가 아니면 *TypeError* 예외를 throw 한다.
          1. _description_ 이 *undefined* 이면 _descString_ 을 *undefined* 로 둔다.
          1. 그렇지 않으면 _descString_ 을 ? ToString(_description_) 로 둔다.
          1. &#8288;[[Description]] 가 _descString_ 인 새 Symbol 을 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Symbol 생성자의 프로퍼티</h1>
      <p>Symbol 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-symbol.asynciterator">
        <h1>Symbol.asyncIterator</h1>
        <p>`Symbol.asyncIterator` 의 초기 값은 well-known symbol %Symbol.asyncIterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.for">
        <h1>Symbol.for ( _key_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. Let _stringKey_ be ? ToString(_key_).
          1. For each element _e_ of the GlobalSymbolRegistry List, do
            1. If _e_.[[Key]] is _stringKey_, return _e_.[[Symbol]].
          1. Assert: The GlobalSymbolRegistry List does not currently contain an entry for _stringKey_.
          1. Let _newSymbol_ be a new Symbol whose [[Description]] is _stringKey_.
          1. Append the GlobalSymbolRegistry Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.
          1. Return _newSymbol_.
        </emu-alg>
        <p><dfn>GlobalSymbolRegistry List</dfn> 는 전역적으로 이용 가능한 append-only 리스트이다. 모든 realm 이 공유한다. 어떤 ECMAScript 코드도 평가되기 전에 새 빈 리스트로 초기화된다. 요소는 <emu-xref href="#table-globalsymbolregistry-record-fields"></emu-xref> 에 정의된 구조의 Record 이다.</p>
        <emu-table id="table-globalsymbolregistry-record-fields" caption="GlobalSymbolRegistry Record 필드" oldids="table-44">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Usage
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                a String
              </td>
              <td>
                전역적으로 Symbol 을 식별하는 문자열 키.
              </td>
            </tr>
            <tr>
              <td>
                [[Symbol]]
              </td>
              <td>
                a Symbol
              </td>
              <td>
                어떤 realm 에서든 조회 가능한 symbol.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-symbol.hasinstance">
        <h1>Symbol.hasInstance</h1>
        <p>`Symbol.hasInstance` 의 초기 값은 well-known symbol %Symbol.hasInstance% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.isconcatspreadable">
        <h1>Symbol.isConcatSpreadable</h1>
        <p>`Symbol.isConcatSpreadable` 의 초기 값은 well-known symbol %Symbol.isConcatSpreadable% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.iterator">
        <h1>Symbol.iterator</h1>
        <p>`Symbol.iterator` 의 초기 값은 well-known symbol %Symbol.iterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.keyfor">
        <h1>Symbol.keyFor ( _sym_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _sym_ 이 Symbol 이 아니면 *TypeError* 예외 throw.
          1. KeyForSymbol(_sym_) 을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.match">
        <h1>Symbol.match</h1>
        <p>`Symbol.match` 의 초기 값은 well-known symbol %Symbol.match% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.matchall">
        <h1>Symbol.matchAll</h1>
        <p>`Symbol.matchAll` 의 초기 값은 well-known symbol %Symbol.matchAll% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype">
        <h1>Symbol.prototype</h1>
        <p>`Symbol.prototype` 의 초기 값은 Symbol 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.replace">
        <h1>Symbol.replace</h1>
        <p>`Symbol.replace` 의 초기 값은 well-known symbol %Symbol.replace% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.search">
        <h1>Symbol.search</h1>
        <p>`Symbol.search` 의 초기 값은 well-known symbol %Symbol.search% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.species">
        <h1>Symbol.species</h1>
        <p>`Symbol.species` 의 초기 값은 well-known symbol %Symbol.species% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.split">
        <h1>Symbol.split</h1>
        <p>`Symbol.split` 의 초기 값은 well-known symbol %Symbol.split% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.toprimitive">
        <h1>Symbol.toPrimitive</h1>
        <p>`Symbol.toPrimitive` 의 초기 값은 well-known symbol %Symbol.toPrimitive% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.tostringtag">
        <h1>Symbol.toStringTag</h1>
        <p>`Symbol.toStringTag` 의 초기 값은 well-known symbol %Symbol.toStringTag% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.unscopables">
        <h1>Symbol.unscopables</h1>
        <p>`Symbol.unscopables` 의 초기 값은 well-known symbol %Symbol.unscopables% (<emu-xref href="#table-well-known-symbols"></emu-xref>) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Symbol 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Symbol 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Symbol.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>Symbol 인스턴스가 아니며 [[SymbolData]] 내부 슬롯을 갖지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-symbol.prototype.constructor">
        <h1>Symbol.prototype.constructor</h1>
        <p>`Symbol.prototype.constructor` 의 초기 값은 %Symbol%.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.description">
        <h1>get Symbol.prototype.description</h1>
        <p>`Symbol.prototype.description` 은 set 접근자 함수가 *undefined* 인 접근자 프로퍼티이다. 그 get 접근자 함수는 호출 시 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _s_ 를 *this* 값으로 둔다.
          1. _sym_ 을 ? ThisSymbolValue(_s_) 로 둔다.
          1. _sym_.[[Description]] 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.tostring">
        <h1>Symbol.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _sym_ 을 ? ThisSymbolValue(*this* value) 로 둔다.
          1. SymbolDescriptiveString(_sym_) 을 반환한다.
        </emu-alg>

        <emu-clause id="sec-symboldescriptivestring" type="abstract operation">
          <h1>
            SymbolDescriptiveString (
              _sym_: Symbol,
            ): String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _desc_ = _sym_.[[Description]].
            1. _desc_ 가 *undefined* 이면 빈 문자열로 설정.
            1. 단언: _desc_ 는 String.
            1. *"Symbol("*, _desc_, *")"* 의 문자열 연결을 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.valueof">
        <h1>Symbol.prototype.valueOf ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisSymbolValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thissymbolvalue" type="abstract operation" oldids="thissymbolvalue">
          <h1>
            ThisSymbolValue (
              _value_: ECMAScript 언어 값,
            ): Symbol 을 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 Symbol 이면 _value_ 반환.
            1. _value_ 가 Object 이고 [[SymbolData]] 내부 슬롯을 가지면
              1. _s_ 를 _value_.[[SymbolData]] 로 둔다.
              1. 단언: _s_ 는 Symbol.
              1. _s_ 반환.
            1. *TypeError* 예외 throw.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@toprimitive" id="sec-symbol.prototype-%symbol.toprimitive%">
        <h1>Symbol.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>이 메서드는 ECMAScript 언어 연산자가 Symbol 객체를 원시 값으로 변환할 때 호출된다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. ? ThisSymbolValue(*this* value) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>인수는 무시된다.</p>
        </emu-note>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
        <p>이 메서드의 *"name"* 프로퍼티 값은 *"[Symbol.toPrimitive]"* 이다.</p>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@tostringtag" id="sec-symbol.prototype-%symbol.tostringtag%">
        <h1>Symbol.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 *"Symbol"* String 값이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-symbol-instances">
      <h1>Symbol 인스턴스의 프로퍼티</h1>
      <p>Symbol 인스턴스는 Symbol 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. Symbol 인스턴스는 [[SymbolData]] 내부 슬롯을 가진다. [[SymbolData]] 내부 슬롯은 이 Symbol 객체가 나타내는 Symbol 값이다.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-symbols">
      <h1>Symbol 을 위한 추상 연산</h1>

      <emu-clause id="sec-keyforsymbol" type="abstract operation">
        <h1>
          KeyForSymbol (
            _sym_: Symbol,
          ): String 또는 *undefined*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_sym_ 이 GlobalSymbolRegistry List 에 있으면 _sym_ 을 등록하는 데 사용된 String 이 반환된다.</dd>
        </dl>
        <emu-alg>
          1. GlobalSymbolRegistry List 의 각 요소 _e_ 에 대해
            1. SameValue(_e_.[[Symbol]], _sym_) 가 *true* 이면 _e_.[[Key]] 반환.
          1. 단언: GlobalSymbolRegistry List 에 현재 _sym_ 항목 없음.
          1. *undefined* 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error 객체</h1>
    <p>Error 객체 인스턴스는 런타임 오류 발생 시 예외로 throw 된다. Error 객체는 사용자 정의 예외 클래스의 기반 객체로도 사용될 수 있다.</p>
    <p>ECMAScript 구현이 런타임 오류를 감지하면 <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> 에 정의된 _NativeError_ 객체 중 하나의 새 인스턴스나 <emu-xref href="#sec-aggregate-error-objects"></emu-xref> 에 정의된 AggregateError 객체의 새 인스턴스를 throw 한다.</p>

    <emu-clause id="sec-error-constructor">
      <h1>Error 생성자</h1>
      <p>Error 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Error%</dfn> 이다.</li>
        <li>전역 객체 *"Error"* 프로퍼티의 초기 값이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 새 Error 객체를 생성·초기화한다. 따라서 `Error(…)` 호출은 동일 인수를 가진 `new Error(…)` 와 동등하다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Error 동작을 상속하려는 서브클래스 생성자는 [[ErrorData]] 내부 슬롯을 가진 서브클래스 인스턴스를 만들기 위해 Error 생성자에 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ [ , _options_ ] )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 이면 _newTarget_ = 활성 함수 객체; 아니면 _newTarget_ = NewTarget.
          1. _O_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Error.prototype%"*, « [[ErrorData]] ») 로 둔다.
          1. _message_ 가 *undefined* 가 아니면
            1. _msg_ = ? ToString(_message_).
            1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_) 수행.
          1. ? InstallErrorCause(_O_, _options_) 수행.
          1. _O_ 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Error 생성자의 프로퍼티</h1>
      <p>Error 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-error.iserror">
        <h1>Error.isError ( _arg_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _arg_ 가 Object 가 아니면 *false* 반환.
          1. _arg_ 가 [[ErrorData]] 내부 슬롯을 가지지 않으면 *false* 반환.
          1. *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-error.prototype">
        <h1>Error.prototype</h1>
        <p>`Error.prototype` 의 초기 값은 Error 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-prototype-object">
      <h1>Error 프로토타입 객체의 프로퍼티</h1>
      <p><dfn>Error 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Error.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>Error 인스턴스가 아니며 [[ErrorData]] 내부 슬롯을 갖지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>

      <emu-clause id="sec-error.prototype.constructor">
        <h1>Error.prototype.constructor</h1>
        <p>`Error.prototype.constructor` 의 초기 값은 %Error%.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.message">
        <h1>Error.prototype.message</h1>
        <p>`Error.prototype.message` 의 초기 값은 빈 문자열이다.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.name">
        <h1>Error.prototype.name</h1>
        <p>`Error.prototype.name` 의 초기 값은 *"Error"*.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.tostring">
        <h1>Error.prototype.toString ( )</h1>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _O_ 를 *this* 값으로 둔다.
          1. _O_ 가 Object 가 아니면 *TypeError* 예외 throw.
          1. _name_ = ? Get(_O_, *"name"*).
          1. _name_ 이 *undefined* 이면 _name_ = *"Error"*; 아니면 _name_ = ? ToString(_name_).
          1. _msg_ = ? Get(_O_, *"message"*).
          1. _msg_ 가 *undefined* 이면 _msg_ = 빈 문자열; 아니면 _msg_ = ? ToString(_msg_).
          1. _name_ 이 빈 문자열이면 _msg_ 반환.
          1. _msg_ 가 빈 문자열이면 _name_ 반환.
          1. _name_, 0x003A, 0x0020, _msg_ 의 문자열 연결을 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Error 인스턴스의 프로퍼티</h1>
      <p>Error 인스턴스는 Error 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이며 값이 *undefined* 인 [[ErrorData]] 내부 슬롯을 가진다. [[ErrorData]] 의 유일한 지정 용도는 `Object.prototype.toString` 과 `Error.isError` 에서 Error, AggregateError, _NativeError_ 인스턴스를 식별하는 것이다.</p>
    </emu-clause>

    <emu-clause id="sec-native-error-types-used-in-this-standard">
      <h1>이 표준에서 사용되는 Native Error 타입</h1>
      <p>런타임 오류가 감지되면 아래 _NativeError_ 객체 중 하나 또는 AggregateError 객체의 새 인스턴스가 throw 된다. 모든 _NativeError_ 객체는 <emu-xref href="#sec-nativeerror-object-structure"></emu-xref> 에 설명된 동일 구조를 공유한다.</p>

      <emu-clause id="sec-native-error-types-used-in-this-standard-evalerror">
        <h1>EvalError</h1>
        <p>EvalError 생성자는 <dfn>%EvalError%</dfn> 이다.</p>
        <p>이 예외는 현재 이 명세 내부에서는 사용되지 않는다. 이전 판과의 호환성을 위해 남아 있다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-rangeerror">
        <h1>RangeError</h1>
        <p>RangeError 생성자는 <dfn>%RangeError%</dfn> 이다.</p>
        <p>허용 가능한 값의 집합 또는 범위에 속하지 않는 값을 나타낸다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-referenceerror">
        <h1>ReferenceError</h1>
        <p>ReferenceError 생성자는 <dfn>%ReferenceError%</dfn> 이다.</p>
        <p>잘못된 참조가 감지되었음을 나타낸다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-syntaxerror">
        <h1>SyntaxError</h1>
        <p>SyntaxError 생성자는 <dfn>%SyntaxError%</dfn> 이다.</p>
        <p>파싱 오류가 발생했음을 나타낸다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-typeerror">
        <h1>TypeError</h1>
        <p>TypeError 생성자는 <dfn>%TypeError%</dfn> 이다.</p>
        <p>다른 _NativeError_ 객체 어느 것도 실패 원인을 적절히 나타내지 못할 때 실패한 연산을 나타내는 데 사용된다.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-urierror">
        <h1>URIError</h1>
        <p>URIError 생성자는 <dfn>%URIError%</dfn> 이다.</p>
        <p>글로벌 URI 처리 함수 중 하나가 그 정의와 호환되지 않는 방식으로 사용되었음을 나타낸다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ 객체 구조</h1>
      <p>이 객체 각각은 아래에 설명된 구조를 가지며, 생성자 이름과 프로토타입 객체의 *"name"* 프로퍼티만 다르다.</p>
      <p>각 error 객체에 대해 정의 내 _NativeError_ 참조는 <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> 의 해당 error 객체 이름으로 대체되어야 한다.</p>

      <emu-clause id="sec-nativeerror-constructors">
        <h1>_NativeError_ 생성자</h1>
        <p>각 _NativeError_ 생성자는:</p>
        <ul>
          <li>생성자가 아니라 함수로 호출될 때 새 _NativeError_ 객체를 생성·초기화한다. 함수 호출 <code><var>NativeError</var>(&hellip;)</code> 는 동일 인수를 가진 <code>new <var>NativeError</var>(&hellip;)</code> 와 동등하다.</li>
          <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 _NativeError_ 동작을 상속하려는 서브클래스 생성자는 [[ErrorData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 _NativeError_ 생성자에 `super` 호출을 포함해야 한다.</li>
        </ul>

        <emu-clause id="sec-nativeerror">
          <h1>_NativeError_ ( _message_ [ , _options_ ] )</h1>
          <p>각 _NativeError_ 함수는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. NewTarget 이 *undefined* 이면 _newTarget_ = 활성 함수 객체; 아니면 _newTarget_ = NewTarget.
            1. [id="step-nativeerror-ordinarycreatefromconstructor"] _O_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>.prototype%"</code>, « [[ErrorData]] ») 로 둔다.
            1. _message_ 가 *undefined* 가 아니면
              1. _msg_ = ? ToString(_message_).
              1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_) 수행.
            1. ? InstallErrorCause(_O_, _options_) 수행.
            1. _O_ 반환.
          </emu-alg>
          <p>step <emu-xref href="#step-nativeerror-ordinarycreatefromconstructor"></emu-xref> 에 전달되는 문자열의 실제 값은 정의 중인 _NativeError_ 생성자에 따라 *"%EvalError.prototype%"*, *"%RangeError.prototype%"*, *"%ReferenceError.prototype%"*, *"%SyntaxError.prototype%"*, *"%TypeError.prototype%"*, *"%URIError.prototype%"* 중 하나이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>_NativeError_ 생성자의 프로퍼티</h1>
        <p>각 _NativeError_ 생성자는:</p>
        <ul>
          <li>값이 %Error% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>값이 String <emu-val>"<var>NativeError</var>"</emu-val> 인 *"name"* 프로퍼티를 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype">
          <h1>_NativeError_.prototype</h1>
          <p><code><var>NativeError</var>.prototype</code> 의 초기 값은 _NativeError_ 프로토타입 객체 (<emu-xref href="#sec-properties-of-the-nativeerror-prototype-objects"></emu-xref>). 각 _NativeError_ 생성자는 서로 다른 프로토타입 객체를 가진다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-prototype-objects">
        <h1>_NativeError_ 프로토타입 객체의 프로퍼티</h1>
        <p>각 <dfn>_NativeError_ 프로토타입 객체</dfn>는:</p>
        <ul>
          <li>ordinary 객체이다.</li>
          <li>Error 인스턴스가 아니며 [[ErrorData]] 내부 슬롯을 갖지 않는다.</li>
          <li>값이 %Error.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype.constructor">
          <h1>_NativeError_.prototype.constructor</h1>
          <p>특정 _NativeError_ 생성자에 대한 프로토타입의 *"constructor"* 프로퍼티 초기 값은 그 생성자 자체이다.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.message">
          <h1>_NativeError_.prototype.message</h1>
          <p>특정 _NativeError_ 생성자 프로토타입의 *"message"* 프로퍼티 초기 값은 빈 문자열이다.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.name">
          <h1>_NativeError_.prototype.name</h1>
          <p>특정 _NativeError_ 생성자 프로토타입의 *"name"* 프로퍼티 초기 값은 ( _NativeError_ 대신 사용되는 ) 생성자의 이름으로 이루어진 String 값이다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>_NativeError_ 인스턴스의 프로퍼티</h1>
        <p>_NativeError_ 인스턴스는 해당 _NativeError_ 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이며 값이 *undefined* 인 [[ErrorData]] 내부 슬롯을 가진다. [[ErrorData]] 의 유일한 지정 용도는 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 과 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 에서 Error, AggregateError 또는 _NativeError_ 인스턴스를 식별하는 것이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError 객체</h1>

      <emu-clause id="sec-aggregate-error-constructor">
        <h1>AggregateError 생성자</h1>
        <p>AggregateError 생성자는 다음과 같다:</p>
        <ul>
          <li><dfn>%AggregateError%</dfn> 이다.</li>
          <li>전역 객체 *"AggregateError"* 프로퍼티의 초기 값이다.</li>
          <li>생성자가 아니라 함수로 호출될 때 새 AggregateError 객체를 생성·초기화한다. 따라서 `AggregateError(…)` 호출은 동일 인수를 가진 `new AggregateError(…)` 와 동등하다.</li>
          <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 AggregateError 동작을 상속하려는 서브클래스 생성자는 [[ErrorData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 AggregateError 생성자에 `super` 호출을 포함해야 한다.</li>
        </ul>

        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
          <emu-alg>
            1. NewTarget 이 *undefined* 이면 _newTarget_ = 활성 함수 객체; 아니면 _newTarget_ = NewTarget.
            1. _O_ 를 ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, « [[ErrorData]] ») 로 둔다.
            1. _message_ 가 *undefined* 가 아니면
              1. _msg_ = ? ToString(_message_).
              1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_) 수행.
            1. ? InstallErrorCause(_O_, _options_) 수행.
            1. _errorsList_ 를 ? IteratorToList(? GetIterator(_errors_, ~sync~)) 로 둔다.
            1. ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }) 수행.
            1. _O_ 반환.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructors">
        <h1>AggregateError 생성자의 프로퍼티</h1>
        <p>AggregateError 생성자는:</p>
        <ul>
          <li>값이 %Error% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
          <li>다음 프로퍼티들을 가진다:</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype">
          <h1>AggregateError.prototype</h1>
          <p>`AggregateError.prototype` 의 초기 값은 %AggregateError.prototype% 이다.</p>
          <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-prototype-objects">
        <h1>AggregateError 프로토타입 객체의 프로퍼티</h1>
        <p><dfn>AggregateError 프로토타입 객체</dfn>는:</p>
        <ul>
          <li><dfn>%AggregateError.prototype%</dfn> 이다.</li>
          <li>ordinary 객체이다.</li>
          <li>Error 인스턴스나 AggregateError 인스턴스가 아니며 [[ErrorData]] 내부 슬롯을 갖지 않는다.</li>
          <li>값이 %Error.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype.constructor">
          <h1>AggregateError.prototype.constructor</h1>
          <p>`AggregateError.prototype.constructor` 의 초기 값은 %AggregateError%.</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.message">
          <h1>AggregateError.prototype.message</h1>
          <p>`AggregateError.prototype.message` 의 초기 값은 빈 문자열이다.</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.name">
          <h1>AggregateError.prototype.name</h1>
          <p>`AggregateError.prototype.name` 의 초기 값은 *"AggregateError"*.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-aggregate-error-instances">
        <h1>AggregateError 인스턴스의 프로퍼티</h1>
        <p>AggregateError 인스턴스는 해당 AggregateError 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이며 값이 *undefined* 인 [[ErrorData]] 내부 슬롯을 가진다. [[ErrorData]] 의 유일한 지정 용도는 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 과 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 에서 Error, AggregateError, _NativeError_ 인스턴스를 식별하는 것이다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-error-objects">
      <h1>Error 객체를 위한 추상 연산</h1>

      <emu-clause id="sec-installerrorcause" type="abstract operation">
        <h1>
          InstallErrorCause (
            _O_: Object,
            _options_: ECMAScript 언어 값,
          ): ~unused~ 를 담은 정상 completion 또는 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_options_ 에 *"cause"* 프로퍼티가 존재할 때 _O_ 에 *"cause"* 프로퍼티를 생성하는 데 사용된다.</dd>
        </dl>
        <emu-alg>
          1. _options_ 가 Object 이고 ? HasProperty(_options_, *"cause"*) 가 *true* 이면
            1. _cause_ 를 ? Get(_options_, *"cause"*) 로 둔다.
            1. CreateNonEnumerableDataPropertyOrThrow(_O_, *"cause"*, _cause_) 수행.
          1. ~unused~ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>숫자와 날짜 (Numbers and Dates)</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number 객체 (Number Objects)</h1>

    <emu-clause id="sec-number-constructor">
      <h1>Number 생성자 (The Number Constructor)</h1>
      <p>Number 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%Number%</dfn> 이다.</li>
        <li>전역 객체 *"Number"* 프로퍼티의 초기 값이다.</li>
        <li>생성자로 호출될 때 새로운 Number 객체를 생성하고 초기화한다.</li>
        <li>생성자가 아니라 함수로 호출될 때 타입 변환을 수행한다.</li>
        <li>클래스 정의의 `extends` 절 값으로 사용할 수 있다. 지정된 Number 동작을 상속하려는 서브클래스 생성자는 [[NumberData]] 내부 슬롯을 가진 서브클래스 인스턴스를 생성·초기화하기 위해 Number 생성자에 대한 `super` 호출을 포함해야 한다.</li>
      </ul>

      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _value_ 가 존재하면
            1. _prim_ 을 ? ToNumeric(_value_) 로 둔다.
            1. _prim_ 이 BigInt 이면 _n_ 을 𝔽(ℝ(_prim_)) 로 둔다.
            1. 그렇지 않으면 _n_ 을 _prim_ 으로 둔다.
          1. 그렇지 않으면,
            1. _n_ 을 *+0*<sub>𝔽</sub> 로 둔다.
          1. NewTarget 이 *undefined* 이면 _n_ 을 반환한다.
          1. _O_ 를 ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] ») 로 둔다.
          1. _O_.[[NumberData]] 를 _n_ 으로 설정한다.
          1. _O_ 를 반환한다.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Number 생성자의 프로퍼티 (Properties of the Number Constructor)</h1>
      <p>Number 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-number.epsilon">
        <h1>Number.EPSILON</h1>
        <p>`Number.EPSILON` 의 값은 1과, Number 값으로 표현 가능한 1보다 큰 가장 작은 값 사이의 차이의 크기(Number 값)이며, 약 2.2204460492503130808472633361816 × 10<sup>-16</sup>이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.isfinite">
        <h1>Number.isFinite ( _number_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 Number 가 아니면 *false* 반환.
          1. _number_ 가 finite 가 아니면 *false* 반환.
          1. 그렇지 않으면 *true* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isinteger">
        <h1>Number.isInteger ( _number_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 정수(Number) 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isnan">
        <h1>Number.isNaN ( _number_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 Number 가 아니면 *false* 반환.
          1. _number_ 가 *NaN* 이면 *true* 반환.
          1. 그렇지 않으면 *false* 반환.
        </emu-alg>
        <emu-note>
          <p>이 함수는 인수를 *NaN* 인지 판정하기 전에 Number 로 변환한다는 점에서 전역 isNaN 함수(<emu-xref href="#sec-isnan-number"></emu-xref>)와 다르다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.issafeinteger">
        <h1>Number.isSafeInteger ( _number_ )</h1>
        <emu-note>
          <p>정수 _n_ 이 "<dfn id="safe-integer">안전한 정수(safe integer)</dfn>" 이려면, 그리고 그럴 때에 한해 _n_ 의 Number 값이 다른 어떤 정수의 Number 값과 같지 않아야 한다.</p>
        </emu-note>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _number_ 가 정수(Number) 이면
            1. abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1 이면 *true* 반환.
          1. *false* 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.max_safe_integer">
        <h1>Number.MAX_SAFE_INTEGER</h1>
        <emu-note>
          <p>IEEE 754-2019의 정밀도 한계로 인한 반올림 동작 때문에 `Number.MAX_SAFE_INTEGER` 보다 큰 모든 정수의 Number 값은 최소 하나 이상의 다른 정수와 공유된다. 그러한 큰 크기의 정수들은 <emu-xref href="#safe-integer">안전</emu-xref>하지 않으며 Number 값으로 정확히 표현되거나 서로 구별될 수 있음을 보장하지 않는다. 예를 들어 `9007199254740992` 와 `9007199254740993` 은 모두 Number 값 *9007199254740992*<sub>𝔽</sub> 로 평가된다.</p>
        </emu-note>
        <p>`Number.MAX_SAFE_INTEGER` 의 값은 *9007199254740991*<sub>𝔽</sub> (𝔽(2<sup>53</sup> - 1)) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.max_value">
        <h1>Number.MAX_VALUE</h1>
        <p>`Number.MAX_VALUE` 의 값은 Number 타입의 가장 큰 양의 유한 값이며, 이는 대략 <emu-eqn>1.7976931348623157 × 10<sup>308</sup></emu-eqn> 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_safe_integer">
        <h1>Number.MIN_SAFE_INTEGER</h1>
        <emu-note>
          <p>IEEE 754-2019의 정밀도 한계로 인한 반올림 동작 때문에 `Number.MIN_SAFE_INTEGER` 보다 작은 모든 정수의 Number 값은 최소 하나 이상의 다른 정수와 공유된다. 그러한 큰 크기의(절대값이 큰) 정수들은 <emu-xref href="#safe-integer">안전</emu-xref>하지 않으며 Number 값으로 정확히 표현되거나 서로 구별될 수 있음을 보장하지 않는다. 예를 들어 `-9007199254740992` 와 `-9007199254740993` 은 모두 Number 값 *-9007199254740992*<sub>𝔽</sub> 로 평가된다.</p>
        </emu-note>
        <p>`Number.MIN_SAFE_INTEGER` 의 값은 *-9007199254740991*<sub>𝔽</sub> (𝔽(-(2<sup>53</sup> - 1))) 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_value">
        <h1>Number.MIN_VALUE</h1>
        <p>`Number.MIN_VALUE` 의 값은 Number 타입의 가장 작은 양의 값이며, 이는 대략 <emu-eqn>5 × 10<sup>-324</sup></emu-eqn> 이다.</p>
        <p>IEEE 754-2019 배정밀도 이진 표현에서 가장 작은 가능한 값은 비정규(denormalized) 수이다. 구현이 비정규 값을 지원하지 않는다면 `Number.MIN_VALUE` 의 값은 구현이 실제로 표현할 수 있는 가장 작은 0이 아닌 양의 값이어야 한다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.nan">
        <h1>Number.NaN</h1>
        <p>`Number.NaN` 의 값은 *NaN* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.negative_infinity">
        <h1>Number.NEGATIVE_INFINITY</h1>
        <p>`Number.NEGATIVE_INFINITY` 의 값은 *-∞*<sub>𝔽</sub> 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.parsefloat">
        <h1>Number.parseFloat ( _string_ )</h1>
        <p>*"parseFloat"* 프로퍼티의 초기 값은 %parseFloat% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.parseint">
        <h1>Number.parseInt ( _string_, _radix_ )</h1>
        <p>*"parseInt"* 프로퍼티의 초기 값은 %parseInt% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.positive_infinity">
        <h1>Number.POSITIVE_INFINITY</h1>
        <p>`Number.POSITIVE_INFINITY` 의 값은 *+∞*<sub>𝔽</sub> 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype">
        <h1>Number.prototype</h1>
        <p>`Number.prototype` 의 초기 값은 Number 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Number 프로토타입 객체의 프로퍼티 (Properties of the Number Prototype Object)</h1>
      <p><dfn>Number 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%Number.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>자체가 Number 객체이며 값이 *+0*<sub>𝔽</sub> 인 [[NumberData]] 내부 슬롯을 가진다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <p>명시적으로 달리 언급되지 않는 한 아래 정의된 Number 프로토타입 객체의 메서드는 generic 하지 않으며, 그들에게 전달된 *this* 값은 Number 값이거나 Number 값으로 초기화된 [[NumberData]] 내부 슬롯을 가진 객체여야 한다.</p>
      <p>메서드 명세 안의 “this Number value” 라는 문구는 해당 메서드 호출의 *this* 값을 인수로 하여 추상 연산 ThisNumberValue 를 호출한 결과를 의미한다.</p>

      <emu-clause id="sec-number.prototype.constructor">
        <h1>Number.prototype.constructor</h1>
        <p>`Number.prototype.constructor` 의 초기 값은 %Number% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toexponential">
        <h1>Number.prototype.toExponential ( _fractionDigits_ )</h1>
        <p>이 메서드는 이 Number 값을 십진 지수 표기(유효숫자 부분의 소수점 앞에 한 자리, 소수점 뒤에 _fractionDigits_ 자리)로 표현한 String 을 반환한다. _fractionDigits_ 가 *undefined* 이면, (항상 지수 표기로 출력된다는 점을 제외하면 ToString 과 같이) Number 를 유일하게 지정하는 데 필요한 만큼의 유효숫자 자릿수를 포함한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _f_ 를 ? ToIntegerOrInfinity(_fractionDigits_) 로 둔다.
          1. 단언: _fractionDigits_ 가 *undefined* 이면 _f_ 는 0.
          1. _x_ 가 finite 가 아니면 Number::toString(_x_, 10) 반환.
          1. _f_ &lt; 0 또는 _f_ > 100 이면 *RangeError* 예외 throw.
          1. _x_ 를 ℝ(_x_) 로 설정.
          1. _s_ 를 빈 문자열로 둔다.
          1. _x_ &lt; 0 이면
            1. _s_ = *"-"*.
            1. _x_ = -_x_.
          1. _x_ = 0 이면
            1. _m_ 을 _f_ + 1 번의 코드 유닛 0x0030 (DIGIT ZERO) 로 구성된 String 값으로 둔다.
            1. _e_ = 0.
          1. 그렇지 않으면,
            1. _fractionDigits_ 가 *undefined* 가 아니면
              1. 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup> 이고 _n_ × 10<sup>_e_ - _f_</sup> - _x_ 가 0 에 가장 가깝도록 하는 정수 _e_, _n_ 을 둔다. 그러한 ( _e_, _n_ ) 이 두 개 있으면 _n_ × 10<sup>_e_ - _f_</sup> 가 더 큰 것을 고른다.
            1. 그렇지 않으면,
              1. [id="step-number-proto-toexponential-intermediate-values"] _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ &lt; 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) 가 𝔽(_x_), 그리고 _ff_ 가 가능한 한 작은 정수인 _e_, _n_, _ff_ 를 둔다. 이때 _n_ 의 십진 표현은 _ff_ + 1 자리이며, _n_ 은 10 으로 나누어떨어지지 않고, _n_ 의 최하위 자리는 유일하게 결정되지 않을 수 있다.
              1. _f_ = _ff_.
            1. _m_ 을 _n_ 의 십진 표현의 자릿수들(선행 0 없이 순서대로)로 구성된 String 값으로 둔다.
          1. _f_ ≠ 0 이면
            1. _a_ = _m_ 의 첫 코드 유닛.
            1. _b_ = 나머지 _f_ 개의 코드 유닛.
            1. _m_ = _a_, *"."*, _b_ 의 문자열 연결.
          1. _e_ = 0 이면
            1. _c_ = *"+"*.
            1. _d_ = *"0"*.
          1. 그렇지 않으면,
            1. _e_ > 0 이면
              1. _c_ = *"+"*.
            1. 그렇지 않으면
              1. 단언: _e_ &lt; 0.
              1. _c_ = *"-"*.
              1. _e_ = -_e_.
            1. _d_ = _e_ 의 십진 표현 자릿수들(선행 0 없이)로 구성된 String 값.
          1. _m_ = _m_, *"e"*, _c_, _d_ 의 문자열 연결.
          1. _s_ 와 _m_ 의 문자열 연결을 반환한다.
        </emu-alg>
        <emu-note>
          <p>위 규칙이 요구하는 것보다 더 정확한 변환을 제공하는 구현은 step <emu-xref href="#step-number-proto-toexponential-intermediate-values"></emu-xref> 의 다음 대안 버전을 지침으로 사용하는 것이 권장된다:</p>
          <emu-alg replaces-step="step-number-proto-toexponential-intermediate-values">
            1. _f_ ≥ 0, 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _f_</sup>) 가 𝔽(_x_), 그리고 _f_ 가 가능한 한 작은 정수인 _e_, _n_, _f_ 를 둔다. _n_ 의 후보가 여러 개면 𝔽(_n_ × 10<sup>_e_ - _f_</sup>) 가 𝔽(_x_) 에 가장 가까운 값을 선택한다. 그런 후보가 두 개면 짝수인 것을 선택한다.
          </emu-alg>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tofixed">
        <h1>Number.prototype.toFixed ( _fractionDigits_ )</h1>
        <emu-note>
          <p>이 메서드는 이 Number 값을 십진 고정 소수점 표기로 표시한 String 을 반환하며 소수점 이하 자리수는 _fractionDigits_ 이다. _fractionDigits_ 가 *undefined* 이면 0 으로 간주한다.</p>
        </emu-note>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _f_ 를 ? ToIntegerOrInfinity(_fractionDigits_) 로 둔다.
          1. 단언: _fractionDigits_ 가 *undefined* 이면 _f_ = 0.
          1. _f_ 가 finite 가 아니면 *RangeError* 예외 throw.
          1. _f_ &lt; 0 또는 _f_ > 100 이면 *RangeError* 예외 throw.
          1. _x_ 가 finite 가 아니면 Number::toString(_x_, 10) 반환.
          1. _x_ = ℝ(_x_).
          1. _s_ = 빈 문자열.
          1. _x_ &lt; 0 이면
            1. _s_ = *"-"*.
            1. _x_ = -_x_.
          1. _x_ ≥ 10<sup>21</sup> 이면
            1. _m_ = ! ToString(𝔽(_x_)).
          1. 그렇지 않으면
            1. _n_ 을 _n_ / 10<sup>_f_</sup> - _x_ 가 0 에 가장 가깝도록 하는 정수로 둔다. 그런 _n_ 이 두 개면 더 큰 _n_ 선택.
            1. _n_ = 0 이면 _m_ = *"0"*; 아니면 _m_ = _n_ 의 십진 표현 자릿수(선행 0 없이).
            1. _f_ ≠ 0 이면
              1. _k_ = _m_ 의 길이.
              1. _k_ ≤ _f_ 이면
                1. _z_ = _f_ + 1 - _k_ 번의 코드 유닛 0x0030 (DIGIT ZERO) 로 구성된 String.
                1. _m_ = _z_ 와 _m_ 의 문자열 연결.
                1. _k_ = _f_ + 1.
              1. _a_ = _m_ 의 처음 _k_ - _f_ 코드 유닛.
              1. _b_ = 나머지 _f_ 코드 유닛.
              1. _m_ = _a_, *"."*, _b_ 의 문자열 연결.
          1. _s_ 와 _m_ 의 문자열 연결을 반환한다.
        </emu-alg>
        <emu-note>
          <p>`toFixed` 의 출력은 어떤 값들에 대해 `toString` 보다 더 정밀할 수 있다. 이는 toString 이 인접한 Number 값들과 구별하기 위한 충분한 유효숫자만을 출력하기 때문이다. 예를 들어,</p>
          <p>
            `(1000000000000000128).toString()` 은 *"1000000000000000100"* 을 반환하고,<br>
            `(1000000000000000128).toFixed(0)` 은 *"1000000000000000128"* 을 반환한다.
          </p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tolocalestring">
        <h1>Number.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API 를 포함하는 ECMAScript 구현은 이 메서드를 ECMA-402 명세에 따라 구현해야 한다. 구현이 ECMA-402 API 를 포함하지 않는 경우 다음 명세가 사용된다:</p>
        <p>이 메서드는 호스트 환경의 현재 로케일 관례에 따라 포맷된 이 Number 값을 나타내는 String 값을 생성한다. 이 메서드는 구현 정의이며 `toString` 과 같은 결과를 반환하는 것이 허용되나 권장되지는 않는다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의된다; ECMA-402 를 지원하지 않는 구현은 그 매개변수 위치를 다른 용도로 사용해서는 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toprecision">
        <h1>Number.prototype.toPrecision ( _precision_ )</h1>
        <p>이 메서드는 이 Number 값을 (유효숫자 부분 소수점 앞에 한 자리, 소수점 뒤에 <emu-eqn>_precision_ - 1</emu-eqn> 자리)인 십진 지수 표기 또는 _precision_ 개의 유효숫자를 갖는 십진 고정 표기 중 하나로 표현한 String 을 반환한다. _precision_ 이 *undefined* 이면 대신 ToString 을 호출한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _precision_ 이 *undefined* 이면 ! ToString(_x_) 반환.
          1. _p_ 를 ? ToIntegerOrInfinity(_precision_) 로 둔다.
          1. _x_ 가 finite 가 아니면 Number::toString(_x_, 10) 반환.
          1. _p_ &lt; 1 또는 _p_ > 100 이면 *RangeError* 예외 throw.
          1. _x_ = ℝ(_x_).
          1. _s_ = 빈 문자열.
          1. _x_ &lt; 0 이면
            1. _s_ = 코드 유닛 0x002D (HYPHEN-MINUS).
            1. _x_ = -_x_.
          1. _x_ = 0 이면
            1. _m_ = _p_ 번의 코드 유닛 0x0030 (DIGIT ZERO) 로 구성된 String.
            1. _e_ = 0.
          1. 그렇지 않으면
            1. 10<sup>_p_ - 1</sup> ≤ _n_ &lt; 10<sup>_p_</sup> 이고 _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ 가 0 에 가장 가깝도록 하는 정수 _e_, _n_ 을 둔다. 그러한 ( _e_, _n_ ) 이 두 개면 _n_ × 10<sup>_e_ - _p_ + 1</sup> 이 더 큰 것을 선택.
            1. _m_ 을 _n_ 의 십진 표현 자릿수들(선행 0 없이)로 구성된 String 값으로 둔다.
            1. _e_ &lt; -6 또는 _e_ ≥ _p_ 이면
              1. 단언: _e_ ≠ 0.
              1. _p_ ≠ 1 이면
                1. _a_ = _m_ 의 첫 코드 유닛.
                1. _b_ = 나머지 _p_ - 1 코드 유닛.
                1. _m_ = _a_, *"."*, _b_ 의 문자열 연결.
              1. _e_ > 0 이면
                1. _c_ = 코드 유닛 0x002B (PLUS SIGN).
              1. 그렇지 않으면
                1. 단언: _e_ &lt; 0.
                1. _c_ = 코드 유닛 0x002D (HYPHEN-MINUS).
                1. _e_ = -_e_.
              1. _d_ = _e_ 의 십진 표현 자릿수들(선행 0 없이)로 구성된 String.
              1. _s_, _m_, 코드 유닛 0x0065 (e), _c_, _d_ 의 문자열 연결을 반환.
          1. _e_ = _p_ - 1 이면 _s_ 와 _m_ 의 문자열 연결 반환.
          1. _e_ ≥ 0 이면
            1. _m_ = 처음 _e_ + 1 코드 유닛, 코드 유닛 0x002E (FULL STOP), 그리고 남은 _p_ - (_e_ + 1) 코드 유닛의 문자열 연결.
          1. 그렇지 않으면
            1. _m_ = 코드 유닛 0x0030 (DIGIT ZERO), 코드 유닛 0x002E (FULL STOP), -(_e_ + 1) 번의 코드 유닛 0x0030 (DIGIT ZERO), 그리고 String _m_ 의 문자열 연결.
          1. _s_ 와 _m_ 의 문자열 연결 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tostring">
        <h1>Number.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>선택적 _radix_ 는 *2*<sub>𝔽</sub> 에서 *36*<sub>𝔽</sub> 사이(포함)의 정수 Number 값이어야 한다. _radix_ 가 *undefined* 이면 *10*<sub>𝔽</sub> 이 _radix_ 값으로 사용된다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisNumberValue(*this* value) 로 둔다.
          1. _radix_ 가 *undefined* 이면 _radixMV_ = 10.
          1. 그렇지 않으면 _radixMV_ = ? ToIntegerOrInfinity(_radix_).
          1. _radixMV_ 가 2 이상 36 이하 구간에 없으면 *RangeError* 예외 throw.
          1. Number::toString(_x_, _radixMV_) 반환.
        </emu-alg>
        <p>이 메서드는 generic 하지 않으며, *this* 값이 Number 또는 Number 객체가 아니면 *TypeError* 예외를 던진다. 따라서 다른 종류의 객체로 이전하여 메서드로 사용할 수 없다.</p>
        <p>이 메서드의 *"length"* 프로퍼티 값은 *1*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.valueof">
        <h1>Number.prototype.valueOf ( )</h1>
        <emu-alg>
          1. ? ThisNumberValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisnumbervalue" type="abstract operation" oldids="thisnumbervalue">
          <h1>
            ThisNumberValue (
              _value_: ECMAScript 언어 값,
            ): Number 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 Number 이면 _value_ 반환.
            1. _value_ 가 Object 이고 [[NumberData]] 내부 슬롯을 가지면
              1. _n_ = _value_.[[NumberData]].
              1. 단언: _n_ 은 Number.
              1. _n_ 반환.
            1. *TypeError* 예외 throw.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-number-instances">
      <h1>Number 인스턴스의 프로퍼티 (Properties of Number Instances)</h1>
      <p>Number 인스턴스는 Number 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. Number 인스턴스는 또한 [[NumberData]] 내부 슬롯을 가진다. [[NumberData]] 내부 슬롯은 이 Number 객체가 나타내는 Number 값이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt 객체 (BigInt Objects)</h1>

    <emu-clause id="sec-bigint-constructor">
      <h1>BigInt 생성자 (The BigInt Constructor)</h1>
      <p>BigInt 생성자는 다음과 같다:</p>
      <ul>
        <li><dfn>%BigInt%</dfn> 이다.</li>
        <li>전역 객체의 *"BigInt"* 프로퍼티 초기 값이다.</li>
        <li>생성자가 아니라 함수로 호출될 때 타입 변환을 수행한다.</li>
        <li>`new` 연산자와 함께 사용하거나 서브클래싱하도록 의도되지 않았다. 클래스 정의의 `extends` 절 값으로 사용할 수는 있으나 BigInt 생성자에 대한 `super` 호출은 예외를 발생시킨다.</li>
      </ul>

      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. NewTarget 이 *undefined* 가 아니면 *TypeError* 예외를 throw 한다.
          1. _prim_ 을 ? ToPrimitive(_value_, ~number~) 로 둔다.
          1. _prim_ 이 Number 이면 ? NumberToBigInt(_prim_) 를 반환한다.
          1. 그렇지 않으면 ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta> 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            NumberToBigInt (
              _number_: a Number,
            ): BigInt 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _number_ 가 정수(Number)가 아니면 *RangeError* 예외를 throw 한다.
            1. ℤ(ℝ(_number_)) 를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>BigInt 생성자의 프로퍼티 (Properties of the BigInt Constructor)</h1>
      <p>BigInt 생성자는:</p>
      <ul>
        <li>값이 %Function.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
        <li>다음 프로퍼티들을 가진다:</li>
      </ul>

      <emu-clause id="sec-bigint.asintn">
        <h1>BigInt.asIntN ( _bits_, _bigint_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _bits_ 를 ? ToIndex(_bits_) 로 설정한다.
          1. _bigint_ 를 ? ToBigInt(_bigint_) 로 설정한다.
          1. _mod_ 를 ℝ(_bigint_) mod 2<sup>_bits_</sup> 로 둔다.
          1. _mod_ ≥ 2<sup>_bits_ - 1</sup> 이면 ℤ(_mod_ - 2<sup>_bits_</sup>) 를 반환; 그렇지 않으면 ℤ(_mod_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.asuintn">
        <h1>BigInt.asUintN ( _bits_, _bigint_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _bits_ 를 ? ToIndex(_bits_) 로 설정한다.
          1. _bigint_ 를 ? ToBigInt(_bigint_) 로 설정한다.
          1. ℤ(ℝ(_bigint_) mod 2<sup>_bits_</sup>) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype">
        <h1>BigInt.prototype</h1>
        <p>`BigInt.prototype` 의 초기 값은 BigInt 프로토타입 객체이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>BigInt 프로토타입 객체의 프로퍼티 (Properties of the BigInt Prototype Object)</h1>
      <p><dfn>BigInt 프로토타입 객체</dfn>는:</p>
      <ul>
        <li><dfn>%BigInt.prototype%</dfn> 이다.</li>
        <li>ordinary 객체이다.</li>
        <li>BigInt 객체가 아니며 [[BigIntData]] 내부 슬롯을 갖지 않는다.</li>
        <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      </ul>
      <p>메서드 명세 내 “this BigInt value” 라는 표현은 그 메서드 호출의 *this* 값을 인수로 하여 추상 연산 ThisBigIntValue 를 호출한 결과를 가리킨다.</p>

      <emu-clause id="sec-bigint.prototype.constructor">
        <h1>BigInt.prototype.constructor</h1>
        <p>`BigInt.prototype.constructor` 의 초기 값은 %BigInt% 이다.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tolocalestring">
        <h1>BigInt.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>ECMA-402 국제화 API 를 포함하는 ECMAScript 구현은 이 메서드를 ECMA-402 명세에 따라 구현해야 한다. 구현이 ECMA-402 API 를 포함하지 않는 경우 아래 명세가 사용된다:</p>
        <p>이 메서드는 호스트 환경의 현재 로케일 관례에 따라 포맷된 이 BigInt 값을 나타내는 String 값을 생성한다. 이 메서드는 구현 정의이며 `toString` 과 동일한 결과를 반환하는 것이 허용되나 권장되지는 않는다.</p>
        <p>이 메서드의 선택적 매개변수 의미는 ECMA-402 명세에 정의되며, ECMA-402 지원이 없는 구현은 해당 매개변수 위치를 다른 목적으로 사용해서는 안 된다.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tostring">
        <h1>BigInt.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>선택적 _radix_ 는 *2*<sub>𝔽</sub> 이상 *36*<sub>𝔽</sub> 이하(포함)의 정수 Number 값이어야 한다. _radix_ 가 *undefined* 이면 *10*<sub>𝔽</sub> 이 _radix_ 값으로 사용된다.</p>
        </emu-note>
        <p>이 메서드는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _x_ 를 ? ThisBigIntValue(*this* value) 로 둔다.
          1. _radix_ 가 *undefined* 이면 _radixMV_ = 10.
          1. 그렇지 않으면 _radixMV_ = ? ToIntegerOrInfinity(_radix_).
          1. _radixMV_ 가 2 이상 36 이하 구간에 없으면 *RangeError* 예외를 throw 한다.
          1. BigInt::toString(_x_, _radixMV_) 를 반환한다.
        </emu-alg>
        <p>이 메서드는 generic 하지 않으며 *this* 값이 BigInt 또는 BigInt 객체가 아니면 *TypeError* 예외를 던진다. 따라서 다른 종류의 객체로 이전하여 메서드로 사용할 수 없다.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.valueof">
        <h1>BigInt.prototype.valueOf ( )</h1>
        <emu-alg>
          1. ? ThisBigIntValue(*this* value) 를 반환한다.
        </emu-alg>

        <emu-clause id="sec-thisbigintvalue" type="abstract operation" oldids="thisbigintvalue">
          <h1>
            ThisBigIntValue (
              _value_: an ECMAScript language value,
            ): BigInt 를 담은 정상 completion 또는 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. _value_ 가 BigInt 이면 _value_ 를 반환한다.
            1. _value_ 가 Object 이고 [[BigIntData]] 내부 슬롯을 가진다면
              1. 단언: _value_.[[BigIntData]] 는 BigInt 이다.
              1. _value_.[[BigIntData]] 를 반환한다.
            1. *TypeError* 예외를 throw 한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-bigint.prototype-@@tostringtag" id="sec-bigint.prototype-%symbol.tostringtag%">
        <h1>BigInt.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 String 값 *"BigInt"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-bigint-instances">
      <h1>BigInt 인스턴스의 프로퍼티 (Properties of BigInt Instances)</h1>
      <p>BigInt 인스턴스는 BigInt 프로토타입 객체로부터 프로퍼티를 상속하는 ordinary 객체이다. BigInt 인스턴스는 또한 [[BigIntData]] 내부 슬롯을 가진다. [[BigIntData]] 내부 슬롯은 해당 BigInt 객체가 나타내는 BigInt 값이다.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-math-object">
    <h1>Math 객체 (The Math Object)</h1>
    <p>Math 객체는 다음과 같다:</p>
    <ul>
      <li><dfn>%Math%</dfn> 이다.</li>
      <li>전역 객체 *"Math"* 프로퍼티의 초기 값이다.</li>
      <li>ordinary 객체이다.</li>
      <li>값이 %Object.prototype% 인 [[Prototype]] 내부 슬롯을 가진다.</li>
      <li>함수 객체가 아니다.</li>
      <li>[[Construct]] 내부 메서드를 가지지 않아 `new` 연산자로 생성자로 사용할 수 없다.</li>
      <li>[[Call]] 내부 메서드를 가지지 않아 함수로 호출될 수 없다.</li>
    </ul>
    <emu-note>
      <p>이 명세에서 “the Number value for _x_” 라는 구문은 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 에 정의된 기술적 의미를 가진다.</p>
    </emu-note>

    <emu-clause id="sec-value-properties-of-the-math-object">
      <h1>Math 객체의 값 프로퍼티 (Value Properties of the Math Object)</h1>

      <emu-clause id="sec-math.e">
        <h1>Math.E</h1>
        <p>자연로그의 밑 <i>e</i> 에 대한 Number 값. 대략 2.7182818284590452354.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln10">
        <h1>Math.LN10</h1>
        <p>10 의 자연로그에 대한 Number 값. 대략 2.302585092994046.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln2">
        <h1>Math.LN2</h1>
        <p>2 의 자연로그에 대한 Number 값. 대략 0.6931471805599453.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.log10e">
        <h1>Math.LOG10E</h1>
        <p>자연로그의 밑 <i>e</i> 의 밑-10 로그(Number 값). 대략 0.4342944819032518.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Math.LOG10E` 값은 `Math.LN10` 값의 역수에 가까운 값이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log2e">
        <h1>Math.LOG2E</h1>
        <p>자연로그의 밑 <i>e</i> 의 밑-2 로그(Number 값). 대략 1.4426950408889634.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Math.LOG2E` 값은 `Math.LN2` 값의 역수에 가까운 값이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.pi">
        <h1>Math.PI</h1>
        <p>원주율 π (원둘레/지름) 에 대한 Number 값. 대략 3.1415926535897932.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause id="sec-math.sqrt1_2">
        <h1>Math.SQRT1_2</h1>
        <p>½ 의 제곱근(Number 값). 대략 0.7071067811865476.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
        <emu-note>
          <p>`Math.SQRT1_2` 값은 `Math.SQRT2` 값의 역수에 가까운 값이다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt2">
        <h1>Math.SQRT2</h1>
        <p>2 의 제곱근(Number 값). 대략 1.4142135623730951.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 특성을 가진다.</p>
      </emu-clause>

      <emu-clause oldids="sec-math-@@tostringtag" id="sec-math-%symbol.tostringtag%">
        <h1>Math [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 프로퍼티의 초기 값은 String 값 *"Math"* 이다.</p>
        <p>이 프로퍼티는 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 특성을 가진다.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Math 객체의 함수 프로퍼티 (Function Properties of the Math Object)</h1>
      <emu-note>
        <p>`acos`, `acosh`, `asin`, `asinh`, `atan`, `atanh`, `atan2`, `cbrt`, `cos`, `cosh`, `exp`, `expm1`, `hypot`, `log`, `log1p`, `log2`, `log10`, `pow`, `random`, `sin`, `sinh`, `tan`, `tanh` 함수의 동작은 경계 사례에 대해 특정 결과를 요구하는 것 외에는 여기서 정확히 규정되지 않는다. 다른 인수 값에 대해서는 익숙한 수학 함수의 결과를 근사하도록 의도되며, 근사 알고리즘 선택에 다소 재량이 허용된다. 일반적인 의도는 구현자가 해당 하드웨어 플랫폼에서 C 프로그래머가 사용할 수 있는 동일한 수학 라이브러리를 ECMAScript 에도 사용할 수 있도록 하는 것이다.</p>
        <p>알고리즘 선택은 구현에 맡기지만(표준에서 강제하지 않음) IEEE 754-2019 산술 근사 알고리즘을 포함하는 Sun Microsystems 의 자유 배포 수학 라이브러리 `fdlibm` 사용이 권장된다 (<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>).</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>_x_ 의 절대값을 반환한다; 결과는 부호만 양수이고 크기는 _x_ 와 동일하다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 *-0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 -_n_ 반환.
          1. _n_ 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acos">
        <h1>Math.acos ( _x_ )</h1>
        <p>_x_ 의 아크코사인(역코사인)을 반환한다. 결과는 라디안으로 표현되며 *+0*<sub>𝔽</sub> 이상 𝔽(π) 이하 구간에 있다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN* 이거나 _n_ > *1*<sub>𝔽</sub> 이거나 _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. _n_ 이 *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 역코사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>_x_ 의 역쌍곡코사인(acosh)을 반환한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN* 이거나 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ 이 *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 역쌍곡코사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asin">
        <h1>Math.asin ( _x_ )</h1>
        <p>_x_ 의 아크사인(역사인)을 반환한다. 결과는 라디안이며 𝔽(-π / 2) 이상 𝔽(π / 2) 이하 구간에 있다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ > *1*<sub>𝔽</sub> 또는 _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 역사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>_x_ 의 역쌍곡사인(asinh)을 반환한다.</p>
        <p>호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ 을 ? ToNumber(_x_) 로 둔다.
          1. _n_ 이 finite 가 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 _n_ 반환.
          1. ℝ(_n_) 의 역쌍곡사인을 나타내는 구현 근사 Number 값을 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan">
        <h1>Math.atan ( _x_ )</h1>
        <p>_x_ 의 아크탄젠트(역탄젠트)를 반환한다. 결과는 라디안이며 𝔽(-π / 2) 이상 𝔽(π / 2) 이하 구간.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ 이 *+∞*<sub>𝔽</sub> 이면 π / 2 를 나타내는 구현 근사 Number 값 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 -π / 2 를 나타내는 구현 근사 Number 값 반환.
          1. ℝ(_n_) 의 역탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>_x_ 의 역쌍곡탄젠트(atanh)를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ > *1*<sub>𝔽</sub> 또는 _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. _n_ 이 *1*<sub>𝔽</sub> 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _n_ 이 *-1*<sub>𝔽</sub> 이면 *-∞*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 역쌍곡탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan2">
        <h1>Math.atan2 ( _y_, _x_ )</h1>
        <p>두 인수 _y_, _x_ 의 몫 <emu-eqn>_y_ / _x_</emu-eqn> 에 대한 역탄젠트를 반환하며, _y_ 와 _x_ 의 부호를 사용해 사분면을 결정한다. 2인수 역탄젠트에서 _y_ 가 첫 번째, _x_ 가 두 번째 인수인 것은 의도적이며 전통이다. 결과는 라디안으로 -π 이상 +π 이하 구간.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _ny_ = ? ToNumber(_y_).
          1. _nx_ = ? ToNumber(_x_).
          1. _ny_ 또는 _nx_ 가 *NaN* 이면 *NaN* 반환.
          1. _ny_ = *+∞*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 π / 4 근사값 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 3π / 4 근사값 반환.
            1. 그렇지 않으면 π / 2 근사값 반환.
          1. _ny_ = *-∞*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 -π / 4 근사값 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 -3π / 4 근사값 반환.
            1. 그렇지 않으면 -π / 2 근사값 반환.
          1. _ny_ = *+0*<sub>𝔽</sub> 이면
            1. _nx_ > *+0*<sub>𝔽</sub> 또는 _nx_ = *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
            1. 그렇지 않으면 π 근사값 반환.
          1. _ny_ = *-0*<sub>𝔽</sub> 이면
            1. _nx_ > *+0*<sub>𝔽</sub> 또는 _nx_ = *+0*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
            1. 그렇지 않으면 -π 근사값 반환.
          1. 단언: _ny_ 는 finite 이고 ±0 아님.
          1. _ny_ > *+0*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 π 근사값 반환.
            1. _nx_ 가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 π / 2 근사값 반환.
          1. _ny_ &lt; *-0*<sub>𝔽</sub> 이면
            1. _nx_ = *+∞*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
            1. _nx_ = *-∞*<sub>𝔽</sub> 이면 -π 근사값 반환.
            1. _nx_ 가 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 -π / 2 근사값 반환.
          1. 단언: _nx_ 는 finite 이고 ±0 아님.
          1. _r_ 를 abs(ℝ(_ny_)/ℝ(_nx_)) 의 역탄젠트로 둔다.
          1. _nx_ &lt; *-0*<sub>𝔽</sub> 이면
            1. _ny_ > *+0*<sub>𝔽</sub> 이면 _r_ = π - _r_.
            1. 그렇지 않으면 _r_ = -π + _r_.
          1. 그렇지 않으면
            1. _ny_ &lt; *-0*<sub>𝔽</sub> 이면 _r_ = -_r_.
          1. _r_ 를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>_x_ 의 세제곱근을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 _n_ 반환.
          1. ℝ(_n_) 의 세제곱근을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>_x_ 보다 작지 않은 가장 작은( -∞ 에 가장 가까운 ) 정수 Number 값을 반환한다. _x_ 가 이미 정수이면 결과는 _x_.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이고 _n_ > *-1*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
          1. _n_ 이 정수이면 _n_ 반환.
          1. _n_ 보다 작지 않은 가장 작은 정수 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.ceil(x)` 값은 `-Math.floor(-x)` 값과 같다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.clz32">
        <h1>Math.clz32 ( _x_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ = ? ToUint32(_x_).
          1. _p_ 를 _n_ 의 부호 없는 32비트 이진 표현에서 선행 0 비트 개수로 둔다.
          1. 𝔽(_p_) 를 반환한다.
        </emu-alg>
        <emu-note>
          <p>_n_ 이 *+0*<sub>𝔽</sub> 또는 *-0*<sub>𝔽</sub> 이면 *32*<sub>𝔽</sub> 반환. 최상위 비트가 1 이면 *+0*<sub>𝔽</sub> 반환.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cos">
        <h1>Math.cos ( _x_ )</h1>
        <p>라디안 인수 _x_ 의 코사인을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니면 *NaN* 반환.
          1. _n_ 이 ±0 이면 *1*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 코사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>_x_ 의 쌍곡코사인을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 ±∞ 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *1*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 쌍곡코사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.cosh(x)` = `(Math.exp(x) + Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>_x_ 의 지수 함수(_e_^_x_) 값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ 이 ±0 이면 *1*<sub>𝔽</sub> 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 지수 함수를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>_e_^_x_ - 1 값을, _x_ 가 0 에 가까운 경우에도 정확하게 계산해 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ 이 *-∞*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. _exp_ 를 ℝ(_n_) 의 지수 함수 값으로 둔다.
          1. _exp_ - 1 을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>_x_ 보다 크지 않은 가장 큰( +∞ 에 가장 가까운 ) 정수 Number 값을 반환. 이미 정수이면 _x_.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. _n_ &lt; *1*<sub>𝔽</sub> 그리고 _n_ > *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 정수이면 _n_ 반환.
          1. _n_ 보다 크지 않은 가장 큰 정수 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.floor(x)` = `-Math.ceil(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.fround">
        <h1>Math.fround ( _x_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 ±0, ±∞ 중 하나이면 _n_ 반환.
          1. _n32_ = _n_ 을 roundTiesToEven 모드로 IEEE 754-2019 binary32 로 변환한 결과.
          1. _n64_ = _n32_ 를 IEEE 754-2019 binary64 로 변환한 결과.
          1. _n64_ 에 대응하는 ECMAScript Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.f16round">
        <h1>Math.f16round ( _x_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 이면 *NaN* 반환.
          1. _n_ 이 ±0, ±∞ 중 하나이면 _n_ 반환.
          1. _n16_ = _n_ 을 roundTiesToEven 모드로 IEEE 754-2019 binary16 으로 변환한 결과.
          1. _n64_ = _n16_ 을 IEEE 754-2019 binary64 로 변환한 결과.
          1. _n64_ 에 대응하는 ECMAScript Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>이 연산은 먼저 binary32 로 변환 후 binary16 으로 변환하는 것과 다르다(이중 반올림 가능성). 예: _k_ = *1.00048828125000022204*<sub>𝔽</sub> 에 대해 Math.f16round(_k_) 는 *1.0009765625*<sub>𝔽</sub> 이지만 Math.f16round(Math.fround(_k_)) 는 *1*<sub>𝔽</sub> 이다.</p>
          <p>모든 플랫폼이 binary64→binary16 캐스팅을 네이티브 지원하지는 않는다. MIT 라이선스 <a href="https://half.sourceforge.net/">half</a> 라이브러리 등 사용 가능. 또는 binary64→binary32 (roundTiesToEven) 후 잘못된 이중 반올림 가능성 검사, 해당 경우 mantissa 조정(odd 라운드에 해당) 후 최종 binary16 캐스팅 등으로 구현 가능.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( ..._args_ )</h1>
        <p>0개 이상의 인수에 대해 제곱들의 합의 제곱근을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _coerced_ = 새 빈 리스트.
          1. _args_ 각 _arg_ 에 대해
            1. _n_ = ? ToNumber(_arg_).
            1. _coerced_ 에 _n_ 추가.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 ±∞ 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _onlyZero_ = *true*.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 *NaN* 이면 *NaN* 반환.
            1. _number_ 가 *+0*<sub>𝔽</sub> 도 *-0*<sub>𝔽</sub> 도 아니면 _onlyZero_ = *false*.
          1. _onlyZero_ 가 *true* 이면 *+0*<sub>𝔽</sub> 반환.
          1. _coerced_ 요소들의 수학적 값 각각 제곱 합의 제곱근을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
        <emu-note>
          <p>두 개 이상 인수 시 단순 구현에서 발생하기 쉬운 overflow/underflow 로 인한 정밀도 손실을 피해야 한다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.imul">
        <h1>Math.imul ( _x_, _y_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _a_ = ℝ(? ToUint32(_x_)).
          1. _b_ = ℝ(? ToUint32(_y_)).
          1. _product_ = (_a_ × _b_) mod 2<sup>32</sup>.
          1. _product_ ≥ 2<sup>31</sup> 이면 𝔽(_product_ - 2<sup>32</sup>) 반환; 아니면 𝔽(_product_) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>_x_ 의 자연로그를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ = *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 자연로그를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>1 + _x_ 의 자연로그를 반환하며 _x_ 가 0 에 매우 가까울 때도 정확하도록 계산된다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ = *-1*<sub>𝔽</sub> 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-1*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. 1 + ℝ(_n_) 의 자연로그를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>_x_ 의 밑 10 로그를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ = *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 밑 10 로그 구현 근사 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>_x_ 의 밑 2 로그를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN* 또는 *+∞*<sub>𝔽</sub> 이면 _n_ 반환.
          1. _n_ = *1*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ 이 ±0 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. ℝ(_n_) 의 밑 2 로그 구현 근사 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( ..._args_ )</h1>
        <p>0개 이상의 인수에 대해 각 인수에 ToNumber 를 적용한 결과 중 최댓값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _coerced_ = 새 빈 리스트.
          1. _args_ 각 _arg_ 에 대해
            1. _n_ = ? ToNumber(_arg_).
            1. _coerced_ 에 _n_ 추가.
          1. _highest_ = *-∞*<sub>𝔽</sub>.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 *NaN* 이면 *NaN* 반환.
            1. _number_ = *+0*<sub>𝔽</sub> 이고 _highest_ = *-0*<sub>𝔽</sub> 이면 _highest_ = *+0*<sub>𝔽</sub>.
            1. _number_ > _highest_ 이면 _highest_ = _number_.
          1. _highest_ 반환.
        </emu-alg>
        <emu-note>
          <p>최댓값 비교는 IsLessThan 알고리즘을 사용하되 *+0*<sub>𝔽</sub> 를 *-0*<sub>𝔽</sub> 보다 큰 것으로 간주한다.</p>
        </emu-note>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( ..._args_ )</h1>
        <p>0개 이상의 인수에 대해 각 인수에 ToNumber 를 적용한 결과 중 최솟값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _coerced_ = 새 빈 리스트.
          1. _args_ 각 _arg_ 에 대해
            1. _n_ = ? ToNumber(_arg_).
            1. _coerced_ 에 _n_ 추가.
          1. _lowest_ = *+∞*<sub>𝔽</sub>.
          1. _coerced_ 각 _number_ 에 대해
            1. _number_ 가 *NaN* 이면 *NaN* 반환.
            1. _number_ = *-0*<sub>𝔽</sub> 이고 _lowest_ = *+0*<sub>𝔽</sub> 이면 _lowest_ = *-0*<sub>𝔽</sub>.
            1. _number_ &lt; _lowest_ 이면 _lowest_ = _number_.
          1. _lowest_ 반환.
        </emu-alg>
        <emu-note>
          <p>최솟값 결정 비교도 IsLessThan 을 사용하되 *+0*<sub>𝔽</sub> 를 *-0*<sub>𝔽</sub> 보다 큰 것으로 취급한다.</p>
        </emu-note>
        <p>이 함수의 *"length"* 프로퍼티는 *2*<sub>𝔽</sub> 이다.</p>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>이 함수는 호출될 때 다음 단계를 수행한다:</p>
        <emu-alg>
          1. _base_ = ? ToNumber(_base_).
          1. _exponent_ = ? ToNumber(_exponent_).
          1. Number::exponentiate(_base_, _exponent_) 를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.random">
        <h1>Math.random ( )</h1>
        <p>*+0*<sub>𝔽</sub> 이상 *1*<sub>𝔽</sub> 미만 구간에서 양의 부호를 가지는 Number 값을 (구현 정의 알고리즘/전략으로) 균등 분포에 가깝게 무작위 또는 의사난수로 반환한다.</p>
        <p>서로 다른 realm 에 대해 생성된 각 `Math.random` 함수는 연속 호출에서 서로 다른 수열을 생성해야 한다.</p>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>_x_ 에 가장 가까운 정수 Number 값을 반환한다. 두 정수가 동일하게 가깝다면 +∞ 에 더 가까운 값을 반환. _x_ 가 이미 정수면 _x_ 반환.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 정수이면 _n_ 반환.
          1. _n_ &lt; *0.5*<sub>𝔽</sub> 그리고 _n_ > *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 그리고 _n_ ≥ *-0.5*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
          1. _n_ 과 가장 가까운 정수 Number 값을 반환(동일 거리면 +∞ 쪽 선택).
        </emu-alg>
        <emu-note>
          <p>`Math.round(3.5)` 는 4, `Math.round(-3.5)` 는 -3.</p>
        </emu-note>
        <emu-note>
          <p>`Math.round(x)` 는 항상 `Math.floor(x + 0.5)` 와 같지 않다. 예를 들어 _x_ 가 *-0*<sub>𝔽</sub> 이거나 *-0*<sub>𝔽</sub> 보다 작고 *-0.5*<sub>𝔽</sub> 이상이면 `Math.round(x)` 는 *-0*<sub>𝔽</sub> 반환하지만 `Math.floor(x + 0.5)` 는 *+0*<sub>𝔽</sub> 를 반환. 또한 내부 반올림으로 인해 차이날 수 있다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>_x_ 의 부호(양수/음수/0)를 나타내는 값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. *1*<sub>𝔽</sub> 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sin">
        <h1>Math.sin ( _x_ )</h1>
        <p>라디안 인수 _x_ 의 사인 값을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ 이 ±∞ 이면 *NaN* 반환.
          1. ℝ(_n_) 의 사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>_x_ 의 쌍곡사인을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. ℝ(_n_) 의 쌍곡사인을 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.sinh(x)` = `(Math.exp(x) - Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>_x_ 의 제곱근을 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub> 중 하나이면 _n_ 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 이면 *NaN* 반환.
          1. 𝔽(ℝ(_n_) 의 제곱근) 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sumprecise">
        <h1>Math.sumPrecise ( _items_ )</h1>
        <p>Number 들로 이루어진 iterable 을 받아 모든 값을 더해 합을 반환한다. 어떤 값이 Number 가 아니면 *TypeError* 예외를 던진다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. ? RequireObjectCoercible(_items_) 수행.
          1. _iteratorRecord_ = ? GetIterator(_items_, ~sync~).
          1. _state_ = ~minus-zero~.
          1. _sum_ = 0.
          1. _count_ = 0.
          1. _next_ = ~not-started~.
          1. _next_ 가 ~done~ 이 아닐 동안 반복
            1. _next_ = ? IteratorStepValue(_iteratorRecord_).
            1. _next_ 가 ~done~ 이 아니면
              1. _count_ ≥ 2<sup>53</sup> - 1 이면
                1. NOTE: 현실적으로 도달하지 않는 단계이며 입력이 “적당한 크기” 임을 가정 가능하게 하기 위한 것.
                1. _error_ = ThrowCompletion(새 *RangeError* 객체).
                1. ? IteratorClose(_iteratorRecord_, _error_) 반환.
              1. _next_ 가 Number 가 아니면
                1. _error_ = ThrowCompletion(새 *TypeError* 객체).
                1. ? IteratorClose(_iteratorRecord_, _error_) 반환.
              1. _n_ = _next_.
              1. _state_ ≠ ~not-a-number~ 이면
                1. _n_ 이 *NaN* 이면
                  1. _state_ = ~not-a-number~.
                1. Else if _n_ = *+∞*<sub>𝔽</sub>
                  1. _state_ = ~minus-infinity~ 이면 ~not-a-number~, 아니면 ~plus-infinity~.
                1. Else if _n_ = *-∞*<sub>𝔽</sub>
                  1. _state_ = ~plus-infinity~ 이면 ~not-a-number~, 아니면 ~minus-infinity~.
                1. Else if _n_ 이 *-0*<sub>𝔽</sub> 가 아니고 _state_ 가 ~minus-zero~ 또는 ~finite~ 이면
                  1. _state_ = ~finite~.
                  1. _sum_ = _sum_ + ℝ(_n_).
              1. _count_ = _count_ + 1.
          1. _state_ = ~not-a-number~ 이면 *NaN* 반환.
          1. _state_ = ~plus-infinity~ 이면 *+∞*<sub>𝔽</sub> 반환.
          1. _state_ = ~minus-infinity~ 이면 *-∞*<sub>𝔽</sub> 반환.
          1. _state_ = ~minus-zero~ 이면 *-0*<sub>𝔽</sub> 반환.
          1. 𝔽(_sum_) 반환.
        </emu-alg>
        <emu-note>
          <p>_sum_ 은 임의 정밀도 산술 없이 여러 알고리즘으로 계산 가능. 예: Jonathan Richard Shewchuk 의 <i>Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates</i> 에 나오는 "Grow-Expansion" 알고리즘. 또는 "<a href="https://arxiv.org/abs/1505.05571">Fast exact summation using small and large superaccumulators</a>" (코드: <a href="https://gitlab.com/radfordneal/xsum">https://gitlab.com/radfordneal/xsum</a>).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.tan">
        <h1>Math.tan ( _x_ )</h1>
        <p>라디안 인수 _x_ 의 탄젠트를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ 이 ±∞ 이면 *NaN* 반환.
          1. ℝ(_n_) 의 탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>_x_ 의 쌍곡탄젠트를 반환한다.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub> 중 하나면 _n_ 반환.
          1. _n_ = *+∞*<sub>𝔽</sub> 이면 *1*<sub>𝔽</sub> 반환.
          1. _n_ = *-∞*<sub>𝔽</sub> 이면 *-1*<sub>𝔽</sub> 반환.
          1. ℝ(_n_) 의 쌍곡탄젠트를 나타내는 구현 근사 Number 값 반환.
        </emu-alg>
        <emu-note>
          <p>`Math.tanh(x)` = `(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>_x_ 의 정수 부분(소수부 제거)을 반환. _x_ 가 이미 정수이면 _x_ 반환.</p>
        <p>호출될 때:</p>
        <emu-alg>
          1. _n_ = ? ToNumber(_x_).
          1. _n_ 이 finite 가 아니거나 ±0 이면 _n_ 반환.
          1. _n_ &lt; *1*<sub>𝔽</sub> 그리고 _n_ > *+0*<sub>𝔽</sub> 이면 *+0*<sub>𝔽</sub> 반환.
          1. _n_ &lt; *-0*<sub>𝔽</sub> 그리고 _n_ > *-1*<sub>𝔽</sub> 이면 *-0*<sub>𝔽</sub> 반환.
          1. *+0*<sub>𝔽</sub> 방향으로 _n_ 에 가장 가까운 정수 Number 값 반환.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date 객체</h1>

    <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
      <h1>Date 객체 개요 및 추상 연산 정의</h1>
      <p>다음의 추상 연산들은 시간 값(<emu-xref href="#sec-time-values-and-time-range"></emu-xref>에서 정의됨)에 대해 동작합니다. 모든 경우에 이 함수들에 인수로 *NaN*이 들어오면 결과도 *NaN*이 됨을 유의하세요.</p>

      <emu-clause id="sec-time-values-and-time-range">
        <h1>시간 값과 시간 범위</h1>
        <p>ECMAScript의 시간 측정은 POSIX의 시간 측정과 유사하며, 특히 전환 그레고리력(proleptic Gregorian calendar), 1970년 1월 1일 0시 UTC의 <dfn id="epoch">기점(epoch)</dfn>, 그리고 하루가 정확히 86,400초(각 초는 1000밀리초)로 구성된다는 정의를 공유합니다.</p>
        <p>ECMAScript의 <dfn variants="time values">시간 값</dfn>은 Number로, 밀리초 단위의 한 순간을 나타내는 유한 정수 Number이거나 특정 순간을 나타내지 않는 *NaN*일 수 있습니다. <emu-eqn>24 × 60 × 60 × 1000 = 86,400,000</emu-eqn>의 배수(즉, 정수 _d_에 대해 86,400,000 × _d_)인 시간 값은 기점 이후 _d_일이 지난 UTC 일의 시작 순간(음수 _d_라면 기점 이전)을 나타냅니다. 그 외의 유한 시간 값 _t_는 그와 가장 가까운 이전 배수 시간 값 _s_를 기준으로 정의되며, _s_와 동일한 UTC 일 내에서 (_t_ - _s_) 밀리초가 지난 순간을 나타냅니다.</p>
        <p>시간 값은 UTC 윤초(leap seconds)를 고려하지 않습니다—양의 윤초 내의 순간을 나타내는 시간 값은 없으며, 음의 윤초로 인해 UTC 타임라인에서 제거된 순간을 나타내는 시간 값은 있습니다. 그럼에도 불구하고 시간 값의 정의는 윤초 경계에서만 불연속이 있고 그 외에는 UTC와 부분적으로 일치함을 보장합니다.</p>
        <p>Number는 -9,007,199,254,740,992에서 9,007,199,254,740,992(<emu-xref href="#sec-number.min_safe_integer"></emu-xref> 및 <emu-xref href="#sec-number.max_safe_integer"></emu-xref> 참고)까지의 모든 정수를 정확하게 표현할 수 있습니다. 시간 값은 -8,640,000,000,000,000에서 8,640,000,000,000,000 밀리초까지의 약간 더 작은 범위를 지원합니다. 이는 1970년 1월 1일 0시 UTC 기준으로 -100,000,000일부터 100,000,000일까지의 시간 값 범위를 제공합니다.</p>
        <p>1970년 1월 1일 0시 UTC의 정확한 순간은 시간 값 *+0*<sub>𝔽</sub>으로 표현됩니다.</p>
        <emu-note>
          <p>전환 그레고리력에서는 윤년이 4로 나누어떨어지고, 400으로 나누어떨어지거나 100으로 나누어떨어지지 않는 해입니다.</p>
          <p>전환 그레고리력의 400년 주기에는 97번의 윤년이 있습니다. 평균적으로 연간 365.2425일, 즉 31,556,952,000 밀리초가 됩니다. 따라서 Number가 밀리초 단위로 정확하게 표현할 수 있는 최대 범위는 1970년 기준으로 약 -285,426년에서 285,426년입니다. 이 절에서 명시된 시간 값의 더 작은 범위는 약 -273,790년에서 273,790년(1970년 기준)입니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-related-constants">
        <h1>시간 관련 상수</h1>
        <p>이 상수들은 다음 섹션의 알고리즘에서 참조됩니다.</p>
        <emu-eqn id="eqn-HoursPerDay" aoid="HoursPerDay">HoursPerDay = 24</emu-eqn>
        <emu-eqn id="eqn-MinutesPerHour" aoid="MinutesPerHour">MinutesPerHour = 60</emu-eqn>
        <emu-eqn id="eqn-SecondsPerMinute" aoid="SecondsPerMinute">SecondsPerMinute = 60</emu-eqn>
        <emu-eqn id="eqn-msPerSecond" aoid="msPerSecond">msPerSecond = *1000*<sub>𝔽</sub></emu-eqn>
        <emu-eqn id="eqn-msPerMinute" aoid="msPerMinute">msPerMinute = *60000*<sub>𝔽</sub> = msPerSecond × 𝔽(SecondsPerMinute)</emu-eqn>
        <emu-eqn id="eqn-msPerHour" aoid="msPerHour">msPerHour = *3600000*<sub>𝔽</sub> = msPerMinute × 𝔽(MinutesPerHour)</emu-eqn>
        <emu-eqn id="eqn-msPerDay" aoid="msPerDay">msPerDay = *86400000*<sub>𝔽</sub> = msPerHour × 𝔽(HoursPerDay)</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-day" type="abstract operation" oldids="eqn-Day,sec-day-number-and-time-within-day">
        <h1>
          Day (
            _t_: 유한한 시간 값,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 날짜의 일 번호(day number)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerDay)))를 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timewithinday" type="abstract operation" oldids="eqn-TimeWithinDay">
        <h1>
          TimeWithinDay (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub> (포함)부터 msPerDay (제외)까지의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 날짜의 시작부터 지난 밀리초 수를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(_t_) modulo ℝ(msPerDay))를 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daysinyear" type="abstract operation" oldids="eqn-DaysInYear,sec-year-number">
        <h1>
          DaysInYear (
            _y_: 정수 Number,
          ): *365*<sub>𝔽</sub> 또는 *366*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_y_년의 일(day) 수를 반환합니다. 윤년은 366일, 그 외는 365일입니다.</dd>
        </dl>
        <emu-alg>
          1. _ry_를 ℝ(_y_)로 합니다.
          1. (_ry_ modulo 400) = 0이면 *366*<sub>𝔽</sub>을 반환합니다.
          1. (_ry_ modulo 100) = 0이면 *365*<sub>𝔽</sub>을 반환합니다.
          1. (_ry_ modulo 4) = 0이면 *366*<sub>𝔽</sub>을 반환합니다.
          1. *365*<sub>𝔽</sub>을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dayfromyear" type="abstract operation" oldids="eqn-DaysFromYear">
        <h1>
          DayFromYear (
            _y_: 정수 Number,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_y_년의 첫날의 일 번호(day number)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. _ry_를 ℝ(_y_)로 합니다.
          1. [declared="numYears1,numYears4,numYears100,numYears400"] 다음 단계에서 _numYears1_, _numYears4_, _numYears100_, _numYears400_은 기점 이후 _y_년 시작까지 1, 4, 100, 400으로 나누어떨어지는 연도 수를 나타냅니다. _y_가 기점 이전이면 음수입니다.
          1. _numYears1_에 (_ry_ - 1970)을 할당합니다.
          1. _numYears4_에 floor((_ry_ - 1969) / 4)을 할당합니다.
          1. _numYears100_에 floor((_ry_ - 1901) / 100)을 할당합니다.
          1. _numYears400_에 floor((_ry_ - 1601) / 400)을 할당합니다.
          1. 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timefromyear" type="abstract operation" oldids="eqn-TimeFromYear">
        <h1>
          TimeFromYear (
            _y_: 정수 Number,
          ): 시간 값
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_y_년의 시작 순간의 시간 값을 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. msPerDay × DayFromYear(_y_)를 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yearfromtime" type="abstract operation" oldids="eqn-YearFromTime">
        <h1>
          YearFromTime (
            _t_: 유한한 시간 값,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 연도를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. [declared="y"] TimeFromYear(_y_) ≤ _t_를 만족하는 가장 큰 정수 _y_를 반환합니다 (+∞에 가장 가까움).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daywithinyear" type="abstract operation" oldids="eqn-DayWithinYear">
        <h1>
          DayWithinYear (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *365*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Day(_t_) - DayFromYear(YearFromTime(_t_))을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-inleapyear" type="abstract operation" oldids="eqn-InLeapYear">
        <h1>
          InLeapYear (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub> 또는 *1*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 윤년 내에 있으면 *1*<sub>𝔽</sub>, 아니면 *+0*<sub>𝔽</sub>을 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. DaysInYear(YearFromTime(_t_))이 *366*<sub>𝔽</sub>이면 *1*<sub>𝔽</sub>을, 아니면 *+0*<sub>𝔽</sub>을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-monthfromtime" type="abstract operation" oldids="eqn-MonthFromTime,sec-month-number">
        <h1>
          MonthFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *11*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 월(month)을 식별하는 Number를 반환합니다. *+0*<sub>𝔽</sub>은 1월, *1*<sub>𝔽</sub>은 2월, … *11*<sub>𝔽</sub>은 12월을 의미합니다. <emu-eqn>MonthFromTime(*+0*<sub>𝔽</sub>) = *+0*<sub>𝔽</sub></emu-eqn>은 1970년 1월 1일 목요일에 해당합니다.</dd>
        </dl>
        <emu-alg>
          1. _inLeapYear_에 InLeapYear(_t_)를 할당합니다.
          1. _dayWithinYear_에 DayWithinYear(_t_)를 할당합니다.
          1. _dayWithinYear_ &lt; *31*<sub>𝔽</sub>이면 *+0*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *59*<sub>𝔽</sub> + _inLeapYear_이면 *1*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *90*<sub>𝔽</sub> + _inLeapYear_이면 *2*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *120*<sub>𝔽</sub> + _inLeapYear_이면 *3*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *151*<sub>𝔽</sub> + _inLeapYear_이면 *4*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *181*<sub>𝔽</sub> + _inLeapYear_이면 *5*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *212*<sub>𝔽</sub> + _inLeapYear_이면 *6*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *243*<sub>𝔽</sub> + _inLeapYear_이면 *7*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *273*<sub>𝔽</sub> + _inLeapYear_이면 *8*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *304*<sub>𝔽</sub> + _inLeapYear_이면 *9*<sub>𝔽</sub>을 반환합니다.
          1. _dayWithinYear_ &lt; *334*<sub>𝔽</sub> + _inLeapYear_이면 *10*<sub>𝔽</sub>을 반환합니다.
          1. Assert: _dayWithinYear_ &lt; *365*<sub>𝔽</sub> + _inLeapYear_.
          1. *11*<sub>𝔽</sub>을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-datefromtime" type="abstract operation" oldids="sec-date-number">
        <h1>
          DateFromTime (
            _t_: 유한한 시간 값,
          ): *1*<sub>𝔽</sub>부터 *31*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 월의 날짜(day of month)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. _inLeapYear_에 InLeapYear(_t_)를 할당합니다.
          1. _dayWithinYear_에 DayWithinYear(_t_)를 할당합니다.
          1. _month_에 MonthFromTime(_t_)를 할당합니다.
          1. _month_가 *+0*<sub>𝔽</sub>이면 _dayWithinYear_ + *1*<sub>𝔽</sub>을 반환합니다.
          1. _month_가 *1*<sub>𝔽</sub>이면 _dayWithinYear_ - *30*<sub>𝔽</sub>을 반환합니다.
          1. _month_가 *2*<sub>𝔽</sub>이면 _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *3*<sub>𝔽</sub>이면 _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *4*<sub>𝔽</sub>이면 _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *5*<sub>𝔽</sub>이면 _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *6*<sub>𝔽</sub>이면 _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *7*<sub>𝔽</sub>이면 _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *8*<sub>𝔽</sub>이면 _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *9*<sub>𝔽</sub>이면 _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. _month_가 *10*<sub>𝔽</sub>이면 _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
          1. Assert: _month_가 *11*<sub>𝔽</sub>임을 보장합니다.
          1. _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weekday" type="abstract operation" oldids="sec-week-day">
        <h1>
          WeekDay (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *6*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 요일(week day)을 식별하는 Number를 반환합니다. *+0*<sub>𝔽</sub>은 일요일, *1*<sub>𝔽</sub>은 월요일, … *6*<sub>𝔽</sub>은 토요일을 의미합니다. <emu-eqn>WeekDay(*+0*<sub>𝔽</sub>) = *4*<sub>𝔽</sub></emu-eqn>은 1970년 1월 1일 목요일에 해당합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hourfromtime" type="abstract operation" oldids="eqn-HourFromTime,sec-hours-minutes-second-and-milliseconds">
        <h1>
          HourFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *23*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 시(hour)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-minfromtime" type="abstract operation" oldids="eqn-MinFromTime">
        <h1>
          MinFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *59*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_t_가 속한 분(minute)을 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour)을 반환합니다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-secfromtime" type="abstract operation" oldids="eqn-SecFromTime">
        <h1>
          SecFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *59*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_t_가 속한 분(minute)의 초(second)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-msfromtime" type="abstract operation" oldids="eqn-msFromTime">
        <h1>
          msFromTime (
            _t_: 유한한 시간 값,
          ): *+0*<sub>𝔽</sub>부터 *999*<sub>𝔽</sub>까지 포함하는 구간의 정수 Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_t_가 속한 초(second)의 밀리초(millisecond)를 반환합니다.</dd>
        </dl>
        <emu-alg>
          1. 𝔽(ℝ(_t_) modulo ℝ(msPerSecond))를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getutcepochnanoseconds" type="abstract operation">
        <h1>
          GetUTCEpochNanoseconds (
            _year_: 정수,
            _month_: 1~12의 정수,
            _day_: 1~31의 정수,
            _hour_: 0~23의 정수,
            _minute_: 0~59의 정수,
            _second_: 0~59의 정수,
            _millisecond_: 0~999의 정수,
            _microsecond_: 0~999의 정수,
            _nanosecond_: 0~999의 정수,
          ): BigInt
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>반환 값은 주어진 ISO 8601 달력 날짜와 UTC 벽시계 시간에 해당하는 기점(epoch) 이후의 나노초 수를 나타냅니다.</dd>
        </dl>
        <emu-alg>
          1. _date_를 MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_))로 한다.
          1. _time_을 MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_))로 한다.
          1. _ms_를 MakeDate(_date_, _time_)로 한다.
          1. Assert: _ms_는 정수 Number이다.
          1. ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifiers">
        <h1>시간대 식별자</h1>

        <p>
          ECMAScript에서 시간대는 <dfn variants="time zone identifier">시간대 식별자</dfn>로 표현되며, 이는 0x0000~0x007F의 코드 유닛으로만 구성된 문자열입니다.
          ECMAScript 구현이 지원하는 시간대는 <dfn variants="available named time zone">사용 가능한 명명된 시간대</dfn>일 수 있고, 이는 AvailableNamedTimeZoneIdentifiers가 반환하는 시간대 식별자 레코드의 [[Identifier]] 필드로 표현됩니다. 또는 <dfn variants="offset time zone">오프셋 시간대</dfn>일 수 있고, 이는 IsTimeZoneOffsetString이 *true*를 반환하는 문자열로 표현됩니다.
        </p>
        <p>
          <dfn variants="primary time zone identifiers">기본 시간대 식별자</dfn>는 사용 가능한 명명된 시간대의 대표 식별자입니다.
          <dfn variants="non-primary time zone identifiers">비기본 시간대 식별자</dfn>는 명명된 시간대를 나타내지만 기본 식별자가 아닌 식별자입니다.
          <dfn variants="available named time zone identifiers">사용 가능한 명명된 시간대 식별자</dfn>는 기본 또는 비기본 식별자입니다.
          각 사용 가능한 명명된 시간대 식별자는 정확히 하나의 명명된 시간대와 연결됩니다.
          각 명명된 시간대는 정확히 하나의 기본 시간대 식별자와 0개 이상의 비기본 식별자와 연결됩니다.
        </p>
        <p>
          ECMAScript 구현은 *"UTC"* 식별자를 가진 명명된 시간대를 지원해야 하며, 이는 UTC 시간대의 기본 식별자여야 합니다.
          추가로, 구현은 다른 명명된 시간대를 임의로 지원할 수 있습니다.
        </p>
        <p>
          ECMA-402 국제화 API 명세의 시간대 요구 사항을 따르는 구현은 <dfn>시간대 지원 구현(time zone aware)</dfn>이라고 합니다.
          시간대 지원 구현은 IANA Time Zone Database의 Zone 및 Link 이름에 해당하는 명명된 시간대를 지원해야 하며, 오직 그러한 이름만 지원해야 합니다.
          시간대 지원 구현에서는 기본 식별자가 Zone 이름, 비기본 식별자가 Link 이름에 해당합니다(ECMA-402에서 특별히 재정의한 경우 제외).
          전체 IANA Time Zone Database를 지원하지 않더라도 IANA 이름을 식별자로 사용하는 것이 권장됩니다.
        </p>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneepochnanoseconds" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneEpochNanoseconds (
            _timeZoneIdentifier_: 문자열,
            _year_: 정수,
            _month_: 1~12의 정수,
            _day_: 1~31의 정수,
            _hour_: 0~23의 정수,
            _minute_: 0~59의 정수,
            _second_: 0~59의 정수,
            _millisecond_: 0~999의 정수,
            _microsecond_: 0~999의 정수,
            _nanosecond_: 0~999의 정수,
          ): BigInt 리스트
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            반환되는 리스트의 각 값은 _timeZoneIdentifier_로 지정된 명명된 시간대에서 주어진 ISO 8601 달력 날짜와 벽시계 시간에 해당하는 기점(epoch) 이후의 나노초 수를 나타냅니다.
          </dd>
        </dl>
        <p>
          입력값이 음의 시간대 전환(예: 서머타임 종료나 시간대 오프셋 감소) 때문에 지역 시간이 두 번 발생하면, 반환 리스트에 두 개 이상의 요소가 들어가고 오름차순으로 정렬됩니다.
          입력값이 양의 시간대 전환(예: 서머타임 시작이나 시간대 오프셋 증가) 때문에 지역 시간이 건너뛰어진 경우, 반환 리스트는 비어 있습니다.
          그 외에는 반환 리스트에 하나의 요소가 들어갑니다.
        </p>
        <p>지역 정치적 규칙이 없는 ECMAScript 구현에서 사용하는 GetNamedTimeZoneEpochNanoseconds 기본 구현은 다음과 같은 단계로 동작합니다:</p>
        <emu-alg>
          1. Assert: _timeZoneIdentifier_가 *"UTC"*임을 보장한다.
          1. _epochNanoseconds_를 GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_)로 한다.
          1. « _epochNanoseconds_ »를 반환한다.
        </emu-alg>
        <emu-note>
          <p>시간대 지원 구현(및 모든 구현에 권장됨)은 IANA Time Zone Database의 시간대 정보를 사용해야 합니다 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>2017년 11월 5일 America/New_York의 오전 1:30은 두 번 반복되므로, GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 11, 5, 1, 30, 0, 0, 0, 0)은 길이 2인 리스트를 반환하며 첫 번째 요소는 05:30 UTC(미국 동부 일광절약시 UTC-04:00의 01:30)에, 두 번째 요소는 06:30 UTC(미국 동부 표준시 UTC-05:00의 01:30)에 해당합니다.</p>
          <p>2017년 3월 12일 America/New_York의 오전 2:30은 존재하지 않으므로, GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 3, 12, 2, 30, 0, 0, 0, 0)은 빈 리스트를 반환합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneoffsetnanoseconds" oldids="sec-local-time-zone-adjustment" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneOffsetNanoseconds (
            _timeZoneIdentifier_: 문자열,
            _epochNanoseconds_: BigInt,
          ): 정수
        </h1>
        <dl class="header">
        </dl>
        <p>반환되는 정수는 _timeZoneIdentifier_로 지정된 명명된 시간대에서, _epochNanoseconds_에 해당하는 순간의 UTC로부터의 오프셋(나노초 단위)을 나타냅니다.</p>
        <p>지역 정치적 규칙이 없는 ECMAScript 구현에서 사용하는 기본 구현은 다음과 같이 동작합니다:</p>
        <emu-alg>
          1. Assert: _timeZoneIdentifier_가 *"UTC"*임을 보장한다.
          1. 0을 반환한다.
        </emu-alg>
        <emu-note>
          <p>시간대 오프셋 값은 양수일 수도 음수일 수도 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifier-record">
        <h1>시간대 식별자 레코드</h1>
        <p><dfn variants="Time Zone Identifier Records">시간대 식별자 레코드</dfn>는 사용 가능한 명명된 시간대 식별자와 해당 기본 시간대 식별자를 설명하는 데 사용되는 레코드입니다.</p>
        <p>시간대 식별자 레코드는 <emu-xref href="#table-time-zone-identifier-record-fields"></emu-xref>에 나열된 필드를 가집니다.</p>
        <emu-table id="table-time-zone-identifier-record-fields" caption="시간대 식별자 레코드 필드">
          <table>
            <thead>
              <tr>
                <th>필드 이름</th>
                <th>값</th>
                <th>의미</th>
              </tr>
            </thead>
            <tr>
              <td>[[Identifier]]</td>
              <td>문자열</td>
              <td>구현에서 지원하는 사용 가능한 명명된 시간대 식별자입니다.</td>
            </tr>
            <tr>
              <td>[[PrimaryIdentifier]]</td>
              <td>문자열</td>
              <td>[[Identifier]]가 resolve되는 기본 시간대 식별자입니다.</td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>[[Identifier]]가 기본 시간대 식별자라면, [[Identifier]]는 [[PrimaryIdentifier]]입니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-availablenamedtimezoneidentifiers" type="implementation-defined abstract operation">
        <h1>AvailableNamedTimeZoneIdentifiers ( ): 시간대 식별자 레코드 리스트</h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            결과는 이 구현에서 사용 가능한 모든 명명된 시간대 식별자와, 각 명명된 시간대 식별자에 해당하는 기본 시간대 식별자를 설명합니다.
            리스트는 각 시간대 식별자 레코드의 [[Identifier]] 필드 기준으로 정렬됩니다.
          </dd>
        </dl>
        <p>
          ECMA-402 국제화 API를 구현하는 모든 시간대 지원 구현은 ECMA-402 명세에 따라 AvailableNamedTimeZoneIdentifiers 추상 연산을 구현해야 합니다.
          시간대 지원하지 않는 구현에서는 다음과 같이 동작합니다:
        </p>
        <emu-alg>
          1. 구현에 지역 정치적 규칙이 없으면,
            1. « 시간대 식별자 레코드 { [[Identifier]]: *"UTC"*, [[PrimaryIdentifier]]: *"UTC"* } »를 반환한다.
          1. _identifiers_를 고유한 사용 가능한 명명된 시간대 식별자 리스트(코드 유닛 사전순으로 정렬)로 한다.
          1. _result_를 새로운 빈 리스트로 한다.
          1. 각 _identifiers_의 요소 _identifier_에 대해,
            1. _primary_를 _identifier_로 한다.
            1. _identifier_가 이 구현에서 비기본 시간대 식별자이고 *"UTC"*가 아니면,
              1. _primary_를 _identifier_와 연결된 기본 시간대 식별자로 설정한다.
              1. NOTE: 기본 식별자를 얻기 위해 _identifier_를 반복적으로 resolve해야 할 수도 있다.
            1. _record_를 시간대 식별자 레코드 { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }로 한다.
            1. _result_에 _record_를 추가한다.
          1. Assert: _result_에 [[Identifier]]가 *"UTC"*이고 [[PrimaryIdentifier]]도 *"UTC"*인 레코드 _r_가 포함됨을 보장한다.
          1. _result_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-systemtimezoneidentifier" oldids="sec-defaulttimezone" type="implementation-defined abstract operation">
        <h1>SystemTimeZoneIdentifier ( ): 문자열</h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            호스트 환경의 현재 시간대를 나타내는 문자열을 반환합니다. 이 문자열은 IsTimeZoneOffsetString이 *true*를 반환하는 UTC 오프셋을 나타내거나, 기본 시간대 식별자일 수 있습니다.
          </dd>
        </dl>

        <emu-alg>
          1. 구현이 UTC 시간대만 지원하면 *"UTC"*를 반환한다.
          1. _systemTimeZoneString_을 호스트 환경의 현재 시간대를 나타내는 문자열(기본 시간대 식별자 또는 오프셋 시간대 식별자)로 한다.
          1. _systemTimeZoneString_을 반환한다.
        </emu-alg>

        <emu-note>
          <p>
            Date 객체의 메서드가 일반적으로 제공하는 기능 수준을 보장하려면, SystemTimeZoneIdentifier가 호스트 환경의 시간대 설정에 대응하는 IANA 시간대 이름을 반환하는 것이 권장됩니다(존재한다면).
            GetNamedTimeZoneEpochNanoseconds와 GetNamedTimeZoneOffsetNanoseconds는 해당 시간대의 표준시 및 서머타임에 대한 지역 정치적 규칙을 반영해야 합니다(존재한다면).
          </p>
          <p>예를 들어, 호스트 환경이 미국 동부 시간대로 설정된 브라우저라면 SystemTimeZoneIdentifier는 *"America/New_York"*을 반환합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-localtime" type="abstract operation">
        <h1>
          LocalTime (
            _t_: 유한한 시간 값,
          ): 정수 Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            _t_를 UTC에서 지역 시간으로 변환합니다.
            _t_ 시점에서 적용되는 표준시 및 서머타임에 대한 지역 정치적 규칙을 적용하여 결과를 결정해야 합니다.
          </dd>
        </dl>
        <emu-alg>
          1. _systemTimeZoneIdentifier_를 SystemTimeZoneIdentifier()로 한다.
          1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_)이 *true*이면
            1. _offsetNs_를 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)로 한다.
          1. 그렇지 않으면,
            1. _offsetNs_를 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>))로 한다.
          1. _offsetMs_를 truncate(_offsetNs_ / 10<sup>6</sup>)로 한다.
          1. _t_ + 𝔽(_offsetMs_)를 반환한다.
        </emu-alg>
        <emu-note>
          <p>구현에 지역 시간 _t_에 대한 정치적 규칙이 없으면, 결과는 _t_입니다. SystemTimeZoneIdentifier가 *"UTC"*이고 GetNamedTimeZoneOffsetNanoseconds가 0을 반환하기 때문입니다.</p>
        </emu-note>
        <emu-note>
          <p>시간대 지원 구현(및 모든 구현에 권장됨)은 IANA Time Zone Database의 시간대 정보를 사용해야 합니다 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
        </emu-note>
        <emu-note>
          <p>음의 시간대 전환(예: 서머타임 종료나 시간대 조정 감소)으로 인해 지역 시간이 반복될 때 서로 다른 입력 시간 값 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>이 동일한 지역 시간 <emu-eqn>t<sub>local</sub></emu-eqn>으로 변환될 수 있습니다.</p>
          <p><emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn>이 항상 <emu-eqn>_t_<sub>local</sub></emu-eqn>과 같지 않을 수 있습니다. 이에 대응하여 <emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> 또한 항상 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>과 같지 않을 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" type="abstract operation">
        <h1>
          UTC (
            _t_: Number,
          ): 시간 값
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>
            _t_를 지역 시간에서 UTC 시간 값으로 변환합니다.
            _t_ 시점에서 적용되는 표준시 및 서머타임에 대한 지역 정치적 규칙을 적용하여 결과를 결정해야 합니다.
          </dd>
        </dl>
        <emu-alg>
          1. _t_가 유한하지 않으면 *NaN*을 반환한다.
          1. _systemTimeZoneIdentifier_를 SystemTimeZoneIdentifier()로 한다.
          1. IsTimeZoneOffsetString(_systemTimeZoneIdentifier_)이 *true*이면
            1. _offsetNs_를 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)로 한다.
          1. 그렇지 않으면,
            1. _possibleInstants_를 GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0)로 한다.
            1. NOTE: 다음 단계는 _t_가 음의 시간대 전환(예: 서머타임 종료나 시간대 오프셋 감소)에서 지역 시간이 여러 번 반복되거나, 양의 시간대 전환(예: 서머타임 시작이나 시간대 오프셋 증가)에서 지역 시간이 건너뛰어진 경우에, 전환 직전의 시간대 오프셋을 사용해 _t_를 해석할 수 있도록 한다.
            1. _possibleInstants_가 비어 있지 않으면
              1. _disambiguatedInstant_를 _possibleInstants_[0]로 한다.
            1. 그렇지 않으면,
              1. NOTE: _t_가 양의 시간대 전환에서 건너뛰어진 지역 시간을 나타낸다(예: 서머타임 시작이나 시간대 오프셋 증가).
              1. [declared="tBefore"] _possibleInstantsBefore_를 GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0)로 한다. 여기서 _tBefore_는 _possibleInstantsBefore_가 비어 있지 않은 가장 큰 정수(< _t_)이다(즉, _tBefore_는 전환 직전의 마지막 지역 시간을 나타낸다).
              1. _disambiguatedInstant_를 _possibleInstantsBefore_의 마지막 요소로 한다.
            1. _offsetNs_를 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_)로 한다.
          1. _offsetMs_를 truncate(_offsetNs_ / 10<sup>6</sup>)로 한다.
          1. _t_ - 𝔽(_offsetMs_)를 반환한다.
        </emu-alg>
        <p>
          입력 _t_는 명목상 시간 값이지만, 어떤 Number 값도 될 수 있습니다.
          알고리즘은 _t_를 시간 값 범위로 제한해서는 안 되며, 지역 UTC 오프셋에 관계없이 경계값에 해당하는 입력도 지원할 수 있어야 합니다.
          예를 들어, 최대 시간 값은 8.64 × 10<sup>15</sup>으로 *"+275760-09-13T00:00:00Z"*에 대응합니다.
          해당 순간의 지역 시간대 오프셋이 UTC보다 1시간 빠른 환경에서는, 입력값이 8.64 × 10<sup>15</sup> + 3.6 × 10<sup>6</sup>이 되고 이는 *"+275760-09-13T01:00:00+01:00"*에 해당합니다.
        </p>
        <p>구현에 지역 시간 _t_에 대한 정치적 규칙이 없으면, 결과는 _t_입니다. SystemTimeZoneIdentifier가 *"UTC"*이고 GetNamedTimeZoneOffsetNanoseconds가 0을 반환하기 때문입니다.</p>
        <emu-note>
          <p>시간대 지원 구현(및 모든 구현에 권장됨)은 IANA Time Zone Database의 시간대 정보를 사용해야 합니다 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>
            2017년 11월 5일 America/New_York의 오전 1:30은 두 번 반복되지만, 반드시 1:30 AM UTC-04로 해석되어야 하며 1:30 AM UTC-05로 해석되어서는 안 됩니다.
            UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))))에서 _offsetMs_ 값은 <emu-eqn>-4 × msPerHour</emu-eqn>입니다.
          </p>
          <p>
            2017년 3월 12일 America/New_York의 오전 2:30은 존재하지 않지만, 반드시 2:30 AM UTC-05(동일한 3:30 AM UTC-04와 동일)로 해석되어야 합니다.
            UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))))에서 _offsetMs_ 값은 <emu-eqn>-5 × msPerHour</emu-eqn>입니다.
          </p>
        </emu-note>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn>이 항상 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>과 같지 않을 수 있습니다. 이에 대응하여 <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> 또한 항상 <emu-eqn>_t_<sub>local</sub></emu-eqn>과 같지 않을 수 있습니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-maketime" type="abstract operation">
        <h1>
          MakeTime (
            _hour_: Number,
            _min_: Number,
            _sec_: Number,
            _ms_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>밀리초 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _hour_, _min_, _sec_, _ms_가 유한하지 않으면 *NaN*을 반환한다.
          1. _h_를 𝔽(! ToIntegerOrInfinity(_hour_))로 한다.
          1. _m_을 𝔽(! ToIntegerOrInfinity(_min_))로 한다.
          1. _s_를 𝔽(! ToIntegerOrInfinity(_sec_))로 한다.
          1. _milli_를 𝔽(! ToIntegerOrInfinity(_ms_))로 한다.
          1. ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_를 반환한다.
        </emu-alg>
        <emu-note>
          <p>MakeTime의 연산은 부동소수점 연산(floating-point arithmetic)으로, 결합법칙이 성립하지 않으므로 반드시 올바른 순서로 연산해야 합니다.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-makeday" type="abstract operation">
        <h1>
          MakeDay (
            _year_: Number,
            _month_: Number,
            _date_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>일(day) 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _year_, _month_, _date_가 유한하지 않으면 *NaN*을 반환한다.
          1. _y_를 𝔽(! ToIntegerOrInfinity(_year_))로 한다.
          1. _m_을 𝔽(! ToIntegerOrInfinity(_month_))로 한다.
          1. _dt_를 𝔽(! ToIntegerOrInfinity(_date_))로 한다.
          1. _ym_을 _y_ + 𝔽(floor(ℝ(_m_) / 12))로 한다.
          1. _ym_이 유한하지 않으면 *NaN*을 반환한다.
          1. _mn_을 𝔽(ℝ(_m_) modulo 12)로 한다.
          1. YearFromTime(_t_)가 _ym_, MonthFromTime(_t_)가 _mn_, DateFromTime(_t_)가 *1*<sub>𝔽</sub>인 유한한 시간 값 _t_를 찾는다. 단, 찾을 수 없다면(인수가 범위 밖인 경우 등) *NaN*을 반환한다.
          1. Day(_t_) + _dt_ - *1*<sub>𝔽</sub>를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makedate" type="abstract operation">
        <h1>
          MakeDate (
            _day_: Number,
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>밀리초 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _day_, _time_이 유한하지 않으면 *NaN*을 반환한다.
          1. _tv_를 _day_ × msPerDay + _time_으로 한다.
          1. _tv_가 유한하지 않으면 *NaN*을 반환한다.
          1. _tv_를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makefullyear" type="abstract operation">
        <h1>
          MakeFullYear (
            _year_: Number,
          ): 정수 Number 또는 *NaN*
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>_year_의 정수 부분에 해당하는 전체 연도를 반환합니다. 0~99 구간의 값은 1900년부터의 연도 수로 해석합니다. 전환 그레고리력과 일치시키기 위해, "전체 연도(full year)"는 0년(기원전 1년)부터의 부호 있는 연도 수로 정의됩니다.</dd>
        </dl>
        <emu-alg>
          1. _year_가 *NaN*이면 *NaN*을 반환한다.
          1. _truncated_를 ! ToIntegerOrInfinity(_year_)로 한다.
          1. _truncated_가 0~99 구간에 있으면 *1900*<sub>𝔽</sub> + 𝔽(_truncated_)를 반환한다.
          1. 𝔽(_truncated_)를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timeclip" type="abstract operation">
        <h1>
          TimeClip (
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>설명</dt>
          <dd>밀리초 수를 계산합니다.</dd>
        </dl>
        <emu-alg>
          1. _time_이 유한하지 않으면 *NaN*을 반환한다.
          1. abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>이면 *NaN*을 반환한다.
          1. 𝔽(! ToIntegerOrInfinity(_time_))를 반환한다.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-time-string-format">
        <h1>날짜-시간 문자열 형식</h1>
        <p>ECMAScript는 ISO 8601 달력 날짜 확장 형식을 단순화한 날짜-시간 문자열 교환 형식을 정의합니다. 형식은 다음과 같습니다: `YYYY-MM-DDTHH:mm:ss.sssZ`</p>
        <p>각 요소의 의미는 다음과 같습니다:</p>
        <figure>
          <table class="lightweight-table">
            <tr>
              <td>
                `YYYY`
              </td>
              <td>
                전환 그레고리력의 연도. 0000~9999의 4자리 십진수, 또는 <emu-xref href="#sec-expanded-years">확장 연도(expanded year)</emu-xref>로서 *"+"* 또는 *"-"* 뒤에 6자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `-`
              </td>
              <td>
                *"-"* (하이픈)은 문자열에 두 번 그대로 나타납니다.
              </td>
            </tr>
            <tr>
              <td>
                `MM`
              </td>
              <td>
                연도의 월(month). 01(1월)~12(12월)까지 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `DD`
              </td>
              <td>
                월의 날짜(day). 01~31의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `T`
              </td>
              <td>
                *"T"*는 문자열에 그대로 나타나며, 시간 요소의 시작임을 나타냅니다.
              </td>
            </tr>
            <tr>
              <td>
                `HH`
              </td>
              <td>
                자정 이후 지난 전체 시간(hour) 수. 00~24의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `:`
              </td>
              <td>
                *":"* (콜론)은 문자열에 두 번 그대로 나타납니다.
              </td>
            </tr>
            <tr>
              <td>
                `mm`
              </td>
              <td>
                시간(hour) 시작 이후 지난 전체 분(minute) 수. 00~59의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `ss`
              </td>
              <td>
                분(minute) 시작 이후 지난 전체 초(second) 수. 00~59의 두 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `.`
              </td>
              <td>
                *"."* (점)은 문자열에 그대로 나타납니다.
              </td>
            </tr>
            <tr>
              <td>
                `sss`
              </td>
              <td>
                초(second) 시작 이후 지난 전체 밀리초(millisecond) 수. 세 자리 십진수.
              </td>
            </tr>
            <tr>
              <td>
                `Z`
              </td>
              <td>
                UTC 오프셋 표현. *"Z"* (오프셋 없는 UTC), 혹은 *"+"* 또는 *"-"* 뒤에 시간 표현 `HH:mm` (UTC 앞 또는 뒤의 지역 시간을 나타내는 <emu-xref href="#sec-time-zone-offset-strings">시간대 오프셋 문자열 형식</emu-xref>의 부분집합)
              </td>
            </tr>
          </table>
        </figure>
        <p>이 형식은 날짜만을 포함하는 형태도 지원합니다:</p>
        <pre>
YYYY
YYYY-MM
YYYY-MM-DD
        </pre>
        <p>또한 위의 날짜만 형식 뒤에 다음 시간 형식이 바로 붙고 선택적 UTC 오프셋 표현이 뒤따르는 “날짜-시간” 형식도 지원합니다:</p>
        <pre>
THH:mm
THH:mm:ss
THH:mm:ss.sss
        </pre>
        <p>형식에 맞지 않거나 범위를 벗어난 요소를 포함한 문자열은 이 형식의 유효한 인스턴스가 아닙니다.</p>
        <emu-note>
          <p>모든 날짜는 자정으로 시작하고 자정으로 끝나므로, `00:00`과 `24:00` 표기법 모두 한 날짜에 연관된 두 자정을 구분할 수 있습니다. 즉, `1995-02-04T24:00`과 `1995-02-05T00:00`은 정확히 같은 시점을 의미합니다. 후자의 형식을 “달력 날짜의 끝”으로 해석하는 것은 ISO 8601과 일치합니다(이 명세는 시간 구간을 설명할 때만 이 표기를 허용하며 단일 시점 표현에는 허용하지 않음).</p>
        </emu-note>
        <emu-note>
          <p>CET, EST 등과 같은 민간 시간대 약어에 대한 국제 표준은 없으며, 약어가 서로 다른 두 시간대를 동시에 나타낼 수도 있습니다. 이런 이유로 ISO 8601과 이 형식 모두 시간대 오프셋을 숫자 표현으로 지정합니다.</p>
        </emu-note>

        <emu-clause id="sec-expanded-years" oldids="sec-extended-years">
          <h1>확장 연도</h1>
          <p>1970년 1월 1일 기준 약 273,790년 전후의 전체 시간 값 범위를 나타내려면 0년 이전 또는 9999년 이후의 연도 표현이 필요합니다(<emu-xref href="#sec-time-values-and-time-range"></emu-xref>). ISO 8601은 연도 표현의 확장을 허용하지만, 정보 교환 당사자 간의 합의가 있을 때만 허용합니다. ECMAScript 단순화 형식에서는 확장 연도 표현이 6자리 숫자로 되어야 하며 항상 + 또는 - 기호가 붙습니다. 0년은 양수로 간주하고 반드시 + 기호를 붙여야 합니다. -000000 형식의 0년 표현은 유효하지 않습니다. 확장 연도가 시간 값 범위를 벗어나는 경우, <emu-xref href="#sec-date-time-string-format">날짜-시간 문자열 형식</emu-xref>과 일치하는 문자열이라도 <emu-xref href="#sec-date.parse">`Date.parse`</emu-xref>에서 인식되지 않으며, 해당 함수는 구현별 동작이나 휴리스틱 없이 *NaN*을 반환합니다.</p>
          <emu-note>
            <p>확장 연도가 포함된 날짜-<emu-not-ref>시간 값</emu-not-ref> 예시:</p>
            <figure>
              <table class="lightweight-table">
                <tr>
                  <td>-271821-04-20T00:00:00Z</td>
                  <td>기원전 271822년</td>
                </tr>
                <tr>
                  <td>-000001-01-01T00:00:00Z</td>
                  <td>기원전 2년</td>
                </tr>
                <tr>
                  <td>+000000-01-01T00:00:00Z</td>
                  <td>기원전 1년</td>
                </tr>
                <tr>
                  <td>+000001-01-01T00:00:00Z</td>
                  <td>서기 1년</td>
                </tr>
                <tr>
                  <td>+001970-01-01T00:00:00Z</td>
                  <td>서기 1970년</td>
                </tr>
                <tr>
                  <td>+002009-12-15T00:00:00Z</td>
                  <td>서기 2009년</td>
                </tr>
                <tr>
                  <td>+275760-09-13T00:00:00Z</td>
                  <td>서기 275760년</td>
                </tr>
              </table>
            </figure>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-time-zone-offset-strings">
        <h1>시간대 오프셋 문자열 형식</h1>

        <p>
          ECMAScript는 ISO 8601에서 파생된 UTC 오프셋의 문자열 교환 형식을 정의합니다.
          이 형식은 다음 문법으로 설명됩니다.
        </p>

        <h2>문법</h2>
        <emu-grammar type="definition">
          UTCOffset :::
            ASCIISign Hour
            ASCIISign Hour HourSubcomponents[+Extended]
            ASCIISign Hour HourSubcomponents[~Extended]

          ASCIISign ::: one of
            `+` `-`

          Hour :::
            `0` DecimalDigit
            `1` DecimalDigit
            `20`
            `21`
            `22`
            `23`

          HourSubcomponents[Extended] :::
            TimeSeparator[?Extended] MinuteSecond
            TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction?

          TimeSeparator[Extended] :::
            [+Extended] `:`
            [~Extended] [empty]

          MinuteSecond :::
            `0` DecimalDigit
            `1` DecimalDigit
            `2` DecimalDigit
            `3` DecimalDigit
            `4` DecimalDigit
            `5` DecimalDigit

          TemporalDecimalFraction :::
            TemporalDecimalSeparator DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

          TemporalDecimalSeparator ::: one of
            `.` `,`
        </emu-grammar>

        <emu-clause id="sec-istimezoneoffsetstring" type="abstract operation">
          <h1>
            IsTimeZoneOffsetString (
              _offsetString_: 문자열,
            ): 불리언(Boolean)
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd>반환 값은 _offsetString_이 |UTCOffset| 문법에 맞는지 여부를 나타냅니다.</dd>
          </dl>
          <emu-alg>
            1. _parseResult_를 ParseText(_offsetString_, |UTCOffset|)로 한다.
            1. _parseResult_가 오류 목록이면 *false*를 반환한다.
            1. *true*를 반환한다.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parsetimezoneoffsetstring" type="abstract operation">
          <h1>
            ParseTimeZoneOffsetString (
              _offsetString_: 문자열,
            ): 정수
          </h1>
          <dl class="header">
            <dt>설명</dt>
            <dd>반환 값은 _offsetString_에 해당하는 UTC 오프셋(나노초 단위)입니다.</dd>
          </dl>
          <emu-alg>
            1. _parseResult_를 ParseText(_offsetString_, |UTCOffset|)로 한다.
            1. Assert: _parseResult_가 오류 목록이 아님을 보장한다.
            1. Assert: _parseResult_에 |ASCIISign| Parse Node가 포함됨을 보장한다.
            1. _parsedSign_을 _parseResult_에 포함된 |ASCIISign| Parse Node가 일치시킨 소스 텍스트로 한다.
            1. _parsedSign_이 U+002D(하이픈) 단일 코드 포인트면
              1. _sign_을 -1로 한다.
            1. 그렇지 않으면
              1. _sign_을 1로 한다.
            1. NOTE: 아래 StringToNumber 이용 시 정밀도 손실 없음(파싱된 값은 충분히 짧은 십진수 문자열임이 보장됨).
            1. Assert: _parseResult_에 |Hour| Parse Node가 포함됨을 보장한다.
            1. _parsedHours_를 _parseResult_에 포함된 |Hour| Parse Node가 일치시킨 소스 텍스트로 한다.
            1. _hours_를 ℝ(StringToNumber(CodePointsToString(_parsedHours_)))로 한다.
            1. _parseResult_에 |MinuteSecond| Parse Node가 없으면
              1. _minutes_를 0으로 한다.
            1. 그렇지 않으면
              1. _parsedMinutes_를 _parseResult_에 포함된 첫 |MinuteSecond| Parse Node가 일치시킨 소스 텍스트로 한다.
              1. _minutes_를 ℝ(StringToNumber(CodePointsToString(_parsedMinutes_)))로 한다.
            1. _parseResult_에 두 번째 |MinuteSecond| Parse Node가 없으면
              1. _seconds_를 0으로 한다.
            1. 그렇지 않으면
              1. _parsedSeconds_를 _parseResult_에 포함된 두 번째 |MinuteSecond| Parse Node가 일치시킨 소스 텍스트로 한다.
              1. _seconds_를 ℝ(StringToNumber(CodePointsToString(_parsedSeconds_)))로 한다.
            1. _parseResult_에 |TemporalDecimalFraction| Parse Node가 없으면
              1. _nanoseconds_를 0으로 한다.
            1. 그렇지 않으면
              1. _parsedFraction_을 _parseResult_에 포함된 |TemporalDecimalFraction| Parse Node가 일치시킨 소스 텍스트로 한다.
              1. _fraction_을 CodePointsToString(_parsedFraction_)과 *"000000000"*을 이어붙인 문자열로 한다.
              1. _nanosecondsString_을 _fraction_의 1~10번째 부분 문자열로 한다.
              1. _nanoseconds_를 ℝ(StringToNumber(_nanosecondsString_))로 한다.
            1. _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_)를 반환한다.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-date-constructor" oldids="this-time-value,sec-thistimevalue,thistimevalue,this-Date-object">
      <h1>The Date Constructor</h1>
      <p>The Date constructor:</p>
      <ul>
        <li>is <dfn>%Date%</dfn>.</li>
        <li>is the initial value of the *"Date"* property of the global object.</li>
        <li>creates and initializes a new Date when called as a constructor.</li>
        <li>returns a String representing the current time (UTC) when called as a function rather than as a constructor.</li>
        <li>is a function whose behaviour differs based upon the number and types of its arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Date behaviour must include a `super` call to the Date constructor to create and initialize the subclass instance with a [[DateValue]] internal slot.</li>
      </ul>

      <emu-clause id="sec-date" oldids="sec-date-constructor-date,sec-date-value,sec-date-year-month-date-hours-minutes-seconds-ms">
        <h1>Date ( ..._values_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, then
            1. Let _now_ be the time value (UTC) identifying the current time.
            1. Return ToDateString(_now_).
          1. Let _numberOfArgs_ be the number of elements in _values_.
          1. If _numberOfArgs_ = 0, then
            1. Let _dv_ be the time value (UTC) identifying the current time.
          1. Else if _numberOfArgs_ = 1, then
            1. Let _value_ be _values_[0].
            1. If _value_ is an Object and _value_ has a [[DateValue]] internal slot, then
              1. Let _tv_ be _value_.[[DateValue]].
            1. Else,
              1. Let _v_ be ? ToPrimitive(_value_).
              1. If _v_ is a String, then
                1. Assert: The next step never returns an abrupt completion because _v_ is a String.
                1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href="#sec-date.parse"></emu-xref>).
              1. Else,
                1. Let _tv_ be ? ToNumber(_v_).
            1. Let _dv_ be TimeClip(_tv_).
          1. Else,
            1. Assert: _numberOfArgs_ ≥ 2.
            1. Let _y_ be ? ToNumber(_values_[0]).
            1. Let _m_ be ? ToNumber(_values_[1]).
            1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]); else let _dt_ be *1*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]); else let _h_ be *+0*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]); else let _min_ be *+0*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]); else let _s_ be *+0*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]); else let _milli_ be *+0*<sub>𝔽</sub>.
            1. Let _yr_ be MakeFullYear(_y_).
            1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).
            1. Let _dv_ be TimeClip(UTC(_finalDate_)).
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Date.prototype%"*, « [[DateValue]] »).
          1. Set _O_.[[DateValue]] to _dv_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Properties of the Date Constructor</h1>
      <p>The Date constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"length"* property whose value is *7*<sub>𝔽</sub>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-date.now">
        <h1>Date.now ( )</h1>
        <p>This function returns the time value designating the UTC date and time of the occurrence of the call to it.</p>
      </emu-clause>

      <emu-clause id="sec-date.parse">
        <h1>Date.parse ( _string_ )</h1>
        <p>This function applies the ToString operator to its argument. If ToString results in an abrupt completion the Completion Record is immediately returned. Otherwise, this function interprets the resulting String as a date and time; it returns a Number, the UTC time value corresponding to the date and time. The String may be interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the String. The function first attempts to parse the String according to the format described in Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>), including expanded years. If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. Strings that are unrecognizable or contain out-of-bounds format element values shall cause this function to return *NaN*.</p>
        <p>If the String conforms to the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>, substitute values take the place of absent format elements. When the `MM` or `DD` elements are absent, *"01"* is used. When the `HH`, `mm`, or `ss` elements are absent, *"00"* is used. When the `sss` element is absent, *"000"* is used. When the UTC offset representation is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time.</p>
        <p>If `x` is any Date whose milliseconds amount is zero within a particular implementation of ECMAScript, then all of the following expressions should produce the same numeric value in that implementation, if all the properties referenced have their initial values:</p>
        <pre><code class="javascript">
          x.valueOf()
          Date.parse(x.toString())
          Date.parse(x.toUTCString())
          Date.parse(x.toISOString())
        </code></pre>
        <p>However, the expression</p>
        <pre><code class="javascript">
          Date.parse(x.toLocaleString())
        </code></pre>
        <p>is not required to produce the same Number value as the preceding three expressions and, in general, the value produced by this function is implementation-defined when given any String value that does not conform to the Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>) and that could not be produced in that implementation by the `toString` or `toUTCString` method.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype">
        <h1>Date.prototype</h1>
        <p>The initial value of `Date.prototype` is the Date prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-date.utc">
        <h1>Date.UTC ( _year_ [ , _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is present, let _m_ be ? ToNumber(_month_); else let _m_ be *+0*<sub>𝔽</sub>.
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be *1*<sub>𝔽</sub>.
          1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be *+0*<sub>𝔽</sub>.
          1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be *+0*<sub>𝔽</sub>.
          1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be *+0*<sub>𝔽</sub>.
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be *+0*<sub>𝔽</sub>.
          1. Let _yr_ be MakeFullYear(_y_).
          1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))).
        </emu-alg>
        <p>The *"length"* property of this function is *7*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This function differs from the Date constructor in two ways: it returns a time value as a Number, rather than creating a Date, and it interprets the arguments in UTC rather than as local time.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-prototype-object">
      <h1>Properties of the Date Prototype Object</h1>
      <p>The <dfn>Date prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Date.prototype%</dfn>.</li>
        <li>is itself an ordinary object.</li>
        <li>is not a Date instance and does not have a [[DateValue]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <p>Unless explicitly defined otherwise, the methods of the Date prototype object defined below are not generic and the *this* value passed to them must be an object that has a [[DateValue]] internal slot that has been initialized to a time value.</p>

      <emu-clause id="sec-date.prototype.constructor">
        <h1>Date.prototype.constructor</h1>
        <p>The initial value of `Date.prototype.constructor` is %Date%.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getdate">
        <h1>Date.prototype.getDate ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return DateFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getday">
        <h1>Date.prototype.getDay ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return WeekDay(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getfullyear">
        <h1>Date.prototype.getFullYear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gethours">
        <h1>Date.prototype.getHours ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return HourFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmilliseconds">
        <h1>Date.prototype.getMilliseconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return msFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getminutes">
        <h1>Date.prototype.getMinutes ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MinFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmonth">
        <h1>Date.prototype.getMonth ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MonthFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getseconds">
        <h1>Date.prototype.getSeconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return SecFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettime">
        <h1>Date.prototype.getTime ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Return _dateObject_.[[DateValue]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettimezoneoffset">
        <h1>Date.prototype.getTimezoneOffset ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return (_t_ - LocalTime(_t_)) / msPerMinute.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcdate">
        <h1>Date.prototype.getUTCDate ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return DateFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcday">
        <h1>Date.prototype.getUTCDay ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return WeekDay(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcfullyear">
        <h1>Date.prototype.getUTCFullYear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutchours">
        <h1>Date.prototype.getUTCHours ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return HourFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmilliseconds">
        <h1>Date.prototype.getUTCMilliseconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return msFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcminutes">
        <h1>Date.prototype.getUTCMinutes ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MinFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmonth">
        <h1>Date.prototype.getUTCMonth ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MonthFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcseconds">
        <h1>Date.prototype.getUTCSeconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return SecFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setdate">
        <h1>Date.prototype.setDate ( _date_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setfullyear">
        <h1>Date.prototype.setFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _y_ be ? ToNumber(_year_).
          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise set _t_ to LocalTime(_t_).
          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _month_ is not present, this method behaves as if _month_ was present with the value `getMonth()`. If _date_ is not present, it behaves as if _date_ was present with the value `getDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.sethours">
        <h1>Date.prototype.setHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _h_ be ? ToNumber(_hour_).
          1. If _min_ is present, let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _min_ is not present, let _m_ be MinFromTime(_t_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *4*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _min_ is not present, this method behaves as if _min_ was present with the value `getMinutes()`. If _sec_ is not present, it behaves as if _sec_ was present with the value `getSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmilliseconds">
        <h1>Date.prototype.setMilliseconds ( _ms_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Set _ms_ to ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).
          1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setminutes">
        <h1>Date.prototype.setMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _sec_ is not present, this method behaves as if _sec_ was present with the value `getSeconds()`. If _ms_ is not present, this behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmonth">
        <h1>Date.prototype.setMonth ( _month_ [ , _date_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_month_).
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _date_ is not present, this method behaves as if _date_ was present with the value `getDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setseconds">
        <h1>Date.prototype.setSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _ms_ is not present, this method behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.settime">
        <h1>Date.prototype.setTime ( _time_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be ? ToNumber(_time_).
          1. Let _v_ be TimeClip(_t_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcdate">
        <h1>Date.prototype.setUTCDate ( _date_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcfullyear">
        <h1>Date.prototype.setUTCFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _month_ is not present, this method behaves as if _month_ was present with the value `getUTCMonth()`. If _date_ is not present, it behaves as if _date_ was present with the value `getUTCDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutchours">
        <h1>Date.prototype.setUTCHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _h_ be ? ToNumber(_hour_).
          1. If _min_ is present, let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _min_ is not present, let _m_ be MinFromTime(_t_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *4*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _min_ is not present, this method behaves as if _min_ was present with the value `getUTCMinutes()`. If _sec_ is not present, it behaves as if _sec_ was present with the value `getUTCSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmilliseconds">
        <h1>Date.prototype.setUTCMilliseconds ( _ms_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Set _ms_ to ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).
          1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcminutes">
        <h1>Date.prototype.setUTCMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _sec_ is not present, this method behaves as if _sec_ was present with the value `getUTCSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value return by `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmonth">
        <h1>Date.prototype.setUTCMonth ( _month_ [ , _date_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_month_).
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _date_ is not present, this method behaves as if _date_ was present with the value `getUTCDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcseconds">
        <h1>Date.prototype.setUTCSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _ms_ is not present, this method behaves as if _ms_ was present with the value `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.todatestring">
        <h1>Date.prototype.toDateString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, return *"Invalid Date"*.
          1. Let _t_ be LocalTime(_tv_).
          1. Return DateString(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toisostring">
        <h1>Date.prototype.toISOString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, throw a *RangeError* exception.
          1. Assert: _tv_ is an integral Number.
          1. If _tv_ corresponds with a year that cannot be represented in the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>, throw a *RangeError* exception.
          1. Return a String representation of _tv_ in the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> on the UTC time scale, including all format elements and the UTC offset representation *"Z"*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tojson">
        <h1>Date.prototype.toJSON ( _key_ )</h1>
        <p>This method provides a String representation of a Date for use by `JSON.stringify` (<emu-xref href="#sec-json.stringify"></emu-xref>).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _tv_ be ? ToPrimitive(_O_, ~number~).
          1. If _tv_ is a Number and _tv_ is not finite, return *null*.
          1. Return ? Invoke(_O_, *"toISOString"*).
        </emu-alg>
        <emu-note>
          <p>The argument is ignored.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a Date. Therefore, it can be transferred to other kinds of objects for use as a method. However, it does require that any such object have a `toISOString` method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaledatestring">
        <h1>Date.prototype.toLocaleDateString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a String value. The contents of the String are implementation-defined, but are intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocalestring">
        <h1>Date.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a String value. The contents of the String are implementation-defined, but are intended to represent the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaletimestring">
        <h1>Date.prototype.toLocaleTimeString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a String value. The contents of the String are implementation-defined, but are intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. Return ToDateString(_tv_).
        </emu-alg>
        <emu-note>
          <p>For any Date `d` such that `d.[[DateValue]]` is evenly divisible by 1000, the result of `Date.parse(d.toString())` = `d.valueOf()`. See <emu-xref href="#sec-date.parse"></emu-xref>.</p>
        </emu-note>
        <emu-note>
          <p>This method is not generic; it throws a *TypeError* exception if its *this* value is not a Date. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-timestring" type="abstract operation">
          <h1>
            TimeString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _hour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2).
            1. Let _minute_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2).
            1. Let _second_ be ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2).
            1. Return the string-concatenation of _hour_, *":"*, _minute_, *":"*, _second_, the code unit 0x0020 (SPACE), and *"GMT"*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-datestring" type="abstract operation">
          <h1>
            DateString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _weekday_ be the Name of the entry in <emu-xref href="#sec-todatestring-day-names"></emu-xref> with the Number WeekDay(_tv_).
            1. Let _month_ be the Name of the entry in <emu-xref href="#sec-todatestring-month-names"></emu-xref> with the Number MonthFromTime(_tv_).
            1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).
            1. Let _yv_ be YearFromTime(_tv_).
            1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise let _yearSign_ be *"-"*.
            1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).
            1. Return the string-concatenation of _weekday_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _yearSign_, and _paddedYear_.
          </emu-alg>
          <emu-table id="sec-todatestring-day-names" caption="Names of days of the week">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sun"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mon"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Tue"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Wed"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"Thu"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Fri"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sat"*
                </td>
              </tr>
            </table>
          </emu-table>
          <emu-table id="sec-todatestring-month-names" caption="Names of months of the year">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jan"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Feb"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mar"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Apr"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"May"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jun"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jul"*
                </td>
              </tr>
              <tr>
                <td>
                  *7*<sub>𝔽</sub>
                </td>
                <td>
                  *"Aug"*
                </td>
              </tr>
              <tr>
                <td>
                  *8*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sep"*
                </td>
              </tr>
              <tr>
                <td>
                  *9*<sub>𝔽</sub>
                </td>
                <td>
                  *"Oct"*
                </td>
              </tr>
              <tr>
                <td>
                  *10*<sub>𝔽</sub>
                </td>
                <td>
                  *"Nov"*
                </td>
              </tr>
              <tr>
                <td>
                  *11*<sub>𝔽</sub>
                </td>
                <td>
                  *"Dec"*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>

        <emu-clause id="sec-timezoneestring" type="abstract operation">
          <h1>
            TimeZoneString (
              _tv_: an integral Number,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().
            1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then
              1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).
            1. Else,
              1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>)).
            1. Let _offset_ be 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>)).
            1. If _offset_ is *+0*<sub>𝔽</sub> or _offset_ > *+0*<sub>𝔽</sub>, then
              1. Let _offsetSign_ be *"+"*.
              1. Let _absOffset_ be _offset_.
            1. Else,
              1. Let _offsetSign_ be *"-"*.
              1. Let _absOffset_ be -_offset_.
            1. Let _offsetMin_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2).
            1. Let _offsetHour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2).
            1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-todatestring" type="abstract operation">
          <h1>
            ToDateString (
              _tv_: an integral Number or *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _tv_ is *NaN*, return *"Invalid Date"*.
            1. Let _t_ be LocalTime(_tv_).
            1. Return the string-concatenation of DateString(_t_), the code unit 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-date.prototype.totimestring">
        <h1>Date.prototype.toTimeString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, return *"Invalid Date"*.
          1. Let _t_ be LocalTime(_tv_).
          1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toutcstring">
        <h1>Date.prototype.toUTCString ( )</h1>
        <p>This method returns a String value representing the instant in time corresponding to the *this* value. The format of the String is based upon "HTTP-date" from RFC 7231, generalized to support the full range of times supported by ECMAScript Dates.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, return *"Invalid Date"*.
          1. Let _weekday_ be the Name of the entry in <emu-xref href="#sec-todatestring-day-names"></emu-xref> with the Number WeekDay(_tv_).
          1. Let _month_ be the Name of the entry in <emu-xref href="#sec-todatestring-month-names"></emu-xref> with the Number MonthFromTime(_tv_).
          1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).
          1. Let _yv_ be YearFromTime(_tv_).
          1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise let _yearSign_ be *"-"*.
          1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).
          1. Return the string-concatenation of _weekday_, *","*, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _yearSign_, _paddedYear_, the code unit 0x0020 (SPACE), and TimeString(_tv_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.valueof">
        <h1>Date.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Return _dateObject_.[[DateValue]].
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-date.prototype-@@toprimitive" id="sec-date.prototype-%symbol.toprimitive%">
        <h1>Date.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>This method is called by ECMAScript language operators to convert a Date to a primitive value. The allowed values for _hint_ are *"default"*, *"number"*, and *"string"*. Dates are unique among built-in ECMAScript object in that they treat *"default"* as being equivalent to *"string"*, All other built-in ECMAScript objects treat *"default"* as being equivalent to *"number"*.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. If _hint_ is either *"string"* or *"default"*, then
            1. Let _tryFirst_ be ~string~.
          1. Else if _hint_ is *"number"*, then
            1. Let _tryFirst_ be ~number~.
          1. Else,
            1. Throw a *TypeError* exception.
          1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_).
        </emu-alg>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The value of the *"name"* property of this method is *"[Symbol.toPrimitive]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-date-instances">
      <h1>Properties of Date Instances</h1>
      <p>Date instances are ordinary objects that inherit properties from the Date prototype object. Date instances also have a [[DateValue]] internal slot. The [[DateValue]] internal slot is the time value represented by this Date.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>Text Processing</h1>

  <emu-clause id="sec-string-objects">
    <h1>String Objects</h1>

    <emu-clause id="sec-string-constructor">
      <h1>The String Constructor</h1>
      <p>The String constructor:</p>
      <ul>
        <li>is <dfn>%String%</dfn>.</li>
        <li>is the initial value of the *"String"* property of the global object.</li>
        <li>creates and initializes a new String object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified String behaviour must include a `super` call to the String constructor to create and initialize the subclass instance with a [[StringData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-string-constructor-string-value">
        <h1>String ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is not present, then
            1. Let _s_ be the empty String.
          1. Else,
            1. If NewTarget is *undefined* and _value_ is a Symbol, return SymbolDescriptiveString(_value_).
            1. Let _s_ be ? ToString(_value_).
          1. If NewTarget is *undefined*, return _s_.
          1. Return StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *"%String.prototype%"*)).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>Properties of the String Constructor</h1>
      <p>The String constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-string.fromcharcode">
        <h1>String.fromCharCode ( ..._codeUnits_ )</h1>
        <p>This function may be called with any number of arguments which form the rest parameter _codeUnits_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _result_ be the empty String.
          1. For each element _next_ of _codeUnits_, do
            1. Let _nextCU_ be the code unit whose numeric value is ℝ(? ToUint16(_next_)).
            1. Set _result_ to the string-concatenation of _result_ and _nextCU_.
          1. Return _result_.
        </emu-alg>
        <p>The *"length"* property of this function is *1*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-string.fromcodepoint">
        <h1>String.fromCodePoint ( ..._codePoints_ )</h1>
        <p>This function may be called with any number of arguments which form the rest parameter _codePoints_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _result_ be the empty String.
          1. For each element _next_ of _codePoints_, do
            1. Let _nextCP_ be ? ToNumber(_next_).
            1. If _nextCP_ is not an integral Number, throw a *RangeError* exception.
            1. If ℝ(_nextCP_) &lt; 0 or ℝ(_nextCP_) > 0x10FFFF, throw a *RangeError* exception.
            1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(ℝ(_nextCP_)).
          1. Assert: If _codePoints_ is empty, then _result_ is the empty String.
          1. Return _result_.
        </emu-alg>
        <p>The *"length"* property of this function is *1*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype">
        <h1>String.prototype</h1>
        <p>The initial value of `String.prototype` is the String prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-string.raw">
        <h1>String.raw ( _template_, ..._substitutions_ )</h1>
        <p>This function may be called with a variable number of arguments. The first argument is _template_ and the remainder of the arguments form the List _substitutions_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _substitutionCount_ be the number of elements in _substitutions_.
          1. Let _cooked_ be ? ToObject(_template_).
          1. Let _literals_ be ? ToObject(? Get(_cooked_, *"raw"*)).
          1. Let _literalCount_ be ? LengthOfArrayLike(_literals_).
          1. If _literalCount_ ≤ 0, return the empty String.
          1. Let _R_ be the empty String.
          1. Let _nextIndex_ be 0.
          1. Repeat,
            1. Let _nextLiteralVal_ be ? Get(_literals_, ! ToString(𝔽(_nextIndex_))).
            1. Let _nextLiteral_ be ? ToString(_nextLiteralVal_).
            1. Set _R_ to the string-concatenation of _R_ and _nextLiteral_.
            1. If _nextIndex_ + 1 = _literalCount_, return _R_.
            1. If _nextIndex_ &lt; _substitutionCount_, then
              1. Let _nextSubVal_ be _substitutions_[_nextIndex_].
              1. Let _nextSub_ be ? ToString(_nextSubVal_).
              1. Set _R_ to the string-concatenation of _R_ and _nextSub_.
            1. Set _nextIndex_ to _nextIndex_ + 1.
        </emu-alg>
        <emu-note>
          <p>This function is intended for use as a tag function of a Tagged Template (<emu-xref href="#sec-tagged-templates"></emu-xref>). When called as such, the first argument will be a well formed template object and the rest parameter will contain the substitution values.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>Properties of the String Prototype Object</h1>
      <p>The <dfn>String prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%String.prototype%</dfn>.</li>
        <li>is a String exotic object and has the internal methods specified for such objects.</li>
        <li>has a [[StringData]] internal slot whose value is the empty String.</li>
        <li>has a *"length"* property whose initial value is *+0*<sub>𝔽</sub> and whose attributes are { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <p>Unless explicitly stated otherwise, the methods of the String prototype object defined below are not generic and the *this* value passed to them must be either a String value or an object that has a [[StringData]] internal slot that has been initialized to a String value.</p>

      <emu-clause id="sec-string.prototype.at">
        <h1>String.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ ≥ _len_, return *undefined*.
          1. Return the substring of _S_ from _k_ to _k_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charat">
        <h1>String.prototype.charAt ( _pos_ )</h1>
        <emu-note>
          <p>This method returns a single element String containing the code unit at index _pos_ within the String value resulting from converting this object to a String. If there is no element at that index, the result is the empty String. The result is a String value, not a String object.</p>
          <p>If `pos` is an integral Number, then the result of `x.charAt(pos)` is equivalent to the result of `x.substring(pos, pos + 1)`.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ ≥ _size_, return the empty String.
          1. Return the substring of _S_ from _position_ to _position_ + 1.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charcodeat">
        <h1>String.prototype.charCodeAt ( _pos_ )</h1>
        <emu-note>
          <p>This method returns a Number (a non-negative integral Number less than 2<sup>16</sup>) that is the numeric value of the code unit at index _pos_ within the String resulting from converting this object to a String. If there is no element at that index, the result is *NaN*.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ ≥ _size_, return *NaN*.
          1. Return the Number value for the numeric value of the code unit at index _position_ within the String _S_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.codepointat">
        <h1>String.prototype.codePointAt ( _pos_ )</h1>
        <emu-note>
          <p>This method returns a non-negative integral Number less than or equal to *0x10FFFF*<sub>𝔽</sub> that is the numeric value of the UTF-16 encoded code point (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) starting at the string element at index _pos_ within the String resulting from converting this object to a String. If there is no element at that index, the result is *undefined*. If a valid UTF-16 surrogate pair does not begin at _pos_, the result is the code unit at _pos_.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ ≥ _size_, return *undefined*.
          1. Let _cp_ be CodePointAt(_S_, _position_).
          1. Return 𝔽(_cp_.[[CodePoint]]).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.concat">
        <h1>String.prototype.concat ( ..._args_ )</h1>
        <emu-note>
          <p>When this method is called it returns the String value consisting of the code units of the *this* value (converted to a String) followed by the code units of each of the arguments converted to a String. The result is a String value, not a String object.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _R_ be _S_.
          1. For each element _next_ of _args_, do
            1. Let _nextString_ be ? ToString(_next_).
            1. Set _R_ to the string-concatenation of _R_ and _nextString_.
          1. Return _R_.
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.constructor">
        <h1>String.prototype.constructor</h1>
        <p>The initial value of `String.prototype.constructor` is %String%.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype.endswith">
        <h1>String.prototype.endsWith ( _searchString_ [ , _endPosition_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _len_ be the length of _S_.
          1. If _endPosition_ is *undefined*, let _pos_ be _len_; else let _pos_ be ? ToIntegerOrInfinity(_endPosition_).
          1. Let _end_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _searchLength_ be the length of _searchStr_.
          1. If _searchLength_ = 0, return *true*.
          1. Let _start_ be _end_ - _searchLength_.
          1. If _start_ &lt; 0, return *false*.
          1. Let _substring_ be the substring of _S_ from _start_ to _end_.
          1. If _substring_ is _searchStr_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method returns *true* if the sequence of code units of _searchString_ converted to a String is the same as the corresponding code units of this object (converted to a String) starting at _endPosition_ - length(this). Otherwise it returns *false*.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.includes">
        <h1>String.prototype.includes ( _searchString_ [ , _position_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _index_ be StringIndexOf(_S_, _searchStr_, _start_).
          1. If _index_ is ~not-found~, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>If _searchString_ appears as a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, at one or more indices that are greater than or equal to _position_, this function returns *true*; otherwise, it returns *false*. If _position_ is *undefined*, 0 is assumed, so as to search all of the String.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.indexof">
        <h1>String.prototype.indexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>If _searchString_ appears as a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, at one or more indices that are greater than or equal to _position_, then the smallest such index is returned; otherwise, *-1*<sub>𝔽</sub> is returned. If _position_ is *undefined*, *+0*<sub>𝔽</sub> is assumed, so as to search all of the String.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _result_ be StringIndexOf(_S_, _searchStr_, _start_).
          1. If _result_ is ~not-found~, return *-1*<sub>𝔽</sub>.
          1. Return 𝔽(_result_).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.iswellformed">
        <h1>String.prototype.isWellFormed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Return IsStringWellFormedUnicode(_S_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.lastindexof">
        <h1>String.prototype.lastIndexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>If _searchString_ appears as a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String at one or more indices that are smaller than or equal to _position_, then the greatest such index is returned; otherwise, *-1*<sub>𝔽</sub> is returned. If _position_ is *undefined*, the length of the String value is assumed, so as to search all of the String.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _numPos_ be ? ToNumber(_position_).
          1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.
          1. If _numPos_ is *NaN*, let _pos_ be +∞; otherwise let _pos_ be ! ToIntegerOrInfinity(_numPos_).
          1. Let _len_ be the length of _S_.
          1. Let _searchLen_ be the length of _searchStr_.
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_ - _searchLen_.
          1. Let _result_ be StringLastIndexOf(_S_, _searchStr_, _start_).
          1. If _result_ is ~not-found~, return *-1*<sub>𝔽</sub>.
          1. Return 𝔽(_result_).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.localecompare">
        <h1>String.prototype.localeCompare ( _that_ [ , _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a Number other than *NaN* representing the result of an implementation-defined locale-sensitive String comparison of the *this* value (converted to a String _S_) with _that_ (converted to a String _thatValue_). The result is intended to correspond with a sort order of String values according to conventions of the host environment's current locale, and will be negative when _S_ is ordered before _thatValue_, positive when _S_ is ordered after _thatValue_, and zero in all other cases (representing no relative ordering between _S_ and _thatValue_).</p>
        <p>Before performing the comparisons, this method performs the following steps to prepare the Strings:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _thatValue_ be ? ToString(_that_).
        </emu-alg>
        <p>The meaning of the optional second and third parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not assign any other interpretation to those parameter positions.</p>
        <p>The actual return values are implementation-defined to permit encoding additional information in them, but this method, when considered as a method of two arguments, is required to be a consistent comparator defining a total ordering on the set of all Strings. This method is also required to recognize and honour canonical equivalence according to the Unicode Standard, including returning *+0*<sub>𝔽</sub> when comparing distinguishable Strings that are canonically equivalent.</p>
        <emu-note>
          <p>This method itself is not directly suitable as an argument to `Array.prototype.sort` because the latter requires a function of two arguments.</p>
        </emu-note>
        <emu-note>
          <p>This method may rely on whatever language- and/or locale-sensitive comparison functionality is available to the ECMAScript environment from the host environment, and is intended to compare according to the conventions of the host environment's current locale. However, regardless of comparison capabilities, this method must recognize and honour canonical equivalence according to the Unicode Standard—for example, the following comparisons must all return *+0*<sub>𝔽</sub>:</p>
          <pre><code class="javascript">
            // &#x212B; ANGSTROM SIGN vs.
            // A&#x030A; LATIN CAPITAL LETTER A + COMBINING RING ABOVE
            "\u212B".localeCompare("A\u030A")

            // &#x2126; OHM SIGN vs.
            // &#x03A9; GREEK CAPITAL LETTER OMEGA
            "\u2126".localeCompare("\u03A9")

            // &#x1E69; LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
            // s&#x0307;&#x0323; LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
            "\u1E69".localeCompare("s\u0307\u0323")

            // &#x1E0B;&#x0323; LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
            // &#x1E0D;&#x0307; LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
            "\u1E0B\u0323".localeCompare("\u1E0D\u0307")

            // &#x1100;&#x1161; HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
            // &#xAC00; HANGUL SYLLABLE GA
            "\u1100\u1161".localeCompare("\uAC00")
          </code></pre>
          <p>For a definition and discussion of canonical equivalence see the Unicode Standard, chapters 2 and 3, as well as <a href="https://unicode.org/reports/tr15/">Unicode Standard Annex #15, Unicode Normalization Forms</a> and <a href="https://unicode.org/notes/tn5/">Unicode Technical Note #5, Canonical Equivalence in Applications</a>. Also see <a href="https://unicode.org/reports/tr10/">Unicode Technical Standard #10, Unicode Collation Algorithm</a>.</p>
          <p>It is recommended that this method should not honour Unicode compatibility equivalents or compatibility decompositions as defined in the Unicode Standard, chapter 3, section 3.7.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.match">
        <h1>String.prototype.match ( _regexp_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _matcher_ be ? GetMethod(_regexp_, %Symbol.match%).
            1. If _matcher_ is not *undefined*, then
              1. Return ? Call(_matcher_, _regexp_, « _O_ »).
          1. Let _S_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).
          1. Return ? Invoke(_rx_, %Symbol.match%, « _S_ »).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.matchall">
        <h1>String.prototype.matchAll ( _regexp_ )</h1>
        <p>This method performs a regular expression match of the String representing the *this* value against _regexp_ and returns an iterator that yields match results. Each match result is an Array containing the matched portion of the String as the first element, followed by the portions matched by any capturing groups. If the regular expression never matches, the returned iterator does not yield any match results.</p>
        <p>It performs the following steps when called:</p>

        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _isRegExp_ be ? IsRegExp(_regexp_).
            1. If _isRegExp_ is *true*, then
              1. Let _flags_ be ? Get(_regexp_, *"flags"*).
              1. Perform ? RequireObjectCoercible(_flags_).
              1. If ? ToString(_flags_) does not contain *"g"*, throw a *TypeError* exception.
            1. Let _matcher_ be ? GetMethod(_regexp_, %Symbol.matchAll%).
            1. If _matcher_ is not *undefined*, then
              1. Return ? Call(_matcher_, _regexp_, « _O_ »).
          1. Let _S_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *"g"*).
          1. Return ? Invoke(_rx_, %Symbol.matchAll%, « _S_ »).
        </emu-alg>
        <emu-note>This method is intentionally generic, it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</emu-note>
        <emu-note>Similarly to `String.prototype.split`, `String.prototype.matchAll` is designed to typically act without mutating its inputs.</emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.normalize">
        <h1>String.prototype.normalize ( [ _form_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. If _form_ is *undefined*, let _f_ be *"NFC"*.
          1. Else, let _f_ be ? ToString(_form_).
          1. If _f_ is not one of *"NFC"*, *"NFD"*, *"NFKC"*, or *"NFKD"*, throw a *RangeError* exception.
          1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href="https://www.unicode.org/versions/latest/ch03.pdf">the latest Unicode Standard, Normalization Forms</a>.
          1. Return _ns_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padend">
        <h1>String.prototype.padEnd ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padstart">
        <h1>String.prototype.padStart ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~).
        </emu-alg>

        <emu-clause id="sec-stringpaddingbuiltinsimpl" type="abstract operation">
          <h1>
            StringPaddingBuiltinsImpl (
              _O_: an ECMAScript language value,
              _maxLength_: an ECMAScript language value,
              _fillString_: an ECMAScript language value,
              _placement_: ~start~ or ~end~,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _S_ be ? ToString(_O_).
            1. Let _intMaxLength_ be ℝ(? ToLength(_maxLength_)).
            1. Let _stringLength_ be the length of _S_.
            1. If _intMaxLength_ ≤ _stringLength_, return _S_.
            1. If _fillString_ is *undefined*, set _fillString_ to the String value consisting solely of the code unit 0x0020 (SPACE).
            1. Else, set _fillString_ to ? ToString(_fillString_).
            1. Return StringPad(_S_, _intMaxLength_, _fillString_, _placement_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-stringpad" type="abstract operation">
          <h1>
            StringPad (
              _S_: a String,
              _maxLength_: a non-negative integer,
              _fillString_: a String,
              _placement_: ~start~ or ~end~,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _stringLength_ be the length of _S_.
            1. If _maxLength_ ≤ _stringLength_, return _S_.
            1. If _fillString_ is the empty String, return _S_.
            1. Let _fillLen_ be _maxLength_ - _stringLength_.
            1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.
            1. If _placement_ is ~start~, return the string-concatenation of _truncatedStringFiller_ and _S_.
            1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_.
          </emu-alg>
          <emu-note>
            <p>The argument _maxLength_ will be clamped such that it can be no smaller than the length of _S_.</p>
          </emu-note>
          <emu-note>
            <p>The argument _fillString_ defaults to *" "* (the String value consisting of the code unit 0x0020 SPACE).</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-tozeropaddeddecimalstring" type="abstract operation">
          <h1>
            ToZeroPaddedDecimalString (
              _n_: a non-negative integer,
              _minLength_: a non-negative integer,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _S_ be the String representation of _n_, formatted as a decimal number.
            1. Return StringPad(_S_, _minLength_, *"0"*, ~start~).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.repeat">
        <h1>String.prototype.repeat ( _count_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _n_ be ? ToIntegerOrInfinity(_count_).
          1. If _n_ &lt; 0 or _n_ = +∞, throw a *RangeError* exception.
          1. If _n_ = 0, return the empty String.
          1. Return the String value that is made from _n_ copies of _S_ appended together.
        </emu-alg>
        <emu-note>
          <p>This method creates the String value consisting of the code units of the *this* value (converted to String) repeated _count_ times.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replace">
        <h1>String.prototype.replace ( _searchValue_, _replaceValue_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _searchValue_ is neither *undefined* nor *null*, then
            1. Let _replacer_ be ? GetMethod(_searchValue_, %Symbol.replace%).
            1. If _replacer_ is not *undefined*, then
              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).
          1. Let _string_ be ? ToString(_O_).
          1. Let _searchString_ be ? ToString(_searchValue_).
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _searchLength_ be the length of _searchString_.
          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).
          1. If _position_ is ~not-found~, return _string_.
          1. Let _preceding_ be the substring of _string_ from 0 to _position_.
          1. Let _following_ be the substring of _string_ from _position_ + _searchLength_.
          1. If _functionalReplace_ is *true*, then
            1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »)).
          1. Else,
            1. Assert: _replaceValue_ is a String.
            1. Let _captures_ be a new empty List.
            1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_).
          1. Return the string-concatenation of _preceding_, _replacement_, and _following_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-getsubstitution" type="abstract operation" oldids="table-replacement-text-symbol-substitutions,table-45">
          <h1>
            GetSubstitution (
              _matched_: a String,
              _str_: a String,
              _position_: a non-negative integer,
              _captures_: a List of either Strings or *undefined*,
              _namedCaptures_: an Object or *undefined*,
              _replacementTemplate_: a String,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>For the purposes of this abstract operation, a <em>decimal digit</em> is a code unit in the inclusive interval from 0x0030 (DIGIT ZERO) to 0x0039 (DIGIT NINE).</dd>
          </dl>
          <emu-alg>
            1. Let _stringLength_ be the length of _str_.
            1. Assert: _position_ ≤ _stringLength_.
            1. Let _result_ be the empty String.
            1. Let _templateRemainder_ be _replacementTemplate_.
            1. Repeat, while _templateRemainder_ is not the empty String,
              1. [declared="ref,refReplacement"] NOTE: The following steps isolate _ref_ (a prefix of _templateRemainder_), determine _refReplacement_ (its replacement), and then append that replacement to _result_.
              1. If _templateRemainder_ starts with *"$$"*, then
                1. Let _ref_ be *"$$"*.
                1. Let _refReplacement_ be *"$"*.
              1. Else if _templateRemainder_ starts with *"$`"*, then
                1. Let _ref_ be *"$`"*.
                1. Let _refReplacement_ be the substring of _str_ from 0 to _position_.
              1. Else if _templateRemainder_ starts with *"$&amp;"*, then
                1. Let _ref_ be *"$&amp;"*.
                1. Let _refReplacement_ be _matched_.
              1. Else if _templateRemainder_ starts with *"$'"* (0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then
                1. Let _ref_ be *"$'"*.
                1. Let _matchLength_ be the length of _matched_.
                1. Let _tailPos_ be _position_ + _matchLength_.
                1. Let _refReplacement_ be the substring of _str_ from min(_tailPos_, _stringLength_).
                1. NOTE: _tailPos_ can exceed _stringLength_ only if this abstract operation was invoked by a call to the intrinsic %Symbol.replace% method of %RegExp.prototype% on an object whose *"exec"* property is not the intrinsic %RegExp.prototype.exec%.
              1. Else if _templateRemainder_ starts with *"$"* followed by 1 or more decimal digits, then
                1. If _templateRemainder_ starts with *"$"* followed by 2 or more decimal digits, let _digitCount_ be 2; otherwise let _digitCount_ be 1.
                1. Let _digits_ be the substring of _templateRemainder_ from 1 to 1 + _digitCount_.
                1. Let _index_ be ℝ(StringToNumber(_digits_)).
                1. Assert: 0 ≤ _index_ ≤ 99.
                1. Let _captureLen_ be the number of elements in _captures_.
                1. If _index_ > _captureLen_ and _digitCount_ = 2, then
                  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.
                  1. Set _digitCount_ to 1.
                  1. Set _digits_ to the substring of _digits_ from 0 to 1.
                  1. Set _index_ to ℝ(StringToNumber(_digits_)).
                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1 + _digitCount_.
                1. If 1 ≤ _index_ ≤ _captureLen_, then
                  1. Let _capture_ be _captures_[_index_ - 1].
                  1. If _capture_ is *undefined*, then
                    1. Let _refReplacement_ be the empty String.
                  1. Else,
                    1. Let _refReplacement_ be _capture_.
                1. Else,
                  1. Let _refReplacement_ be _ref_.
              1. Else if _templateRemainder_ starts with *"$&lt;"*, then
                1. Let _gtPos_ be StringIndexOf(_templateRemainder_, *">"*, 0).
                1. If _gtPos_ is ~not-found~ or _namedCaptures_ is *undefined*, then
                  1. Let _ref_ be *"$&lt;"*.
                  1. Let _refReplacement_ be _ref_.
                1. Else,
                  1. Let _ref_ be the substring of _templateRemainder_ from 0 to _gtPos_ + 1.
                  1. Let _groupName_ be the substring of _templateRemainder_ from 2 to _gtPos_.
                  1. Assert: _namedCaptures_ is an Object.
                  1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).
                  1. If _capture_ is *undefined*, then
                    1. Let _refReplacement_ be the empty String.
                  1. Else,
                    1. Let _refReplacement_ be ? ToString(_capture_).
              1. Else,
                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1.
                1. Let _refReplacement_ be _ref_.
              1. Let _refLength_ be the length of _ref_.
              1. Set _templateRemainder_ to the substring of _templateRemainder_ from _refLength_.
              1. Set _result_ to the string-concatenation of _result_ and _refReplacement_.
            1. Return _result_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replaceall">
        <h1>String.prototype.replaceAll ( _searchValue_, _replaceValue_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _searchValue_ is neither *undefined* nor *null*, then
            1. Let _isRegExp_ be ? IsRegExp(_searchValue_).
            1. If _isRegExp_ is *true*, then
              1. Let _flags_ be ? Get(_searchValue_, *"flags"*).
              1. Perform ? RequireObjectCoercible(_flags_).
              1. If ? ToString(_flags_) does not contain *"g"*, throw a *TypeError* exception.
            1. Let _replacer_ be ? GetMethod(_searchValue_, %Symbol.replace%).
            1. If _replacer_ is not *undefined*, then
              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).
          1. Let _string_ be ? ToString(_O_).
          1. Let _searchString_ be ? ToString(_searchValue_).
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _searchLength_ be the length of _searchString_.
          1. Let _advanceBy_ be max(1, _searchLength_).
          1. Let _matchPositions_ be a new empty List.
          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).
          1. Repeat, while _position_ is not ~not-found~,
            1. Append _position_ to _matchPositions_.
            1. Set _position_ to StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_).
          1. Let _endOfLastMatch_ be 0.
          1. Let _result_ be the empty String.
          1. For each element _p_ of _matchPositions_, do
            1. Let _preserved_ be the substring of _string_ from _endOfLastMatch_ to _p_.
            1. If _functionalReplace_ is *true*, then
              1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »)).
            1. Else,
              1. Assert: _replaceValue_ is a String.
              1. Let _captures_ be a new empty List.
              1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_).
            1. Set _result_ to the string-concatenation of _result_, _preserved_, and _replacement_.
            1. Set _endOfLastMatch_ to _p_ + _searchLength_.
          1. If _endOfLastMatch_ &lt; the length of _string_, then
            1. Set _result_ to the string-concatenation of _result_ and the substring of _string_ from _endOfLastMatch_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.search">
        <h1>String.prototype.search ( _regexp_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _searcher_ be ? GetMethod(_regexp_, %Symbol.search%).
            1. If _searcher_ is not *undefined*, then
              1. Return ? Call(_searcher_, _regexp_, « _O_ »).
          1. Let _string_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).
          1. Return ? Invoke(_rx_, %Symbol.search%, « _string_ »).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.slice">
        <h1>String.prototype.slice ( _start_, _end_ )</h1>
        <p>This method returns a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, starting from index _start_ and running to, but not including, index _end_ (or through the end of the String if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_sourceLength_ + _start_</emu-eqn> where _sourceLength_ is the length of the String. If _end_ is negative, it is treated as <emu-eqn>_sourceLength_ + _end_</emu-eqn> where _sourceLength_ is the length of the String. The result is a String value, not a String object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _intStart_ = -∞, let _from_ be 0.
          1. Else if _intStart_ &lt; 0, let _from_ be max(_len_ + _intStart_, 0).
          1. Else, let _from_ be min(_intStart_, _len_).
          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _intEnd_ = -∞, let _to_ be 0.
          1. Else if _intEnd_ &lt; 0, let _to_ be max(_len_ + _intEnd_, 0).
          1. Else, let _to_ be min(_intEnd_, _len_).
          1. If _from_ ≥ _to_, return the empty String.
          1. Return the substring of _S_ from _from_ to _to_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.split">
        <h1>String.prototype.split ( _separator_, _limit_ )</h1>
        <p>This method returns an Array into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of _separator_; these occurrences are not part of any String in the returned array, but serve to divide up the String value. The value of _separator_ may be a String of any length or it may be an object, such as a RegExp, that has a %Symbol.split% method.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _separator_ is neither *undefined* nor *null*, then
            1. Let _splitter_ be ? GetMethod(_separator_, %Symbol.split%).
            1. If _splitter_ is not *undefined*, then
              1. Return ? Call(_splitter_, _separator_, « _O_, _limit_ »).
          1. Let _S_ be ? ToString(_O_).
          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).
          1. Let _R_ be ? ToString(_separator_).
          1. If _lim_ = 0, then
            1. Return CreateArrayFromList(« »).
          1. If _separator_ is *undefined*, then
            1. Return CreateArrayFromList(« _S_ »).
          1. Let _separatorLength_ be the length of _R_.
          1. If _separatorLength_ = 0, then
            1. Let _strLen_ be the length of _S_.
            1. Let _outLen_ be the result of clamping _lim_ between 0 and _strLen_.
            1. Let _head_ be the substring of _S_ from 0 to _outLen_.
            1. Let _codeUnits_ be a List consisting of the sequence of code units that are the elements of _head_.
            1. Return CreateArrayFromList(_codeUnits_).
          1. If _S_ is the empty String, return CreateArrayFromList(« _S_ »).
          1. Let _substrings_ be a new empty List.
          1. Let _i_ be 0.
          1. Let _j_ be StringIndexOf(_S_, _R_, 0).
          1. Repeat, while _j_ is not ~not-found~,
            1. Let _T_ be the substring of _S_ from _i_ to _j_.
            1. Append _T_ to _substrings_.
            1. If the number of elements in _substrings_ is _lim_, return CreateArrayFromList(_substrings_).
            1. Set _i_ to _j_ + _separatorLength_.
            1. Set _j_ to StringIndexOf(_S_, _R_, _i_).
          1. Let _T_ be the substring of _S_ from _i_.
          1. Append _T_ to _substrings_.
          1. Return CreateArrayFromList(_substrings_).
        </emu-alg>
        <emu-note>
          <p>The value of _separator_ may be an empty String. In this case, _separator_ does not match the empty <emu-not-ref>substring</emu-not-ref> at the beginning or end of the input String, nor does it match the empty <emu-not-ref>substring</emu-not-ref> at the end of the previous separator match. If _separator_ is the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each <emu-not-ref>substring</emu-not-ref> contains one code unit.</p>
          <p>If the *this* value is (or converts to) the empty String, the result depends on whether _separator_ can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
          <p>If _separator_ is *undefined*, then the result array contains just one String, which is the *this* value (converted to a String). If _limit_ is not *undefined*, then the output array is truncated so that it contains no more than _limit_ elements.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.startswith">
        <h1>String.prototype.startsWith ( _searchString_ [ , _position_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _len_ be the length of _S_.
          1. If _position_ is *undefined*, let _pos_ be 0; else let _pos_ be ? ToIntegerOrInfinity(_position_).
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _searchLength_ be the length of _searchStr_.
          1. If _searchLength_ = 0, return *true*.
          1. Let _end_ be _start_ + _searchLength_.
          1. If _end_ > _len_, return *false*.
          1. Let _substring_ be the substring of _S_ from _start_ to _end_.
          1. If _substring_ is _searchStr_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method returns *true* if the sequence of code units of _searchString_ converted to a String is the same as the corresponding code units of this object (converted to a String) starting at index _position_. Otherwise it returns *false*.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.substring">
        <h1>String.prototype.substring ( _start_, _end_ )</h1>
        <p>This method returns a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, starting from index _start_ and running to, but not including, index _end_ of the String (or through the end of the String if _end_ is *undefined*). The result is a String value, not a String object.</p>
        <p>If either argument is *NaN* or negative, it is replaced with zero; if either argument is strictly greater than the length of the String, it is replaced with the length of the String.</p>
        <p>If _start_ is strictly greater than _end_, they are swapped.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).
          1. Let _finalStart_ be the result of clamping _intStart_ between 0 and _len_.
          1. Let _finalEnd_ be the result of clamping _intEnd_ between 0 and _len_.
          1. Let _from_ be min(_finalStart_, _finalEnd_).
          1. Let _to_ be max(_finalStart_, _finalEnd_).
          1. Return the substring of _S_ from _from_ to _to_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocalelowercase">
        <h1>String.prototype.toLocaleLowerCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It works exactly the same as `toLowerCase` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocaleuppercase">
        <h1>String.prototype.toLocaleUpperCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It works exactly the same as `toUpperCase` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolowercase">
        <h1>String.prototype.toLowerCase ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _sText_ be StringToCodePoints(_S_).
          1. Let _lowerText_ be toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.
          1. Let _L_ be CodePointsToString(_lowerText_).
          1. Return _L_.
        </emu-alg>
        <p>The result must be derived according to the locale-insensitive case mappings in the Unicode Character Database (this explicitly includes not only the file <a href="https://unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"><code>UnicodeData.txt</code></a>, but also all locale-insensitive mappings in the file <a href="https://unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt"><code>SpecialCasing.txt</code></a> that accompanies it).</p>
        <emu-note>
          <p>The case mapping of some code points may produce multiple code points. In this case the result String may not be the same length as the source String. Because both `toUpperCase` and `toLowerCase` have context-sensitive behaviour, the methods are not symmetrical. In other words, `s.toUpperCase().toLowerCase()` is not necessarily equal to `s.toLowerCase()`.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tostring">
        <h1>String.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisStringValue(*this* value).
        </emu-alg>
        <emu-note>
          <p>For a String object, this method happens to return the same thing as the `valueOf` method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.touppercase">
        <h1>String.prototype.toUpperCase ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It behaves in exactly the same way as `String.prototype.toLowerCase`, except that the String is mapped using the toUppercase algorithm of the Unicode Default Case Conversion.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.towellformed">
        <h1>String.prototype.toWellFormed ( )</h1>
        <p>This method returns a String representation of this object with all leading surrogates and trailing surrogates that are not part of a surrogate pair replaced with U+FFFD (REPLACEMENT CHARACTER).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _strLen_ be the length of _S_.
          1. Let _k_ be 0.
          1. Let _result_ be the empty String.
          1. Repeat, while _k_ &lt; _strLen_,
            1. Let _cp_ be CodePointAt(_S_, _k_).
            1. If _cp_.[[IsUnpairedSurrogate]] is *true*, then
              1. Set _result_ to the string-concatenation of _result_ and 0xFFFD (REPLACEMENT CHARACTER).
            1. Else,
              1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_.[[CodePoint]]).
            1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trim">
        <h1>String.prototype.trim ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? TrimString(_S_, ~start+end~).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-trimstring" type="abstract operation">
          <h1>
            TrimString (
              _string_: an ECMAScript language value,
              _where_: ~start~, ~end~, or ~start+end~,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It interprets _string_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</dd>
          </dl>
          <emu-alg>
            1. Perform ? RequireObjectCoercible(_string_).
            1. Let _S_ be ? ToString(_string_).
            1. If _where_ is ~start~, then
              1. Let _T_ be the String value that is a copy of _S_ with leading white space removed.
            1. Else if _where_ is ~end~, then
              1. Let _T_ be the String value that is a copy of _S_ with trailing white space removed.
            1. Else,
              1. Assert: _where_ is ~start+end~.
              1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.
            1. Return _T_.
          </emu-alg>
          <p>The definition of white space is the union of |WhiteSpace| and |LineTerminator|. When determining whether a Unicode code point is in Unicode general category “Space_Separator” (“Zs”), code unit sequences are interpreted as UTF-16 encoded code point sequences as specified in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimend">
        <h1>String.prototype.trimEnd ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? TrimString(_S_, ~end~).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimstart">
        <h1>String.prototype.trimStart ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? TrimString(_S_, ~start~).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.valueof">
        <h1>String.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisStringValue(*this* value).
        </emu-alg>

        <emu-clause id="sec-thisstringvalue" type="abstract operation" oldids="thisstringvalue">
          <h1>
            ThisStringValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _value_ is a String, return _value_.
            1. If _value_ is an Object and _value_ has a [[StringData]] internal slot, then
              1. Let _s_ be _value_.[[StringData]].
              1. Assert: _s_ is a String.
              1. Return _s_.
            1. Throw a *TypeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype-%symbol.iterator%" oldids="sec-string.prototype-@@iterator,sec-createstringiterator,sec-properties-of-string-iterator-instances,table-46,table-internal-slots-of-string-iterator-instances">
        <h1>String.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>This method returns an iterator object that iterates over the code points of a String value, returning each code point as a String value.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _s_ be ? ToString(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:
            1. Let _len_ be the length of _s_.
            1. Let _position_ be 0.
            1. Repeat, while _position_ &lt; _len_,
              1. Let _cp_ be CodePointAt(_s_, _position_).
              1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].
              1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.
              1. Set _position_ to _nextIndex_.
              1. Perform ? GeneratorYield(CreateIteratorResultObject(_resultString_, *false*)).
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%StringIteratorPrototype%"*, %StringIteratorPrototype%).
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.iterator]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-string-instances">
      <h1>Properties of String Instances</h1>
      <p>String instances are String exotic objects and have the internal methods specified for such objects. String instances inherit properties from the String prototype object. String instances also have a [[StringData]] internal slot. The [[StringData]] internal slot is the String value represented by this String object.</p>
      <p>String instances have a *"length"* property, and a set of enumerable properties with integer-indexed names.</p>

      <emu-clause id="sec-properties-of-string-instances-length">
        <h1>length</h1>
        <p>The number of elements in the String value represented by this String object.</p>
        <p>Once a String object is initialized, this property is unchanging. It has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-iterator-objects">
      <h1>String Iterator Objects</h1>
      <p>A <dfn variants="String Iterators,String Iterator object,String Iterator objects">String Iterator</dfn> is an object that represents a specific iteration over some specific String instance object. There is not a named constructor for String Iterator objects. Instead, String Iterator objects are created by calling certain methods of String instance objects.</p>

      <emu-clause id="sec-%stringiteratorprototype%-object">
        <h1>The %StringIteratorPrototype% Object</h1>
        <p>The <dfn>%StringIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all String Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%stringiteratorprototype%.next">
          <h1>%StringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%StringIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%stringiteratorprototype%-@@tostringtag" id="sec-%stringiteratorprototype%-%symbol.tostringtag%">
          <h1>%StringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"String Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (Regular Expression) Objects</h1>
    <p>A RegExp object contains a regular expression and the associated flags.</p>
    <emu-note>
      <p>The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 programming language.</p>
    </emu-note>

    <emu-clause id="sec-patterns">
      <h1>Patterns</h1>
      <p>The RegExp constructor applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of |Pattern|.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `|` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [empty]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          `(?=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        Quantifier ::
          QuantifierPrefix
          QuantifierPrefix `?`

        QuantifierPrefix ::
          `*`
          `+`
          `?`
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          PatternCharacter
          `.`
          `\` AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
          CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
          `(` GroupSpecifier[?UnicodeMode]? Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        RegularExpressionModifiers ::
          [empty]
          RegularExpressionModifiers RegularExpressionModifier

        RegularExpressionModifier :: one of
          `i` `m` `s`

        SyntaxCharacter :: one of
          `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

        PatternCharacter ::
          SourceCharacter but not SyntaxCharacter

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          DecimalEscape
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          IdentityEscape[?UnicodeMode]

        ControlEscape :: one of
          `f` `n` `r` `t` `v`

        GroupSpecifier[UnicodeMode] ::
          `?` GroupName[?UnicodeMode]

        GroupName[UnicodeMode] ::
          `&lt;` RegExpIdentifierName[?UnicodeMode] `&gt;`

        RegExpIdentifierName[UnicodeMode] ::
          RegExpIdentifierStart[?UnicodeMode]
          RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]

        RegExpIdentifierStart[UnicodeMode] ::
          IdentifierStartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpIdentifierPart[UnicodeMode] ::
          IdentifierPartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpUnicodeEscapeSequence[UnicodeMode] ::
          [+UnicodeMode] `u` HexLeadSurrogate `\u` HexTrailSurrogate
          [+UnicodeMode] `u` HexLeadSurrogate
          [+UnicodeMode] `u` HexTrailSurrogate
          [+UnicodeMode] `u` HexNonSurrogate
          [~UnicodeMode] `u` Hex4Digits
          [+UnicodeMode] `u{` CodePoint `}`

        UnicodeLeadSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+D800 to U+DBFF

        UnicodeTrailSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
      </emu-grammar>
      <p>Each `\\u` |HexTrailSurrogate| for which the choice of associated `u` |HexLeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |HexLeadSurrogate| that would otherwise have no corresponding `\\u` |HexTrailSurrogate|.</p>
      <emu-grammar type="definition">
        HexLeadSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xD800 to 0xDBFF]

        HexTrailSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xDC00 to 0xDFFF]

        HexNonSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is not in the inclusive interval from 0xD800 to 0xDFFF]

        IdentityEscape[UnicodeMode] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacter but not UnicodeIDContinue

        DecimalEscape ::
          NonZeroDigit DecimalDigits[~Sep]? [lookahead &notin; DecimalDigit]

        CharacterClassEscape[UnicodeMode] ::
          `d`
          `D`
          `s`
          `S`
          `w`
          `W`
          [+UnicodeMode] `p{` UnicodePropertyValueExpression `}`
          [+UnicodeMode] `P{` UnicodePropertyValueExpression `}`

        UnicodePropertyValueExpression ::
          UnicodePropertyName `=` UnicodePropertyValue
          LoneUnicodePropertyNameOrValue

        UnicodePropertyName ::
          UnicodePropertyNameCharacters

        UnicodePropertyNameCharacters ::
          UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

        UnicodePropertyValue ::
          UnicodePropertyValueCharacters

        LoneUnicodePropertyNameOrValue ::
          UnicodePropertyValueCharacters

        UnicodePropertyValueCharacters ::
          UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

        UnicodePropertyValueCharacter ::
          UnicodePropertyNameCharacter
          DecimalDigit

        UnicodePropertyNameCharacter ::
          AsciiLetter
          `_`

        CharacterClass[UnicodeMode, UnicodeSetsMode] ::
          `[` [lookahead != `^`] ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`
          `[^` ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`

        ClassContents[UnicodeMode, UnicodeSetsMode] ::
          [empty]
          [~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
          [+UnicodeSetsMode] ClassSetExpression

        NonemptyClassRanges[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtom[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        NonemptyClassRangesNoDash[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        ClassAtom[UnicodeMode] ::
          `-`
          ClassAtomNoDash[?UnicodeMode]

        ClassAtomNoDash[UnicodeMode] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode]

        ClassEscape[UnicodeMode] ::
          `b`
          [+UnicodeMode] `-`
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]

        ClassSetExpression ::
          ClassUnion
          ClassIntersection
          ClassSubtraction

        ClassUnion ::
          ClassSetRange ClassUnion?
          ClassSetOperand ClassUnion?

        ClassIntersection ::
          ClassSetOperand `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand
          ClassIntersection `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand

        ClassSubtraction ::
          ClassSetOperand `--` ClassSetOperand
          ClassSubtraction `--` ClassSetOperand

        ClassSetRange ::
          ClassSetCharacter `-` ClassSetCharacter

        ClassSetOperand ::
          NestedClass
          ClassStringDisjunction
          ClassSetCharacter

        NestedClass ::
          `[` [lookahead != `^`] ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `[^` ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `\` CharacterClassEscape[+UnicodeMode]
      </emu-grammar>
      <emu-note>
        <p>The first two lines here are equivalent to CharacterClass.</p>
      </emu-note>
      <emu-grammar type="definition">
        ClassStringDisjunction ::
          `\q{` ClassStringDisjunctionContents `}`

        ClassStringDisjunctionContents ::
          ClassString
          ClassString `|` ClassStringDisjunctionContents

        ClassString ::
          [empty]
          NonEmptyClassString

        NonEmptyClassString ::
          ClassSetCharacter NonEmptyClassString?

        ClassSetCharacter ::
          [lookahead &notin; ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
          `\` CharacterEscape[+UnicodeMode]
          `\` ClassSetReservedPunctuator
          `\b`

        ClassSetReservedDoublePunctuator :: one of
          `&amp;&amp;` `!!` `##`
          `$$` `%%` `**`
          `++` `,,` `..`
          `::` `;;` `&lt;&lt;`
          `==` `&gt;&gt;` `??`
          `@@` `^^` `&grave;&grave;`
          `~~`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetSyntaxCharacter :: one of
          `(` `)` `[` `]` `{` `}` `/` `-` `\` `|`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetReservedPunctuator :: one of
          `&amp;` `-` `!` `#` `%` `,`
          `:` `;` `&lt;` `=` `&gt;` `@`
          `&grave;` `~`
      </emu-grammar>
      <emu-note>
        <p>A number of productions in this section are given alternative definitions in section <emu-xref href="#sec-regular-expressions-patterns"></emu-xref>.</p>
      </emu-note>

      <emu-clause id="sec-patterns-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if CountLeftCapturingParensWithin(|Pattern|) ≥ 2<sup>32</sup> - 1.
          </li>
          <li>
            It is a Syntax Error if |Pattern| contains two distinct |GroupSpecifier|s _x_ and _y_ such that the CapturingGroupName of _x_ is the CapturingGroupName of _y_ and such that MightBothParticipate(_x_, _y_) is *true*.
          </li>
        </ul>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the MV of the first |DecimalDigits| is strictly greater than the MV of the second |DecimalDigits|.
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by |RegularExpressionModifiers| contains the same code point more than once.
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by the first |RegularExpressionModifiers| and the source text matched by the second |RegularExpressionModifiers| are both empty.
          </li>
          <li>
            It is a Syntax Error if the source text matched by the first |RegularExpressionModifiers| contains the same code point more than once.
          </li>
          <li>
            It is a Syntax Error if the source text matched by the second |RegularExpressionModifiers| contains the same code point more than once.
          </li>
          <li>
            It is a Syntax Error if any code point in the source text matched by the first |RegularExpressionModifiers| is also contained in the source text matched by the second |RegularExpressionModifiers|.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if GroupSpecifiersThatMatch(|GroupName|) is empty.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CapturingGroupNumber of |DecimalEscape| is strictly greater than CountLeftCapturingParensWithin(the |Pattern| containing |AtomEscape|).
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true*.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *false*, IsCharacterClass of the second |ClassAtom| is *false*, and the CharacterValue of the first |ClassAtom| is strictly greater than the CharacterValue of the second |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true*.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *false*, IsCharacterClass of |ClassAtom| is *false*, and the CharacterValue of |ClassAtomNoDash| is strictly greater than the CharacterValue of |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CharacterValue of |RegExpUnicodeEscapeSequence| is not the numeric value of some code point matched by the |IdentifierStartChar| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the RegExpIdentifierCodePoint of |RegExpIdentifierStart| is not matched by the |UnicodeIDStart| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CharacterValue of |RegExpUnicodeEscapeSequence| is not the numeric value of some code point matched by the |IdentifierPartChar| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the RegExpIdentifierCodePoint of |RegExpIdentifierPart| is not matched by the |UnicodeIDContinue| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by |UnicodePropertyName| is not a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if the source text matched by |UnicodePropertyValue| is not a property value or property value alias for the Unicode property or property alias given by the source text matched by |UnicodePropertyName| listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by |LoneUnicodePropertyNameOrValue| is not a Unicode property value or property value alias for the General_Category (gc) property listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>, nor a binary property or binary property alias listed in the “Property name and aliases” column of <emu-xref href="#table-binary-unicode-properties"></emu-xref>, nor a binary property of strings listed in the “Property name” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if the enclosing |Pattern| does not have a <sub>[UnicodeSetsMode]</sub> parameter and the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>.
          </li>
        </ul>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if MayContainStrings of the |UnicodePropertyValueExpression| is *true*.
          </li>
        </ul>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if MayContainStrings of the |ClassContents| is *true*.
          </li>
        </ul>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if MayContainStrings of the |ClassContents| is *true*.
          </li>
        </ul>
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CharacterValue of the first |ClassSetCharacter| is strictly greater than the CharacterValue of the second |ClassSetCharacter|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparenswithin" type="abstract operation">
        <h1>
          Static Semantics: CountLeftCapturingParensWithin (
            _node_: a Parse Node,
          ): a non-negative integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the number of left-capturing parentheses in _node_. A <dfn variants="left-capturing parentheses">left-capturing parenthesis</dfn> is any `(` pattern character that is matched by the `(` terminal of the <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> production.</dd>
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-alg>
          1. Assert: _node_ is an instance of a production in <emu-xref href="#sec-patterns">the RegExp Pattern grammar</emu-xref>.
          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _node_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparensbefore" type="abstract operation">
        <h1>
          Static Semantics: CountLeftCapturingParensBefore (
            _node_: a Parse Node,
          ): a non-negative integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the number of left-capturing parentheses within the enclosing pattern that occur to the left of _node_.</dd>
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-alg>
          1. Assert: _node_ is an instance of a production in <emu-xref href="#sec-patterns">the RegExp Pattern grammar</emu-xref>.
          1. Let _pattern_ be the |Pattern| containing _node_.
          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _pattern_ that either occur before _node_ or contain _node_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mightbothparticipate" type="abstract operation">
        <h1>
          Static Semantics: MightBothParticipate (
            _x_: a Parse Node,
            _y_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _x_ and _y_ have the same enclosing |Pattern|.
          1. If the enclosing |Pattern| contains a <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar> Parse Node such that either _x_ is contained within the |Alternative| and _y_ is contained within the derived |Disjunction|, or _x_ is contained within the derived |Disjunction| and _y_ is contained within the |Alternative|, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-capturing-group-number" type="sdo">
        <h1>Static Semantics: CapturingGroupNumber ( ): a positive integer</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>DecimalEscape :: NonZeroDigit</emu-grammar>
        <emu-alg>
          1. Return the MV of |NonZeroDigit|.
        </emu-alg>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits</emu-grammar>
        <emu-alg>
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Return (the MV of |NonZeroDigit| × 10<sup>_n_</sup> plus the MV of |DecimalDigits|).
        </emu-alg>
        <p>The definitions of “the MV of |NonZeroDigit|” and “the MV of |DecimalDigits|” are in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-is-character-class" type="sdo">
        <h1>Static Semantics: IsCharacterClass ( ): a Boolean</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-is-character-class-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>
          ClassAtom ::
            `-`

          ClassAtomNoDash ::
            SourceCharacter but not one of `\` or `]` or `-`

          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-character-value" type="sdo">
        <h1>Static Semantics: CharacterValue ( ): a non-negative integer</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-character-value-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>
          ClassAtom :: `-`
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+002D (HYPHEN-MINUS).
        </emu-alg>
        <emu-grammar>
          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`
        </emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |SourceCharacter|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `b`
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+0008 (BACKSPACE).
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `-`
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+002D (HYPHEN-MINUS).
        </emu-alg>
        <emu-grammar>CharacterEscape :: ControlEscape</emu-grammar>
        <emu-alg>
          1. Return the numeric value according to <emu-xref href="#table-controlescape-code-point-values"></emu-xref>.
        </emu-alg>
        <emu-table id="table-controlescape-code-point-values" caption="ControlEscape Code Point Values" oldids="table-47">
          <table>
            <thead>
              <tr>
                <th>
                  ControlEscape
                </th>
                <th>
                  Numeric Value
                </th>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode Name
                </th>
                <th>
                  Symbol
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `t`
              </td>
              <td>
                9
              </td>
              <td>
                `U+0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `n`
              </td>
              <td>
                10
              </td>
              <td>
                `U+000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `v`
              </td>
              <td>
                11
              </td>
              <td>
                `U+000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `f`
              </td>
              <td>
                12
              </td>
              <td>
                `U+000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `r`
              </td>
              <td>
                13
              </td>
              <td>
                `U+000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-grammar>CharacterEscape :: `c` AsciiLetter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |AsciiLetter|.
          1. Let _i_ be the numeric value of _ch_.
          1. Return the remainder of dividing _i_ by 32.
        </emu-alg>
        <emu-grammar>CharacterEscape :: `0` [lookahead &notin; DecimalDigit]</emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+0000 (NULL).
        </emu-alg>
        <emu-note>
          <p>`\\0` represents the &lt;NUL> character and cannot be followed by a decimal digit.</p>
        </emu-note>
        <emu-grammar>CharacterEscape :: HexEscapeSequence</emu-grammar>
        <emu-alg>
          1. Return the MV of |HexEscapeSequence|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` HexLeadSurrogate `\u` HexTrailSurrogate</emu-grammar>
        <emu-alg>
          1. Let _lead_ be the CharacterValue of |HexLeadSurrogate|.
          1. Let _trail_ be the CharacterValue of |HexTrailSurrogate|.
          1. Let _cp_ be UTF16SurrogatePairToCodePoint(_lead_, _trail_).
          1. Return the numeric value of _cp_.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. Return the MV of |Hex4Digits|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. Return the MV of |CodePoint|.
        </emu-alg>
        <emu-grammar>
          HexLeadSurrogate :: Hex4Digits

          HexTrailSurrogate :: Hex4Digits

          HexNonSurrogate :: Hex4Digits
        </emu-grammar>
        <emu-alg>
          1. Return the MV of |Hex4Digits|.
        </emu-alg>
        <emu-grammar>CharacterEscape :: IdentityEscape</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |IdentityEscape|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: SourceCharacter but not ClassSetSyntaxCharacter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |SourceCharacter|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\` ClassSetReservedPunctuator</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |ClassSetReservedPunctuator|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+0008 (BACKSPACE).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-maycontainstrings" type="sdo">
        <h1>Static Semantics: MayContainStrings ( ): a Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          CharacterClassEscape ::
            `d`
            `D`
            `s`
            `S`
            `w`
            `W`
            `P{` UnicodePropertyValueExpression `}`

          UnicodePropertyValueExpression ::
            UnicodePropertyName `=` UnicodePropertyValue

          NestedClass ::
            `[^` ClassContents `]`

          ClassContents ::
            [empty]
            NonemptyClassRanges

          ClassSetOperand ::
            ClassSetCharacter
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. If the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. If the |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the |ClassSetOperand| is *true*, return *true*.
          1. If |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the first |ClassSetOperand| is *false*, return *false*.
          1. If MayContainStrings of the second |ClassSetOperand| is *false*, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the |ClassIntersection| is *false*, return *false*.
          1. If MayContainStrings of the |ClassSetOperand| is *false*, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Return MayContainStrings of the first |ClassSetOperand|.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Return MayContainStrings of the |ClassSubtraction|.
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the |ClassString| is *true*, return *true*.
          1. Return MayContainStrings of the |ClassStringDisjunctionContents|.
        </emu-alg>
        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. Return MayContainStrings of the |NonEmptyClassString|.
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. If |NonEmptyClassString| is present, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-groupspecifiersthatmatch" type="abstract operation">
        <h1>
          Static Semantics: GroupSpecifiersThatMatch (
            _thisGroupName_: a |GroupName| Parse Node,
          ): a List of |GroupSpecifier| Parse Nodes
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _name_ be the CapturingGroupName of _thisGroupName_.
          1. Let _pattern_ be the |Pattern| containing _thisGroupName_.
          1. Let _result_ be a new empty List.
          1. For each |GroupSpecifier| _gs_ that _pattern_ contains, do
            1. If the CapturingGroupName of _gs_ is _name_, then
              1. Append _gs_ to _result_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-capturinggroupname" oldids="sec-regexp-identifier-names-static-semantics-stringvalue" type="sdo">
        <h1>Static Semantics: CapturingGroupName ( ): a String</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          GroupName :: `&lt;` RegExpIdentifierName `&gt;`
        </emu-grammar>
        <emu-alg>
          1. Let _idTextUnescaped_ be the RegExpIdentifierCodePoints of |RegExpIdentifierName|.
          1. Return CodePointsToString(_idTextUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoints" type="sdo">
        <h1>Static Semantics: RegExpIdentifierCodePoints ( ): a List of code points</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierStart</emu-grammar>
        <emu-alg>
          1. Let _cp_ be the RegExpIdentifierCodePoint of |RegExpIdentifierStart|.
          1. Return « _cp_ ».
        </emu-alg>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierName RegExpIdentifierPart</emu-grammar>
        <emu-alg>
          1. Let _cps_ be the RegExpIdentifierCodePoints of the derived |RegExpIdentifierName|.
          1. Let _cp_ be the RegExpIdentifierCodePoint of |RegExpIdentifierPart|.
          1. Return the list-concatenation of _cps_ and « _cp_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoint" type="sdo">
        <h1>Static Semantics: RegExpIdentifierCodePoint ( ): a code point</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. Return the code point matched by |IdentifierStartChar|.
        </emu-alg>
        <emu-grammar>RegExpIdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. Return the code point matched by |IdentifierPartChar|.
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence

          RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence
        </emu-grammar>
        <emu-alg>
          1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

          RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
        </emu-grammar>
        <emu-alg>
          1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.
          1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.
          1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-pattern-semantics">
      <h1>Pattern Semantics</h1>
      <p>A regular expression pattern is converted into an Abstract Closure using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The Abstract Closure is used as the value of a RegExp object's [[RegExpMatcher]] internal slot.</p>
      <p>A |Pattern| is a BMP pattern if its associated flags contain neither a `u` nor a `v`. Otherwise, it is a Unicode pattern. A BMP pattern matches against a String interpreted as consisting of a sequence of 16-bit values that are Unicode code points in the range of the Basic Multilingual Plane. A Unicode pattern matches against a String interpreted as consisting of Unicode code points encoded using UTF-16. In the context of describing the behaviour of a BMP pattern “character” means a single 16-bit Unicode BMP code point. In the context of describing the behaviour of a Unicode pattern “character” means a UTF-16 encoded code point (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). In either context, “character value” means the numeric value of the corresponding non-encoded code point.</p>
      <p>The syntax and semantics of |Pattern| is defined as if the source text for the |Pattern| was a List of |SourceCharacter| values where each |SourceCharacter| corresponds to a Unicode code point. If a BMP pattern contains a non-BMP |SourceCharacter| the entire pattern is encoded using UTF-16 and the individual code units of that encoding are used as the elements of the List.</p>
      <emu-note>
        <p>For example, consider a pattern expressed in source text as the single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a Unicode pattern, it would be a single element (character) List consisting of the single code point U+1D11E. However, interpreted as a BMP pattern, it is first UTF-16 encoded to produce a two element List consisting of the code units 0xD834 and 0xDD1E.</p>
        <p>Patterns are passed to the RegExp constructor as ECMAScript String values in which non-BMP characters are UTF-16 encoded. For example, the single character MUSICAL SYMBOL G CLEF pattern, expressed as a String value, is a String of length 2 whose elements were the code units 0xD834 and 0xDD1E. So no further translation of the string would be necessary to process it as a BMP pattern consisting of two pattern characters. However, to process it as a Unicode pattern UTF16SurrogatePairToCodePoint must be used in producing a List whose sole element is a single pattern character, the code point U+1D11E.</p>
        <p>An implementation may not actually perform such translations to or from UTF-16, but the semantics of this specification requires that the result of pattern matching be as if such translations were performed.</p>
      </emu-note>

      <emu-clause id="sec-pattern-notation" oldids="sec-notation">
        <h1>Notation</h1>
        <p>The descriptions below use the following internal data structures:</p>
        <ul>
          <li>
            A <dfn>CharSetElement</dfn> is one of the two following entities:
            <ul>
              <li>
                If _rer_.[[UnicodeSets]] is *false*, then a CharSetElement is a character in the sense of the Pattern Semantics above.
              </li>
              <li>
                If _rer_.[[UnicodeSets]] is *true*, then a CharSetElement is a sequence whose elements are characters in the sense of the Pattern Semantics above. This includes the empty sequence, sequences of one character, and sequences of more than one character. For convenience, when working with CharSetElements of this kind, an individual character is treated interchangeably with a sequence of one character.
              </li>
            </ul>
          </li>
          <li>
            A <dfn id="pattern-charset" variants="CharSets">CharSet</dfn> is a mathematical set of CharSetElements.
          </li>
          <li>
            A <dfn id="pattern-capturerange" variants="CaptureRanges">CaptureRange</dfn> is a Record { [[StartIndex]], [[EndIndex]] } that represents the range of characters included in a capture, where [[StartIndex]] is an integer representing the start index (inclusive) of the range within _Input_, and [[EndIndex]] is an integer representing the end index (exclusive) of the range within _Input_. For any CaptureRange, these indices must satisfy the invariant that [[StartIndex]] ≤ [[EndIndex]].
          </li>
          <li>
            A <dfn id="pattern-matchstate" variants="MatchStates" oldids="pattern-matchresult">MatchState</dfn> is a Record { [[Input]], [[EndIndex]], [[Captures]] } where [[Input]] is a List of characters representing the String being matched, [[EndIndex]] is an integer, and [[Captures]] is a List of values, one for each left-capturing parenthesis in the pattern. MatchStates are used to represent partial match states in the regular expression matching algorithms. The [[EndIndex]] is one plus the index of the last input character matched so far by the pattern, while [[Captures]] holds the results of capturing parentheses. The _n_<sup>th</sup> element of [[Captures]] is either a CaptureRange representing the range of characters captured by the _n_<sup>th</sup> set of capturing parentheses, or *undefined* if the _n_<sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many MatchStates may be in use at any time during the matching process.
          </li>
          <li>
            A <dfn id="pattern-matchercontinuation" variants="MatcherContinuations">MatcherContinuation</dfn> is an Abstract Closure that takes one MatchState argument and returns either a MatchState or ~failure~. The MatcherContinuation attempts to match the remaining portion (specified by the closure's captured values) of the pattern against _Input_, starting at the intermediate state given by its MatchState argument. If the match succeeds, the MatcherContinuation returns the final MatchState that it reached; if the match fails, the MatcherContinuation returns ~failure~.
          </li>
          <li>
            A <dfn id="pattern-matcher" variants="Matchers">Matcher</dfn> is an Abstract Closure that takes two arguments—a MatchState and a MatcherContinuation—and returns either a MatchState or ~failure~. A Matcher attempts to match a middle subpattern (specified by the closure's captured values) of the pattern against the MatchState's [[Input]], starting at the intermediate state given by its MatchState argument. The MatcherContinuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new MatchState, the Matcher then calls MatcherContinuation on that new MatchState to test if the rest of the pattern can match as well. If it can, the Matcher returns the MatchState returned by MatcherContinuation; if not, the Matcher may try different choices at its choice points, repeatedly calling MatcherContinuation until it either succeeds or all possibilities have been exhausted.
          </li>
        </ul>

        <emu-clause id="sec-regexp-records">
          <h1>RegExp Records</h1>
          <p>A <dfn variants="RegExp Records">RegExp Record</dfn> is a Record value used to store information about a RegExp that is needed during compilation and possibly during matching.</p>
          <p>It has the following fields:</p>
          <emu-table id="table-regexp-record-fields" caption="RegExp Record Fields">
            <table>
              <thead>
                <tr>
                  <th>Field Name</th>
                  <th>Value</th>
                  <th>Meaning</th>
                </tr>
              </thead>
              <tr>
                <td>[[IgnoreCase]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"i"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[Multiline]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"m"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[DotAll]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"s"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[Unicode]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"u"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[UnicodeSets]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"v"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[CapturingGroupsCount]]</td>
                <td>a non-negative integer</td>
                <td>the number of left-capturing parentheses in the RegExp's pattern</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilepattern" type="sdo" oldids="sec-pattern">
        <h1>
          Runtime Semantics: CompilePattern (
            _rer_: a RegExp Record,
          ): an Abstract Closure that takes a List of characters and a non-negative integer and returns either a MatchState or ~failure~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.
          1. Return a new Abstract Closure with parameters (_Input_, _index_) that captures _rer_ and _m_ and performs the following steps when called:
            1. Assert: _Input_ is a List of characters.
            1. Assert: 0 ≤ _index_ ≤ the number of elements in _Input_.
            1. Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].
            1. Let _x_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }.
            1. Return _m_(_x_, _c_).
        </emu-alg>
        <emu-note>
          <p>A Pattern compiles to an Abstract Closure value. RegExpBuiltinExec can then apply this procedure to a List of characters and an offset within that List to determine whether the pattern would match starting at exactly that offset within the List, and, if it does match, what the values of the capturing parentheses would be. The algorithms in <emu-xref href="#sec-pattern-semantics"></emu-xref> are designed so that compiling a pattern may throw a *SyntaxError* exception; on the other hand, once the pattern is successfully compiled, applying the resulting Abstract Closure to find a match in a List of characters cannot throw an exception (except for any implementation-defined exceptions that can occur anywhere such as out-of-memory).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-compilesubpattern" type="sdo" oldids="sec-disjunction,sec-alternative,sec-term">
        <h1>
          Runtime Semantics: CompileSubpattern (
            _rer_: a RegExp Record,
            _direction_: ~forward~ or ~backward~,
          ): a Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compilesubpattern-annexb"></emu-xref>.</p>
        </emu-note>

        <!-- Disjunction -->
        <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar>
        <emu-alg>
          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.
          1. Let _m2_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.
          1. Return MatchTwoAlternatives(_m1_, _m2_).
        </emu-alg>
        <emu-note>
          <p>The `|` regular expression operator separates two alternatives. The pattern first tries to match the left |Alternative| (followed by the sequel of the regular expression); if it fails, it tries to match the right |Disjunction| (followed by the sequel of the regular expression). If the left |Alternative|, the right |Disjunction|, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left |Alternative|. If choices in the left |Alternative| are exhausted, the right |Disjunction| is tried instead of the left |Alternative|. Any capturing parentheses inside a portion of the pattern skipped by `|` produce *undefined* values instead of Strings. Thus, for example,</p>
          <pre><code class="javascript">/a|ab/.exec("abc")</code></pre>
          <p>returns the result *"a"* and not *"ab"*. Moreover,</p>
          <pre><code class="javascript">/((a)|(ab))((c)|(bc))/.exec("abc")</code></pre>
          <p>returns the array</p>
          <pre><code class="javascript">["abc", "a", "a", undefined, "bc", undefined, "bc"]</code></pre>
          <p>and not</p>
          <pre><code class="javascript">["abc", "ab", undefined, "ab", "c", "c", undefined]</code></pre>
          <p>The order in which the two alternatives are tried is independent of the value of _direction_.</p>
        </emu-note>

        <!-- Alternative -->
        <emu-grammar>Alternative :: [empty]</emu-grammar>
        <emu-alg>
          1. Return EmptyMatcher().
        </emu-alg>
        <emu-grammar>Alternative :: Alternative Term</emu-grammar>
        <emu-alg>
          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.
          1. Let _m2_ be CompileSubpattern of |Term| with arguments _rer_ and _direction_.
          1. Return MatchSequence(_m1_, _m2_, _direction_).
        </emu-alg>
        <emu-note>
          <p>Consecutive |Term|s try to simultaneously match consecutive portions of _Input_. When _direction_ is ~forward~, if the left |Alternative|, the right |Term|, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right |Term|, and all choices in the right |Term| are tried before moving on to the next choice in the left |Alternative|. When _direction_ is ~backward~, the evaluation order of |Alternative| and |Term| are reversed.</p>
        </emu-note>

        <!-- Term -->
        <emu-grammar>Term :: Assertion</emu-grammar>
        <emu-alg>
          1. Return CompileAssertion of |Assertion| with argument _rer_.
        </emu-alg>
        <emu-note>
          <p>The resulting Matcher is independent of _direction_.</p>
        </emu-note>
        <emu-grammar>Term :: Atom</emu-grammar>
        <emu-alg>
          1. Return CompileAtom of |Atom| with arguments _rer_ and _direction_.
        </emu-alg>
        <emu-grammar>Term :: Atom Quantifier</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileAtom of |Atom| with arguments _rer_ and _direction_.
          1. Let _q_ be CompileQuantifier of |Quantifier|.
          1. Assert: _q_.[[Min]] ≤ _q_.[[Max]].
          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Term|).
          1. Let _parenCount_ be CountLeftCapturingParensWithin(|Atom|).
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_, _q_, _parenIndex_, and _parenCount_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Return RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-repeatmatcher-abstract-operation" type="abstract operation">
          <h1>
            RepeatMatcher (
              _m_: a Matcher,
              _min_: a non-negative integer,
              _max_: a non-negative integer or +&infin;,
              _greedy_: a Boolean,
              _x_: a MatchState,
              _c_: a MatcherContinuation,
              _parenIndex_: a non-negative integer,
              _parenCount_: a non-negative integer,
            ): either a MatchState or ~failure~
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _max_ = 0, return _c_(_x_).
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. [id="step-repeatmatcher-done"] If _min_ = 0 and _y_.[[EndIndex]] = _x_.[[EndIndex]], return ~failure~.
              1. If _min_ = 0, let _min2_ be 0; otherwise let _min2_ be _min_ - 1.
              1. If _max_ = +∞, let _max2_ be +∞; otherwise let _max2_ be _max_ - 1.
              1. Return RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).
            1. Let _cap_ be a copy of _x_.[[Captures]].
            1. [id="step-repeatmatcher-clear-captures"] For each integer _k_ in the inclusive interval from _parenIndex_ + 1 to _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _xr_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ }.
            1. If _min_ ≠ 0, return _m_(_xr_, _d_).
            1. If _greedy_ is *false*, then
              1. Let _z_ be _c_(_x_).
              1. If _z_ is not ~failure~, return _z_.
              1. Return _m_(_xr_, _d_).
            1. Let _z_ be _m_(_xr_, _d_).
            1. If _z_ is not ~failure~, return _z_.
            1. Return _c_(_x_).
          </emu-alg>
          <emu-note>
            <p>An |Atom| followed by a |Quantifier| is repeated the number of times specified by the |Quantifier|. A |Quantifier| can be non-greedy, in which case the |Atom| pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the |Atom| pattern is repeated as many times as possible while still matching the sequel. The |Atom| pattern is repeated rather than the input character sequence that it matches, so different repetitions of the |Atom| can match different input substrings.</p>
          </emu-note>
          <emu-note>
            <p>If the |Atom| and the sequel of the regular expression all have choice points, the |Atom| is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of |Atom|. All choices in the last (n<sup>th</sup>) repetition of |Atom| are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of |Atom|; at which point it may turn out that more or fewer repetitions of |Atom| are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of |Atom| and so on.</p>
            <p>Compare</p>
            <pre><code class="javascript">/a[a-z]{2,4}/.exec("abcdefghi")</code></pre>
            <p>which returns *"abcde"* with</p>
            <pre><code class="javascript">/a[a-z]{2,4}?/.exec("abcdefghi")</code></pre>
            <p>which returns *"abc"*.</p>
            <p>Consider also</p>
            <pre><code class="javascript">/(aa|aabaac|ba|b|c)*/.exec("aabaac")</code></pre>
            <p>which, by the choice point ordering above, returns the array</p>
            <pre><code class="javascript">["aaba", "ba"]</code></pre>
            <p>and not any of:</p>
            <pre><code class="javascript">
              ["aabaac", "aabaac"]
              ["aabaac", "c"]
            </code></pre>
            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>
            <pre><code class="javascript">"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")</code></pre>
            <p>which returns the gcd in unary notation *"aaaaa"*.</p>
          </emu-note>
          <emu-note>
            <p>Step <emu-xref href="#step-repeatmatcher-clear-captures"></emu-xref> of the RepeatMatcher clears |Atom|'s captures each time |Atom| is repeated. We can see its behaviour in the regular expression</p>
            <pre><code class="javascript">/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</code></pre>
            <p>which returns the array</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", undefined, "c"]</code></pre>
            <p>and not</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</code></pre>
            <p>because each iteration of the outermost `*` clears all captured Strings contained in the quantified |Atom|, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>
          </emu-note>
          <emu-note>
            <p>Step <emu-xref href="#step-repeatmatcher-done"></emu-xref> of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of |Atom| that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>
            <pre><code class="javascript">/(a*)*/.exec("b")</code></pre>
            <p>or the slightly more complicated:</p>
            <pre><code class="javascript">/(a*)b\1+/.exec("baaaac")</code></pre>
            <p>which returns the array</p>
            <pre><code class="javascript">["b", ""]</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-emptymatcher" type="abstract operation">
          <h1>EmptyMatcher ( ): a Matcher</h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Return _c_(_x_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchtwoalternatives" type="abstract operation">
          <h1>
            MatchTwoAlternatives (
              _m1_: a Matcher,
              _m2_: a Matcher,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Let _r_ be _m1_(_x_, _c_).
              1. If _r_ is not ~failure~, return _r_.
              1. Return _m2_(_x_, _c_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchsequence" type="abstract operation">
          <h1>
            MatchSequence (
              _m1_: a Matcher,
              _m2_: a Matcher,
              _direction_: ~forward~ or ~backward~,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _direction_ is ~forward~, then
              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:
                1. Assert: _x_ is a MatchState.
                1. Assert: _c_ is a MatcherContinuation.
                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:
                  1. Assert: _y_ is a MatchState.
                  1. Return _m2_(_y_, _c_).
                1. Return _m1_(_x_, _d_).
            1. Else,
              1. Assert: _direction_ is ~backward~.
              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:
                1. Assert: _x_ is a MatchState.
                1. Assert: _c_ is a MatcherContinuation.
                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:
                  1. Assert: _y_ is a MatchState.
                  1. Return _m1_(_y_, _c_).
                1. Return _m2_(_x_, _d_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileassertion" type="sdo" oldids="sec-assertion">
        <h1>
          Runtime Semantics: CompileAssertion (
            _rer_: a RegExp Record,
          ): a Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compileassertion-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>Assertion :: `^`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. If _e_ = 0, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_ - 1] is matched by |LineTerminator|, then
              1. Return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-note>
          <p>Even when the `y` flag is used with a pattern, `^` always matches only at the beginning of _Input_, or (if _rer_.[[Multiline]] is *true*) at the beginning of a line.</p>
        </emu-note>
        <emu-grammar>Assertion :: `$`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _InputLength_ be the number of elements in _Input_.
            1. If _e_ = _InputLength_, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_] is matched by |LineTerminator|, then
              1. Return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-grammar>Assertion :: `\b`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).
            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).
            1. If _a_ is *true* and _b_ is *false*, or if _a_ is *false* and _b_ is *true*, return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-grammar>Assertion :: `\B`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).
            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).
            1. If _a_ is *true* and _b_ is *true*, or if _a_ is *false* and _b_ is *false*, return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is ~failure~, return ~failure~.
            1. Assert: _r_ is a MatchState.
            1. Let _cap_ be _r_.[[Captures]].
            1. Let _Input_ be _x_.[[Input]].
            1. Let _xe_ be _x_.[[EndIndex]].
            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.
            1. Return _c_(_z_).
        </emu-alg>
        <emu-note>
          <p>The form `(?=` |Disjunction| `)` specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside |Disjunction| must match at the current position, but the current position is not advanced before matching the sequel. If |Disjunction| can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a `(?=` form (this unusual behaviour is inherited from Perl). This only matters when the |Disjunction| contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.</p>
          <p>For example,</p>
          <pre><code class="javascript">/(?=(a+))/.exec("baaabac")</code></pre>
          <p>matches the empty String immediately after the first `b` and therefore returns the array:</p>
          <pre><code class="javascript">["", "aaa"]</code></pre>
          <p>To illustrate the lack of backtracking into the lookahead, consider:</p>
          <pre><code class="javascript">/(?=(a+))a*b\1/.exec("baaabac")</code></pre>
          <p>This expression returns</p>
          <pre><code class="javascript">["aba", "a"]</code></pre>
          <p>and not:</p>
          <pre><code class="javascript">["aaaba", "a"]</code></pre>
        </emu-note>
        <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is not ~failure~, return ~failure~.
            1. Return _c_(_x_).
        </emu-alg>
        <emu-note>
          <p>The form `(?!` |Disjunction| `)` specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside |Disjunction| must fail to match at the current position. The current position is not advanced before matching the sequel. |Disjunction| can contain capturing parentheses, but backreferences to them only make sense from within |Disjunction| itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return *undefined* because the negative lookahead must fail for the pattern to succeed. For example,</p>
          <pre><code class="javascript">/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</code></pre>
          <p>looks for an `a` not immediately followed by some positive number n of `a`'s, a `b`, another n `a`'s (specified by the first `\\2`) and a `c`. The second `\\2` is outside the negative lookahead, so it matches against *undefined* and therefore always succeeds. The whole expression returns the array:</p>
          <pre><code class="javascript">["baaabaac", "ba", undefined, "abaac"]</code></pre>
        </emu-note>
        <emu-grammar>Assertion :: `(?&lt;=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is ~failure~, return ~failure~.
            1. Assert: _r_ is a MatchState.
            1. Let _cap_ be _r_.[[Captures]].
            1. Let _Input_ be _x_.[[Input]].
            1. Let _xe_ be _x_.[[EndIndex]].
            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.
            1. Return _c_(_z_).
        </emu-alg>
        <emu-grammar>Assertion :: `(?&lt;!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is not ~failure~, return ~failure~.
            1. Return _c_(_x_).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-iswordchar-abstract-operation" type="abstract operation">
          <h1>
            IsWordChar (
              _rer_: a RegExp Record,
              _Input_: a List of characters,
              _e_: an integer,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _InputLength_ be the number of elements in _Input_.
            1. If _e_ = -1 or _e_ = _InputLength_, return *false*.
            1. Let _c_ be the character _Input_[_e_].
            1. If WordCharacters(_rer_) contains _c_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilequantifier" type="sdo" oldids="sec-quantifier">
        <h1>Runtime Semantics: CompileQuantifier ( ): a Record with fields [[Min]] (a non-negative integer), [[Max]] (a non-negative integer or +&infin;), and [[Greedy]] (a Boolean)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Quantifier :: QuantifierPrefix</emu-grammar>
        <emu-alg>
          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.
          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* }.
        </emu-alg>
        <emu-grammar>Quantifier :: QuantifierPrefix `?`</emu-grammar>
        <emu-alg>
          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.
          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compilequantifierprefix" type="sdo">
        <h1>Runtime Semantics: CompileQuantifierPrefix ( ): a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +&infin;)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>QuantifierPrefix :: `*`</emu-grammar>
        <emu-alg>
          1. Return the Record { [[Min]]: 0, [[Max]]: +∞ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `+`</emu-grammar>
        <emu-alg>
          1. Return the Record { [[Min]]: 1, [[Max]]: +∞ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `?`</emu-grammar>
        <emu-alg>
          1. Return the Record { [[Min]]: 0, [[Max]]: 1 }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. Let _i_ be the MV of |DecimalDigits| (see <emu-xref href="#sec-literals-numeric-literals"></emu-xref>).
          1. Return the Record { [[Min]]: _i_, [[Max]]: _i_ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,}`</emu-grammar>
        <emu-alg>
          1. Let _i_ be the MV of |DecimalDigits|.
          1. Return the Record { [[Min]]: _i_, [[Max]]: +∞ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. Let _i_ be the MV of the first |DecimalDigits|.
          1. Let _j_ be the MV of the second |DecimalDigits|.
          1. Return the Record { [[Min]]: _i_, [[Max]]: _j_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compileatom" type="sdo" oldids="sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape">
        <h1>
          Runtime Semantics: CompileAtom (
            _rer_: a RegExp Record,
            _direction_: ~forward~ or ~backward~,
          ): a Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compileatom-annexb"></emu-xref>.</p>
        </emu-note>

        <!-- Atom -->
        <emu-grammar>Atom :: PatternCharacter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the character matched by |PatternCharacter|.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>Atom :: `.`</emu-grammar>
        <emu-alg>
          1. Let _A_ be AllCharacters(_rer_).
          1. If _rer_.[[DotAll]] is not *true*, then
            1. Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>Atom :: CharacterClass</emu-grammar>
        <emu-alg>
          1. Let _cc_ be CompileCharacterClass of |CharacterClass| with argument _rer_.
          1. Let _cs_ be _cc_.[[CharSet]].
          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_).
          1. Assert: _cc_.[[Invert]] is *false*.
          1. Let _lm_ be an empty List of Matchers.
          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do
            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.
            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).
            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do
              1. Let _cs1_ be a one-element CharSet containing _c1_.
              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).
              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).
            1. Append _m2_ to _lm_.
          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.
          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.
          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.
          1. Let _m2_ be the last Matcher in _lm_.
          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do
            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).
          1. Return _m2_.
        </emu-alg>
        <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.
          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).
          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Let _cap_ be a copy of _y_.[[Captures]].
              1. Let _Input_ be _x_.[[Input]].
              1. Let _xe_ be _x_.[[EndIndex]].
              1. Let _ye_ be _y_.[[EndIndex]].
              1. If _direction_ is ~forward~, then
                1. Assert: _xe_ ≤ _ye_.
                1. Let _r_ be the CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.
              1. Else,
                1. Assert: _direction_ is ~backward~.
                1. Assert: _ye_ ≤ _xe_.
                1. Let _r_ be the CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.
              1. Set _cap_[_parenIndex_ + 1] to _r_.
              1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.
              1. Return _c_(_z_).
            1. Return _m_(_x_, _d_).
        </emu-alg>
        <emu-note>
          <p>Parentheses of the form `(` |Disjunction| `)` serve both to group the components of the |Disjunction| pattern together and to save the result of the match. The result can be used either in a backreference (`\\` followed by a non-zero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching Abstract Closure. To inhibit the capturing behaviour of parentheses, use the form `(?:` |Disjunction| `)` instead.</p>
        </emu-note>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _addModifiers_ be the source text matched by |RegularExpressionModifiers|.
          1. Let _removeModifiers_ be the empty String.
          1. Let _modifiedRer_ be UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), _removeModifiers_).
          1. Return CompileSubpattern of |Disjunction| with arguments _modifiedRer_ and _direction_.
        </emu-alg>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _addModifiers_ be the source text matched by the first |RegularExpressionModifiers|.
          1. Let _removeModifiers_ be the source text matched by the second |RegularExpressionModifiers|.
          1. Let _modifiedRer_ be UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), CodePointsToString(_removeModifiers_)).
          1. Return CompileSubpattern of |Disjunction| with arguments _modifiedRer_ and _direction_.
        </emu-alg>

        <!-- AtomEscape -->
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <emu-alg>
          1. Let _n_ be the CapturingGroupNumber of |DecimalEscape|.
          1. Assert: _n_ ≤ _rer_.[[CapturingGroupsCount]].
          1. Return BackreferenceMatcher(_rer_, « _n_ », _direction_).
        </emu-alg>
        <emu-note>
          <p>An escape sequence of the form `\\` followed by a non-zero decimal number _n_ matches the result of the _n_<sup>th</sup> set of capturing parentheses (<emu-xref href="#sec-pattern-notation"></emu-xref>). It is an error if the regular expression has fewer than _n_ capturing parentheses. If the regular expression has _n_ or more capturing parentheses but the _n_<sup>th</sup> one is *undefined* because it has not captured anything, then the backreference always succeeds.</p>
        </emu-note>
        <emu-grammar>AtomEscape :: CharacterEscape</emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of |CharacterEscape|.
          1. Let _ch_ be the character whose character value is _cv_.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>AtomEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Let _cs_ be CompileToCharSet of |CharacterClassEscape| with argument _rer_.
          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, *false*, _direction_).
          1. Let _lm_ be an empty List of Matchers.
          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do
            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.
            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).
            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do
              1. Let _cs1_ be a one-element CharSet containing _c1_.
              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).
              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).
            1. Append _m2_ to _lm_.
          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.
          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.
          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.
          1. Let _m2_ be the last Matcher in _lm_.
          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do
            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).
          1. Return _m2_.
        </emu-alg>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <emu-alg>
          1. Let _matchingGroupSpecifiers_ be GroupSpecifiersThatMatch(|GroupName|).
          1. Let _parenIndices_ be a new empty List.
          1. For each |GroupSpecifier| _groupSpecifier_ of _matchingGroupSpecifiers_, do
            1. Let _parenIndex_ be CountLeftCapturingParensBefore(_groupSpecifier_).
            1. Append _parenIndex_ to _parenIndices_.
          1. Return BackreferenceMatcher(_rer_, _parenIndices_, _direction_).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-charactersetmatcher-abstract-operation" type="abstract operation">
          <h1>
            CharacterSetMatcher (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _invert_: a Boolean,
              _direction_: ~forward~ or ~backward~,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *true*, then
              1. Assert: _invert_ is *false*.
              1. Assert: Every CharSetElement of _A_ consists of a single character.
            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _A_, _invert_, and _direction_ and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Let _Input_ be _x_.[[Input]].
              1. Let _e_ be _x_.[[EndIndex]].
              1. If _direction_ is ~forward~, let _f_ be _e_ + 1.
              1. Else, let _f_ be _e_ - 1.
              1. Let _InputLength_ be the number of elements in _Input_.
              1. If _f_ &lt; 0 or _f_ > _InputLength_, return ~failure~.
              1. Let _index_ be min(_e_, _f_).
              1. Let _ch_ be the character _Input_[_index_].
              1. Let _cc_ be Canonicalize(_rer_, _ch_).
              1. If there exists a CharSetElement in _A_ containing exactly one character _a_ such that Canonicalize(_rer_, _a_) is _cc_, let _found_ be *true*; otherwise let _found_ be *false*.
              1. If _invert_ is *false* and _found_ is *false*, return ~failure~.
              1. If _invert_ is *true* and _found_ is *true*, return ~failure~.
              1. Let _cap_ be _x_.[[Captures]].
              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.
              1. Return _c_(_y_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-backreference-matcher" type="abstract operation">
          <h1>
            BackreferenceMatcher (
              _rer_: a RegExp Record,
              _ns_: a List of positive integers,
              _direction_: ~forward~ or ~backward~,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _ns_, and _direction_ and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Let _Input_ be _x_.[[Input]].
              1. Let _cap_ be _x_.[[Captures]].
              1. Let _r_ be *undefined*.
              1. For each integer _n_ of _ns_, do
                1. If _cap_[_n_] is not *undefined*, then
                  1. Assert: _r_ is *undefined*.
                  1. Set _r_ to _cap_[_n_].
              1. If _r_ is *undefined*, return _c_(_x_).
              1. Let _e_ be _x_.[[EndIndex]].
              1. Let _rs_ be _r_.[[StartIndex]].
              1. Let _re_ be _r_.[[EndIndex]].
              1. Let _len_ be _re_ - _rs_.
              1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.
              1. Else, let _f_ be _e_ - _len_.
              1. Let _InputLength_ be the number of elements in _Input_.
              1. If _f_ &lt; 0 or _f_ > _InputLength_, return ~failure~.
              1. Let _g_ be min(_e_, _f_).
              1. If there exists an integer _i_ in the interval from 0 (inclusive) to _len_ (exclusive) such that Canonicalize(_rer_, _Input_[_rs_ + _i_]) is not Canonicalize(_rer_, _Input_[_g_ + _i_]), return ~failure~.
              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.
              1. Return _c_(_y_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-canonicalize-ch" type="abstract operation">
          <h1>
            Canonicalize (
              _rer_: a RegExp Record,
              _ch_: a character,
            ): a character
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*, then
              1. If the file <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.
              1. Return _ch_.
            1. If _rer_.[[IgnoreCase]] is *false*, return _ch_.
            1. Assert: _ch_ is a UTF-16 code unit.
            1. Let _cp_ be the code point whose numeric value is the numeric value of _ch_.
            1. Let _u_ be toUppercase(« _cp_ »), according to the Unicode Default Case Conversion algorithm.
            1. Let _uStr_ be CodePointsToString(_u_).
            1. If the length of _uStr_ ≠ 1, return _ch_.
            1. Let _cu_ be _uStr_'s single code unit element.
            1. If the numeric value of _ch_ ≥ 128 and the numeric value of _cu_ &lt; 128, return _ch_.
            1. Return _cu_.
          </emu-alg>
          <emu-note>
            <p>In case-insignificant matches when HasEitherUnicodeFlag(_rer_) is *true*, all characters are implicitly case-folded using the simple mapping provided by the Unicode Standard immediately before they are compared. The simple mapping always maps to a single code point, so it does not map, for example, `ß` (U+00DF LATIN SMALL LETTER SHARP S) to `ss` or `SS`. It may however map code points outside the Basic Latin block to code points within it—for example, `ſ` (U+017F LATIN SMALL LETTER LONG S) case-folds to `s` (U+0073 LATIN SMALL LETTER S) and `K` (U+212A KELVIN SIGN) case-folds to `k` (U+006B LATIN SMALL LETTER K). Strings containing those code points are matched by regular expressions such as `/[a-z]/ui`.</p>
            <p>In case-insignificant matches when HasEitherUnicodeFlag(_rer_) is *false*, the mapping is based on Unicode Default Case Conversion algorithm toUppercase rather than toCasefold, which results in some subtle differences. For example, `Ω` (U+2126 OHM SIGN) is mapped by toUppercase to itself but by toCasefold to `ω` (U+03C9 GREEK SMALL LETTER OMEGA) along with `Ω` (U+03A9 GREEK CAPITAL LETTER OMEGA), so *"\u2126"* is matched by `/[ω]/ui` and `/[\u03A9]/ui` but not by `/[ω]/i` or `/[\u03A9]/i`. Also, no code point outside the Basic Latin block is mapped to a code point within it, so strings such as *"\u017F ſ"* and *"\u212A K"* are not matched by `/[a-z]/i`.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-updatemodifiers" type="abstract operation">
          <h1>
            UpdateModifiers (
              _rer_: a RegExp Record,
              _add_: a String,
              _remove_: a String,
            ): a RegExp Record
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _add_ and _remove_ have no elements in common.
            1. Let _ignoreCase_ be _rer_.[[IgnoreCase]].
            1. Let _multiline_ be _rer_.[[Multiline]].
            1. Let _dotAll_ be _rer_.[[DotAll]].
            1. Let _unicode_ be _rer_.[[Unicode]].
            1. Let _unicodeSets_ be _rer_.[[UnicodeSets]].
            1. Let _capturingGroupsCount_ be _rer_.[[CapturingGroupsCount]].
            1. If _remove_ contains *"i"*, set _ignoreCase_ to *false*.
            1. Else if _add_ contains *"i"*, set _ignoreCase_ to *true*.
            1. If _remove_ contains *"m"*, set _multiline_ to *false*.
            1. Else if _add_ contains *"m"*, set _multiline_ to *true*.
            1. If _remove_ contains *"s"*, set _dotAll_ to *false*.
            1. Else if _add_ contains *"s"*, set _dotAll_ to *true*.
            1. Return the RegExp Record { [[IgnoreCase]]: _ignoreCase_, [[Multiline]]: _multiline_, [[DotAll]]: _dotAll_, [[Unicode]]: _unicode_, [[UnicodeSets]]: _unicodeSets_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilecharacterclass" type="sdo" oldids="sec-characterclass">
        <h1>
          Runtime Semantics: CompileCharacterClass (
            _rer_: a RegExp Record,
          ): a Record with fields [[CharSet]] (a CharSet) and [[Invert]] (a Boolean)
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>CharacterClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *false* }.
        </emu-alg>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. If _rer_.[[UnicodeSets]] is *true*, then
            1. Return the Record { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* }.
          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *true* }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compiletocharset" type="sdo" oldids="sec-classranges,sec-nonemptyclassranges,sec-nonemptyclassrangesnodash,sec-classatom,sec-classatomnodash,sec-classescape,sec-characterclassescape">
        <h1>
          Runtime Semantics: CompileToCharSet (
            _rer_: a RegExp Record,
          ): a CharSet
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compiletocharset-annexb"></emu-xref>.</p>
        </emu-note>

        <!-- ClassContents -->
        <emu-grammar>ClassContents :: [empty]</emu-grammar>
        <emu-alg>
          1. Return the empty CharSet.
        </emu-alg>

        <!-- NonemptyClassRanges -->
        <emu-grammar>NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtom| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRange(_A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>

        <!-- NonemptyClassRangesNoDash -->
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRange(_A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>
        <emu-note>
          <p>|ClassContents| can expand into a single |ClassAtom| and/or ranges of two |ClassAtom| separated by dashes. In the latter case the |ClassContents| includes all characters between the first |ClassAtom| and the second |ClassAtom|, inclusive; an error occurs if either |ClassAtom| does not represent a single character (for example, if one is \w) or if the first |ClassAtom|'s character value is strictly greater than the second |ClassAtom|'s character value.</p>
        </emu-note>
        <emu-note>
          <p>Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. Thus, for example, the pattern `/[E-F]/i` matches only the letters `E`, `F`, `e`, and `f`, while the pattern `/[E-f]/i` matches all uppercase and lowercase letters in the Unicode Basic Latin block as well as the symbols `[`, `\\`, `]`, `^`, `_`, and <code>`</code>.</p>
        </emu-note>
        <emu-note>
          <p>A `-` character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of |ClassContents|, the beginning or end limit of a range specification, or immediately follows a range specification.</p>
        </emu-note>

        <!-- ClassAtom -->
        <emu-grammar>ClassAtom :: `-`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).
        </emu-alg>

        <!-- ClassAtomNoDash -->
        <emu-grammar>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the character matched by |SourceCharacter|.
        </emu-alg>

        <!-- ClassEscape -->
        <emu-grammar>
          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassEscape|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-note>
          <p>A |ClassAtom| can use any of the escape sequences that are allowed in the rest of the regular expression except for `\\b`, `\\B`, and backreferences. Inside a |CharacterClass|, `\\b` means the backspace character, while `\\B` and backreferences raise errors. Using a backreference inside a |ClassAtom| causes an error.</p>
        </emu-note>

        <!-- CharacterClassEscape -->
        <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>
        <emu-alg>
          1. Return the ten-element CharSet containing the characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, and `9`.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `D`</emu-grammar>
        <emu-alg>
          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `S`</emu-grammar>
        <emu-alg>
          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>
        <emu-alg>
          1. Return MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `W`</emu-grammar>
        <emu-alg>
          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `p{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. Let _S_ be CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.
          1. Assert: _S_ contains only single code points.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <emu-alg>
          1. Let _ps_ be the source text matched by |UnicodePropertyName|.
          1. Let _p_ be UnicodeMatchProperty(_rer_, _ps_).
          1. Assert: _p_ is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
          1. Let _vs_ be the source text matched by |UnicodePropertyValue|.
          1. Let _v_ be UnicodeMatchPropertyValue(_p_, _vs_).
          1. Let _A_ be the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. Let _s_ be the source text matched by |LoneUnicodePropertyNameOrValue|.
          1. If UnicodeMatchPropertyValue(`General_Category`, _s_) is a Unicode property value or property value alias for the General_Category (gc) property listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>, then
            1. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value _s_.
          1. Let _p_ be UnicodeMatchProperty(_rer_, _s_).
          1. Assert: _p_ is a binary Unicode property or binary property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href="#table-binary-unicode-properties"></emu-xref>, or a binary Unicode property of strings listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>.
          1. Let _A_ be the CharSet containing all CharSetElements whose character database definition includes the property _p_ with value “True”.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>

        <!-- ClassUnion -->
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.
          1. If |ClassUnion| is present, then
            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.
            1. Return the union of CharSets _A_ and _B_.
          1. Return _A_.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.
          1. If |ClassUnion| is present, then
            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.
            1. Return the union of CharSets _A_ and _B_.
          1. Return _A_.
        </emu-alg>

        <!-- ClassIntersection -->
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.
          1. Return the intersection of CharSets _A_ and _B_.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the |ClassIntersection| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.
          1. Return the intersection of CharSets _A_ and _B_.
        </emu-alg>

        <!-- ClassSubtraction -->
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.
          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the |ClassSubtraction| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.
          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.
        </emu-alg>

        <!-- ClassSetRange -->
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassSetCharacter| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassSetCharacter| with argument _rer_.
          1. Return MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)).
        </emu-alg>
        <emu-note>
          <p>The result will often consist of two or more ranges. When UnicodeSets is *true* and IgnoreCase is *true*, then MaybeSimpleCaseFolding(_rer_, [Ā-č]) will include only the odd-numbered code points of that range.</p>
        </emu-note>

        <!-- ClassSetOperand -->
        <emu-grammar>ClassSetOperand :: ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>
        <emu-grammar>ClassSetOperand :: ClassStringDisjunction</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassStringDisjunction| with argument _rer_.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>
        <emu-grammar>ClassSetOperand :: NestedClass</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |NestedClass| with argument _rer_.
        </emu-alg>

        <!-- NestedClass -->
        <emu-grammar>NestedClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |ClassContents| with argument _rer_.
        </emu-alg>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Return CharacterComplement(_rer_, _A_).
        </emu-alg>
        <emu-grammar>NestedClass :: `\` CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |CharacterClassEscape| with argument _rer_.
        </emu-alg>

        <!-- ClassStringDisjunction -->
        <emu-grammar>ClassStringDisjunction :: `\q{` ClassStringDisjunctionContents `}`</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.
        </emu-alg>

        <!-- ClassStringDisjunctionContents -->
        <emu-grammar>ClassStringDisjunctionContents :: ClassString</emu-grammar>
        <emu-alg>
          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.
          1. Return the CharSet containing the one string _s_.
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.
          1. Let _A_ be the CharSet containing the one string _s_.
          1. Let _B_ be CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>

        <!-- ClassSetCharacter -->
        <emu-grammar>
          ClassSetCharacter ::
            SourceCharacter but not ClassSetSyntaxCharacter
            `\` CharacterEscape
            `\` ClassSetReservedPunctuator
        </emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the single character U+0008 (BACKSPACE).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-characterrange-abstract-operation" type="abstract operation">
          <h1>
            CharacterRange (
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _A_ and _B_ each contain exactly one character.
            1. Let _a_ be the one character in CharSet _A_.
            1. Let _b_ be the one character in CharSet _B_.
            1. Let _i_ be the character value of character _a_.
            1. Let _j_ be the character value of character _b_.
            1. Assert: _i_ ≤ _j_.
            1. Return the CharSet containing all characters with a character value in the inclusive interval from _i_ to _j_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-haseitherunicodeflag-abstract-operation" type="abstract operation">
          <h1>
            HasEitherUnicodeFlag (
              _rer_: a RegExp Record,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _rer_.[[Unicode]] is *true* or _rer_.[[UnicodeSets]] is *true*, then
              1. Return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-wordcharacters" type="abstract operation" oldids="sec-runtime-semantics-wordcharacters-abstract-operation">
          <h1>
            WordCharacters (
              _rer_: a RegExp Record,
            ): a CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Returns a CharSet containing the characters considered "word characters" for the purposes of `\\b`, `\\B`, `\\w`, and `\\W`</dd>
          </dl>
          <emu-alg>
            1. Let _basicWordChars_ be the CharSet containing every character in the ASCII word characters.
            1. Let _extraWordChars_ be the CharSet containing all characters _c_ such that _c_ is not in _basicWordChars_ but Canonicalize(_rer_, _c_) is in _basicWordChars_.
            1. Assert: _extraWordChars_ is empty unless HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*.
            1. Return the union of _basicWordChars_ and _extraWordChars_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allcharacters" type="abstract operation">
          <h1>
            AllCharacters (
              _rer_: a RegExp Record,
            ): a CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Returns the set of “all characters” according to the regular expression flags.</dd>
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *true* and _rer_.[[IgnoreCase]] is *true*, then
              1. [declared="c"] Return the CharSet containing all Unicode code points _c_ that do not have a <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).
            1. Else if HasEitherUnicodeFlag(_rer_) is *true*, then
              1. Return the CharSet containing all code point values.
            1. Else,
              1. Return the CharSet containing all code unit values.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-maybesimplecasefolding" type="abstract operation">
          <h1>
            MaybeSimpleCaseFolding (
              _rer_: a RegExp Record,
              _A_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, it returns _A_. Otherwise, it uses the <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> (<emu-eqn id="eqn-scf" aoid="scf">scf(_cp_)</emu-eqn>) definitions in the file <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> of the Unicode Character Database (each of which maps a single code point to another single code point) to map each CharSetElement of _A_ character-by-character into a canonical form and returns the resulting CharSet.</dd>
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, return _A_.
            1. Let _B_ be a new empty CharSet.
            1. For each CharSetElement _s_ of _A_, do
              1. Let _t_ be an empty sequence of characters.
              1. For each single code point _cp_ in _s_, do
                1. Append scf(_cp_) to _t_.
              1. Add _t_ to _B_.
            1. Return _B_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-charactercomplement" type="abstract operation">
          <h1>
            CharacterComplement (
              _rer_: a RegExp Record,
              _S_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _A_ be AllCharacters(_rer_).
            1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _S_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchproperty-p" type="abstract operation">
          <h1>
            UnicodeMatchProperty (
              _rer_: a RegExp Record,
              _p_: ECMAScript source text,
            ): a Unicode property name
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *true* and _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>, then
              1. Return the List of Unicode code points _p_.
            1. Assert: _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> or <emu-xref href="#table-binary-unicode-properties"></emu-xref>.
            1. Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the “Canonical <emu-not-ref>property name</emu-not-ref>” column of the corresponding row.
            1. Return the List of Unicode code points _c_.
          </emu-alg>
          <p>Implementations must support the Unicode property names and aliases listed in <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>, <emu-xref href="#table-binary-unicode-properties"></emu-xref>, and <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>. To ensure interoperability, implementations must not support any other property names or aliases.</p>
          <emu-note>
            <p>For example, `Script_Extensions` (property name) and `scx` (property alias) are valid, but `script_extensions` or `Scx` aren't.</p>
          </emu-note>
          <emu-note>
            <p>The listed properties form a superset of what <a href="https://unicode.org/reports/tr18/#RL1.2">UTS18 RL1.2</a> requires.</p>
          </emu-note>
          <emu-note>
            <p>The spellings of entries in these tables (including casing) match the spellings used in the file <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt"><code>PropertyAliases.txt</code></a> in the Unicode Character Database. The precise spellings in that file are <a href="https://www.unicode.org/policies/stability_policy.html#Alias_Stability">guaranteed to be stable</a>.</p>
          </emu-note>
          <emu-import href="table-nonbinary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties-of-strings.html"></emu-import>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchpropertyvalue-p-v" type="abstract operation">
          <h1>
            UnicodeMatchPropertyValue (
              _p_: ECMAScript source text,
              _v_: ECMAScript source text,
            ): a Unicode property value
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _p_ is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
            1. Assert: _v_ is a property value or property value alias for the Unicode property _p_ listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>.
            1. Let _value_ be the canonical property value of _v_ as given in the “Canonical property value” column of the corresponding row.
            1. Return the List of Unicode code points _value_.
          </emu-alg>
          <p>Implementations must support the Unicode property values and property value aliases listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a> for the properties listed in <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>. To ensure interoperability, implementations must not support any other property values or property value aliases.</p>
          <emu-note>
            <p>For example, `Xpeo` and `Old_Persian` are valid `Script_Extensions` values, but `xpeo` and `Old Persian` aren't.</p>
          </emu-note>
          <emu-note>
            <p>This algorithm differs from <a href="https://unicode.org/reports/tr44/#Matching_Symbolic">the matching rules for symbolic values listed in UAX44</a>: case, <emu-xref href="#sec-white-space">white space</emu-xref>, U+002D (HYPHEN-MINUS), and U+005F (LOW LINE) are not ignored, and the `Is` prefix is not supported.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileclasssetstring" type="sdo">
        <h1>
          Runtime Semantics: CompileClassSetString (
            _rer_: a RegExp Record,
          ): a sequence of characters
        </h1>
        <dl class="header">
        </dl>

        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. Return an empty sequence of characters.
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. Return CompileClassSetString of |NonEmptyClassString| with argument _rer_.
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.
          1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.
          1. If |NonEmptyClassString| is present, then
            1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.
            1. Return the concatenation of _s1_ and _s2_.
          1. Return _s1_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-creation" oldids="sec-abstract-operations-for-the-regexp-constructor">
      <h1>Abstract Operations for RegExp Creation</h1>

      <emu-clause id="sec-regexpcreate" type="abstract operation">
        <h1>
          RegExpCreate (
            _P_: an ECMAScript language value,
            _F_: a String or *undefined*,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _obj_ be ! RegExpAlloc(%RegExp%).
          1. Return ? RegExpInitialize(_obj_, _P_, _F_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpalloc" type="abstract operation">
        <h1>
          RegExpAlloc (
            _newTarget_: a constructor,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%RegExp.prototype%"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »).
          1. Perform ! DefinePropertyOrThrow(_obj_, *"lastIndex"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpinitialize" type="abstract operation">
        <h1>
          RegExpInitialize (
            _obj_: an Object,
            _pattern_: an ECMAScript language value,
            _flags_: an ECMAScript language value,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _pattern_ is *undefined*, let _P_ be the empty String.
          1. Else, let _P_ be ? ToString(_pattern_).
          1. If _flags_ is *undefined*, let _F_ be the empty String.
          1. Else, let _F_ be ? ToString(_flags_).
          1. If _F_ contains any code unit other than *"d"*, *"g"*, *"i"*, *"m"*, *"s"*, *"u"*, *"v"*, or *"y"*, or if _F_ contains any code unit more than once, throw a *SyntaxError* exception.
          1. If _F_ contains *"i"*, let _i_ be *true*; else let _i_ be *false*.
          1. If _F_ contains *"m"*, let _m_ be *true*; else let _m_ be *false*.
          1. If _F_ contains *"s"*, let _s_ be *true*; else let _s_ be *false*.
          1. If _F_ contains *"u"*, let _u_ be *true*; else let _u_ be *false*.
          1. If _F_ contains *"v"*, let _v_ be *true*; else let _v_ be *false*.
          1. If _u_ is *true* or _v_ is *true*, then
            1. Let _patternText_ be StringToCodePoints(_P_).
          1. Else,
            1. Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).
          1. If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.
          1. Assert: _parseResult_ is a |Pattern| Parse Node.
          1. Set _obj_.[[OriginalSource]] to _P_.
          1. Set _obj_.[[OriginalFlags]] to _F_.
          1. Let _capturingGroupsCount_ be CountLeftCapturingParensWithin(_parseResult_).
          1. Let _rer_ be the RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.
          1. Set _obj_.[[RegExpRecord]] to _rer_.
          1. Set _obj_.[[RegExpMatcher]] to CompilePattern of _parseResult_ with argument _rer_.
          1. Perform ? <emu-meta suppress-effects="user-code">Set(_obj_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-parsepattern" type="abstract operation">
        <h1>
          Static Semantics: ParsePattern (
            _patternText_: a sequence of Unicode code points,
            _u_: a Boolean,
            _v_: a Boolean,
          ): a Parse Node or a non-empty List of *SyntaxError* objects
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-parsepattern-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-alg>
          1. If _v_ is *true* and _u_ is *true*, then
            1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.
          1. Else if _v_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else if _u_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else,
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Return _parseResult_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-constructor">
      <h1>The RegExp Constructor</h1>
      <p>The RegExp constructor:</p>
      <ul>
        <li>is <dfn>%RegExp%</dfn>.</li>
        <li>is the initial value of the *"RegExp"* property of the global object.</li>
        <li>creates and initializes a new RegExp object when called as a constructor.</li>
        <li>when called as a function rather than as a constructor, returns either a new RegExp object, or the argument itself if the only argument is a RegExp object.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified RegExp behaviour must include a `super` call to the RegExp constructor to create and initialize subclass instances with the necessary internal slots.</li>
      </ul>

      <emu-clause id="sec-regexp-pattern-flags">
        <h1>RegExp ( _pattern_, _flags_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).
          1. If NewTarget is *undefined*, then
            1. Let _newTarget_ be the active function object.
            1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then
              1. Let _patternConstructor_ be ? Get(_pattern_, *"constructor"*).
              1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.
          1. Else,
            1. Let _newTarget_ be NewTarget.
          1. If _pattern_ is an Object and _pattern_ has a [[RegExpMatcher]] internal slot, then
            1. Let _P_ be _pattern_.[[OriginalSource]].
            1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].
            1. Else, let _F_ be _flags_.
          1. Else if _patternIsRegExp_ is *true*, then
            1. Let _P_ be ? Get(_pattern_, *"source"*).
            1. If _flags_ is *undefined*, then
              1. Let _F_ be ? Get(_pattern_, *"flags"*).
            1. Else,
              1. Let _F_ be _flags_.
          1. Else,
            1. Let _P_ be _pattern_.
            1. Let _F_ be _flags_.
          1. Let _O_ be ? RegExpAlloc(_newTarget_).
          1. Return ? RegExpInitialize(_O_, _P_, _F_).
        </emu-alg>
        <emu-note>
          <p>If pattern is supplied using a |StringLiteral|, the usual escape sequence substitutions are performed before the String is processed by this function. If pattern must contain an escape sequence to be recognized by this function, any U+005C (REVERSE SOLIDUS) code points must be escaped within the |StringLiteral| to prevent them being removed when the contents of the |StringLiteral| are formed.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>Properties of the RegExp Constructor</h1>
      <p>The RegExp constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-regexp.escape">
        <h1>RegExp.escape ( _S_ )</h1>
        <p>This function returns a copy of _S_ in which characters that are potentially special in a regular expression |Pattern| have been replaced by equivalent escape sequences.</p>
        <p>It performs the following steps when called:</p>

        <emu-alg>
          1. If _S_ is not a String, throw a *TypeError* exception.
          1. Let _escaped_ be the empty String.
          1. Let _cpList_ be StringToCodePoints(_S_).
          1. For each code point _cp_ of _cpList_, do
            1. If _escaped_ is the empty String and _cp_ is matched by either |DecimalDigit| or |AsciiLetter|, then
              1. NOTE: Escaping a leading digit ensures that output corresponds with pattern text which may be used after a `\0` character escape or a |DecimalEscape| such as `\1` and still match _S_ rather than be interpreted as an extension of the preceding escape sequence. Escaping a leading ASCII letter does the same for the context after `\c`.
              1. Let _numericValue_ be the numeric value of _cp_.
              1. Let _hex_ be Number::toString(𝔽(_numericValue_), 16).
              1. Assert: The length of _hex_ is 2.
              1. Set _escaped_ to the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *"x"*, and _hex_.
            1. Else,
              1. Set _escaped_ to the string-concatenation of _escaped_ and EncodeForRegExpEscape(_cp_).
          1. Return _escaped_.
        </emu-alg>

        <emu-note>
          <p>Despite having similar names, EscapeRegExpPattern and `RegExp.escape` do not perform similar actions. The former escapes a pattern for representation as a string, while this function escapes a string for representation inside a pattern.</p>
        </emu-note>

        <emu-clause id="sec-encodeforregexpescape" type="abstract operation">
          <h1>
            EncodeForRegExpEscape (
              _cp_: a code point,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It returns a String representing a |Pattern| for matching _cp_. If _cp_ is white space or an ASCII punctuator, the returned value is an escape sequence. Otherwise, the returned value is a String representation of _cp_ itself.</dd>
          </dl>

          <emu-alg>
            1. If _cp_ is matched by |SyntaxCharacter| or _cp_ is U+002F (SOLIDUS), then
              1. Return the string-concatenation of 0x005C (REVERSE SOLIDUS) and UTF16EncodeCodePoint(_cp_).
            1. Else if _cp_ is a code point listed in the “Code Point” column of <emu-xref href="#table-controlescape-code-point-values"></emu-xref>, then
              1. Return the string-concatenation of 0x005C (REVERSE SOLIDUS) and the string in the “ControlEscape” column of the row whose “Code Point” column contains _cp_.
            1. Let _otherPunctuators_ be the string-concatenation of *",-=&lt;>#&amp;!%:;@~'`"* and the code unit 0x0022 (QUOTATION MARK).
            1. Let _toEscape_ be StringToCodePoints(_otherPunctuators_).
            1. If _toEscape_ contains _cp_, _cp_ is matched by either |WhiteSpace| or |LineTerminator|, or _cp_ has the same numeric value as a leading surrogate or trailing surrogate, then
              1. Let _cpNum_ be the numeric value of _cp_.
              1. If _cpNum_ ≤ 0xFF, then
                1. Let _hex_ be Number::toString(𝔽(_cpNum_), 16).
                1. Return the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *"x"*, and StringPad(_hex_, 2, *"0"*, ~start~).
              1. Let _escaped_ be the empty String.
              1. Let _codeUnits_ be UTF16EncodeCodePoint(_cp_).
              1. For each code unit _cu_ of _codeUnits_, do
                1. Set _escaped_ to the string-concatenation of _escaped_ and UnicodeEscape(_cu_).
              1. Return _escaped_.
            1. Return UTF16EncodeCodePoint(_cp_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype">
        <h1>RegExp.prototype</h1>
        <p>The initial value of `RegExp.prototype` is the RegExp prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-regexp-@@species" id="sec-get-regexp-%symbol.species%">
        <h1>get RegExp [ %Symbol.species% ]</h1>
        <p>`RegExp[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>RegExp prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>Properties of the RegExp Prototype Object</h1>
      <p>The <dfn>RegExp prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%RegExp.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a RegExp instance and does not have a [[RegExpMatcher]] internal slot or any of the other internal slots of RegExp instance objects.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <emu-note>
        <p>The RegExp prototype object does not have a *"valueOf"* property of its own; however, it inherits the *"valueOf"* property from the Object prototype object.</p>
      </emu-note>

      <emu-clause id="sec-regexp.prototype.constructor">
        <h1>RegExp.prototype.constructor</h1>
        <p>The initial value of `RegExp.prototype.constructor` is %RegExp%.</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.exec">
        <h1>RegExp.prototype.exec ( _string_ )</h1>
        <p>This method searches _string_ for an occurrence of the regular expression pattern and returns an Array containing the results of the match, or *null* if _string_ did not match.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Let _S_ be ? ToString(_string_).
          1. Return ? RegExpBuiltinExec(_R_, _S_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.dotAll">
        <h1>get RegExp.prototype.dotAll</h1>
        <p>`RegExp.prototype.dotAll` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0073 (LATIN SMALL LETTER S).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.flags">
        <h1>get RegExp.prototype.flags</h1>
        <p>`RegExp.prototype.flags` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _codeUnits_ be a new empty List.
          1. Let _hasIndices_ be ToBoolean(? Get(_R_, *"hasIndices"*)).
          1. If _hasIndices_ is *true*, append the code unit 0x0064 (LATIN SMALL LETTER D) to _codeUnits_.
          1. Let _global_ be ToBoolean(? Get(_R_, *"global"*)).
          1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) to _codeUnits_.
          1. Let _ignoreCase_ be ToBoolean(? Get(_R_, *"ignoreCase"*)).
          1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) to _codeUnits_.
          1. Let _multiline_ be ToBoolean(? Get(_R_, *"multiline"*)).
          1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) to _codeUnits_.
          1. Let _dotAll_ be ToBoolean(? Get(_R_, *"dotAll"*)).
          1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) to _codeUnits_.
          1. Let _unicode_ be ToBoolean(? Get(_R_, *"unicode"*)).
          1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) to _codeUnits_.
          1. Let _unicodeSets_ be ToBoolean(? Get(_R_, *"unicodeSets"*)).
          1. If _unicodeSets_ is *true*, append the code unit 0x0076 (LATIN SMALL LETTER V) to _codeUnits_.
          1. Let _sticky_ be ToBoolean(? Get(_R_, *"sticky"*)).
          1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) to _codeUnits_.
          1. Return the String value whose code units are the elements of the List _codeUnits_. If _codeUnits_ has no elements, the empty String is returned.
        </emu-alg>

        <emu-clause id="sec-regexphasflag" type="abstract operation">
          <h1>
            RegExpHasFlag (
              _R_: an ECMAScript language value,
              _codeUnit_: a code unit,
            ): either a normal completion containing either a Boolean or *undefined*, or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _R_ is not an Object, throw a *TypeError* exception.
            1. If _R_ does not have an [[OriginalFlags]] internal slot, then
              1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.
              1. Otherwise, throw a *TypeError* exception.
            1. Let _flags_ be _R_.[[OriginalFlags]].
            1. If _flags_ contains _codeUnit_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.global">
        <h1>get RegExp.prototype.global</h1>
        <p>`RegExp.prototype.global` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0067 (LATIN SMALL LETTER G).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.hasIndices">
        <h1>get RegExp.prototype.hasIndices</h1>
        <p>`RegExp.prototype.hasIndices` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0064 (LATIN SMALL LETTER D).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.ignorecase">
        <h1>get RegExp.prototype.ignoreCase</h1>
        <p>`RegExp.prototype.ignoreCase` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0069 (LATIN SMALL LETTER I).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@match" id="sec-regexp.prototype-%symbol.match%">
        <h1>RegExp.prototype [ %Symbol.match% ] ( _string_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _flags_ be ? ToString(? Get(_rx_, *"flags"*)).
          1. If _flags_ does not contain *"g"*, then
            1. Return ? RegExpExec(_rx_, _S_).
          1. Else,
            1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*; otherwise let _fullUnicode_ be *false*.
            1. Perform ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
            1. Let _A_ be ! ArrayCreate(0).
            1. Let _n_ be 0.
            1. Repeat,
              1. Let _result_ be ? RegExpExec(_rx_, _S_).
              1. If _result_ is *null*, then
                1. If _n_ = 0, return *null*.
                1. Return _A_.
              1. Else,
                1. Let _matchStr_ be ? ToString(? Get(_result_, *"0"*)).
                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).
                1. If _matchStr_ is the empty String, then
                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))).
                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
                1. Set _n_ to _n_ + 1.
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.match]"*.</p>
        <emu-note>
          <p>The %Symbol.match% property is used by the IsRegExp abstract operation to identify objects that have the basic behaviour of regular expressions. The absence of a %Symbol.match% property or the existence of such a property whose value does not Boolean coerce to *true* indicates that the object is not intended to be used as a regular expression object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-regexp-prototype-matchall" id="sec-regexp-prototype-%symbol.matchall%">
        <h1>RegExp.prototype [ %Symbol.matchAll% ] ( _string_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).
          1. Let _flags_ be ? ToString(? Get(_R_, *"flags"*)).
          1. Let _matcher_ be ? Construct(_C_, « _R_, _flags_ »).
          1. Let _lastIndex_ be ? ToLength(? Get(_R_, *"lastIndex"*)).
          1. Perform ? Set(_matcher_, *"lastIndex"*, _lastIndex_, *true*).
          1. If _flags_ contains *"g"*, let _global_ be *true*.
          1. Else, let _global_ be *false*.
          1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*.
          1. Else, let _fullUnicode_ be *false*.
          1. Return CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_).
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.matchAll]"*.</p>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.multiline">
        <h1>get RegExp.prototype.multiline</h1>
        <p>`RegExp.prototype.multiline` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x006D (LATIN SMALL LETTER M).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@replace" id="sec-regexp.prototype-%symbol.replace%">
        <h1>RegExp.prototype [ %Symbol.replace% ] ( _string_, _replaceValue_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _lengthS_ be the length of _S_.
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _flags_ be ? ToString(? Get(_rx_, *"flags"*)).
          1. If _flags_ contains *"g"*, let _global_ be *true*; otherwise let _global_ be *false*.
          1. If _global_ is *true*, then
            1. Perform ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
          1. Let _results_ be a new empty List.
          1. Let _done_ be *false*.
          1. Repeat, while _done_ is *false*,
            1. Let _result_ be ? RegExpExec(_rx_, _S_).
            1. If _result_ is *null*, then
              1. Set _done_ to *true*.
            1. Else,
              1. Append _result_ to _results_.
              1. If _global_ is *false*, then
                1. Set _done_ to *true*.
              1. Else,
                1. Let _matchStr_ be ? ToString(? Get(_result_, *"0"*)).
                1. If _matchStr_ is the empty String, then
                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))).
                  1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*; otherwise let _fullUnicode_ be *false*.
                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
          1. Let _accumulatedResult_ be the empty String.
          1. Let _nextSourcePosition_ be 0.
          1. For each element _result_ of _results_, do
            1. Let _resultLength_ be ? LengthOfArrayLike(_result_).
            1. Let _nCaptures_ be max(_resultLength_ - 1, 0).
            1. Let _matched_ be ? ToString(? Get(_result_, *"0"*)).
            1. Let _matchLength_ be the length of _matched_.
            1. Let _position_ be ? ToIntegerOrInfinity(? Get(_result_, *"index"*)).
            1. Set _position_ to the result of clamping _position_ between 0 and _lengthS_.
            1. Let _captures_ be a new empty List.
            1. Let _n_ be 1.
            1. Repeat, while _n_ ≤ _nCaptures_,
              1. Let _capN_ be ? Get(_result_, ! ToString(𝔽(_n_))).
              1. If _capN_ is not *undefined*, then
                1. Set _capN_ to ? ToString(_capN_).
              1. Append _capN_ to _captures_.
              1. NOTE: When _n_ = 1, the preceding step puts the first element into _captures_ (at index 0). More generally, the _n_<sup>th</sup> capture (the characters captured by the _n_<sup>th</sup> set of capturing parentheses) is at _captures_[_n_ - 1].
              1. Set _n_ to _n_ + 1.
            1. Let _namedCaptures_ be ? Get(_result_, *"groups"*).
            1. If _functionalReplace_ is *true*, then
              1. Let _replacerArgs_ be the list-concatenation of « _matched_ », _captures_, and « 𝔽(_position_), _S_ ».
              1. If _namedCaptures_ is not *undefined*, then
                1. Append _namedCaptures_ to _replacerArgs_.
              1. Let _replacementValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).
              1. Let _replacementString_ be ? ToString(_replacementValue_).
            1. Else,
              1. If _namedCaptures_ is not *undefined*, then
                1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).
              1. Let _replacementString_ be ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).
            1. If _position_ ≥ _nextSourcePosition_, then
              1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.
              1. Set _accumulatedResult_ to the string-concatenation of _accumulatedResult_, the substring of _S_ from _nextSourcePosition_ to _position_, and _replacementString_.
              1. Set _nextSourcePosition_ to _position_ + _matchLength_.
          1. If _nextSourcePosition_ ≥ _lengthS_, return _accumulatedResult_.
          1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ from _nextSourcePosition_.
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.replace]"*.</p>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@search" id="sec-regexp.prototype-%symbol.search%">
        <h1>RegExp.prototype [ %Symbol.search% ] ( _string_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _previousLastIndex_ be ? Get(_rx_, *"lastIndex"*).
          1. If _previousLastIndex_ is not *+0*<sub>𝔽</sub>, then
            1. Perform ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
          1. Let _result_ be ? RegExpExec(_rx_, _S_).
          1. Let _currentLastIndex_ be ? Get(_rx_, *"lastIndex"*).
          1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then
            1. Perform ? Set(_rx_, *"lastIndex"*, _previousLastIndex_, *true*).
          1. If _result_ is *null*, return *-1*<sub>𝔽</sub>.
          1. Return ? Get(_result_, *"index"*).
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.search]"*.</p>
        <emu-note>
          <p>The *"lastIndex"* and *"global"* properties of this RegExp object are ignored when performing the search. The *"lastIndex"* property is left unchanged.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.source">
        <h1>get RegExp.prototype.source</h1>
        <p>`RegExp.prototype.source` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalSource]] internal slot, then
            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *"(?:)"*.
            1. Otherwise, throw a *TypeError* exception.
          1. Assert: _R_ has an [[OriginalFlags]] internal slot.
          1. Let _src_ be _R_.[[OriginalSource]].
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. Return EscapeRegExpPattern(_src_, _flags_).
        </emu-alg>

        <emu-clause id="sec-escaperegexppattern" type="abstract operation">
          <h1>
            EscapeRegExpPattern (
              _P_: a String,
              _F_: a String,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _F_ contains *"v"*, then
              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, +UnicodeSetsMode]|.
            1. Else if _F_ contains *"u"*, then
              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.
            1. Else,
              1. Let _patternSymbol_ be |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.
            1. Let _S_ be a String in the form of a _patternSymbol_ equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not differ from _P_; however, the Abstract Closure that would result from evaluating _S_ as a _patternSymbol_ must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.
            1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *"/"*, _S_, *"/"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *"/"*, then _S_ could be *"\\/"* or *"\\u002F"*, among other possibilities, but not *"/"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *"(?:)"*.
            1. Return _S_.
          </emu-alg>

          <emu-note>
            <p>Despite having similar names, `RegExp.escape` and EscapeRegExpPattern do not perform similar actions. The former escapes a string for representation inside a pattern, while this function escapes a pattern for representation as a string.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@split" id="sec-regexp.prototype-%symbol.split%">
        <h1>RegExp.prototype [ %Symbol.split% ] ( _string_, _limit_ )</h1>
        <emu-note>
          <p>This method returns an Array into which substrings of the result of converting _string_ to a String have been stored. The substrings are determined by searching from left to right for matches of the *this* value regular expression; these occurrences are not part of any String in the returned array, but serve to divide up the String value.</p>
          <p>The *this* value may be an empty regular expression or a regular expression that can match an empty String. In this case, the regular expression does not match the empty <emu-not-ref>substring</emu-not-ref> at the beginning or end of the input String, nor does it match the empty <emu-not-ref>substring</emu-not-ref> at the end of the previous separator match. (For example, if the regular expression matches the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each <emu-not-ref>substring</emu-not-ref> contains one code unit.) Only the first match at a given index of the String is considered, even if backtracking could yield a non-empty <emu-not-ref>substring</emu-not-ref> match at that index. (For example, `/a*?/[Symbol.split]("ab")` evaluates to the array `["a", "b"]`, while `/a*/[Symbol.split]("ab")` evaluates to the array `["","b"]`.)</p>
          <p>If _string_ is (or converts to) the empty String, the result depends on whether the regular expression can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
          <p>If the regular expression contains capturing parentheses, then each time _separator_ is matched the results (including any *undefined* results) of the capturing parentheses are spliced into the output array. For example,</p>
          <pre><code class="javascript">/&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split]("A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;")</code></pre>
          <p>evaluates to the array</p>
          <pre><code class="javascript">["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]</code></pre>
          <p>If _limit_ is not *undefined*, then the output array is truncated so that it contains no more than _limit_ elements.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).
          1. Let _flags_ be ? ToString(? Get(_rx_, *"flags"*)).
          1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _unicodeMatching_ be *true*.
          1. Else, let _unicodeMatching_ be *false*.
          1. If _flags_ contains *"y"*, let _newFlags_ be _flags_.
          1. Else, let _newFlags_ be the string-concatenation of _flags_ and *"y"*.
          1. Let _splitter_ be ? Construct(_C_, « _rx_, _newFlags_ »).
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _lengthA_ be 0.
          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).
          1. If _lim_ = 0, return _A_.
          1. If _S_ is the empty String, then
            1. Let _z_ be ? RegExpExec(_splitter_, _S_).
            1. If _z_ is not *null*, return _A_.
            1. Perform ! CreateDataPropertyOrThrow(_A_, *"0"*, _S_).
            1. Return _A_.
          1. Let _size_ be the length of _S_.
          1. Let _p_ be 0.
          1. Let _q_ be _p_.
          1. Repeat, while _q_ &lt; _size_,
            1. Perform ? Set(_splitter_, *"lastIndex"*, 𝔽(_q_), *true*).
            1. Let _z_ be ? RegExpExec(_splitter_, _S_).
            1. If _z_ is *null*, then
              1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
            1. Else,
              1. Let _e_ be ℝ(? ToLength(? Get(_splitter_, *"lastIndex"*))).
              1. Set _e_ to min(_e_, _size_).
              1. If _e_ = _p_, then
                1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
              1. Else,
                1. Let _T_ be the substring of _S_ from _p_ to _q_.
                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).
                1. Set _lengthA_ to _lengthA_ + 1.
                1. If _lengthA_ = _lim_, return _A_.
                1. Set _p_ to _e_.
                1. Let _numberOfCaptures_ be ? LengthOfArrayLike(_z_).
                1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).
                1. Let _i_ be 1.
                1. Repeat, while _i_ ≤ _numberOfCaptures_,
                  1. Let _nextCapture_ be ? Get(_z_, ! ToString(𝔽(_i_))).
                  1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).
                  1. Set _i_ to _i_ + 1.
                  1. Set _lengthA_ to _lengthA_ + 1.
                  1. If _lengthA_ = _lim_, return _A_.
                1. Set _q_ to _p_.
          1. Let _T_ be the substring of _S_ from _p_ to _size_.
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).
          1. Return _A_.
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.split]"*.</p>
        <emu-note>
          <p>This method ignores the value of the *"global"* and *"sticky"* properties of this RegExp object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.sticky">
        <h1>get RegExp.prototype.sticky</h1>
        <p>`RegExp.prototype.sticky` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0079 (LATIN SMALL LETTER Y).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.test">
        <h1>RegExp.prototype.test ( _S_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _string_ be ? ToString(_S_).
          1. Let _match_ be ? RegExpExec(_R_, _string_).
          1. If _match_ is not *null*, return *true*; else return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.tostring">
        <h1>RegExp.prototype.toString ( )</h1>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _pattern_ be ? ToString(? Get(_R_, *"source"*)).
          1. Let _flags_ be ? ToString(? Get(_R_, *"flags"*)).
          1. Let _result_ be the string-concatenation of *"/"*, _pattern_, *"/"*, and _flags_.
          1. Return _result_.
        </emu-alg>
        <emu-note>
          <p>The returned String has the form of a |RegularExpressionLiteral| that evaluates to another RegExp object with the same behaviour as this object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicode">
        <h1>get RegExp.prototype.unicode</h1>
        <p>`RegExp.prototype.unicode` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0075 (LATIN SMALL LETTER U).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicodesets">
        <h1>get RegExp.prototype.unicodeSets</h1>
        <p>`RegExp.prototype.unicodeSets` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0076 (LATIN SMALL LETTER V).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-matching">
      <h1>Abstract Operations for RegExp Matching</h1>

      <emu-clause id="sec-regexpexec" type="abstract operation">
        <h1>
          RegExpExec (
            _R_: an Object,
            _S_: a String,
          ): either a normal completion containing either an Object or *null*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _exec_ be ? Get(_R_, *"exec"*).
          1. If IsCallable(_exec_) is *true*, then
            1. Let _result_ be ? Call(_exec_, _R_, « _S_ »).
            1. If _result_ is not an Object and _result_ is not *null*, throw a *TypeError* exception.
            1. Return _result_.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Return ? RegExpBuiltinExec(_R_, _S_).
        </emu-alg>
        <emu-note>
          <p>If a callable *"exec"* property is not found this algorithm falls back to attempting to use the built-in RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where most built-in algorithms that use regular expressions did not perform a dynamic property lookup of *"exec"*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-regexpbuiltinexec" type="abstract operation">
        <h1>
          RegExpBuiltinExec (
            _R_: an initialized RegExp instance,
            _S_: a String,
          ): either a normal completion containing either an Array exotic object or *null*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _length_ be the length of _S_.
          1. Let _lastIndex_ be ℝ(? ToLength(! Get(_R_, *"lastIndex"*))).
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains *"g"*, let _global_ be *true*; else let _global_ be *false*.
          1. If _flags_ contains *"y"*, let _sticky_ be *true*; else let _sticky_ be *false*.
          1. If _flags_ contains *"d"*, let _hasIndices_ be *true*; else let _hasIndices_ be *false*.
          1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.
          1. Let _matcher_ be _R_.[[RegExpMatcher]].
          1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*; else let _fullUnicode_ be *false*.
          1. Let _matchSucceeded_ be *false*.
          1. If _fullUnicode_ is *true*, let _input_ be StringToCodePoints(_S_); otherwise let _input_ be a List whose elements are the code units that are the elements of _S_.
          1. NOTE: Each element of _input_ is considered to be a character.
          1. Repeat, while _matchSucceeded_ is *false*,
            1. If _lastIndex_ > _length_, then
              1. If _global_ is *true* or _sticky_ is *true*, then
                1. Perform ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
              1. Return *null*.
            1. Let _inputIndex_ be the index into _input_ of the character that was obtained from element _lastIndex_ of _S_.
            1. Let _r_ be _matcher_(_input_, _inputIndex_).
            1. If _r_ is ~failure~, then
              1. If _sticky_ is *true*, then
                1. Perform ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
                1. Return *null*.
              1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).
            1. Else,
              1. Assert: _r_ is a MatchState.
              1. Set _matchSucceeded_ to *true*.
          1. Let _e_ be _r_.[[EndIndex]].
          1. If _fullUnicode_ is *true*, set _e_ to GetStringIndex(_S_, _e_).
          1. If _global_ is *true* or _sticky_ is *true*, then
            1. Perform ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, 𝔽(_e_), *true*)</emu-meta>.
          1. Let _n_ be the number of elements in _r_.[[Captures]].
          1. Assert: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]].
          1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
          1. Let _A_ be ! ArrayCreate(_n_ + 1).
          1. Assert: The mathematical value of _A_'s *"length"* property is _n_ + 1.
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"index"*, 𝔽(_lastIndex_)).
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"input"*, _S_).
          1. Let _match_ be the Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }.
          1. Let _indices_ be a new empty List.
          1. Let _groupNames_ be a new empty List.
          1. Append _match_ to _indices_.
          1. Let _matchedSubstr_ be GetMatchString(_S_, _match_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"0"*, _matchedSubstr_).
          1. If _R_ contains any |GroupName|, then
            1. Let _groups_ be OrdinaryObjectCreate(*null*).
            1. Let _hasGroups_ be *true*.
          1. Else,
            1. Let _groups_ be *undefined*.
            1. Let _hasGroups_ be *false*.
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_).
          1. Let _matchedGroupNames_ be a new empty List.
          1. For each integer _i_ such that 1 ≤ _i_ ≤ _n_, in ascending order, do
            1. Let _captureI_ be _i_<sup>th</sup> element of _r_.[[Captures]].
            1. If _captureI_ is *undefined*, then
              1. Let _capturedValue_ be *undefined*.
              1. Append *undefined* to _indices_.
            1. Else,
              1. Let _captureStart_ be _captureI_.[[StartIndex]].
              1. Let _captureEnd_ be _captureI_.[[EndIndex]].
              1. If _fullUnicode_ is *true*, then
                1. Set _captureStart_ to GetStringIndex(_S_, _captureStart_).
                1. Set _captureEnd_ to GetStringIndex(_S_, _captureEnd_).
              1. Let _capture_ be the Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }.
              1. Let _capturedValue_ be GetMatchString(_S_, _capture_).
              1. Append _capture_ to _indices_.
            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).
            1. If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then
              1. Let _s_ be the CapturingGroupName of that |GroupName|.
              1. If _matchedGroupNames_ contains _s_, then
                1. Assert: _capturedValue_ is *undefined*.
                1. Append *undefined* to _groupNames_.
              1. Else,
                1. If _capturedValue_ is not *undefined*, append _s_ to _matchedGroupNames_.
                1. NOTE: If there are multiple groups named _s_, _groups_ may already have an _s_ property at this point. However, because _groups_ is an ordinary object whose properties are all writable data properties, the call to CreateDataPropertyOrThrow is nevertheless guaranteed to succeed.
                1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).
                1. Append _s_ to _groupNames_.
            1. Else,
              1. Append *undefined* to _groupNames_.
          1. If _hasIndices_ is *true*, then
            1. Let _indicesArray_ be MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, *"indices"*, _indicesArray_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-advancestringindex" type="abstract operation">
        <h1>
          AdvanceStringIndex (
            _S_: a String,
            _index_: a non-negative integer,
            _unicode_: a Boolean,
          ): an integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _index_ ≤ 2<sup>53</sup> - 1.
          1. If _unicode_ is *false*, return _index_ + 1.
          1. Let _length_ be the length of _S_.
          1. If _index_ + 1 ≥ _length_, return _index_ + 1.
          1. Let _cp_ be CodePointAt(_S_, _index_).
          1. Return _index_ + _cp_.[[CodeUnitCount]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getstringindex" type="abstract operation">
        <h1>
          GetStringIndex (
            _S_: a String,
            _codePointIndex_: a non-negative integer,
          ): a non-negative integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It interprets _S_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, and returns the code unit index corresponding to code point index _codePointIndex_ when such an index exists. Otherwise, it returns the length of _S_.</dd>
        </dl>
        <emu-alg>
          1. If _S_ is the empty String, return 0.
          1. Let _len_ be the length of _S_.
          1. Let _codeUnitCount_ be 0.
          1. Let _codePointCount_ be 0.
          1. Repeat, while _codeUnitCount_ &lt; _len_,
            1. If _codePointCount_ = _codePointIndex_, return _codeUnitCount_.
            1. Let _cp_ be CodePointAt(_S_, _codeUnitCount_).
            1. Set _codeUnitCount_ to _codeUnitCount_ + _cp_.[[CodeUnitCount]].
            1. Set _codePointCount_ to _codePointCount_ + 1.
          1. Return _len_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-match-records">
        <h1>Match Records</h1>
        <p>A <dfn variants="Match Records">Match Record</dfn> is a Record value used to encapsulate the start and end indices of a regular expression match or capture.</p>
        <p>Match Records have the fields listed in <emu-xref href="#table-match-record"></emu-xref>.</p>
        <emu-table id="table-match-record" caption="Match Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[StartIndex]]</td>
              <td>a non-negative integer</td>
              <td>The number of code units from the start of a string at which the match begins (inclusive).</td>
            </tr>
            <tr>
              <td>[[EndIndex]]</td>
              <td>an integer ≥ [[StartIndex]]</td>
              <td>The number of code units from the start of a string at which the match ends (exclusive).</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getmatchstring" type="abstract operation">
        <h1>
          GetMatchString (
            _S_: a String,
            _match_: a Match Record,
          ): a String
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.
          1. Return the substring of _S_ from _match_.[[StartIndex]] to _match_.[[EndIndex]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmatchindexpair" type="abstract operation">
        <h1>
          GetMatchIndexPair (
            _S_: a String,
            _match_: a Match Record,
          ): an Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.
          1. Return CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makematchindicesindexpairarray" type="abstract operation">
        <h1>
          MakeMatchIndicesIndexPairArray (
            _S_: a String,
            _indices_: a List of either Match Records or *undefined*,
            _groupNames_: a List of either Strings or *undefined*,
            _hasGroups_: a Boolean,
          ): an Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _n_ be the number of elements in _indices_.
          1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
          1. Assert: _groupNames_ has _n_ - 1 elements.
          1. NOTE: The _groupNames_ List contains elements aligned with the _indices_ List starting at _indices_[1].
          1. Let _A_ be ! ArrayCreate(_n_).
          1. If _hasGroups_ is *true*, then
            1. Let _groups_ be OrdinaryObjectCreate(*null*).
          1. Else,
            1. Let _groups_ be *undefined*.
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_).
          1. For each integer _i_ such that 0 ≤ _i_ &lt; _n_, in ascending order, do
            1. Let _matchIndices_ be _indices_[_i_].
            1. If _matchIndices_ is not *undefined*, then
              1. Let _matchIndexPair_ be GetMatchIndexPair(_S_, _matchIndices_).
            1. Else,
              1. Let _matchIndexPair_ be *undefined*.
            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_).
            1. If _i_ > 0, then
              1. Let _s_ be _groupNames_[_i_ - 1].
              1. If _s_ is not *undefined*, then
                1. Assert: _groups_ is not *undefined*.
                1. NOTE: If there are multiple groups named _s_, _groups_ may already have an _s_ property at this point. However, because _groups_ is an ordinary object whose properties are all writable data properties, the call to CreateDataPropertyOrThrow is nevertheless guaranteed to succeed.
                1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _matchIndexPair_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-regexp-instances">
      <h1>Properties of RegExp Instances</h1>
      <p>RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp instances have internal slots [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], and [[RegExpMatcher]]. The value of the [[RegExpMatcher]] internal slot is an Abstract Closure representation of the |Pattern| of the RegExp object.</p>
      <emu-note>
        <p>Prior to ECMAScript 2015, RegExp instances were specified as having the own data properties *"source"*, *"global"*, *"ignoreCase"*, and *"multiline"*. Those properties are now specified as accessor properties of `RegExp.prototype`.</p>
      </emu-note>
      <p>RegExp instances also have the following property:</p>

      <emu-clause id="sec-lastindex">
        <h1>lastIndex</h1>
        <p>The value of the *"lastIndex"* property specifies the String index at which to start the next match. It is coerced to an integral Number when used (see <emu-xref href="#sec-regexpbuiltinexec"></emu-xref>). This property shall have the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-string-iterator-objects">
      <h1>RegExp String Iterator Objects</h1>
      <p>A <dfn variants="RegExp String Iterators,RegExp String Iterator object,RegExp String Iterator objects">RegExp String Iterator</dfn> is an object that represents a specific iteration over some specific String instance object, matching against some specific RegExp instance object. There is not a named constructor for RegExp String Iterator objects. Instead, RegExp String Iterator objects are created by calling certain methods of RegExp instance objects.</p>

      <emu-clause id="sec-createregexpstringiterator" type="abstract operation">
        <h1>
          CreateRegExpStringIterator (
            _R_: an Object,
            _S_: a String,
            _global_: a Boolean,
            _fullUnicode_: a Boolean,
          ): an Object
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _iterator_ be OrdinaryObjectCreate(%RegExpStringIteratorPrototype%, « [[IteratingRegExp]], [[IteratedString]], [[Global]], [[Unicode]], [[Done]] »).
          1. Set _iterator_.[[IteratingRegExp]] to _R_.
          1. Set _iterator_.[[IteratedString]] to _S_.
          1. Set _iterator_.[[Global]] to _global_.
          1. Set _iterator_.[[Unicode]] to _fullUnicode_.
          1. Set _iterator_.[[Done]] to *false*.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%regexpstringiteratorprototype%-object">
        <h1>The %RegExpStringIteratorPrototype% Object</h1>
        <p>The <dfn>%RegExpStringIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all RegExp String Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%regexpstringiteratorprototype%.next">
          <h1>%RegExpStringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If _O_ is not an Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a RegExp String Iterator Object Instance (see <emu-xref href="#sec-properties-of-regexp-string-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. If _O_.[[Done]] is *true*, then
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. Let _R_ be _O_.[[IteratingRegExp]].
            1. Let _S_ be _O_.[[IteratedString]].
            1. Let _global_ be _O_.[[Global]].
            1. Let _fullUnicode_ be _O_.[[Unicode]].
            1. Let _match_ be ? RegExpExec(_R_, _S_).
            1. If _match_ is *null*, then
              1. Set _O_.[[Done]] to *true*.
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. If _global_ is *false*, then
              1. Set _O_.[[Done]] to *true*.
              1. Return CreateIteratorResultObject(_match_, *false*).
            1. Let _matchStr_ be ? ToString(? Get(_match_, *"0"*)).
            1. If _matchStr_ is the empty String, then
              1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *"lastIndex"*))).
              1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
              1. Perform ? Set(_R_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
            1. Return CreateIteratorResultObject(_match_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%regexpstringiteratorprototype%-@@tostringtag" id="sec-%regexpstringiteratorprototype%-%symbol.tostringtag%">
          <h1>%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"RegExp String Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-regexp-string-iterator-instances">
        <h1>Properties of RegExp String Iterator Instances</h1>
        <p>RegExp String Iterator instances are ordinary objects that inherit properties from the %RegExpStringIteratorPrototype% intrinsic object. RegExp String Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-regexp-string-iterator-instance-slots"></emu-xref>.</p>
        <emu-table id="table-regexp-string-iterator-instance-slots" caption="Internal Slots of RegExp String Iterator Instances">
          <table>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>[[IteratingRegExp]]</td>
              <td>an Object</td>
              <td>The regular expression used for iteration. IsRegExp([[IteratingRegExp]]) is initially *true*.</td>
            </tr>
            <tr>
              <td>[[IteratedString]]</td>
              <td>a String</td>
              <td>The String value being iterated upon.</td>
            </tr>
            <tr>
              <td>[[Global]]</td>
              <td>a Boolean</td>
              <td>Indicates whether the [[IteratingRegExp]] is global or not.</td>
            </tr>
            <tr>
              <td>[[Unicode]]</td>
              <td>a Boolean</td>
              <td>Indicates whether the [[IteratingRegExp]] is in Unicode mode or not.</td>
            </tr>
            <tr>
              <td>[[Done]]</td>
              <td>a Boolean</td>
              <td>Indicates whether the iteration is complete or not.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>Indexed Collections</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array Objects</h1>
    <p>Arrays are exotic objects that give special treatment to a certain class of property names. See <emu-xref href="#sec-array-exotic-objects"></emu-xref> for a definition of this special treatment.</p>

    <emu-clause id="sec-array-constructor">
      <h1>The Array Constructor</h1>
      <p>The Array constructor:</p>
      <ul>
        <li>is <dfn>%Array%</dfn>.</li>
        <li>is the initial value of the *"Array"* property of the global object.</li>
        <li>creates and initializes a new Array when called as a constructor.</li>
        <li>also creates and initializes a new Array when called as a function rather than as a constructor. Thus the function call `Array(…)` is equivalent to the object creation expression `new Array(…)` with the same arguments.</li>
        <li>is a function whose behaviour differs based upon the number and types of its arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the exotic Array behaviour must include a `super` call to the Array constructor to initialize subclass instances that are Array exotic objects. However, most of the `Array.prototype` methods are generic methods that are not dependent upon their *this* value being an Array exotic object.</li>
      </ul>

      <emu-clause id="sec-array" oldids="sec-array-constructor-array,sec-array-len,sec-array-items">
        <h1>Array ( ..._values_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, *"%Array.prototype%"*).
          1. Let _numberOfArgs_ be the number of elements in _values_.
          1. If _numberOfArgs_ = 0, then
            1. Return ! ArrayCreate(0, _proto_).
          1. Else if _numberOfArgs_ = 1, then
            1. Let _len_ be _values_[0].
            1. Let _array_ be ! ArrayCreate(0, _proto_).
            1. If _len_ is not a Number, then
              1. Perform ! CreateDataPropertyOrThrow(_array_, *"0"*, _len_).
              1. Let _intLen_ be *1*<sub>𝔽</sub>.
            1. Else,
              1. Let _intLen_ be ! ToUint32(_len_).
              1. If SameValueZero(_intLen_, _len_) is *false*, throw a *RangeError* exception.
            1. Perform ! Set(_array_, *"length"*, _intLen_, *true*).
            1. Return _array_.
          1. Else,
            1. Assert: _numberOfArgs_ ≥ 2.
            1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _numberOfArgs_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _itemK_ be _values_[_k_].
              1. Perform ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_).
              1. Set _k_ to _k_ + 1.
            1. Assert: The mathematical value of _array_'s *"length"* property is _numberOfArgs_.
            1. Return _array_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Properties of the Array Constructor</h1>
      <p>The Array constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-array.from">
        <h1>Array.from ( _items_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _mapper_ is *undefined*, then
            1. Let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Let _usingIterator_ be ? GetMethod(_items_, %Symbol.iterator%).
          1. If _usingIterator_ is not *undefined*, then
            1. If IsConstructor(_C_) is *true*, then
              1. Let _A_ be ? Construct(_C_).
            1. Else,
              1. Let _A_ be ! ArrayCreate(0).
            1. Let _iteratorRecord_ be ? GetIteratorFromMethod(_items_, _usingIterator_).
            1. Let _k_ be 0.
            1. Repeat,
              1. If _k_ ≥ 2<sup>53</sup> - 1, then
                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _error_).
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Perform ? Set(_A_, *"length"*, 𝔽(_k_), *true*).
                1. Return _A_.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be Completion(Call(_mapper_, _thisArg_, « _next_, 𝔽(_k_) »)).
                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_).
              1. Else,
                1. Let _mappedValue_ be _next_.
              1. Let _defineStatus_ be Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)).
              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_).
              1. Set _k_ to _k_ + 1.
          1. NOTE: _items_ is not iterable so assume it is an array-like object.
          1. Let _arrayLike_ be ! ToObject(_items_).
          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_, « 𝔽(_len_) »).
          1. Else,
            1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
            1. Else,
              1. Let _mappedValue_ be _kValue_.
            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. Set _k_ to _k_ + 1.
          1. Perform ? Set(_A_, *"length"*, 𝔽(_len_), *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is an intentionally generic factory method; it does not require that its *this* value be the Array constructor. Therefore it can be transferred to or inherited by any other constructors that may be called with a single numeric argument.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.isarray">
        <h1>Array.isArray ( _arg_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return ? IsArray(_arg_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.of">
        <h1>Array.of ( ..._items_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _len_ be the number of elements in _items_.
          1. Let _lenNumber_ be 𝔽(_len_).
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_, « _lenNumber_ »).
          1. Else,
            1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _items_[_k_].
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).
            1. Set _k_ to _k_ + 1.
          1. Perform ? Set(_A_, *"length"*, _lenNumber_, *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is an intentionally generic factory method; it does not require that its *this* value be the Array constructor. Therefore it can be transferred to or inherited by other constructors that may be called with a single numeric argument.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype">
        <h1>Array.prototype</h1>
        <p>The value of `Array.prototype` is the Array prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-array-@@species" id="sec-get-array-%symbol.species%">
        <h1>get Array [ %Symbol.species% ]</h1>
        <p>`Array[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Array prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-prototype-object">
      <h1>Properties of the Array Prototype Object</h1>
      <p>The <dfn>Array prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Array.prototype%</dfn>.</li>
        <li>is an Array exotic object and has the internal methods specified for such objects.</li>
        <li>has a *"length"* property whose initial value is *+0*<sub>𝔽</sub> and whose attributes are { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <emu-note>
        <p>The Array prototype object is specified to be an Array exotic object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p>
      </emu-note>

      <emu-clause id="sec-array.prototype.at">
        <h1>Array.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ ≥ _len_, return *undefined*.
          1. Return ? Get(_O_, ! ToString(𝔽(_k_))).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.concat">
        <h1>Array.prototype.concat ( ..._items_ )</h1>
        <p>This method returns an array containing the array elements of the object followed by the array elements of each argument.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Let _n_ be 0.
          1. Prepend _O_ to _items_.
          1. For each element _E_ of _items_, do
            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).
            1. If _spreadable_ is *true*, then
              1. Let _len_ be ? LengthOfArrayLike(_E_).
              1. If _n_ + _len_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Let _k_ be 0.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _Pk_ be ! ToString(𝔽(_k_)).
                1. Let _exists_ be ? HasProperty(_E_, _Pk_).
                1. If _exists_ is *true*, then
                  1. Let _subElement_ be ? Get(_E_, _Pk_).
                  1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_).
                1. Set _n_ to _n_ + 1.
                1. Set _k_ to _k_ + 1.
            1. Else,
              1. NOTE: _E_ is added as a single item rather than spread.
              1. If _n_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_).
              1. Set _n_ to _n_ + 1.
          1. [id="step-array-proto-concat-set-length"] Perform ? Set(_A_, *"length"*, 𝔽(_n_), *true*).
          1. Return _A_.
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>The explicit setting of the *"length"* property in step <emu-xref href="#step-array-proto-concat-set-length"></emu-xref> is intended to ensure the length is correct when the final non-empty element of _items_ has trailing holes or when _A_ is not a built-in Array.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-isconcatspreadable" type="abstract operation">
          <h1>
            IsConcatSpreadable (
              _O_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _O_ is not an Object, return *false*.
            1. Let _spreadable_ be ? Get(_O_, %Symbol.isConcatSpreadable%).
            1. If _spreadable_ is not *undefined*, return ToBoolean(_spreadable_).
            1. Return ? IsArray(_O_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.constructor">
        <h1>Array.prototype.constructor</h1>
        <p>The initial value of `Array.prototype.constructor` is %Array%.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.copywithin">
        <h1>Array.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <emu-note>
          <p>The _end_ argument is optional. If it is not provided, the length of the *this* value is used.</p>
        </emu-note>
        <emu-note>
          <p>If _target_ is negative, it is treated as <emu-eqn>_length_ + _target_</emu-eqn> where _length_ is the length of the array. If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn>. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
          1. If _relativeTarget_ = -∞, let _to_ be 0.
          1. Else if _relativeTarget_ &lt; 0, let _to_ be max(_len_ + _relativeTarget_, 0).
          1. Else, let _to_ be min(_relativeTarget_, _len_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _from_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _from_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _from_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).
          1. If _from_ &lt; _to_ and _to_ &lt; _from_ + _count_, then
            1. Let _direction_ be -1.
            1. Set _from_ to _from_ + _count_ - 1.
            1. Set _to_ to _to_ + _count_ - 1.
          1. Else,
            1. Let _direction_ be 1.
          1. Repeat, while _count_ > 0,
            1. Let _fromKey_ be ! ToString(𝔽(_from_)).
            1. Let _toKey_ be ! ToString(𝔽(_to_)).
            1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _fromKey_).
              1. Perform ? Set(_O_, _toKey_, _fromValue_, *true*).
            1. Else,
              1. Assert: _fromPresent_ is *false*.
              1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).
            1. Set _from_ to _from_ + _direction_.
            1. Set _to_ to _to_ + _direction_.
            1. Set _count_ to _count_ - 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.entries">
        <h1>Array.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.every">
        <h1>Array.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `every` calls _callback_ once for each element present in the array, in ascending order, until it finds one where _callback_ returns *false*. If such an element is found, `every` immediately returns *false*. Otherwise, `every` returns *true*. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`every` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `every` is set before the first call to _callback_. Elements which are appended to the array after the call to `every` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `every` visits them; elements that are deleted after the call to `every` begins and before being visited are not visited. `every` acts like the "for all" quantifier in mathematics. In particular, for an empty array, it returns *true*.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. If _testResult_ is *false*, return *false*.
            1. Set _k_ to _k_ + 1.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.fill">
        <h1>Array.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <emu-note>
          <p>The _start_ argument is optional. If it is not provided, *+0*<sub>𝔽</sub> is used.</p>
          <p>The _end_ argument is optional. If it is not provided, the length of the *this* value is used.</p>
        </emu-note>
        <emu-note>
          <p>If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the array. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _k_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _k_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Repeat, while _k_ &lt; _final_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ? Set(_O_, _Pk_, _value_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.filter">
        <h1>Array.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `filter` calls _callback_ once for each element in the array, in ascending order, and constructs a new array of all the values for which _callback_ returns *true*. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`filter` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `filter` is set before the first call to _callback_. Elements which are appended to the array after the call to `filter` begins will not be visited by _callback_. If existing elements of the array are changed their value as passed to _callback_ will be the value at the time `filter` visits them; elements that are deleted after the call to `filter` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Let _k_ be 0.
          1. Let _to_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _selected_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. If _selected_ is *true*, then
                1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_).
                1. Set _to_ to _to_ + 1.
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.find">
        <h1>Array.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in ascending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `find` immediately returns that element value. Otherwise, `find` returns *undefined*.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findindex">
        <h1>Array.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in ascending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `findIndex` immediately returns the index of that element value. Otherwise, `findIndex` returns -1.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlast">
        <h1>Array.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in descending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `findLast` immediately returns that element value. Otherwise, `findLast` returns *undefined*.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlastindex">
        <h1>Array.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in descending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `findLastIndex` immediately returns the index of that element value. Otherwise, `findLastIndex` returns -1.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-findviapredicate" type="abstract operation">
          <h1>
            FindViaPredicate (
              _O_: an Object,
              _len_: a non-negative integer,
              _direction_: ~ascending~ or ~descending~,
              _predicate_: an ECMAScript language value,
              _thisArg_: an ECMAScript language value,
            ): either a normal completion containing a Record with fields [[Index]] (an integral Number) and [[Value]] (an ECMAScript language value) or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              <p>_O_ should be an array-like object or a TypedArray. This operation calls _predicate_ once for each element of _O_, in either ascending index order or descending index order (as indicated by _direction_), until it finds one where _predicate_ returns a value that coerces to *true*. At that point, this operation returns a Record that gives the index and value of the element found. If no such element is found, this operation returns a Record that specifies *-1*<sub>𝔽</sub> for the index and *undefined* for the value.</p>
              <p>_predicate_ should be a function. When called for an element of the array, it is passed three arguments: the value of the element, the index of the element, and the object being traversed. Its return value will be coerced to a Boolean value.</p>
              <p>_thisArg_ will be used as the *this* value for each invocation of _predicate_.</p>
              <p>This operation does not directly mutate the object on which it is called, but the object may be mutated by the calls to _predicate_.</p>
              <p>The range of elements processed is set before the first call to _predicate_, just before the traversal begins. Elements that are appended to the array after this will not be visited by _predicate_. If existing elements of the array are changed, their value as passed to _predicate_ will be the value at the time that this operation visits them. Elements that are deleted after traversal begins and before being visited are still visited and are either looked up from the prototype or are *undefined*.</p>
            </dd>
          </dl>
          <emu-alg>
            1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
            1. If _direction_ is ~ascending~, then
              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in ascending order.
            1. Else,
              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in descending order.
            1. For each integer _k_ of _indices_, do
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. NOTE: If _O_ is a TypedArray, the following invocation of Get will return a normal completion.
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
              1. If ToBoolean(_testResult_) is *true*, return the Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ }.
            1. Return the Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flat">
        <h1>Array.prototype.flat ( [ _depth_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).
          1. Let _depthNum_ be 1.
          1. If _depth_ is not *undefined*, then
            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).
            1. If _depthNum_ &lt; 0, set _depthNum_ to 0.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).
          1. Return _A_.
        </emu-alg>

        <emu-clause id="sec-flattenintoarray" type="abstract operation">
          <h1>
            FlattenIntoArray (
              _target_: an Object,
              _source_: an Object,
              _sourceLen_: a non-negative integer,
              _start_: a non-negative integer,
              _depth_: a non-negative integer or +&infin;,
              optional _mapperFunction_: a function object,
              optional _thisArg_: an ECMAScript language value,
            ): either a normal completion containing a non-negative integer or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.
            1. Let _targetIndex_ be _start_.
            1. Let _sourceIndex_ be *+0*<sub>𝔽</sub>.
            1. Repeat, while ℝ(_sourceIndex_) &lt; _sourceLen_,
              1. Let _P_ be ! ToString(_sourceIndex_).
              1. Let _exists_ be ? HasProperty(_source_, _P_).
              1. If _exists_ is *true*, then
                1. Let _element_ be ? Get(_source_, _P_).
                1. If _mapperFunction_ is present, then
                  1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).
                1. Let _shouldFlatten_ be *false*.
                1. If _depth_ > 0, then
                  1. Set _shouldFlatten_ to ? IsArray(_element_).
                1. If _shouldFlatten_ is *true*, then
                  1. If _depth_ = +∞, let _newDepth_ be +∞.
                  1. Else, let _newDepth_ be _depth_ - 1.
                  1. Let _elementLen_ be ? LengthOfArrayLike(_element_).
                  1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).
                1. Else,
                  1. If _targetIndex_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.
                  1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_).
                  1. Set _targetIndex_ to _targetIndex_ + 1.
              1. Set _sourceIndex_ to _sourceIndex_ + *1*<sub>𝔽</sub>.
            1. Return _targetIndex_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flatmap">
        <h1>Array.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.foreach">
        <h1>Array.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `forEach` calls _callback_ once for each element present in the array, in ascending order. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `forEach` is set before the first call to _callback_. Elements which are appended to the array after the call to `forEach` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `forEach` visits them; elements that are deleted after the call to `forEach` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.includes">
        <h1>Array.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>This method compares _searchElement_ to the elements of the array, in ascending order, using the SameValueZero algorithm, and if found at any position, returns *true*; otherwise, it returns *false*.</p>
          <p>The optional second argument _fromIndex_ defaults to *+0*<sub>𝔽</sub> (i.e. the whole array is searched). If it is greater than or equal to the length of the array, *false* is returned, i.e. the array will not be searched. If it is less than *-0*<sub>𝔽</sub>, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than or equal to *+0*<sub>𝔽</sub>, the whole array will be searched.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, return *false*.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *false*.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).
            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
        <emu-note>
          <p>This method intentionally differs from the similar `indexOf` method in two ways. First, it uses the SameValueZero algorithm, instead of IsStrictlyEqual, allowing it to detect *NaN* array elements. Second, it does not skip missing array elements, instead treating them as *undefined*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.indexof">
        <h1>Array.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>This method compares _searchElement_ to the elements of the array, in ascending order, using the IsStrictlyEqual algorithm, and if found at one or more indices, returns the smallest such index; otherwise, it returns *-1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>The optional second argument _fromIndex_ defaults to *+0*<sub>𝔽</sub> (i.e. the whole array is searched). If it is greater than or equal to the length of the array, *-1*<sub>𝔽</sub> is returned, i.e. the array will not be searched. If it is less than *-0*<sub>𝔽</sub>, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than or equal to *+0*<sub>𝔽</sub>, the whole array will be searched.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ? Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ + 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.join">
        <h1>Array.prototype.join ( _separator_ )</h1>
        <p>This method converts the elements of the array to Strings, and then concatenates these Strings, separated by occurrences of the _separator_. If no separator is provided, a single comma is used as the separator.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _separator_ is *undefined*, let _sep_ be *","*.
          1. Else, let _sep_ be ? ToString(_separator_).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.
            1. Let _element_ be ? Get(_O_, ! ToString(𝔽(_k_))).
            1. If _element_ is neither *undefined* nor *null*, then
              1. Let _S_ be ? ToString(_element_).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.keys">
        <h1>Array.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.lastindexof">
        <h1>Array.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>This method compares _searchElement_ to the elements of the array in descending order using the IsStrictlyEqual algorithm, and if found at one or more indices, returns the largest such index; otherwise, it returns *-1*<sub>𝔽</sub>.</p>
          <p>The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than *-0*<sub>𝔽</sub>, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than or equal to *+0*<sub>𝔽</sub>, *-1*<sub>𝔽</sub> is returned.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.
          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.
          1. If _n_ ≥ 0, then
            1. Let _k_ be min(_n_, _len_ - 1).
          1. Else,
            1. Let _k_ be _len_ + _n_.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ? Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ - 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.map">
        <h1>Array.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `map` calls _callback_ once for each element in the array, in ascending order, and constructs a new Array from the results. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`map` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `map` is set before the first call to _callback_. Elements which are appended to the array after the call to `map` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `map` visits them; elements that are deleted after the call to `map` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _mappedValue_ be ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
              1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.pop">
        <h1>Array.prototype.pop ( )</h1>
        <emu-note>
          <p>This method removes the last element of the array and returns it.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, then
            1. Perform ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*).
            1. Return *undefined*.
          1. Else,
            1. Assert: _len_ > 0.
            1. Let _newLen_ be 𝔽(_len_ - 1).
            1. Let _index_ be ! ToString(_newLen_).
            1. Let _element_ be ? Get(_O_, _index_).
            1. Perform ? DeletePropertyOrThrow(_O_, _index_).
            1. Perform ? Set(_O_, *"length"*, _newLen_, *true*).
            1. Return _element_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.push">
        <h1>Array.prototype.push ( ..._items_ )</h1>
        <emu-note>
          <p>This method appends the arguments to the end of the array, in the order in which they appear. It returns the new length of the array.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _argCount_ be the number of elements in _items_.
          1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. For each element _E_ of _items_, do
            1. Perform ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*).
            1. Set _len_ to _len_ + 1.
          1. Perform ? Set(_O_, *"length"*, 𝔽(_len_), *true*).
          1. Return 𝔽(_len_).
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduce">
        <h1>Array.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that takes four arguments. `reduce` calls the callback, as a function, once for each element after the first element present in the array, in ascending order.</p>
          <p>_callback_ is called with four arguments: the _previousValue_ (value from the previous call to _callback_), the _currentValue_ (value of the current element), the _currentIndex_, and the object being traversed. The first time that callback is called, the _previousValue_ and _currentValue_ can be one of two values. If an _initialValue_ was supplied in the call to `reduce`, then _previousValue_ will be _initialValue_ and _currentValue_ will be the first value in the array. If no _initialValue_ was supplied, then _previousValue_ will be the first value in the array and _currentValue_ will be the second. It is a *TypeError* if the array contains no elements and _initialValue_ is not provided.</p>
          <p>`reduce` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `reduce` is set before the first call to _callback_. Elements that are appended to the array after the call to `reduce` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `reduce` visits them; elements that are deleted after the call to `reduce` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _kPresent_ be *false*.
            1. Repeat, while _kPresent_ is *false* and _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).
              1. If _kPresent_ is *true*, then
                1. Set _accumulator_ to ? Get(_O_, _Pk_).
              1. Set _k_ to _k_ + 1.
            1. If _kPresent_ is *false*, throw a *TypeError* exception.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return _accumulator_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduceright">
        <h1>Array.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that takes four arguments. `reduceRight` calls the callback, as a function, once for each element after the first element present in the array, in descending order.</p>
          <p>_callback_ is called with four arguments: the _previousValue_ (value from the previous call to _callback_), the _currentValue_ (value of the current element), the _currentIndex_, and the object being traversed. The first time the function is called, the _previousValue_ and _currentValue_ can be one of two values. If an _initialValue_ was supplied in the call to `reduceRight`, then _previousValue_ will be _initialValue_ and _currentValue_ will be the last value in the array. If no _initialValue_ was supplied, then _previousValue_ will be the last value in the array and _currentValue_ will be the second-to-last value. It is a *TypeError* if the array contains no elements and _initialValue_ is not provided.</p>
          <p>`reduceRight` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `reduceRight` is set before the first call to _callback_. Elements that are appended to the array after the call to `reduceRight` begins will not be visited by _callback_. If existing elements of the array are changed by _callback_, their value as passed to _callback_ will be the value at the time `reduceRight` visits them; elements that are deleted after the call to `reduceRight` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _kPresent_ be *false*.
            1. Repeat, while _kPresent_ is *false* and _k_ ≥ 0,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).
              1. If _kPresent_ is *true*, then
                1. Set _accumulator_ to ? Get(_O_, _Pk_).
              1. Set _k_ to _k_ - 1.
            1. If _kPresent_ is *false*, throw a *TypeError* exception.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ - 1.
          1. Return _accumulator_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reverse">
        <h1>Array.prototype.reverse ( )</h1>
        <emu-note>
          <p>This method rearranges the elements of the array so as to reverse their order. It returns the reversed array.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _middle_ be floor(_len_ / 2).
          1. Let _lower_ be 0.
          1. Repeat, while _lower_ ≠ _middle_,
            1. Let _upper_ be _len_ - _lower_ - 1.
            1. Let _upperP_ be ! ToString(𝔽(_upper_)).
            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).
            1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).
            1. If _lowerExists_ is *true*, then
              1. Let _lowerValue_ be ? Get(_O_, _lowerP_).
            1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).
            1. If _upperExists_ is *true*, then
              1. Let _upperValue_ be ? Get(_O_, _upperP_).
            1. If _lowerExists_ is *true* and _upperExists_ is *true*, then
              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then
              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).
            1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then
              1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).
              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else,
              1. Assert: _lowerExists_ and _upperExists_ are both *false*.
              1. NOTE: No action is required.
            1. Set _lower_ to _lower_ + 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.shift">
        <h1>Array.prototype.shift ( )</h1>
        <p>This method removes the first element of the array and returns it.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, then
            1. Perform ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*).
            1. Return *undefined*.
          1. Let _first_ be ? Get(_O_, *"0"*).
          1. Let _k_ be 1.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _from_ be ! ToString(𝔽(_k_)).
            1. Let _to_ be ! ToString(𝔽(_k_ - 1)).
            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _from_).
              1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
            1. Else,
              1. Assert: _fromPresent_ is *false*.
              1. Perform ? DeletePropertyOrThrow(_O_, _to_).
            1. Set _k_ to _k_ + 1.
          1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).
          1. Perform ? Set(_O_, *"length"*, 𝔽(_len_ - 1), *true*).
          1. Return _first_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.slice">
        <h1>Array.prototype.slice ( _start_, _end_ )</h1>
        <p>This method returns an array containing the elements of the array from element _start_ up to, but not including, element _end_ (or through the end of the array if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the array. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn> where _length_ is the length of the array.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _k_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _k_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be max(_final_ - _k_, 0).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).
          1. Let _n_ be 0.
          1. Repeat, while _k_ &lt; _final_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_).
            1. Set _k_ to _k_ + 1.
            1. Set _n_ to _n_ + 1.
          1. [id="step-array-proto-slice-set-length"] Perform ? Set(_A_, *"length"*, 𝔽(_n_), *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The explicit setting of the *"length"* property in step <emu-xref href="#step-array-proto-slice-set-length"></emu-xref> is intended to ensure the length is correct even when _A_ is not a built-in Array.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.some">
        <h1>Array.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `some` calls _callback_ once for each element present in the array, in ascending order, until it finds one where _callback_ returns *true*. If such an element is found, `some` immediately returns *true*. Otherwise, `some` returns *false*. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`some` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `some` is set before the first call to _callback_. Elements that are appended to the array after the call to `some` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time that `some` visits them; elements that are deleted after the call to `some` begins and before being visited are not visited. `some` acts like the "exists" quantifier in mathematics. In particular, for an empty array, it returns *false*.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. If _testResult_ is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.sort" oldids="sec-sortcompare">
        <h1>Array.prototype.sort ( _comparator_ )</h1>
        <p>This method sorts the elements of this array. If _comparator_ is not *undefined*, it should be a function that accepts two arguments _x_ and _y_ and returns a negative Number if _x_ &lt; _y_, a positive Number if _x_ > _y_, or a zero otherwise.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. [id="step-array-sort-comparefn"] If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be ? ToObject(*this* value).
          1. [id="step-array-sort-len"] Let _len_ be ? LengthOfArrayLike(_obj_).
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareArrayElements(_x_, _y_, _comparator_).
          1. [id="step-array-sortindexedproperties"] Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).
          1. Let _itemCount_ be the number of elements in _sortedList_.
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _itemCount_,
            1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).
            1. Set _j_ to _j_ + 1.
          1. NOTE: The call to SortIndexedProperties in step <emu-xref href="#step-array-sortindexedproperties"></emu-xref> uses ~skip-holes~. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).
            1. Set _j_ to _j_ + 1.
          1. Return _obj_.
        </emu-alg>
        <emu-note>
          <p>Because non-existent property values always compare greater than *undefined* property values, and *undefined* always compares greater than any other value (see CompareArrayElements), *undefined* property values always sort to the end of the result, followed by non-existent property values.</p>
        </emu-note>
        <emu-note>
          <p>Method calls performed by the ToString abstract operations in steps <emu-xref href="#step-sortcompare-tostring-x"></emu-xref> and <emu-xref href="#step-sortcompare-tostring-y"></emu-xref> have the potential to cause _SortCompare_ to not behave as a consistent comparator.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-sortindexedproperties" type="abstract operation">
          <h1>
            SortIndexedProperties (
              _obj_: an Object,
              _len_: a non-negative integer,
              _SortCompare_: an Abstract Closure with two parameters,
              _holes_: ~skip-holes~ or ~read-through-holes~,
            ): either a normal completion containing a List of ECMAScript language values or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _items_ be a new empty List.
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. If _holes_ is ~skip-holes~, then
                1. Let _kRead_ be ? HasProperty(_obj_, _Pk_).
              1. Else,
                1. Assert: _holes_ is ~read-through-holes~.
                1. Let _kRead_ be *true*.
              1. If _kRead_ is *true*, then
                1. Let _kValue_ be ? Get(_obj_, _Pk_).
                1. Append _kValue_ to _items_.
              1. Set _k_ to _k_ + 1.
            1. [id="step-array-sort"] Sort _items_ using an implementation-defined sequence of <emu-meta effects="user-code">calls to _SortCompare_</emu-meta>. If any such call returns an abrupt completion, stop before performing any further calls to _SortCompare_ and return that Completion Record.
            1. Return _items_.
          </emu-alg>
          <p>The <dfn id="sort-order">sort order</dfn> is the ordering of _items_ after completion of step <emu-xref href="#step-array-sort"></emu-xref> of the algorithm above. The sort order is implementation-defined if _SortCompare_ is not a consistent comparator for the elements of _items_. When SortIndexedProperties is invoked by <emu-xref href="#sec-array.prototype.sort">Array.prototype.sort</emu-xref> or <emu-xref href="#sec-array.prototype.tosorted">Array.prototype.toSorted</emu-xref>, the sort order is also implementation-defined if _comparator_ is *undefined*, and all applications of ToString, to any specific value passed as an argument to _SortCompare_, do not produce the same result.</p>
          <p>Unless the sort order is specified to be implementation-defined, it must satisfy all of the following conditions:</p>
          <ul>
            <li>
              There must be some mathematical permutation π of the non-negative integers less than _itemCount_, such that for every non-negative integer _j_ less than _itemCount_, the element <emu-eqn>old[_j_]</emu-eqn> is exactly the same as <emu-eqn>new[π(_j_)]</emu-eqn>.
            </li>
            <li>
              Then for all non-negative integers _j_ and _k_, each less than _itemCount_, if <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) &lt; 0</emu-eqn>, then <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>.
            </li>
            <li>
              And for all non-negative integers _j_ and _k_ such that _j_ &lt; _k_ &lt; _itemCount_, if <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) = 0</emu-eqn>, then <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>; i.e., the sort is stable.
            </li>
          </ul>
          <p>Here the notation <emu-eqn>old[_j_]</emu-eqn> is used to refer to <emu-eqn>_items_[_j_]</emu-eqn> before step <emu-xref href="#step-array-sort"></emu-xref> is executed, and the notation <emu-eqn>new[_j_]</emu-eqn> to refer to <emu-eqn>_items_[_j_]</emu-eqn> after step <emu-xref href="#step-array-sort"></emu-xref> has been executed.</p>
          <p>An abstract closure or function _comparator_ is a <dfn id="consistent-comparator">consistent comparator</dfn> for a set of values _S_ if all of the requirements below are met for all values _a_, _b_, and _c_ (possibly the same value) in the set _S_: The notation <emu-eqn>_a_ &lt;<sub>C</sub> _b_</emu-eqn> means <emu-eqn>ℝ(_comparator_(_a_, _b_)) &lt; 0</emu-eqn>; <emu-eqn>_a_ =<sub>C</sub> _b_</emu-eqn> means <emu-eqn>ℝ(_comparator_(_a_, _b_)) = 0</emu-eqn>; and <emu-eqn>_a_ ><sub>C</sub> _b_</emu-eqn> means <emu-eqn>ℝ(_comparator_(_a_, _b_)) > 0</emu-eqn>.</p>
          <ul>
            <li>
              Calling _comparator_(_a_, _b_) always returns the same value _v_ when given a specific pair of values _a_ and _b_ as its two arguments. Furthermore, _v_ is a Number, and _v_ is not *NaN*. Note that this implies that exactly one of _a_ &lt;<sub>C</sub> _b_, _a_ =<sub>C</sub> _b_, and _a_ ><sub>C</sub> _b_ will be true for a given pair of _a_ and _b_.
            </li>
            <li>
              Calling _comparator_(_a_, _b_) does not modify _obj_ or any object on _obj_'s prototype chain.
            </li>
            <li>
              _a_ =<sub>C</sub> _a_ (reflexivity)
            </li>
            <li>
              If _a_ =<sub>C</sub> _b_, then _b_ =<sub>C</sub> _a_ (symmetry)
            </li>
            <li>
              If _a_ =<sub>C</sub> _b_ and _b_ =<sub>C</sub> _c_, then _a_ =<sub>C</sub> _c_ (transitivity of =<sub>C</sub>)
            </li>
            <li>
              If _a_ &lt;<sub>C</sub> _b_ and _b_ &lt;<sub>C</sub> _c_, then _a_ &lt;<sub>C</sub> _c_ (transitivity of &lt;<sub>C</sub>)
            </li>
            <li>
              If _a_ ><sub>C</sub> _b_ and _b_ ><sub>C</sub> _c_, then _a_ ><sub>C</sub> _c_ (transitivity of ><sub>C</sub>)
            </li>
          </ul>
          <emu-note>
            <p>The above conditions are necessary and sufficient to ensure that _comparator_ divides the set _S_ into equivalence classes and that these equivalence classes are totally ordered.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-comparearrayelements" type="abstract operation">
          <h1>
            CompareArrayElements (
              _x_: an ECMAScript language value,
              _y_: an ECMAScript language value,
              _comparator_: a function object or *undefined*,
            ): either a normal completion containing a Number or an abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _x_ and _y_ are both *undefined*, return *+0*<sub>𝔽</sub>.
            1. If _x_ is *undefined*, return *1*<sub>𝔽</sub>.
            1. If _y_ is *undefined*, return *-1*<sub>𝔽</sub>.
            1. If _comparator_ is not *undefined*, then
              1. Let _v_ be ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »)).
              1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.
              1. Return _v_.
            1. [id="step-sortcompare-tostring-x"] Let _xString_ be ? ToString(_x_).
            1. [id="step-sortcompare-tostring-y"] Let _yString_ be ? ToString(_y_).
            1. Let _xSmaller_ be ! IsLessThan(_xString_, _yString_, *true*).
            1. If _xSmaller_ is *true*, return *-1*<sub>𝔽</sub>.
            1. Let _ySmaller_ be ! IsLessThan(_yString_, _xString_, *true*).
            1. If _ySmaller_ is *true*, return *1*<sub>𝔽</sub>.
            1. Return *+0*<sub>𝔽</sub>.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.splice">
        <h1>Array.prototype.splice ( _start_, _deleteCount_, ..._items_ )</h1>
        <emu-note>
          <p>This method deletes the _deleteCount_ elements of the array starting at integer index _start_ and replaces them with the elements of _items_. It returns an Array containing the deleted elements (if any).</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _actualStart_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _actualStart_ be min(_relativeStart_, _len_).
          1. Let _itemCount_ be the number of elements in _items_.
          1. If _start_ is not present, then
            1. Let _actualDeleteCount_ be 0.
          1. Else if _deleteCount_ is not present, then
            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.
          1. If _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _actualDeleteCount_,
            1. Let _from_ be ! ToString(𝔽(_actualStart_ + _k_)).
            1. If ? HasProperty(_O_, _from_) is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _from_).
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_).
            1. Set _k_ to _k_ + 1.
          1. [id="step-array-proto-splice-set-length"] Perform ? Set(_A_, *"length"*, 𝔽(_actualDeleteCount_), *true*).
          1. If _itemCount_ &lt; _actualDeleteCount_, then
            1. Set _k_ to _actualStart_.
            1. Repeat, while _k_ &lt; (_len_ - _actualDeleteCount_),
              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_)).
              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_)).
              1. If ? HasProperty(_O_, _from_) is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Set _k_ to _k_ + 1.
            1. Set _k_ to _len_.
            1. Repeat, while _k_ > (_len_ - _actualDeleteCount_ + _itemCount_),
              1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).
              1. Set _k_ to _k_ - 1.
          1. Else if _itemCount_ > _actualDeleteCount_, then
            1. Set _k_ to (_len_ - _actualDeleteCount_).
            1. Repeat, while _k_ > _actualStart_,
              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).
              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_ - 1)).
              1. If ? HasProperty(_O_, _from_) is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Set _k_ to _k_ - 1.
          1. Set _k_ to _actualStart_.
          1. For each element _E_ of _items_, do
            1. Perform ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).
            1. Set _k_ to _k_ + 1.
          1. [id="step-array-proto-splice-set-length-2"] Perform ? Set(_O_, *"length"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The explicit setting of the *"length"* property in steps <emu-xref href="#step-array-proto-splice-set-length"></emu-xref> and <emu-xref href="#step-array-proto-splice-set-length-2"></emu-xref> is intended to ensure the lengths are correct even when the objects are not built-in Arrays.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tolocalestring">
        <h1>Array.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.</p>
        <emu-note>
          <p>The first edition of ECMA-402 did not include a replacement specification for this method.</p>
        </emu-note>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _array_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_array_).
          1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *", "*).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _separator_.
            1. Let _element_ be ? Get(_array_, ! ToString(𝔽(_k_))).
            1. If _element_ is neither *undefined* nor *null*, then
              1. Let _S_ be ? ToString(? Invoke(_element_, *"toLocaleString"*)).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>This method converts the elements of the array to Strings using their `toLocaleString` methods, and then concatenates these Strings, separated by occurrences of an implementation-defined locale-sensitive separator String. This method is analogous to `toString` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.toreversed">
        <h1>Array.prototype.toReversed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _fromValue_ be ? Get(_O_, _from_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tosorted">
        <h1>Array.prototype.toSorted ( _comparator_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareArrayElements(_x_, _y_, _comparator_).
          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]).
            1. Set _j_ to _j_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tospliced">
        <h1>Array.prototype.toSpliced ( _start_, _skipCount_, ..._items_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _actualStart_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _actualStart_ be min(_relativeStart_, _len_).
          1. Let _insertCount_ be the number of elements in _items_.
          1. If _start_ is not present, then
            1. Let _actualSkipCount_ be 0.
          1. Else if _skipCount_ is not present, then
            1. Let _actualSkipCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _sc_ be ? ToIntegerOrInfinity(_skipCount_).
            1. Let _actualSkipCount_ be the result of clamping _sc_ between 0 and _len_ - _actualStart_.
          1. Let _newLen_ be _len_ + _insertCount_ - _actualSkipCount_.
          1. If _newLen_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _A_ be ? ArrayCreate(_newLen_).
          1. Let _i_ be 0.
          1. Let _r_ be _actualStart_ + _actualSkipCount_.
          1. Repeat, while _i_ &lt; _actualStart_,
            1. Let _Pi_ be ! ToString(𝔽(_i_)).
            1. Let _iValue_ be ? Get(_O_, _Pi_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_).
            1. Set _i_ to _i_ + 1.
          1. For each element _E_ of _items_, do
            1. Let _Pi_ be ! ToString(𝔽(_i_)).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_).
            1. Set _i_ to _i_ + 1.
          1. Repeat, while _i_ &lt; _newLen_,
            1. Let _Pi_ be ! ToString(𝔽(_i_)).
            1. Let _from_ be ! ToString(𝔽(_r_)).
            1. Let _fromValue_ be ? Get(_O_, _from_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_).
            1. Set _i_ to _i_ + 1.
            1. Set _r_ to _r_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tostring">
        <h1>Array.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _array_ be ? ToObject(*this* value).
          1. Let _func_ be ? Get(_array_, *"join"*).
          1. If IsCallable(_func_) is *false*, set _func_ to the intrinsic function %Object.prototype.toString%.
          1. Return ? Call(_func_, _array_).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.unshift">
        <h1>Array.prototype.unshift ( ..._items_ )</h1>
        <p>This method prepends the arguments to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _argCount_ be the number of elements in _items_.
          1. If _argCount_ > 0, then
            1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
            1. Let _k_ be _len_.
            1. Repeat, while _k_ > 0,
              1. Let _from_ be ! ToString(𝔽(_k_ - 1)).
              1. Let _to_ be ! ToString(𝔽(_k_ + _argCount_ - 1)).
              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
              1. If _fromPresent_ is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else,
                1. Assert: _fromPresent_ is *false*.
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Set _k_ to _k_ - 1.
            1. Let _j_ be *+0*<sub>𝔽</sub>.
            1. For each element _E_ of _items_, do
              1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).
              1. Set _j_ to _j_ + *1*<sub>𝔽</sub>.
          1. Perform ? Set(_O_, *"length"*, 𝔽(_len_ + _argCount_), *true*).
          1. Return 𝔽(_len_ + _argCount_).
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.values">
        <h1>Array.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.with">
        <h1>Array.prototype.with ( _index_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.
          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
          1. If _actualIndex_ ≥ _len_ or _actualIndex_ &lt; 0, throw a *RangeError* exception.
          1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. If _k_ = _actualIndex_, let _fromValue_ be _value_.
            1. Else, let _fromValue_ be ? Get(_O_, _Pk_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@iterator" id="sec-array.prototype-%symbol.iterator%">
        <h1>Array.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %Array.prototype.values%, defined in <emu-xref href="#sec-array.prototype.values"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@unscopables" id="sec-array.prototype-%symbol.unscopables%">
        <h1>Array.prototype [ %Symbol.unscopables% ]</h1>
        <p>The initial value of the %Symbol.unscopables% data property is an object created by the following steps:</p>
        <emu-alg>
          1. Let _unscopableList_ be OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"at"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findLast"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findLastIndex"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toReversed"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toSorted"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toSpliced"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*).
          1. Return _unscopableList_.
        </emu-alg>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <emu-note>
          <p>The own property names of this object are property names that were not included as standard properties of `Array.prototype` prior to the ECMAScript 2015 specification. These names are ignored for `with` statement binding purposes in order to preserve the behaviour of existing code that might use one of these names as a binding in an outer scope that is shadowed by a `with` statement whose binding object is an Array.</p>
          <p>The reason that *"with"* is not included in the _unscopableList_ is because it is already a <emu-xref href="#sec-keywords-and-reserved-words">reserved word</emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-array-instances">
      <h1>Properties of Array Instances</h1>
      <p>Array instances are Array exotic objects and have the internal methods specified for such objects. Array instances inherit properties from the Array prototype object.</p>
      <p>Array instances have a *"length"* property, and a set of enumerable properties with array index names.</p>

      <emu-clause id="sec-properties-of-array-instances-length">
        <h1>length</h1>
        <p>The *"length"* property of an Array instance is a data property whose value is always numerically greater than the name of every configurable own property whose name is an array index.</p>
        <p>The *"length"* property initially has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Reducing the value of the *"length"* property has the side-effect of deleting own array elements whose array index is between the old and new length values. However, non-configurable properties can not be deleted. Attempting to set the *"length"* property of an Array to a value that is numerically less than or equal to the largest numeric own property name of an existing non-configurable <emu-xref href="#array-index">array-indexed</emu-xref> property of the array will result in the length being set to a numeric value that is one greater than that non-configurable numeric own property name. See <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-iterator-objects">
      <h1>Array Iterator Objects</h1>
      <p>An <dfn variants="Array Iterators,Array Iterator object,Array Iterator objects">Array Iterator</dfn> is an object that represents a specific iteration over some specific Array instance object. There is not a named constructor for Array Iterator objects. Instead, Array Iterator objects are created by calling certain methods of Array instance objects.</p>

      <emu-clause id="sec-createarrayiterator" type="abstract operation">
        <h1>
          CreateArrayIterator (
            _array_: an Object,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): an Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create iterator objects for Array methods that return such iterators.</dd>
        </dl>
        <emu-alg>
          1. Let _iterator_ be OrdinaryObjectCreate(%ArrayIteratorPrototype%, « [[IteratedArrayLike]], [[ArrayLikeNextIndex]], [[ArrayLikeIterationKind]] »).
          1. Set _iterator_.[[IteratedArrayLike]] to _array_.
          1. Set _iterator_.[[ArrayLikeNextIndex]] to 0.
          1. Set _iterator_.[[ArrayLikeIterationKind]] to _kind_.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%arrayiteratorprototype%-object">
        <h1>The %ArrayIteratorPrototype% Object</h1>
        <p>The <dfn>%ArrayIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Array Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%arrayiteratorprototype%.next">
          <h1>%ArrayIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If _O_ is not an Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of an Array Iterator Instance (<emu-xref href="#sec-properties-of-array-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. Let _array_ be _O_.[[IteratedArrayLike]].
            1. If _array_ is *undefined*, return CreateIteratorResultObject(*undefined*, *true*).
            1. Let _index_ be _O_.[[ArrayLikeNextIndex]].
            1. Let _kind_ be _O_.[[ArrayLikeIterationKind]].
            1. If _array_ has a [[TypedArrayName]] internal slot, then
              1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).
              1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
              1. Let _len_ be TypedArrayLength(_taRecord_).
            1. Else,
              1. Let _len_ be ? LengthOfArrayLike(_array_).
            1. If _index_ ≥ _len_, then
              1. Set _O_.[[IteratedArrayLike]] to *undefined*.
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. Set _O_.[[ArrayLikeNextIndex]] to _index_ + 1.
            1. Let _indexNumber_ be 𝔽(_index_).
            1. If _kind_ is ~key~, then
              1. Let _result_ be _indexNumber_.
            1. Else,
              1. Let _elementKey_ be ! ToString(_indexNumber_).
              1. Let _elementValue_ be ? Get(_array_, _elementKey_).
              1. If _kind_ is ~value~, then
                1. Let _result_ be _elementValue_.
              1. Else,
                1. Assert: _kind_ is ~key+value~.
                1. Let _result_ be CreateArrayFromList(« _indexNumber_, _elementValue_ »).
            1. Return CreateIteratorResultObject(_result_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%arrayiteratorprototype%-@@tostringtag" id="sec-%arrayiteratorprototype%-%symbol.tostringtag%">
          <h1>%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Array Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-array-iterator-instances">
        <h1>Properties of Array Iterator Instances</h1>
        <p>Array Iterator instances are ordinary objects that inherit properties from the %ArrayIteratorPrototype% intrinsic object. Array Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-internal-slots-of-array-iterator-instances"></emu-xref>.</p>
        <emu-table id="table-internal-slots-of-array-iterator-instances" caption="Internal Slots of Array Iterator Instances" oldids="table-48">
          <table>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedArrayLike]]
              </td>
              <td>
                an Object or *undefined*
              </td>
              <td>
                The array-like object that is being iterated.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeNextIndex]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                The integer index of the next element to be examined by this iterator.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeIterationKind]]
              </td>
              <td>
                ~key+value~, ~key~, or ~value~
              </td>
              <td>
                A value that identifies what is returned for each element of the iteration.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>
    <p>A _TypedArray_ presents an array-like view of an underlying binary data buffer (<emu-xref href="#sec-arraybuffer-objects"></emu-xref>). A <dfn variants="TypedArray element types">TypedArray element type</dfn> is the underlying binary scalar data type that all elements of a _TypedArray_ instance have. There is a distinct _TypedArray_ constructor, listed in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>, for each of the supported element types. Each constructor in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> has a corresponding distinct prototype object.</p>
    <emu-table id="table-the-typedarray-constructors" caption="The TypedArray Constructors" oldids="table-49">
      <table>
        <thead>
          <tr>
            <th>
              Constructor Name and Intrinsic
            </th>
            <th>
              Element Type
            </th>
            <th>
              Element Size
            </th>
            <th>
              Conversion Operation
            </th>
            <th>
              Description
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Int8Array<br>
            <dfn>%Int8Array%</dfn>
          </td>
          <td>
            ~int8~
          </td>
          <td>
            1
          </td>
          <td>
            ToInt8
          </td>
          <td>
            8-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            Uint8Array<br>
            <dfn>%Uint8Array%</dfn>
          </td>
          <td>
            ~uint8~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8
          </td>
          <td>
            8-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            Uint8ClampedArray<br>
            <dfn>%Uint8ClampedArray%</dfn>
          </td>
          <td>
            ~uint8clamped~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8Clamp
          </td>
          <td>
            8-bit unsigned integer (clamped conversion)
          </td>
        </tr>
        <tr>
          <td>
            Int16Array<br>
            <dfn>%Int16Array%</dfn>
          </td>
          <td>
            ~int16~
          </td>
          <td>
            2
          </td>
          <td>
            ToInt16
          </td>
          <td>
            16-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            Uint16Array<br>
            <dfn>%Uint16Array%</dfn>
          </td>
          <td>
            ~uint16~
          </td>
          <td>
            2
          </td>
          <td>
            ToUint16
          </td>
          <td>
            16-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            Int32Array<br>
            <dfn>%Int32Array%</dfn>
          </td>
          <td>
            ~int32~
          </td>
          <td>
            4
          </td>
          <td>
            ToInt32
          </td>
          <td>
            32-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            Uint32Array<br>
            <dfn>%Uint32Array%</dfn>
          </td>
          <td>
            ~uint32~
          </td>
          <td>
            4
          </td>
          <td>
            ToUint32
          </td>
          <td>
            32-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            BigInt64Array<br>
            <dfn>%BigInt64Array%</dfn>
          </td>
          <td>
            ~bigint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigInt64
          </td>
          <td>
            64-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            BigUint64Array<br>
            <dfn>%BigUint64Array%</dfn>
          </td>
          <td>
            ~biguint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigUint64
          </td>
          <td>
            64-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            Float16Array<br>
            <dfn>%Float16Array%</dfn>
          </td>
          <td>
            ~float16~
          </td>
          <td>
            2
          </td>
          <td>
          </td>
          <td>
            16-bit IEEE floating point
          </td>
        </tr>
        <tr>
          <td>
            Float32Array<br>
            <dfn>%Float32Array%</dfn>
          </td>
          <td>
            ~float32~
          </td>
          <td>
            4
          </td>
          <td>
          </td>
          <td>
            32-bit IEEE floating point
          </td>
        </tr>
        <tr>
          <td>
            Float64Array<br>
            <dfn>%Float64Array%</dfn>
          </td>
          <td>
            ~float64~
          </td>
          <td>
            8
          </td>
          <td>
          </td>
          <td>
            64-bit IEEE floating point
          </td>
        </tr>
      </table>
    </emu-table>
    <p>In the definitions below, references to _TypedArray_ should be replaced with the appropriate constructor name from the above table.</p>

    <emu-clause id="sec-%typedarray%-intrinsic-object">
      <h1>The %TypedArray% Intrinsic Object</h1>
      <p>The <dfn>%TypedArray%</dfn> intrinsic object:</p>
      <ul>
        <li>is a constructor function object that all of the _TypedArray_ constructor objects inherit from.</li>
        <li>along with its corresponding prototype object, provides common properties that are inherited by all _TypedArray_ constructors and their instances.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>acts as the abstract superclass of the various _TypedArray_ constructors.</li>
        <li>will throw an error when invoked, because it is an abstract class constructor. The _TypedArray_ constructors do not perform a `super` call to it.</li>
      </ul>

      <emu-clause id="sec-%typedarray%">
        <h1>%TypedArray% ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>The *"length"* property of this function is *+0*<sub>𝔽</sub>.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarray%-intrinsic-object">
      <h1>Properties of the %TypedArray% Intrinsic Object</h1>
      <p>The %TypedArray% intrinsic object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"name"* property whose value is *"TypedArray"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%typedarray%.from">
        <h1>%TypedArray%.from ( _source_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. If _mapper_ is *undefined*, then
            1. Let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Let _usingIterator_ be ? GetMethod(_source_, %Symbol.iterator%).
          1. If _usingIterator_ is not *undefined*, then
            1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)).
            1. Let _len_ be the number of elements in _values_.
            1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _kValue_ be the first element of _values_.
              1. Remove the first element from _values_.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
              1. Else,
                1. Let _mappedValue_ be _kValue_.
              1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).
              1. Set _k_ to _k_ + 1.
            1. Assert: _values_ is now an empty List.
            1. Return _targetObj_.
          1. NOTE: _source_ is not an iterable object, so assume it is already an array-like object.
          1. Let _arrayLike_ be ! ToObject(_source_).
          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
          1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
            1. Else,
              1. Let _mappedValue_ be _kValue_.
            1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _targetObj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.of">
        <h1>%TypedArray%.of ( ..._items_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _len_ be the number of elements in _items_.
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. Let _newObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _items_[_k_].
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ? Set(_newObj_, _Pk_, _kValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _newObj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype">
        <h1>%TypedArray%.prototype</h1>
        <p>The initial value of %TypedArray%`.prototype` is the %TypedArray% prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%-@@species" id="sec-get-%typedarray%-%symbol.species%">
        <h1>get %TypedArray% [ %Symbol.species% ]</h1>
        <p>%TypedArray%`[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>%TypedArray.prototype% methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
      <h1>Properties of the %TypedArray% Prototype Object</h1>
      <p>The <dfn>%TypedArray% prototype object</dfn>:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is <dfn>%TypedArray.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to _TypedArray_ instance objects.</li>
      </ul>

      <emu-clause id="sec-%typedarray%.prototype.at">
        <h1>%TypedArray%.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ ≥ _len_, return *undefined*.
          1. Return ! Get(_O_, ! ToString(𝔽(_k_))).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.buffer">
        <h1>get %TypedArray%.prototype.buffer</h1>
        <p>%TypedArray%`.prototype.buffer` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
        <h1>get %TypedArray%.prototype.byteLength</h1>
        <p>%TypedArray%`.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. Let _size_ be TypedArrayByteLength(_taRecord_).
          1. Return 𝔽(_size_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
        <h1>get %TypedArray%.prototype.byteOffset</h1>
        <p>%TypedArray%`.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Return 𝔽(_offset_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.constructor">
        <h1>%TypedArray%.prototype.constructor</h1>
        <p>The initial value of %TypedArray%`.prototype.constructor` is %TypedArray%.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.copywithin">
        <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.copyWithin` as defined in <emu-xref href="#sec-array.prototype.copywithin"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
          1. If _relativeTarget_ = -∞, let _targetIndex_ be 0.
          1. Else if _relativeTarget_ &lt; 0, let _targetIndex_ be max(_len_ + _relativeTarget_, 0).
          1. Else, let _targetIndex_ be min(_relativeTarget_, _len_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).
          1. Let _count_ be min(_endIndex_ - _startIndex_, _len_ - _targetIndex_).
          1. If _count_ > 0, then
            1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.
            1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
            1. Set _len_ to TypedArrayLength(_taRecord_).
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _byteOffset_ be _O_.[[ByteOffset]].
            1. Let _bufferByteLimit_ be (_len_ × _elementSize_) + _byteOffset_.
            1. Let _toByteIndex_ be (_targetIndex_ × _elementSize_) + _byteOffset_.
            1. Let _fromByteIndex_ be (_startIndex_ × _elementSize_) + _byteOffset_.
            1. Let _countBytes_ be _count_ × _elementSize_.
            1. If _fromByteIndex_ &lt; _toByteIndex_ and _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_, then
              1. Let _direction_ be -1.
              1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.
              1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.
            1. Else,
              1. Let _direction_ be 1.
            1. Repeat, while _countBytes_ > 0,
              1. If _fromByteIndex_ &lt; _bufferByteLimit_ and _toByteIndex_ &lt; _bufferByteLimit_, then
                1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~).
                1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.
                1. Set _toByteIndex_ to _toByteIndex_ + _direction_.
                1. Set _countBytes_ to _countBytes_ - 1.
              1. Else,
                1. Set _countBytes_ to 0.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.entries">
        <h1>%TypedArray%.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Return CreateArrayIterator(_O_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.every">
        <h1>%TypedArray%.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.every` as defined in <emu-xref href="#sec-array.prototype.every"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. If _testResult_ is *false*, return *false*.
            1. Set _k_ to _k_ + 1.
          1. Return *true*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.fill` as defined in <emu-xref href="#sec-array.prototype.fill"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _O_.[[ContentType]] is ~bigint~, set _value_ to ? ToBigInt(_value_).
          1. Otherwise, set _value_ to ? ToNumber(_value_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).
          1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
          1. Set _len_ to TypedArrayLength(_taRecord_).
          1. Set _endIndex_ to min(_endIndex_, _len_).
          1. Let _k_ be _startIndex_.
          1. Repeat, while _k_ &lt; _endIndex_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ! Set(_O_, _Pk_, _value_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.filter">
        <h1>%TypedArray%.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.filter` as defined in <emu-xref href="#sec-array.prototype.filter"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _kept_ be a new empty List.
          1. Let _captured_ be 0.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _selected_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. If _selected_ is *true*, then
              1. Append _kValue_ to _kept_.
              1. Set _captured_ to _captured_ + 1.
            1. Set _k_ to _k_ + 1.
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »).
          1. Let _n_ be 0.
          1. For each element _e_ of _kept_, do
            1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*).
            1. Set _n_ to _n_ + 1.
          1. Return _A_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.find">
        <h1>%TypedArray%.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.find` as defined in <emu-xref href="#sec-array.prototype.find"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findindex">
        <h1>%TypedArray%.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findIndex` as defined in <emu-xref href="#sec-array.prototype.findindex"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlast">
        <h1>%TypedArray%.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findLast` as defined in <emu-xref href="#sec-array.prototype.findlast"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlastindex">
        <h1>%TypedArray%.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findLastIndex` as defined in <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.foreach">
        <h1>%TypedArray%.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.forEach` as defined in <emu-xref href="#sec-array.prototype.foreach"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Perform ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return *undefined*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.includes">
        <h1>%TypedArray%.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.includes` as defined in <emu-xref href="#sec-array.prototype.includes"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _len_ = 0, return *false*.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *false*.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).
            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.indexof">
        <h1>%TypedArray%.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.indexOf` as defined in <emu-xref href="#sec-array.prototype.indexof"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ! HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ! Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ + 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.join">
        <h1>%TypedArray%.prototype.join ( _separator_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.join` as defined in <emu-xref href="#sec-array.prototype.join"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _separator_ is *undefined*, let _sep_ be *","*.
          1. Else, let _sep_ be ? ToString(_separator_).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.
            1. Let _element_ be ! Get(_O_, ! ToString(𝔽(_k_))).
            1. If _element_ is not *undefined*, then
              1. Let _S_ be ! ToString(_element_).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.keys">
        <h1>%TypedArray%.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Return CreateArrayIterator(_O_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.lastindexof">
        <h1>%TypedArray%.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.lastIndexOf` as defined in <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.
          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.
          1. If _n_ ≥ 0, then
            1. Let _k_ be min(_n_, _len_ - 1).
          1. Else,
            1. Let _k_ be _len_ + _n_.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ! HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ! Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ - 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.length">
        <h1>get %TypedArray%.prototype.length</h1>
        <p>%TypedArray%`.prototype.length` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.
          1. Let _length_ be TypedArrayLength(_taRecord_).
          1. Return 𝔽(_length_).
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.map">
        <h1>%TypedArray%.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.map` as defined in <emu-xref href="#sec-array.prototype.map"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _mappedValue_ be ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. Perform ? Set(_A_, _Pk_, _mappedValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduce">
        <h1>%TypedArray%.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reduce` as defined in <emu-xref href="#sec-array.prototype.reduce"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Set _accumulator_ to ! Get(_O_, _Pk_).
            1. Set _k_ to _k_ + 1.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return _accumulator_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduceright">
        <h1>%TypedArray%.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reduceRight` as defined in <emu-xref href="#sec-array.prototype.reduceright"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Set _accumulator_ to ! Get(_O_, _Pk_).
            1. Set _k_ to _k_ - 1.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ - 1.
          1. Return _accumulator_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reverse">
        <h1>%TypedArray%.prototype.reverse ( )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reverse` as defined in <emu-xref href="#sec-array.prototype.reverse"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _middle_ be floor(_len_ / 2).
          1. Let _lower_ be 0.
          1. Repeat, while _lower_ ≠ _middle_,
            1. Let _upper_ be _len_ - _lower_ - 1.
            1. Let _upperP_ be ! ToString(𝔽(_upper_)).
            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).
            1. Let _lowerValue_ be ! Get(_O_, _lowerP_).
            1. Let _upperValue_ be ! Get(_O_, _upperP_).
            1. Perform ! Set(_O_, _lowerP_, _upperValue_, *true*).
            1. Perform ! Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Set _lower_ to _lower_ + 1.
          1. Return _O_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.set" oldids="sec-%typedarray%.prototype.set-overloaded-offset">
        <h1>%TypedArray%.prototype.set ( _source_ [ , _offset_ ] )</h1>
        <p>This method sets multiple values in this _TypedArray_, reading the values from _source_. The details differ based upon the type of _source_. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _target_ be the *this* value.
          1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).
          1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _targetOffset_ be ? ToIntegerOrInfinity(_offset_).
          1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
          1. If _source_ is an Object that has a [[TypedArrayName]] internal slot, then
            1. Perform ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_).
          1. Else,
            1. Perform ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_).
          1. Return *undefined*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>

        <emu-clause id="sec-settypedarrayfromarraylike" type="abstract operation" oldids="sec-%typedarray%.prototype.set-array-offset">
          <h1>
            SetTypedArrayFromArrayLike (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: an ECMAScript language value, but not a TypedArray,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_.</dd>
          </dl>
          <emu-alg>
            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).
            1. Let _src_ be ? ToObject(_source_).
            1. Let _srcLength_ be ? LengthOfArrayLike(_src_).
            1. If _targetOffset_ = +∞, throw a *RangeError* exception.
            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _srcLength_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _value_ be ? Get(_src_, _Pk_).
              1. Let _targetIndex_ be 𝔽(_targetOffset_ + _k_).
              1. Perform ? TypedArraySetElement(_target_, _targetIndex_, _value_).
              1. Set _k_ to _k_ + 1.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>
            SetTypedArrayFromTypedArray (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: a TypedArray,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_.</dd>
          </dl>
          <emu-alg>
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).
            1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].
            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.
            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).
            1. Let _targetType_ be TypedArrayElementType(_target_).
            1. Let _targetElementSize_ be TypedArrayElementSize(_target_).
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcType_ be TypedArrayElementType(_source_).
            1. Let _srcElementSize_ be TypedArrayElementSize(_source_).
            1. Let _srcByteOffset_ be _source_.[[ByteOffset]].
            1. If _targetOffset_ = +∞, throw a *RangeError* exception.
            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.
            1. If _target_.[[ContentType]] is not _source_.[[ContentType]], throw a *TypeError* exception.
            1. If IsSharedArrayBuffer(_srcBuffer_) is *true*, IsSharedArrayBuffer(_targetBuffer_) is *true*, and _srcBuffer_.[[ArrayBufferData]] is _targetBuffer_.[[ArrayBufferData]], let _sameSharedArrayBuffer_ be *true*; otherwise let _sameSharedArrayBuffer_ be *false*.
            1. If SameValue(_srcBuffer_, _targetBuffer_) is *true* or _sameSharedArrayBuffer_ is *true*, then
              1. Let _srcByteLength_ be TypedArrayByteLength(_srcRecord_).
              1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).
              1. Let _srcByteIndex_ be 0.
            1. Else,
              1. Let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be (_targetOffset_ × _targetElementSize_) + _targetByteOffset_.
            1. Let _limit_ be _targetByteIndex_ + (_targetElementSize_ × _srcLength_).
            1. If _srcType_ is _targetType_, then
              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Repeat, while _targetByteIndex_ &lt; _limit_,
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
            1. Else,
              1. Repeat, while _targetByteIndex_ &lt; _limit_,
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.slice">
        <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.slice` as defined in <emu-xref href="#sec-array.prototype.slice"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _srcArrayLength_ be TypedArrayLength(_taRecord_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_srcArrayLength_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _srcArrayLength_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _srcArrayLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_srcArrayLength_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _srcArrayLength_).
          1. Let _countBytes_ be max(_endIndex_ - _startIndex_, 0).
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »).
          1. If _countBytes_ > 0, then
            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
            1. Set _endIndex_ to min(_endIndex_, TypedArrayLength(_taRecord_)).
            1. Set _countBytes_ to max(_endIndex_ - _startIndex_, 0).
            1. Let _srcType_ be TypedArrayElementType(_O_).
            1. Let _targetType_ be TypedArrayElementType(_A_).
            1. If _srcType_ is _targetType_, then
              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].
              1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].
              1. Let _elementSize_ be TypedArrayElementSize(_O_).
              1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
              1. Let _srcByteIndex_ be (_startIndex_ × _elementSize_) + _srcByteOffset_.
              1. Let _targetByteIndex_ be _A_.[[ByteOffset]].
              1. Let _endByteIndex_ be _targetByteIndex_ + (_countBytes_ × _elementSize_).
              1. Repeat, while _targetByteIndex_ &lt; _endByteIndex_,
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
            1. Else,
              1. Let _n_ be 0.
              1. Let _k_ be _startIndex_.
              1. Repeat, while _k_ &lt; _endIndex_,
                1. Let _Pk_ be ! ToString(𝔽(_k_)).
                1. Let _kValue_ be ! Get(_O_, _Pk_).
                1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*).
                1. Set _k_ to _k_ + 1.
                1. Set _n_ to _n_ + 1.
          1. Return _A_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.some">
        <h1>%TypedArray%.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.some` as defined in <emu-xref href="#sec-array.prototype.some"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. If _testResult_ is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.sort" oldids="sec-typedarraysortcompare">
        <h1>%TypedArray%.prototype.sort ( _comparator_ )</h1>
        <p>This is a distinct method that, except as described below, implements the same requirements as those of `Array.prototype.sort` as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. The implementation of this method may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose integer-indexed properties are not sparse.</p>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_obj_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.sort"></emu-xref>.
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparator_).
          1. Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).
            1. Set _j_ to _j_ + 1.
          1. Return _obj_.
        </emu-alg>
        <emu-note>
          <p>Because *NaN* always compares greater than any other value (see CompareTypedArrayElements), *NaN* property values always sort to the end of the result when _comparator_ is not provided.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.subarray">
        <h1>%TypedArray%.prototype.subarray ( _start_, _end_ )</h1>
        <p>This method returns a new _TypedArray_ whose element type is the element type of this _TypedArray_ and whose ArrayBuffer is the ArrayBuffer of this _TypedArray_, referencing the elements in the interval from _start_ (inclusive) to _end_ (exclusive). If either _start_ or _end_ is negative, it refers to an index from the end of the array, as opposed to from the beginning.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, then
            1. Let _srcLength_ be 0.
          1. Else,
            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_srcLength_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _srcLength_).
          1. Let _elementSize_ be TypedArrayElementSize(_O_).
          1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
          1. Let _beginByteOffset_ be _srcByteOffset_ + (_startIndex_ × _elementSize_).
          1. If _O_.[[ArrayLength]] is ~auto~ and _end_ is *undefined*, then
            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_) ».
          1. Else,
            1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
            1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
            1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_srcLength_ + _relativeEnd_, 0).
            1. Else, let _endIndex_ be min(_relativeEnd_, _srcLength_).
            1. Let _newLength_ be max(_endIndex_ - _startIndex_, 0).
            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) ».
          1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tolocalestring">
        <h1>%TypedArray%.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>This is a distinct method that implements the same algorithm as `Array.prototype.toLocaleString` as defined in <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref> except that TypedArrayLength is called in place of performing a [[Get]] of *"length"*. The implementation of the algorithm may be optimized with the knowledge that the *this* value has a fixed length when the underlying buffer is not resizable and whose integer-indexed properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This method is not generic. ValidateTypedArray is called with the *this* value and ~seq-cst~ as arguments prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
        <emu-note>
          <p>If the ECMAScript implementation includes the ECMA-402 Internationalization API this method is based upon the algorithm for `Array.prototype.toLocaleString` that is in the ECMA-402 specification.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.toreversed">
        <h1>%TypedArray%.prototype.toReversed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _A_ be ? TypedArrayCreateSameType(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _fromValue_ be ! Get(_O_, _from_).
            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tosorted">
        <h1>%TypedArray%.prototype.toSorted ( _comparator_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _A_ be ? TypedArrayCreateSameType(_O_, _len_).
          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.tosorted"></emu-xref>.
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparator_).
          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).
            1. Set _j_ to _j_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tostring">
        <h1>%TypedArray%.prototype.toString ( )</h1>
        <p>The initial value of the *"toString"* property is %Array.prototype.toString%, defined in <emu-xref href="#sec-array.prototype.tostring"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.values">
        <h1>%TypedArray%.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Return CreateArrayIterator(_O_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.with">
        <h1>%TypedArray%.prototype.with ( _index_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.
          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
          1. If _O_.[[ContentType]] is ~bigint~, let _numericValue_ be ? ToBigInt(_value_).
          1. Else, let _numericValue_ be ? ToNumber(_value_).
          1. If IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) is *false*, throw a *RangeError* exception.
          1. Let _A_ be ? TypedArrayCreateSameType(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. If _k_ = _actualIndex_, let _fromValue_ be _numericValue_.
            1. Else, let _fromValue_ be ! Get(_O_, _Pk_).
            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%typedarray%.prototype-@@iterator" id="sec-%typedarray%.prototype-%symbol.iterator%">
        <h1>%TypedArray%.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %TypedArray.prototype.values%, defined in <emu-xref href="#sec-%typedarray%.prototype.values"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%.prototype-@@tostringtag" id="sec-get-%typedarray%.prototype-%symbol.tostringtag%">
        <h1>get %TypedArray%.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%TypedArray%`.prototype[%Symbol.toStringTag%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, return *undefined*.
          1. If _O_ does not have a [[TypedArrayName]] internal slot, return *undefined*.
          1. Let _name_ be _O_.[[TypedArrayName]].
          1. Assert: _name_ is a String.
          1. Return _name_.
        </emu-alg>
        <p>This property has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The initial value of the *"name"* property of this function is *"get [Symbol.toStringTag]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-typedarray-objects">
      <h1>Abstract Operations for TypedArray Objects</h1>

      <emu-clause id="sec-typedarraycreatefromconstructor" oldids="typedarray-create" type="abstract operation">
        <h1>
          TypedArrayCreateFromConstructor (
            _constructor_: a constructor,
            _argumentList_: a List of ECMAScript language values,
          ): either a normal completion containing a TypedArray or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to specify the creation of a new TypedArray using a constructor function.</dd>
        </dl>
        <emu-alg>
          1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).
          1. Let _taRecord_ be ? ValidateTypedArray(_newTypedArray_, ~seq-cst~).
          1. Assert: _newTypedArray_ has all the internal slots mentioned in <emu-xref href="#sec-properties-of-typedarray-instances" title></emu-xref>.
          1. If the number of elements in _argumentList_ is 1 and _argumentList_[0] is a Number, then
            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
            1. Let _length_ be TypedArrayLength(_taRecord_).
            1. If _length_ &lt; ℝ(_argumentList_[0]), throw a *TypeError* exception.
          1. Return _newTypedArray_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-create-same-type" type="abstract operation">
        <h1>
          TypedArrayCreateSameType (
            _exemplar_: a TypedArray,
            _length_: a non-negative integer,
          ): either a normal completion containing a TypedArray or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to specify the creation of a new TypedArray using a constructor function that is derived from _exemplar_, and a _length_. Unlike TypedArraySpeciesCreate, which can construct custom TypedArray subclasses through the use of %Symbol.species%, this operation always uses one of the built-in TypedArray constructors.</dd>
        </dl>
        <emu-alg>
          1. Let _constructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.
          1. Let _result_ be ? <emu-meta suppress-effects="user-code">TypedArrayCreateFromConstructor(_constructor_, « 𝔽(_length_) »)</emu-meta>.
          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.
          1. Assert: _result_.[[ContentType]] is _exemplar_.[[ContentType]].
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-species-create" type="abstract operation">
        <h1>
          TypedArraySpeciesCreate (
            _exemplar_: a TypedArray,
            _argumentList_: a List of ECMAScript language values,
          ): either a normal completion containing a TypedArray or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to specify the creation of a new TypedArray using a constructor function that is derived from _exemplar_. Unlike ArraySpeciesCreate, which can create non-Array objects through the use of %Symbol.species%, this operation enforces that the constructor function creates an actual TypedArray.</dd>
        </dl>
        <emu-alg>
          1. Let _defaultConstructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.
          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).
          1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).
          1. If _result_.[[ContentType]] is not _exemplar_.[[ContentType]], throw a *TypeError* exception.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validatetypedarray" type="abstract operation">
        <h1>
          ValidateTypedArray (
            _O_: an ECMAScript language value,
            _order_: ~seq-cst~ or ~unordered~,
          ): either a normal completion containing a TypedArray With Buffer Witness Record or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, _order_).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
          1. Return _taRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementsize" type="abstract operation">
        <h1>
          TypedArrayElementSize (
            _O_: a TypedArray,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementtype" type="abstract operation">
        <h1>
          TypedArrayElementType (
            _O_: a TypedArray,
          ): a TypedArray element type
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return the Element Type value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-comparetypedarrayelements" type="abstract operation">
        <h1>
          CompareTypedArrayElements (
            _x_: a Number or a BigInt,
            _y_: a Number or a BigInt,
            _comparator_: a function object or *undefined*,
          ): either a normal completion containing a Number or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _x_ is a Number and _y_ is a Number, or _x_ is a BigInt and _y_ is a BigInt.
          1. If _comparator_ is not *undefined*, then
            1. Let _v_ be ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »)).
            1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.
            1. Return _v_.
          1. If _x_ and _y_ are both *NaN*, return *+0*<sub>𝔽</sub>.
          1. If _x_ is *NaN*, return *1*<sub>𝔽</sub>.
          1. If _y_ is *NaN*, return *-1*<sub>𝔽</sub>.
          1. If _x_ &lt; _y_, return *-1*<sub>𝔽</sub>.
          1. If _x_ > _y_, return *1*<sub>𝔽</sub>.
          1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.
          1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.
          1. Return *+0*<sub>𝔽</sub>.
        </emu-alg>
        <emu-note>
          This performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-comparearrayelements"></emu-xref>.
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-constructors">
      <h1>The _TypedArray_ Constructors</h1>
      <p>Each _TypedArray_ constructor:</p>
      <ul>
        <li>is an intrinsic object that has the structure described below, differing only in the name used as the constructor name instead of _TypedArray_, in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.</li>
        <li>is a function whose behaviour differs based upon the number and types of its arguments. The actual behaviour of a call of _TypedArray_ depends upon the number and kind of arguments that are passed to it.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified _TypedArray_ behaviour must include a `super` call to the _TypedArray_ constructor to create and initialize the subclass instance with the internal state necessary to support the %TypedArray%`.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-typedarray" oldids="sec-typedarray-length,sec-typedarray-object">
        <h1>_TypedArray_ ( ..._args_ )</h1>
        <p>Each _TypedArray_ constructor performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _proto_ be <code>"%<var>TypedArray</var>.prototype%"</code>.
          1. Let _numberOfArgs_ be the number of elements in _args_.
          1. If _numberOfArgs_ = 0, then
            1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0).
          1. Else,
            1. Let _firstArgument_ be _args_[0].
            1. If _firstArgument_ is an Object, then
              1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, _proto_).
              1. If _firstArgument_ has a [[TypedArrayName]] internal slot, then
                1. Perform ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_).
              1. Else if _firstArgument_ has an [[ArrayBufferData]] internal slot, then
                1. If _numberOfArgs_ > 1, let _byteOffset_ be _args_[1]; else let _byteOffset_ be *undefined*.
                1. If _numberOfArgs_ > 2, let _length_ be _args_[2]; else let _length_ be *undefined*.
                1. Perform ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_).
              1. Else,
                1. Assert: _firstArgument_ is an Object and _firstArgument_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.
                1. Let _usingIterator_ be ? GetMethod(_firstArgument_, %Symbol.iterator%).
                1. If _usingIterator_ is not *undefined*, then
                  1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_)).
                  1. Perform ? InitializeTypedArrayFromList(_O_, _values_).
                1. Else,
                  1. NOTE: _firstArgument_ is not an iterable object, so assume it is already an array-like object.
                  1. Perform ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_).
              1. Return _O_.
            1. Else,
              1. Assert: _firstArgument_ is not an Object.
              1. Let _elementLength_ be ? ToIndex(_firstArgument_).
              1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_).
        </emu-alg>

        <emu-clause id="sec-allocatetypedarray" type="abstract operation">
          <h1>
            AllocateTypedArray (
              _constructorName_: a String which is the name of a TypedArray constructor in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>,
              _newTarget_: a constructor,
              _defaultProto_: a String,
              optional _length_: a non-negative integer,
            ): either a normal completion containing a TypedArray or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It is used to validate and create an instance of a TypedArray constructor. If the _length_ argument is passed, an ArrayBuffer of that length is also allocated and associated with the new TypedArray instance. AllocateTypedArray provides common semantics that is used by _TypedArray_.</dd>
          </dl>
          <emu-alg>
            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).
            1. Let _obj_ be TypedArrayCreate(_proto_).
            1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.
            1. Set _obj_.[[TypedArrayName]] to _constructorName_.
            1. If _constructorName_ is either *"BigInt64Array"* or *"BigUint64Array"*, set _obj_.[[ContentType]] to ~bigint~.
            1. Otherwise, set _obj_.[[ContentType]] to ~number~.
            1. If _length_ is not present, then
              1. Set _obj_.[[ByteLength]] to 0.
              1. Set _obj_.[[ByteOffset]] to 0.
              1. Set _obj_.[[ArrayLength]] to 0.
            1. Else,
              1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).
            1. Return _obj_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray">
          <h1>
            InitializeTypedArrayFromTypedArray (
              _O_: a TypedArray,
              _srcArray_: a TypedArray,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
            1. Let _elementType_ be TypedArrayElementType(_O_).
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _srcType_ be TypedArrayElementType(_srcArray_).
            1. Let _srcElementSize_ be TypedArrayElementSize(_srcArray_).
            1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.
            1. Let _elementLength_ be TypedArrayLength(_srcRecord_).
            1. Let _byteLength_ be _elementSize_ × _elementLength_.
            1. If _elementType_ is _srcType_, then
              1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).
            1. Else,
              1. Let _data_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
              1. If _srcArray_.[[ContentType]] is not _O_.[[ContentType]], throw a *TypeError* exception.
              1. Let _srcByteIndex_ be _srcByteOffset_.
              1. Let _targetByteIndex_ be 0.
              1. Let _count_ be _elementLength_.
              1. Repeat, while _count_ > 0,
                1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
                1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
                1. Set _count_ to _count_ - 1.
            1. Set _O_.[[ViewedArrayBuffer]] to _data_.
            1. Set _O_.[[ByteLength]] to _byteLength_.
            1. Set _O_.[[ByteOffset]] to 0.
            1. Set _O_.[[ArrayLength]] to _elementLength_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length">
          <h1>
            InitializeTypedArrayFromArrayBuffer (
              _O_: a TypedArray,
              _buffer_: an ArrayBuffer or a SharedArrayBuffer,
              _byteOffset_: an ECMAScript language value,
              _length_: an ECMAScript language value,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _offset_ be ? ToIndex(_byteOffset_).
            1. If _offset_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.
            1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).
            1. If _length_ is not *undefined*, then
              1. Let _newLength_ be ? ToIndex(_length_).
            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
            1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).
            1. If _length_ is *undefined* and _bufferIsFixedLength_ is *false*, then
              1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.
              1. Set _O_.[[ByteLength]] to ~auto~.
              1. Set _O_.[[ArrayLength]] to ~auto~.
            1. Else,
              1. If _length_ is *undefined*, then
                1. If _bufferByteLength_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.
                1. Let _newByteLength_ be _bufferByteLength_ - _offset_.
                1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
              1. Else,
                1. Let _newByteLength_ be _newLength_ × _elementSize_.
                1. If _offset_ + _newByteLength_ > _bufferByteLength_, throw a *RangeError* exception.
              1. Set _O_.[[ByteLength]] to _newByteLength_.
              1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
            1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
            1. Set _O_.[[ByteOffset]] to _offset_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromlist" type="abstract operation">
          <h1>
            InitializeTypedArrayFromList (
              _O_: a TypedArray,
              _values_: a List of ECMAScript language values,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _len_ be the number of elements in _values_.
            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _kValue_ be the first element of _values_.
              1. Remove the first element from _values_.
              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).
              1. Set _k_ to _k_ + 1.
            1. Assert: _values_ is now an empty List.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraylike" type="abstract operation">
          <h1>
            InitializeTypedArrayFromArrayLike (
              _O_: a TypedArray,
              _arrayLike_: an Object, but not a TypedArray or an ArrayBuffer,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).
              1. Set _k_ to _k_ + 1.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allocatetypedarraybuffer" type="abstract operation">
          <h1>
            AllocateTypedArrayBuffer (
              _O_: a TypedArray,
              _length_: a non-negative integer,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It allocates and associates an ArrayBuffer with _O_.</dd>
          </dl>
          <emu-alg>
            1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _byteLength_ be _elementSize_ × _length_.
            1. Let _data_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
            1. Set _O_.[[ViewedArrayBuffer]] to _data_.
            1. Set _O_.[[ByteLength]] to _byteLength_.
            1. Set _O_.[[ByteOffset]] to 0.
            1. Set _O_.[[ArrayLength]] to _length_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>Properties of the _TypedArray_ Constructors</h1>
      <p>Each _TypedArray_ constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %TypedArray%.</li>
        <li>has a *"length"* property whose value is *3*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is the String value of the constructor name specified for it in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-typedarray.bytes_per_element">
        <h1>_TypedArray_.BYTES_PER_ELEMENT</h1>
        <p>The value of _TypedArray_`.BYTES_PER_ELEMENT` is the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _TypedArray_.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype">
        <h1>_TypedArray_.prototype</h1>
        <p>The initial value of _TypedArray_`.prototype` is the corresponding _TypedArray_ prototype intrinsic object (<emu-xref href="#sec-properties-of-typedarray-prototype-objects"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-prototype-objects">
      <h1>Properties of the _TypedArray_ Prototype Objects</h1>
      <p>Each _TypedArray_ prototype object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %TypedArray.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to _TypedArray_ instance objects.</li>
      </ul>

      <emu-clause id="sec-typedarray.prototype.bytes_per_element">
        <h1>_TypedArray_.prototype.BYTES_PER_ELEMENT</h1>
        <p>The value of _TypedArray_`.prototype.BYTES_PER_ELEMENT` is the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _TypedArray_.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype.constructor">
        <h1>_TypedArray_.prototype.constructor</h1>
        <p>The initial value of the *"constructor"* property of the prototype for a given _TypedArray_ constructor is the constructor itself.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-instances">
      <h1>Properties of _TypedArray_ Instances</h1>
      <p>_TypedArray_ instances are TypedArrays. Each _TypedArray_ instance inherits properties from the corresponding _TypedArray_ prototype object. Each _TypedArray_ instance has the following internal slots: [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], and [[ArrayLength]].</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>Keyed Collections</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map Objects</h1>
    <p>Maps are collections of key/value pairs where both the keys and values may be arbitrary ECMAScript language values. A distinct key value may only occur in one key/value pair within the Map's collection. Distinct key values are discriminated using the semantics of the SameValueZero comparison algorithm.</p>
    <p>Maps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Maps. It is not intended to be a viable implementation model.</p>

    <emu-clause id="sec-map-constructor">
      <h1>The Map Constructor</h1>
      <p>The Map constructor:</p>
      <ul>
        <li>is <dfn>%Map%</dfn>.</li>
        <li>is the initial value of the *"Map"* property of the global object.</li>
        <li>creates and initializes a new Map when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Map behaviour must include a `super` call to the Map constructor to create and initialize the subclass instance with the internal state necessary to support the `Map.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-map-iterable">
        <h1>Map ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Map.prototype%"*, « [[MapData]] »).
          1. Set _map_.[[MapData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _map_.
          1. Let _adder_ be ? Get(_map_, *"set"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>If the parameter _iterable_ is present, it is expected to be an object that implements a %Symbol.iterator% method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-add-entries-from-iterable" type="abstract operation">
        <h1>
          AddEntriesFromIterable (
            _target_: an Object,
            _iterable_: an ECMAScript language value, but not *undefined* or *null*,
            _adder_: a function object,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_adder_ will be invoked, with _target_ as the receiver.</dd>
        </dl>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _target_.
            1. If _next_ is not an Object, then
              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _error_).
            1. Let _k_ be Completion(Get(_next_, *"0"*)).
            1. IfAbruptCloseIterator(_k_, _iteratorRecord_).
            1. Let _v_ be Completion(Get(_next_, *"1"*)).
            1. IfAbruptCloseIterator(_v_, _iteratorRecord_).
            1. Let _status_ be Completion(Call(_adder_, _target_, « _k_, _v_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
        <emu-note>
          <p>The parameter _iterable_ is expected to be an object that implements a %Symbol.iterator% method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Properties of the Map Constructor</h1>
      <p>The Map constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-map.groupby">
        <h1>Map.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts two arguments. `groupBy` calls _callback_ once for each element in _items_, in ascending order, and constructs a new Map. Each value returned by _callback_ is used as a key in the Map. For each such key, the result Map has an entry whose key is that key and whose value is an array containing all the elements for which _callback_ returned that key.</p>
          <p>_callback_ is called with two arguments: the value of the element and the index of the element.</p>
          <p>The return value of `groupBy` is a Map.</p>
        </emu-note>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _groups_ be ? GroupBy(_items_, _callback_, ~collection~).
          1. Let _map_ be ! Construct(%Map%).
          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do
            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).
            1. Let _entry_ be the Record { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }.
            1. Append _entry_ to _map_.[[MapData]].
          1. Return _map_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype">
        <h1>Map.prototype</h1>
        <p>The initial value of `Map.prototype` is the Map prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-map-@@species" id="sec-get-map-%symbol.species%">
        <h1>get Map [ %Symbol.species% ]</h1>
        <p>`Map[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Methods that create derived collection objects should call %Symbol.species% to determine the constructor to use to create the derived objects. Subclass constructor may over-ride %Symbol.species% to change the default constructor assignment.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-prototype-object">
      <h1>Properties of the Map Prototype Object</h1>
      <p>The <dfn>Map prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Map.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[MapData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-map.prototype.clear">
        <h1>Map.prototype.clear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. Set _p_.[[Key]] to ~empty~.
            1. Set _p_.[[Value]] to ~empty~.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The existing [[MapData]] List is preserved because there may be existing Map Iterator objects that are suspended midway through iterating over that List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.constructor">
        <h1>Map.prototype.constructor</h1>
        <p>The initial value of `Map.prototype.constructor` is %Map%.</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype.delete">
        <h1>Map.prototype.delete ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Key]] to ~empty~.
              1. Set _p_.[[Value]] to ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.entries">
        <h1>Map.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.foreach">
        <h1>Map.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _entries_ be _M_.[[MapData]].
          1. Let _numEntries_ be the number of elements in _entries_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _numEntries_,
            1. Let _e_ be _entries_[_index_].
            1. Set _index_ to _index_ + 1.
            1. If _e_.[[Key]] is not ~empty~, then
              1. Perform ? Call(_callback_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »).
              1. NOTE: The number of elements in _entries_ may have increased during execution of _callback_.
              1. Set _numEntries_ to the number of elements in _entries_.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `forEach` calls _callback_ once for each key/value pair present in the Map, in key insertion order. _callback_ is called only for keys of the Map which actually exist; it is not called for keys that have been deleted from the Map.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the item, the key of the item, and the Map being traversed.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_. Each entry of a map's [[MapData]] is only visited once. New keys added after the call to `forEach` begins are visited. A key will be revisited if it is deleted after it has been visited and then re-added before the `forEach` call completes. Keys that are deleted after the call to `forEach` begins and before being visited are not visited unless the key is added again before the `forEach` call completes.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.get">
        <h1>Map.prototype.get ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.has">
        <h1>Map.prototype.has ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.keys">
        <h1>Map.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.set">
        <h1>Map.prototype.set ( _key_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Value]] to _value_.
              1. Return _M_.
          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. Append _p_ to _M_.[[MapData]].
          1. Return _M_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-map.prototype.size">
        <h1>get Map.prototype.size</h1>
        <p>`Map.prototype.size` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _count_ be 0.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~, set _count_ to _count_ + 1.
          1. Return 𝔽(_count_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.values">
        <h1>Map.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@iterator" id="sec-map.prototype-%symbol.iterator%">
        <h1>Map.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %Map.prototype.entries%, defined in <emu-xref href="#sec-map.prototype.entries"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@tostringtag" id="sec-map.prototype-%symbol.tostringtag%">
        <h1>Map.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Map"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-map-instances">
      <h1>Properties of Map Instances</h1>
      <p>Map instances are ordinary objects that inherit properties from the Map prototype object. Map instances also have a [[MapData]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-map-iterator-objects">
      <h1>Map Iterator Objects</h1>
      <p>A <dfn variants="Map Iterators,Map Iterator object,Map Iterator objects">Map Iterator</dfn> is an object that represents a specific iteration over some specific Map instance object. There is not a named constructor for Map Iterator objects. Instead, Map Iterator objects are created by calling certain methods of Map instance objects.</p>

      <emu-clause id="sec-createmapiterator" type="abstract operation" oldids="sec-properties-of-map-iterator-instances,table-50,table-internal-slots-of-map-iterator-instances">
        <h1>
          CreateMapIterator (
            _map_: an ECMAScript language value,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): either a normal completion containing a Generator or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create iterator objects for Map methods that return such iterators.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:
            1. Let _entries_ be _map_.[[MapData]].
            1. Let _index_ be 0.
            1. Let _numEntries_ be the number of elements in _entries_.
            1. Repeat, while _index_ &lt; _numEntries_,
              1. Let _e_ be _entries_[_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_.[[Key]] is not ~empty~, then
                1. If _kind_ is ~key~, then
                  1. Let _result_ be _e_.[[Key]].
                1. Else if _kind_ is ~value~, then
                  1. Let _result_ be _e_.[[Value]].
                1. Else,
                  1. Assert: _kind_ is ~key+value~.
                  1. Let _result_ be CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).
                1. Perform ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)).
                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by GeneratorYield.
                1. Set _numEntries_ to the number of elements in _entries_.
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%MapIteratorPrototype%"*, %MapIteratorPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%mapiteratorprototype%-object">
        <h1>The %MapIteratorPrototype% Object</h1>
        <p>The <dfn>%MapIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Map Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%mapiteratorprototype%.next">
          <h1>%MapIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%MapIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%mapiteratorprototype%-@@tostringtag" id="sec-%mapiteratorprototype%-%symbol.tostringtag%">
          <h1>%MapIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Map Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set Objects</h1>
    <p>Set objects are collections of ECMAScript language values. A distinct value may only occur once as an element of a Set's collection. Distinct values are discriminated using the semantics of the SameValueZero comparison algorithm.</p>
    <p>Set objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Set objects. It is not intended to be a viable implementation model.</p>

    <emu-clause id="sec-abstract-operations-for-set-objects">
      <h1>Abstract Operations For Set Objects</h1>

      <emu-clause id="sec-set-records">
        <h1>Set Records</h1>
        <p>A <dfn variants="Set Records">Set Record</dfn> is a Record value used to encapsulate the interface of a Set or similar object.</p>
        <p>Set Records have the fields listed in <emu-xref href="#table-set-record-fields"></emu-xref>.</p>
        <emu-table id="table-set-record-fields" caption="Set Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[SetObject]]
              </td>
              <td>
                an Object
              </td>
              <td>
                the Set or similar object.
              </td>
            </tr>
            <tr>
              <td>
                [[Size]]
              </td>
              <td>
                a non-negative integer or +∞
              </td>
              <td>
                The reported size of the object.
              </td>
            </tr>
            <tr>
              <td>
                [[Has]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The `has` method of the object.
              </td>
            </tr>
            <tr>
              <td>
                [[Keys]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The `keys` method of the object.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getsetrecord" type="abstract operation">
        <h1>
          GetSetRecord (
            _obj_: an ECMAScript language value,
          ): either a normal completion containing a Set Record or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _obj_ is not an Object, throw a *TypeError* exception.
          1. Let _rawSize_ be ? Get(_obj_, *"size"*).
          1. Let _numSize_ be ? ToNumber(_rawSize_).
          1. NOTE: If _rawSize_ is *undefined*, then _numSize_ will be *NaN*.
          1. If _numSize_ is *NaN*, throw a *TypeError* exception.
          1. Let _intSize_ be ! ToIntegerOrInfinity(_numSize_).
          1. If _intSize_ &lt; 0, throw a *RangeError* exception.
          1. Let _has_ be ? Get(_obj_, *"has"*).
          1. If IsCallable(_has_) is *false*, throw a *TypeError* exception.
          1. Let _keys_ be ? Get(_obj_, *"keys"*).
          1. If IsCallable(_keys_) is *false*, throw a *TypeError* exception.
          1. Return a new Set Record { [[SetObject]]: _obj_, [[Size]]: _intSize_, [[Has]]: _has_, [[Keys]]: _keys_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatahas" type="abstract operation">
        <h1>
          SetDataHas (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If SetDataIndex(_setData_, _value_) is ~not-found~, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdataindex" type="abstract operation">
        <h1>
          SetDataIndex (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. Let _size_ be the number of elements in _setData_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _size_,
            1. Let _e_ be _setData_[_index_].
            1. If _e_ is not ~empty~ and _e_ is _value_, then
              1. Return _index_.
            1. Set _index_ to _index_ + 1.
          1. Return ~not-found~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatasize" type="abstract operation">
        <h1>
          SetDataSize (
            _setData_: a List of either ECMAScript language values or ~empty~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _count_ be 0.
          1. For each element _e_ of _setData_, do
            1. If _e_ is not ~empty~, set _count_ to _count_ + 1.
          1. Return _count_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-set-constructor">
      <h1>The Set Constructor</h1>
      <p>The Set constructor:</p>
      <ul>
        <li>is <dfn>%Set%</dfn>.</li>
        <li>is the initial value of the *"Set"* property of the global object.</li>
        <li>creates and initializes a new Set object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Set behaviour must include a `super` call to the Set constructor to create and initialize the subclass instance with the internal state necessary to support the `Set.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-set-iterable">
        <h1>Set ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Set.prototype%"*, « [[SetData]] »).
          1. Set _set_.[[SetData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _set_.
          1. Let _adder_ be ? Get(_set_, *"add"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _set_.
            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Properties of the Set Constructor</h1>
      <p>The Set constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-set.prototype">
        <h1>Set.prototype</h1>
        <p>The initial value of `Set.prototype` is the Set prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-set-@@species" id="sec-get-set-%symbol.species%">
        <h1>get Set [ %Symbol.species% ]</h1>
        <p>`Set[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Methods that create derived collection objects should call %Symbol.species% to determine the constructor to use to create the derived objects. Subclass constructor may over-ride %Symbol.species% to change the default constructor assignment.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-prototype-object">
      <h1>Properties of the Set Prototype Object</h1>
      <p>The <dfn>Set prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Set.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[SetData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-set.prototype.add">
        <h1>Set.prototype.add ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. For each element _e_ of _S_.[[SetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Return _S_.
          1. Append _value_ to _S_.[[SetData]].
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.clear">
        <h1>Set.prototype.clear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. For each element _e_ of _S_.[[SetData]], do
            1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The existing [[SetData]] List is preserved because there may be existing Set Iterator objects that are suspended midway through iterating over that List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.constructor">
        <h1>Set.prototype.constructor</h1>
        <p>The initial value of `Set.prototype.constructor` is %Set%.</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype.delete">
        <h1>Set.prototype.delete ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. For each element _e_ of _S_.[[SetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.difference">
        <h1>Set.prototype.difference ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _resultSetData_ be a copy of _O_.[[SetData]].
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]], then
            1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
            1. Let _index_ be 0.
            1. Repeat, while _index_ &lt; _thisSize_,
              1. Let _e_ be _resultSetData_[_index_].
              1. If _e_ is not ~empty~, then
                1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. If _inOther_ is *true*, then
                  1. Set _resultSetData_[_index_] to ~empty~.
              1. Set _index_ to _index_ + 1.
          1. Else,
            1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. Let _next_ be ~not-started~.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_keysIter_).
              1. If _next_ is not ~done~, then
                1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
                1. Let _valueIndex_ be SetDataIndex(_resultSetData_, _next_).
                1. If _valueIndex_ is not ~not-found~, then
                  1. Set _resultSetData_[_valueIndex_] to ~empty~.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.entries">
        <h1>Set.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateSetIterator(_S_, ~key+value~).
        </emu-alg>
        <emu-note>
          <p>For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.foreach">
        <h1>Set.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _entries_ be _S_.[[SetData]].
          1. Let _numEntries_ be the number of elements in _entries_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _numEntries_,
            1. Let _e_ be _entries_[_index_].
            1. Set _index_ to _index_ + 1.
            1. If _e_ is not ~empty~, then
              1. Perform ? Call(_callback_, _thisArg_, « _e_, _e_, _S_ »).
              1. NOTE: The number of elements in _entries_ may have increased during execution of _callback_.
              1. Set _numEntries_ to the number of elements in _entries_.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `forEach` calls _callback_ once for each value present in the Set object, in value insertion order. _callback_ is called only for values of the Set which actually exist; it is not called for keys that have been deleted from the set.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the first two arguments are a value contained in the Set. The same value is passed for both arguments. The Set object being traversed is passed as the third argument.</p>
          <p>The _callback_ is called with three arguments to be consistent with the call back functions used by `forEach` methods for Map and Array. For Sets, each item value is considered to be both the key and the value.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>Each value is normally visited only once. However, a value will be revisited if it is deleted after it has been visited and then re-added before the `forEach` call completes. Values that are deleted after the call to `forEach` begins and before being visited are not visited unless the value is added again before the `forEach` call completes. New values added after the call to `forEach` begins are visited.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.has">
        <h1>Set.prototype.has ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. For each element _e_ of _S_.[[SetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.intersection">
        <h1>Set.prototype.intersection ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _resultSetData_ be a new empty List.
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]], then
            1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
            1. Let _index_ be 0.
            1. Repeat, while _index_ &lt; _thisSize_,
              1. Let _e_ be _O_.[[SetData]][_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_ is not ~empty~, then
                1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. If _inOther_ is *true*, then
                  1. NOTE: It is possible for earlier calls to _otherRec_.[[Has]] to remove and re-add an element of _O_.[[SetData]], which can cause the same element to be visited twice during this iteration.
                  1. If SetDataHas(_resultSetData_, _e_) is *false*, then
                    1. Append _e_ to _resultSetData_.
                1. NOTE: The number of elements in _O_.[[SetData]] may have increased during execution of _otherRec_.[[Has]].
                1. Set _thisSize_ to the number of elements in _O_.[[SetData]].
          1. Else,
            1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. Let _next_ be ~not-started~.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_keysIter_).
              1. If _next_ is not ~done~, then
                1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
                1. Let _inThis_ be SetDataHas(_O_.[[SetData]], _next_).
                1. If _inThis_ is *true*, then
                  1. NOTE: Because _other_ is an arbitrary object, it is possible for its *"keys"* iterator to produce the same value more than once.
                  1. If SetDataHas(_resultSetData_, _next_) is *false*, then
                    1. Append _next_ to _resultSetData_.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.isdisjointfrom">
        <h1>Set.prototype.isDisjointFrom ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]], then
            1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
            1. Let _index_ be 0.
            1. Repeat, while _index_ &lt; _thisSize_,
              1. Let _e_ be _O_.[[SetData]][_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_ is not ~empty~, then
                1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. If _inOther_ is *true*, return *false*.
                1. NOTE: The number of elements in _O_.[[SetData]] may have increased during execution of _otherRec_.[[Has]].
                1. Set _thisSize_ to the number of elements in _O_.[[SetData]].
          1. Else,
            1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. Let _next_ be ~not-started~.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_keysIter_).
              1. If _next_ is not ~done~, then
                1. If SetDataHas(_O_.[[SetData]], _next_) is *true*, then
                  1. Perform ? IteratorClose(_keysIter_, NormalCompletion(~unused~)).
                  1. Return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issubsetof">
        <h1>Set.prototype.isSubsetOf ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) > _otherRec_.[[Size]], return *false*.
          1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _thisSize_,
            1. Let _e_ be _O_.[[SetData]][_index_].
            1. Set _index_ to _index_ + 1.
            1. If _e_ is not ~empty~, then
              1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
              1. If _inOther_ is *false*, return *false*.
              1. NOTE: The number of elements in _O_.[[SetData]] may have increased during execution of _otherRec_.[[Has]].
              1. Set _thisSize_ to the number of elements in _O_.[[SetData]].
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issupersetof">
        <h1>Set.prototype.isSupersetOf ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) &lt; _otherRec_.[[Size]], return *false*.
          1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_keysIter_).
            1. If _next_ is not ~done~, then
              1. If SetDataHas(_O_.[[SetData]], _next_) is *false*, then
                1. Perform ? IteratorClose(_keysIter_, NormalCompletion(~unused~)).
                1. Return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.keys">
        <h1>Set.prototype.keys ( )</h1>
        <p>The initial value of the *"keys"* property is %Set.prototype.values%, defined in <emu-xref href="#sec-set.prototype.values"></emu-xref>.</p>
        <emu-note>
          <p>For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-set.prototype.size">
        <h1>get Set.prototype.size</h1>
        <p>`Set.prototype.size` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _size_ be SetDataSize(_S_.[[SetData]]).
          1. Return 𝔽(_size_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.symmetricdifference">
        <h1>Set.prototype.symmetricDifference ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. Let _resultSetData_ be a copy of _O_.[[SetData]].
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_keysIter_).
            1. If _next_ is not ~done~, then
              1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
              1. Let _resultIndex_ be SetDataIndex(_resultSetData_, _next_).
              1. If _resultIndex_ is ~not-found~, let _alreadyInResult_ be *false*; otherwise let _alreadyInResult_ be *true*.
              1. If SetDataHas(_O_.[[SetData]], _next_) is *true*, then
                1. If _alreadyInResult_ is *true*, set _resultSetData_[_resultIndex_] to ~empty~.
              1. Else,
                1. If _alreadyInResult_ is *false*, append _next_ to _resultSetData_.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.union">
        <h1>Set.prototype.union ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. Let _resultSetData_ be a copy of _O_.[[SetData]].
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_keysIter_).
            1. If _next_ is not ~done~, then
              1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
              1. If SetDataHas(_resultSetData_, _next_) is *false*, then
                1. Append _next_ to _resultSetData_.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.values">
        <h1>Set.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateSetIterator(_S_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@iterator" id="sec-set.prototype-%symbol.iterator%">
        <h1>Set.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %Set.prototype.values%, defined in <emu-xref href="#sec-set.prototype.values"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@tostringtag" id="sec-set.prototype-%symbol.tostringtag%">
        <h1>Set.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Set"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-set-instances">
      <h1>Properties of Set Instances</h1>
      <p>Set instances are ordinary objects that inherit properties from the Set prototype object. Set instances also have a [[SetData]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-set-iterator-objects">
      <h1>Set Iterator Objects</h1>
      <p>A <dfn variants="Set Iterators,Set Iterator object,Set Iterator objects">Set Iterator</dfn> is an ordinary object, with the structure defined below, that represents a specific iteration over some specific Set instance object. There is not a named constructor for Set Iterator objects. Instead, Set Iterator objects are created by calling certain methods of Set instance objects.</p>

      <emu-clause id="sec-createsetiterator" type="abstract operation" oldids="sec-properties-of-set-iterator-instances,table-51,table-internal-slots-of-set-iterator-instances">
        <h1>
          CreateSetIterator (
            _set_: an ECMAScript language value,
            _kind_: ~key+value~ or ~value~,
          ): either a normal completion containing a Generator or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create iterator objects for Set methods that return such iterators.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:
            1. Let _index_ be 0.
            1. Let _entries_ be _set_.[[SetData]].
            1. Let _numEntries_ be the number of elements in _entries_.
            1. Repeat, while _index_ &lt; _numEntries_,
              1. Let _e_ be _entries_[_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_ is not ~empty~, then
                1. If _kind_ is ~key+value~, then
                  1. Let _result_ be CreateArrayFromList(« _e_, _e_ »).
                  1. Perform ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)).
                1. Else,
                  1. Assert: _kind_ is ~value~.
                  1. Perform ? GeneratorYield(CreateIteratorResultObject(_e_, *false*)).
                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by GeneratorYield.
                1. Set _numEntries_ to the number of elements in _entries_.
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%SetIteratorPrototype%"*, %SetIteratorPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%setiteratorprototype%-object">
        <h1>The %SetIteratorPrototype% Object</h1>
        <p>The <dfn>%SetIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Set Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%setiteratorprototype%.next">
          <h1>%SetIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%SetIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%setiteratorprototype%-@@tostringtag" id="sec-%setiteratorprototype%-%symbol.tostringtag%">
          <h1>%SetIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Set Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap Objects</h1>
    <p>WeakMaps are collections of key/value pairs where the keys are objects and/or symbols and values may be arbitrary ECMAScript language values. A WeakMap may be queried to see if it contains a key/value pair with a specific key, but no mechanism is provided for enumerating the values it holds as keys. In certain conditions, values which are not live are removed as WeakMap keys, as described in <emu-xref href="#sec-weakref-execution"></emu-xref>.</p>
    <p>An implementation may impose an arbitrarily determined latency between the time a key/value pair of a WeakMap becomes inaccessible and the time when the key/value pair is removed from the WeakMap. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to observe a key of a WeakMap that does not require the observer to present the observed key.</p>
    <p>WeakMaps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of key/value pairs in the collection. The data structure used in this specification is only intended to describe the required observable semantics of WeakMaps. It is not intended to be a viable implementation model.</p>
    <emu-note>
      <p>WeakMap and WeakSet are intended to provide mechanisms for dynamically associating state with an object or symbol in a manner that does not “leak” memory resources if, in the absence of the WeakMap or WeakSet instance, the object or symbol otherwise became inaccessible and subject to resource reclamation by the implementation's garbage collection mechanisms. This characteristic can be achieved by using an inverted per-object/symbol mapping of WeakMap or WeakSet instances to keys. Alternatively, each WeakMap or WeakSet instance may internally store its key and value data, but this approach requires coordination between the WeakMap or WeakSet implementation and the garbage collector. The following references describe mechanism that may be useful to implementations of WeakMap and WeakSet:</p>
      <p>Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In <i>Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)</i>, A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183, <a href="http://doi.acm.org/10.1145/263698.263733">http://doi.acm.org/10.1145/263698.263733</a>.</p>
      <p>Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, <a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak">http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak</a></p>
    </emu-note>

    <emu-clause id="sec-weakmap-constructor">
      <h1>The WeakMap Constructor</h1>
      <p>The WeakMap constructor:</p>
      <ul>
        <li>is <dfn>%WeakMap%</dfn>.</li>
        <li>is the initial value of the *"WeakMap"* property of the global object.</li>
        <li>creates and initializes a new WeakMap when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified WeakMap behaviour must include a `super` call to the WeakMap constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakMap.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-weakmap-iterable">
        <h1>WeakMap ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakMap.prototype%"*, « [[WeakMapData]] »).
          1. Set _map_.[[WeakMapData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _map_.
          1. Let _adder_ be ? Get(_map_, *"set"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>If the parameter _iterable_ is present, it is expected to be an object that implements a %Symbol.iterator% method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a WeakMap key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>Properties of the WeakMap Constructor</h1>
      <p>The WeakMap constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype">
        <h1>WeakMap.prototype</h1>
        <p>The initial value of `WeakMap.prototype` is the WeakMap prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-prototype-object">
      <h1>Properties of the WeakMap Prototype Object</h1>
      <p>The <dfn>WeakMap prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%WeakMap.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakMapData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype.constructor">
        <h1>WeakMap.prototype.constructor</h1>
        <p>The initial value of `WeakMap.prototype.constructor` is %WeakMap%.</p>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.delete">
        <h1>WeakMap.prototype.delete ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Key]] to ~empty~.
              1. Set _p_.[[Value]] to ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.get">
        <h1>WeakMap.prototype.get ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, return *undefined*.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.has">
        <h1>WeakMap.prototype.has ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.set">
        <h1>WeakMap.prototype.set ( _key_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, throw a *TypeError* exception.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Value]] to _value_.
              1. Return _M_.
          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. Append _p_ to _M_.[[WeakMapData]].
          1. Return _M_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakmap.prototype-@@tostringtag" id="sec-weakmap.prototype-%symbol.tostringtag%">
        <h1>WeakMap.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"WeakMap"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakmap-instances">
      <h1>Properties of WeakMap Instances</h1>
      <p>WeakMap instances are ordinary objects that inherit properties from the WeakMap prototype object. WeakMap instances also have a [[WeakMapData]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet Objects</h1>
    <p>WeakSets are collections of objects and/or symbols. A distinct object or symbol may only occur once as an element of a WeakSet's collection. A WeakSet may be queried to see if it contains a specific value, but no mechanism is provided for enumerating the values it holds. In certain conditions, values which are not live are removed as WeakSet elements, as described in <emu-xref href="#sec-weakref-execution"></emu-xref>.</p>
    <p>An implementation may impose an arbitrarily determined latency between the time a value contained in a WeakSet becomes inaccessible and the time when the value is removed from the WeakSet. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to determine if a WeakSet contains a particular value that does not require the observer to present the observed value.</p>
    <p>WeakSets must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of WeakSets. It is not intended to be a viable implementation model.</p>
    <emu-note>
      <p>See the NOTE in <emu-xref href="#sec-weakmap-objects"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-weakset-constructor">
      <h1>The WeakSet Constructor</h1>
      <p>The WeakSet constructor:</p>
      <ul>
        <li>is <dfn>%WeakSet%</dfn>.</li>
        <li>is the initial value of the *"WeakSet"* property of the global object.</li>
        <li>creates and initializes a new WeakSet when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified WeakSet behaviour must include a `super` call to the WeakSet constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakSet.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-weakset-iterable">
        <h1>WeakSet ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakSet.prototype%"*, « [[WeakSetData]] »).
          1. Set _set_.[[WeakSetData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _set_.
          1. Let _adder_ be ? Get(_set_, *"add"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _set_.
            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>Properties of the WeakSet Constructor</h1>
      <p>The WeakSet constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weakset.prototype">
        <h1>WeakSet.prototype</h1>
        <p>The initial value of `WeakSet.prototype` is the WeakSet prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-prototype-object">
      <h1>Properties of the WeakSet Prototype Object</h1>
      <p>The <dfn>WeakSet prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%WeakSet.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakSetData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weakset.prototype.add">
        <h1>WeakSet.prototype.add ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If CanBeHeldWeakly(_value_) is *false*, throw a *TypeError* exception.
          1. For each element _e_ of _S_.[[WeakSetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Return _S_.
          1. Append _value_ to _S_.[[WeakSetData]].
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.constructor">
        <h1>WeakSet.prototype.constructor</h1>
        <p>The initial value of `WeakSet.prototype.constructor` is %WeakSet%.</p>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.delete">
        <h1>WeakSet.prototype.delete ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.
          1. For each element _e_ of _S_.[[WeakSetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Replace the element of _S_.[[WeakSetData]] whose value is _e_ with an element whose value is ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.has">
        <h1>WeakSet.prototype.has ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.
          1. For each element _e_ of _S_.[[WeakSetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakset.prototype-@@tostringtag" id="sec-weakset.prototype-%symbol.tostringtag%">
        <h1>WeakSet.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"WeakSet"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakset-instances">
      <h1>Properties of WeakSet Instances</h1>
      <p>WeakSet instances are ordinary objects that inherit properties from the WeakSet prototype object. WeakSet instances also have a [[WeakSetData]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-keyed-collections">
    <h1>Abstract Operations for Keyed Collections</h1>

    <emu-clause id="sec-canonicalizekeyedcollectionkey" type="abstract operation">
      <h1>
        CanonicalizeKeyedCollectionKey (
          _key_: an ECMAScript language value,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _key_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
        1. Return _key_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>Structured Data</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer Objects</h1>

    <emu-clause id="sec-arraybuffer-notation">
      <h1>Notation</h1>
      <p>The descriptions below in this section, <emu-xref href="#sec-atomics-object"></emu-xref>, and <emu-xref href="#sec-memory-model"></emu-xref> use the read-modify-write modification function internal data structure.</p>
      <p>A <dfn variants="read-modify-write modification functions">read-modify-write modification function</dfn> is a mathematical function that is represented as an abstract closure that takes two Lists of byte values as arguments and returns a List of byte values. These abstract closures satisfy all of the following properties:</p>
      <ul>
        <li>They perform all their algorithm steps atomically.</li>
        <li>Their individual algorithm steps are not observable.</li>
      </ul>
      <emu-note>
        <p>To aid verifying that a read-modify-write modification function's algorithm steps constitute a pure, mathematical function, the following editorial conventions are recommended:</p>
        <ul>
          <li>They do not access, directly or transitively via invoked abstract operations and abstract closures, any language or specification values except their parameters and captured values.</li>
          <li>They do not invoke, directly or transitively, abstract operations and abstract closures that return Completion Records.</li>
          <li>They do not return Completion Records.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-fixed-length-and-resizable-arraybuffer-objects">
      <h1>Fixed-length and Resizable ArrayBuffer Objects</h1>
      <p>A <dfn>fixed-length ArrayBuffer</dfn> is an ArrayBuffer whose byte length cannot change after creation.</p>
      <p>A <dfn>resizable ArrayBuffer</dfn> is an ArrayBuffer whose byte length may change after creation via calls to <emu-xref href="#sec-arraybuffer.prototype.resize" title></emu-xref>.</p>
      <p>The kind of ArrayBuffer object that is created depends on the arguments passed to <emu-xref href="#sec-arraybuffer-length" title></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-arraybuffer-objects">
      <h1>Abstract Operations For ArrayBuffer Objects</h1>

      <emu-clause id="sec-allocatearraybuffer" type="abstract operation">
        <h1>
          AllocateArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create an ArrayBuffer.</dd>
        </dl>
        <emu-alg>
          1. Let _slots_ be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».
          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingResizableBuffer_ be *true*; otherwise let _allocatingResizableBuffer_ be *false*.
          1. If _allocatingResizableBuffer_ is *true*, then
            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.
            1. Append [[ArrayBufferMaxByteLength]] to _slots_.
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, _slots_).
          1. Let _block_ be ? CreateByteDataBlock(_byteLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. If _allocatingResizableBuffer_ is *true*, then
            1. If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.
            1. NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations may throw if, for example, virtual memory cannot be reserved up front.
            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybufferbytelength" type="abstract operation">
        <h1>
          ArrayBufferByteLength (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _order_: ~seq-cst~ or ~unordered~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then
            1. Let _bufferByteLengthBlock_ be _arrayBuffer_.[[ArrayBufferByteLengthData]].
            1. Let _rawLength_ be GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_).
            1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
            1. Return ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)).
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Return _arrayBuffer_.[[ArrayBufferByteLength]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffercopyanddetach" type="abstract operation">
        <h1>
          ArrayBufferCopyAndDetach (
            _arrayBuffer_: an ECMAScript language value,
            _newLength_: an ECMAScript language value,
            _preserveResizability_: ~preserve-resizability~ or ~fixed-length~,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.
          1. If _newLength_ is *undefined*, then
            1. Let _newByteLength_ be _arrayBuffer_.[[ArrayBufferByteLength]].
          1. Else,
            1. Let _newByteLength_ be ? ToIndex(_newLength_).
          1. If IsDetachedBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.
          1. If _preserveResizability_ is ~preserve-resizability~ and IsFixedLengthArrayBuffer(_arrayBuffer_) is *false*, then
            1. Let _newMaxByteLength_ be _arrayBuffer_.[[ArrayBufferMaxByteLength]].
          1. Else,
            1. Let _newMaxByteLength_ be ~empty~.
          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not *undefined*, throw a *TypeError* exception.
          1. Let _newBuffer_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta>.
          1. Let _copyLength_ be min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]).
          1. Let _fromBlock_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _toBlock_ be _newBuffer_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).
          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a `realloc`.
          1. Perform ! DetachArrayBuffer(_arrayBuffer_).
          1. Return _newBuffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdetachedbuffer" type="abstract operation">
        <h1>
          IsDetachedBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-detacharraybuffer" type="abstract operation">
        <h1>
          DetachArrayBuffer (
            _arrayBuffer_: an ArrayBuffer,
            optional _key_: anything,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>skip global checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.
          1. If _key_ is not present, set _key_ to *undefined*.
          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not _key_, throw a *TypeError* exception.
          1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.
          1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>Detaching an ArrayBuffer instance disassociates the Data Block used as its backing store from the instance and sets the byte length of the buffer to 0.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-clonearraybuffer" type="abstract operation">
        <h1>
          CloneArrayBuffer (
            _srcBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _srcByteOffset_: a non-negative integer,
            _srcLength_: a non-negative integer,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It creates a new ArrayBuffer whose data is a copy of _srcBuffer_'s data over the range starting at _srcByteOffset_ and continuing for _srcLength_ bytes.</dd>
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_srcBuffer_) is *false*.
          1. Let _targetBuffer_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta>.
          1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].
          1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).
          1. Return _targetBuffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
        <h1>
          GetArrayBufferMaxByteLengthOption (
            _options_: an ECMAScript language value,
          ): either a normal completion containing either a non-negative integer or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _options_ is not an Object, return ~empty~.
          1. Let _maxByteLength_ be ? Get(_options_, *"maxByteLength"*).
          1. If _maxByteLength_ is *undefined*, return ~empty~.
          1. Return ? ToIndex(_maxByteLength_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation">
        <h1>
          HostResizeArrayBuffer (
            _buffer_: an ArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It gives the host an opportunity to perform implementation-defined resizing of _buffer_. If the host chooses not to handle resizing of _buffer_, it may return ~unhandled~ for the default behaviour.</dd>
        </dl>

        <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
        <ul>
          <li>The abstract operation does not detach _buffer_.</li>
          <li>If the abstract operation completes normally with ~handled~, _buffer_.[[ArrayBufferByteLength]] is _newByteLength_.</li>
        </ul>

        <p>The default implementation of HostResizeArrayBuffer is to return NormalCompletion(~unhandled~).</p>
      </emu-clause>

      <emu-clause id="sec-isfixedlengtharraybuffer" type="abstract operation">
        <h1>
          IsFixedLengthArrayBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _arrayBuffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunsignedelementtype" type="abstract operation">
        <h1>
          IsUnsignedElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It verifies if the argument _type_ is an unsigned TypedArray element type.</dd>
        </dl>
        <emu-alg>
          1. If _type_ is one of ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, or ~biguint64~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunclampedintegerelementtype" type="abstract operation">
        <h1>
          IsUnclampedIntegerElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It verifies if the argument _type_ is an Integer TypedArray element type not including ~uint8clamped~.</dd>
        </dl>
        <emu-alg>
          1. If _type_ is one of ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, or ~uint32~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isbigintelementtype" type="abstract operation">
        <h1>
          IsBigIntElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It verifies if the argument _type_ is a BigInt TypedArray element type.</dd>
        </dl>
        <emu-alg>
          1. If _type_ is either ~biguint64~ or ~bigint64~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isnotearconfiguration" type="abstract operation">
        <h1>
          IsNoTearConfiguration (
            _type_: a TypedArray element type,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If IsUnclampedIntegerElementType(_type_) is *true*, return *true*.
          1. If IsBigIntElementType(_type_) is *true* and _order_ is neither ~init~ nor ~unordered~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rawbytestonumeric" type="abstract operation" oldids="sec-rawbytestonumber">
        <h1>
          RawBytesToNumeric (
            _type_: a TypedArray element type,
            _rawBytes_: a List of byte values,
            _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. If _type_ is ~float16~, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary16 value.
            1. If _value_ is a NaN, return *NaN*.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is ~float32~, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.
            1. If _value_ is a NaN, return *NaN*.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is ~float64~, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.
            1. If _value_ is a NaN, return *NaN*.
            1. Return the Number value that corresponds to _value_.
          1. If IsUnsignedElementType(_type_) is *true*, then
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
          1. Else,
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ × 8.
          1. If IsBigIntElementType(_type_) is *true*, return the BigInt value that corresponds to _intValue_.
          1. Otherwise, return the Number value that corresponds to _intValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getrawbytesfromsharedblock" type="abstract operation">
        <h1>
          GetRawBytesFromSharedBlock (
            _block_: a Shared Data Block,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
          1. Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.
          1. Append _readEvent_ to _eventsRecord_.[[EventList]].
          1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].
          1. Return _rawValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvaluefrombuffer" type="abstract operation">
        <h1>
          GetValueFromBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
            optional _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Assert: _block_ is a Shared Data Block.
            1. Let _rawValue_ be GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_).
          1. Else,
            1. Let _rawValue_ be a List whose elements are bytes from _block_ at indices in the interval from _byteIndex_ (inclusive) to _byteIndex_ + _elementSize_ (exclusive).
          1. Assert: The number of elements in _rawValue_ is _elementSize_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numerictorawbytes" type="abstract operation" oldids="sec-numbertorawbytes">
        <h1>
          NumericToRawBytes (
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isLittleEndian_: a Boolean,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _type_ is ~float16~, then
            1. Let _rawBytes_ be a List whose elements are the 2 bytes that are the result of converting _value_ to IEEE 754-2019 binary16 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary16 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is ~float32~, then
            1. Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is ~float64~, then
            1. Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else,
            1. Let _n_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
            1. Let _conversionOperation_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
            1. Let _intValue_ be ℝ(! _conversionOperation_(_value_)).
            1. If _intValue_ ≥ 0, then
              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. The bytes are ordered in little endian order.
            1. Else,
              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. The bytes are ordered in little endian order.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. Return _rawBytes_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setvalueinbuffer" type="abstract operation">
        <h1>
          SetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
            optional _isLittleEndian_: a Boolean,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
            1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventsRecord_.[[EventList]].
          1. Else,
            1. Store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" type="abstract operation">
        <h1>
          GetModifySetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _op_: a read-modify-write modification function,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
            1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
            1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.
            1. Append _rmwEvent_ to _eventsRecord_.[[EventList]].
            1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
          1. Else,
            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].
            1. Let _rawBytesModified_ be _op_(_rawBytesRead_, _rawBytes_).
            1. Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].
          1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arraybuffer-constructor">
      <h1>The ArrayBuffer Constructor</h1>
      <p>The ArrayBuffer constructor:</p>
      <ul>
        <li>is <dfn>%ArrayBuffer%</dfn>.</li>
        <li>is the initial value of the *"ArrayBuffer"* property of the global object.</li>
        <li>creates and initializes a new ArrayBuffer when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified ArrayBuffer behaviour must include a `super` call to the ArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `ArrayBuffer.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-arraybuffer-length">
        <h1>ArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _byteLength_ be ? ToIndex(_length_).
          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).
          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>Properties of the ArrayBuffer Constructor</h1>
      <p>The ArrayBuffer constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-arraybuffer.isview">
        <h1>ArrayBuffer.isView ( _arg_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _arg_ is not an Object, return *false*.
          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype">
        <h1>ArrayBuffer.prototype</h1>
        <p>The initial value of `ArrayBuffer.prototype` is the ArrayBuffer prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-arraybuffer-@@species" id="sec-get-arraybuffer-%symbol.species%">
        <h1>get ArrayBuffer [ %Symbol.species% ]</h1>
        <p>`ArrayBuffer[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p><emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> normally uses its *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour for the <emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> method by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>Properties of the ArrayBuffer Prototype Object</h1>
      <p>The <dfn>ArrayBuffer prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%ArrayBuffer.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength</h1>
        <p>`ArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.constructor">
        <h1>ArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `ArrayBuffer.prototype.constructor` is %ArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.detached">
        <h1>get ArrayBuffer.prototype.detached</h1>
        <p>`ArrayBuffer.prototype.detached` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Return IsDetachedBuffer(_O_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
        <h1>get ArrayBuffer.prototype.maxByteLength</h1>
        <p>`ArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.
          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then
            1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Else,
            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.resizable">
        <h1>get ArrayBuffer.prototype.resizable</h1>
        <p>`ArrayBuffer.prototype.resizable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.resize">
        <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _newByteLength_ be ? ToIndex(_newLength_).
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
          1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).
          1. If _hostHandled_ is ~handled~, return *undefined*.
          1. Let _oldBlock_ be _O_.[[ArrayBufferData]].
          1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).
          1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
          1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).
          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as in-place growth or shrinkage.
          1. Set _O_.[[ArrayBufferData]] to _newBlock_.
          1. Set _O_.[[ArrayBufferByteLength]] to _newByteLength_.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _len_ be _O_.[[ArrayBufferByteLength]].
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _first_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _first_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).
          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.
          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
          1. NOTE: Side-effects of the above steps may have detached or resized _O_.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Let _currentLen_ be _O_.[[ArrayBufferByteLength]].
          1. If _first_ &lt; _currentLen_, then
            1. Let _count_ be min(_newLen_, _currentLen_ - _first_).
            1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfer">
        <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfertofixedlength">
        <h1>ArrayBuffer.prototype.transferToFixedLength ( [ _newLength_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-arraybuffer.prototype-@@tostringtag" id="sec-arraybuffer.prototype-%symbol.tostringtag%">
        <h1>ArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"ArrayBuffer"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-instances">
      <h1>Properties of ArrayBuffer Instances</h1>
      <p>ArrayBuffer instances inherit properties from the ArrayBuffer prototype object. ArrayBuffer instances each have an [[ArrayBufferData]] internal slot, an [[ArrayBufferByteLength]] internal slot, and an [[ArrayBufferDetachKey]] internal slot. ArrayBuffer instances which are resizable each have an [[ArrayBufferMaxByteLength]] internal slot.</p>
      <p>ArrayBuffer instances whose [[ArrayBufferData]] is *null* are considered to be detached and all operators to access or modify data contained in the ArrayBuffer instance will fail.</p>
      <p>ArrayBuffer instances whose [[ArrayBufferDetachKey]] is set to a value other than *undefined* need to have all DetachArrayBuffer calls passing that same "detach key" as an argument, otherwise a TypeError will result. This internal slot is only ever set by certain embedding environments, not by algorithms in this specification.</p>
    </emu-clause>

    <emu-clause id="sec-resizable-arraybuffer-guidelines">
      <h1>Resizable ArrayBuffer Guidelines</h1>
      <emu-note>
        <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer.</p>
        <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differs greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
        <p>When choosing a value for the *"maxByteLength"* option for resizable ArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that *"maxByteLength"* does not exceed 1,073,741,824 (2<sup>30</sup> bytes or 1GiB).</p>
        <p>Please note that successfully constructing a resizable ArrayBuffer for a particular maximum size does not guarantee that future resizes will succeed.</p>
      </emu-note>

      <emu-note>
        <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
        <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the constructor's *"maxByteLength"* option.</p>
        <p>If a host is multi-tenanted (i.e. it runs many ECMAScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of *"maxByteLength"* ≥ 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risk.</p>
        <p>If a host does not have virtual memory, such as those running on embedded devices without an MMU, or if a host only implements resizing by copying, it may accept any <emu-not-ref>Number value for</emu-not-ref> the *"maxByteLength"* option. However, we recommend a *RangeError* be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximum amount of usable memory on the device.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-fixed-length-and-growable-sharedarraybuffer-objects">
      <h1>Fixed-length and Growable SharedArrayBuffer Objects</h1>
      <p>A <dfn>fixed-length SharedArrayBuffer</dfn> is a SharedArrayBuffer whose byte length cannot change after creation.</p>
      <p>A <dfn>growable SharedArrayBuffer</dfn> is a SharedArrayBuffer whose byte length may increase after creation via calls to <emu-xref href="#sec-sharedarraybuffer.prototype.grow" title></emu-xref>.</p>
      <p>The kind of SharedArrayBuffer object that is created depends on the arguments passed to <emu-xref href="#sec-sharedarraybuffer-length" title></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects">
      <h1>Abstract Operations for SharedArrayBuffer Objects</h1>

      <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation">
        <h1>
          AllocateSharedArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): either a normal completion containing a SharedArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create a SharedArrayBuffer.</dd>
        </dl>
        <emu-alg>
          1. Let _slots_ be « [[ArrayBufferData]] ».
          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingGrowableBuffer_ be *true*; otherwise let _allocatingGrowableBuffer_ be *false*.
          1. If _allocatingGrowableBuffer_ is *true*, then
            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.
            1. Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.
          1. Else,
            1. Append [[ArrayBufferByteLength]] to _slots_.
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, _slots_).
          1. If _allocatingGrowableBuffer_ is *true*, let _allocLength_ be _maxByteLength_; otherwise let _allocLength_ be _byteLength_.
          1. Let _block_ be ? CreateSharedByteDataBlock(_allocLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. If _allocatingGrowableBuffer_ is *true*, then
            1. Assert: _byteLength_ ≤ _maxByteLength_.
            1. Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).
            1. Perform SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~).
            1. Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.
            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.
          1. Else,
            1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issharedarraybuffer" type="abstract operation">
        <h1>
          IsSharedArrayBuffer (
            _obj_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It tests whether an object is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either.</dd>
        </dl>
        <emu-alg>
          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].
          1. If _bufferData_ is *null*, return *false*.
          1. If _bufferData_ is a Data Block, return *false*.
          1. Assert: _bufferData_ is a Shared Data Block.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation">
        <h1>
          HostGrowSharedArrayBuffer (
            _buffer_: a SharedArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It gives the host an opportunity to perform implementation-defined growing of _buffer_. If the host chooses not to handle growing of _buffer_, it may return ~unhandled~ for the default behaviour.</dd>
        </dl>
        <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
        <ul>
          <li>If the abstract operation does not complete normally with ~unhandled~, and _newByteLength_ &lt; the current byte length of the _buffer_ or _newByteLength_ > _buffer_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.</li>
          <li>Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record. If the abstract operation completes normally with ~handled~, a WriteSharedMemory or ReadModifyWriteSharedMemory event whose [[Order]] is ~seq-cst~, [[Payload]] is NumericToRawBytes(~biguint64~, _newByteLength_, _isLittleEndian_), [[Block]] is _buffer_.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and [[ElementSize]] is 8 is added to the surrounding agent's candidate execution such that racing calls to `SharedArrayBuffer.prototype.grow` are not "lost", i.e. silently do nothing.</li>
        </ul>

        <emu-note>
          <p>The second requirement above is intentionally vague about how or when the current byte length of _buffer_ is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such, SharedArrayBuffer.prototype.grow itself does not perform bounds checking on _newByteLength_ before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.</p>
          <p>This is in contrast with HostResizeArrayBuffer, which is guaranteed that the value of _newByteLength_ is ≥ 0 and ≤ _buffer_.[[ArrayBufferMaxByteLength]].</p>
        </emu-note>

        <p>The default implementation of HostGrowSharedArrayBuffer is to return NormalCompletion(~unhandled~).</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer-constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor:</p>
      <ul>
        <li>is <dfn>%SharedArrayBuffer%</dfn>.</li>
        <li>is the initial value of the *"SharedArrayBuffer"* property of the global object, if that property is present (see below).</li>
        <li>creates and initializes a new SharedArrayBuffer when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a `super` call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `SharedArrayBuffer.prototype` built-in methods.</li>
      </ul>

      <p>Whenever a host does not provide concurrent access to SharedArrayBuffers it may omit the *"SharedArrayBuffer"* property of the global object.</p>

      <emu-note>
        <p>Unlike an `ArrayBuffer`, a `SharedArrayBuffer` cannot become detached, and its internal [[ArrayBufferData]] slot is never *null*.</p>
      </emu-note>

      <emu-clause id="sec-sharedarraybuffer-length">
        <h1>SharedArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _byteLength_ be ? ToIndex(_length_).
          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).
          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>Properties of the SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-sharedarraybuffer.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>The initial value of `SharedArrayBuffer.prototype` is the SharedArrayBuffer prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer-@@species" id="sec-sharedarraybuffer-%symbol.species%">
        <h1>get SharedArrayBuffer [ %Symbol.species% ]</h1>
        <p>`SharedArrayBuffer[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object">
      <h1>Properties of the SharedArrayBuffer Prototype Object</h1>
      <p>The <dfn>SharedArrayBuffer prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%SharedArrayBuffer.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>
        <p>`SharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _length_ be ArrayBufferByteLength(_O_, ~seq-cst~).
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `SharedArrayBuffer.prototype.constructor` is %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.grow">
        <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _newByteLength_ be ? ToIndex(_newLength_).
          1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).
          1. If _hostHandled_ is ~handled~, return *undefined*.
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
          1. Let _currentByteLengthRawBytes_ be GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~).
          1. Let _newByteLengthRawBytes_ be NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_).
          1. Repeat,
            1. NOTE: This is a compare-and-exchange loop to ensure that parallel, racing grows of the same buffer are totally ordered, are not lost, and do not silently do nothing. The loop exits if it was able to attempt to grow uncontended.
            1. Let _currentByteLength_ be ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)).
            1. If _newByteLength_ = _currentByteLength_, return *undefined*.
            1. If _newByteLength_ &lt; _currentByteLength_ or _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
            1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.
            1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, throw a *RangeError* exception.
            1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step captures the requirement that implementations that run out of memory must throw a *RangeError*.
            1. Let _readByteLengthRawBytes_ be AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_).
            1. If ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) is *true*, return *undefined*.
            1. Set _currentByteLengthRawBytes_ to _readByteLengthRawBytes_.
        </emu-alg>
        <emu-note>
          <p>Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a ReadModifyWriteSharedMemory event (i.e. a successful compare-exchange) is always added into the candidate execution.</p>
          <p>Parallel calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls: `sab.grow(10)` and `sab.grow(20)`. One of the two calls is guaranteed to win the race. The call to `sab.grow(10)` will never shrink `sab` even if `sab.grow(20)` happened first; in that case it will instead throw a RangeError.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
        <h1>get SharedArrayBuffer.prototype.growable</h1>
        <p>`SharedArrayBuffer.prototype.growable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
        <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
        <p>`SharedArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then
            1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Else,
            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _len_ be ArrayBufferByteLength(_O_, ~seq-cst~).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _first_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _first_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).
          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferData]] is _O_.[[ArrayBufferData]], throw a *TypeError* exception.
          1. If ArrayBufferByteLength(_new_, ~seq-cst~) &lt; _newLen_, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer.prototype.toString,sec-sharedarraybuffer.prototype-@@tostringtag" id="sec-sharedarraybuffer.prototype-%symbol.tostringtag%">
        <h1>SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"SharedArrayBuffer"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-instances">
      <h1>Properties of SharedArrayBuffer Instances</h1>
      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot. SharedArrayBuffer instances which are not growable each have an [[ArrayBufferByteLength]] internal slot. SharedArrayBuffer instances which are growable each have an [[ArrayBufferByteLengthData]] internal slot and an [[ArrayBufferMaxByteLength]] internal slot.</p>

      <emu-note>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-growable-sharedarraybuffer-guidelines">
      <h1>Growable SharedArrayBuffer Guidelines</h1>
      <emu-note>
        <p>The following are guidelines for ECMAScript programmers working with growable SharedArrayBuffer.</p>
        <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
        <p>When choosing a value for the *"maxByteLength"* option for growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that *"maxByteLength"* does not exceed 1073741824, or 1GiB.</p>
        <p>Please note that successfully constructing a growable SharedArrayBuffer for a particular maximum size does not guarantee that future grows will succeed.</p>
        <p>Not all loads of a growable SharedArrayBuffer's length are synchronizing ~seq-cst~ loads. Loads of the length that are for bounds-checking of an integer-indexed property access, e.g. `u8[idx]`, are not synchronizing. In general, in the absence of explicit synchronization, one property access being in-bound does not imply a subsequent property access in the same agent is also in-bound. In contrast, explicit loads of the length via the `length` and `byteLength` getters on SharedArrayBuffer, %TypedArray%.prototype, and DataView.prototype are synchronizing. Loads of the length that are performed by built-in methods to check if a TypedArray is entirely out-of-bounds are also synchronizing.</p>
      </emu-note>

      <emu-note>
        <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
        <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
        <p>Because grow operations can happen in parallel with memory accesses on a growable SharedArrayBuffer, the constraints of the memory model require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
        <p>Grown memory must appear zeroed from the moment of its creation, including to any racy accesses in parallel. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.</p>
        <p>Integer-indexed property access on TypedArray views of growable SharedArrayBuffers is intended to be optimizable similarly to access on TypedArray views of non-growable SharedArrayBuffers, because integer-indexed property loads on are not synchronizing on the underlying buffer's length (see programmer guidelines above). For example, bounds checks for property accesses may still be hoisted out of loops.</p>
        <p>In practice it is difficult to implement growable SharedArrayBuffer by copying on hosts that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such hosts may significantly differ from that of hosts with virtual memory. Such hosts should clearly communicate memory usage expectations to users.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView Objects</h1>

    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>Abstract Operations For DataView Objects</h1>

      <emu-clause id="sec-dataview-with-buffer-witness-records">
        <h1>DataView With Buffer Witness Records</h1>
        <p>A <dfn variants="DataView With Buffer Witness Records">DataView With Buffer Witness Record</dfn> is a Record value used to encapsulate a DataView along with a cached byte length of the viewed buffer. It is used to help ensure there is a single shared memory read event of the byte length data block when the viewed buffer is a growable SharedArrayBuffers.</p>
        <p>DataView With Buffer Witness Records have the fields listed in <emu-xref href="#table-dataview-with-buffer-witness-record-fields"></emu-xref>.</p>
        <emu-table id="table-dataview-with-buffer-witness-record-fields" caption="DataView With Buffer Witness Record Fields">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a DataView
              </td>
              <td>
                The DataView object whose buffer's byte length is loaded.
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                The byte length of the object's [[ViewedArrayBuffer]] when the Record was created.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-makedataviewwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeDataViewWithBufferWitnessRecord (
            _obj_: a DataView,
            _order_: ~seq-cst~ or ~unordered~,
          ): a DataView With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, then
            1. Let _byteLength_ be ~detached~.
          1. Else,
            1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).
          1. Return the DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewbytelength" type="abstract operation">
        <h1>
          GetViewByteLength (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsViewOutOfBounds(_viewRecord_) is *false*.
          1. Let _view_ be _viewRecord_.[[Object]].
          1. If _view_.[[ByteLength]] is not ~auto~, return _view_.[[ByteLength]].
          1. Assert: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) is *false*.
          1. Let _byteOffset_ be _view_.[[ByteOffset]].
          1. Let _byteLength_ be _viewRecord_.[[CachedBufferByteLength]].
          1. Assert: _byteLength_ is not ~detached~.
          1. Return _byteLength_ - _byteOffset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isviewoutofbounds" type="abstract operation">
        <h1>
          IsViewOutOfBounds (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _view_ be _viewRecord_.[[Object]].
          1. Let _bufferByteLength_ be _viewRecord_.[[CachedBufferByteLength]].
          1. Assert: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.
          1. If _bufferByteLength_ is ~detached~, return *true*.
          1. Let _byteOffsetStart_ be _view_.[[ByteOffset]].
          1. If _view_.[[ByteLength]] is ~auto~, then
            1. Let _byteOffsetEnd_ be _bufferByteLength_.
          1. Else,
            1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _view_.[[ByteLength]].
          1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.
          1. NOTE: 0-length DataViews are not considered out-of-bounds.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewvalue" type="abstract operation">
        <h1>
          GetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
          ): either a normal completion containing either a Number or a BigInt, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used by functions on DataView instances to retrieve values from the view's buffer.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Return GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setviewvalue" type="abstract operation">
        <h1>
          SetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
            _value_: an ECMAScript language value,
          ): either a normal completion containing *undefined* or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used by functions on DataView instances to store values into the view's buffer.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. If IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).
          1. Otherwise, let _numberValue_ be ? ToNumber(_value_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Perform SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-dataview-constructor">
      <h1>The DataView Constructor</h1>
      <p>The DataView constructor:</p>
      <ul>
        <li>is <dfn>%DataView%</dfn>.</li>
        <li>is the initial value of the *"DataView"* property of the global object.</li>
        <li>creates and initializes a new DataView when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified DataView behaviour must include a `super` call to the DataView constructor to create and initialize subclass instances with the internal state necessary to support the `DataView.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
        <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).
          1. Let _offset_ be ? ToIndex(_byteOffset_).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).
          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.
          1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).
          1. If _byteLength_ is *undefined*, then
            1. If _bufferIsFixedLength_ is *true*, then
              1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.
            1. Else,
              1. Let _viewByteLength_ be ~auto~.
          1. Else,
            1. Let _viewByteLength_ be ? ToIndex(_byteLength_).
            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Set _bufferByteLength_ to ArrayBufferByteLength(_buffer_, ~seq-cst~).
          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.
          1. If _byteLength_ is not *undefined*, then
            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.
          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
          1. Set _O_.[[ByteLength]] to _viewByteLength_.
          1. Set _O_.[[ByteOffset]] to _offset_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>Properties of the DataView Constructor</h1>
      <p>The DataView constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-dataview.prototype">
        <h1>DataView.prototype</h1>
        <p>The initial value of `DataView.prototype` is the DataView prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-prototype-object">
      <h1>Properties of the DataView Prototype Object</h1>
      <p>The <dfn>DataView prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%DataView.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], or [[ByteOffset]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-dataview.prototype.buffer">
        <h1>get DataView.prototype.buffer</h1>
        <p>`DataView.prototype.buffer` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.bytelength">
        <h1>get DataView.prototype.byteLength</h1>
        <p>`DataView.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _size_ be GetViewByteLength(_viewRecord_).
          1. Return 𝔽(_size_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.byteoffset">
        <h1>get DataView.prototype.byteOffset</h1>
        <p>`DataView.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Return 𝔽(_offset_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.constructor">
        <h1>DataView.prototype.constructor</h1>
        <p>The initial value of `DataView.prototype.constructor` is %DataView%.</p>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbigint64">
        <h1>DataView.prototype.getBigInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbiguint64">
        <h1>DataView.prototype.getBigUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat16">
        <h1>DataView.prototype.getFloat16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat32">
        <h1>DataView.prototype.getFloat32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat64">
        <h1>DataView.prototype.getFloat64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint8">
        <h1>DataView.prototype.getInt8 ( _byteOffset_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, *true*, ~int8~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint16">
        <h1>DataView.prototype.getInt16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint32">
        <h1>DataView.prototype.getInt32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint8">
        <h1>DataView.prototype.getUint8 ( _byteOffset_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, *true*, ~uint8~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint16">
        <h1>DataView.prototype.getUint16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint32">
        <h1>DataView.prototype.getUint32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbigint64">
        <h1>DataView.prototype.setBigInt64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbiguint64">
        <h1>DataView.prototype.setBigUint64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat16">
        <h1>DataView.prototype.setFloat16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat32">
        <h1>DataView.prototype.setFloat32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat64">
        <h1>DataView.prototype.setFloat64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint8">
        <h1>DataView.prototype.setInt8 ( _byteOffset_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, *true*, ~int8~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint16">
        <h1>DataView.prototype.setInt16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint32">
        <h1>DataView.prototype.setInt32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint8">
        <h1>DataView.prototype.setUint8 ( _byteOffset_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, *true*, ~uint8~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint16">
        <h1>DataView.prototype.setUint16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint32">
        <h1>DataView.prototype.setUint32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-dataview.prototype-@@tostringtag" id="sec-dataview.prototype-%symbol.tostringtag%">
        <h1>DataView.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"DataView"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-dataview-instances">
      <h1>Properties of DataView Instances</h1>
      <p>DataView instances are ordinary objects that inherit properties from the DataView prototype object. DataView instances each have [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal slots.</p>
      <emu-note>
        <p>The value of the [[DataView]] internal slot is not used within this specification. The simple presence of that internal slot is used within the specification to identify objects created using the DataView constructor.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics-object">
    <h1>The Atomics Object</h1>
    <p>The Atomics object:</p>
    <ul>
      <li>is <dfn>%Atomics%</dfn>.</li>
      <li>is the initial value of the *"Atomics"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events. When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs. The rules that govern shared-memory communication are provided by the memory model, defined below.</p>
    <emu-note>
      <p>For informative guidelines for programming and implementing shared memory in ECMAScript, please see the notes at the end of the memory model section.</p>
    </emu-note>

    <emu-clause id="sec-waiter-record">
      <h1>Waiter Record</h1>
      <p>A <dfn variants="Waiter Records">Waiter Record</dfn> is a Record value used to denote a particular call to `Atomics.wait` or `Atomics.waitAsync`.</p>
      <p>A Waiter Record has fields listed in <emu-xref href="#table-waiterrecord"></emu-xref>.</p>
      <emu-table id="table-waiterrecord" caption="Waiter Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[AgentSignifier]]
            </td>
            <td>
              an agent signifier
            </td>
            <td>
              The agent that called `Atomics.wait` or `Atomics.waitAsync`.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            </td>
            <td>
              a PromiseCapability Record or ~blocking~
            </td>
            <td>
              If denoting a call to `Atomics.waitAsync`, the resulting promise, otherwise ~blocking~.
            </td>
          </tr>
          <tr>
            <td>
              [[TimeoutTime]]
            </td>
            <td>
              a non-negative extended mathematical value
            </td>
            <td>
              The earliest time by which timeout may be triggered; computed using time values.
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            </td>
            <td>
              *"ok"* or *"timed-out"*
            </td>
            <td>
              The return value of the call.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-waiterlist-records" oldids="sec-waiterlist-objects">
      <h1>WaiterList Records</h1>
      <p>A <dfn variants="WaiterList Records">WaiterList Record</dfn> is used to explain waiting and notification of agents via `Atomics.wait`, `Atomics.waitAsync`, and `Atomics.notify`.</p>
      <p>A WaiterList Record has fields listed in <emu-xref href="#table-waiterlistrecord"></emu-xref>.</p>
      <emu-table id="table-waiterlistrecord" caption="WaiterList Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Waiters]]
            </td>
            <td>
              a List of Waiter Records
            </td>
            <td>
              The calls to `Atomics.wait` or `Atomics.waitAsync` that are waiting on the location with which this WaiterList is associated.
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            </td>
            <td>
              a Synchronize event or ~empty~
            </td>
            <td>
              The event of the most recent leaving of its critical section, or ~empty~ if its critical section has never been entered.
            </td>
          </tr>
        </table>
      </emu-table>
      <p>There can be multiple Waiter Records in a WaiterList with the same agent signifier.</p>
      <p>The agent cluster has a store of WaiterList Records; the store is indexed by (_block_, _i_), where _block_ is a Shared Data Block and _i_ a byte offset into the memory of _block_. WaiterList Records are agent-independent: a lookup in the store of WaiterList Records by (_block_, _i_) will result in the same WaiterList Record in any agent in the agent cluster.</p>
      <p>Each WaiterList Record has a <dfn variants="critical sections">critical section</dfn> that controls exclusive access to that WaiterList Record during evaluation. Only a single agent may enter a WaiterList Record's critical section at one time. Entering and leaving a WaiterList Record's critical section is controlled by the abstract operations EnterCriticalSection and LeaveCriticalSection. Operations on a WaiterList Record—adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, setting and retrieving the Synchronize event—may only be performed by agents that have entered the WaiterList Record's critical section.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-atomics">
      <h1>Abstract Operations for Atomics</h1>

      <emu-clause id="sec-validateintegertypedarray" type="abstract operation" oldids="sec-validatesharedintegertypedarray">
        <h1>
          ValidateIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _waitable_: a Boolean,
          ): either a normal completion containing a TypedArray With Buffer Witness Record, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _taRecord_ be ? ValidateTypedArray(_typedArray_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.
          1. If _waitable_ is *true*, then
            1. If _typedArray_.[[TypedArrayName]] is neither *"Int32Array"* nor *"BigInt64Array"*, throw a *TypeError* exception.
          1. Else,
            1. Let _type_ be TypedArrayElementType(_typedArray_).
            1. If IsUnclampedIntegerElementType(_type_) is *false* and IsBigIntElementType(_type_) is *false*, throw a *TypeError* exception.
          1. Return _taRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccess" type="abstract operation">
        <h1>
          ValidateAtomicAccess (
            _taRecord_: a TypedArray With Buffer Witness Record,
            _requestIndex_: an ECMAScript language value,
          ): either a normal completion containing an integer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _length_ be TypedArrayLength(_taRecord_).
          1. Let _accessIndex_ be ? ToIndex(_requestIndex_).
          1. Assert: _accessIndex_ ≥ 0.
          1. If _accessIndex_ ≥ _length_, throw a *RangeError* exception.
          1. Let _typedArray_ be _taRecord_.[[Object]].
          1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Return (_accessIndex_ × _elementSize_) + _offset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccessonintegertypedarray" type="abstract operation">
        <h1>
          ValidateAtomicAccessOnIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
          ): either a normal completion containing an integer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *false*).
          1. Return ? ValidateAtomicAccess(_taRecord_, _requestIndex_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-revalidateatomicaccess" type="abstract operation">
        <h1>
          RevalidateAtomicAccess (
            _typedArray_: a TypedArray,
            _byteIndexInBuffer_: an integer,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>This operation revalidates the index within the backing buffer for atomic operations after all argument coercions are performed in Atomics methods, as argument coercions can have arbitrary side effects, which could cause the buffer to become out of bounds. This operation does not throw when _typedArray_'s backing buffer is a SharedArrayBuffer.</dd>
        </dl>
        <emu-alg>
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
          1. Assert: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].
          1. If _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]], throw a *RangeError* exception.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getwaiterlist" type="abstract operation">
        <h1>
          GetWaiterList (
            _block_: a Shared Data Block,
            _i_: a non-negative integer that is evenly divisible by 4,
          ): a WaiterList Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.
          1. Return the WaiterList Record that is referenced by the pair (_block_, _i_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-entercriticalsection" type="abstract operation">
        <h1>
          EnterCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is not in the critical section for any WaiterList Record.
          1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).
          1. If _WL_.[[MostRecentLeaveEvent]] is not ~empty~, then
            1. NOTE: A _WL_ whose critical section has been entered at least once has a Synchronize event set by LeaveCriticalSection.
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. Let _enterEvent_ be a new Synchronize event.
            1. Append _enterEvent_ to _eventsRecord_.[[EventList]].
            1. Append (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]].
          1. Return ~unused~.
        </emu-alg>
        <p>EnterCriticalSection has <dfn>contention</dfn> when an agent attempting to enter the critical section must wait for another agent to leave it. When there is no contention, FIFO order of EnterCriticalSection calls is observable. When there is contention, an implementation may choose an arbitrary order but may not cause an agent to wait indefinitely.</p>
      </emu-clause>

      <emu-clause id="sec-leavecriticalsection" type="abstract operation">
        <h1>
          LeaveCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _leaveEvent_ be a new Synchronize event.
          1. Append _leaveEvent_ to _eventsRecord_.[[EventList]].
          1. Set _WL_.[[MostRecentLeaveEvent]] to _leaveEvent_.
          1. Leave the critical section for _WL_.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-addwaiter" type="abstract operation">
        <h1>
          AddWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Assert: There is no Waiter Record in _WL_.[[Waiters]] whose [[PromiseCapability]] field is _waiterRecord_.[[PromiseCapability]] and whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]].
          1. Append _waiterRecord_ to _WL_.[[Waiters]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiter" type="abstract operation">
        <h1>
          RemoveWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.
          1. Remove _waiterRecord_ from _WL_.[[Waiters]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiters" type="abstract operation">
        <h1>
          RemoveWaiters (
            _WL_: a WaiterList Record,
            _c_: a non-negative integer or +&infin;,
          ): a List of Waiter Records
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Let _len_ be the number of elements in _WL_.[[Waiters]].
          1. Let _n_ be min(_c_, _len_).
          1. Let _L_ be a List whose elements are the first _n_ elements of _WL_.[[Waiters]].
          1. Remove the first _n_ elements of _WL_.[[Waiters]].
          1. Return _L_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-suspendthisagent" type="abstract operation" oldids="sec-suspend,sec-suspendagent">
        <h1>
          SuspendThisAgent (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.
          1. Let _thisAgent_ be AgentSignifier().
          1. Assert: _waiterRecord_.[[AgentSignifier]] is _thisAgent_.
          1. Assert: _waiterRecord_.[[PromiseCapability]] is ~blocking~.
          1. Assert: AgentCanSuspend() is *true*.
          1. Perform LeaveCriticalSection(_WL_) and suspend the surrounding agent until the time is _waiterRecord_.[[TimeoutTime]], performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. The surrounding agent can only wake from suspension due to a timeout or due to another agent calling NotifyWaiter with arguments _WL_ and _thisAgent_ (i.e. via a call to `Atomics.notify`).
          1. Perform EnterCriticalSection(_WL_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-notifywaiter" type="abstract operation">
        <h1>
          NotifyWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. If _waiterRecord_.[[PromiseCapability]] is ~blocking~, then
            1. Wake the agent whose signifier is _waiterRecord_.[[AgentSignifier]] from suspension.
            1. NOTE: This causes the agent to resume execution in SuspendThisAgent.
          1. Else if AgentSignifier() is _waiterRecord_.[[AgentSignifier]], then
            1. Let _promiseCapability_ be _waiterRecord_.[[PromiseCapability]].
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] »).
          1. Else,
            1. Perform EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]).
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>An agent must not access another agent's promise capability in any capacity beyond passing it to the host.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueresolveinagentjob" type="abstract operation">
        <h1>
          EnqueueResolveInAgentJob (
            _agentSignifier_: an agent signifier,
            _promiseCapability_: a PromiseCapability Record,
            _resolution_: *"ok"* or *"timed-out"*,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _resolveJob_ be a new Job Abstract Closure with no parameters that captures _agentSignifier_, _promiseCapability_, and _resolution_ and performs the following steps when called:
            1. Assert: AgentSignifier() is _agentSignifier_.
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »).
            1. Return ~unused~.
          1. Let _realmInTargetAgent_ be ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).
          1. Assert: _agentSignifier_ is _realmInTargetAgent_.[[AgentSignifier]].
          1. Perform HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dowait" type="abstract operation">
        <h1>
          DoWait (
            _mode_: ~sync~ or ~async~,
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _timeout_: an ECMAScript language value,
          ): either a normal completion containing either an Object, *"not-equal"*, *"timed-out"*, or *"ok"*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).
          1. Let _buffer_ be _taRecord_.[[Object]].[[ViewedArrayBuffer]].
          1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.
          1. Let _i_ be ? ValidateAtomicAccess(_taRecord_, _index_).
          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
          1. If _arrayTypeName_ is *"BigInt64Array"*, let _v_ be ? ToBigInt64(_value_).
          1. Else, let _v_ be ? ToInt32(_value_).
          1. Let _q_ be ? ToNumber(_timeout_).
          1. If _q_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _t_ be +∞; else if _q_ is *-∞*<sub>𝔽</sub>, let _t_ be 0; else let _t_ be max(ℝ(_q_), 0).
          1. If _mode_ is ~sync~ and AgentCanSuspend() is *false*, throw a *TypeError* exception.
          1. Let _block_ be _buffer_.[[ArrayBufferData]].
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Let _byteIndexInBuffer_ be (_i_ × 4) + _offset_.
          1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).
          1. If _mode_ is ~sync~, then
            1. Let _promiseCapability_ be ~blocking~.
            1. Let _resultObject_ be *undefined*.
          1. Else,
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _resultObject_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform EnterCriticalSection(_WL_).
          1. Let _elementType_ be TypedArrayElementType(_typedArray_).
          1. Let _w_ be GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
          1. If _v_ ≠ _w_, then
            1. Perform LeaveCriticalSection(_WL_).
            1. If _mode_ is ~sync~, return *"not-equal"*.
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*).
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"not-equal"*).
            1. Return _resultObject_.
          1. If _t_ = 0 and _mode_ is ~async~, then
            1. NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid unnecessary Promise jobs.
            1. Perform LeaveCriticalSection(_WL_).
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*).
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"timed-out"*).
            1. Return _resultObject_.
          1. Let _thisAgent_ be AgentSignifier().
          1. Let _now_ be the time value (UTC) identifying the current time.
          1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.
          1. Let _timeoutTime_ be ℝ(_now_) + _t_ + _additionalTimeout_.
          1. NOTE: When _t_ is +∞, _timeoutTime_ is also +∞.
          1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* }.
          1. Perform AddWaiter(_WL_, _waiterRecord_).
          1. If _mode_ is ~sync~, then
            1. Perform SuspendThisAgent(_WL_, _waiterRecord_).
          1. Else if _timeoutTime_ is finite, then
            1. Perform EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_).
          1. Perform LeaveCriticalSection(_WL_).
          1. If _mode_ is ~sync~, return _waiterRecord_.[[Result]].
          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, _promiseCapability_.[[Promise]]).
          1. Return _resultObject_.
        </emu-alg>
        <emu-note>
          <p>_additionalTimeout_ allows implementations to pad timeouts as necessary, such as for reducing power consumption or coarsening timer resolution to mitigate timing attacks. This value may differ from call to call of DoWait.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueatomicswaitasynctimeoutjob" type="abstract operation">
        <h1>
          EnqueueAtomicsWaitAsyncTimeoutJob (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _timeoutJob_ be a new Job Abstract Closure with no parameters that captures _WL_ and _waiterRecord_ and performs the following steps when called:
            1. Perform EnterCriticalSection(_WL_).
            1. If _WL_.[[Waiters]] contains _waiterRecord_, then
              1. Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.
              1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values).
              1. Set _waiterRecord_.[[Result]] to *"timed-out"*.
              1. Perform RemoveWaiter(_WL_, _waiterRecord_).
              1. Perform NotifyWaiter(_WL_, _waiterRecord_).
            1. Perform LeaveCriticalSection(_WL_).
            1. Return ~unused~.
          1. Let _now_ be the time value (UTC) identifying the current time.
          1. Let _currentRealm_ be the current Realm Record.
          1. Perform HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomiccompareexchangeinsharedblock" type="abstract operation">
        <h1>
          AtomicCompareExchangeInSharedBlock (
            _block_: a Shared Data Block,
            _byteIndexInBuffer_: an integer,
            _elementSize_: a non-negative integer,
            _expectedBytes_: a List of byte values,
            _replacementBytes_: a List of byte values,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
              1. Return _newBytes_.
            1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.
          1. Else,
            1. Let _event_ be ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }.
          1. Append _event_ to _eventsRecord_.[[EventList]].
          1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
          1. Return _rawBytesRead_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation">
        <h1>
          AtomicReadModifyWrite (
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _op_: a read-modify-write modification function,
          ): either a normal completion containing either a Number or a BigInt, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_op_ takes two List of byte values arguments and returns a List of byte values. This operation atomically loads a value, combines it with another value, and stores the combination. It returns the loaded value.</dd>
        </dl>
        <emu-alg>
          1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
          1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).
          1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).
          1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
          1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
          1. Let _elementType_ be TypedArrayElementType(_typedArray_).
          1. Return GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistbitwiseop" type="abstract operation">
        <h1>
          ByteListBitwiseOp (
            _op_: `&amp;`, `^`, or `|`,
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): a List of byte values
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>The operation atomically performs a bitwise operation on all byte values of the arguments and returns a List of byte values.</dd>
        </dl>
        <emu-alg>
          1. Assert: _xBytes_ and _yBytes_ have the same number of elements.
          1. Let _result_ be a new empty List.
          1. Let _i_ be 0.
          1. For each element _xByte_ of _xBytes_, do
            1. Let _yByte_ be _yBytes_[_i_].
            1. If _op_ is `&amp;`, then
              1. Let _resultByte_ be the result of applying the bitwise AND operation to _xByte_ and _yByte_.
            1. Else if _op_ is `^`, then
              1. Let _resultByte_ be the result of applying the bitwise exclusive OR (XOR) operation to _xByte_ and _yByte_.
            1. Else,
              1. Assert: _op_ is `|`.
              1. Let _resultByte_ be the result of applying the bitwise inclusive OR operation to _xByte_ and _yByte_.
            1. Set _i_ to _i_ + 1.
            1. Append _resultByte_ to _result_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistequal" type="abstract operation">
        <h1>
          ByteListEqual (
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.
          1. Let _i_ be 0.
          1. For each element _xByte_ of _xBytes_, do
            1. Let _yByte_ be _yBytes_[_i_].
            1. If _xByte_ ≠ _yByte_, return *false*.
            1. Set _i_ to _i_ + 1.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-atomics.add">
      <h1>Atomics.add ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _typedArray_ and performs the following steps atomically when called:
          1. Let _type_ be TypedArrayElementType(_typedArray_).
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).
          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).
          1. If _x_ is a Number, then
            1. Let _sum_ be Number::add(_x_, _y_).
          1. Else,
            1. Assert: _x_ is a BigInt.
            1. Let _sum_ be BigInt::add(_x_, _y_).
          1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).
          1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements.
          1. Return _sumBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.and">
      <h1>Atomics.and ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return ByteListBitwiseOp(`&amp;`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. If _typedArray_.[[ContentType]] is ~bigint~, then
          1. Let _expected_ be ? ToBigInt(_expectedValue_).
          1. Let _replacement_ be ? ToBigInt(_replacementValue_).
        1. Else,
          1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).
          1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).
        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).
        1. If IsSharedArrayBuffer(_buffer_) is *true*, then
          1. Let _rawBytesRead_ be AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).
        1. Else,
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].
        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange">
      <h1>Atomics.exchange ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return _newBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree ( _size_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _n_ be ? ToIntegerOrInfinity(_size_).
        1. Let _AR_ be the Agent Record of the surrounding agent.
        1. If _n_ = 1, return _AR_.[[IsLockFree1]].
        1. If _n_ = 2, return _AR_.[[IsLockFree2]].
        1. If _n_ = 4, return *true*.
        1. If _n_ = 8, return _AR_.[[IsLockFree8]].
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>This function is an optimization primitive. The intuition is that if the atomic step of an atomic primitive (`compareExchange`, `load`, `store`, `add`, `sub`, `and`, `or`, `xor`, or `exchange`) on a datum of size _n_ bytes will be performed without the surrounding agent acquiring a lock outside the _n_ bytes comprising the datum, then `Atomics.isLockFree`(_n_) will return *true*. High-performance algorithms will use this function to determine whether to use locks or atomic operations in critical sections. If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</p>
        <p>`Atomics.isLockFree`(4) always returns *true* as that can be supported on all known relevant hardware. Being able to assume this will generally simplify programs.</p>
        <p>Regardless of the value returned by this function, all atomic operations are guaranteed to be atomic. For example, they will never have a visible operation take place in the middle of the operation (e.g., "tearing").</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-atomics.load" oldids="sec-atomicload">
      <h1>Atomics.load ( _typedArray_, _index_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.or">
      <h1>Atomics.or ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).
        1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Perform SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~).
        1. Return _v_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.sub">
      <h1>Atomics.sub ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _typedArray_ and performs the following steps atomically when called:
          1. Let _type_ be TypedArrayElementType(_typedArray_).
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).
          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).
          1. If _x_ is a Number, then
            1. Let _difference_ be Number::subtract(_x_, _y_).
          1. Else,
            1. Assert: _x_ is a BigInt.
            1. Let _difference_ be BigInt::subtract(_x_, _y_).
          1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).
          1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements.
          1. Return _differenceBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>This function puts the surrounding agent in a wait queue and suspends it until notified or until the wait times out, returning a String differentiating those cases.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.waitasync">
      <h1>Atomics.waitAsync ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>This function returns a Promise that is resolved when the calling agent is notified or the timeout is reached.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.notify">
      <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
      <p>This function notifies some agents that are sleeping in the wait queue.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccess(_taRecord_, _index_).
        1. If _count_ is *undefined*, then
          1. Let _c_ be +∞.
        1. Else,
          1. Let _intCount_ be ? ToIntegerOrInfinity(_count_).
          1. Let _c_ be max(_intCount_, 0).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. If IsSharedArrayBuffer(_buffer_) is *false*, return *+0*<sub>𝔽</sub>.
        1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, _c_).
        1. For each element _W_ of _S_, do
          1. Perform NotifyWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. Let _n_ be the number of elements in _S_.
        1. Return 𝔽(_n_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.xor">
      <h1>Atomics.xor ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_).
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-atomics-@@tostringtag" id="sec-atomics-%symbol.tostringtag%">
      <h1>Atomics [ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Atomics"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-json-object">
    <h1>The JSON Object</h1>
    <p>The JSON object:</p>
    <ul>
      <li>is <dfn>%JSON%</dfn>.</li>
      <li>is the initial value of the *"JSON"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>contains two functions, `parse` and `stringify`, that are used to parse and construct JSON texts.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <p>The JSON Data Interchange Format is defined in ECMA-404. The JSON interchange format used in this specification is exactly that described by ECMA-404. Conforming implementations of `JSON.parse` and `JSON.stringify` must support the exact interchange format described in the ECMA-404 specification without any deletions or extensions to the format.</p>

    <emu-clause id="sec-json.parse">
      <h1>JSON.parse ( _text_ [ , _reviver_ ] )</h1>
      <p>This function parses a JSON text (a JSON-formatted String) and produces an ECMAScript language value. The JSON format represents literals, arrays, and objects with a syntax similar to the syntax for ECMAScript literals, Array Initializers, and Object Initializers. After parsing, JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript Array instances. JSON strings, numbers, booleans, and null are realized as ECMAScript Strings, Numbers, Booleans, and *null*.</p>
      <p>The optional _reviver_ parameter is a function that takes two parameters, _key_ and _value_. It can filter and transform the results. It is called with each of the _key_/_value_ pairs produced by the parse, and its return value is used instead of the original value. If it returns what it received, the structure is not modified. If it returns *undefined* then the property is deleted from the result.</p>
      <emu-alg>
        1. Let _jsonString_ be ? ToString(_text_).
        1. Let _unfiltered_ be ? ParseJSON(_jsonString_).
        1. If IsCallable(_reviver_) is *true*, then
          1. Let _root_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Let _rootName_ be the empty String.
          1. Perform ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_).
          1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).
        1. Else,
          1. Return _unfiltered_.
      </emu-alg>
      <p>The *"length"* property of this function is *2*<sub>𝔽</sub>.</p>

      <emu-clause id="sec-ParseJSON" type="abstract operation">
        <h1>
          ParseJSON (
            _text_: a String,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. [id="step-json-parse-validate"] If StringToCodePoints(_text_) is not a valid JSON text as specified in ECMA-404, throw a *SyntaxError* exception.
          1. Let _scriptString_ be the string-concatenation of *"("*, _text_, and *");"*.
          1. [id="step-json-parse-parse"] Let _script_ be ParseText(_scriptString_, |Script|).
          1. NOTE: The early error rules defined in <emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref> have special handling for the above invocation of ParseText.
          1. Assert: _script_ is a Parse Node.
          1. [id="step-json-parse-eval"] Let _result_ be ! <emu-meta suppress-effects="user-code">Evaluation of _script_</emu-meta>.
          1. NOTE: The PropertyDefinitionEvaluation semantics defined in <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> have special handling for the above evaluation.
          1. [id="step-json-parse-assert-type"] Assert: _result_ is either a String, a Number, a Boolean, an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|, or *null*.
          1. Return _result_.
        </emu-alg>
        <p>It is not permitted for a conforming implementation of `JSON.parse` to extend the JSON grammars. If an implementation wishes to support a modified or extended JSON interchange format it must do so by defining a different parse function.</p>
        <emu-note>
          <p>Valid JSON text is a subset of the ECMAScript |PrimaryExpression| syntax. Step <emu-xref href="#step-json-parse-validate"></emu-xref> verifies that _jsonString_ conforms to that subset, and step <emu-xref href="#step-json-parse-assert-type"></emu-xref> asserts that evaluation returns a value of an appropriate type.</p>
          <p>However, because <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> behaves differently during ParseJSON, the same source text can produce different results when evaluated as a |PrimaryExpression| rather than as JSON. Furthermore, the Early Error for duplicate *"__proto__"* properties in object literals, which likewise does not apply during ParseJSON, means that not all texts accepted by ParseJSON are valid as a |PrimaryExpression|, despite matching the grammar.</p>
        </emu-note>
        <emu-note>
          <p>In the case where there are duplicate name Strings within an object, lexically preceding values for the same key shall be overwritten.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-internalizejsonproperty" type="abstract operation">
        <h1>
          InternalizeJSONProperty (
            _holder_: an Object,
            _name_: a String,
            _reviver_: a function object,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This algorithm intentionally does not throw an exception if either [[Delete]] or CreateDataProperty return *false*.</p>
        </emu-note>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _val_ be ? Get(_holder_, _name_).
          1. If _val_ is an Object, then
            1. Let _isArray_ be ? IsArray(_val_).
            1. If _isArray_ is *true*, then
              1. Let _len_ be ? LengthOfArrayLike(_val_).
              1. Let _I_ be 0.
              1. Repeat, while _I_ &lt; _len_,
                1. Let _prop_ be ! ToString(𝔽(_I_)).
                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _prop_, _reviver_).
                1. If _newElement_ is *undefined*, then
                  1. Perform ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_prop_).
                1. Else,
                  1. Perform ? CreateDataProperty(_val_, _prop_, _newElement_).
                1. Set _I_ to _I_ + 1.
            1. Else,
              1. Let _keys_ be ? EnumerableOwnProperties(_val_, ~key~).
              1. For each String _P_ of _keys_, do
                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_, _reviver_).
                1. If _newElement_ is *undefined*, then
                  1. Perform ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_P_).
                1. Else,
                  1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).
          1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json.stringify">
      <h1>JSON.stringify ( _value_ [ , _replacer_ [ , _space_ ] ] )</h1>
      <p>This function returns a String in UTF-16 encoded JSON format representing an ECMAScript language value, or *undefined*. It can take three parameters. The _value_ parameter is an ECMAScript language value, which is usually an object or array, although it can also be a String, Boolean, Number or *null*. The optional _replacer_ parameter is either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that acts as an inclusion list for selecting the object properties that will be stringified. The optional _space_ parameter is a String or Number that allows the result to have white space injected into it to improve human readability.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _stack_ be a new empty List.
        1. Let _indent_ be the empty String.
        1. Let _PropertyList_ be *undefined*.
        1. Let _ReplacerFunction_ be *undefined*.
        1. If _replacer_ is an Object, then
          1. If IsCallable(_replacer_) is *true*, then
            1. Set _ReplacerFunction_ to _replacer_.
          1. Else,
            1. Let _isArray_ be ? IsArray(_replacer_).
            1. If _isArray_ is *true*, then
              1. Set _PropertyList_ to a new empty List.
              1. Let _len_ be ? LengthOfArrayLike(_replacer_).
              1. Let _k_ be 0.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _prop_ be ! ToString(𝔽(_k_)).
                1. Let _v_ be ? Get(_replacer_, _prop_).
                1. Let _item_ be *undefined*.
                1. If _v_ is a String, then
                  1. Set _item_ to _v_.
                1. Else if _v_ is a Number, then
                  1. Set _item_ to ! ToString(_v_).
                1. Else if _v_ is an Object, then
                  1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).
                1. If _item_ is not *undefined* and _PropertyList_ does not contain _item_, then
                  1. Append _item_ to _PropertyList_.
                1. Set _k_ to _k_ + 1.
        1. If _space_ is an Object, then
          1. If _space_ has a [[NumberData]] internal slot, then
            1. Set _space_ to ? ToNumber(_space_).
          1. Else if _space_ has a [[StringData]] internal slot, then
            1. Set _space_ to ? ToString(_space_).
        1. If _space_ is a Number, then
          1. Let _spaceMV_ be ! ToIntegerOrInfinity(_space_).
          1. Set _spaceMV_ to min(10, _spaceMV_).
          1. If _spaceMV_ &lt; 1, let _gap_ be the empty String; otherwise let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).
        1. Else if _space_ is a String, then
          1. If the length of _space_ ≤ 10, let _gap_ be _space_; otherwise let _gap_ be the substring of _space_ from 0 to 10.
        1. Else,
          1. Let _gap_ be the empty String.
        1. Let _wrapper_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_wrapper_, the empty String, _value_).
        1. Let _state_ be the JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.
        1. Return ? SerializeJSONProperty(_state_, the empty String, _wrapper_).
      </emu-alg>
      <p>The *"length"* property of this function is *3*<sub>𝔽</sub>.</p>
      <emu-note>
        <p>JSON structures are allowed to be nested to any depth, but they must be acyclic. If _value_ is or contains a cyclic structure, then this function must throw a *TypeError* exception. This is an example of a value that cannot be stringified:</p>
        <pre><code class="javascript">
          a = [];
          a[0] = a;
          my_text = JSON.stringify(a); // This must throw a TypeError.
        </code></pre>
      </emu-note>
      <emu-note>
        <p>Symbolic primitive values are rendered as follows:</p>
        <ul>
          <li>
            The *null* value is rendered in JSON text as the String value *"null"*.
          </li>
          <li>
            The *undefined* value is not rendered.
          </li>
          <li>
            The *true* value is rendered in JSON text as the String value *"true"*.
          </li>
          <li>
            The *false* value is rendered in JSON text as the String value *"false"*.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>String values are wrapped in QUOTATION MARK (`"`) code units. The code units `"` and `\\` are escaped with `\\` prefixes. Control characters code units are replaced with escape sequences `\\u`HHHH, or with the shorter forms, `\\b` (BACKSPACE), `\\f` (FORM FEED), `\\n` (LINE FEED), `\\r` (CARRIAGE RETURN), `\\t` (CHARACTER TABULATION).</p>
      </emu-note>
      <emu-note>
        <p>Finite numbers are stringified as if by calling ToString(_number_). *NaN* and *Infinity* regardless of sign are represented as the String value *"null"*.</p>
      </emu-note>
      <emu-note>
        <p>Values that do not have a JSON representation (such as *undefined* and functions) do not produce a String. Instead they produce the *undefined* value. In arrays these values are represented as the String value *"null"*. In objects an unrepresentable value causes the property to be excluded from stringification.</p>
      </emu-note>
      <emu-note>
        <p>An object is rendered as U+007B (LEFT CURLY BRACKET) followed by zero or more properties, separated with a U+002C (COMMA), closed with a U+007D (RIGHT CURLY BRACKET). A property is a quoted String representing the property name, a U+003A (COLON), and then the stringified property value. An array is rendered as an opening U+005B (LEFT SQUARE BRACKET) followed by zero or more values, separated with a U+002C (COMMA), closed with a U+005D (RIGHT SQUARE BRACKET).</p>
      </emu-note>

      <emu-clause id="sec-json-serialization-record">
        <h1>JSON Serialization Record</h1>
        <p>A <dfn variants="JSON Serialization Records">JSON Serialization Record</dfn> is a Record value used to enable serialization to the JSON format.</p>
        <p>JSON Serialization Records have the fields listed in <emu-xref href="#table-json-serialization-record"></emu-xref>.</p>
        <emu-table id="table-json-serialization-record" caption="JSON Serialization Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[ReplacerFunction]]</td>
              <td>a function object or *undefined*</td>
              <td>A function that can supply replacement values for object properties (from JSON.stringify's _replacer_ parameter).</td>
            </tr>
            <tr>
              <td>[[PropertyList]]</td>
              <td>either a List of Strings or *undefined*</td>
              <td>The names of properties to include when serializing a non-array object (from JSON.stringify's _replacer_ parameter).</td>
            </tr>
            <tr>
              <td>[[Gap]]</td>
              <td>a String</td>
              <td>The unit of indentation (from JSON.stringify's _space_ parameter).</td>
            </tr>
            <tr>
              <td>[[Stack]]</td>
              <td>a List of Objects</td>
              <td>The set of nested objects that are in the process of being serialized. Used to detect cyclic structures.</td>
            </tr>
            <tr>
              <td>[[Indent]]</td>
              <td>a String</td>
              <td>The current indentation.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-serializejsonproperty" type="abstract operation">
        <h1>
          SerializeJSONProperty (
            _state_: a JSON Serialization Record,
            _key_: a String,
            _holder_: an Object,
          ): either a normal completion containing either a String or *undefined*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _value_ be ? Get(_holder_, _key_).
          1. If _value_ is an Object or _value_ is a BigInt, then
            1. Let _toJSON_ be ? GetV(_value_, *"toJSON"*).
            1. If IsCallable(_toJSON_) is *true*, then
              1. Set _value_ to ? Call(_toJSON_, _value_, « _key_ »).
          1. If _state_.[[ReplacerFunction]] is not *undefined*, then
            1. Set _value_ to ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).
          1. If _value_ is an Object, then
            1. If _value_ has a [[NumberData]] internal slot, then
              1. Set _value_ to ? ToNumber(_value_).
            1. Else if _value_ has a [[StringData]] internal slot, then
              1. Set _value_ to ? ToString(_value_).
            1. Else if _value_ has a [[BooleanData]] internal slot, then
              1. Set _value_ to _value_.[[BooleanData]].
            1. Else if _value_ has a [[BigIntData]] internal slot, then
              1. Set _value_ to _value_.[[BigIntData]].
          1. If _value_ is *null*, return *"null"*.
          1. If _value_ is *true*, return *"true"*.
          1. If _value_ is *false*, return *"false"*.
          1. If _value_ is a String, return QuoteJSONString(_value_).
          1. If _value_ is a Number, then
            1. If _value_ is finite, return ! ToString(_value_).
            1. Return *"null"*.
          1. If _value_ is a BigInt, throw a *TypeError* exception.
          1. If _value_ is an Object and IsCallable(_value_) is *false*, then
            1. Let _isArray_ be ? IsArray(_value_).
            1. If _isArray_ is *true*, return ? SerializeJSONArray(_state_, _value_).
            1. Return ? SerializeJSONObject(_state_, _value_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-quotejsonstring" type="abstract operation">
        <h1>
          QuoteJSONString (
            _value_: a String,
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It wraps _value_ in 0x0022 (QUOTATION MARK) code units and escapes certain other code units within it. This operation interprets _value_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</dd>
        </dl>
        <emu-alg>
          1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).
          1. For each code point _C_ of StringToCodePoints(_value_), do
            1. If _C_ is listed in the “Code Point” column of <emu-xref href="#table-json-single-character-escapes"></emu-xref>, then
              1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the “Escape Sequence” column of the corresponding row.
            1. Else if _C_ has a numeric value less than 0x0020 (SPACE) or _C_ has the same numeric value as a leading surrogate or trailing surrogate, then
              1. Let _unit_ be the code unit whose numeric value is the numeric value of _C_.
              1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).
            1. Else,
              1. Set _product_ to the string-concatenation of _product_ and UTF16EncodeCodePoint(_C_).
          1. Set _product_ to the string-concatenation of _product_ and the code unit 0x0022 (QUOTATION MARK).
          1. Return _product_.
        </emu-alg>
        <emu-table id="table-json-single-character-escapes" caption="JSON Single Character Escape Sequences">
          <table>
            <thead>
              <tr>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Escape Sequence
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                U+0008
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                `\\b`
              </td>
            </tr>
            <tr>
              <td>
                U+0009
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                `\\t`
              </td>
            </tr>
            <tr>
              <td>
                U+000A
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                `\\n`
              </td>
            </tr>
            <tr>
              <td>
                U+000C
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                `\\f`
              </td>
            </tr>
            <tr>
              <td>
                U+000D
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                `\\r`
              </td>
            </tr>
            <tr>
              <td>
                U+0022
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `\\"`
              </td>
            </tr>
            <tr>
              <td>
                U+005C
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\\\`
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unicodeescape" type="abstract operation">
        <h1>
          UnicodeEscape (
            _C_: a code unit,
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It represents _C_ as a Unicode escape sequence.</dd>
        </dl>
        <emu-alg>
          1. Let _n_ be the numeric value of _C_.
          1. Assert: _n_ ≤ 0xFFFF.
          1. Let _hex_ be the String representation of _n_, formatted as a lowercase hexadecimal number.
          1. Return the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *"u"*, and StringPad(_hex_, 4, *"0"*, ~start~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonobject" type="abstract operation">
        <h1>
          SerializeJSONObject (
            _state_: a JSON Serialization Record,
            _value_: an Object,
          ): either a normal completion containing a String or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It serializes an object.</dd>
        </dl>
        <emu-alg>
          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.
          1. Append _value_ to _state_.[[Stack]].
          1. Let _stepBack_ be _state_.[[Indent]].
          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].
          1. If _state_.[[PropertyList]] is not *undefined*, then
            1. Let _K_ be _state_.[[PropertyList]].
          1. Else,
            1. Let _K_ be ? EnumerableOwnProperties(_value_, ~key~).
          1. Let _partial_ be a new empty List.
          1. For each element _P_ of _K_, do
            1. Let _strP_ be ? SerializeJSONProperty(_state_, _P_, _value_).
            1. If _strP_ is not *undefined*, then
              1. Let _member_ be QuoteJSONString(_P_).
              1. Set _member_ to the string-concatenation of _member_ and *":"*.
              1. If _state_.[[Gap]] is not the empty String, then
                1. Set _member_ to the string-concatenation of _member_ and the code unit 0x0020 (SPACE).
              1. Set _member_ to the string-concatenation of _member_ and _strP_.
              1. Append _member_ to _partial_.
          1. If _partial_ is empty, then
            1. Let _final_ be *"{}"*.
          1. Else,
            1. If _state_.[[Gap]] is the empty String, then
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"{"*, _properties_, and *"}"*.
            1. Else,
              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"{"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepBack_, and *"}"*.
          1. Remove the last element of _state_.[[Stack]].
          1. Set _state_.[[Indent]] to _stepBack_.
          1. Return _final_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonarray" type="abstract operation">
        <h1>
          SerializeJSONArray (
            _state_: a JSON Serialization Record,
            _value_: an ECMAScript language value,
          ): either a normal completion containing a String or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It serializes an array.</dd>
        </dl>
        <emu-alg>
          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.
          1. Append _value_ to _state_.[[Stack]].
          1. Let _stepBack_ be _state_.[[Indent]].
          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].
          1. Let _partial_ be a new empty List.
          1. Let _len_ be ? LengthOfArrayLike(_value_).
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _len_,
            1. Let _strP_ be ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).
            1. If _strP_ is *undefined*, then
              1. Append *"null"* to _partial_.
            1. Else,
              1. Append _strP_ to _partial_.
            1. Set _index_ to _index_ + 1.
          1. If _partial_ is empty, then
            1. Let _final_ be *"[]"*.
          1. Else,
            1. If _state_.[[Gap]] is the empty String, then
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"["*, _properties_, and *"]"*.
            1. Else,
              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"["*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepBack_, and *"]"*.
          1. Remove the last element of _state_.[[Stack]].
          1. Set _state_.[[Indent]] to _stepBack_.
          1. Return _final_.
        </emu-alg>
        <emu-note>
          <p>The representation of arrays includes only the elements in the interval from *+0*<sub>𝔽</sub> (inclusive) to `array.length` (exclusive). Properties whose keys are not array indices are excluded from the stringification. An array is stringified as an opening LEFT SQUARE BRACKET, elements separated by COMMA, and a closing RIGHT SQUARE BRACKET.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-json-@@tostringtag" id="sec-json-%symbol.tostringtag%">
      <h1>JSON [ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"JSON"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>Managing Memory</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef Objects</h1>
    <p>A WeakRef is an object that is used to refer to a target object or symbol without preserving it from garbage collection. WeakRefs can be dereferenced to allow access to the target value, if the target hasn't been reclaimed by garbage collection.</p>

    <emu-clause id="sec-weak-ref-constructor">
      <h1>The WeakRef Constructor</h1>
      <p>The <dfn variants="WeakRefs">WeakRef</dfn> constructor:</p>
      <ul>
        <li>is <dfn>%WeakRef%</dfn>.</li>
        <li>
          is the initial value of the *"WeakRef"* property of the global object.
        </li>
        <li>
          creates and initializes a new WeakRef when called as a constructor.
        </li>
        <li>
          is not intended to be called as a function and will throw an exception when called in that manner.
        </li>
        <li>
          may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `WeakRef` behaviour must include a `super` call to the `WeakRef` constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakRef.prototype` built-in methods.
        </li>
      </ul>

      <emu-clause id="sec-weak-ref-target">
        <h1>WeakRef ( _target_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.
          1. Let _weakRef_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakRef.prototype%"*, « [[WeakRefTarget]] »).
          1. Perform AddToKeptObjects(_target_).
          1. Set _weakRef_.[[WeakRefTarget]] to _target_.
          1. Return _weakRef_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor">
      <h1>Properties of the WeakRef Constructor</h1>
      <p>The WeakRef constructor:</p>
      <ul>
        <li>
          has a [[Prototype]] internal slot whose value is %Function.prototype%.
        </li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype">
        <h1>WeakRef.prototype</h1>
        <p>The initial value of `WeakRef.prototype` is the WeakRef prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-prototype-object">
      <h1>Properties of the WeakRef Prototype Object</h1>
      <p>The <dfn>WeakRef prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%WeakRef.prototype%</dfn>.</li>
        <li>
          has a [[Prototype]] internal slot whose value is %Object.prototype%.
        </li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakRefTarget]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype.constructor" normative-optional>
        <h1>WeakRef.prototype.constructor</h1>

        <p>The initial value of `WeakRef.prototype.constructor` is %WeakRef%.</p>
      </emu-clause>

      <emu-clause id="sec-weak-ref.prototype.deref">
        <h1>WeakRef.prototype.deref ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _weakRef_ be the *this* value.
          1. Perform ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]).
          1. Return WeakRefDeref(_weakRef_).
        </emu-alg>

        <emu-note>
          <p>If the WeakRef returns a _target_ value that is not *undefined*, then this _target_ value should not be garbage collected until the current execution of ECMAScript code has completed. The AddToKeptObjects operation makes sure read consistency is maintained.</p>

          <pre><code class="javascript">
            let target = { foo() {} };
            let weakRef = new WeakRef(target);

            // ... later ...

            if (weakRef.deref()) {
              weakRef.deref().foo();
            }
          </code></pre>

          <p>In the above example, if the first deref does not evaluate to *undefined* then the second deref cannot either.</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-weak-ref.prototype-@@tostringtag" id="sec-weak-ref.prototype-%symbol.tostringtag%">
        <h1>WeakRef.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"WeakRef"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-weakref-abstract-operations">
      <h1>WeakRef Abstract Operations</h1>

      <emu-clause id="sec-weakrefderef" type="abstract operation">
        <h1>
          WeakRefDeref (
            _weakRef_: a WeakRef,
          ): an ECMAScript language value
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _target_ be _weakRef_.[[WeakRefTarget]].
          1. If _target_ is not ~empty~, then
            1. Perform AddToKeptObjects(_target_).
            1. Return _target_.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>This abstract operation is defined separately from WeakRef.prototype.deref strictly to make it possible to succinctly define liveness.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weak-ref-instances">
      <h1>Properties of WeakRef Instances</h1>
      <p>WeakRef instances are ordinary objects that inherit properties from the WeakRef prototype object. WeakRef instances also have a [[WeakRefTarget]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry Objects</h1>
    <p>A FinalizationRegistry is an object that manages registration and unregistration of cleanup operations that are performed when target objects and symbols are garbage collected.</p>

    <emu-clause id="sec-finalization-registry-constructor">
      <h1>The FinalizationRegistry Constructor</h1>
      <p>The <dfn variants="FinalizationRegistrys">FinalizationRegistry</dfn> constructor:</p>
      <ul>
        <li>is <dfn>%FinalizationRegistry%</dfn>.</li>
        <li>
          is the initial value of the *"FinalizationRegistry"* property of the global object.
        </li>
        <li>
          creates and initializes a new FinalizationRegistry when called as a constructor.
        </li>
        <li>
          is not intended to be called as a function and will throw an exception when called in that manner.
        </li>
        <li>
          may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `FinalizationRegistry` behaviour must include a `super` call to the `FinalizationRegistry` constructor to create and initialize the subclass instance with the internal state necessary to support the `FinalizationRegistry.prototype` built-in methods.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry-cleanup-callback">
        <h1>FinalizationRegistry ( _cleanupCallback_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If IsCallable(_cleanupCallback_) is *false*, throw a *TypeError* exception.
          1. Let _finalizationRegistry_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%FinalizationRegistry.prototype%"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).
          1. Let _fn_ be the active function object.
          1. Set _finalizationRegistry_.[[Realm]] to _fn_.[[Realm]].
          1. Set _finalizationRegistry_.[[CleanupCallback]] to HostMakeJobCallback(_cleanupCallback_).
          1. Set _finalizationRegistry_.[[Cells]] to a new empty List.
          1. Return _finalizationRegistry_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor">
      <h1>Properties of the FinalizationRegistry Constructor</h1>
      <p>The FinalizationRegistry constructor:</p>
      <ul>
        <li>
          has a [[Prototype]] internal slot whose value is %Function.prototype%.
        </li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype">
        <h1>FinalizationRegistry.prototype</h1>
        <p>The initial value of `FinalizationRegistry.prototype` is the FinalizationRegistry prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-prototype-object">
      <h1>Properties of the FinalizationRegistry Prototype Object</h1>
      <p>The <dfn>FinalizationRegistry prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%FinalizationRegistry.prototype%</dfn>.</li>
        <li>
          has a [[Prototype]] internal slot whose value is %Object.prototype%.
        </li>
        <li>is an ordinary object.</li>
        <li>
          does not have [[Cells]] and [[CleanupCallback]] internal slots.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype.constructor">
        <h1>FinalizationRegistry.prototype.constructor</h1>
        <p>The initial value of `FinalizationRegistry.prototype.constructor` is %FinalizationRegistry%.</p>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.register">
        <h1>FinalizationRegistry.prototype.register ( _target_, _heldValue_ [ , _unregisterToken_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _finalizationRegistry_ be the *this* value.
          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).
          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.
          1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.
          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, then
            1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.
            1. Set _unregisterToken_ to ~empty~.
          1. Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.
          1. Append _cell_ to _finalizationRegistry_.[[Cells]].
          1. Return *undefined*.
        </emu-alg>

        <emu-note>
          <p>Based on the algorithms and definitions in this specification, _cell_.[[HeldValue]] is live when _finalizationRegistry_.[[Cells]] contains _cell_; however, this does not necessarily mean that _cell_.[[UnregisterToken]] or _cell_.[[Target]] are live. For example, registering an object with itself as its unregister token would not keep the object alive forever.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.unregister">
        <h1>FinalizationRegistry.prototype.unregister ( _unregisterToken_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _finalizationRegistry_ be the *this* value.
          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).
          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, throw a *TypeError* exception.
          1. Let _removed_ be *false*.
          1. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_ of _finalizationRegistry_.[[Cells]], do
            1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then
              1. Remove _cell_ from _finalizationRegistry_.[[Cells]].
              1. Set _removed_ to *true*.
          1. Return _removed_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-finalization-registry.prototype-@@tostringtag" id="sec-finalization-registry.prototype-%symbol.tostringtag%">
        <h1>FinalizationRegistry.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"FinalizationRegistry"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-finalization-registry-instances">
      <h1>Properties of FinalizationRegistry Instances</h1>
      <p>FinalizationRegistry instances are ordinary objects that inherit properties from the FinalizationRegistry prototype object. FinalizationRegistry instances also have [[Cells]] and [[CleanupCallback]] internal slots.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-iteration">
    <h1>Iteration</h1>

    <emu-clause id="sec-common-iteration-interfaces">
      <h1>Common Iteration Interfaces</h1>
      <p>An interface is a set of property keys whose associated values match a specific specification. Any object that provides all the properties as described by an interface's specification <em>conforms</em> to that interface. An interface is not represented by a distinct object. There may be many separately implemented objects that conform to any interface. An individual object may conform to multiple interfaces.</p>

      <emu-clause id="sec-iterable-interface">
        <h1>The Iterable Interface</h1>
        <p>The <dfn variants="iterable,iterables,iterable object,iterable objects">iterable interface</dfn> includes the property described in <emu-xref href="#table-iterable-interface-required-properties"></emu-xref>:</p>
        <emu-table id="table-iterable-interface-required-properties" caption="Iterable Interface Required Properties" oldids="table-52">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `%Symbol.iterator%`
              </td>
              <td>
                a function that returns an iterator object
              </td>
              <td>
                The returned object must conform to the iterator interface.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-iterator-interface">
        <h1>The Iterator Interface</h1>
        <p>An object that implements the <dfn variants="iterator object,iterator objects,iterator,iterators">iterator interface</dfn> must include the property in <emu-xref href="#table-iterator-interface-required-properties"></emu-xref>. Such objects may also implement the properties in <emu-xref href="#table-iterator-interface-optional-properties"></emu-xref>.</p>
        <emu-table id="table-iterator-interface-required-properties" caption="Iterator Interface Required Properties" oldids="table-53">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"next"*
              </td>
              <td>
                a function that returns an IteratorResult object
              </td>
              <td>
                The returned object must conform to the IteratorResult interface. If a previous call to the `next` method of an iterator has returned an IteratorResult object whose *"done"* property is *true*, then all subsequent calls to the `next` method of that object should also return an IteratorResult object whose *"done"* property is *true*. However, this requirement is not enforced.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Arguments may be passed to the `next` function but their interpretation and validity is dependent upon the target iterator. The for-of statement and other common users of iterators do not pass any arguments, so iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.</p>
        </emu-note>
        <emu-table id="table-iterator-interface-optional-properties" caption="Iterator Interface Optional Properties" oldids="table-54">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"return"*
              </td>
              <td>
                a function that returns an IteratorResult object
              </td>
              <td>
                The returned object must conform to the IteratorResult interface. Invoking this method notifies the iterator object that the caller does not intend to make any more `next` method calls to the iterator. The returned IteratorResult object will typically have a *"done"* property whose value is *true*, and a *"value"* property with the value passed as the argument of the `return` method. However, this requirement is not enforced.
              </td>
            </tr>
            <tr>
              <td>
                *"throw"*
              </td>
              <td>
                a function that returns an IteratorResult object
              </td>
              <td>
                The returned object must conform to the IteratorResult interface. Invoking this method notifies the iterator object that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to `throw` the value passed as the argument. If the method does not `throw`, the returned IteratorResult object will typically have a *"done"* property whose value is *true*.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including `for`-`of`, `yield*`, and array destructuring call these methods after performing an existence check. Most ECMAScript library functions that accept iterable objects as arguments also conditionally call them.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-asynciterable-interface">
        <h1>The Async Iterable Interface</h1>
        <p>The <dfn variants="async iterable,async iterables,async iterable object,async iterable objects">async iterable interface</dfn> includes the properties described in <emu-xref href="#table-async-iterable"></emu-xref>:</p>
        <emu-table id="table-async-iterable" caption="Async Iterable Interface Required Properties">
          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
                <th>Requirements</th>
              </tr>
            </thead>
            <tr>
              <td>`%Symbol.asyncIterator%`</td>
              <td>a function that returns an async iterator object</td>
              <td>The returned object must conform to the async iterator interface.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asynciterator-interface">
        <h1>The Async Iterator Interface</h1>
        <p>An object that implements the <dfn variants="async iterator object,async iterator objects,async iterator,async iterators">async iterator interface</dfn> must include the properties in <emu-xref href="#table-async-iterator-required"></emu-xref>. Such objects may also implement the properties in <emu-xref href="#table-async-iterator-optional"></emu-xref>.</p>
        <emu-table id="table-async-iterator-required" caption="Async Iterator Interface Required Properties">
          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
                <th>Requirements</th>
              </tr>
            </thead>
            <tr>
              <td>*"next"*</td>
              <td>a function that returns a promise for an IteratorResult object</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object that conforms to the IteratorResult interface. If a previous call to the `next` method of an async iterator has returned a promise for an IteratorResult object whose *"done"* property is *true*, then all subsequent calls to the `next` method of that object should also return a promise for an IteratorResult object whose *"done"* property is *true*. However, this requirement is not enforced.</p>

                <p>Additionally, the IteratorResult object that serves as a fulfillment value should have a *"value"* property whose value is not a promise (or "thenable"). However, this requirement is also not enforced.</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Arguments may be passed to the `next` function but their interpretation and validity is dependent upon the target async iterator. The `for`-`await`-`of` statement and other common users of async iterators do not pass any arguments, so async iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.</p>
        </emu-note>
        <emu-table id="table-async-iterator-optional" caption="Async Iterator Interface Optional Properties">
          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
                <th>Requirements</th>
              </tr>
            </thead>
            <tr>
              <td>*"return"*</td>
              <td>a function that returns a promise for an IteratorResult object</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object that conforms to the IteratorResult interface. Invoking this method notifies the async iterator object that the caller does not intend to make any more `next` method calls to the async iterator. The returned promise will fulfill with an IteratorResult object which will typically have a *"done"* property whose value is *true*, and a *"value"* property with the value passed as the argument of the `return` method. However, this requirement is not enforced.</p>

                <p>Additionally, the IteratorResult object that serves as a fulfillment value should have a *"value"* property whose value is not a promise (or "thenable"). If the argument value is used in the typical manner, then if it is a rejected promise, a promise rejected with the same reason should be returned; if it is a fulfilled promise, then its fulfillment value should be used as the *"value"* property of the returned promise's IteratorResult object fulfillment value. However, these requirements are also not enforced.</p>
              </td>
            </tr>
            <tr>
              <td>*"throw"*</td>
              <td>a function that returns a promise for an IteratorResult object</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object that conforms to the IteratorResult interface. Invoking this method notifies the async iterator object that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to return a rejected promise which rejects with the value passed as the argument.</p>

                <p>If the returned promise is fulfilled, the IteratorResult object fulfillment value will typically have a *"done"* property whose value is *true*. Additionally, it should have a *"value"* property whose value is not a promise (or "thenable"), but this requirement is not enforced.</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including `for`-`await`-`of` and `yield*` call these methods after performing an existence check.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iteratorresult-interface">
        <h1>The IteratorResult Interface</h1>
        <p>The <dfn variants="IteratorResult object,IteratorResult objects">IteratorResult interface</dfn> includes the properties listed in <emu-xref href="#table-iteratorresult-interface-properties"></emu-xref>:</p>
        <emu-table id="table-iteratorresult-interface-properties" caption="IteratorResult Interface Properties" oldids="table-55">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"done"*
              </td>
              <td>
                a Boolean
              </td>
              <td>
                This is the result status of an iterator `next` method call. If the end of the iterator was reached *"done"* is *true*. If the end was not reached *"done"* is *false* and a value is available. If a *"done"* property (either own or inherited) does not exist, it is considered to have the value *false*.
              </td>
            </tr>
            <tr>
              <td>
                *"value"*
              </td>
              <td>
                an ECMAScript language value
              </td>
              <td>
                If done is *false*, this is the current iteration element value. If done is *true*, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, *"value"* is *undefined*. In that case, the *"value"* property may be absent from the conforming object if it does not inherit an explicit *"value"* property.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-helper-objects">
      <h1>Iterator Helper Objects</h1>
      <p>An <dfn variants="Iterator Helper objects">Iterator Helper object</dfn> is an ordinary object that represents a lazy transformation of some specific source iterator object. There is not a named constructor for Iterator Helper objects. Instead, Iterator Helper objects are created by calling certain methods of Iterator instance objects.</p>

      <emu-clause id="sec-%iteratorhelperprototype%-object">
        <h1>The %IteratorHelperPrototype% Object</h1>
        <p>The <dfn>%IteratorHelperPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Iterator Helper objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%iteratorhelperprototype%.next">
          <h1>%IteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? GeneratorResume(*this* value, *undefined*, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%.return">
          <h1>%IteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. Let _O_ be *this* value.
            1. Perform ? RequireInternalSlot(_O_, [[UnderlyingIterator]]).
            1. Assert: _O_ has a [[GeneratorState]] internal slot.
            1. If _O_.[[GeneratorState]] is ~suspended-start~, then
              1. Set _O_.[[GeneratorState]] to ~completed~.
              1. NOTE: Once a generator enters the completed state it never leaves it and its associated execution context is never resumed. Any execution state associated with _O_ can be discarded at this point.
              1. Perform ? IteratorClose(_O_.[[UnderlyingIterator]], NormalCompletion(~unused~)).
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. Let _C_ be ReturnCompletion(*undefined*).
            1. Return ? GeneratorResumeAbrupt(_O_, _C_, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%-%symbol.tostringtag%">
          <h1>%IteratorHelperPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Iterator Helper"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-objects">
      <h1>Iterator Objects</h1>

      <emu-clause id="sec-iterator-constructor">
        <h1>The Iterator Constructor</h1>
        <p>The <dfn>Iterator</dfn> constructor:</p>
        <ul>
          <li>is <dfn>%Iterator%</dfn>.</li>
          <li>is the initial value of the *"Iterator"* property of the global object.</li>
          <li>is designed to be subclassable. It may be used as the value of an *extends* clause of a class definition.</li>
        </ul>

        <emu-clause id="sec-iterator">
          <h1>Iterator ( )</h1>
          <p>This function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is either *undefined* or the active function object, throw a *TypeError* exception.
            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *"%Iterator.prototype%"*).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-iterator-constructor">
        <h1>Properties of the Iterator Constructor</h1>
        <p>The Iterator constructor:</p>
        <ul>
          <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-iterator.from">
          <h1>Iterator.from ( _O_ )</h1>
          <emu-alg>
            1. Let _iteratorRecord_ be ? GetIteratorFlattenable(_O_, ~iterate-string-primitives~).
            1. Let _hasInstance_ be ? OrdinaryHasInstance(%Iterator%, _iteratorRecord_.[[Iterator]]).
            1. If _hasInstance_ is *true*, then
              1. Return _iteratorRecord_.[[Iterator]].
            1. Let _wrapper_ be OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] »).
            1. Set _wrapper_.[[Iterated]] to _iteratorRecord_.
            1. Return _wrapper_.
          </emu-alg>

          <emu-clause id="sec-%wrapforvaliditeratorprototype%-object">
            <h1>The %WrapForValidIteratorPrototype% Object</h1>
            <p>The <dfn>%WrapForValidIteratorPrototype%</dfn> object:</p>
            <ul>
              <li>is an ordinary object.</li>
              <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
            </ul>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.next">
              <h1>%WrapForValidIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Perform ? RequireInternalSlot(_O_, [[Iterated]]).
                1. Let _iteratorRecord_ be _O_.[[Iterated]].
                1. Return ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.return">
              <h1>%WrapForValidIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Perform ? RequireInternalSlot(_O_, [[Iterated]]).
                1. Let _iterator_ be _O_.[[Iterated]].[[Iterator]].
                1. Assert: _iterator_ is an Object.
                1. Let _returnMethod_ be ? GetMethod(_iterator_, *"return"*).
                1. If _returnMethod_ is *undefined*, then
                  1. Return CreateIteratorResultObject(*undefined*, *true*).
                1. Return ? Call(_returnMethod_, _iterator_).
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype">
          <h1>Iterator.prototype</h1>
          <p>The initial value of Iterator.prototype is the Iterator prototype object.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-%iteratorprototype%-object" id="sec-%iterator.prototype%-object">
      <h1>Properties of the Iterator Prototype Object</h1>
      <p>The <dfn>Iterator prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Iterator.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
      </ul>
      <emu-note>
        <p>All objects defined in this specification that implement the iterator interface also inherit from %Iterator.prototype%. ECMAScript code may also define objects that inherit from %Iterator.prototype%. %Iterator.prototype% provides a place where additional methods that are applicable to all iterator objects may be added.</p>
        <p>The following expression is one way that ECMAScript code can access the %Iterator.prototype% object:</p>
        <pre><code class="javascript">Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))</code></pre>
      </emu-note>

      <emu-clause id="sec-iterator.prototype.constructor">
        <h1>Iterator.prototype.constructor</h1>
        <p>`Iterator.prototype.constructor` is an accessor property with attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }. The [[Get]] and [[Set]] attributes are defined as follows:</p>

        <emu-clause id="sec-get-iterator.prototype.constructor">
          <h1>get Iterator.prototype.constructor</h1>
          <p>The value of the [[Get]] attribute is a built-in function that requires no arguments. It performs the following steps when called:</p>
          <emu-alg>
            1. Return %Iterator%.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype.constructor">
          <h1>set Iterator.prototype.constructor</h1>
          <p>The value of the [[Set]] attribute is a built-in function that takes an argument _v_. It performs the following steps when called:</p>
          <emu-alg>
            1. Perform ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, *"constructor"*, _v_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>Unlike the *"constructor"* property on most built-in prototypes, for web-compatibility reasons this property must be an accessor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.drop">
        <h1>Iterator.prototype.drop ( _limit_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. Let _numLimit_ be Completion(ToNumber(_limit_)).
          1. IfAbruptCloseIterator(_numLimit_, _iterated_).
          1. If _numLimit_ is *NaN*, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat, while _remaining_ > 0,
              1. If _remaining_ ≠ +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is ~done~, return ReturnCompletion(*undefined*).
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _completion_ be Completion(Yield(_value_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.every">
        <h1>Iterator.prototype.every ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *true*.
            1. Let _result_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *false*, return ? IteratorClose(_iterated_, NormalCompletion(*false*)).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.filter">
        <h1>Iterator.prototype.filter ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _predicate_ and performs the following steps when called:
            1. Let _counter_ be 0.
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _selected_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
              1. IfAbruptCloseIterator(_selected_, _iterated_).
              1. If ToBoolean(_selected_) is *true*, then
                1. Let _completion_ be Completion(Yield(_value_)).
                1. IfAbruptCloseIterator(_completion_, _iterated_).
              1. Set _counter_ to _counter_ + 1.
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.find">
        <h1>Iterator.prototype.find ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *undefined*.
            1. Let _result_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? IteratorClose(_iterated_, NormalCompletion(_value_)).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.flatmap">
        <h1>Iterator.prototype.flatMap ( _mapper_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_mapper_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Let _counter_ be 0.
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »)).
              1. IfAbruptCloseIterator(_mapped_, _iterated_).
              1. Let _innerIterator_ be Completion(GetIteratorFlattenable(_mapped_, ~reject-primitives~)).
              1. IfAbruptCloseIterator(_innerIterator_, _iterated_).
              1. Let _innerAlive_ be *true*.
              1. Repeat, while _innerAlive_ is *true*,
                1. Let _innerValue_ be Completion(IteratorStepValue(_innerIterator_)).
                1. IfAbruptCloseIterator(_innerValue_, _iterated_).
                1. If _innerValue_ is ~done~, then
                  1. Set _innerAlive_ to *false*.
                1. Else,
                  1. Let _completion_ be Completion(Yield(_innerValue_)).
                  1. If _completion_ is an abrupt completion, then
                    1. Let _backupCompletion_ be Completion(IteratorClose(_innerIterator_, _completion_)).
                    1. IfAbruptCloseIterator(_backupCompletion_, _iterated_).
                    1. Return ? IteratorClose(_iterated_, _completion_).
              1. Set _counter_ to _counter_ + 1.
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.foreach">
        <h1>Iterator.prototype.forEach ( _procedure_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_procedure_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *undefined*.
            1. Let _result_ be Completion(Call(_procedure_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.map">
        <h1>Iterator.prototype.map ( _mapper_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_mapper_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Let _counter_ be 0.
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »)).
              1. IfAbruptCloseIterator(_mapped_, _iterated_).
              1. Let _completion_ be Completion(Yield(_mapped_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
              1. Set _counter_ to _counter_ + 1.
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.reduce">
        <h1>Iterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_reducer_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. If _initialValue_ is not present, then
            1. Let _accumulator_ be ? IteratorStepValue(_iterated_).
            1. If _accumulator_ is ~done~, throw a *TypeError* exception.
            1. Let _counter_ be 1.
          1. Else,
            1. Let _accumulator_ be _initialValue_.
            1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return _accumulator_.
            1. Let _result_ be Completion(Call(_reducer_, *undefined*, « _accumulator_, _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. Set _accumulator_ to _result_.
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.some">
        <h1>Iterator.prototype.some ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *false*.
            1. Let _result_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? IteratorClose(_iterated_, NormalCompletion(*true*)).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.take">
        <h1>Iterator.prototype.take ( _limit_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. Let _numLimit_ be Completion(ToNumber(_limit_)).
          1. IfAbruptCloseIterator(_numLimit_, _iterated_).
          1. If _numLimit_ is *NaN*, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat,
              1. If _remaining_ = 0, then
                1. Return ? IteratorClose(_iterated_, ReturnCompletion(*undefined*)).
              1. If _remaining_ ≠ +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _completion_ be Completion(Yield(_value_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.toarray">
        <h1>Iterator.prototype.toArray ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be ? GetIteratorDirect(_O_).
          1. Let _items_ be a new empty List.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return CreateArrayFromList(_items_).
            1. Append _value_ to _items_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%iteratorprototype%-@@iterator,sec-%iteratorprototype%-%symbol.iterator%" id="sec-iterator.prototype-%symbol.iterator%">
        <h1>Iterator.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.iterator]"*.</p>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype-%symbol.tostringtag%">
        <h1>Iterator.prototype [ %Symbol.toStringTag% ]</h1>
        <p>`Iterator.prototype[%Symbol.toStringTag%]` is an accessor property with attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }. The [[Get]] and [[Set]] attributes are defined as follows:</p>

        <emu-clause id="sec-get-iterator.prototype-%symbol.tostringtag%">
          <h1>get Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>The value of the [[Get]] attribute is a built-in function that requires no arguments. It performs the following steps when called:</p>
          <emu-alg>
            1. Return *"Iterator"*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype-%symbol.tostringtag%">
          <h1>set Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>The value of the [[Set]] attribute is a built-in function that takes an argument _v_. It performs the following steps when called:</p>
          <emu-alg>
            1. Perform ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, %Symbol.toStringTag%, _v_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>Unlike the %Symbol.toStringTag% property on most built-in prototypes, for web-compatibility reasons this property must be an accessor.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>The %AsyncIteratorPrototype% Object</h1>
      <p>The <dfn>%AsyncIteratorPrototype%</dfn> object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
      </ul>
      <emu-note>
        <p>All objects defined in this specification that implement the async iterator interface also inherit from %AsyncIteratorPrototype%. ECMAScript code may also define objects that inherit from %AsyncIteratorPrototype%. The %AsyncIteratorPrototype% object provides a place where additional methods that are applicable to all async iterator objects may be added.</p>
      </emu-note>

      <emu-clause oldids="sec-asynciteratorprototype-asynciterator" id="sec-%asynciteratorprototype%-%symbol.asynciterator%">
        <h1>%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.asyncIterator]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-from-sync-iterator-objects">
      <h1>Async-from-Sync Iterator Objects</h1>
      <p>An <dfn variants="Async-from-Sync Iterator objects">Async-from-Sync Iterator object</dfn> is an async iterator that adapts a specific synchronous iterator. Async-from-Sync Iterator objects are never directly accessible to ECMAScript code. There is not a named constructor for Async-from-Sync Iterator objects. Instead, Async-from-Sync Iterator objects are created by the CreateAsyncFromSyncIterator abstract operation as needed.</p>

      <emu-clause id="sec-createasyncfromsynciterator" type="abstract operation">
        <h1>
          CreateAsyncFromSyncIterator (
            _syncIteratorRecord_: an Iterator Record,
          ): an Iterator Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create an async Iterator Record from a synchronous Iterator Record.</dd>
        </dl>
        <emu-alg>
          1. Let _asyncIterator_ be OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).
          1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.
          1. Let _nextMethod_ be ! Get(_asyncIterator_, *"next"*).
          1. Let _iteratorRecord_ be the Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.
          1. Return _iteratorRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%asyncfromsynciteratorprototype%-object">
        <h1>The %AsyncFromSyncIteratorPrototype% Object</h1>
        <p>The <dfn>%AsyncFromSyncIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Async-from-Sync Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %AsyncIteratorPrototype%.</li>
          <li>is never directly accessible to ECMAScript code.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.next">
          <h1>%AsyncFromSyncIteratorPrototype%.next ( [ _value_ ] )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. If _value_ is present, then
              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_, _value_)).
            1. Else,
              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.return">
          <h1>%AsyncFromSyncIteratorPrototype%.return ( [ _value_ ] )</h1>

          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. Let _syncIterator_ be _syncIteratorRecord_.[[Iterator]].
            1. Let _return_ be Completion(GetMethod(_syncIterator_, *"return"*)).
            1. IfAbruptRejectPromise(_return_, _promiseCapability_).
            1. If _return_ is *undefined*, then
              1. Let _iteratorResult_ be CreateIteratorResultObject(_value_, *true*).
              1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).
              1. Return _promiseCapability_.[[Promise]].
            1. If _value_ is present, then
              1. Let _result_ be Completion(Call(_return_, _syncIterator_, « _value_ »)).
            1. Else,
              1. Let _result_ be Completion(Call(_return_, _syncIterator_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. If _result_ is not an Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.throw">
          <h1>%AsyncFromSyncIteratorPrototype%.throw ( [ _value_ ] )</h1>
          <emu-note>In this specification, _value_ is always provided, but is left optional for consistency with <emu-xref title href="#sec-%asyncfromsynciteratorprototype%.return"></emu-xref>.</emu-note>

          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. Let _syncIterator_ be _syncIteratorRecord_.[[Iterator]].
            1. Let _throw_ be Completion(GetMethod(_syncIterator_, *"throw"*)).
            1. IfAbruptRejectPromise(_throw_, _promiseCapability_).
            1. If _throw_ is *undefined*, then
              1. NOTE: If _syncIterator_ does not have a `throw` method, close it to give it a chance to clean up before we reject the capability.
              1. Let _closeCompletion_ be NormalCompletion(~empty~).
              1. Let _result_ be Completion(IteratorClose(_syncIteratorRecord_, _closeCompletion_)).
              1. IfAbruptRejectPromise(_result_, _promiseCapability_).
              1. NOTE: The next step throws a *TypeError* to indicate that there was a protocol violation: _syncIterator_ does not have a `throw` method.
              1. NOTE: If closing _syncIterator_ does not throw then the result of that operation is ignored, even if it yields a rejected promise.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. If _value_ is present, then
              1. Let _result_ be Completion(Call(_throw_, _syncIterator_, « _value_ »)).
            1. Else,
              1. Let _result_ be Completion(Call(_throw_, _syncIterator_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. If _result_ is not an Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-async-from-sync-iterator-instances">
        <h1>Properties of Async-from-Sync Iterator Instances</h1>
        <p>Async-from-Sync Iterator instances are ordinary objects that inherit properties from the %AsyncFromSyncIteratorPrototype% intrinsic object. Async-from-Sync Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-async-from-sync-iterator-internal-slots"></emu-xref>.</p>
        <emu-table id="table-async-from-sync-iterator-internal-slots" caption="Internal Slots of Async-from-Sync Iterator Instances">
          <table>
            <thead>
              <tr>
                <th>
                  Internal Slot
                </th>
                <th>
                  Type
                </th>
                <th>
                  Description
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[SyncIteratorRecord]]
              </td>
              <td>
                an Iterator Record
              </td>
              <td>
                Represents the original synchronous iterator which is being adapted.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncfromsynciteratorcontinuation" type="abstract operation" oldids="sec-async-from-sync-iterator-value-unwrap-functions">
        <h1>
          AsyncFromSyncIteratorContinuation (
            _result_: an Object,
            _promiseCapability_: a PromiseCapability Record for an intrinsic %Promise%,
            _syncIteratorRecord_: an Iterator Record,
            _closeOnRejection_: a Boolean,
          ): a Promise
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. NOTE: Because _promiseCapability_ is derived from the intrinsic %Promise%, the calls to _promiseCapability_.[[Reject]] entailed by the use IfAbruptRejectPromise below are guaranteed not to throw.
          1. Let _done_ be Completion(IteratorComplete(_result_)).
          1. IfAbruptRejectPromise(_done_, _promiseCapability_).
          1. Let _value_ be Completion(IteratorValue(_result_)).
          1. IfAbruptRejectPromise(_value_, _promiseCapability_).
          1. Let _valueWrapper_ be Completion(PromiseResolve(%Promise%, _value_)).
          1. If _valueWrapper_ is an abrupt completion, _done_ is *false*, and _closeOnRejection_ is *true*, then
            1. Set _valueWrapper_ to Completion(IteratorClose(_syncIteratorRecord_, _valueWrapper_)).
          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).
          1. Let _unwrap_ be a new Abstract Closure with parameters (_v_) that captures _done_ and performs the following steps when called:
            1. Return CreateIteratorResultObject(_v_, _done_).
          1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, *""*, « »).
          1. NOTE: _onFulfilled_ is used when processing the *"value"* property of an IteratorResult object in order to wait for its value if it is a promise and re-package the result in a new "unwrapped" IteratorResult object.
          1. If _done_ is *true*, or if _closeOnRejection_ is *false*, then
            1. Let _onRejected_ be *undefined*.
          1. Else,
            1. Let _closeIterator_ be a new Abstract Closure with parameters (_error_) that captures _syncIteratorRecord_ and performs the following steps when called:
              1. Return ? IteratorClose(_syncIteratorRecord_, ThrowCompletion(_error_)).
            1. Let _onRejected_ be CreateBuiltinFunction(_closeIterator_, 1, *""*, « »).
            1. NOTE: _onRejected_ is used to close the Iterator when the *"value"* property of an IteratorResult object it yields is a rejected promise.
          1. Perform PerformPromiseThen(_valueWrapper_, _onFulfilled_, _onRejected_, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise Objects</h1>
    <p>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</p>
    <p>Any Promise is in one of three mutually exclusive states: <em>fulfilled</em>, <em>rejected</em>, and <em>pending</em>:</p>
    <ul>
      <li>
        A promise `p` is fulfilled if `p.then(f, r)` will immediately enqueue a Job to call the function `f`.
      </li>
      <li>
        A promise `p` is rejected if `p.then(f, r)` will immediately enqueue a Job to call the function `r`.
      </li>
      <li>
        A promise is pending if it is neither fulfilled nor rejected.
      </li>
    </ul>
    <p>A promise is said to be <em>settled</em> if it is not pending, i.e. if it is either fulfilled or rejected.</p>
    <p>A promise is <em>resolved</em> if it is settled or if it has been “locked in” to match the state of another promise. Attempting to resolve or reject a resolved promise has no effect. A promise is <em>unresolved</em> if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled or rejected.</p>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise Abstract Operations</h1>

      <emu-clause id="sec-promisecapability-records">
        <h1>PromiseCapability Records</h1>
        <p>A <dfn variants="PromiseCapability Records">PromiseCapability Record</dfn> is a Record value used to encapsulate a Promise or promise-like object along with the functions that are capable of resolving or rejecting that promise. PromiseCapability Records are produced by the NewPromiseCapability abstract operation.</p>
        <p>PromiseCapability Records have the fields listed in <emu-xref href="#table-promisecapability-record-fields"></emu-xref>.</p>
        <emu-table id="table-promisecapability-record-fields" caption="PromiseCapability Record Fields" oldids="table-57">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Promise]]
              </td>
              <td>
                an Object
              </td>
              <td>
                An object that is usable as a promise.
              </td>
            </tr>
            <tr>
              <td>
                [[Resolve]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The function that is used to resolve the given promise.
              </td>
            </tr>
            <tr>
              <td>
                [[Reject]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The function that is used to reject the given promise.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
          <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
          <p>IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a PromiseCapability Record. An algorithm step of the form:</p>
          <emu-alg>
            1. IfAbruptRejectPromise(_value_, _capability_).
          </emu-alg>
          <p>means the same thing as:</p>
          <emu-alg>
            1. Assert: _value_ is a Completion Record.
            1. If _value_ is an abrupt completion, then
              1. Perform ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »).
              1. Return _capability_.[[Promise]].
            1. Else,
              1. Set _value_ to ! _value_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction Records</h1>
        <p>A <dfn variants="PromiseReaction Records">PromiseReaction Record</dfn> is a Record value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction Records are created by the PerformPromiseThen abstract operation, and are used by the Abstract Closure returned by NewPromiseReactionJob.</p>
        <p>PromiseReaction Records have the fields listed in <emu-xref href="#table-promisereaction-record-fields"></emu-xref>.</p>
        <emu-table id="table-promisereaction-record-fields" caption="PromiseReaction Record Fields" oldids="table-58">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                a PromiseCapability Record or *undefined*
              </td>
              <td>
                The capabilities of the promise for which this record provides a reaction handler.
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                ~fulfill~ or ~reject~
              </td>
              <td>
                The [[Type]] is used when [[Handler]] is ~empty~ to allow for behaviour specific to the settlement type.
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                a JobCallback Record or ~empty~
              </td>
              <td>
                The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is ~empty~, a function that depends on the value of [[Type]] will be used instead.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-createresolvingfunctions" type="abstract operation">
        <h1>
          CreateResolvingFunctions (
            _promise_: a Promise,
          ): a Record with fields [[Resolve]] (a function object) and [[Reject]] (a function object)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _alreadyResolved_ be the Record { [[Value]]: *false* }.
          1. Let _stepsResolve_ be the algorithm steps defined in <emu-xref href="#sec-promise-resolve-functions" title></emu-xref>.
          1. Let _lengthResolve_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise-resolve-functions" title></emu-xref>.
          1. Let _resolve_ be CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *""*, « [[Promise]], [[AlreadyResolved]] »).
          1. Set _resolve_.[[Promise]] to _promise_.
          1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.
          1. Let _stepsReject_ be the algorithm steps defined in <emu-xref href="#sec-promise-reject-functions" title></emu-xref>.
          1. Let _lengthReject_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise-reject-functions" title></emu-xref>.
          1. Let _reject_ be CreateBuiltinFunction(_stepsReject_, _lengthReject_, *""*, « [[Promise]], [[AlreadyResolved]] »).
          1. Set _reject_.[[Promise]] to _promise_.
          1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.
          1. Return the Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }.
        </emu-alg>

        <emu-clause id="sec-promise-reject-functions">
          <h1>Promise Reject Functions</h1>
          <p>A promise reject function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
          <p>When a promise reject function is called with argument _reason_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
            1. Let _promise_ be _F_.[[Promise]].
            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyResolved_.[[Value]] to *true*.
            1. Perform RejectPromise(_promise_, _reason_).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a promise reject function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>

        <emu-clause id="sec-promise-resolve-functions">
          <h1>Promise Resolve Functions</h1>
          <p>A promise resolve function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
          <p>When a promise resolve function is called with argument _resolution_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
            1. Let _promise_ be _F_.[[Promise]].
            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyResolved_.[[Value]] to *true*.
            1. If SameValue(_resolution_, _promise_) is *true*, then
              1. Let _selfResolutionError_ be a newly created *TypeError* object.
              1. Perform RejectPromise(_promise_, _selfResolutionError_).
              1. Return *undefined*.
            1. If _resolution_ is not an Object, then
              1. Perform FulfillPromise(_promise_, _resolution_).
              1. Return *undefined*.
            1. Let _then_ be Completion(Get(_resolution_, *"then"*)).
            1. If _then_ is an abrupt completion, then
              1. Perform RejectPromise(_promise_, _then_.[[Value]]).
              1. Return *undefined*.
            1. Let _thenAction_ be _then_.[[Value]].
            1. If IsCallable(_thenAction_) is *false*, then
              1. Perform FulfillPromise(_promise_, _resolution_).
              1. Return *undefined*.
            1. Let _thenJobCallback_ be HostMakeJobCallback(_thenAction_).
            1. Let _job_ be NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_).
            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a promise resolve function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-fulfillpromise" type="abstract operation">
        <h1>
          FulfillPromise (
            _promise_: a Promise,
            _value_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promise_.[[PromiseState]] is ~pending~.
          1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].
          1. Set _promise_.[[PromiseResult]] to _value_.
          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
          1. Set _promise_.[[PromiseState]] to ~fulfilled~.
          1. Perform TriggerPromiseReactions(_reactions_, _value_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromisecapability" type="abstract operation" oldids="sec-getcapabilitiesexecutor-functions">
        <h1>
          NewPromiseCapability (
            _C_: an ECMAScript language value,
          ): either a normal completion containing a PromiseCapability Record or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It attempts to use _C_ as a constructor in the fashion of the built-in Promise constructor to create a promise and extract its `resolve` and `reject` functions. The promise plus the `resolve` and `reject` functions are used to initialize a new PromiseCapability Record.</dd>
        </dl>
        <emu-alg>
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href="#sec-promise-executor"></emu-xref>).
          1. Let _resolvingFunctions_ be the Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.
          1. Let _executorClosure_ be a new Abstract Closure with parameters (_resolve_, _reject_) that captures _resolvingFunctions_ and performs the following steps when called:
            1. If _resolvingFunctions_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.
            1. If _resolvingFunctions_.[[Reject]] is not *undefined*, throw a *TypeError* exception.
            1. Set _resolvingFunctions_.[[Resolve]] to _resolve_.
            1. Set _resolvingFunctions_.[[Reject]] to _reject_.
            1. Return NormalCompletion(*undefined*).
          1. Let _executor_ be CreateBuiltinFunction(_executorClosure_, 2, *""*, « »).
          1. Let _promise_ be ? Construct(_C_, « _executor_ »).
          1. If IsCallable(_resolvingFunctions_.[[Resolve]]) is *false*, throw a *TypeError* exception.
          1. If IsCallable(_resolvingFunctions_.[[Reject]]) is *false*, throw a *TypeError* exception.
          1. Return the PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }.
        </emu-alg>
        <emu-note>
          <p>This abstract operation supports Promise subclassing, as it is generic on any constructor that calls a passed executor function argument in the same way as the Promise constructor. It is used to generalize static methods of the Promise constructor to any subclass.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-ispromise" type="abstract operation">
        <h1>
          IsPromise (
            _x_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It checks for the promise brand on an object.</dd>
        </dl>
        <emu-alg>
          1. If _x_ is not an Object, return *false*.
          1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rejectpromise" type="abstract operation">
        <h1>
          RejectPromise (
            _promise_: a Promise,
            _reason_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promise_.[[PromiseState]] is ~pending~.
          1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].
          1. Set _promise_.[[PromiseResult]] to _reason_.
          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
          1. Set _promise_.[[PromiseState]] to ~rejected~.
          1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *"reject"*).
          1. Perform TriggerPromiseReactions(_reactions_, _reason_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-triggerpromisereactions" type="abstract operation">
        <h1>
          TriggerPromiseReactions (
            _reactions_: a List of PromiseReaction Records,
            _argument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It enqueues a new Job for each record in _reactions_. Each such Job processes the [[Type]] and [[Handler]] of the PromiseReaction Record, and if the [[Handler]] is not ~empty~, calls it passing the given argument. If the [[Handler]] is ~empty~, the behaviour is determined by the [[Type]].</dd>
        </dl>
        <emu-alg>
          1. For each element _reaction_ of _reactions_, do
            1. Let _job_ be NewPromiseReactionJob(_reaction_, _argument_).
            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" type="host-defined abstract operation">
        <h1>
          HostPromiseRejectionTracker (
            _promise_: a Promise,
            _operation_: *"reject"* or *"handle"*,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It allows host environments to track promise rejections.</dd>
        </dl>
        <p>The default implementation of HostPromiseRejectionTracker is to return ~unused~.</p>

        <emu-note>
          <p>HostPromiseRejectionTracker is called in two scenarios:</p>

          <ul>
            <li>When a promise is rejected without any handlers, it is called with its _operation_ argument set to *"reject"*.</li>
            <li>When a handler is added to a rejected promise for the first time, it is called with its _operation_ argument set to *"handle"*.</li>
          </ul>

          <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>
        </emu-note>

        <emu-note>
          <p>If _operation_ is *"handle"*, an implementation should not hold a reference to _promise_ in a way that would interfere with garbage collection. An implementation may hold a reference to _promise_ if _operation_ is *"reject"*, since it is expected that rejections will be rare and not on hot code paths.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise Jobs</h1>

      <emu-clause id="sec-newpromisereactionjob" type="abstract operation" oldids="sec-promisereactionjob">
        <h1>
          NewPromiseReactionJob (
            _reaction_: a PromiseReaction Record,
            _argument_: an ECMAScript language value,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record or *null*)
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns a new Job Abstract Closure that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.</dd>
        </dl>
        <emu-alg>
          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:
            1. Let _promiseCapability_ be _reaction_.[[Capability]].
            1. Let _type_ be _reaction_.[[Type]].
            1. Let _handler_ be _reaction_.[[Handler]].
            1. If _handler_ is ~empty~, then
              1. If _type_ is ~fulfill~, then
                1. Let _handlerResult_ be NormalCompletion(_argument_).
              1. Else,
                1. Assert: _type_ is ~reject~.
                1. Let _handlerResult_ be ThrowCompletion(_argument_).
            1. Else,
              1. Let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).
            1. If _promiseCapability_ is *undefined*, then
              1. Assert: _handlerResult_ is not an abrupt completion.
              1. Return ~empty~.
            1. Assert: _promiseCapability_ is a PromiseCapability Record.
            1. If _handlerResult_ is an abrupt completion, then
              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).
            1. Else,
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).
          1. Let _handlerRealm_ be *null*.
          1. If _reaction_.[[Handler]] is not ~empty~, then
            1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).
            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].
            1. Else, set _handlerRealm_ to the current Realm Record.
            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.
          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromiseresolvethenablejob" type="abstract operation" oldids="sec-promiseresolvethenablejob">
        <h1>
          NewPromiseResolveThenableJob (
            _promiseToResolve_: a Promise,
            _thenable_: an Object,
            _then_: a JobCallback Record,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:
            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).
            1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).
            1. If _thenCallResult_ is an abrupt completion, then
              1. Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).
            1. Return ! _thenCallResult_.
          1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).
          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].
          1. Else, let _thenRealm_ be the current Realm Record.
          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.
          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.
        </emu-alg>
        <emu-note>
          <p>This Job uses the supplied thenable and its `then` method to resolve the given promise. This process must take place as a Job to ensure that the evaluation of the `then` method occurs after evaluation of any surrounding code has completed.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-constructor">
      <h1>The Promise Constructor</h1>
      <p>The Promise constructor:</p>
      <ul>
        <li>is <dfn>%Promise%</dfn>.</li>
        <li>is the initial value of the *"Promise"* property of the global object.</li>
        <li>creates and initializes a new Promise when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Promise behaviour must include a `super` call to the Promise constructor to create and initialize the subclass instance with the internal state necessary to support the `Promise` and `Promise.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-promise-executor">
        <h1>Promise ( _executor_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.
          1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Promise.prototype%"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).
          1. Set _promise_.[[PromiseState]] to ~pending~.
          1. Set _promise_.[[PromiseResult]] to ~empty~.
          1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.
          1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.
          1. Set _promise_.[[PromiseIsHandled]] to *false*.
          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).
          1. Let _completion_ be Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).
          1. If _completion_ is an abrupt completion, then
            1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »).
          1. Return _promise_.
        </emu-alg>
        <emu-note>
          <p>The _executor_ argument must be a function object. It is called for initiating and reporting completion of the possibly deferred action represented by this Promise. The executor is called with two arguments: _resolve_ and _reject_. These are functions that may be used by the _executor_ function to report eventual completion or failure of the deferred computation. Returning from the executor function does not mean that the deferred action has been completed but only that the request to eventually perform the deferred action has been accepted.</p>
          <p>The _resolve_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _resolve_ function to indicate that it wishes to resolve the associated Promise. The argument passed to the _resolve_ function represents the eventual value of the deferred action and can be either the actual fulfillment value or another promise which will provide the value if it is fulfilled.</p>
          <p>The _reject_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _reject_ function to indicate that the associated Promise is rejected and will never be fulfilled. The argument passed to the _reject_ function is used as the rejection value of the promise. Typically it will be an Error object.</p>
          <p>The resolve and reject functions passed to an _executor_ function by the Promise constructor have the capability to actually resolve and reject the associated promise. Subclasses may have different constructor behaviour that passes in customized values for resolve and reject.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Properties of the Promise Constructor</h1>
      <p>The Promise constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-promise.all">
        <h1>Promise.all ( _iterable_ )</h1>
        <p>This function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>This function requires its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>

        <emu-clause id="sec-getpromiseresolve" type="abstract operation">
          <h1>
            GetPromiseResolve (
              _promiseConstructor_: a constructor,
            ): either a normal completion containing a function object or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _promiseResolve_ be ? Get(_promiseConstructor_, *"resolve"*).
            1. If IsCallable(_promiseResolve_) is *false*, throw a *TypeError* exception.
            1. Return _promiseResolve_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-performpromiseall" type="abstract operation">
          <h1>
            PerformPromiseAll (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _values_ be a new empty List.
            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] = 0, then
                  1. Let _valuesArray_ be CreateArrayFromList(_values_).
                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
                1. Return _resultCapability_.[[Promise]].
              1. Append *undefined* to _values_.
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref>.
              1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref>.
              1. Let _onFulfilled_ be CreateBuiltinFunction(_steps_, _length_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
              1. Set _onFulfilled_.[[AlreadyCalled]] to *false*.
              1. Set _onFulfilled_.[[Index]] to _index_.
              1. Set _onFulfilled_.[[Values]] to _values_.
              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.
              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _resultCapability_.[[Reject]] »).
              1. Set _index_ to _index_ + 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.all-resolve-element-functions">
          <h1>`Promise.all` Resolve Element Functions</h1>
          <p>A `Promise.all` resolve element function is an anonymous built-in function that is used to resolve a specific `Promise.all` element. Each `Promise.all` resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.all` resolve element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.
            1. Set _F_.[[AlreadyCalled]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Set _values_[_index_] to _x_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.all` resolve element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.allsettled">
        <h1>Promise.allSettled ( _iterable_ )</h1>
        <p>This function returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>This function requires its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseallsettled" type="abstract operation">
          <h1>
            PerformPromiseAllSettled (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _values_ be a new empty List.
            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] = 0, then
                  1. Let _valuesArray_ be CreateArrayFromList(_values_).
                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
                1. Return _resultCapability_.[[Promise]].
              1. Append *undefined* to _values_.
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref>.
              1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref>.
              1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
              1. Let _alreadyCalled_ be the Record { [[Value]]: *false* }.
              1. Set _onFulfilled_.[[AlreadyCalled]] to _alreadyCalled_.
              1. Set _onFulfilled_.[[Index]] to _index_.
              1. Set _onFulfilled_.[[Values]] to _values_.
              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.
              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.
              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref>.
              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref>.
              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
              1. Set _onRejected_.[[AlreadyCalled]] to _alreadyCalled_.
              1. Set _onRejected_.[[Index]] to _index_.
              1. Set _onRejected_.[[Values]] to _values_.
              1. Set _onRejected_.[[Capability]] to _resultCapability_.
              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _onRejected_ »).
              1. Set _index_ to _index_ + 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-resolve-element-functions">
          <h1>`Promise.allSettled` Resolve Element Functions</h1>
          <p>A `Promise.allSettled` resolve element function is an anonymous built-in function that is used to resolve a specific `Promise.allSettled` element. Each `Promise.allSettled` resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.allSettled` resolve element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].
            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyCalled_.[[Value]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"fulfilled"*).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"value"*, _x_).
            1. Set _values_[_index_] to _obj_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.allSettled` resolve element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-reject-element-functions">
          <h1>`Promise.allSettled` Reject Element Functions</h1>
          <p>A `Promise.allSettled` reject element function is an anonymous built-in function that is used to reject a specific `Promise.allSettled` element. Each `Promise.allSettled` reject element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.allSettled` reject element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].
            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyCalled_.[[Value]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"rejected"*).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"reason"*, _x_).
            1. Set _values_[_index_] to _obj_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.allSettled` reject element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.any">
        <h1>Promise.any ( _iterable_ )</h1>
        <p>This function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an `AggregateError` holding the rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>This function requires its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseany" type="abstract operation">
          <h1>
            PerformPromiseAny (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _errors_ be a new empty List.
            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] = 0, then
                  1. Let _error_ be a newly created *AggregateError* object.
                  1. Perform ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).
                  1. Return ThrowCompletion(_error_).
                1. Return _resultCapability_.[[Promise]].
              1. Append *undefined* to _errors_.
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref>.
              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref>.
              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).
              1. Set _onRejected_.[[AlreadyCalled]] to *false*.
              1. Set _onRejected_.[[Index]] to _index_.
              1. Set _onRejected_.[[Errors]] to _errors_.
              1. Set _onRejected_.[[Capability]] to _resultCapability_.
              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _onRejected_ »).
              1. Set _index_ to _index_ + 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.any-reject-element-functions">
          <h1>`Promise.any` Reject Element Functions</h1>
          <p>A `Promise.any` reject element function is an anonymous built-in function that is used to reject a specific `Promise.any` element. Each `Promise.any` reject element function has [[Index]], [[Errors]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.any` reject element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.
            1. Set _F_.[[AlreadyCalled]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _errors_ be _F_.[[Errors]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Set _errors_[_index_] to _x_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _error_ be a newly created *AggregateError* object.
              1. Perform ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).
              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.any` reject element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype">
        <h1>Promise.prototype</h1>
        <p>The initial value of `Promise.prototype` is the Promise prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-promise.race">
        <h1>Promise.race ( _iterable_ )</h1>
        <p>This function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed _iterable_ to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>If the _iterable_ argument yields no values or if none of the promises yielded by _iterable_ ever settle, then the pending promise returned by this method will never be settled.</p>
        </emu-note>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor. It also expects that its *this* value provides a `resolve` method.</p>
        </emu-note>

        <emu-clause id="sec-performpromiserace" type="abstract operation">
          <h1>
            PerformPromiseRace (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Return _resultCapability_.[[Promise]].
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.reject">
        <h1>Promise.reject ( _r_ )</h1>
        <p>This function returns a new promise rejected with the passed argument.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.resolve">
        <h1>Promise.resolve ( _x_ )</h1>
        <p>This function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _C_ is not an Object, throw a *TypeError* exception.
          1. Return ? PromiseResolve(_C_, _x_).
        </emu-alg>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>

        <emu-clause id="sec-promise-resolve" type="abstract operation">
          <h1>
            PromiseResolve (
              _C_: an Object,
              _x_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It returns a new promise resolved with _x_.</dd>
          </dl>
          <emu-alg>
            1. If IsPromise(_x_) is *true*, then
              1. Let _xConstructor_ be ? Get(_x_, *"constructor"*).
              1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.
            1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »).
            1. Return _promiseCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.try">
        <h1>Promise.try ( _callback_, ..._args_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _C_ is not an Object, throw a *TypeError* exception.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _status_ be Completion(Call(_callback_, *undefined*, _args_)).
          1. If _status_ is an abrupt completion, then
            1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _status_.[[Value]] »).
          1. Else,
            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _status_.[[Value]] »).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.withResolvers">
        <h1>Promise.withResolvers ( )</h1>
        <p>This function returns an object with three properties: a new promise together with the `resolve` and `reject` functions associated with it.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, *"promise"*, _promiseCapability_.[[Promise]]).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, *"resolve"*, _promiseCapability_.[[Resolve]]).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, *"reject"*, _promiseCapability_.[[Reject]]).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-get-promise-@@species" id="sec-get-promise-%symbol.species%">
        <h1>get Promise [ %Symbol.species% ]</h1>
        <p>`Promise[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Promise prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Properties of the Promise Prototype Object</h1>
      <p>The <dfn>Promise prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Promise.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[PromiseState]] internal slot or any of the other internal slots of Promise instances.</li>
      </ul>

      <emu-clause id="sec-promise.prototype.catch">
        <h1>Promise.prototype.catch ( _onRejected_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. Return ? Invoke(_promise_, *"then"*, « *undefined*, _onRejected_ »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.constructor">
        <h1>Promise.prototype.constructor</h1>
        <p>The initial value of `Promise.prototype.constructor` is %Promise%.</p>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.finally" oldids="sec-thenfinallyfunctions,sec-catchfinallyfunctions">
        <h1>Promise.prototype.finally ( _onFinally_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If _promise_ is not an Object, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Assert: IsConstructor(_C_) is *true*.
          1. If IsCallable(_onFinally_) is *false*, then
            1. Let _thenFinally_ be _onFinally_.
            1. Let _catchFinally_ be _onFinally_.
          1. Else,
            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:
              1. Let _result_ be ? Call(_onFinally_, *undefined*).
              1. Let _p_ be ? PromiseResolve(_C_, _result_).
              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:
                1. Return NormalCompletion(_value_).
              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *""*, « »).
              1. Return ? Invoke(_p_, *"then"*, « _valueThunk_ »).
            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *""*, « »).
            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:
              1. Let _result_ be ? Call(_onFinally_, *undefined*).
              1. Let _p_ be ? PromiseResolve(_C_, _result_).
              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:
                1. Return ThrowCompletion(_reason_).
              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *""*, « »).
              1. Return ? Invoke(_p_, *"then"*, « _thrower_ »).
            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *""*, « »).
          1. Return ? Invoke(_promise_, *"then"*, « _thenFinally_, _catchFinally_ »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).
        </emu-alg>

        <emu-clause id="sec-performpromisethen" type="abstract operation">
          <h1>
            PerformPromiseThen (
              _promise_: a Promise,
              _onFulfilled_: an ECMAScript language value,
              _onRejected_: an ECMAScript language value,
              optional _resultCapability_: a PromiseCapability Record,
            ): an ECMAScript language value
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs the “then” operation on _promise_ using _onFulfilled_ and _onRejected_ as its settlement actions. If _resultCapability_ is passed, the result is stored by updating _resultCapability_'s promise. If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter.</dd>
          </dl>
          <emu-alg>
            1. Assert: IsPromise(_promise_) is *true*.
            1. If _resultCapability_ is not present, then
              1. Set _resultCapability_ to *undefined*.
            1. If IsCallable(_onFulfilled_) is *false*, then
              1. Let _onFulfilledJobCallback_ be ~empty~.
            1. Else,
              1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).
            1. If IsCallable(_onRejected_) is *false*, then
              1. Let _onRejectedJobCallback_ be ~empty~.
            1. Else,
              1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).
            1. Let _fulfillReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ }.
            1. Let _rejectReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ }.
            1. If _promise_.[[PromiseState]] is ~pending~, then
              1. Append _fulfillReaction_ to _promise_.[[PromiseFulfillReactions]].
              1. Append _rejectReaction_ to _promise_.[[PromiseRejectReactions]].
            1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then
              1. Let _value_ be _promise_.[[PromiseResult]].
              1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).
              1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).
            1. Else,
              1. Assert: _promise_.[[PromiseState]] is ~rejected~.
              1. Let _reason_ be _promise_.[[PromiseResult]].
              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *"handle"*).
              1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).
              1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).
            1. Set _promise_.[[PromiseIsHandled]] to *true*.
            1. If _resultCapability_ is *undefined*, then
              1. Return *undefined*.
            1. Else,
              1. Return _resultCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-promise.prototype-@@tostringtag" id="sec-promise.prototype-%symbol.tostringtag%">
        <h1>Promise.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Promise"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-promise-instances">
      <h1>Properties of Promise Instances</h1>
      <p>Promise instances are ordinary objects that inherit properties from the Promise prototype object (the intrinsic, %Promise.prototype%). Promise instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-promise-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-promise-instances" caption="Internal Slots of Promise Instances" oldids="table-59">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[PromiseState]]
            </td>
            <td>
              ~pending~, ~fulfilled~, or ~rejected~
            </td>
            <td>
              Governs how a promise will react to incoming calls to its `then` method.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseResult]]
            </td>
            <td>
              an ECMAScript language value or ~empty~
            </td>
            <td>
              The value with which the promise has been fulfilled or rejected, if any. ~empty~ if and only if the [[PromiseState]] is ~pending~.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseFulfillReactions]]
            </td>
            <td>
              a List of PromiseReaction Records
            </td>
            <td>
              Records to be processed when/if the promise transitions from the ~pending~ state to the ~fulfilled~ state.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseRejectReactions]]
            </td>
            <td>
              a List of PromiseReaction Records
            </td>
            <td>
              Records to be processed when/if the promise transitions from the ~pending~ state to the ~rejected~ state.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseIsHandled]]
            </td>
            <td>
              a Boolean
            </td>
            <td>
              Indicates whether the promise has ever had a fulfillment or rejection handler; used in unhandled rejection tracking.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generatorfunction-objects">
    <h1>GeneratorFunction Objects</h1>
    <p>GeneratorFunctions are functions that are usually created by evaluating |GeneratorDeclaration|s, |GeneratorExpression|s, and |GeneratorMethod|s. They may also be created by calling the %GeneratorFunction% intrinsic.</p>
    <emu-figure id="figure-2" caption="Generator Objects Relationships" informative>
      <img alt="A staggering variety of boxes and arrows." height="700" src="img/figure-2.svg" width="900">
    </emu-figure>

    <emu-clause id="sec-generatorfunction-constructor">
      <h1>The GeneratorFunction Constructor</h1>
      <p>The GeneratorFunction constructor:</p>
      <ul>
        <li>is <dfn>%GeneratorFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new GeneratorFunction when called as a function rather than as a constructor. Thus the function call `GeneratorFunction (…)` is equivalent to the object creation expression `new GeneratorFunction (…)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified GeneratorFunction behaviour must include a `super` call to the GeneratorFunction constructor to create and initialize subclass instances with the internal slots necessary for built-in GeneratorFunction behaviour. All ECMAScript syntactic forms for defining generator function objects create direct instances of GeneratorFunction. There is no syntactic means to create instances of GeneratorFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-generatorfunction">
        <h1>GeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of a generator function; any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_).
        </emu-alg>
        <emu-note>
          <p>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-constructor">
      <h1>Properties of the GeneratorFunction Constructor</h1>
      <p>The GeneratorFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the Function constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function%.</li>
        <li oldids="sec-generatorfunction.length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is *"GeneratorFunction"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype">
        <h1>GeneratorFunction.prototype</h1>
        <p>The initial value of `GeneratorFunction.prototype` is the GeneratorFunction prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-prototype-object">
      <h1>Properties of the GeneratorFunction Prototype Object</h1>
      <p>The <dfn>GeneratorFunction prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%GeneratorFunction.prototype%</dfn> (see <emu-xref href="#figure-2"></emu-xref>).</li>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> or <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype.constructor">
        <h1>GeneratorFunction.prototype.constructor</h1>
        <p>The initial value of `GeneratorFunction.prototype.constructor` is %GeneratorFunction%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype.prototype">
        <h1>GeneratorFunction.prototype.prototype</h1>
        <p>The initial value of `GeneratorFunction.prototype.prototype` is %GeneratorPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-generatorfunction.prototype-@@tostringtag" id="sec-generatorfunction.prototype-%symbol.tostringtag%">
        <h1>GeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"GeneratorFunction"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-generatorfunction-instances">
      <h1>GeneratorFunction Instances</h1>
      <p>Every GeneratorFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. The value of the [[IsClassConstructor]] internal slot for all such instances is *false*.</p>
      <p>Each GeneratorFunction instance has the following own properties:</p>

      <emu-clause id="sec-generatorfunction-instances-length">
        <h1>length</h1>
        <p>The specification for the *"length"* property of Function instances given in <emu-xref href="#sec-function-instances-length"></emu-xref> also applies to GeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-name">
        <h1>name</h1>
        <p>The specification for the *"name"* property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to GeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-prototype">
        <h1>prototype</h1>
        <p>Whenever a GeneratorFunction instance is created another ordinary object is also created and is the initial value of the generator function's *"prototype"* property. The value of the prototype property is used to initialize the [[Prototype]] internal slot of a newly created Generator when the generator function object is invoked using [[Call]].</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Unlike Function instances, the object that is the value of a GeneratorFunction's *"prototype"* property does not have a *"constructor"* property whose value is the GeneratorFunction instance.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgeneratorfunction-objects">
    <h1>AsyncGeneratorFunction Objects</h1>
    <p>AsyncGeneratorFunctions are functions that are usually created by evaluating |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, and |AsyncGeneratorMethod| syntactic productions. They may also be created by calling the %AsyncGeneratorFunction% intrinsic.</p>

    <emu-clause id="sec-asyncgeneratorfunction-constructor">
      <h1>The AsyncGeneratorFunction Constructor</h1>
      <p>The AsyncGeneratorFunction constructor:</p>
      <ul>
        <li>is <dfn>%AsyncGeneratorFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new AsyncGeneratorFunction when called as a function rather than as a constructor. Thus the function call `AsyncGeneratorFunction (...)` is equivalent to the object creation expression `new AsyncGeneratorFunction (...)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncGeneratorFunction behaviour must include a `super` call to the AsyncGeneratorFunction constructor to create and initialize subclass instances with the internal slots necessary for built-in AsyncGeneratorFunction behaviour. All ECMAScript syntactic forms for defining async generator function objects create direct instances of AsyncGeneratorFunction. There is no syntactic means to create instances of AsyncGeneratorFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction">
        <h1>AsyncGeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of an async generator function; any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_).
        </emu-alg>
        <emu-note>
          <p>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction">
      <h1>Properties of the AsyncGeneratorFunction Constructor</h1>
      <p>The AsyncGeneratorFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the Function constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function%.</li>
        <li oldids="sec-asyncgeneratorfunction-length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is *"AsyncGeneratorFunction"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype">
        <h1>AsyncGeneratorFunction.prototype</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype` is the AsyncGeneratorFunction prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction-prototype">
      <h1>Properties of the AsyncGeneratorFunction Prototype Object</h1>
      <p>The <dfn>AsyncGeneratorFunction prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncGeneratorFunction.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> or <emu-xref href="#table-internal-slots-of-asyncgenerator-instances"></emu-xref>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-constructor">
        <h1>AsyncGeneratorFunction.prototype.constructor</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype.constructor` is %AsyncGeneratorFunction%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-prototype">
        <h1>AsyncGeneratorFunction.prototype.prototype</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype.prototype` is %AsyncGeneratorPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-asyncgeneratorfunction-prototype-tostringtag" id="sec-asyncgeneratorfunction-prototype-%symbol.tostringtag%">
        <h1>AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"AsyncGeneratorFunction"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunction-instances">
      <h1>AsyncGeneratorFunction Instances</h1>
      <p>Every AsyncGeneratorFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. The value of the [[IsClassConstructor]] internal slot for all such instances is *false*.</p>
      <p>Each AsyncGeneratorFunction instance has the following own properties:</p>

      <emu-clause id="sec-asyncgeneratorfunction-instance-length">
        <h1>length</h1>
        <p>The value of the *"length"* property is an integral Number that indicates the typical number of arguments expected by the AsyncGeneratorFunction. However, the language permits the function to be invoked with some other number of arguments. The behaviour of an AsyncGeneratorFunction when invoked on a number of arguments other than the number specified by its *"length"* property depends on the function.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-name">
        <h1>name</h1>
        <p>The specification for the *"name"* property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to AsyncGeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-prototype">
        <h1>prototype</h1>
        <p>Whenever an AsyncGeneratorFunction instance is created, another ordinary object is also created and is the initial value of the async generator function's *"prototype"* property. The value of the prototype property is used to initialize the [[Prototype]] internal slot of a newly created AsyncGenerator when the generator function object is invoked using [[Call]].</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Unlike function instances, the object that is the value of an AsyncGeneratorFunction's *"prototype"* property does not have a *"constructor"* property whose value is the AsyncGeneratorFunction instance.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator Objects</h1>
    <p>A Generator is created by calling a generator function and conforms to both the iterator interface and the iterable interface.</p>
    <p>Generator instances directly inherit properties from the initial value of the *"prototype"* property of the generator function that created the instance. Generator instances indirectly inherit properties from %GeneratorPrototype%.</p>

    <emu-clause id="sec-properties-of-generator-prototype">
      <h1>The %GeneratorPrototype% Object</h1>
      <p>The <dfn>%GeneratorPrototype%</dfn> object:</p>
      <ul>
        <li>is <dfn>%GeneratorFunction.prototype.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a Generator instance and does not have a [[GeneratorState]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
        <li>has properties that are indirectly inherited by all Generator instances.</li>
      </ul>

      <emu-clause id="sec-generator.prototype.constructor">
        <h1>%GeneratorPrototype%.constructor</h1>
        <p>The initial value of %GeneratorPrototype%`.constructor` is %GeneratorFunction.prototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.next">
        <h1>%GeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. Return ? GeneratorResume(*this* value, _value_, ~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.return">
        <h1>%GeneratorPrototype%.return ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Let _C_ be ReturnCompletion(_value_).
          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.throw">
        <h1>%GeneratorPrototype%.throw ( _exception_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Let _C_ be ThrowCompletion(_exception_).
          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-generator.prototype-@@tostringtag" id="sec-generator.prototype-%symbol.tostringtag%">
        <h1>%GeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Generator"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Properties of Generator Instances</h1>
      <p>Generator instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Internal Slots of Generator Instances" oldids="table-56">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              ~suspended-start~, ~suspended-yield~, ~executing~, or ~completed~
            </td>
            <td>
              The current execution state of the generator.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              an execution context
            </td>
            <td>
              The execution context that is used when executing the code of this generator.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              a String or ~empty~
            </td>
            <td>
              A brand used to distinguish different kinds of generators. The [[GeneratorBrand]] of generators declared by ECMAScript source text is always ~empty~.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator Abstract Operations</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[GeneratorState]] is ~suspended-start~.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.
            1. If _result_ is a normal completion, then
              1. Let _resultValue_ be *undefined*.
            1. Else if _result_ is a return completion, then
              1. Let _resultValue_ be _result_.[[Value]].
            1. Else,
              1. Assert: _result_ is a throw completion.
              1. Return ? _result_.
            1. Return NormalCompletion(CreateIteratorResultObject(_resultValue_, *true*)).
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[GeneratorContext]] to _genContext_.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing one of ~suspended-start~, ~suspended-yield~, or ~completed~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. Assert: _generator_ also has a [[GeneratorContext]] internal slot.
          1. Let _state_ be _generator_.[[GeneratorState]].
          1. If _state_ is ~executing~, throw a *TypeError* exception.
          1. Return _state_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~completed~, return CreateIteratorResultObject(*undefined*, *true*).
          1. Assert: _state_ is either ~suspended-start~ or ~suspended-yield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~suspended-start~, then
            1. Set _generator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. Set _state_ to ~completed~.
          1. If _state_ is ~completed~, then
            1. If _abruptCompletion_ is a return completion, then
              1. Return CreateIteratorResultObject(_abruptCompletion_.[[Value]], *true*).
            1. Return ? _abruptCompletion_.
          1. Assert: _state_ is ~suspended-yield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getgeneratorkind" type="abstract operation">
        <h1>GetGeneratorKind ( ): ~non-generator~, ~sync~, or ~async~</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. If _genContext_ does not have a Generator component, return ~non-generator~.
          1. Let _generator_ be the Generator component of _genContext_.
          1. If _generator_ has an [[AsyncGeneratorState]] internal slot, return ~async~.
          1. Else, return ~sync~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatoryield" type="abstract operation">
        <h1>
          GeneratorYield (
            _iteratorResult_: an Object that conforms to the IteratorResult interface,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. Assert: _genContext_ is the execution context of a generator.
          1. Let _generator_ be the value of the Generator component of _genContext_.
          1. Assert: GetGeneratorKind() is ~sync~.
          1. Set _generator_.[[GeneratorState]] to ~suspended-yield~.
          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Let _callerContext_ be the running execution context.
          1. Resume _callerContext_ passing NormalCompletion(_iteratorResult_). If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.
          1. Assert: If control reaches here, then _genContext_ is the running execution context again.
          1. Return _resumptionValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yield" type="abstract operation">
        <h1>
          Yield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _generatorKind_ be GetGeneratorKind().
          1. If _generatorKind_ is ~async~, return ? AsyncGeneratorYield(? Await(_value_)).
          1. Otherwise, return ? GeneratorYield(CreateIteratorResultObject(_value_, *false*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
            optional _extraSlots_: a List of names of internal slots,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.
          1. If _extraSlots_ is not present, set _extraSlots_ to a new empty List.
          1. Let _internalSlotsList_ be the list-concatenation of _extraSlots_ and « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[GeneratorState]] to ~suspended-start~.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform GeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator Objects</h1>
    <p>An AsyncGenerator is created by calling an async generator function and conforms to both the async iterator interface and the async iterable interface.</p>

    <p>AsyncGenerator instances directly inherit properties from the initial value of the *"prototype"* property of the async generator function that created the instance. AsyncGenerator instances indirectly inherit properties from %AsyncGeneratorPrototype%.</p>

    <emu-clause id="sec-properties-of-asyncgenerator-prototype">
      <h1>The %AsyncGeneratorPrototype% Object</h1>
      <p>The <dfn>%AsyncGeneratorPrototype%</dfn> object:</p>
      <ul>
        <li>is <dfn>%AsyncGeneratorFunction.prototype.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not an AsyncGenerator instance and does not have an [[AsyncGeneratorState]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %AsyncIteratorPrototype%.</li>
        <li>has properties that are indirectly inherited by all AsyncGenerator instances.</li>
      </ul>

      <emu-clause id="sec-asyncgenerator-prototype-constructor">
        <h1>%AsyncGeneratorPrototype%.constructor</h1>
        <p>The initial value of %AsyncGeneratorPrototype%`.constructor` is %AsyncGeneratorFunction.prototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-next">
        <h1>%AsyncGeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is ~completed~, then
            1. Let _iteratorResult_ be CreateIteratorResultObject(*undefined*, *true*).
            1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).
            1. Return _promiseCapability_.[[Promise]].
          1. Let _completion_ be NormalCompletion(_value_).
          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
          1. If _state_ is either ~suspended-start~ or ~suspended-yield~, then
            1. Perform AsyncGeneratorResume(_generator_, _completion_).
          1. Else,
            1. Assert: _state_ is either ~executing~ or ~draining-queue~.
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-return">
        <h1>%AsyncGeneratorPrototype%.return ( _value_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Let _completion_ be ReturnCompletion(_value_).
          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is either ~suspended-start~ or ~completed~, then
            1. Set _generator_.[[AsyncGeneratorState]] to ~draining-queue~.
            1. Perform AsyncGeneratorAwaitReturn(_generator_).
          1. Else if _state_ is ~suspended-yield~, then
            1. Perform AsyncGeneratorResume(_generator_, _completion_).
          1. Else,
            1. Assert: _state_ is either ~executing~ or ~draining-queue~.
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-throw">
        <h1>%AsyncGeneratorPrototype%.throw ( _exception_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is ~suspended-start~, then
            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.
            1. Set _state_ to ~completed~.
          1. If _state_ is ~completed~, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »).
            1. Return _promiseCapability_.[[Promise]].
          1. Let _completion_ be ThrowCompletion(_exception_).
          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
          1. If _state_ is ~suspended-yield~, then
            1. Perform AsyncGeneratorResume(_generator_, _completion_).
          1. Else,
            1. Assert: _state_ is either ~executing~ or ~draining-queue~.
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-asyncgenerator-prototype-tostringtag" id="sec-asyncgenerator-prototype-%symbol.tostringtag%">
        <h1>%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"AsyncGenerator"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>Properties of AsyncGenerator Instances</h1>
      <p>AsyncGenerator instances are initially created with the internal slots described below:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="Internal Slots of AsyncGenerator Instances">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>~suspended-start~, ~suspended-yield~, ~executing~, ~draining-queue~, or ~completed~</td>
            <td>The current execution state of the async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>an execution context</td>
            <td>The execution context that is used when executing the code of this async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>a List of AsyncGeneratorRequest Records</td>
            <td>Records which represent requests to resume the async generator. Except during state transitions, it is non-empty if and only if [[AsyncGeneratorState]] is either ~executing~ or ~draining-queue~.</td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>a String or ~empty~</td>
            <td>A brand used to distinguish different kinds of async generators. The [[GeneratorBrand]] of async generators declared by ECMAScript source text is always ~empty~.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator Abstract Operations</h1>

      <emu-clause id="sec-asyncgeneratorrequest-records">
        <h1>AsyncGeneratorRequest Records</h1>
        <p>An <dfn variants="AsyncGeneratorRequests">AsyncGeneratorRequest</dfn> is a Record value used to store information about how an async generator should be resumed and contains capabilities for fulfilling or rejecting the corresponding promise.</p>
        <p>They have the following fields:</p>
        <emu-table caption="AsyncGeneratorRequest Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Completion]]</td>
              <td>a Completion Record</td>
              <td>The Completion Record which should be used to resume the async generator.</td>
            </tr>
            <tr>
              <td>[[Capability]]</td>
              <td>a PromiseCapability Record</td>
              <td>The promise capabilities associated with this request.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is ~suspended-start~.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~draining-queue~.
            1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).
            1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).
            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).
            1. Return NormalCompletion(*undefined*).
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.
          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorenqueue" type="abstract operation">
        <h1>
          AsyncGeneratorEnqueue (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _promiseCapability_: a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.
          1. Append _request_ to _generator_.[[AsyncGeneratorQueue]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorcompletestep" type="abstract operation">
        <h1>
          AsyncGeneratorCompleteStep (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _done_: a Boolean,
            optional _realm_: a Realm Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorQueue]] is not empty.
          1. Let _next_ be the first element of _generator_.[[AsyncGeneratorQueue]].
          1. Remove the first element from _generator_.[[AsyncGeneratorQueue]].
          1. Let _promiseCapability_ be _next_.[[Capability]].
          1. Let _value_ be _completion_.[[Value]].
          1. If _completion_ is a throw completion, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).
          1. Else,
            1. Assert: _completion_ is a normal completion.
            1. If _realm_ is present, then
              1. Let _oldRealm_ be the running execution context's Realm.
              1. Set the running execution context's Realm to _realm_.
              1. Let _iteratorResult_ be CreateIteratorResultObject(_value_, _done_).
              1. Set the running execution context's Realm to _oldRealm_.
            1. Else,
              1. Let _iteratorResult_ be CreateIteratorResultObject(_value_, _done_).
            1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspended-start~ or ~suspended-yield~.
          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].
          1. Let _callerContext_ be the running execution context.
          1. Suspend _callerContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: _result_ is never an abrupt completion.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorunwrapyieldresumption" type="abstract operation">
        <h1>
          AsyncGeneratorUnwrapYieldResumption (
            _resumptionValue_: a Completion Record,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _resumptionValue_ is not a return completion, return ? _resumptionValue_.
          1. Let _awaited_ be Completion(Await(_resumptionValue_.[[Value]])).
          1. If _awaited_ is a throw completion, return ? _awaited_.
          1. Assert: _awaited_ is a normal completion.
          1. Return ReturnCompletion(_awaited_.[[Value]]).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratoryield" type="abstract operation">
        <h1>
          AsyncGeneratorYield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. Assert: _genContext_ is the execution context of a generator.
          1. Let _generator_ be the value of the Generator component of _genContext_.
          1. Assert: GetGeneratorKind() is ~async~.
          1. Let _completion_ be NormalCompletion(_value_).
          1. Assert: The execution context stack has at least two elements.
          1. Let _previousContext_ be the second to top element of the execution context stack.
          1. Let _previousRealm_ be _previousContext_'s Realm.
          1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_).
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. If _queue_ is not empty, then
            1. NOTE: Execution continues without suspending the generator.
            1. Let _toYield_ be the first element of _queue_.
            1. Let _resumptionValue_ be Completion(_toYield_.[[Completion]]).
            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).
          1. Else,
            1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-yield~.
            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Let _callerContext_ be the running execution context.
            1. Resume _callerContext_ passing *undefined*. If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.
            1. Assert: If control reaches here, then _genContext_ is the running execution context again.
            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorawaitreturn" type="abstract operation">
        <h1>
          AsyncGeneratorAwaitReturn (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Assert: _queue_ is not empty.
          1. Let _next_ be the first element of _queue_.
          1. Let _completion_ be Completion(_next_.[[Completion]]).
          1. Assert: _completion_ is a return completion.
          1. Let _promiseCompletion_ be Completion(PromiseResolve(%Promise%, _completion_.[[Value]])).
          1. If _promiseCompletion_ is an abrupt completion, then
            1. Perform AsyncGeneratorCompleteStep(_generator_, _promiseCompletion_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return ~unused~.
          1. Assert: _promiseCompletion_ is a normal completion.
          1. Let _promise_ be _promiseCompletion_.[[Value]].
          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:
            1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
            1. Let _result_ be NormalCompletion(_value_).
            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return NormalCompletion(*undefined*).
          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « »).
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:
            1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
            1. Let _result_ be ThrowCompletion(_reason_).
            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return NormalCompletion(*undefined*).
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »).
          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratordrainqueue" type="abstract operation">
        <h1>
          AsyncGeneratorDrainQueue (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It drains the generator's AsyncGeneratorQueue until it encounters an AsyncGeneratorRequest which holds a return completion.</dd>
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Repeat, while _queue_ is not empty,
            1. Let _next_ be the first element of _queue_.
            1. Let _completion_ be Completion(_next_.[[Completion]]).
            1. If _completion_ is a return completion, then
              1. Perform AsyncGeneratorAwaitReturn(_generator_).
              1. Return ~unused~.
            1. Else,
              1. If _completion_ is a normal completion, then
                1. Set _completion_ to NormalCompletion(*undefined*).
              1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *true*).
          1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.
          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform AsyncGeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction Objects</h1>
    <p>AsyncFunctions are functions that are usually created by evaluating |AsyncFunctionDeclaration|s, |AsyncFunctionExpression|s, |AsyncMethod|s, and |AsyncArrowFunction|s. They may also be created by calling the %AsyncFunction% intrinsic.</p>

    <emu-clause id="sec-async-function-constructor">
      <h1>The AsyncFunction Constructor</h1>

      <p>The AsyncFunction constructor:</p>
      <ul>
        <li>is <dfn>%AsyncFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new AsyncFunction when called as a function rather than as a constructor. Thus the function call `AsyncFunction(…)` is equivalent to the object creation expression `new AsyncFunction(…)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncFunction behaviour must include a `super` call to the AsyncFunction constructor to create and initialize a subclass instance with the internal slots necessary for built-in async function behaviour. All ECMAScript syntactic forms for defining async function objects create direct instances of AsyncFunction. There is no syntactic means to create instances of AsyncFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-arguments">
        <h1>AsyncFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>

        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_).
        </emu-alg>

        <emu-note>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-constructor-properties">
      <h1>Properties of the AsyncFunction Constructor</h1>

      <p>The AsyncFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the Function constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function%.</li>
        <li oldids="sec-async-function-constructor-length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is *"AsyncFunction"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-prototype">
        <h1>AsyncFunction.prototype</h1>
        <p>The initial value of `AsyncFunction.prototype` is the AsyncFunction prototype object.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-prototype-properties">
      <h1>Properties of the AsyncFunction Prototype Object</h1>
      <p>The <dfn>AsyncFunction prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncFunction.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <emu-clause id="sec-async-function-prototype-properties-constructor">
        <h1>AsyncFunction.prototype.constructor</h1>

        <p>The initial value of `AsyncFunction.prototype.constructor` is %AsyncFunction%.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-async-function-prototype-properties-toStringTag" id="sec-async-function-prototype-%symbol.tostringtag%">
        <h1>AsyncFunction.prototype [ %Symbol.toStringTag% ]</h1>

        <p>The initial value of the %Symbol.toStringTag% property is the String value *"AsyncFunction"*.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-instances">
      <h1>AsyncFunction Instances</h1>

      <p>Every AsyncFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. The value of the [[IsClassConstructor]] internal slot for all such instances is *false*. AsyncFunction instances are not constructors and do not have a [[Construct]] internal method. AsyncFunction instances do not have a prototype property as they are not constructable.</p>
      <p>Each AsyncFunction instance has the following own properties:</p>

      <emu-clause id="sec-async-function-instances-length">
        <h1>length</h1>
        <p>The specification for the *"length"* property of Function instances given in <emu-xref href="#sec-function-instances-length"></emu-xref> also applies to AsyncFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-async-function-instances-name">
        <h1>name</h1>
        <p>The specification for the *"name"* property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to AsyncFunction instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async Functions Abstract Operations</h1>

      <emu-clause id="sec-async-functions-abstract-operations-async-function-start" type="abstract operation">
        <h1>
          AsyncFunctionStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncFunctionBody_: a |FunctionBody| Parse Node, an |ExpressionBody| Parse Node, or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _runningContext_ be the running execution context.
          1. Let _asyncContext_ be a copy of _runningContext_.
          1. NOTE: Copying the execution state is required for AsyncBlockStart to resume its execution. It is ill-defined to resume a currently executing context.
          1. Perform AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncblockstart" type="abstract operation">
        <h1>
          AsyncBlockStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncBody_: a Parse Node or an Abstract Closure with no parameters,
            _asyncContext_: an execution context,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _runningContext_ be the running execution context.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:
            1. Let _acAsyncContext_ be the running execution context.
            1. If _asyncBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _asyncBody_).
            1. Else,
              1. Assert: _asyncBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_asyncBody_()).
            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. If _result_ is a normal completion, then
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).
            1. Else if _result_ is a return completion, then
              1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).
            1. Else,
              1. Assert: _result_ is a throw completion.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).
            1. [id="step-asyncblockstart-return-undefined"] Return NormalCompletion(~unused~).
          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.
          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href="#step-asyncblockstart-return-undefined"></emu-xref> above.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="await" oldids="await-fulfilled,await-rejected" type="abstract operation">
        <h1>
          Await (
            _value_: an ECMAScript language value,
          ): either a normal completion containing either an ECMAScript language value or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _asyncContext_ be the running execution context.
          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).
          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:
            1. Let _prevContext_ be the running execution context.
            1. Suspend _prevContext_.
            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
            1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.
            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
            1. Return NormalCompletion(*undefined*).
          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « »).
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:
            1. Let _prevContext_ be the running execution context.
            1. Suspend _prevContext_.
            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
            1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.
            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
            1. Return NormalCompletion(*undefined*).
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »).
          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).
          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Let _callerContext_ be the running execution context.
          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.
          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.
          1. Return _completion_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection">
  <h1>Reflection</h1>

  <emu-clause id="sec-reflect-object">
    <h1>The Reflect Object</h1>
    <p>The Reflect object:</p>
    <ul>
      <li>is <dfn>%Reflect%</dfn>.</li>
      <li>is the initial value of the *"Reflect"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>

    <emu-clause id="sec-reflect.apply">
      <h1>Reflect.apply ( _target_, _thisArgument_, _argumentsList_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.
        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).
        1. Perform PrepareForTailCall().
        1. Return ? Call(_target_, _thisArgument_, _args_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.construct">
      <h1>Reflect.construct ( _target_, _argumentsList_ [ , _newTarget_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to _target_.
        1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.
        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).
        1. Return ? Construct(_target_, _args_, _newTarget_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.defineproperty">
      <h1>Reflect.defineProperty ( _target_, _propertyKey_, _attributes_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).
        1. Return ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.deleteproperty">
      <h1>Reflect.deleteProperty ( _target_, _propertyKey_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Return ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.get">
      <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. If _receiver_ is not present, then
          1. Set _receiver_ to _target_.
        1. Return ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_key_, _receiver_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getownpropertydescriptor">
      <h1>Reflect.getOwnPropertyDescriptor ( _target_, _propertyKey_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Let _desc_ be ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_).
        1. Return FromPropertyDescriptor(_desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getprototypeof">
      <h1>Reflect.getPrototypeOf ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]()</emu-meta>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.has">
      <h1>Reflect.has ( _target_, _propertyKey_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Return ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.isextensible">
      <h1>Reflect.isExtensible ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[IsExtensible]]()</emu-meta>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.ownkeys">
      <h1>Reflect.ownKeys ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _keys_ be ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>.
        1. Return CreateArrayFromList(_keys_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.preventextensions">
      <h1>Reflect.preventExtensions ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.set">
      <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. If _receiver_ is not present, then
          1. Set _receiver_ to _target_.
        1. Return ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.setprototypeof">
      <h1>Reflect.setPrototypeOf ( _target_, _proto_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_).
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-reflect-@@tostringtag" id="sec-reflect-%symbol.tostringtag%">
      <h1>Reflect [ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Reflect"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-objects">
    <h1>Proxy Objects</h1>

    <emu-clause id="sec-proxy-constructor">
      <h1>The Proxy Constructor</h1>
      <p>The Proxy constructor:</p>
      <ul>
        <li>is <dfn>%Proxy%</dfn>.</li>
        <li>is the initial value of the *"Proxy"* property of the global object.</li>
        <li>creates and initializes a new Proxy object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      </ul>

      <emu-clause id="sec-proxy-target-handler">
        <h1>Proxy ( _target_, _handler_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Return ? ProxyCreate(_target_, _handler_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-proxy-constructor">
      <h1>Properties of the Proxy Constructor</h1>
      <p>The Proxy constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>does not have a *"prototype"* property because Proxy objects do not have a [[Prototype]] internal slot that requires initialization.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-proxy.revocable" oldids="sec-proxy-revocation-functions">
        <h1>Proxy.revocable ( _target_, _handler_ )</h1>
        <p>This function creates a revocable Proxy object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _proxy_ be ? ProxyCreate(_target_, _handler_).
          1. Let _revokerClosure_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _F_ be the active function object.
            1. Let _p_ be _F_.[[RevocableProxy]].
            1. If _p_ is *null*, return NormalCompletion(*undefined*).
            1. Set _F_.[[RevocableProxy]] to *null*.
            1. Assert: _p_ is a Proxy exotic object.
            1. Set _p_.[[ProxyTarget]] to *null*.
            1. Set _p_.[[ProxyHandler]] to *null*.
            1. Return NormalCompletion(*undefined*).
          1. Let _revoker_ be CreateBuiltinFunction(_revokerClosure_, 0, *""*, « [[RevocableProxy]] »).
          1. Set _revoker_.[[RevocableProxy]] to _proxy_.
          1. Let _result_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_result_, *"proxy"*, _proxy_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, *"revoke"*, _revoker_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-module-namespace-objects">
    <h1>Module Namespace Objects</h1>
    <p>A Module Namespace Object is a module namespace exotic object that provides runtime property-based access to a module's exported bindings. There is no constructor function for Module Namespace Objects. Instead, such an object is created for each module that is imported by an |ImportDeclaration| that contains a |NameSpaceImport|.</p>
    <p>In addition to the properties specified in <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> each Module Namespace Object has the following own property:</p>

    <emu-clause oldids="sec-@@tostringtag" id="sec-%symbol.tostringtag%">
      <h1>%Symbol.toStringTag%</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Module"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-memory-model">
  <h1>Memory Model</h1>
  <p>The memory consistency model, or <dfn>memory model</dfn>, specifies the possible orderings of Shared Data Block events, arising via accessing TypedArray instances backed by a SharedArrayBuffer and via methods on the Atomics object. When the program has no data races (defined below), the ordering of events appears as sequentially consistent, i.e., as an interleaving of actions from each agent. When the program has data races, shared memory operations may appear sequentially inconsistent. For example, programs may exhibit causality-violating behaviour and other astonishments. These astonishments arise from compiler transforms and the design of CPUs (e.g., out-of-order execution and speculation). The memory model defines both the precise conditions under which a program exhibits sequentially consistent behaviour as well as the possible values read from data races. To wit, there is no undefined behaviour.</p>
  <p>The memory model is defined as relational constraints on events introduced by abstract operations on SharedArrayBuffer or by methods on the Atomics object during an evaluation.</p>
  <emu-note>
    <p>This section provides an axiomatic model on events introduced by the abstract operations on SharedArrayBuffers. It bears stressing that the model is not expressible algorithmically, unlike the rest of this specification. The nondeterministic introduction of events by abstract operations is the interface between the operational semantics of ECMAScript evaluation and the axiomatic semantics of the memory model. The semantics of these events is defined by considering graphs of all events in an evaluation. These are neither Static Semantics nor Runtime Semantics. There is no demonstrated algorithmic implementation, but instead a set of constraints that determine if a particular event graph is allowed or disallowed.</p>
  </emu-note>

  <emu-clause id="sec-memory-model-fundamentals">
    <h1>Memory Model Fundamentals</h1>
    <p>Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a strict total ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a strict total ordering agreed upon by all agents, i.e., unordered.</p>
    <emu-note>
      <p>No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.</p>
    </emu-note>
    <p>A <dfn variants="Shared Data Block events">Shared Data Block event</dfn> is either a <dfn>ReadSharedMemory</dfn>, <dfn>WriteSharedMemory</dfn>, or <dfn>ReadModifyWriteSharedMemory</dfn> Record.</p>

    <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory Event Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~ or ~unordered~</td>
          <td>The weakest ordering guaranteed by the memory model for the event.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>a Boolean</td>
          <td>Whether this event is allowed to read from multiple write events with equal range as this event.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>a Shared Data Block</td>
          <td>The block the event operates on.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>a non-negative integer</td>
          <td>The byte address of the read in [[Block]].</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>a non-negative integer</td>
          <td>The size of the read.</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory Event Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~, ~unordered~, or ~init~</td>
          <td>The weakest ordering guaranteed by the memory model for the event.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>a Boolean</td>
          <td>Whether this event is allowed to be read from multiple read events with equal range as this event.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>a Shared Data Block</td>
          <td>The block the event operates on.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>a non-negative integer</td>
          <td>The byte address of the write in [[Block]].</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>a non-negative integer</td>
          <td>The size of the write.</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>a List of byte values</td>
          <td>The List of byte values to be read by other events.</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory Event Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~</td>
          <td>Read-modify-write events are always sequentially consistent.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>*true*</td>
          <td>Read-modify-write events cannot tear.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>a Shared Data Block</td>
          <td>The block the event operates on.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>a non-negative integer</td>
          <td>The byte address of the read-modify-write in [[Block]].</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>a non-negative integer</td>
          <td>The size of the read-modify-write.</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>a List of byte values</td>
          <td>The List of byte values to be passed to [[ModifyOp]].</td>
        </tr>
        <tr>
          <td>[[ModifyOp]]</td>
          <td>a read-modify-write modification function</td>
          <td>An abstract closure that returns a modified List of byte values from a read List of byte values and [[Payload]].</td>
        </tr>
      </table>
    </emu-table>

    <p>These events are introduced by abstract operations or by methods on the Atomics object.</p>
    <p>Some operations may also introduce <dfn>Synchronize</dfn> events. A <dfn variants="Synchronize events">Synchronize event</dfn> has no fields, and exists purely to directly constrain the permitted orderings of other events.</p>
    <p>In addition to Shared Data Block and Synchronize events, there are host-specific events.</p>
    <p>Let the range of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event be the Set of contiguous integers from its [[ByteIndex]] to [[ByteIndex]] + [[ElementSize]] - 1. Two events' ranges are equal when the events have the same [[Block]], and the ranges are element-wise equal. Two events' ranges are overlapping when the events have the same [[Block]], the ranges are not equal and their intersection is non-empty. Two events' ranges are disjoint when the events do not have the same [[Block]] or their ranges are neither equal nor overlapping.</p>
    <emu-note>
      <p>Examples of host-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one agent to another (e.g., by `postMessage` in a browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory. For a particular execution _execution_, those events are provided by the host via the host-synchronizes-with strict partial order. Additionally, hosts can add host-specific synchronizing events to _execution_.[[EventList]] so as to participate in the is-agent-order-before Relation.</p>
    </emu-note>
    <p>Events are ordered within candidate executions by the relations defined below.</p>
  </emu-clause>

  <emu-clause id="sec-agent-event-records">
    <h1>Agent Events Records</h1>
    <p>An <dfn variants="Agent Events Records">Agent Events Record</dfn> is a Record with the following fields.</p>
    <emu-table id="table-agent-events-records" caption="Agent Events Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[AgentSignifier]]</td>
          <td>an agent signifier</td>
          <td>The agent whose evaluation resulted in this ordering.</td>
        </tr>
        <tr>
          <td>[[EventList]]</td>
          <td>a List of events</td>
          <td>Events are appended to the list during evaluation.</td>
        </tr>
        <tr>
          <td>[[AgentSynchronizesWith]]</td>
          <td>a List of pairs of Synchronize events</td>
          <td>Synchronize relationships introduced by the operational semantics.</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-chosen-value-records">
    <h1>Chosen Value Records</h1>
    <p>A <dfn variants="Chosen Value Records">Chosen Value Record</dfn> is a Record with the following fields.</p>
    <emu-table id="table-chosen-value-records" caption="Chosen Value Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Event]]</td>
          <td>a Shared Data Block event</td>
          <td>The ReadSharedMemory or ReadModifyWriteSharedMemory event that was introduced for this chosen value.</td>
        </tr>
        <tr>
          <td>[[ChosenValue]]</td>
          <td>a List of byte values</td>
          <td>The bytes that were nondeterministically chosen during evaluation.</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-candidate-executions">
    <h1>Candidate Executions</h1>
    <p>A <dfn variants="candidate executions">candidate execution</dfn> of the evaluation of an agent cluster is a Record with the following fields.</p>
    <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[EventsRecords]]</td>
          <td>a List of Agent Events Records</td>
          <td>Maps an agent to Lists of events appended during the evaluation.</td>
        </tr>
        <tr>
          <td>[[ChosenValues]]</td>
          <td>a List of Chosen Value Records</td>
          <td>Maps ReadSharedMemory or ReadModifyWriteSharedMemory events to the List of byte values chosen during the evaluation.</td>
        </tr>
      </table>
    </emu-table>

    <p>An <dfn variants="empty candidate executions">empty candidate execution</dfn> is a candidate execution Record whose fields are empty Lists.</p>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-the-memory-model" oldids="sec-synchronizeeventset">
    <h1>Abstract Operations for the Memory Model</h1>

    <emu-clause id="sec-event-set" type="abstract operation">
      <h1>
        EventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each Agent Events Record _aer_ of _execution_.[[EventsRecords]], do
          1. For each event _E_ of _aer_.[[EventList]], do
            1. Add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedatablockeventset" type="abstract operation">
      <h1>
        SharedDataBlockEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ of EventSet(_execution_), do
          1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hosteventset" type="abstract operation">
      <h1>
        HostEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ of EventSet(_execution_), do
          1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-composewriteeventbytes" type="abstract operation">
      <h1>
        ComposeWriteEventBytes (
          _execution_: a candidate execution,
          _byteIndex_: a non-negative integer,
          _Ws_: a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _byteLocation_ be _byteIndex_.
        1. Let _bytesRead_ be a new empty List.
        1. For each element _W_ of _Ws_, do
          1. Assert: _W_ has _byteLocation_ in its range.
          1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].
          1. If _W_ is a WriteSharedMemory event, then
            1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].
          1. Else,
            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.
            1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).
            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).
            1. Let _byte_ be _bytesModified_[_payloadIndex_].
          1. Append _byte_ to _bytesRead_.
          1. Set _byteLocation_ to _byteLocation_ + 1.
        1. Return _bytesRead_.
      </emu-alg>
      <emu-note>
        <p>The read-modify-write modification [[ModifyOp]] is given by the function properties on the Atomics object that introduce ReadModifyWriteSharedMemory events.</p>
      </emu-note>
      <emu-note>
        <p>This abstract operation composes a List of write events into a List of byte values. It is used in the event semantics of ReadSharedMemory and ReadModifyWriteSharedMemory events.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valueofreadevent" type="abstract operation">
      <h1>
        ValueOfReadEvent (
          _execution_: a candidate execution,
          _R_: a ReadSharedMemory or ReadModifyWriteSharedMemory event,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _Ws_ be reads-bytes-from(_R_) in _execution_.
        1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].
        1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relations-of-candidate-executions">
    <h1>Relations of Candidate Executions</h1>

    <p>The following relations and mathematical functions are parameterized over a particular candidate execution and order its events.</p>

    <emu-clause id="sec-agent-order">
      <h1>is-agent-order-before</h1>
      <p>For a candidate execution _execution_, its <dfn>is-agent-order-before</dfn> Relation is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>For events _E_ and _D_, _E_ is-agent-order-before _D_ in _execution_ if there is some Agent Events Record _aer_ in _execution_.[[EventsRecords]] such that _aer_.[[EventList]] contains both _E_ and _D_ and _E_ is before _D_ in List order of _aer_.[[EventList]].</li>
      </ul>

      <emu-note>
        <p>Each agent introduces events in a per-agent strict total order during the evaluation. This is the union of those strict total orders.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-reads-bytes-from" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>For a candidate execution _execution_, its <em>reads-bytes-from</em> function is a mathematical function mapping events in SharedDataBlockEventSet(_execution_) to Lists of events in SharedDataBlockEventSet(_execution_) that satisfies the following conditions.</p>
      <ul>
        <li>
          <p>For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in SharedDataBlockEventSet(_execution_), reads-bytes-from(_R_) in _execution_ is a List of length _R_.[[ElementSize]] whose elements are WriteSharedMemory or ReadModifyWriteSharedMemory events _Ws_ such that all of the following are true.</p>
          <ul>
            <li>Each event _W_ with index _i_ in _Ws_ has _R_.[[ByteIndex]] + _i_ in its range.</li>
            <li>_R_ is not in _Ws_.</li>
          </ul>
        </li>
      </ul>
      <p>A candidate execution always admits a reads-bytes-from function.</p>
    </emu-clause>

    <emu-clause id="sec-reads-from">
      <h1>reads-from</h1>
      <p>For a candidate execution _execution_, its <dfn>reads-from</dfn> Relation is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>For events _R_ and _W_, _R_ reads-from _W_ in _execution_ if SharedDataBlockEventSet(_execution_) contains both _R_ and _W_, and reads-bytes-from(_R_) in _execution_ contains _W_.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>For a candidate execution _execution_, its <dfn>host-synchronizes-with</dfn> Relation is a host-provided strict partial order on host-specific events that satisfies at least the following.</p>
      <ul>
        <li>If _E_ host-synchronizes-with _D_ in _execution_, HostEventSet(_execution_) contains _E_ and _D_.</li>
        <li>There is no cycle in the union of host-synchronizes-with and is-agent-order-before in _execution_.</li>
      </ul>

      <emu-note>
        <p>For two host-specific events _E_ and _D_ in a candidate execution _execution_, _E_ host-synchronizes-with _D_ in _execution_ implies _E_ happens-before _D_ in _execution_.</p>
      </emu-note>
      <emu-note>
        <p>This Relation allows the host to provide additional synchronization mechanisms, such as `postMessage` between HTML workers.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>For a candidate execution _execution_, its <dfn>synchronizes-with</dfn> Relation is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>
          For events _R_ and _W_, _W_ synchronizes-with _R_ in _execution_ if _R_ reads-from _W_ in _execution_, _R_.[[Order]] is ~seq-cst~, _W_.[[Order]] is ~seq-cst~, and _R_ and _W_ have equal ranges.
        </li>
        <li>
          For each element _eventsRecord_ of _execution_.[[EventsRecords]], the following is true.
          <ul>
            <li>For events _S_ and _Sw_, _S_ synchronizes-with _Sw_ in _execution_ if _eventsRecord_.[[AgentSynchronizesWith]] contains (_S_, _Sw_).</li>
          </ul>
        </li>
        <li>For events _E_ and _D_, _E_ synchronizes-with _D_ in _execution_ if _execution_.[[HostSynchronizesWith]] contains (_E_, _D_).</li>
      </ul>

      <emu-note>
        <p>Owing to convention in memory model literature, in a candidate execution _execution_, write events synchronizes-with read events, instead of read events synchronizes-with write events.</p>
      </emu-note>

      <emu-note>
        <p>In a candidate execution _execution_, ~init~ events do not participate in this Relation and are instead constrained directly by happens-before.</p>
      </emu-note>

      <emu-note>
        <p>In a candidate execution _execution_, not all ~seq-cst~ events related by reads-from are related by synchronizes-with. Only events that also have equal ranges are related by synchronizes-with.</p>
      </emu-note>

      <emu-note>
        <p>For Shared Data Block events _R_ and _W_ in a candidate execution _execution_ such that _W_ synchronizes-with _R_, _R_ may reads-from other writes than _W_.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-happens-before">
      <h1>happens-before</h1>
      <p>For a candidate execution _execution_, its <dfn>happens-before</dfn> Relation is the least Relation on events that satisfies the following.</p>

      <ul>
        <li>
          <p>For events _E_ and _D_, _E_ happens-before _D_ in _execution_ if any of the following conditions are true.</p>
          <ul>
            <li>_E_ is-agent-order-before _D_ in _execution_.</li>
            <li>_E_ synchronizes-with _D_ in _execution_.</li>
            <li>SharedDataBlockEventSet(_execution_) contains both _E_ and _D_, _E_.[[Order]] is ~init~, and _E_ and _D_ have overlapping ranges.</li>
            <li>There is an event _F_ such that _E_ happens-before _F_ and _F_ happens-before _D_ in _execution_.</li>
          </ul>
        </li>
      </ul>

      <emu-note>
        <p>Because happens-before is a superset of agent-order, a candidate execution is consistent with the single-thread evaluation semantics of ECMAScript.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-valid-executions">
    <h1>Properties of Valid Executions</h1>

    <emu-clause id="sec-valid-chosen-reads">
      <h1>Valid Chosen Reads</h1>
      <p>A candidate execution _execution_ has valid chosen reads if the following algorithm returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do
          1. Let _chosenValueRecord_ be the element of _execution_.[[ChosenValues]] whose [[Event]] field is _R_.
          1. Let _chosenValue_ be _chosenValueRecord_.[[ChosenValue]].
          1. Let _readValue_ be ValueOfReadEvent(_execution_, _R_).
          1. Let _chosenLen_ be the number of elements in _chosenValue_.
          1. Let _readLen_ be the number of elements in _readValue_.
          1. If _chosenLen_ ≠ _readLen_, then
            1. Return *false*.
          1. If _chosenValue_[_i_] ≠ _readValue_[_i_] for some integer _i_ in the interval from 0 (inclusive) to _chosenLen_ (exclusive), then
            1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-coherent-reads">
      <h1>Coherent Reads</h1>
      <p>A candidate execution _execution_ has coherent reads if the following algorithm returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do
          1. Let _Ws_ be reads-bytes-from(_R_) in _execution_.
          1. Let _byteLocation_ be _R_.[[ByteIndex]].
          1. For each element _W_ of _Ws_, do
            1. If _R_ happens-before _W_ in _execution_, then
              1. Return *false*.
            1. If there exists a WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ that has _byteLocation_ in its range such that _W_ happens-before _V_ in _execution_ and _V_ happens-before _R_ in _execution_, then
              1. Return *false*.
            1. Set _byteLocation_ to _byteLocation_ + 1.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tear-free-aligned-reads">
      <h1>Tear Free Reads</h1>
      <p>A candidate execution _execution_ has tear free reads if the following algorithm returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do
          1. If _R_.[[NoTear]] is *true*, then
            1. Assert: The remainder of dividing _R_.[[ByteIndex]] by _R_.[[ElementSize]] is 0.
            1. For each event _W_ such that _R_ reads-from _W_ in _execution_ and _W_.[[NoTear]] is *true*, do
              1. If _R_ and _W_ have equal ranges and there exists an event _V_ such that _V_ and _W_ have equal ranges, _V_.[[NoTear]] is *true*, _W_ and _V_ are not the same Shared Data Block event, and _R_ reads-from _V_ in _execution_, then
                1. Return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-note>
        <p>An event's [[NoTear]] field is *true* when that event was introduced via accessing an integer TypedArray, and *false* when introduced via accessing a floating point TypedArray or DataView.</p>
        <p>Intuitively, this requirement says when a memory range is accessed in an aligned fashion via an integer TypedArray, a single write event on that range must "win" when in a data race with other write events with equal ranges. More precisely, this requirement says an aligned read event cannot read a value composed of bytes from multiple, different write events all with equal ranges. It is possible, however, for an aligned read event to read from multiple write events with overlapping ranges.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-memory-order">
      <h1>Sequentially Consistent Atomics</h1>
      <p>For a candidate execution _execution_, <dfn>is-memory-order-before</dfn> is a strict total order of all events in EventSet(_execution_) that satisfies the following.</p>
      <ul>
        <li>For events _E_ and _D_, _E_ is-memory-order-before _D_ in _execution_ if _E_ happens-before _D_ in _execution_.</li>
        <li>
          <p>For events _R_ and _W_ such that _R_ reads-from _W_ in _execution_, there is no WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ in SharedDataBlockEventSet(_execution_) such that _V_.[[Order]] is ~seq-cst~, _W_ is-memory-order-before _V_ in _execution_, _V_ is-memory-order-before _R_ in _execution_, and any of the following conditions are true.</p>
          <ul>
            <li>_W_ synchronizes-with _R_ in _execution_, and _V_ and _R_ have equal ranges.</li>
            <li>_W_ happens-before _R_ and _V_ happens-before _R_ in _execution_, _W_.[[Order]] is ~seq-cst~, and _W_ and _V_ have equal ranges.</li>
            <li>_W_ happens-before _R_ and _W_ happens-before _V_ in _execution_, _R_.[[Order]] is ~seq-cst~, and _V_ and _R_ have equal ranges.</li>
          </ul>
          <emu-note>
            <p>This clause additionally constrains ~seq-cst~ events on equal ranges.</p>
          </emu-note>
        </li>
        <li>
          <p>For each WriteSharedMemory or ReadModifyWriteSharedMemory event _W_ in SharedDataBlockEventSet(_execution_), if _W_.[[Order]] is ~seq-cst~, then it is not the case that there is an infinite number of ReadSharedMemory or ReadModifyWriteSharedMemory events in SharedDataBlockEventSet(_execution_) with equal range that is memory-order before _W_.</p>
          <emu-note>
            <p>This clause together with the forward progress guarantee on agents ensure the liveness condition that ~seq-cst~ writes become visible to ~seq-cst~ reads with equal range in finite time.</p>
          </emu-note>
        </li>
      </ul>
      <p>A candidate execution has sequentially consistent atomics if it admits an is-memory-order-before Relation.</p>

      <emu-note>
        <p>While is-memory-order-before includes all events in EventSet(_execution_), those that are not constrained by happens-before or synchronizes-with in _execution_ are allowed to occur anywhere in the order.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valid-executions">
      <h1>Valid Executions</h1>
      <p>A candidate execution _execution_ is a valid execution (or simply an execution) if all of the following are true.</p>
      <ul>
        <li>The host provides a host-synchronizes-with Relation for _execution_.</li>
        <li>_execution_ admits a happens-before Relation that is a strict partial order.</li>
        <li>_execution_ has valid chosen reads.</li>
        <li>_execution_ has coherent reads.</li>
        <li>_execution_ has tear free reads.</li>
        <li>_execution_ has sequentially consistent atomics.</li>
      </ul>
      <p>All programs have at least one valid execution.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-races">
    <h1>Races</h1>
    <p>For an execution _execution_ and events _E_ and _D_ that are contained in SharedDataBlockEventSet(_execution_), _E_ and _D_ are in a <em>race</em> if the following algorithm returns *true*.</p>
    <emu-alg>
      1. If _E_ and _D_ are not the same Shared Data Block event, then
        1. If it is not the case that both _E_ happens-before _D_ in _execution_ and _D_ happens-before _E_ in _execution_, then
          1. If _E_ and _D_ are both WriteSharedMemory or ReadModifyWriteSharedMemory events and _E_ and _D_ do not have disjoint ranges, then
            1. Return *true*.
          1. If _E_ reads-from _D_ in _execution_ or _D_ reads-from _E_ in _execution_, then
            1. Return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-races">
    <h1>Data Races</h1>
    <p>For an execution _execution_ and events _E_ and _D_ that are contained in SharedDataBlockEventSet(_execution_), _E_ and _D_ are in a <dfn>data race</dfn> if the following algorithm returns *true*.</p>
    <emu-alg>
      1. If _E_ and _D_ are in a <emu-xref href="#sec-races">race</emu-xref> in _execution_, then
        1. If _E_.[[Order]] is not ~seq-cst~ or _D_.[[Order]] is not ~seq-cst~, then
          1. Return *true*.
        1. If _E_ and _D_ have overlapping ranges, then
          1. Return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-race-freedom">
    <h1>Data Race Freedom</h1>
    <p>An execution _execution_ is <dfn>data race free</dfn> if there are no two events in SharedDataBlockEventSet(_execution_) that are in a data race.</p>
    <p>A program is data race free if all its executions are data race free.</p>
    <p>The memory model guarantees sequential consistency of all events for data race free programs.</p>
  </emu-clause>

  <emu-clause id="sec-shared-memory-guidelines">
    <h1>Shared Memory Guidelines</h1>
    <emu-note>
      <p>The following are guidelines for ECMAScript programmers working with shared memory.</p>
      <p>We recommend programs be kept data race free, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data race free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript.</p>
      <p>More generally, even if a program is not data race free it may have predictable behaviour, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not "tear" (bits of their values will not be mixed).</p>
    </emu-note>

    <emu-note>
      <p>The following are guidelines for ECMAScript implementers writing compiler transformations for programs using shared memory.</p>
      <p>It is desirable to allow most program transformations that are valid in a single-agent setting in a multi-agent setting, to ensure that the performance of each agent in a multi-agent program is as good as it would be in a single-agent setting. Frequently these transformations are hard to judge. We outline some rules about program transformations that are intended to be taken as normative (in that they are implied by the memory model or stronger than what the memory model implies) but which are likely not exhaustive. These rules are intended to apply to program transformations that precede the introductions of the events that make up the is-agent-order-before Relation.</p>
      <p>Let an <dfn variants="agent-order slices">agent-order slice</dfn> be the subset of the is-agent-order-before Relation pertaining to a single agent.</p>
      <p>Let <dfn>possible read values</dfn> of a read event be the set of all values of ValueOfReadEvent for that event across all valid executions.</p>
      <p>Any transformation of an agent-order slice that is valid in the absence of shared memory is valid in the presence of shared memory, with the following exceptions.</p>
      <ul>
        <li>
          <p><em>Atomics are carved in stone</em>: Program transformations must not cause the ~seq-cst~ events in an agent-order slice to be reordered with its ~unordered~ operations, nor its ~seq-cst~ operations to be reordered with each other, nor may a program transformation remove a ~seq-cst~ operation from the is-agent-order-before Relation.</p>
          <p>(In practice, the prohibition on reorderings forces a compiler to assume that every ~seq-cst~ operation is a synchronization and included in the final is-memory-order-before Relation, which it would usually have to assume anyway in the absence of inter-agent program analysis. It also forces the compiler to assume that every call where the callee's effects on the memory-order are unknown may contain ~seq-cst~ operations.)</p>
        </li>
        <li>
          <p><em>Reads must be stable</em>: Any given shared memory read must only observe a single value in an execution.</p>
          <p>(For example, if what is semantically a single read in the program is executed multiple times then the program is subsequently allowed to observe only one of the values read. A transformation known as rematerialization can violate this rule.)</p>
        </li>
        <li>
          <p><em>Writes must be stable</em>: All observable writes to shared memory must follow from program semantics in an execution.</p>
          <p>(For example, a transformation may not introduce certain observable writes, such as by using read-modify-write operations on a larger location to write a smaller datum, writing a value to memory that the program could not have written, or writing a just-read value back to the location it was read from, if that location could have been overwritten by another agent after the read.)</p>
        </li>
        <li>
          <p><em>Possible read values must be non-empty</em>: Program transformations cannot cause the possible read values of a shared memory read to become empty.</p>
          <p>(Counterintuitively, this rule in effect restricts transformations on writes, because writes have force in memory model insofar as to be read by read events. For example, writes may be moved and coalesced and sometimes reordered between two ~seq-cst~ operations, but the transformation may not remove every write that updates a location; some write must be preserved.)</p>
        </li>
      </ul>
      <p>Examples of transformations that remain valid are: merging multiple non-atomic reads from the same location, reordering non-atomic reads, introducing speculative non-atomic reads, merging multiple non-atomic writes to the same location, reordering non-atomic writes to different locations, and hoisting non-atomic reads out of loops even if that affects termination. Note in general that aliased TypedArrays make it hard to prove that locations are different.</p>
    </emu-note>

    <emu-note>
      <p>The following are guidelines for ECMAScript implementers generating machine code for shared memory accesses.</p>
      <p>For architectures with memory models no weaker than those of ARM or Power, non-atomic stores and loads may be compiled to bare stores and loads on the target architecture. Atomic stores and loads may be compiled down to instructions that guarantee sequential consistency. If no such instructions exist, memory barriers are to be employed, such as placing barriers on both sides of a bare store or load. Read-modify-write operations may be compiled to read-modify-write instructions on the target architecture, such as <code>LOCK</code>-prefixed instructions on x86, load-exclusive/store-exclusive instructions on ARM, and load-link/store-conditional instructions on Power.</p>
      <p>Specifically, the memory model is intended to allow code generation as follows.</p>
      <ul>
        <li>Every atomic operation in the program is assumed to be necessary.</li>
        <li>Atomic operations are never rearranged with each other or with non-atomic operations.</li>
        <li>Functions are always assumed to perform atomic operations.</li>
        <li>Atomic operations are never implemented as read-modify-write operations on larger data, but as non-lock-free atomics if the platform does not have atomic operations of the appropriate size. (We already assume that every platform has normal memory access operations of every interesting size.)</li>
      </ul>
      <p>Naive code generation uses these patterns:</p>
      <ul>
        <li>Regular loads and stores compile to single load and store instructions.</li>
        <li>Lock-free atomic loads and stores compile to a full (sequentially consistent) fence, a regular load or store, and a full fence.</li>
        <li>Lock-free atomic read-modify-write accesses compile to a full fence, an atomic read-modify-write instruction sequence, and a full fence.</li>
        <li>Non-lock-free atomics compile to a spinlock acquire, a full fence, a series of non-atomic load and store instructions, a full fence, and a spinlock release.</li>
      </ul>
      <p>That mapping is correct so long as an atomic operation on an address range does not race with a non-atomic write or with an atomic operation of different size. However, that is all we need: the memory model effectively demotes the atomic operations involved in a race to non-atomic status. On the other hand, the naive mapping is quite strong: it allows atomic operations to be used as sequentially consistent fences, which the memory model does not actually guarantee.</p>
      <p>Local improvements to those basic patterns are also allowed, subject to the constraints of the memory model. For example:</p>
      <ul>
        <li>There are obvious platform-dependent improvements that remove redundant fences. For example, on x86 the fences around lock-free atomic loads and stores can always be omitted except for the fence following a store, and no fence is needed for lock-free read-modify-write instructions, as these all use <code>LOCK</code>-prefixed instructions. On many platforms there are fences of several strengths, and weaker fences can be used in certain contexts without destroying sequential consistency.</li>
        <li>Most modern platforms support lock-free atomics for all the data sizes required by ECMAScript atomics. Should non-lock-free atomics be needed, the fences surrounding the body of the atomic operation can usually be folded into the lock and unlock steps. The simplest solution for non-lock-free atomics is to have a single lock word per SharedArrayBuffer.</li>
        <li>There are also more complicated platform-dependent local improvements, requiring some code analysis. For example, two back-to-back fences often have the same effect as a single fence, so if code is generated for two atomic operations in sequence, only a single fence need separate them. On x86, even a single fence separating atomic stores can be omitted, as the fence following a store is only needed to separate the store from a subsequent load.</li>
      </ul>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-grammar-summary">
  <h1>Grammar Summary</h1>

  <emu-annex id="sec-lexical-grammar">
    <h1>Lexical Grammar</h1>
    <emu-prodref name="SourceCharacter"></emu-prodref>
    <emu-prodref name="InputElementDiv"></emu-prodref>
    <emu-prodref name="InputElementRegExp"></emu-prodref>
    <emu-prodref name="InputElementRegExpOrTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementHashbangOrRegExp"></emu-prodref>
    <emu-prodref name="WhiteSpace"></emu-prodref>
    <emu-prodref name="LineTerminator"></emu-prodref>
    <emu-prodref name="LineTerminatorSequence"></emu-prodref>
    <emu-prodref name="Comment"></emu-prodref>
    <emu-prodref name="MultiLineComment"></emu-prodref>
    <emu-prodref name="MultiLineCommentChars"></emu-prodref>
    <emu-prodref name="PostAsteriskCommentChars"></emu-prodref>
    <emu-prodref name="MultiLineNotAsteriskChar"></emu-prodref>
    <emu-prodref name="MultiLineNotForwardSlashOrAsteriskChar"></emu-prodref>
    <emu-prodref name="SingleLineComment"></emu-prodref>
    <emu-prodref name="SingleLineCommentChars"></emu-prodref>
    <emu-prodref name="SingleLineCommentChar"></emu-prodref>
    <emu-prodref name="HashbangComment"></emu-prodref>
    <emu-prodref name="CommonToken"></emu-prodref>
    <emu-prodref name="PrivateIdentifier"></emu-prodref>
    <emu-prodref name="IdentifierName"></emu-prodref>
    <emu-prodref name="IdentifierStart"></emu-prodref>
    <emu-prodref name="IdentifierPart"></emu-prodref>
    <emu-prodref name="IdentifierStartChar"></emu-prodref>
    <emu-prodref name="IdentifierPartChar"></emu-prodref>
    <emu-prodref name="AsciiLetter"></emu-prodref>
    <emu-prodref name="UnicodeIDStart"></emu-prodref>
    <emu-prodref name="UnicodeIDContinue"></emu-prodref>
    <emu-prodref name="ReservedWord"></emu-prodref>
    <emu-prodref name="Punctuator"></emu-prodref>
    <emu-prodref name="OptionalChainingPunctuator"></emu-prodref>
    <emu-prodref name="OtherPunctuator"></emu-prodref>
    <emu-prodref name="DivPunctuator"></emu-prodref>
    <emu-prodref name="RightBracePunctuator"></emu-prodref>
    <emu-prodref name="NullLiteral"></emu-prodref>
    <emu-prodref name="BooleanLiteral"></emu-prodref>
    <emu-prodref name="NumericLiteralSeparator"></emu-prodref>
    <emu-prodref name="NumericLiteral"></emu-prodref>
    <emu-prodref name="DecimalBigIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="BigIntLiteralSuffix"></emu-prodref>
    <emu-prodref name="DecimalLiteral"></emu-prodref>
    <emu-prodref name="DecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="DecimalDigits"></emu-prodref>
    <emu-prodref name="DecimalDigit"></emu-prodref>
    <emu-prodref name="NonZeroDigit"></emu-prodref>
    <emu-prodref name="ExponentPart"></emu-prodref>
    <emu-prodref name="ExponentIndicator"></emu-prodref>
    <emu-prodref name="SignedInteger"></emu-prodref>
    <emu-prodref name="BinaryIntegerLiteral"></emu-prodref>
    <emu-prodref name="BinaryDigits"></emu-prodref>
    <emu-prodref name="BinaryDigit"></emu-prodref>
    <emu-prodref name="OctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigits"></emu-prodref>
    <emu-prodref name="LegacyOctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonOctalDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="LegacyOctalLikeDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigit"></emu-prodref>
    <emu-prodref name="NonOctalDigit"></emu-prodref>
    <emu-prodref name="HexIntegerLiteral"></emu-prodref>
    <emu-prodref name="HexDigits"></emu-prodref>
    <emu-prodref name="HexDigit"></emu-prodref>
    <emu-prodref name="StringLiteral"></emu-prodref>
    <emu-prodref name="DoubleStringCharacters"></emu-prodref>
    <emu-prodref name="SingleStringCharacters"></emu-prodref>
    <emu-prodref name="DoubleStringCharacter"></emu-prodref>
    <emu-prodref name="SingleStringCharacter"></emu-prodref>
    <emu-prodref name="LineContinuation"></emu-prodref>
    <emu-prodref name="EscapeSequence"></emu-prodref>
    <emu-prodref name="CharacterEscapeSequence"></emu-prodref>
    <emu-prodref name="SingleEscapeCharacter"></emu-prodref>
    <emu-prodref name="NonEscapeCharacter"></emu-prodref>
    <emu-prodref name="EscapeCharacter"></emu-prodref>
    <emu-prodref name="LegacyOctalEscapeSequence"></emu-prodref>
    <emu-prodref name="NonZeroOctalDigit"></emu-prodref>
    <emu-prodref name="ZeroToThree"></emu-prodref>
    <emu-prodref name="FourToSeven"></emu-prodref>
    <emu-prodref name="NonOctalDecimalEscapeSequence"></emu-prodref>
    <emu-prodref name="HexEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="Hex4Digits"></emu-prodref>
    <emu-prodref name="RegularExpressionLiteral"></emu-prodref>
    <emu-prodref name="RegularExpressionBody"></emu-prodref>
    <emu-prodref name="RegularExpressionChars"></emu-prodref>
    <emu-prodref name="RegularExpressionFirstChar"></emu-prodref>
    <emu-prodref name="RegularExpressionChar"></emu-prodref>
    <emu-prodref name="RegularExpressionBackslashSequence"></emu-prodref>
    <emu-prodref name="RegularExpressionNonTerminator"></emu-prodref>
    <emu-prodref name="RegularExpressionClass"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChars"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChar"></emu-prodref>
    <emu-prodref name="RegularExpressionFlags"></emu-prodref>
    <emu-prodref name="Template"></emu-prodref>
    <emu-prodref name="NoSubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateHead"></emu-prodref>
    <emu-prodref name="TemplateSubstitutionTail"></emu-prodref>
    <emu-prodref name="TemplateMiddle"></emu-prodref>
    <emu-prodref name="TemplateTail"></emu-prodref>
    <emu-prodref name="TemplateCharacters"></emu-prodref>
    <emu-prodref name="TemplateCharacter"></emu-prodref>
    <emu-prodref name="TemplateEscapeSequence"></emu-prodref>
    <emu-prodref name="NotEscapeSequence"></emu-prodref>
    <emu-prodref name="NotCodePoint"></emu-prodref>
    <emu-prodref name="CodePoint"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-expressions">
    <h1>Expressions</h1>
    <emu-prodref name="IdentifierReference"></emu-prodref>
    <emu-prodref name="BindingIdentifier"></emu-prodref>
    <emu-prodref name="LabelIdentifier"></emu-prodref>
    <emu-prodref name="Identifier"></emu-prodref>
    <emu-prodref name="PrimaryExpression"></emu-prodref>
    <emu-prodref name="CoverParenthesizedExpressionAndArrowParameterList"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="PrimaryExpression" a="parencover"></emu-prodref><br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:
    </p>
    <emu-prodref name="ParenthesizedExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Literal"></emu-prodref>
    <emu-prodref name="ArrayLiteral"></emu-prodref>
    <emu-prodref name="ElementList"></emu-prodref>
    <emu-prodref name="Elision"></emu-prodref>
    <emu-prodref name="SpreadElement"></emu-prodref>
    <emu-prodref name="ObjectLiteral"></emu-prodref>
    <emu-prodref name="PropertyDefinitionList"></emu-prodref>
    <emu-prodref name="PropertyDefinition"></emu-prodref>
    <emu-prodref name="PropertyName"></emu-prodref>
    <emu-prodref name="LiteralPropertyName"></emu-prodref>
    <emu-prodref name="ComputedPropertyName"></emu-prodref>
    <emu-prodref name="CoverInitializedName"></emu-prodref>
    <emu-prodref name="Initializer"></emu-prodref>
    <emu-prodref name="TemplateLiteral"></emu-prodref>
    <emu-prodref name="SubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateSpans"></emu-prodref>
    <emu-prodref name="TemplateMiddleList"></emu-prodref>
    <emu-prodref name="MemberExpression"></emu-prodref>
    <emu-prodref name="SuperProperty"></emu-prodref>
    <emu-prodref name="MetaProperty"></emu-prodref>
    <emu-prodref name="NewTarget"></emu-prodref>
    <emu-prodref name="ImportMeta"></emu-prodref>
    <emu-prodref name="NewExpression"></emu-prodref>
    <emu-prodref name="CallExpression"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="CallExpression" a="callcover"></emu-prodref><br>
      the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:
    </p>
    <emu-prodref name="CallMemberExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="SuperCall"></emu-prodref>
    <emu-prodref name="ImportCall"></emu-prodref>
    <emu-prodref name="Arguments"></emu-prodref>
    <emu-prodref name="ArgumentList"></emu-prodref>
    <emu-prodref name="OptionalExpression"></emu-prodref>
    <emu-prodref name="OptionalChain"></emu-prodref>
    <emu-prodref name="LeftHandSideExpression"></emu-prodref>
    <emu-prodref name="UpdateExpression"></emu-prodref>
    <emu-prodref name="UnaryExpression"></emu-prodref>
    <emu-prodref name="ExponentiationExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeOperator"></emu-prodref>
    <emu-prodref name="AdditiveExpression"></emu-prodref>
    <emu-prodref name="ShiftExpression"></emu-prodref>
    <emu-prodref name="RelationalExpression"></emu-prodref>
    <emu-prodref name="EqualityExpression"></emu-prodref>
    <emu-prodref name="BitwiseANDExpression"></emu-prodref>
    <emu-prodref name="BitwiseXORExpression"></emu-prodref>
    <emu-prodref name="BitwiseORExpression"></emu-prodref>
    <emu-prodref name="LogicalANDExpression"></emu-prodref>
    <emu-prodref name="LogicalORExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpressionHead"></emu-prodref>
    <emu-prodref name="ShortCircuitExpression"></emu-prodref>
    <emu-prodref name="ConditionalExpression"></emu-prodref>
    <emu-prodref name="AssignmentExpression"></emu-prodref>
    <emu-prodref name="AssignmentOperator"></emu-prodref>
    <p>
      In certain circumstances when processing an instance of the production<br>
      <emu-prodref name="AssignmentExpression" a="assignment"></emu-prodref><br>
      the interpretation of |LeftHandSideExpression| is refined using the following grammar:
    </p>
    <emu-prodref name="AssignmentPattern"></emu-prodref>
    <emu-prodref name="ObjectAssignmentPattern"></emu-prodref>
    <emu-prodref name="ArrayAssignmentPattern"></emu-prodref>
    <emu-prodref name="AssignmentRestProperty"></emu-prodref>
    <emu-prodref name="AssignmentPropertyList"></emu-prodref>
    <emu-prodref name="AssignmentElementList"></emu-prodref>
    <emu-prodref name="AssignmentElisionElement"></emu-prodref>
    <emu-prodref name="AssignmentProperty"></emu-prodref>
    <emu-prodref name="AssignmentElement"></emu-prodref>
    <emu-prodref name="AssignmentRestElement"></emu-prodref>
    <emu-prodref name="DestructuringAssignmentTarget"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Expression"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-statements">
    <h1>Statements</h1>
    <emu-prodref name="Statement"></emu-prodref>
    <emu-prodref name="Declaration"></emu-prodref>
    <emu-prodref name="HoistableDeclaration"></emu-prodref>
    <emu-prodref name="BreakableStatement"></emu-prodref>
    <emu-prodref name="BlockStatement"></emu-prodref>
    <emu-prodref name="Block"></emu-prodref>
    <emu-prodref name="StatementList"></emu-prodref>
    <emu-prodref name="StatementListItem"></emu-prodref>
    <emu-prodref name="LexicalDeclaration"></emu-prodref>
    <emu-prodref name="LetOrConst"></emu-prodref>
    <emu-prodref name="BindingList"></emu-prodref>
    <emu-prodref name="LexicalBinding"></emu-prodref>
    <emu-prodref name="VariableStatement"></emu-prodref>
    <emu-prodref name="VariableDeclarationList"></emu-prodref>
    <emu-prodref name="VariableDeclaration"></emu-prodref>
    <emu-prodref name="BindingPattern"></emu-prodref>
    <emu-prodref name="ObjectBindingPattern"></emu-prodref>
    <emu-prodref name="ArrayBindingPattern"></emu-prodref>
    <emu-prodref name="BindingRestProperty"></emu-prodref>
    <emu-prodref name="BindingPropertyList"></emu-prodref>
    <emu-prodref name="BindingElementList"></emu-prodref>
    <emu-prodref name="BindingElisionElement"></emu-prodref>
    <emu-prodref name="BindingProperty"></emu-prodref>
    <emu-prodref name="BindingElement"></emu-prodref>
    <emu-prodref name="SingleNameBinding"></emu-prodref>
    <emu-prodref name="BindingRestElement"></emu-prodref>
    <emu-prodref name="EmptyStatement"></emu-prodref>
    <emu-prodref name="ExpressionStatement"></emu-prodref>
    <emu-prodref name="IfStatement"></emu-prodref>
    <emu-prodref name="IterationStatement"></emu-prodref>
    <emu-prodref name="DoWhileStatement"></emu-prodref>
    <emu-prodref name="WhileStatement"></emu-prodref>
    <emu-prodref name="ForStatement"></emu-prodref>
    <emu-prodref name="ForInOfStatement"></emu-prodref>
    <emu-prodref name="ForDeclaration"></emu-prodref>
    <emu-prodref name="ForBinding"></emu-prodref>
    <emu-prodref name="ContinueStatement"></emu-prodref>
    <emu-prodref name="BreakStatement"></emu-prodref>
    <emu-prodref name="ReturnStatement"></emu-prodref>
    <emu-prodref name="WithStatement"></emu-prodref>
    <emu-prodref name="SwitchStatement"></emu-prodref>
    <emu-prodref name="CaseBlock"></emu-prodref>
    <emu-prodref name="CaseClauses"></emu-prodref>
    <emu-prodref name="CaseClause"></emu-prodref>
    <emu-prodref name="DefaultClause"></emu-prodref>
    <emu-prodref name="LabelledStatement"></emu-prodref>
    <emu-prodref name="LabelledItem"></emu-prodref>
    <emu-prodref name="ThrowStatement"></emu-prodref>
    <emu-prodref name="TryStatement"></emu-prodref>
    <emu-prodref name="Catch"></emu-prodref>
    <emu-prodref name="Finally"></emu-prodref>
    <emu-prodref name="CatchParameter"></emu-prodref>
    <emu-prodref name="DebuggerStatement"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-functions-and-classes">
    <h1>Functions and Classes</h1>
    <emu-prodref name="UniqueFormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameterList"></emu-prodref>
    <emu-prodref name="FunctionRestParameter"></emu-prodref>
    <emu-prodref name="FormalParameter"></emu-prodref>
    <emu-prodref name="FunctionDeclaration"></emu-prodref>
    <emu-prodref name="FunctionExpression"></emu-prodref>
    <emu-prodref name="FunctionBody"></emu-prodref>
    <emu-prodref name="FunctionStatementList"></emu-prodref>
    <emu-prodref name="ArrowFunction"></emu-prodref>
    <emu-prodref name="ArrowParameters"></emu-prodref>
    <emu-prodref name="ConciseBody"></emu-prodref>
    <emu-prodref name="ExpressionBody"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="ArrowParameters" a="parencover"></emu-prodref><br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:
    </p>
    <emu-prodref name="ArrowFormalParameters"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="AsyncArrowFunction"></emu-prodref>
    <emu-prodref name="AsyncConciseBody"></emu-prodref>
    <emu-prodref name="AsyncArrowBindingIdentifier"></emu-prodref>
    <emu-prodref name="CoverCallExpressionAndAsyncArrowHead"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="AsyncArrowFunction" a="callcover"></emu-prodref><br>
      the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:
    </p>
    <emu-prodref name="AsyncArrowHead"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="MethodDefinition"></emu-prodref>
    <emu-prodref name="PropertySetParameterList"></emu-prodref>
    <emu-prodref name="GeneratorDeclaration"></emu-prodref>
    <emu-prodref name="GeneratorExpression"></emu-prodref>
    <emu-prodref name="GeneratorMethod"></emu-prodref>
    <emu-prodref name="GeneratorBody"></emu-prodref>
    <emu-prodref name="YieldExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorDeclaration"></emu-prodref>
    <emu-prodref name="AsyncGeneratorExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorMethod"></emu-prodref>
    <emu-prodref name="AsyncGeneratorBody"></emu-prodref>
    <emu-prodref name="AsyncFunctionDeclaration"></emu-prodref>
    <emu-prodref name="AsyncFunctionExpression"></emu-prodref>
    <emu-prodref name="AsyncMethod"></emu-prodref>
    <emu-prodref name="AsyncFunctionBody"></emu-prodref>
    <emu-prodref name="AwaitExpression"></emu-prodref>
    <emu-prodref name="ClassDeclaration"></emu-prodref>
    <emu-prodref name="ClassExpression"></emu-prodref>
    <emu-prodref name="ClassTail"></emu-prodref>
    <emu-prodref name="ClassHeritage"></emu-prodref>
    <emu-prodref name="ClassBody"></emu-prodref>
    <emu-prodref name="ClassElementList"></emu-prodref>
    <emu-prodref name="ClassElement"></emu-prodref>
    <emu-prodref name="FieldDefinition"></emu-prodref>
    <emu-prodref name="ClassElementName"></emu-prodref>
    <emu-prodref name="ClassStaticBlock"></emu-prodref>
    <emu-prodref name="ClassStaticBlockBody"></emu-prodref>
    <emu-prodref name="ClassStaticBlockStatementList"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-scripts-and-modules">
    <h1>Scripts and Modules</h1>
    <emu-prodref name="Script"></emu-prodref>
    <emu-prodref name="ScriptBody"></emu-prodref>
    <emu-prodref name="Module"></emu-prodref>
    <emu-prodref name="ModuleBody"></emu-prodref>
    <emu-prodref name="ModuleItemList"></emu-prodref>
    <emu-prodref name="ModuleItem"></emu-prodref>
    <emu-prodref name="ModuleExportName"></emu-prodref>
    <emu-prodref name="ImportDeclaration"></emu-prodref>
    <emu-prodref name="ImportClause"></emu-prodref>
    <emu-prodref name="ImportedDefaultBinding"></emu-prodref>
    <emu-prodref name="NameSpaceImport"></emu-prodref>
    <emu-prodref name="NamedImports"></emu-prodref>
    <emu-prodref name="FromClause"></emu-prodref>
    <emu-prodref name="ImportsList"></emu-prodref>
    <emu-prodref name="ImportSpecifier"></emu-prodref>
    <emu-prodref name="ModuleSpecifier"></emu-prodref>
    <emu-prodref name="ImportedBinding"></emu-prodref>
    <emu-prodref name="WithClause"></emu-prodref>
    <emu-prodref name="WithEntries"></emu-prodref>
    <emu-prodref name="AttributeKey"></emu-prodref>
    <emu-prodref name="ExportDeclaration"></emu-prodref>
    <emu-prodref name="ExportFromClause"></emu-prodref>
    <emu-prodref name="NamedExports"></emu-prodref>
    <emu-prodref name="ExportsList"></emu-prodref>
    <emu-prodref name="ExportSpecifier"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-number-conversions">
    <h1>Number Conversions</h1>
    <emu-prodref name="StringNumericLiteral"></emu-prodref>
    <emu-prodref name="StrWhiteSpace"></emu-prodref>
    <emu-prodref name="StrWhiteSpaceChar"></emu-prodref>
    <emu-prodref name="StrNumericLiteral"></emu-prodref>
    <emu-prodref name="StrDecimalLiteral"></emu-prodref>
    <emu-prodref name="StrUnsignedDecimalLiteral"></emu-prodref>
    <p>All grammar symbols not explicitly defined by the |StringNumericLiteral| grammar have the definitions used in the <emu-xref href="#sec-literals-numeric-literals">Lexical Grammar for numeric literals</emu-xref>.</p>
    <emu-prodref name="StringIntegerLiteral"></emu-prodref>
    <emu-prodref name="StrIntegerLiteral"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-time-zone-offset-string-format">
    <h1>Time Zone Offset String Format</h1>
    <emu-prodref name="UTCOffset"></emu-prodref>
    <emu-prodref name="ASCIISign"></emu-prodref>
    <emu-prodref name="Hour"></emu-prodref>
    <emu-prodref name="HourSubcomponents"></emu-prodref>
    <emu-prodref name="TimeSeparator"></emu-prodref>
    <emu-prodref name="MinuteSecond"></emu-prodref>
    <emu-prodref name="TemporalDecimalFraction"></emu-prodref>
    <emu-prodref name="TemporalDecimalSeparator"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-regular-expressions">
    <h1>Regular Expressions</h1>
    <emu-prodref name="Pattern"></emu-prodref>
    <emu-prodref name="Disjunction"></emu-prodref>
    <emu-prodref name="Alternative"></emu-prodref>
    <emu-prodref name="Term"></emu-prodref>
    <emu-prodref name="Assertion"></emu-prodref>
    <emu-prodref name="Quantifier"></emu-prodref>
    <emu-prodref name="QuantifierPrefix"></emu-prodref>
    <emu-prodref name="Atom"></emu-prodref>
    <emu-prodref name="RegularExpressionModifiers"></emu-prodref>
    <emu-prodref name="RegularExpressionModifier"></emu-prodref>
    <emu-prodref name="SyntaxCharacter"></emu-prodref>
    <emu-prodref name="PatternCharacter"></emu-prodref>
    <emu-prodref name="AtomEscape"></emu-prodref>
    <emu-prodref name="CharacterEscape"></emu-prodref>
    <emu-prodref name="ControlEscape"></emu-prodref>
    <emu-prodref name="GroupSpecifier"></emu-prodref>
    <emu-prodref name="GroupName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierStart"></emu-prodref>
    <emu-prodref name="RegExpIdentifierPart"></emu-prodref>
    <emu-prodref name="RegExpUnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeLeadSurrogate"></emu-prodref>
    <emu-prodref name="UnicodeTrailSurrogate"></emu-prodref>
    <p>Each `\\u` |HexTrailSurrogate| for which the choice of associated `u` |HexLeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |HexLeadSurrogate| that would otherwise have no corresponding `\\u` |HexTrailSurrogate|.</p>
    <p>&nbsp;</p>
    <emu-prodref name="HexLeadSurrogate"></emu-prodref>
    <emu-prodref name="HexTrailSurrogate"></emu-prodref>
    <emu-prodref name="HexNonSurrogate"></emu-prodref>
    <emu-prodref name="IdentityEscape"></emu-prodref>
    <emu-prodref name="DecimalEscape"></emu-prodref>
    <emu-prodref name="CharacterClassEscape"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueExpression"></emu-prodref>
    <emu-prodref name="UnicodePropertyName"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValue"></emu-prodref>
    <emu-prodref name="LoneUnicodePropertyNameOrValue"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacter"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacter"></emu-prodref>
    <emu-prodref name="CharacterClass"></emu-prodref>
    <emu-prodref name="ClassContents"></emu-prodref>
    <emu-prodref name="NonemptyClassRanges"></emu-prodref>
    <emu-prodref name="NonemptyClassRangesNoDash"></emu-prodref>
    <emu-prodref name="ClassAtom"></emu-prodref>
    <emu-prodref name="ClassAtomNoDash"></emu-prodref>
    <emu-prodref name="ClassEscape"></emu-prodref>
    <emu-prodref name="ClassSetExpression"></emu-prodref>
    <emu-prodref name="ClassUnion"></emu-prodref>
    <emu-prodref name="ClassIntersection"></emu-prodref>
    <emu-prodref name="ClassSubtraction"></emu-prodref>
    <emu-prodref name="ClassSetRange"></emu-prodref>
    <emu-prodref name="ClassSetOperand"></emu-prodref>
    <emu-prodref name="NestedClass"></emu-prodref>
    <emu-prodref name="ClassStringDisjunction"></emu-prodref>
    <emu-prodref name="ClassStringDisjunctionContents"></emu-prodref>
    <emu-prodref name="ClassString"></emu-prodref>
    <emu-prodref name="NonEmptyClassString"></emu-prodref>
    <emu-prodref name="ClassSetCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedDoublePunctuator"></emu-prodref>
    <emu-prodref name="ClassSetSyntaxCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedPunctuator"></emu-prodref>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>Additional ECMAScript Features for Web Browsers</h1>
  <p>The ECMAScript language syntax and semantics defined in this annex are required when the ECMAScript host is a web browser. The content of this annex is normative but optional if the ECMAScript host is not a web browser.</p>
  <p>Some features defined in this annex are specified in this annex, and some are specified in the main body of this document.</p>
  <p>When a feature is specified in the main body, each point where it affects the document is marked with the words "Normative Optional" in a coloured box. Moreover, where the feature involves particular wording in an algorithm or early error rule, this is guarded by the condition that “<dfn variants="otherwise supports">the host supports</dfn>” the relevant feature. Web browsers are required to support all such features.</p>
  <emu-note>
    <p>This annex describes various legacy features and other characteristics of web browser ECMAScript hosts. All of the language features and behaviours specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. However, the usage of these features by large numbers of existing web pages means that web browsers must continue to support them. The specifications in this annex define the requirements for interoperable implementations of these legacy features.</p>
    <p>These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ECMAScript implementations are discouraged from implementing these features unless the implementation is part of a web browser or is required to run the same legacy ECMAScript code that web browsers encounter.</p>
  </emu-note>

  <emu-annex id="sec-additional-syntax">
    <h1>Additional Syntax</h1>

    <emu-annex id="sec-html-like-comments">
      <h1>HTML-like Comments</h1>
      <p>The syntax and semantics of <emu-xref href="#sec-comments"></emu-xref> is extended as follows except that this extension is not allowed when parsing source text using the goal symbol |Module|:</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        InputElementHashbangOrRegExp ::
          WhiteSpace
          LineTerminator
          Comment
          CommonToken
          HashbangComment
          RegularExpressionLiteral
          HTMLCloseComment

        Comment ::
          MultiLineComment
          SingleLineComment
          SingleLineHTMLOpenComment
          SingleLineHTMLCloseComment
          SingleLineDelimitedComment

        MultiLineComment ::
          `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

        FirstCommentLine ::
          SingleLineDelimitedCommentChars

        SingleLineHTMLOpenComment ::
          `&lt;!--` SingleLineCommentChars?

        SingleLineHTMLCloseComment ::
          LineTerminatorSequence HTMLCloseComment

        SingleLineDelimitedComment ::
          `/*` SingleLineDelimitedCommentChars? `*/`

        HTMLCloseComment ::
          WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `--&gt;` SingleLineCommentChars?

        SingleLineDelimitedCommentChars ::
          SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotAsteriskChar ::
          SourceCharacter but not one of `*` or LineTerminator

        SingleLinePostAsteriskCommentChars ::
          SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotForwardSlashOrAsteriskChar ::
          SourceCharacter but not one of `/` or `*` or LineTerminator

        WhiteSpaceSequence ::
          WhiteSpace WhiteSpaceSequence?

        SingleLineDelimitedCommentSequence ::
          SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?
      </emu-grammar>
      <p>Similar to a |MultiLineComment| that contains a line terminator code point, a |SingleLineHTMLCloseComment| is considered to be a |LineTerminator| for purposes of parsing by the syntactic grammar.</p>
    </emu-annex>

    <emu-annex id="sec-regular-expressions-patterns">
      <h1>Regular Expressions Patterns</h1>
      <p>The syntax of <emu-xref href="#sec-patterns"></emu-xref> is modified and extended as follows. These changes introduce ambiguities that are broken by the ordering of grammar productions and by contextual information. When parsing using the following grammar, each alternative is considered only if previous production alternatives do not match.</p>
      <p>This alternative pattern grammar and semantics only changes the syntax and semantics of BMP patterns. The following grammar extensions include productions parameterized with the [UnicodeMode] parameter. However, none of these extensions change the syntax of Unicode patterns recognized when parsing with the [UnicodeMode] parameter present on the goal symbol.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [+UnicodeMode] Assertion[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] Assertion[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups]

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          [+UnicodeMode] `(?=` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [+UnicodeMode] `(?!` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups]
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        QuantifiableAssertion[NamedCaptureGroups] ::
          `(?=` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`

        ExtendedAtom[NamedCaptureGroups] ::
          `.`
          `\` AtomEscape[~UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]
          CharacterClass[~UnicodeMode, ~UnicodeSetsMode]
          `(` GroupSpecifier[~UnicodeMode]? Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          InvalidBracedQuantifier
          ExtendedPatternCharacter

        InvalidBracedQuantifier ::
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        ExtendedPatternCharacter ::
          SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] DecimalEscape
          [~UnicodeMode] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &le; CountLeftCapturingParensWithin(the |Pattern| containing |DecimalEscape|)]
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode, NamedCaptureGroups] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          [~UnicodeMode] LegacyOctalEscapeSequence
          IdentityEscape[?UnicodeMode, ?NamedCaptureGroups]

        IdentityEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacterIdentityEscape[?NamedCaptureGroups]

        SourceCharacterIdentityEscape[NamedCaptureGroups] ::
          [~NamedCaptureGroups] SourceCharacter but not `c`
          [+NamedCaptureGroups] SourceCharacter but not one of `c` or `k`

        ClassAtomNoDash[UnicodeMode, NamedCaptureGroups] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]

        ClassEscape[UnicodeMode, NamedCaptureGroups] ::
          `b`
          [+UnicodeMode] `-`
          [~UnicodeMode] `c` ClassControlLetter
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]

        ClassControlLetter ::
          DecimalDigit
          `_`
      </emu-grammar>
      <emu-note>
        <p>When the same left-hand sides occurs with both [+UnicodeMode] and [\~UnicodeMode] guards it is to control the disambiguation priority.</p>
      </emu-note>

      <emu-annex id="sec-patterns-static-semantics-early-errors-annexb">
        <h1>Static Semantics: Early Errors</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-early-errors"></emu-xref> is extended as follows:</p>
        <emu-grammar>ExtendedAtom :: InvalidBracedQuantifier</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this production.
          </li>
        </ul>
        <p>Additionally, the rules for the following productions are modified with the addition of the <ins>highlighted</ins> text:</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true* <ins>and this production has a <sub>[UnicodeMode]</sub> parameter</ins>.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *false*, IsCharacterClass of the second |ClassAtom| is *false*, and the CharacterValue of the first |ClassAtom| is strictly greater than the CharacterValue of the second |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true* <ins>and this production has a <sub>[UnicodeMode]</sub> parameter</ins>.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *false*, IsCharacterClass of |ClassAtom| is *false*, and the CharacterValue of |ClassAtomNoDash| is strictly greater than the CharacterValue of |ClassAtom|.
          </li>
        </ul>
      </emu-annex>

      <emu-annex id="sec-countleftcapturingparens-annexb">
        <h1>Static Semantics: CountLeftCapturingParensWithin and CountLeftCapturingParensBefore</h1>
        <p>In the definitions of CountLeftCapturingParensWithin and CountLeftCapturingParensBefore, references to “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ” are to be interpreted as meaning “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ” or “<emu-grammar>ExtendedAtom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ”.</p>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-is-character-class-annexb">
        <h1>Static Semantics: IsCharacterClass</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-is-character-class"></emu-xref> is extended as follows:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-character-value-annexb">
        <h1>Static Semantics: CharacterValue</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-character-value"></emu-xref> is extended as follows:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+005C (REVERSE SOLIDUS).
        </emu-alg>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |ClassControlLetter|.
          1. Let _i_ be the numeric value of _ch_.
          1. Return the remainder of dividing _i_ by 32.
        </emu-alg>
        <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar>
        <emu-alg>
          1. Return the MV of |LegacyOctalEscapeSequence| (see <emu-xref href="#sec-string-literals-static-semantics-mv"></emu-xref>).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compilesubpattern-annexb" oldids="sec-regular-expression-patterns-semantics">
        <h1>Runtime Semantics: CompileSubpattern</h1>
        <p>The semantics of CompileSubpattern is extended as follows:</p>

        <p>The rule for <emu-grammar>Term :: QuantifiableAssertion Quantifier</emu-grammar> is the same as for <emu-grammar>Term :: Atom Quantifier</emu-grammar> but with |QuantifiableAssertion| substituted for |Atom|.</p>
        <p>The rule for <emu-grammar>Term :: ExtendedAtom Quantifier</emu-grammar> is the same as for <emu-grammar>Term :: Atom Quantifier</emu-grammar> but with |ExtendedAtom| substituted for |Atom|.</p>
        <p>The rule for <emu-grammar>Term :: ExtendedAtom</emu-grammar> is the same as for <emu-grammar>Term :: Atom</emu-grammar> but with |ExtendedAtom| substituted for |Atom|.</p>
      </emu-annex>

      <emu-annex id="sec-compileassertion-annexb">
        <h1>Runtime Semantics: CompileAssertion</h1>
        <p>CompileAssertion rules for the <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar> and <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar> productions are also used for the |QuantifiableAssertion| productions, but with |QuantifiableAssertion| substituted for |Assertion|.</p>
      </emu-annex>

      <emu-annex id="sec-compileatom-annexb">
        <h1>Runtime Semantics: CompileAtom</h1>
        <p>CompileAtom rules for the |Atom| productions except for <emu-grammar>Atom :: PatternCharacter</emu-grammar> are also used for the |ExtendedAtom| productions, but with |ExtendedAtom| substituted for |Atom|. The following rules, with parameter _direction_, are also added:</p>
        <emu-grammar>ExtendedAtom :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. Let _A_ be the CharSet containing the single character `\\` U+005C (REVERSE SOLIDUS).
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>ExtendedAtom :: ExtendedPatternCharacter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the character represented by |ExtendedPatternCharacter|.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compiletocharset-annexb">
        <h1>Runtime Semantics: CompileToCharSet</h1>
        <p>The semantics of <emu-xref href="#sec-compiletocharset"></emu-xref> is extended as follows:</p>

        <p>The following two rules replace the corresponding rules of CompileToCharSet.</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRangeOrUnion(_rer_, _A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRangeOrUnion(_rer_, _A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>

        <p>In addition, the following rules are added to CompileToCharSet.</p>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassEscape|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-grammar>ClassAtomNoDash :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the single character `\\` U+005C (REVERSE SOLIDUS).
        </emu-alg>

        <emu-note>This production can only be reached from the sequence `\c` within a character class where it is not followed by an acceptable control character.</emu-note>

        <emu-annex id="sec-runtime-semantics-characterrangeorunion-abstract-operation" type="abstract operation">
          <h1>
            CharacterRangeOrUnion (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If HasEitherUnicodeFlag(_rer_) is *false*, then
              1. If _A_ does not contain exactly one character or _B_ does not contain exactly one character, then
                1. Let _C_ be the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).
                1. Return the union of CharSets _A_, _B_ and _C_.
            1. Return CharacterRange(_A_, _B_).
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-parsepattern-annexb">
        <h1>Static Semantics: ParsePattern ( _patternText_, _u_, _v_ )</h1>
        <p>The semantics of <emu-xref href="#sec-parsepattern"></emu-xref> is extended as follows:</p>
        <p>The abstract operation ParsePattern takes arguments _patternText_ (a sequence of Unicode code points), _u_ (a Boolean), and _v_ (a Boolean). It performs the following steps when called:</p>
        <emu-alg>
          1. If _v_ is *true* and _u_ is *true*, then
            1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.
          1. Else if _v_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else if _u_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else,
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, ~NamedCaptureGroups]|).
            1. If _parseResult_ is a Parse Node and _parseResult_ contains a |GroupName|, then
              1. Set _parseResult_ to ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Return _parseResult_.
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-additional-built-in-properties">
    <h1>Additional Built-in Properties</h1>
    <p>When the ECMAScript host is a web browser the following additional properties of the standard built-in objects are defined.</p>

    <emu-annex id="sec-additional-properties-of-the-global-object">
      <h1>Additional Properties of the Global Object</h1>
      <p>The entries in <emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref> are added to <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>.</p>
      <emu-table id="table-additional-well-known-intrinsic-objects" caption="Additional Well-known Intrinsic Objects" oldids="table-60">
        <table>
          <thead>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              %escape%
            </td>
            <td>
              `escape`
            </td>
            <td>
              The `escape` function (<emu-xref href="#sec-escape-string"></emu-xref>)
            </td>
          </tr>
          <tr>
            <td>
              %unescape%
            </td>
            <td>
              `unescape`
            </td>
            <td>
              The `unescape` function (<emu-xref href="#sec-unescape-string"></emu-xref>)
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-annex id="sec-escape-string">
        <h1>escape ( _string_ )</h1>
        <p>This function is a property of the global object. It computes a new version of a String value in which certain code units have been replaced by a hexadecimal escape sequence.</p>
        <p>When replacing a code unit of numeric value less than or equal to 0x00FF, a two-digit escape sequence of the form <code>%<var>xx</var></code> is used. When replacing a code unit of numeric value strictly greater than 0x00FF, a four-digit escape sequence of the form <code>%u<var>xxxx</var></code> is used.</p>
        <p>It is the <dfn>%escape%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Set _string_ to ? ToString(_string_).
          1. Let _len_ be the length of _string_.
          1. Let _R_ be the empty String.
          1. Let _unescapedSet_ be the string-concatenation of the ASCII word characters and *"@\*+-./"*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _C_ be the code unit at index _k_ within _string_.
            1. If _unescapedSet_ contains _C_, then
              1. Let _S_ be _C_.
            1. Else,
              1. Let _n_ be the numeric value of _C_.
              1. If _n_ &lt; 256, then
                1. Let _hex_ be the String representation of _n_, formatted as an uppercase hexadecimal number.
                1. Let _S_ be the string-concatenation of *"%"* and StringPad(_hex_, 2, *"0"*, ~start~).
              1. Else,
                1. Let _hex_ be the String representation of _n_, formatted as an uppercase hexadecimal number.
                1. Let _S_ be the string-concatenation of *"%u"* and StringPad(_hex_, 4, *"0"*, ~start~).
            1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>The encoding is partly based on the encoding described in RFC 1738, but the entire encoding specified in this standard is described above without regard to the contents of RFC 1738. This encoding does not reflect changes to RFC 1738 made by RFC 3986.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-unescape-string">
        <h1>unescape ( _string_ )</h1>
        <p>This function is a property of the global object. It computes a new version of a String value in which each escape sequence of the sort that might be introduced by the `escape` function is replaced with the code unit that it represents.</p>
        <p>It is the <dfn>%unescape%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Set _string_ to ? ToString(_string_).
          1. Let _len_ be the length of _string_.
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _C_ be the code unit at index _k_ within _string_.
            1. If _C_ is the code unit 0x0025 (PERCENT SIGN), then
              1. Let _hexDigits_ be the empty String.
              1. Let _optionalAdvance_ be 0.
              1. If _k_ + 5 &lt; _len_ and the code unit at index _k_ + 1 within _string_ is the code unit 0x0075 (LATIN SMALL LETTER U), then
                1. Set _hexDigits_ to the substring of _string_ from _k_ + 2 to _k_ + 6.
                1. Set _optionalAdvance_ to 5.
              1. Else if _k_ + 3 ≤ _len_, then
                1. Set _hexDigits_ to the substring of _string_ from _k_ + 1 to _k_ + 3.
                1. Set _optionalAdvance_ to 2.
              1. Let _parseResult_ be ParseText(_hexDigits_, |HexDigits[~Sep]|).
              1. If _parseResult_ is a Parse Node, then
                1. Let _n_ be the MV of _parseResult_.
                1. Set _C_ to the code unit whose numeric value is _n_.
                1. Set _k_ to _k_ + _optionalAdvance_.
            1. Set _R_ to the string-concatenation of _R_ and _C_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-string.prototype-object">
      <h1>Additional Properties of the String.prototype Object</h1>

      <emu-annex id="sec-string.prototype.substr">
        <h1>String.prototype.substr ( _start_, _length_ )</h1>
        <p>This method returns a <emu-not-ref>substring</emu-not-ref> of the result of converting the *this* value to a String, starting from index _start_ and running for _length_ code units (or through the end of the String if _length_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_sourceLength_ + _start_</emu-eqn> where _sourceLength_ is the length of the String. The result is a String value, not a String object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _size_ be the length of _S_.
          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _intStart_ = -∞, set _intStart_ to 0.
          1. Else if _intStart_ &lt; 0, set _intStart_ to max(_size_ + _intStart_, 0).
          1. Else, set _intStart_ to min(_intStart_, _size_).
          1. If _length_ is *undefined*, let _intLength_ be _size_; otherwise let _intLength_ be ? ToIntegerOrInfinity(_length_).
          1. Set _intLength_ to the result of clamping _intLength_ between 0 and _size_.
          1. Let _intEnd_ be min(_intStart_ + _intLength_, _size_).
          1. Return the substring of _S_ from _intStart_ to _intEnd_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-string.prototype.anchor">
        <h1>String.prototype.anchor ( _name_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"a"*, *"name"*, _name_).
        </emu-alg>

        <emu-annex id="sec-createhtml" type="abstract operation">
          <h1>
            CreateHTML (
              _string_: an ECMAScript language value,
              _tag_: a String,
              _attribute_: a String,
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Perform ? RequireObjectCoercible(_string_).
            1. Let _S_ be ? ToString(_string_).
            1. Let _p1_ be the string-concatenation of *"&lt;"* and _tag_.
            1. If _attribute_ is not the empty String, then
              1. Let _V_ be ? ToString(_value_).
              1. Let _escapedV_ be the String value that is the same as _V_ except that each occurrence of the code unit 0x0022 (QUOTATION MARK) in _V_ has been replaced with the six code unit sequence *"&amp;quot;"*.
              1. Set _p1_ to the string-concatenation of:
                * _p1_
                * the code unit 0x0020 (SPACE)
                * _attribute_
                * the code unit 0x003D (EQUALS SIGN)
                * the code unit 0x0022 (QUOTATION MARK)
                * _escapedV_
                * the code unit 0x0022 (QUOTATION MARK)
            1. Let _p2_ be the string-concatenation of _p1_ and *">"*.
            1. Let _p3_ be the string-concatenation of _p2_ and _S_.
            1. Let _p4_ be the string-concatenation of _p3_, *"&lt;/"*, _tag_, and *">"*.
            1. Return _p4_.
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-string.prototype.big">
        <h1>String.prototype.big ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"big"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.blink">
        <h1>String.prototype.blink ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"blink"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.bold">
        <h1>String.prototype.bold ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"b"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fixed">
        <h1>String.prototype.fixed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"tt"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontcolor">
        <h1>String.prototype.fontcolor ( _colour_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"font"*, *"color"*, _colour_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontsize">
        <h1>String.prototype.fontsize ( _size_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"font"*, *"size"*, _size_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.italics">
        <h1>String.prototype.italics ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"i"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.link">
        <h1>String.prototype.link ( _url_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"a"*, *"href"*, _url_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.small">
        <h1>String.prototype.small ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"small"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.strike">
        <h1>String.prototype.strike ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"strike"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sub">
        <h1>String.prototype.sub ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"sub"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sup">
        <h1>String.prototype.sup ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"sup"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="String.prototype.trimleft">
        <h1>String.prototype.trimLeft ( )</h1>
        <emu-note>
          <p>The property *"trimStart"* is preferred. The *"trimLeft"* property is provided principally for compatibility with old code. It is recommended that the *"trimStart"* property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The initial value of the *"trimLeft"* property is %String.prototype.trimStart%, defined in <emu-xref href="#sec-string.prototype.trimstart"></emu-xref>.</p>
      </emu-annex>

      <emu-annex id="String.prototype.trimright">
        <h1>String.prototype.trimRight ( )</h1>
        <emu-note>
          <p>The property *"trimEnd"* is preferred. The *"trimRight"* property is provided principally for compatibility with old code. It is recommended that the *"trimEnd"* property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The initial value of the *"trimRight"* property is %String.prototype.trimEnd%, defined in <emu-xref href="#sec-string.prototype.trimend"></emu-xref>.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-date.prototype-object">
      <h1>Additional Properties of the Date.prototype Object</h1>

      <emu-annex id="sec-date.prototype.getyear">
        <h1>Date.prototype.getYear ( )</h1>
        <emu-note>
          <p>The `getFullYear` method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(LocalTime(_t_)) - *1900*<sub>𝔽</sub>.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.setyear">
        <h1>Date.prototype.setYear ( _year_ )</h1>
        <emu-note>
          <p>The `setFullYear` method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _y_ be ? ToNumber(_year_).
          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise set _t_ to LocalTime(_t_).
          1. Let _yyyy_ be MakeFullYear(_y_).
          1. Let _d_ be MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_)).
          1. Let _date_ be MakeDate(_d_, TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.togmtstring">
        <h1>Date.prototype.toGMTString ( )</h1>
        <emu-note>
          <p>The `toUTCString` method is preferred. This method is provided principally for compatibility with old code.</p>
        </emu-note>
        <p>The initial value of the *"toGMTString"* property is %Date.prototype.toUTCString%, defined in <emu-xref href="#sec-date.prototype.toutcstring"></emu-xref>.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-regexp.prototype-object">
      <h1>Additional Properties of the RegExp.prototype Object</h1>

      <emu-annex id="sec-regexp.prototype.compile">
        <h1>RegExp.prototype.compile ( _pattern_, _flags_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[RegExpMatcher]]).
          1. If _pattern_ is an Object and _pattern_ has a [[RegExpMatcher]] internal slot, then
            1. If _flags_ is not *undefined*, throw a *TypeError* exception.
            1. Let _P_ be _pattern_.[[OriginalSource]].
            1. Let _F_ be _pattern_.[[OriginalFlags]].
          1. Else,
            1. Let _P_ be _pattern_.
            1. Let _F_ be _flags_.
          1. Return ? RegExpInitialize(_O_, _P_, _F_).
        </emu-alg>
        <emu-note>
          <p>This method completely reinitializes the *this* value RegExp with a new pattern and flags. An implementation may interpret use of this method as an assertion that the resulting RegExp object will be used multiple times and hence is a candidate for extra optimization.</p>
        </emu-note>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-other-additional-features">
    <h1>Other Additional Features</h1>

    <emu-annex id="sec-labelled-function-declarations">
      <h1>Labelled Function Declarations</h1>
      <p>Prior to ECMAScript 2015, the specification of |LabelledStatement| did not allow for the association of a statement label with a |FunctionDeclaration|. However, a labelled |FunctionDeclaration| was an allowable extension for non-strict code and most browser-hosted ECMAScript implementations supported that extension. In ECMAScript 2015 and later, the grammar production for |LabelledStatement| permits use of |FunctionDeclaration| as a |LabelledItem| but <emu-xref href="#sec-labelled-statements-static-semantics-early-errors"></emu-xref> includes an Early Error rule that produces a Syntax Error if that occurs. That rule is then modified to suppress the Syntax Error in non-strict code if the host supports this feature.</p>
      <emu-note>
        <p>The early error rules for |WithStatement|, |IfStatement|, and |IterationStatement| prevent these statements from containing a labelled |FunctionDeclaration| in non-strict code.</p>
      </emu-note>
    </emu-annex>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>Block-Level Function Declarations Web Legacy Compatibility Semantics</h1>
      <p>Prior to ECMAScript 2015, the ECMAScript specification did not define the occurrence of a |FunctionDeclaration| as an element of a |Block| statement's |StatementList|. However, support for that form of |FunctionDeclaration| was an allowable extension and most browser-hosted ECMAScript implementations permitted them. Unfortunately, the semantics of such declarations differ among those implementations. Because of these semantic differences, existing web ECMAScript source text that uses |Block| level function declarations is only portable among browser implementations if the usage only depends upon the semantic intersection of all of the browser implementations for such declarations. The following are the use cases that fall within that intersection semantics:</p>
      <ol>
        <li>
          <p>A function is declared and only referenced within a single block.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration|s whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_.
            </li>
            <li>
              All occurrences of _f_ as an |IdentifierReference| are within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
          </ul>
        </li>
        <li>
          <p>A function is declared and possibly used within a single |Block| but also referenced by an inner function definition that is not contained within that same |Block|.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration|s whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_.
            </li>
            <li>
              There may be occurrences of _f_ as an |IdentifierReference| within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
            <li>
              There is at least one occurrence of _f_ as an |IdentifierReference| within another function _h_ that is nested within _g_ and no other declaration of _f_ shadows the references to _f_ from within _h_.
            </li>
            <li>
              All invocations of _h_ occur after the declaration of _f_ has been evaluated.
            </li>
          </ul>
        </li>
        <li>
          <p>A function is declared and possibly used within a single block but also referenced within subsequent blocks.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration| whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_.
            </li>
            <li>
              There may be occurrences of _f_ as an |IdentifierReference| within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
            <li>
              There is at least one occurrence of _f_ as an |IdentifierReference| within the function code of _g_ that lexically follows the |Block| containing the declaration of _f_.
            </li>
          </ul>
        </li>
      </ol>
      <p>The first use case is interoperable with the semantics of |Block| level function declarations provided by ECMAScript 2015. Any pre-existing ECMAScript source text that employs that use case will operate using the Block level function declarations semantics defined by clauses <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>, <emu-xref href="#sec-ecmascript-language-statements-and-declarations"></emu-xref>, and <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>.</p>
      <p>ECMAScript 2015 interoperability for the second and third use cases requires the following extensions to the clause <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>, clause <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>, clause <emu-xref href="#sec-eval-x"></emu-xref> and clause <emu-xref href="#sec-globaldeclarationinstantiation"></emu-xref> semantics.</p>
      <p>If an ECMAScript implementation has a mechanism for reporting diagnostic warning messages, a warning should be produced when code contains a |FunctionDeclaration| for which these compatibility semantics are applied and introduce observable differences from non-compatibility semantics. For example, if a var binding is not introduced because its introduction would create an early error, a warning message should not be produced.</p>
      <p>This feature involves special semantics at the following points:</p>
      <ul>
        <li>one of the early error rules for <emu-grammar>Block : `{` StatementList `}`</emu-grammar> in <emu-xref href="#sec-block-static-semantics-early-errors"></emu-xref></li>
        <li>one of the early error rules for <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar> in <emu-xref href="#sec-switch-statement-static-semantics-early-errors"></emu-xref></li>
        <li>step <emu-xref href="#step-functiondeclarationinstantiation-web-compat-insertion-point"></emu-xref> in FunctionDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref> in BlockDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref> in BlockDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-globaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> in GlobalDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-evaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> in EvalDeclarationInstantiation</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-functiondeclarations-in-ifstatement-statement-clauses">
      <h1>FunctionDeclarations in IfStatement Statement Clauses</h1>
      <p>The following augments the |IfStatement| production in <emu-xref href="#sec-if-statement"></emu-xref>:</p>
      <emu-grammar type="definition">
        IfStatement[Yield, Await, Return] :
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] [lookahead != `else`]
      </emu-grammar>
      <p>This production only applies when parsing non-strict code. Source text matched by this production is processed as if each matching occurrence of |FunctionDeclaration[?Yield, ?Await, ~Default]| was the sole |StatementListItem| of a |BlockStatement| occupying that position in the source text. The semantics of such a synthetic |BlockStatement| includes the web legacy compatibility semantics specified in <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>.</p>
    </emu-annex>

    <emu-annex id="sec-variablestatements-in-catch-blocks">
      <h1>VariableStatements in Catch Blocks</h1>
      <p>In this feature, the |Block| of a |Catch| clause may contain `var` declarations that bind a name that is also bound by the |CatchParameter|. This is accomplished by modifying an early error rule for <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar> in <emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>.</p>
      <emu-note>
        <p>At runtime, such bindings are instantiated in the VariableDeclarationEnvironment. They do not shadow the same-named bindings introduced by the |CatchParameter| and hence the |Initializer| for such `var` declarations will assign to the corresponding catch parameter rather than the `var` binding.</p>
      </emu-note>
      <p>This modified behaviour also applies to `var` and `function` declarations introduced by direct eval calls contained within the |Block| of a |Catch| clause. This change is accomplished by modifying steps <emu-xref href="#step-evaldeclarationinstantiation-throw-duplicate-binding"></emu-xref> and <emu-xref href="#step-evaldeclarationinstantiation-web-compat-bindingexists"></emu-xref> in EvalDeclarationInstantiation.</p>
    </emu-annex>

    <emu-annex id="sec-initializers-in-forin-statement-heads">
      <h1>Initializers in ForIn Statement Heads</h1>
      <p>The following augments the |ForInOfStatement| production in <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>:</p>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>
      <p>This production only applies when parsing non-strict code.</p>
      <p>The static semantics of ContainsDuplicateLabels in <emu-xref href="#sec-static-semantics-containsduplicatelabels"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
      </emu-alg>
      <p>The static semantics of ContainsUndefinedBreakTarget in <emu-xref href="#sec-static-semantics-containsundefinedbreaktarget"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
      </emu-alg>
      <p>The static semantics of ContainsUndefinedContinueTarget in <emu-xref href="#sec-static-semantics-containsundefinedcontinuetarget"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».
      </emu-alg>
      <p>The static semantics of IsDestructuring in <emu-xref href="#sec-static-semantics-isdestructuring"></emu-xref> are augmented with the following:</p>
      <emu-grammar>
        BindingIdentifier :
          Identifier
          `yield`
          `await`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <p>The static semantics of VarDeclaredNames in <emu-xref href="#sec-static-semantics-vardeclarednames"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |BindingIdentifier|.
        1. Let _names2_ be the VarDeclaredNames of |Statement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <p>The static semantics of VarScopedDeclarations in <emu-xref href="#sec-static-semantics-varscopeddeclarations"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _declarations1_ be « |BindingIdentifier| ».
        1. Let _declarations2_ be the VarScopedDeclarations of |Statement|.
        1. Return the list-concatenation of _declarations1_ and _declarations2_.
      </emu-alg>
      <p>The runtime semantics of ForInOfLoopEvaluation in <emu-xref href="#sec-runtime-semantics-forinofloopevaluation"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
        1. Let _lhs_ be ? ResolveBinding(_bindingId_).
        1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
          1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
        1. Else,
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
        1. Perform ? PutValue(_lhs_, _value_).
        1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).
        1. Return ? ForIn/OfBodyEvaluation(|BindingIdentifier|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_).
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-IsHTMLDDA-internal-slot">
      <h1>The [[IsHTMLDDA]] Internal Slot</h1>
      <p>An <dfn>[[IsHTMLDDA]] internal slot</dfn> may exist on host-defined objects. Objects with an [[IsHTMLDDA]] internal slot behave like *undefined* in the <emu-xref href="#sec-toboolean">ToBoolean</emu-xref> and IsLooselyEqual abstract operations and when used as an operand for the <emu-xref href="#sec-typeof-operator">`typeof` operator</emu-xref>.</p>
      <emu-note>
        <p>Objects with an [[IsHTMLDDA]] internal slot are never created by this specification. However, the <a href="https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all"><code>document.all</code> object</a> in web browsers is a host-defined exotic object with this slot that exists for web compatibility purposes. There are no other known examples of this type of object and implementations should not create any with the exception of `document.all`.</p>
      </emu-note>
      <p>This feature involves special semantics at the following points:</p>
      <ul>
        <li>step <emu-xref href="#step-to-boolean-web-compat-insertion-point"></emu-xref> in ToBoolean</li>
        <li>step <emu-xref href="#step-abstract-equality-comparison-web-compat-insertion-point"></emu-xref> in IsLooselyEqual</li>
        <li>step <emu-xref href="#step-typeof-web-compat-insertion-point"></emu-xref> in the evaluation semantics for `typeof`</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-make-job-callback">
      <h1>Non-default behaviour in HostMakeJobCallback</h1>
      <p>The HostMakeJobCallback abstract operation allows hosts which are web browsers to specify non-default behaviour.</p>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-ensure-can-add-private-field">
      <h1>Non-default behaviour in HostEnsureCanAddPrivateElement</h1>
      <p>The HostEnsureCanAddPrivateElement abstract operation allows hosts which are web browsers to specify non-default behaviour.</p>
    </emu-annex>

    <emu-annex id="sec-runtime-errors-for-function-call-assignment-targets">
      <h1>Runtime Errors for Function Call Assignment Targets</h1>
      <p>When a function call (<emu-xref href="#sec-function-calls"></emu-xref>) is used as an assignment target in non-strict code, instead of producing an early error, a *ReferenceError* exception is thrown during evaluation of the assignment.</p>
      <emu-note>
        <p>When the assignment target is the |LeftHandSideExpression| of an |AssignmentExpression|, the assignment operator must be `=` or an |AssignmentOperator|; in particular, the allowance here does not apply to the logical assignment operators (`??=`, `&&=`, `||=`).</p>
      </emu-note>
      <p>See step <emu-xref href="#step-assignmenttargettype-web-compat"></emu-xref> of AssignmentTargetType for <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> and <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>.</p>
    </emu-annex>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-strict-mode-of-ecmascript">
  <h1>The Strict Mode of ECMAScript</h1>
  <p><b>The strict mode restriction and exceptions</b></p>
  <ul>
    <li>
      `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, and `yield` are reserved words within strict mode code. (<emu-xref href="#sec-keywords-and-reserved-words"></emu-xref>).
    </li>
    <li>
      A conforming implementation, when processing strict mode code, must disallow instances of the productions <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar> and <emu-grammar>DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral</emu-grammar>.
    </li>
    <li>
      A conforming implementation, when processing strict mode code, must disallow instances of the productions <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> and <emu-grammar>EscapeSequence :: NonOctalDecimalEscapeSequence</emu-grammar>.
    </li>
    <li>
      Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within strict mode code, its |LeftHandSideExpression| must not evaluate to an unresolvable Reference. If it does a *ReferenceError* exception is thrown (<emu-xref href="#sec-putvalue"></emu-xref>). The |LeftHandSideExpression| also may not be a reference to a data property with the attribute value { [[Writable]]: *false* }, to an accessor property with the attribute value { [[Set]]: *undefined* }, nor to a non-existent property of an object whose [[Extensible]] internal slot is *false*. In these cases a `TypeError` exception is thrown (<emu-xref href="#sec-assignment-operators"></emu-xref>).
    </li>
    <li>
      An |IdentifierReference| with the StringValue *"eval"* or *"arguments"* may not appear as the |LeftHandSideExpression| of an Assignment operator (<emu-xref href="#sec-assignment-operators"></emu-xref>) or of an |UpdateExpression| (<emu-xref href="#sec-update-expressions"></emu-xref>) or as the |UnaryExpression| operated upon by a Prefix Increment (<emu-xref href="#sec-prefix-increment-operator"></emu-xref>) or a Prefix Decrement (<emu-xref href="#sec-prefix-decrement-operator"></emu-xref>) operator.
    </li>
    <li>
      Arguments objects for strict functions define a non-configurable accessor property *"callee"* which throws a *TypeError* exception on access (<emu-xref href="#sec-createunmappedargumentsobject"></emu-xref>).
    </li>
    <li>
      Arguments objects for strict functions do not dynamically share their <emu-xref href="#array-index">array-indexed</emu-xref> property values with the corresponding formal parameter bindings of their functions. (<emu-xref href="#sec-arguments-exotic-objects"></emu-xref>).
    </li>
    <li>
      For strict functions, if an arguments object is created the binding of the local identifier `arguments` to the arguments object is immutable and hence may not be the target of an assignment expression. (<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if the StringValue of a |BindingIdentifier| is either *"eval"* or *"arguments"* within strict mode code (<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code (<emu-xref href="#sec-eval-x"></emu-xref>).
    </li>
    <li>
      If *this* is evaluated within strict mode code, then the *this* value is not coerced to an object. A *this* value of either *undefined* or *null* is not converted to the global object and primitive values are not converted to wrapper objects. The *this* value passed via a function call (including calls made using `Function.prototype.apply` and `Function.prototype.call`) do not coerce the passed *this* value to an object (<emu-xref href="#sec-ordinarycallbindthis"></emu-xref>, <emu-xref href="#sec-function.prototype.apply"></emu-xref>, <emu-xref href="#sec-function.prototype.call"></emu-xref>).
    </li>
    <li>
      When a `delete` operator occurs within strict mode code, a *SyntaxError* is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name (<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      When a `delete` operator occurs within strict mode code, a *TypeError* is thrown if the property to be deleted has the attribute { [[Configurable]]: *false* } or otherwise cannot be deleted (<emu-xref href="#sec-delete-operator-runtime-semantics-evaluation"></emu-xref>).
    </li>
    <li>
      Strict mode code may not include a |WithStatement|. The occurrence of a |WithStatement| in such a context is a *SyntaxError* (<emu-xref href="#sec-with-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if a |CatchParameter| occurs within strict mode code and the BoundNames of |CatchParameter| contains either `eval` or `arguments` (<emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if the same |BindingIdentifier| appears more than once in the |FormalParameters| of a strict function. An attempt to create such a function using a Function, Generator, or AsyncFunction constructor is a *SyntaxError* (<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-createdynamicfunction"></emu-xref>).
    </li>
    <li>
      An implementation may not extend, beyond that defined in this specification, the meanings within strict functions of properties named *"caller"* or *"arguments"* of function instances.
    </li>
  </ul>
</emu-annex>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>
  <p>See <emu-xref href="#sec-hosts-and-implementations"></emu-xref> for the definition of host.</p>

  <emu-annex id="sec-host-hooks-summary">
    <h1>Host Hooks</h1>
    <p><b>HostCallJobCallback(...)</b></p>
    <p><b>HostEnqueueFinalizationRegistryCleanupJob(...)</b></p>
    <p><b>HostEnqueueGenericJob(...)</b></p>
    <p><b>HostEnqueuePromiseJob(...)</b></p>
    <p><b>HostEnqueueTimeoutJob(...)</b></p>
    <p><b>HostEnsureCanCompileStrings(...)</b></p>
    <p><b>HostFinalizeImportMeta(...)</b></p>
    <p><b>HostGetImportMetaProperties(...)</b></p>
    <p><b>HostGrowSharedArrayBuffer(...)</b></p>
    <p><b>HostHasSourceTextAvailable(...)</b></p>
    <p><b>HostLoadImportedModule(...)</b></p>
    <p><b>HostGetSupportedImportAttributes(...)</b></p>
    <p><b>HostMakeJobCallback(...)</b></p>
    <p><b>HostPromiseRejectionTracker(...)</b></p>
    <p><b>HostResizeArrayBuffer(...)</b></p>
    <p><b>InitializeHostDefinedRealm(...)</b></p>
  </emu-annex>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>Host-defined Fields</h1>
    <p>[[HostDefined]] on Realm Records: See <emu-xref href="#table-realm-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on Script Records: See <emu-xref href="#table-script-records"></emu-xref>.</p>
    <p>[[HostDefined]] on Module Records: See <emu-xref href="#table-module-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on JobCallback Records: See <emu-xref href="#table-jobcallback-records"></emu-xref>.</p>
    <p>[[HostSynchronizesWith]] on Candidate Executions: See <emu-xref href="#table-candidate-execution-records"></emu-xref>.</p>
    <p>[[IsHTMLDDA]]: See <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-host-defined-objects-summary">
    <h1>Host-defined Objects</h1>
    <p>The global object: See clause <emu-xref href="#sec-global-object"></emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-host-running-jobs">
    <h1>Running Jobs</h1>
    <p>Preparation steps before, and cleanup steps after, invocation of Job Abstract Closures. See <emu-xref href="#sec-jobs"></emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-host-internal-methods-of-exotic-objects">
    <h1>Internal Methods of Exotic Objects</h1>
    <p>Any of the essential internal methods in <emu-xref href="#table-essential-internal-methods"></emu-xref> for any exotic object not specified within this specification.</p>
  </emu-annex>

  <emu-annex id="sec-host-built-in-objects-and-methods">
    <h1>Built-in Objects and Methods</h1>
    <p>Any built-in objects and methods not defined within this specification, except as restricted in <emu-xref href="#sec-forbidden-extensions"></emu-xref>.</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact">
  <h1>Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact</h1>
  <p><emu-xref href="#sec-candeclareglobalvar"></emu-xref>-<emu-xref href="#sec-createglobalfunctionbinding"></emu-xref> Edition 5 and 5.1 used a property existence test to determine whether a global object property corresponding to a new global declaration already existed. ECMAScript 2015 uses an own property existence test. This corresponds to what has been most commonly implemented by web browsers.</p>
  <p><emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>: The 5<sup>th</sup> Edition moved the capture of the current array length prior to the integer conversion of the array index or new length value. However, the captured length value could become invalid if the conversion process has the side-effect of changing the array length. ECMAScript 2015 specifies that the current array length must be captured after the possible occurrence of such side-effects.</p>
  <p><emu-xref href="#sec-timeclip"></emu-xref>: Previous editions permitted the TimeClip abstract operation to return either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub> as the representation of a 0 time value. ECMAScript 2015 specifies that *+0*<sub>𝔽</sub> always returned. This means that for ECMAScript 2015 the time value of a Date is never observably *-0*<sub>𝔽</sub> and methods that return time values never return *-0*<sub>𝔽</sub>.</p>
  <p><emu-xref href="#sec-date-time-string-format"></emu-xref>: If a UTC offset representation is not present, the local time zone is used. Edition 5.1 incorrectly stated that a missing time zone should be interpreted as *"z"*.</p>
  <p><emu-xref href="#sec-date.prototype.toisostring"></emu-xref>: If the year cannot be represented using the Date Time String Format specified in <emu-xref href="#sec-date-time-string-format"></emu-xref> a RangeError exception is thrown. Previous editions did not specify the behaviour for that case.</p>
  <p><emu-xref href="#sec-date.prototype.tostring"></emu-xref>: Previous editions did not specify the value returned by `Date.prototype.toString` when the time value is *NaN*. ECMAScript 2015 specifies the result to be the String value *"Invalid Date"*.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>, <emu-xref href="#sec-escaperegexppattern"></emu-xref>: Any LineTerminator code points in the value of the *"source"* property of a RegExp instance must be expressed using an escape sequence. Edition 5.1 only required the escaping of `/`.</p>
  <p><emu-xref href="#sec-regexp.prototype-%symbol.match%"></emu-xref>, <emu-xref href="#sec-regexp.prototype-%symbol.replace%"></emu-xref>: In previous editions, the specifications for `String.prototype.match` and `String.prototype.replace` was incorrect for cases where the pattern argument was a RegExp value whose `global` flag is set. The previous specifications stated that for each attempt to match the pattern, if `lastIndex` did not change, it should be incremented by 1. The correct behaviour is that `lastIndex` should be incremented by 1 only if the pattern matched the empty String.</p>
  <p><emu-xref href="#sec-array.prototype.sort"></emu-xref>: Previous editions did not specify how a *NaN* value returned by a _comparator_ was interpreted by `Array.prototype.sort`. ECMAScript 2015 specifies that such as value is treated as if *+0*<sub>𝔽</sub> was returned from the _comparator_. ECMAScript 2015 also specifies that ToNumber is applied to the result returned by a _comparator_. In previous editions, the effect of a _comparator_ result that is not a Number value was implementation-defined. In practice, implementations call ToNumber.</p>
</emu-annex>

<emu-annex id="sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions">
  <h1>Additions and Changes That Introduce Incompatibilities with Prior Editions</h1>
  <p><emu-xref href="#sec-reference-record-specification-type"></emu-xref>: In ECMAScript 2015, Function calls are not allowed to return a Reference Record.</p>
  <p><emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>: In ECMAScript 2015, ToNumber applied to a String value now recognizes and converts |BinaryIntegerLiteral| and |OctalIntegerLiteral| numeric strings. In previous editions such strings were converted to *NaN*.</p>
  <p><emu-xref href="#sec-code-realms"></emu-xref>: In ECMAScript 2018, Template objects are canonicalized based on Parse Node (source location), instead of across all occurrences of that template literal or tagged template in a Realm in previous editions.</p>
  <p><emu-xref href="#sec-white-space"></emu-xref>: In ECMAScript 2016, Unicode 8.0.0 or higher is mandated, as opposed to ECMAScript 2015 which mandated Unicode 5.1. In particular, this caused U+180E MONGOLIAN VOWEL SEPARATOR, which was in the `Space_Separator` (`Zs`) category and thus treated as whitespace in ECMAScript 2015, to be moved to the `Format` (`Cf`) category (as of Unicode 6.3.0). This causes whitespace-sensitive methods to behave differently. For example, `"\u180E".trim().length` was `0` in previous editions, but `1` in ECMAScript 2016 and later. Additionally, ECMAScript 2017 mandated always using the latest version of the Unicode Standard.</p>
  <p><emu-xref href="#sec-names-and-keywords"></emu-xref>: In ECMAScript 2015, the valid code points for an |IdentifierName| are specified in terms of the Unicode properties “ID_Start” and “ID_Continue”. In previous editions, the valid |IdentifierName| or |Identifier| code points were specified by enumerating various Unicode code point categories.</p>
  <p><emu-xref href="#sec-rules-of-automatic-semicolon-insertion"></emu-xref>: In ECMAScript 2015, Automatic Semicolon Insertion adds a semicolon at the end of a do-while statement if the semicolon is missing. This change aligns the specification with the actual behaviour of most existing implementations.</p>
  <p><emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>: In ECMAScript 2015, it is no longer an early error to have duplicate property names in Object Initializers.</p>
  <p><emu-xref href="#sec-assignment-operators-static-semantics-early-errors"></emu-xref>: In ECMAScript 2015, strict mode code containing an assignment to an immutable binding such as the function name of a |FunctionExpression| does not produce an early error. Instead it produces a runtime error.</p>
  <p><emu-xref href="#sec-block"></emu-xref>: In ECMAScript 2015, a |StatementList| beginning with the token let followed by the input elements |LineTerminator| then |Identifier| is the start of a |LexicalDeclaration|. In previous editions, automatic semicolon insertion would always insert a semicolon before the |Identifier| input element.</p>
  <p><emu-xref href="#sec-expression-statement"></emu-xref>: In ECMAScript 2015, a |StatementListItem| beginning with the token `let` followed by the token `[` is the start of a |LexicalDeclaration|. In previous editions such a sequence would be the start of an |ExpressionStatement|.</p>
  <p><emu-xref href="#sec-if-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the normal result of an |IfStatement| is never the value ~empty~. If no |Statement| part is evaluated or if the evaluated |Statement| part produces a normal completion containing ~empty~, the result of the |IfStatement| is *undefined*.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, if the `(` token of a for statement is immediately followed by the token sequence `let [` then the `let` is treated as the start of a |LexicalDeclaration|. In previous editions such a token sequence would be the start of an |Expression|.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, if the ( token of a for-in statement is immediately followed by the token sequence `let [` then the `let` is treated as the start of a |ForDeclaration|. In previous editions such a token sequence would be the start of an |LeftHandSideExpression|.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: Prior to ECMAScript 2015, an initialization expression could appear as part of the |VariableDeclaration| that precedes the `in` keyword. In ECMAScript 2015, the |ForBinding| in that same position does not allow the occurrence of such an initializer. In ECMAScript 2017, such an initializer is permitted only in non-strict code.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, the result of evaluating an |IterationStatement| is never a normal completion whose [[Value]] is ~empty~. If the |Statement| part of an |IterationStatement| is not evaluated or if the final evaluation of the |Statement| part produces a normal completion whose [[Value]] is ~empty~, the result of evaluating the |IterationStatement| is a normal completion whose [[Value]] is *undefined*.</p>
  <p><emu-xref href="#sec-with-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the result of evaluating a |WithStatement| is never a normal completion whose [[Value]] is ~empty~. If evaluation of the |Statement| part of a |WithStatement| produces a normal completion whose [[Value]] is ~empty~, the result of evaluating the |WithStatement| is a normal completion whose [[Value]] is *undefined*.</p>
  <p><emu-xref href="#sec-switch-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the result of evaluating a |SwitchStatement| is never a normal completion whose [[Value]] is ~empty~. If evaluation of the |CaseBlock| part of a |SwitchStatement| produces a normal completion whose [[Value]] is ~empty~, the result of evaluating the |SwitchStatement| is a normal completion whose [[Value]] is *undefined*.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>: In ECMAScript 2015, it is an early error for a |Catch| clause to contain a `var` declaration for the same |Identifier| that appears as the |Catch| clause parameter. In previous editions, such a variable declaration would be instantiated in the enclosing variable environment but the declaration's |Initializer| value would be assigned to the |Catch| parameter.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>, <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref>: In ECMAScript 2015, a runtime *SyntaxError* is thrown if a |Catch| clause evaluates a non-strict direct `eval` whose eval code includes a `var` or `FunctionDeclaration` declaration that binds the same |Identifier| that appears as the |Catch| clause parameter.</p>
  <p><emu-xref href="#sec-try-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the result of a |TryStatement| is never the value ~empty~. If the |Block| part of a |TryStatement| evaluates to a normal completion containing ~empty~, the result of the |TryStatement| is *undefined*. If the |Block| part of a |TryStatement| evaluates to a throw completion and it has a |Catch| part that evaluates to a normal completion containing ~empty~, the result of the |TryStatement| is *undefined* if there is no |Finally| clause or if its |Finally| clause evaluates to an ~empty~ normal completion.</p>
  <p><emu-xref href="#sec-runtime-semantics-methoddefinitionevaluation"></emu-xref> In ECMAScript 2015, the function objects that are created as the values of the [[Get]] or [[Set]] attribute of accessor properties in an |ObjectLiteral| are not constructor functions and they do not have a *"prototype"* own property. In the previous edition, they were constructors and had a *"prototype"* property.</p>
  <p><emu-xref href="#sec-object.freeze"></emu-xref>: In ECMAScript 2015, if the argument to `Object.freeze` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getownpropertydescriptor"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getOwnPropertyDescriptor` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getownpropertynames"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getOwnPropertyNames` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getprototypeof"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getPrototypeOf` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.isextensible"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isExtensible` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.isfrozen"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isFrozen` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.issealed"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isSealed` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.keys"></emu-xref>: In ECMAScript 2015, if the argument to `Object.keys` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.preventextensions"></emu-xref>: In ECMAScript 2015, if the argument to `Object.preventExtensions` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.seal"></emu-xref>: In ECMAScript 2015, if the argument to `Object.seal` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-function.prototype.bind"></emu-xref>: In ECMAScript 2015, the [[Prototype]] internal slot of a bound function is set to the [[GetPrototypeOf]] value of its target function. In the previous edition, [[Prototype]] was always set to %Function.prototype%.</p>
  <p><emu-xref href="#sec-function-instances-length"></emu-xref>: In ECMAScript 2015, the *"length"* property of function instances is configurable. In previous editions it was non-configurable.</p>
  <p><emu-xref href="#sec-properties-of-the-nativeerror-constructors"></emu-xref>: In ECMAScript 2015, the [[Prototype]] internal slot of a _NativeError_ constructor is the Error constructor. In previous editions it was the Function prototype object.</p>
  <p><emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref> In ECMAScript 2015, the Date prototype object is not a Date instance. In previous editions it was a Date instance whose TimeValue was *NaN*.</p>
  <p><emu-xref href="#sec-string.prototype.localecompare"></emu-xref> In ECMAScript 2015, the `String.prototype.localeCompare` function must treat Strings that are canonically equivalent according to the Unicode Standard as being identical. In previous editions implementations were permitted to ignore canonical equivalence and could instead use a bit-wise comparison.</p>
  <p><emu-xref href="#sec-string.prototype.tolowercase"></emu-xref> and <emu-xref href="#sec-string.prototype.touppercase"></emu-xref> In ECMAScript 2015, lowercase/upper conversion processing operates on code points. In previous editions such the conversion processing was only applied to individual code units. The only affected code points are those in the Deseret block of Unicode.</p>
  <p><emu-xref href="#sec-string.prototype.trim"></emu-xref> In ECMAScript 2015, the `String.prototype.trim` method is defined to recognize white space code points that may exist outside of the Unicode BMP. However, as of Unicode 7 no such code points are defined. In previous editions such code points would not have been recognized as white space.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref> In ECMAScript 2015, If the _pattern_ argument is a RegExp instance and the _flags_ argument is not *undefined*, a new RegExp instance is created just like _pattern_ except that _pattern_'s flags are replaced by the argument _flags_. In previous editions a *TypeError* exception was thrown when _pattern_ was a RegExp instance and _flags_ was not *undefined*.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> In ECMAScript 2015, the RegExp prototype object is not a RegExp instance. In previous editions it was a RegExp instance whose pattern is the empty String.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> In ECMAScript 2015, *"source"*, *"global"*, *"ignoreCase"*, and *"multiline"* are accessor properties defined on the RegExp prototype object. In previous editions they were data properties defined on RegExp instances.</p>
  <p><emu-xref href="#sec-atomics.notify"></emu-xref>: In ECMAScript 2019, `Atomics.wake` has been renamed to `Atomics.notify` to prevent confusion with `Atomics.wait`.</p>
  <p><emu-xref href="#sec-asyncfromsynciteratorcontinuation"></emu-xref>, <emu-xref href="#sec-asyncgeneratorresume"></emu-xref>: In ECMAScript 2019, the number of Jobs enqueued by `await` was reduced, which could create an observable difference in resolution order between a `then()` call and an `await` expression.</p>
</emu-annex>

<emu-annex id="sec-bibliography" back-matter>
  <h1>Bibliography</h1>
  <ol>
    <li>
      <dfn>IEEE 754-2019</dfn>: <i>IEEE Standard for Floating-Point Arithmetic</i>. Institute of Electrical and Electronic Engineers, New York (2019)
      <emu-note>
        <p>There are no normative changes between IEEE 754-2008 and IEEE 754-2019 that affect the ECMA-262 specification.</p>
      </emu-note>
    </li>
    <li>
      <i>The Unicode Standard</i>, available at &lt;<a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>>
    </li>
    <li>
      <i>Unicode Technical Note #5: Canonical Equivalence in Applications</i>, available at &lt;<a href="https://unicode.org/notes/tn5/">https://unicode.org/notes/tn5/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #10: Unicode Collation Algorithm</i>, available at &lt;<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #15, Unicode Normalization Forms</i>, available at &lt;<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #18: Unicode Regular Expressions</i>, available at &lt;<a href="https://unicode.org/reports/tr18/">https://unicode.org/reports/tr18/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #24: Unicode `Script` Property</i>, available at &lt;<a href="https://unicode.org/reports/tr24/">https://unicode.org/reports/tr24/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax</i>, available at &lt;<a href="https://unicode.org/reports/tr31/">https://unicode.org/reports/tr31/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #44: Unicode Character Database</i>, available at &lt;<a href="https://unicode.org/reports/tr44/">https://unicode.org/reports/tr44/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #51: Unicode Emoji</i>, available at &lt;<a href="https://unicode.org/reports/tr51/">https://unicode.org/reports/tr51/</a>>
    </li>
    <li>
      <i>IANA Time Zone Database</i>, available at &lt;<a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>>
    </li>
    <li>
      ISO 8601:2004(E) <i>Data elements and interchange formats — Information interchange — Representation of dates and times</i>
    </li>
    <li>
      <i>RFC 1738 “Uniform Resource Locators (URL)”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc1738">https://tools.ietf.org/html/rfc1738</a>>
    </li>
    <li>
      <i>RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc2396">https://tools.ietf.org/html/rfc2396</a>>
    </li>
    <li>
      <i>RFC 3629 “UTF-8, a transformation format of ISO 10646”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>>
    </li>
    <li>
      <i>RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>>
    </li>
  </ol>
</emu-annex>

<emu-annex id="sec-colophon" back-matter>
  <h1>Colophon</h1>
  <p>This specification is authored on <a href="https://github.com/tc39/ecma262">GitHub</a> in a plaintext source format called <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a>. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring Ecma specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a> for defining syntax and <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> for authoring algorithm steps. PDF renderings of this specification are produced using a print stylesheet which takes advantage of the CSS Paged Media specification and is converted using <a href="https://www.princexml.com/">PrinceXML</a>.</p>
  <p>Prior editions of this specification were authored using Word—the Ecmarkup source text that formed the basis of this edition was produced by converting the ECMAScript 2015 Word document to Ecmarkup using an automated conversion tool.</p>
</emu-annex>
