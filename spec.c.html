<!DOCTYPE html>
<html lang="zh-hans">
<meta charset="utf-8">
<link rel="icon" href="https://tc39.es/ecma262/img/favicon.ico">
<script src="https://htmlspecs.com/dropdown.js"></script>
<style>
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }

  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }

  #ecma-logo {
    width: 500px;
  }

  .corner-cell {
    position: relative;
    height: 2lh;
  }
  .corner-cell .slash {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom left, transparent calc(50% - 1px), gray, transparent calc(50% + 1px));
  }
  .corner-cell > .column {
    position: absolute;
    bottom: 0.4em;
    left: 1em;
  }
  .corner-cell > .row {
    position: absolute;
    top: 0.4em;
    right: 1em;
  }
</style>
<style media="print">
  /**
  * ECMA-262-specific hacks. Shouldn't require a ton of maintenance; audit if
  * visual inspection results in unexpected page breaks.
  *
  * For print version, the table captioned "Module fields after the initial Evaluate() call" _may_ need to set the row
  * EVALUATING-ASYNC to one cell with a colspan of 5. It typically does not fit on the page, but the cell merging is
  * not a perfectly accurate solution and will not be merged back in to the specification.
  * See https://github.com/tc39/ecma262/pull/3623#issuecomment-3029366960
  */

  /* Make sure tables are wide enough for their captions */
  table {
    min-width: 135mm;
  }

  /* 2.2 Examples of legacy/normative-optional are small enough to be aggressive against breaks */
  #sec-conformance [example],
  /* 16.2.1.xxx many tables */
  #sec-example-cyclic-module-record-graphs table {
    break-inside: avoid-page;
  }

  /* 12.10.1 long note can break wherever it wants */
  #sec-rules-of-automatic-semicolon-insertion > emu-note {
    break-before: initial;
    break-inside: initial;
  }

  /* 12.10.X Sections start with an <em> not inside a <p> */
  #sec-examples-of-automatic-semicolon-insertion > em,
  #sec-interesting-cases-of-automatic-semicolon-insertion > em,
  #sec-asi-cases-with-no-lineterminator-here > em {
    display: block;
    margin-top: 1.25ex;
  }

  /* 15.1.X missing spacing between intro and first emu-grammar */
  #sec-static-semantics-containsexpression > emu-grammar:first-of-type {
    margin-top: 2ex;
  }

  /* 15.3 A very long term combined with inline-block, nowrap, and justified text resulting in weird punctuation */
  #sec-arrow-function-definitions > p > emu-grammar {
    text-align: left;
  }

  /* 20.X legacy title */
  #sec-object\.prototype\.__proto__ > .attributes-tag {
    break-before: avoid-page;
    break-after: avoid-page;
  }

  /* 21.X table middle column is too narrow */
  #table-time-zone-identifier-record-fields > figure > table th:nth-of-type(2) {
    min-width: 19mm;
  }

  /* 29.X extremely long note */
  #sec-shared-memory-guidelines > emu-note {
    break-inside: auto;
  }

  .unicode-property-table {
    table-layout: initial;
    width: auto;
    font-size: 90%;
  }

  .unicode-property-table th:first-of-type {
    width: 33%;
  }

  .corner-cell {
    background-image: url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI0NiIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNSIgd2lkdGg9IjI0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzE1LjI2NiAzOTYuMzQzIDI0MS4zOTQgNDUuMTU1IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS4wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMxNC45MyAtMzk1LjkzNSkiLz48L3N2Zz4=);
    background-repeat: no-repeat;
    background-size: 100% 3em;
    height: 3em;
    padding: 0;
    vertical-align: inherit;
    position: static;
  }

  .corner-cell .slash {
    display: none;
  }

  .corner-cell > .column, .corner-cell > .row {
    display: block;
    position: relative;
  }

  .corner-cell > .row {
    text-align: right;
    top: -0.75em
  }

  .corner-cell > .column {
    text-align: left;
    bottom: -1.25em;
  }
</style>
<pre class="metadata">
  title: ECMAScript<sup>&reg;</sup> 2026 语言规范
  shortname: ECMA-262
  status: draft
  location: https://tc39.es/ecma262/
  markEffects: true
</pre>
<p><img src="https://tc39.es/ecma262/img/ecma-logo.svg" id="ecma-logo" alt="Ecma International 标志"></p>
<div id="metadata-block">
  <h1>关于本规范</h1>
  <p>位于 <a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a> 的文档是最准确且最新的 ECMAScript 规范。它包含了最近年度快照的内容，以及自该快照以来所有已完成的 <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md">提案</a>（即已在 <a href="https://tc39.es/process-document/">提案流程</a>中达到第 4 阶段，并且已在多个实现中落地、将在下一次实际修订中包含的提案）。</p>
  <p>本文件可作为<a href>单页</a>或<a href="multipage/">多页</a>形式获取。</p>
  <h1>如何参与规范制定</h1>
  <p>本规范在 GitHub 上由 ECMAScript 社区协作开发。您可以通过以下几种方式参与本规范的制定：</p>
  <ul>
    <li>GitHub 仓库：<a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></li>
    <li>问题反馈：<a href="https://github.com/tc39/ecma262/issues">所有问题</a>，<a href="https://github.com/tc39/ecma262/issues/new">提交新问题</a></li>
    <li>拉取请求：<a href="https://github.com/tc39/ecma262/pulls">所有拉取请求</a>，<a href="https://github.com/tc39/ecma262/pulls/new">创建新拉取请求</a></li>
    <li>测试套件：<a href="https://github.com/tc39/test262">Test262</a></li>
    <li>
      编辑：
      <ul>
        <li><a href="mailto:shu at rfrn dot org">Shu-yu Guo</a></li>
        <li><a href="mailto:ecma262-editor-list at michael dot ficarra dot me">Michael Ficarra</a> (<a href="https://bsky.app/profile/michael.ficarra.me">@michael.ficarra.me</a>)</li>
        <li><a href="mailto:bakkot at gmail dot com">Kevin Gibbons</a></li>
      </ul>
    </li>
    <li>
      社区：
      <ul>
        <li>Discourse: <a href="https://es.discourse.group">https://es.discourse.group/</a></li>
        <li>聊天：<a href="https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md">Matrix</a></li>
        <li>邮件<emu-not-ref>列表</emu-not-ref>存档：<a href="https://esdiscuss.org">https://esdiscuss.org/</a></li>
      </ul>
    </li>
  </ul>
  <p>更多关于本文件创建方式的信息请参阅 <emu-xref href="#sec-colophon">colophon</emu-xref>。</p>
</div>

<emu-intro id="sec-intro">
  <h1>简介</h1>
  <p>本 Ecma 标准定义了 ECMAScript 2026 语言，这是 ECMAScript 语言规范的第十七版。自1997年第一版发布以来，ECMAScript已发展为全球使用最广泛的通用编程语言之一。它最著名的应用是在网页浏览器中嵌入的语言，但也在服务器和嵌入式应用中被广泛采用。</p>
  <p>ECMAScript 基于多种起源技术，其中最知名的是 JavaScript（Netscape）和 JScript（Microsoft）。该语言由 Brendan Eich 在 Netscape 发明，并首次出现在该公司 Navigator 2.0 浏览器中。随后，Netscape 的所有浏览器以及 Microsoft 从 Internet Explorer 3.0 起的所有浏览器均支持该语言。</p>
  <p>ECMAScript 语言规范的开发始于 1996 年 11 月。该 Ecma 标准的第一版由 Ecma 大会在 1997 年 6 月通过。</p>
  <p>该 Ecma 标准按快速通道程序提交至 ISO/IEC JTC 1，并于 1998 年 4 月获批为国际标准 ISO/IEC 16262。Ecma 大会于 1998 年 6 月批准了 ECMA-262 的第二版，以确保其与 ISO/IEC 16262 完全一致。第一版与第二版之间的更改仅为编辑性质。</p>
  <p>标准的第三版引入了强大的正则表达式、更好的字符串处理、新的控制语句、try/catch 异常处理、更严格的错误定义、数字输出格式，以及为未来语言发展做出的细微调整。第三版由 Ecma 大会于 1999 年 12 月通过，并作为 ISO/IEC 16262:2002 于 2002 年 6 月发布。</p>
  <p>第三版发布后，ECMAScript 在万维网环境下得到广泛采用，成为几乎所有浏览器支持的编程语言。曾有大量工作投入到 ECMAScript 第四版的开发中，但该工作最终未完成并未以第四版发布，部分内容被融入到第六版的开发中。</p>
  <p>ECMAScript 第五版（作为 ECMA-262 第 5 版发布）规范化了已成为浏览器实现间通用的语言解释方式，并加入了自第三版发布以来出现的新特性。这些特性包括访问器属性、对象的反射创建与检查、属性特性程序控制、更多数组操作函数、对 JSON 对象编码格式的支持，以及增强错误检查和程序安全性的严格模式。第五版由 Ecma 大会于 2009 年 12 月通过。</p>
  <p>第五版按快速通道程序提交至 ISO/IEC JTC 1，并获批为国际标准 ISO/IEC 16262:2011。ECMAScript 标准第 5.1 版包含了细微修正，与 ISO/IEC 16262:2011 的文本一致。5.1 版由 Ecma 大会于 2011 年 6 月通过。</p>
  <p>第六版的集中开发始于 2009 年，在第五版准备发布期间。但在此之前，自 1999 年第三版发布起，已进行了大量实验和语言增强设计。实际上，第六版的完成是十五年努力的结晶。本版目标包括更好地支持大型应用、库创建，以及将 ECMAScript 作为其他语言编译目标。主要增强包括模块、类声明、词法块作用域、迭代器和生成器、异步编程的 Promise、解构模式和尾调用优化。内置库扩展以支持更多数据抽象，如 Map、Set 和二进制数值数组，并进一步支持字符串和正则表达式中的 Unicode 补充字符。内置对象也可以通过子类化进行扩展。第六版为语言和库的常规、增量性增强奠定了基础。第六版由 2015 年 6 月的大会通过。</p>
  <p>ECMAScript 2016 是 Ecma TC39 新的年度发布节奏和开放开发流程下发布的首个 ECMAScript 版本。基础文档由 ECMAScript 2015 的源文档转换成纯文本格式，并在 GitHub 上持续开发。在本标准开发期间，提交了数百个拉取请求和问题，修复了数千个错误、编辑问题和其他改进。此外，开发了许多软件工具以支持此过程，包括 Ecmarkup、Ecmarkdown 和 Grammarkdown。ES2016 还新增了指数运算符和 `Array.prototype` 的 `includes` 方法。</p>
  <p>ECMAScript 2017 引入了异步函数、共享内存和原子操作，以及多项语言和库的增强、错误修复和编辑更新。异步函数通过提供 Promise 返回函数的语法改善了异步编程体验。共享内存和原子操作引入了新的内存模型，使多代理程序可以使用原子操作进行通信，即使在并行 CPU 上也能确保有序执行。还新增了 Object 的静态方法：`Object.values`、`Object.entries` 和 `Object.getOwnPropertyDescriptors`。</p>
  <p>ECMAScript 2018 引入了通过异步迭代器协议和异步生成器实现的异步迭代支持。还新增了四种正则表达式特性：`dotAll` 标志、命名捕获组、Unicode 属性转义和后行断言。最后还包括对象剩余和展开属性。</p>
  <p>ECMAScript 2019 新增了几种内置函数：用于数组扁平化的 `Array.prototype` 上的 `flat` 和 `flatMap`，用于直接将 `Object.entries` 的返回值转为新对象的 `Object.fromEntries`，以及作为更合理命名替代的 `String.prototype` 上的 `trimStart` 和 `trimEnd`（替代广泛实现但未标准化的 `String.prototype.trimLeft` 和 `trimRight`）。此外还包括对语法和语义的细微更新。语法更新包括可选的 catch 绑定参数以及在字符串字面量中允许 U+2028（行分隔符）和 U+2029（段分隔符），以与 JSON 保持一致。其他更新包括要求 `Array.prototype.sort` 必须为稳定排序，要求 `JSON.stringify` 无论输入如何都返回格式正确的 UTF-8，以及明确要求 `Function.prototype.toString` 返回相应的原始源代码或标准占位符。</p>
  <p>ECMAScript 2020，第 11 版，引入了字符串的 `matchAll` 方法，可通过全局正则表达式生成所有匹配对象的迭代器；`import()`，一种可动态指定异步导入模块的语法；`BigInt`，用于任意精度整数的新数值原语；`Promise.allSettled`，一种不会短路的 Promise 组合器；`globalThis`，一种通用访问全局 `this` 的方式；模块内专用的 `export * as ns from 'module'` 语法；`for-in` 枚举顺序的标准化提升；模块内由宿主环境填充的 `import.meta` 对象，可包含关于模块的上下文信息；以及为“空值”(*undefined* 或 *null*) 增强体验的新语法特性：空值合并运算符和可选链运算符，分别用于值选择和属性访问/函数调用时遇到空值自动短路。</p>
  <p>ECMAScript 2021，第 12 版，引入了字符串的 `replaceAll` 方法；`Promise.any`，一种在输入值满足条件时短路的 Promise 组合器；`AggregateError`，用于同时表示多个错误的新错误类型；逻辑赋值运算符（`??=`, `&&=`, `||=`）；`WeakRef`，用于引用目标对象但不阻止其被垃圾回收，以及 `FinalizationRegistry`，用于注册和注销在目标对象被垃圾回收时执行的清理操作；数字字面量分隔符（如 `1_000`）；并且 `Array.prototype.sort` 更加精确，减少了实现定义排序结果的情况。</p>
  <p>ECMAScript 2022，第 13 版，引入了顶层 `await`，允许在模块顶层使用该关键字；新增类元素：公有和私有实例字段、静态字段、私有实例方法和访问器、私有静态方法和访问器；类中的静态块，用于每个类的初始化；`#x in obj` 语法，用于检测对象上的私有字段是否存在；正则表达式匹配索引（通过 `/d` 标志），可提供匹配子字符串的起止索引；错误对象的 `cause` 属性，可用于记录错误因果链；字符串、数组和 TypedArray 的 `at` 方法，实现相对索引；以及 `Object.hasOwn`，作为更方便的 `Object.prototype.hasOwnProperty` 替代方案。</p>
  <p>ECMAScript 2023，第 14 版，在 `Array.prototype` 和 `TypedArray.prototype` 上新增了 `toSorted`、`toReversed`、`with`、`findLast` 和 `findLastIndex` 方法，并在 `Array.prototype` 上新增了 `toSpliced` 方法；支持文件开头的 `#!` 注释，以更好地支持可执行 ECMAScript 文件；允许在弱集合中使用大多数 Symbol 作为键。</p>
  <p>ECMAScript 2024，第 15 版，增加了 ArrayBuffer 和 SharedArrayBuffer 的动态调整大小和转移功能；新增了用于处理字符串集合的高级特性的新正则表达式 `/v` 标志；引入了便捷构造 Promise 的 `Promise.withResolvers` 方法，数据聚合的 `Object.groupBy` 和 `Map.groupBy` 方法，异步等待共享内存变更的 `Atomics.waitAsync` 方法，以及用于检测和保证字符串仅包含格式正确 Unicode 的 `String.prototype.isWellFormed` 和 `String.prototype.toWellFormed` 方法。</p>
  <p>ECMAScript 2025，第 16 版，新增了带有相关静态方法和原型方法的全局 `Iterator`，用于迭代器操作；为 `Set.prototype` 增加了常用集合操作方法；支持导入 JSON 模块，以及声明导入模块属性的语法；新增了用于安全处理字符串的 `RegExp.escape` 方法；支持在正则表达式中内联启用和禁用修饰符标志的语法；新增了用于处理可能返回 Promise 或非 Promise 的函数并确保返回值始终是 Promise 的 `Promise.try` 方法；并新增了新的 `Float16Array` 类型数组及相关的 `DataView.prototype.getFloat16`、`DataView.prototype.setFloat16` 和 `Math.f16round` 方法。</p>
  <p>有数十位代表众多机构的个人在 Ecma TC39 中为本版及以往版本的开发做出了重要贡献。此外，支持 TC39 ECMAScript 工作的社区也日益活跃。该社区审查了大量草案，提交了成千上万个错误报告，进行了实现实验，贡献了测试套件，并向全球开发者介绍 ECMAScript。遗憾的是，无法逐一列举和感谢每一位做出贡献的个人和机构。</p>
  <p>
    Allen Wirfs-Brock<br>
    ECMA-262，第 6 版项目编辑
  </p>
  <p>
    Brian Terlson<br>
    ECMA-262，第 7–10 版项目编辑
  </p>
  <p>
    Jordan Harband<br>
    ECMA-262，第 10–12 版项目编辑
  </p>
  <p>
    Shu-yu Guo<br>
    ECMA-262，第 12–16 版项目编辑
  </p>
  <p>
    Michael Ficarra<br>
    ECMA-262，第 12–16 版项目编辑
  </p>
  <p>
    Kevin Gibbons<br>
    ECMA-262，第 12–16 版项目编辑
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>范围</h1>
  <p>本标准定义了 ECMAScript 2026 通用编程语言。</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>一致性</h1>
  <p>符合规范的 ECMAScript 实现必须提供并支持本规范中描述的所有类型、值、对象、属性、函数，以及程序的语法和语义。</p>
  <p>符合规范的 ECMAScript 实现必须按照最新版 Unicode 标准和 ISO/IEC 10646 的要求解释源文本输入。</p>
  <p>符合规范的 ECMAScript 实现如果提供支持不同语言和国家的语言习惯和文化规范的应用程序编程接口（API），则必须实现与本规范兼容的最新版 ECMA-402 所定义的接口。</p>
  <p>符合规范的 ECMAScript 实现可以提供本规范未描述的其他类型、值、对象、属性和函数。特别地，符合规范的 ECMAScript 实现可以为本规范所描述的对象提供未在本规范中描述的属性，以及这些属性的值。</p>
  <p>符合规范的 ECMAScript 实现可以支持本规范未描述的程序和正则表达式语法。特别地，符合规范的 ECMAScript 实现可以支持使用本规范 <emu-xref href="#sec-keywords-and-reserved-words"></emu-xref> 分条中所述任何“未来保留字”的程序语法。</p>
  <p>符合规范的 ECMAScript 实现不得实现本规范 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 分条中列为禁止扩展的任何扩展。</p>
  <p>符合规范的 ECMAScript 实现不得重新定义任何非实现自定义、非近似实现或非宿主自定义的机制。</p>
  <p>符合规范的 ECMAScript 实现可以选择实现或不实现 <dfn>规范性可选</dfn> 子条款，除非另有说明。通常情况下，网页浏览器要求实现所有规范性可选子条款。（参见附录 <emu-xref href="#sec-additional-ecmascript-features-for-web-browsers"></emu-xref>。）如果实现了任何规范性可选行为，则必须实现包含该行为的所有规范性可选条款。规范性可选条款在本规范中以彩色框显示“规范性可选”字样，如下所示。</p>

  <emu-clause id="sec-conformance-normative-optional" oldids="sec-conformance.normative-optional" example normative-optional>
    <h1>规范性可选条款标题示例</h1>
    <p>条款内容示例。</p>
  </emu-clause>
  <p>符合规范的 ECMAScript 实现必须实现 <dfn>遗留</dfn> 子条款，除非它们也被标记为规范性可选。遗留子条款中指定的所有语言特性和行为都具有一个或多个不理想的特性，但由于现有应用仍在使用，无法从规范中移除这些特性。这些特性不属于 ECMAScript 语言核心。编程人员在编写新的 ECMAScript 代码时不应使用或假定这些特性和行为的存在。</p>

  <emu-clause id="sec-conformance-legacy" example legacy>
    <h1>遗留条款标题示例</h1>
    <p>条款内容示例。</p>
  </emu-clause>

  <emu-clause id="sec-conformance-legacy-normative-optional" example legacy normative-optional>
    <h1>遗留规范性可选条款标题示例</h1>
    <p>条款内容示例。</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>规范性引用文件</h1>
  <p>下列引用文件对于本文件的应用是不可或缺的。对于有日期的引用，仅适用于所引用的版本；对于无日期的引用，适用于引用文件的最新版本（包括任何修订）。</p>
  <p>IEEE 754-2019，《浮点数运算标准》。</p>
  <p>
    Unicode 标准。<br>
    <a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>
  </p>
  <p>ISO/IEC 10646，《信息技术——通用多字节编码字符集（UCS）》，包括修订1:2005、修订2:2006、修订3:2008、修订4:2008，以及更多修订和勘误，或后续版本。</p>
  <p>
    ECMA-402，《ECMAScript 国际化 API 规范》，特别是与本规范版本相对应的年度版本。<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-402/">https://www.ecma-international.org/publications-and-standards/standards/ecma-402/</a>
  </p>
  <p>
    ECMA-404，《JSON 数据交换格式》。<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>
  </p>
</emu-clause>

<emu-clause id="sec-overview">
  <h1>概述</h1>
  <p>本节包含 ECMAScript 语言的非规范性概述。</p>
  <p>ECMAScript 是一种面向对象的编程语言，用于在宿主环境中进行计算和操作计算对象。本规范中的 ECMAScript 并不旨在具备完全自给自足的计算能力；实际上，本规范未为外部数据输入或计算结果输出提供规定。而是预期 ECMAScript 程序的计算环境不仅提供本规范描述的对象和其他机制，还提供某些特定于环境的对象，其描述和行为超出本规范范围，仅说明它们可以提供可访问的属性和可从 ECMAScript 程序调用的函数。</p>
  <p>ECMAScript 最初设计为脚本语言，但现已广泛用作通用编程语言。<em>脚本语言</em>是用于操作、定制和自动化现有系统功能的编程语言。在此类系统中，实用功能通常通过用户界面提供，脚本语言则是让程序能够控制这些功能的机制。这样，现有系统就提供了对象和机制组成的宿主环境，补足了脚本语言的能力。脚本语言面向专业和非专业程序员。</p>
  <p>ECMAScript 最初设计为<em>Web 脚本语言</em>，用于在浏览器中为 Web 页面赋予动态行为，并在基于 Web 的客户端-服务器架构中执行服务器端计算。如今，ECMAScript 被用于为多种宿主环境提供核心脚本能力。因此，核心语言在本文件中独立于任何特定宿主环境进行描述。</p>
  <p>ECMAScript 的使用已超越简单脚本，现在在许多环境和规模下用于各类编程任务。随着 ECMAScript 应用范围的扩大，其所提供的特性和机制也不断丰富。ECMAScript 现已成为功能完备的通用编程语言。</p>

  <emu-clause id="sec-web-scripting">
    <h1>Web 脚本</h1>
    <p>网页浏览器为客户端计算提供 ECMAScript 宿主环境，例如用于表示窗口、菜单、弹窗、对话框、文本区域、锚点、框架、历史、Cookie 和输入/输出的对象。此外，宿主环境提供了将脚本代码绑定到事件的方法，如焦点变化、页面和图片加载、卸载、错误和中断、选择、表单提交和鼠标操作。脚本代码出现在 HTML 内，显示的页面是用户界面元素与固定及计算文本和图片的结合。脚本代码响应用户交互，无需主程序。</p>
    <p>Web 服务器则为服务端计算提供不同的宿主环境，包括用于表示请求、客户端和文件的对象，以及锁定与共享数据的机制。通过结合浏览器端和服务器端脚本，可以在客户端和服务器间分布计算，同时为 Web 应用提供定制化用户界面。</p>
    <p>支持 ECMAScript 的每个 Web 浏览器和服务器都提供自己的宿主环境，完善了 ECMAScript 的执行环境。</p>
  </emu-clause>

  <emu-clause id="sec-hosts-and-implementations">
    <h1>宿主和实现</h1>
    <p>为便于将 ECMAScript 集成到宿主环境中，本规范将某些机制（如抽象操作）全部或部分定义留给规范外部的来源。本规范在编辑上区分如下几种委托方式。</p>
    <p><em id="implementation">实现</em>指的是进一步定义附件 <emu-xref href="#sec-host-layering-points"></emu-xref> 列举的机制，或被标记为实现自定义或实现近似的机制的外部来源。在非正式用法中，实现通常指某个具体产物，如某个网页浏览器。</p>
    <p><dfn id="implementation-defined">实现自定义</dfn>指将某个机制的定义无附加限定地委托给外部来源。本规范未对具体行为做任何建议，符合规范的实现可在规范约束范围内自由选择行为。</p>
    <p><dfn id="implementation-approximated">实现近似</dfn>指将某个机制的定义委托给外部来源，同时建议理想行为。符合规范的实现可在规范约束范围内自由选择行为，但鼓励尽量接近理想。例如部分数学操作，如 <emu-xref href="#sec-math.exp"><code>Math.exp</code></emu-xref>，采用实现近似方式。</p>
    <p><dfn id="host" variants="hosts">宿主</dfn>指进一步定义附件 <emu-xref href="#sec-host-layering-points"></emu-xref> 所列机制，但不进一步定义其他实现自定义或近似机制的外部来源。在非正式用法中，宿主指以相同方式通过附件 <emu-xref href="#sec-host-layering-points"></emu-xref> 与本规范接口的所有实现集合，如所有网页浏览器。宿主通常是外部规范，如 WHATWG HTML（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）。换句话说，宿主自定义机制常在外部规范中进一步定义。</p>
    <p><dfn id="host-hook" variants="host hooks">宿主钩子</dfn>是由外部来源全部或部分定义的抽象操作。所有宿主钩子须列于附件 <emu-xref href="#sec-host-layering-points"></emu-xref>。宿主钩子须至少满足以下要求：</p>
    <ul>
      <li>必须返回正常完成或抛出完成。</li>
    </ul>
    <p><dfn id="host-defined">宿主自定义</dfn>指无附加限定地将机制定义委托给外部来源，并列于附件 <emu-xref href="#sec-host-layering-points"></emu-xref>。非宿主的实现也可为宿主自定义机制提供定义。</p>
    <p><dfn id="host-environment" variants="host environments">宿主环境</dfn>指对所有宿主自定义机制的具体定义选择。宿主环境通常包括一些对象或函数，通过全局对象的宿主自定义属性实现输入输出。</p>
    <p>本规范在编辑上始终采用最具体术语。例如，如果某机制为宿主自定义，不应称其为实现自定义。</p>
    <p>宿主和实现都可通过本规范定义的语言类型、规范类型、抽象操作、语法产生式、内在对象和内在符号与本规范接口。</p>
  </emu-clause>

  <emu-clause id="sec-ecmascript-overview">
    <h1>ECMAScript 概览</h1>
    <p>以下是 ECMAScript 的非正式概览，未描述语言的所有部分。本概览不是标准正文的一部分。</p>
    <p>ECMAScript 是基于对象的：基本语言机制和宿主机制由对象提供，ECMAScript 程序是一组相互通信的对象。在 ECMAScript 中，<em>对象</em>是包含零个或多个<em>属性</em>的集合，每个属性具有<em>特性</em>，这些特性决定属性的使用方式——例如，当属性的 Writable 特性为 *false* 时，任何 ECMAScript 代码尝试为该属性赋新值都将失败。属性是用来保存其他对象、<em>原始值</em>或<em>函数</em>的容器。原始值属于以下内建类型之一：<b>Undefined</b>、<b>Null</b>、<b>Boolean</b>、<b>Number</b>、<b>BigInt</b>、<b>String</b> 和 <b>Symbol</b>；对象属于内建类型 <b>Object</b>；函数是可调用的对象。通过属性与对象关联的函数称为<em>方法</em>。</p>
    <p>ECMAScript 定义了一组<em>内建对象</em>，补充了 ECMAScript 实体的定义。这些内建对象包括全局对象；与语言运行时语义密切相关的对象，如 `Object`、`Function`、`Boolean`、`Symbol` 及各类 `Error` 对象；用于表示和操作数值的对象，如 `Math`、`Number` 和 `Date`；用于文本处理的对象 `String` 和 `RegExp`；用于值索引集合的对象，如 `Array` 以及具有特定数值表示的九种 Typed Array；用于键值集合的 `Map` 和 `Set`；用于结构化数据的对象，如 `JSON`、`ArrayBuffer`、`SharedArrayBuffer` 和 `DataView`；用于控制抽象的对象，如生成器函数和 `Promise`；以及用于反射的对象，如 `Proxy` 和 `Reflect`。</p>
    <p>ECMAScript 还定义了一组内建<em>运算符</em>。ECMAScript 运算符包括各类一元运算、乘法运算、加法运算、位移运算、关系运算、相等运算、二元位运算、二元逻辑运算、赋值运算和逗号运算。</p>
    <p>大型 ECMAScript 程序通过<em>模块</em>得到支持，允许将程序划分为多个语句和声明序列。每个模块明确标识需要由其他模块提供的声明，以及哪些声明可供其他模块使用。</p>
    <p>ECMAScript 的语法有意与 Java 语法相似。ECMAScript 的语法较为宽松，便于其作为易用的脚本语言。例如，变量无需声明类型，属性也无类型约束，定义的函数无需在调用前出现在文本中。</p>

    <emu-clause id="sec-objects">
      <h1>对象</h1>
      <p>尽管 ECMAScript 包含类定义语法，但 ECMAScript 对象本质上不是 C++、Smalltalk 或 Java 那样的类基础对象。对象可以通过多种方式创建，包括字面量方式或通过<em>构造函数</em>创建对象并执行初始化代码为属性赋初值。每个构造函数都是一个函数，拥有名为 *"prototype"* 的属性，用于实现<em>基于原型的继承</em>和<em>共享属性</em>。对象可通过 <b>new</b> 表达式使用构造函数创建，例如 `new Date(2009, 11)` 创建一个新的 Date 对象。直接调用构造函数而不使用 <b>new</b> 的行为取决于构造函数，例如 `Date()` 返回当前日期和时间的字符串而不是对象。</p>
      <p>每个由构造函数创建的对象都隐式引用（称为对象的<em>原型</em>）其构造函数的 *"prototype"* 属性。此外，原型还可以非 *null* 地隐式引用其原型，依此类推；这被称为<em>原型链</em>。访问对象属性时，查找的是原型链中第一个包含该属性的对象。即，首先检查直接引用的对象是否有该属性，若有则访问该属性，若无则检查该对象的原型，依此类推。</p>
      <emu-figure id="figure-1" caption="对象/原型关系">
        <img alt="一个包含许多方框和箭头的图示。" height="354" src="https://tc39.es/ecma262/img/figure-1.svg" width="719">
      </emu-figure>
      <p>在基于类的面向对象语言中，状态通常由实例承载，方法由类承载，继承仅限结构和行为。而在 ECMAScript 中，状态和方法都由对象承载，结构、行为和状态都可继承。</p>
      <p>所有未直接拥有其原型属性的对象共享该属性及其值。图1对此进行了说明：</p>
      <p><b>CF</b> 是一个构造函数（也是一个对象）。通过 `new` 表达式创建了五个对象：<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 和 <b>cf<sub>5</sub></b>。每个对象都包含名为 *"q1"* 和 *"q2"* 的属性。虚线表示隐式原型关系；例如，<b>cf<sub>3</sub></b> 的原型是 <b>CF<sub>p</sub></b>。构造函数 <b>CF</b> 自身有两个属性，分别为 *"P1"* 和 *"P2"*，这些属性对 <b>CF<sub>p</sub></b>、<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 或 <b>cf<sub>5</sub></b> 不可见。<b>CF<sub>p</sub></b> 的 *"CFP1"* 属性被 <b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 和 <b>cf<sub>5</sub></b> 共享（但不包括 <b>CF</b>），以及 <b>CF<sub>p</sub></b> 的隐式原型链上除 *"q1"*、*"q2"* 和 *"CFP1"* 外的所有属性。注意 <b>CF</b> 和 <b>CF<sub>p</sub></b> 之间没有隐式原型链接。</p>
      <p>与多数基于类的对象语言不同，可以通过为对象赋值动态添加属性。即，构造函数无需为所有或任何构造对象的属性命名或赋值。在上述图示中，可以通过为 <b>CF<sub>p</sub></b> 属性赋新值，为 <b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 和 <b>cf<sub>5</sub></b> 新增共享属性。</p>
      <p>虽然 ECMAScript 对象本质上不是类基础，但基于通用的构造函数、原型对象和方法模式定义类式抽象通常很方便。ECMAScript 的内建对象本身也遵循此类模式。从 ECMAScript 2015 起，ECMAScript 语言包含类定义语法，允许程序员简洁地定义符合内建对象所用类式抽象模式的对象。</p>
    </emu-clause>

    <emu-clause id="sec-strict-variant-of-ecmascript">
      <h1>ECMAScript 的严格模式变体</h1>
      <p>ECMAScript 语言考虑到部分用户可能希望限制语言中的某些特性使用。这样做可能出于安全考虑、避免易出错特性、获得更强的错误检查或其他原因。为此，ECMAScript 定义了语言的严格模式变体。严格模式变体排除了常规 ECMAScript 语言中的部分特定语法和语义特性，并对部分特性进行了详细语义修改。严格模式还规定了在非严格模式下不视为错误的情况下必须抛出错误异常的额外错误条件。</p>
      <p>ECMAScript 的严格模式变体通常被称为语言的<em>严格模式</em>。严格模式的选择及语法和语义的使用在单个 ECMAScript 源文本单元级进行，如 <emu-xref href="#sec-strict-mode-code"></emu-xref> 所述。由于严格模式在语法源文本单元级选择，严格模式仅在该单元内产生局部影响。严格模式不会限制或修改必须跨多个源文本单元一致运行的 ECMAScript 语义。完整的 ECMAScript 程序可以包含严格模式和非严格模式的源文本单元。此时，严格模式仅在实际执行定义于严格模式源文本单元的代码时生效。</p>
      <p>为符合本规范，ECMAScript 实现必须实现本规范定义的完整的非受限 ECMAScript 语言和严格模式变体，并支持将非受限和严格模式源文本单元组合为单一复合程序。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-terms-and-definitions">
    <h1>术语和定义</h1>
    <p>本文件的目的所涉及的术语和定义如下。</p>

    <emu-clause id="sec-terms-and-definitions-implementation-approximated">
      <h1>实现近似</h1>
      <p>实现近似机制由外部来源全部或部分定义，但本规范推荐理想行为</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-implementation-defined">
      <h1>实现自定义</h1>
      <p>实现自定义机制由外部来源全部或部分定义</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-host-defined">
      <h1>宿主自定义</h1>
      <p>同实现自定义</p>
      <emu-note>
        <p>编辑说明，见 <emu-xref href="#sec-hosts-and-implementations"></emu-xref> 条款。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-type">
      <h1>类型</h1>
      <p>如 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 条款所定义的数据值集合</p>
    </emu-clause>

    <emu-clause id="sec-primitive-value">
      <h1>原始值</h1>
      <p>属于 Undefined、Null、Boolean、Number、BigInt、Symbol 或 String 类型之一，如 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 条款所定义</p>
      <emu-note>
        <p>原始值是由语言实现直接在最低层级表示的数据项。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-object">
      <h1>对象</h1>
      <p>属于 Object 类型的成员</p>
      <emu-note>
        <p>对象是属性集合，并且有唯一的原型对象。原型可以为 *null*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-constructor">
      <h1>构造函数</h1>
      <p>用于创建和初始化对象的函数对象</p>
      <emu-note>
        <p>构造函数的 *"prototype"* 属性值是实现继承和共享属性所用的原型对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-prototype">
      <h1>原型</h1>
      <p>为其他对象提供共享属性的对象</p>
      <emu-note>
        <p>构造函数创建对象时，该对象隐式引用构造函数的 *"prototype"* 属性以解析属性引用。构造函数的 *"prototype"* 属性可通过程序表达式 <code><var>constructor</var>.prototype</code> 访问，向原型添加属性，通过继承，所有共享该原型的对象都可访问这些属性。或者，可以通过 `Object.create` 内建函数创建具有指定原型的新对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinary-object">
      <h1>普通对象</h1>
      <p>具有所有对象必须支持的基本内部方法默认行为的对象</p>
    </emu-clause>

    <emu-clause id="sec-exotic-object">
      <h1>特殊对象</h1>
      <p>在一个或多个基本内部方法上不具有默认行为的对象</p>
      <emu-note>
        <p>任何非普通对象都是特殊对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-standard-object">
      <h1>标准对象</h1>
      <p>其语义由本规范定义的对象</p>
    </emu-clause>

    <emu-clause id="sec-built-in-object">
      <h1>内建对象</h1>
      <p>由 ECMAScript 实现指定并提供的对象</p>
      <emu-note>
        <p>标准内建对象由本规范定义。ECMAScript 实现可以指定和提供其他类型的内建对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-undefined-value">
      <h1>undefined 值</h1>
      <p>在变量未赋值时使用的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-undefined-type">
      <h1>Undefined 类型</h1>
      <p>其唯一值为 *undefined* 的类型</p>
    </emu-clause>

    <emu-clause id="sec-null-value">
      <h1>null 值</h1>
      <p>表示有意无对象值的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-null-type">
      <h1>Null 类型</h1>
      <p>其唯一值为 *null* 的类型</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-value">
      <h1>Boolean 值</h1>
      <p>属于 Boolean 类型的成员</p>
      <emu-note>
        <p>只有两个 Boolean 值，*true* 和 *false*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-type">
      <h1>Boolean 类型</h1>
      <p>由原始值 *true* 和 *false* 组成的类型</p>
    </emu-clause>

    <emu-clause id="sec-boolean-object">
      <h1>Boolean 对象</h1>
      <p>属于 Object 类型且为标准内建 Boolean 构造函数实例的成员</p>
      <emu-note>
        <p>Boolean 对象通过在 `new` 表达式中使用 Boolean 构造函数并传递 Boolean 值参数创建。生成的对象有一个内部插槽，值为 Boolean 值。Boolean 对象可被强制转换为 Boolean 值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-value">
      <h1>String 值</h1>
      <p>为有限有序的零个或多个 16 位无符号整数值序列的原始值</p>
      <emu-note>
        <p>String 值属于 String 类型。序列中的每个整数值通常表示一个 UTF-16 文本的 16 位单元。但 ECMAScript 不对这些值做任何限制或要求，仅要求其为 16 位无符号整数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-type">
      <h1>String 类型</h1>
      <p>所有可能的 String 值的集合</p>
    </emu-clause>

    <emu-clause id="sec-string-object">
      <h1>String 对象</h1>
      <p>属于 Object 类型且为标准内建 String 构造函数实例的成员</p>
      <emu-note>
        <p>String 对象通过在 `new` 表达式中使用 String 构造函数并传递 String 值参数创建。生成的对象有一个内部插槽，值为 String 值。String 对象可通过将 String 构造函数作为函数调用（<emu-xref href="#sec-string-constructor-string-value"></emu-xref>）被强制转换为 String 值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-value">
      <h1>Number 值</h1>
      <p>与双精度 64 位二进制格式 IEEE 754-2019 值对应的原始值</p>
      <emu-note>
        <p>Number 值属于 Number 类型，是数字的直接表示。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-type">
      <h1>Number 类型</h1>
      <p>所有可能的 Number 值集合，包括 *NaN*（非数字）、*+∞*<sub>𝔽</sub>（正无穷）、*-∞*<sub>𝔽</sub>（负无穷）</p>
    </emu-clause>

    <emu-clause id="sec-number-object">
      <h1>Number 对象</h1>
      <p>属于 Object 类型且为标准内建 Number 构造函数实例的成员</p>
      <emu-note>
        <p>Number 对象通过在 `new` 表达式中使用 Number 构造函数并传递 Number 值参数创建。生成的对象有一个内部插槽，值为 Number 值。Number 对象可通过将 Number 构造函数作为函数调用（<emu-xref href="#sec-number-constructor-number-value"></emu-xref>）被强制转换为 Number 值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-infinity">
      <h1>Infinity</h1>
      <p>为正无穷值的 Number 值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-nan">
      <h1>NaN</h1>
      <p>为 IEEE 754-2019 NaN（非数字）值的 Number 值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-value">
      <h1>BigInt 值</h1>
      <p>对应于任意精度整数值的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-type">
      <h1>BigInt 类型</h1>
      <p>所有可能的 BigInt 值集合</p>
    </emu-clause>

    <emu-clause id="sec-bigint-object">
      <h1>BigInt 对象</h1>
      <p>属于 Object 类型且为标准内建 BigInt 构造函数实例的成员</p>
    </emu-clause>

    <emu-clause id="sec-symbol-value">
      <h1>Symbol 值</h1>
      <p>表示唯一、非 String 对象属性键的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-symbol-type">
      <h1>Symbol 类型</h1>
      <p>所有可能的 Symbol 值集合</p>
    </emu-clause>

    <emu-clause id="sec-symbol-object">
      <h1>Symbol 对象</h1>
      <p>属于 Object 类型且为标准内建 Symbol 构造函数实例的成员</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-function">
      <h1>函数</h1>
      <p>属于 Object 类型，可作为子程序调用的成员</p>
      <emu-note>
        <p>函数除具有属性外，还包含可执行代码和状态，决定调用时的行为。函数代码可能用 ECMAScript 编写，也可能不是。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function">
      <h1>内建函数</h1>
      <p>为函数的内建对象</p>
      <emu-note>
        <p>内建函数示例包括 `parseInt` 和 `Math.exp`。宿主或实现可提供未在本规范描述的其他内建函数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-constructor">
      <h1>内建构造函数</h1>
      <p>为构造函数的内建函数</p>
      <emu-note>
        <p>内建构造函数示例包括 `Object` 和 `Function`。宿主或实现可提供未在本规范描述的其他内建构造函数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-property">
      <h1>属性</h1>
      <p>对象的一部分，将键（String 值或 Symbol 值）与值关联</p>
      <emu-note>
        <p>根据属性形式，值可以直接表示为数据值（原始值、对象或函数对象），也可以通过一对访问器函数间接表示。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-method">
      <h1>方法</h1>
      <p>作为属性值的函数</p>
      <emu-note>
        <p>当函数作为对象的方法调用时，该对象作为 *this* 值传递给函数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-method">
      <h1>内建方法</h1>
      <p>为内建函数的方法</p>
      <emu-note>
        <p>标准内建方法由本规范定义。宿主或实现可提供未在本规范描述的其他内建方法。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-attribute">
      <h1>特性</h1>
      <p>定义属性某些特性的内部值</p>
    </emu-clause>

    <emu-clause id="sec-own-property">
      <h1>自身属性</h1>
      <p>直接由对象包含的属性</p>
    </emu-clause>

    <emu-clause id="sec-inherited-property">
      <h1>继承属性</h1>
      <p>不是对象自身属性但属于对象原型（自身或继承）的属性</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-organization-of-this-specification">
    <h1>本规范的结构</h1>
    <p>本规范余下内容组织如下：</p>
    <p><emu-xref href="#sec-notational-conventions"></emu-xref> 条款定义了贯穿规范的符号约定。</p>
    <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 至 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 条款定义了 ECMAScript 程序运行的执行环境。</p>
    <p><emu-xref href="#sec-ecmascript-language-source-code"></emu-xref> 至 <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 条款定义了实际的 ECMAScript 编程语言，包括语法编码和所有语言特性的执行语义。</p>
    <p><emu-xref href="#sec-ecmascript-standard-built-in-objects"></emu-xref> 至 <emu-xref href="#sec-reflection"></emu-xref> 条款定义了 ECMAScript 标准库，包含 ECMAScript 程序执行时可用的所有标准对象定义。</p>
    <p><emu-xref href="#sec-memory-model"></emu-xref> 条款描述了对 SharedArrayBuffer 支持的内存一致性模型以及 Atomics 对象的方法。</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>符号约定</h1>

  <emu-clause id="sec-syntactic-and-lexical-grammars">
    <h1>句法和词法文法</h1>

    <emu-clause id="sec-context-free-grammars">
      <h1>上下文无关文法</h1>
      <p><em>上下文无关文法</em>由若干<em>产生式</em>组成。每个产生式都有一个抽象符号，称为<em>非终结符</em>，作为其<em>左部</em>，以及由零个或多个非终结符和<em>终结符</em>组成的序列，作为其<em>右部</em>。对于每个文法，终结符来自指定的字母表。</p>
      <p><dfn variants="chain productions">链式产生式</dfn>是指其右部恰好只有一个非终结符和零个或多个终结符的产生式。</p>
      <p>从一个仅包含单一特殊非终结符的句子开始，称为<dfn variants="goal symbols">目标符号</dfn>，给定的上下文无关文法定义了一个<em>语言</em>，即通过不断将序列中的任意非终结符替换为以该非终结符为左部的某个产生式的右部，最终可能得到的所有终结符序列的集合（可能是无限的）。</p>
    </emu-clause>

    <emu-clause id="sec-lexical-and-regexp-grammars">
      <h1>词法和正则表达式文法</h1>
      <p>ECMAScript 的<em>词法文法</em>见 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>。该文法的终结符是符合 <emu-xref href="#sec-source-text"></emu-xref> 中 |SourceCharacter| 规则的 Unicode 码点。它定义了一组产生式，从目标符号 |InputElementDiv|、|InputElementTemplateTail|、|InputElementRegExp|、|InputElementRegExpOrTemplateTail| 或 |InputElementHashbangOrRegExp| 开始，描述了这些码点序列如何转换为输入元素序列。</p>
      <p>除空白和注释外的输入元素构成 ECMAScript 句法文法的终结符，被称为 ECMAScript <em>标记</em>。这些标记包括 ECMAScript 语言的保留字、标识符、字面量和标点符号。此外，行终止符虽然不是标记，但也成为输入元素流的一部分，引导自动分号插入过程（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）。简单空白和单行注释会被丢弃，不会出现在句法文法的输入元素流中。|MultiLineComment|（即形如 `/*`…`*/` 的注释，无论是否跨越多行）如果不包含行终止符，则同样被丢弃；但若包含一个或多个行终止符，则被替换为一个单一行终止符，后者成为句法文法输入元素流的一部分。</p>
      <p>ECMAScript 的<em>正则表达式文法</em>见 <emu-xref href="#sec-patterns"></emu-xref>。该文法的终结符同样为 |SourceCharacter| 所定义的码点。它定义了一组产生式，从目标符号 |Pattern| 开始，描述了码点序列如何转换为正则表达式模式。</p>
      <p>词法和正则表达式文法的产生式以两个冒号“<b>::</b>”作为分隔标志。词法文法和正则表达式文法共享部分产生式。</p>
    </emu-clause>

    <emu-clause id="sec-numeric-string-grammar">
      <h1>数值字符串文法</h1>
      <p><em>数值字符串文法</em>见 <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>。其终结符为 |SourceCharacter|，用于将字符串从目标符号 |StringNumericLiteral| 开始转换为数值（与 <emu-xref href="#sec-literals-numeric-literals">数值字面量的词法文法</emu-xref> 类似但不同）。</p>
      <p>数值字符串文法的产生式以三个冒号“<b>:::</b>”为标点，并从不用于解析源文本。</p>
    </emu-clause>

    <emu-clause id="sec-syntactic-grammar">
      <h1>句法文法</h1>
      <p>ECMAScript 的<em>句法文法</em>见 <emu-xref href="#sec-ecmascript-language-expressions"></emu-xref> 到 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref>。该文法的终结符为词法文法定义的 ECMAScript 标记（<emu-xref href="#sec-lexical-and-regexp-grammars"></emu-xref>）。它定义了一组产生式，从两个备选目标符号 |Script| 和 |Module| 开始，描述了标记序列如何组成语法正确的 ECMAScript 程序独立组件。</p>
      <p>当要将码点流解析为 ECMAScript 的 |Script| 或 |Module| 时，首先通过反复应用词法文法，将其转换为输入元素流；然后该输入元素流通过一次句法文法解析。若输入元素流中的标记无法解析为一个目标非终结符（|Script| 或 |Module|）的实例，且没有剩余标记，则输入流存在语法错误。</p>
      <p>解析成功时会构建一个<em>解析树</em>，即以根为起点的树结构，每个节点为一个<dfn variants="Parse Nodes">解析节点</dfn>。每个解析节点是文法符号的一个<em>实例</em>，表示可由该符号导出的源文本片段。解析树的根节点，代表整个源文本，是解析目标符号的一个实例。当解析节点是非终结符的实例时，也是以该非终结符为左部的某个产生式的实例。此外，它有零个或多个<em>子节点</em>，每个对应产生式右部的一个符号：每个子节点是相应符号的解析节点实例。</p>
      <p>每次解析器调用都会实例化新的解析节点，即使解析的源文本完全相同，解析节点也不会复用。只有当解析节点代表同一源文本片段、是同一文法符号的实例且来源于同一次解析器调用时，才认为它们<dfn>是同一个解析节点</dfn>。</p>
      <emu-note>
        <p>多次解析同一个字符串会得到不同的解析节点。例如：</p>
        <pre><code class="javascript">
          let str = "1 + 1;";
          eval(str);
          eval(str);
        </code></pre>
        <p>每次调用 `eval` 都会将 `str` 的值转换为 ECMAScript 源文本，并进行独立解析，生成各自独立的解析节点树。即使每次解析的源文本都来自同一个字符串值，树结构也是不同的。</p>
      </emu-note>
      <emu-note>解析节点是规范中的抽象实体，具体实现无需采用类似的数据结构。</emu-note>
      <p>句法文法的产生式以单个冒号“<b>:</b>”作为标点。</p>
      <p>在 <emu-xref href="#sec-ecmascript-language-expressions"></emu-xref> 到 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref> 条款中呈现的句法文法并未完全覆盖所有可作为正确 ECMAScript |Script| 或 |Module| 被接受的标记序列。额外接受的标记序列包括那些仅需在某些位置（如行终止符前）添加分号即可被文法描述的序列。此外，某些文法描述的标记序列若在某些“特殊”位置出现行终止符，则不被接受。</p>
      <p>为避免歧义，句法文法在某些情况下使用了广义产生式，允许不形成有效 ECMAScript |Script| 或 |Module| 的标记序列。例如，对象字面量和对象解构模式采用此技术。在这些情况下，会提供更严格的<em>补充文法</em>以进一步限制可接受的标记序列。一般情况下，早期错误规则会规定，在某些上下文中，“_P_ <dfn id="must-cover">必须覆盖</dfn> _N_”，其中 _P_ 是解析节点（广义产生式的实例），_N_ 是补充文法中的非终结符。这表示：</p>
      <ol>
        <li>对 _P_ 最初匹配的标记序列，以 _N_ 作为目标符号再次解析。如果 _N_ 有文法参数，则使用 _P_ 最初解析时的参数值。</li>
        <li>如果标记序列能作为 _N_ 的唯一实例解析，且无剩余标记，则：
          <ol>
            <li>我们称该实例（唯一对应于某个 _P_ 的解析节点）为“_P_ 所<dfn>覆盖</dfn>的 _N_”。</li>
            <li>所有对 _N_ 及其派生产生式的早期错误规则也适用于 _P_ 所覆盖的 _N_。</li>
          </ol>
        </li>
        <li>否则（解析失败），则为早期语法错误。</li>
      </ol>
    </emu-clause>

    <emu-clause id="sec-grammar-notation" namespace="grammar-notation">
      <h1>文法记号</h1>

      <emu-clause id="sec-terminal-symbols">
        <h1>终结符号</h1>
        <p>在 ECMAScript 文法中，部分终结符以 `等宽字体` 展示。这些符号应在源文本中完全按原样出现。此类终结符指定的所有码点均应理解为基本拉丁区（Basic Latin block）中对应的 Unicode 码点，不包括其他 Unicode 区段中外观相似的码点。终结符中的码点不能用 `\\` |UnicodeEscapeSequence| 表示。</p>
        <p>在以单个 Unicode 码点为终结符的文法（即词法、正则和数值字符串文法）中，产生式中连续出现的多个等宽码点是一种简写，表示同样顺序的独立终结符。</p>
        <p>例如如下产生式：</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0x` HexDigits
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0` `x` HexDigits
        </emu-grammar>
        <p>而在句法文法中，连续的等宽码点则视为单一终结符。</p>
        <p>终结符还可以有两种形式：</p>
        <ul>
          <li>在词法和正则文法中，无传统印刷表示的 Unicode 码点以“&lt;ABBREV>”形式展示，其中“ABBREV”是该码点或码点集的助记符。这些形式在 <emu-xref href="#sec-unicode-format-control-characters" title></emu-xref>、<emu-xref href="#sec-white-space" title></emu-xref> 和 <emu-xref href="#sec-line-terminators" title></emu-xref> 中定义。</li>
          <li>在句法文法中，某些终结符（如 |IdentifierName| 和 |RegularExpressionLiteral|）以斜体显示，表示它们引用词法文法中同名非终结符。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-nonterminal-symbols-and-productions">
        <h1>非终结符号和产生式</h1>
        <p>非终结符以<i>斜体</i>展示。非终结符的定义（也称“产生式”）由被定义的非终结符名称后跟一个或多个冒号引出。（冒号数量表明该产生式属于哪种文法。）随后为该非终结符的一个或多个备选右部。例如，句法定义：</p>
        <emu-grammar type="definition" example>
          WhileStatement :
            `while` `(` Expression `)` Statement
        </emu-grammar>
        <p>说明非终结符 |WhileStatement| 表示标记 `while`，后跟左括号标记，再跟 |Expression|，再跟右括号标记，最后跟 |Statement|。其中 |Expression| 和 |Statement| 本身也是非终结符。另一个例子，句法定义：</p>
        <emu-grammar type="definition" example>
          ArgumentList :
            AssignmentExpression
            ArgumentList `,` AssignmentExpression
        </emu-grammar>
        <p>说明 |ArgumentList| 可以表示单个 |AssignmentExpression|，或 |ArgumentList| 后跟逗号，再跟 |AssignmentExpression|。该定义是递归的，即用自身定义自身。因此 |ArgumentList| 可包含任意数量且大于零的参数，每个参数表达式为 |AssignmentExpression|，参数间以逗号分隔。此类递归定义很常见。</p>
      </emu-clause>

      <emu-clause id="sec-optional-symbols">
        <h1>可选符号</h1>
        <p>下标后缀“<sub>opt</sub>”用于终结符或非终结符之后，表示该符号为可选。包含可选符号的备选实际上指定了两个右部：一个省略可选元素，一个包含可选元素。即：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer?
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer
        </emu-grammar>
        <p>同理：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression? `)` Statement
        </emu-grammar>
        <p>进一步简写为：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` `)` Statement
            `for` `(` LexicalDeclaration `;` Expression `)` Statement
            `for` `(` LexicalDeclaration Expression `;` `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
        </emu-grammar>
        <p>所以在此例中，非终结符 |ForStatement| 实际有四个备选右部。</p>
      </emu-clause>

      <emu-clause id="sec-grammatical-parameters">
        <h1>文法参数</h1>
        <p>产生式可以通过下标标注“<sub>[参数]</sub>”进行参数化，该标注可作为产生式定义的非终结符后缀。“<sub>参数</sub>”可以是单个名称或以逗号分隔的名称列表。参数化产生式是对一组产生式的简写，定义了所有参数名称组合，组合名以下划线为前缀，附加到参数化非终结符后。即：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>同理：</p>
        <emu-grammar type="definition" example>
          StatementList[Return, In] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement

          StatementList_In :
            ReturnStatement
            ExpressionStatement

          StatementList_Return_In :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>多个参数会生成组合数量的产生式，但完整文法中并不一定全部引用。</p>
        <p>产生式右部对非终结符的引用也可以参数化。例如：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[+In]
        </emu-grammar>
        <p>等价于：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement_In
        </emu-grammar>
        <p>而：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[~In]
        </emu-grammar>
        <p>等价于：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>非终结符引用可以同时有参数列表和“<sub>opt</sub>”后缀。例如：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer[+In]?
        </emu-grammar>
        <p>简写为：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>在右部非终结符引用上用“<sub>?</sub>”作为参数名前缀，使该参数取值依赖于当前产生式左部符号引用是否出现该参数。例如：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration[In] :
            BindingIdentifier Initializer[?In]
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer

          VariableDeclaration_In :
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>如果右部备选以“[+参数]”为前缀，表示仅当引用产生式非终结符时使用了该参数名才可用该备选。如果以“[\~参数]”为前缀，则仅在未使用该参数名时可用该备选。即：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [+Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>简写为：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>同理：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [~Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>简写为：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ExpressionStatement
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-one-of">
        <h1>one of</h1>
        <p>当“<b>one of</b>”出现在文法定义中的冒号后，表示后续每个终结符都是一个备选定义。例如 ECMAScript 的词法文法包含如下产生式：</p>
        <emu-grammar type="definition" example>
          NonZeroDigit :: one of
            `1` `2` `3` `4` `5` `6` `7` `8` `9`
        </emu-grammar>
        <p>实际上是如下简写：</p>
        <emu-grammar type="definition" example>
          NonZeroDigit ::
            `1`
            `2`
            `3`
            `4`
            `5`
            `6`
            `7`
            `8`
            `9`
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-empty">
        <h1>[empty]</h1>
        <p>如果“[empty]”出现在产生式右部，表示该产生式右部不包含任何终结符或非终结符。</p>
      </emu-clause>

      <emu-clause id="sec-lookahead-restrictions">
        <h1>前瞻限制</h1>
        <p>若“[lookahead = _seq_]”出现在产生式右部，表示只有当标记序列 _seq_ 是紧跟输入标记序列的前缀时，才能使用该产生式。同理，“[lookahead ∈ _set_]”，其中 _set_ 为有限非空标记序列集合，表示只有当集合中的某个元素是紧跟输入标记序列的前缀时才能使用该产生式。为了方便，也可以将集合写为非终结符，此时表示该非终结符可能扩展到的所有标记序列。若非终结符能扩展为无限多种不同标记序列，则视为编辑错误。</p>
        <p>这些条件可以取反。“[lookahead ≠ _seq_]”表示只有当 _seq_ <em>不是</em>紧跟输入标记序列的前缀时才能使用该产生式，而“[lookahead ∉ _set_]”表示只有当集合中无元素是紧跟输入标记序列的前缀时才能使用该产生式。</p>
        <p>例如，给定如下定义：</p>
        <emu-grammar type="definition" example>
          DecimalDigit :: one of
            `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

          DecimalDigits ::
            DecimalDigit
            DecimalDigits DecimalDigit
        </emu-grammar>
        <p>则如下定义：</p>
        <emu-grammar type="definition" example>
          LookaheadExample ::
            `n` [lookahead &notin; { `1`, `3`, `5`, `7`, `9` }] DecimalDigits
            DecimalDigit [lookahead &notin; DecimalDigit]
        </emu-grammar>
        <p>匹配字符 `n` 后跟一个或多个十进制数字，且首位为偶数，或匹配一个十进制数字且后面不再有十进制数字。</p>
        <p>注意，这些短语用于句法文法时，可能无法明确识别紧跟的标记序列，因为确定后续标记需要知道后续使用哪个词法目标符号。因此，在句法文法中使用这些短语时，若前缀标记序列 _seq_ 的词法目标符号选择会影响其是否作为结果标记序列前缀，则视为编辑错误。</p>
      </emu-clause>

      <emu-clause id="sec-no-lineterminator-here">
        <h1>[此处无 |LineTerminator|]</h1>
        <p>若“[no |LineTerminator| here]”出现在句法文法产生式右部，表示该产生式为<em>受限产生式</em>：若在指定位置的输入流中出现 |LineTerminator|，则不能使用该产生式。例如如下产生式：</p>
        <emu-grammar type="definition" example>
          ThrowStatement :
            `throw` [no LineTerminator here] Expression `;`
        </emu-grammar>
        <p>表示若在脚本中的 `throw` 标记和 |Expression| 之间出现 |LineTerminator|，则不能使用该产生式。</p>
        <p>除非受限产生式禁止出现 |LineTerminator|，否则在输入元素流的任意两个连续标记之间可以出现任意数量的 |LineTerminator|，不会影响脚本的语法合法性。</p>
      </emu-clause>

      <emu-clause id="sec-but-not">
        <h1>but not</h1>
        <p>产生式右部可用“<b>but not</b>”短语指定某些扩展不允许。例如如下产生式：</p>
        <emu-grammar type="definition" example>
          Identifier ::
            IdentifierName but not ReservedWord
        </emu-grammar>
        <p>表示非终结符 |Identifier| 可替换为可替换 |IdentifierName| 的任何码点序列，但不能替换为可替换 |ReservedWord| 的同一序列。</p>
      </emu-clause>

      <emu-clause id="sec-descriptive-phrases">
        <h1>描述性短语</h1>
        <p>最后，少数非终结符用无衬线字体描述性短语来说明，当枚举所有备选项不切实际时使用：</p>
        <emu-grammar type="definition" example>
          SourceCharacter ::
            &gt; 任意 Unicode 码点
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-algorithm-conventions">
    <h1>算法约定</h1>
    <p>规范经常使用编号列表来指定算法步骤。这些算法用于精确定义 ECMAScript 语言结构所需的语义。算法并不意味着必须采用任何特定的实现技术。实际应用中，可能有更高效的算法可用于实现某个特性。</p>
    <p>算法可以显式使用有序、逗号分隔的别名序列进行参数化，在算法步骤中可以通过这些别名引用对应位置传入的参数。可选参数用括号（[ , _name_ ]）标记，在算法步骤中与必选参数没有区别。参数列表末尾可以出现剩余参数，用前置省略号（, ..._name_）标记。剩余参数会将所有必选和可选参数之后传入的参数收集到一个 List 中。如果没有额外参数，则该 List 为空。</p>
    <p>算法步骤可以细分为顺序子步骤。子步骤缩进显示，并且自身可以进一步划分为缩进子步骤。大纲编号用于标识子步骤：第一层使用小写字母，第二层使用小写罗马数字。如需超过三层，则第四层用数字编号。例如：</p>
    <emu-alg example>
      1. 顶层步骤
        1. 子步骤。
        1. 子步骤。
          1. 子子步骤。
            1. 子子子步骤
              1. 子子子子步骤
                1. 子子子子子步骤
    </emu-alg>
    <p>某个步骤或子步骤可以写成“if”条件，控制其子步骤。此时，只有条件为真时才执行子步骤。如果步骤或子步骤以“else”开头，则表示该条件是同级前一个“if”条件的否定。</p>
    <p>步骤可以指定对子步骤的迭代应用。</p>
    <p>以“<dfn id="assert">Assert</dfn>:”开头的步骤表示断言该算法的不变条件。这样的断言用于显式表达本应隐含的算法不变量，不增加语义要求，因此实现无需检查。它们仅用于澄清算法。</p>
    <p>算法步骤可以用“Let _x_ be _someValue_”声明命名别名。这些别名类似引用，即 _x_ 和 _someValue_ 都引用相同的数据，对任一的修改都可见。若算法步骤希望避免引用行为，应显式复制右侧值：“Let _x_ be a copy of _someValue_”会创建 _someValue_ 的浅复制。</p>
    <p>别名声明后可在后续步骤引用，但不可在声明前引用。别名可用“Set _x_ to _someOtherValue_”进行赋值。</p>

    <emu-clause id="sec-algorithm-conventions-abstract-operations">
      <h1>抽象操作</h1>
      <p>为便于在规范多个部分中使用，部分算法（称为<dfn>抽象操作</dfn>）采用命名并参数化的函数形式书写，以便在其他算法中通过名称引用。抽象操作通常以函数调用形式引用，如 OperationName(_arg1_, _arg2_)。有些抽象操作作为类似类的规范抽象的多态分派方法对待，这类方法通常以 _someValue_.OperationName(_arg1_, _arg2_) 形式引用。</p>
    </emu-clause>

    <emu-clause id="sec-algorithm-conventions-syntax-directed-operations">
      <h1>语法导向操作</h1>
      <p><dfn variants="syntax-directed operations">语法导向操作</dfn>是指以名称定义、由若干算法组成，并与 ECMAScript 某个文法中的一个或多个产生式关联的操作。具有多个备选定义的产生式通常为每个备选定义关联一个独立算法。若算法与某个文法产生式关联，则可将产生式备选中的终结符和非终结符视为算法参数进行引用。以此方式使用时，非终结符引用实际为解析源文本时匹配的具体备选定义。<dfn oldids="sec-static-semantics-sourcetext">某个文法产生式或其派生的解析节点所匹配的源文本</dfn>是指从第一个参与匹配的终结符开始到最后一个终结符结束的源文本片段。</p>
      <p>当算法与产生式备选关联时，备选一般不带“[ ]”文法标注。这些标注仅影响备选的句法识别，对备选相关语义无影响。</p>
      <p>语法导向操作通过解析节点和可选参数调用，具体调用方式见以下算法的 <emu-xref href="#step-sdo-invocation-example-1"></emu-xref>、<emu-xref href="#step-sdo-invocation-example-2"></emu-xref> 和 <emu-xref href="#step-sdo-invocation-example-3"></emu-xref> 步骤：</p>
      <emu-alg example>
        1. [id="step-sdo-invocation-example-1"] Let _status_ be SyntaxDirectedOperation of |SomeNonTerminal|.
        1. Let _someParseNode_ be the parse of some source text.
        1. [id="step-sdo-invocation-example-2"] Perform SyntaxDirectedOperation of _someParseNode_.
        1. [id="step-sdo-invocation-example-3"] Perform SyntaxDirectedOperation of _someParseNode_ with argument *"value"*.
      </emu-alg>
      <p>除非另有说明，所有链式产生式都隐含定义了对该产生式左部非终结符可应用的所有操作的隐含定义。隐含定义即对链式产生式唯一右部非终结符以相同参数重复应用同一操作，返回结果。例如，假设某算法有如下步骤：“Return Evaluation of |Block|”且有如下产生式：</p>
      <emu-grammar example>
        Block :
          `{` StatementList `}`
      </emu-grammar>
      <p>但 Evaluation 操作未与该产生式关联算法，则此时 Evaluation 操作隐含如下关联：</p>
      <p><b>运行时语义：Evaluation</b></p>
      <emu-grammar example>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg example>
        1. Return Evaluation of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics">
      <h1>运行时语义</h1>
      <p>指定运行时必须调用的语义的算法称为<dfn>运行时语义</dfn>。运行时语义通过抽象操作或语法导向操作定义。</p>

      <emu-clause id="sec-completion-ao" type="abstract operation">
        <h1>
          Completion (
            _completionRecord_: a Completion Record,
          ): a Completion Record
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>用于强调返回的是 Completion Record。</dd>
          <dt>跳过返回检查</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: _completionRecord_ 是 Completion Record。
          1. Return _completionRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throw-an-exception">
        <h1>抛出异常</h1>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Return ThrowCompletion(a newly created *TypeError* object).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt" aoid="ReturnIfAbrupt">
        <h1>ReturnIfAbrupt</h1>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_argument_).
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Assert: _argument_ 是 Completion Record。
          1. 如果 _argument_ 是异常完成，则返回 Completion(_argument_)。
          1. 否则，将 _argument_ 设为 _argument_.[[Value]]。
        </emu-alg>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(AbstractOperation()).
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Let _hygienicTemp_ be AbstractOperation().
          1. Assert: _hygienicTemp_ 是 Completion Record。
          1. 如果 _hygienicTemp_ 是异常完成，则返回 Completion(_hygienicTemp_)。
          1. 否则，将 _hygienicTemp_ 设为 _hygienicTemp_.[[Value]]。
        </emu-alg>
        <p>其中 _hygienicTemp_ 仅在 ReturnIfAbrupt 相关步骤中可见且为临时变量。</p>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. Let _result_ be AbstractOperation(ReturnIfAbrupt(_argument_)).
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Assert: _argument_ 是 Completion Record。
          1. 如果 _argument_ 是异常完成，则返回 Completion(_argument_)。
          1. 否则，将 _argument_ 设为 _argument_.[[Value]]。
          1. Let _result_ be AbstractOperation(_argument_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt-shorthands">
        <h1>ReturnIfAbrupt 简记法</h1>
        <p>抽象操作和语法导向操作调用前加 `?` 表示应对返回的 Completion Record 应用 ReturnIfAbrupt。例如：</p>
        <emu-alg example>
          1. ? OperationName().
        </emu-alg>
        <p>等价于：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(OperationName()).
        </emu-alg>
        <p>类似地，方法调用风格：</p>
        <emu-alg example>
          1. ? _someValue_.OperationName().
        </emu-alg>
        <p>等价于：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_someValue_.OperationName()).
        </emu-alg>
        <p>类似地，前缀 `!` 表示后续抽象或语法导向操作的调用不会返回异常完成，结果应取 Completion Record 的 [[Value]] 字段作为操作的返回值。例如：</p>
        <emu-alg example>
          1. Let _val_ be ! OperationName().
        </emu-alg>
        <p>等价于：</p>
        <emu-alg example>
          1. Let _val_ be OperationName()。
          1. Assert: _val_ 是正常完成。
          1. Set _val_ to _val_.[[Value]]。
        </emu-alg>
        <p>运行时语义的语法导向操作会通过在操作调用前加 `!` 或 `?` 使用此简记法：</p>
        <emu-alg example>
          1. Perform ! SyntaxDirectedOperation of |NonTerminal|。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-implicit-normal-completion" oldids="sec-implicit-completion-values">
        <h1>隐式正常完成</h1>
        <p>对于声明为返回 Completion Record 的抽象操作算法以及所有内建函数，其返回值会先传递给 NormalCompletion，再使用结果。该规则不适用于 Completion 算法内部或返回值明确标为 Completion Record 的步骤；包括：</p>
        <ul>
          <li>直接返回 Completion、NormalCompletion、ThrowCompletion 或 ReturnCompletion 的结果</li>
          <li>直接返回构造的 Completion Record 的结果</li>
        </ul>
        <p>如果通过其他方式从此类抽象操作返回 Completion Record，则属于编辑错误。例如，在这些抽象操作中，</p>
        <emu-alg example>
          1. Return *true*.
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Return NormalCompletion(*true*)。
        </emu-alg>
        <p>或</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*)。
          1. Return Completion(_completion_)。
        </emu-alg>
        <p>或</p>
        <emu-alg example>
          1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: *true*, [[Target]]: ~empty~ }。
        </emu-alg>
        <p>注意，通过 ReturnIfAbrupt 展开，以下写法允许，因为在展开步骤中，异常情况直接返回 Completion，正常情况在解包后隐式应用 NormalCompletion。</p>
        <emu-alg example>
          1. Return ? _completion_。
        </emu-alg>
        <p>以下示例则属于编辑错误，因为返回 Completion Record 时未在该步骤标注。</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*)。
          1. Return _completion_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-static-semantic-rules">
      <h1>静态语义</h1>
      <p>上下文无关文法无法表达所有判断输入元素流是否能组成可求值的有效 ECMAScript |Script| 或 |Module| 的规则。在某些情况下需补充规则，可用 ECMAScript 算法约定或散文要求表达。这些规则总是与某个文法产生式关联，称为该产生式的<dfn>静态语义</dfn>。</p>
      <p>静态语义规则有名称，通常用算法定义。命名静态语义规则与文法产生式关联，具有多个备选定义的产生式通常为每个备选和每个适用的命名静态语义规则定义独立算法。</p>
      <p>一种特殊的静态语义规则是<dfn id="early-error-rule">早期错误规则</dfn>。早期错误规则定义了与特定文法产生式关联的早期错误条件（见 <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 条款）。大多数早期错误规则的判断不会在规范算法中显式调用。符合规范的实现必须在首次求值 |Script| 或 |Module| 之前，验证用于解析该 |Script| 或 |Module| 的所有产生式的早期错误规则。如果有任何早期错误规则被违反，则该 |Script| 或 |Module| 无效且不可求值。</p>
    </emu-clause>

    <emu-clause id="sec-mathematical-operations">
      <h1>数学运算</h1>
      <p>规范涉及以下数值类型：</p>
      <ul>
        <li><dfn id="mathematical-value" variants="mathematical value,mathematical values">数学值</dfn>：任意实数，作为默认数值类型。</li>
        <li><dfn id="extended-mathematical-value" variants="extended mathematical value,extended mathematical values">扩展数学值</dfn>：数学值加上 +∞ 和 -∞。</li>
        <li><em>Numbers</em>：IEEE 754-2019 binary64（双精度浮点数）值。</li>
        <li><em>BigInts</em>：ECMAScript 语言值，一一对应表示任意整数。</li>
      </ul>

      <p>在规范语言中，不同数值类型通过下标后缀区分。下标 <sub>𝔽</sub> 表示 Numbers，下标 <sub>ℤ</sub> 表示 BigInts。无下标后缀的数值表示数学值。规范多数数值以十进制表示，也用 0x 加数字 0-9 或 A-F 表示十六进制。</p>
      <p>一般来说，规范提及数值时，如“_y_ 的长度”或“四个十六进制数字表示的整数”，未显式说明数值类型时，指的是数学值。指明 Number 或 BigInt 时会明确标注，如“表示代码点数量的 Number 值”或“表示某值的 BigInt 值”。</p>
      <p>规范中的<dfn id="integer" oldids="mathematical integer" variants="integers">integer</dfn>指数学上的整数，除非另有说明。<dfn id="integral-number" oldids="sec-isintegralnumber,sec-isinteger" variants="integral Numbers">integral Number</dfn>指数学值为整数的有限 Number 值。</p>
      <p>如 +、×、=、≥ 等数值运算符，具体操作取决于操作数类型。用于数学值时为常规数学运算，扩展数学值时为扩展实数运算（不定义不定型，规范中出现为编辑错误），用于 Number 时为 IEEE 754-2019 运算，BigInt 时为 BigInt 的数学值运算。混合类型操作数（如 Number 与数学值）不定义，规范中出现为编辑错误。</p>
      <p>数学值与 Number 或 BigInt 间转换均为显式。数学值或扩展数学值 _x_ 转 Number 表示为“_x_ 的 Number 值”或 <emu-eqn id="𝔽" aoid="𝔽">𝔽(_x_)</emu-eqn>，见 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>。整数 _x_ 转 BigInt 表示为“_x_ 的 <dfn id="bigint-value-for">BigInt 值</dfn>”或 <emu-eqn id="ℤ" aoid="ℤ">ℤ(_x_)</emu-eqn>。Number 或 BigInt _x_ 转数学值表示为“_x_ 的 <dfn id="mathematical-value-of">数学值</dfn>”或 <emu-eqn id="ℝ" aoid="ℝ">ℝ(_x_)</emu-eqn>。*+0*<sub>𝔽</sub> 和 *-0*<sub>𝔽</sub> 的数学值为 0，非有限值的数学值不定义。<dfn id="extended-mathematical-value-of">_x_ 的扩展数学值</dfn> 对于有限值为数学值，*+∞*<sub>𝔽</sub> 和 *-∞*<sub>𝔽</sub> 分别为 +∞ 和 -∞，*NaN* 不定义。</p>
      <p>数学函数 <emu-eqn id="eqn-abs" aoid="abs">abs(_x_)</emu-eqn> 返回 _x_ 的绝对值，即当 _x_ &lt; 0 时为 <emu-eqn>-_x_</emu-eqn>，否则为 _x_。</p>
      <p>数学函数 <emu-eqn id="eqn-min" aoid="min">min(_x1_, _x2_, … , _xN_)</emu-eqn> 取 <emu-eqn>_x1_</emu-eqn> 到 <emu-eqn>_xN_</emu-eqn> 中最小值，<emu-eqn id="eqn-max" aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn> 取最大值，定义域和值域为扩展数学值。</p>
      <p>记号“<emu-eqn id="eqn-modulo" aoid="modulo">_x_ 模 _y_</emu-eqn>”（_y_ 必须为有限且非零）计算与 _y_ 同号或为零的值 _k_，满足 <emu-eqn>abs(_k_) &lt; abs(_y_) 且 _x_ - _k_ = _q_ × _y_</emu-eqn>，其中 _q_ 为整数。</p>
      <p>“将 _x_ 限制在 _lower_ 与 _upper_ 之间”（_x_ 为扩展数学值，_lower_ 和 _upper_ 为满足 _lower_ ≤ _upper_ 的数学值）表示若 _x_ &lt; _lower_，则取 _lower_，若 _x_ > _upper_，则取 _upper_，否则取 _x_。</p>
      <p>数学函数 <emu-eqn id="eqn-floor" aoid="floor">floor(_x_)</emu-eqn> 返回不大于 _x_ 的最大整数（最接近 +∞）。</p>
      <emu-note>
        <p><emu-eqn>floor(_x_) = _x_ - (_x_ 模 1)</emu-eqn>。</p>
      </emu-note>
      <p>数学函数 <emu-eqn id="eqn-truncate" aoid="truncate">truncate(_x_)</emu-eqn> 通过向零舍入移除 _x_ 的小数部分，当 _x_ &lt; 0 时为 <emu-eqn>-floor(-_x_)</emu-eqn>，否则为 <emu-eqn>floor(_x_)</emu-eqn>。</p>
      <p>数学函数 min、max、abs、floor 和 truncate 不用于 Numbers 和 BigInts，对非数学值参数使用这些方法属于编辑错误。</p>
      <p><dfn id="interval">区间</dfn>从下界 _a_ 到上界 _b_，是同一数值类型的可能无限或空的数值集合。每个边界描述为闭或开，不可兼有。区间分为四种：</p>
      <ul>
        <li>从 _a_（闭）到 _b_（闭），亦称<dfn id="inclusive-interval">闭区间</dfn>，包含所有满足 _a_ ≤ _x_ ≤ _b_ 的同类型值 _x_。</li>
        <li>从 _a_（闭）到 _b_（开），包含所有满足 _a_ ≤ _x_ &lt; _b_ 的同类型值 _x_。</li>
        <li>从 _a_（开）到 _b_（闭），包含所有满足 _a_ &lt; _x_ ≤ _b_ 的同类型值 _x_。</li>
        <li>从 _a_（开）到 _b_（开），包含所有满足 _a_ &lt; _x_ &lt; _b_ 的同类型值 _x_。</li>
      </ul>
      <p>例如，1（闭）到 2（开）区间包含所有 1 到 2 之间的数学值，包括 1 不包括 2。定义区间时，*-0*<sub>𝔽</sub> &lt; *+0*<sub>𝔽</sub>，因此下界为 *+0*<sub>𝔽</sub> 的闭区间包含 *+0*<sub>𝔽</sub> 但不包含 *-0*<sub>𝔽</sub>。*NaN* 永不包含在区间内。</p>
    </emu-clause>

    <emu-clause id="sec-value-notation">
      <h1>值记号</h1>
      <p>本规范中，ECMAScript 语言值用 *粗体* 显示，如 *null*、*true* 或 *"hello"*。这与 ECMAScript 源文本（如 `Function.prototype.apply` 或 `let n = 42;`）区分开。</p>
    </emu-clause>

    <emu-clause id="sec-identity">
      <h1>同一性</h1>
      <p>本规范中，规范值和 ECMAScript 语言值都可进行相等性比较。比较时，值分为两类。<dfn variants="values without identity,value without identity">无同一性的值</dfn>，若所有固有特性相同（如整数的大小或序列的长度）则彼此相等。无同一性值可通过完全描述其特性直接表现，无需先前引用。相比之下，<dfn variants="values with identity">有同一性的值</dfn>是唯一的，仅与自身相等。有同一性的值除了拥有无同一性值的特性，还具有不可猜测、不可变、全局唯一的特性，称为<em>同一性</em>。对现有有同一性的值的引用不能仅通过描述其特性表现，同一性本身无法描述，必须显式传递。有同一性的值有些可变，可原地改变其特性（除了同一性），所有持有者都能观察到新特性。无同一性值永远不等于有同一性值。</p>
      <p>在规范角度，“is”用于比较两个值是否相等，例如“If _bool_ is *true*, then ...”；“contains”用于在列表中用相等性比较查找值，如“If _list_ contains a Record _r_ such that _r_.[[Foo]] is *true*, then ...”。规范值的<em>规范同一性</em>决定了这些比较结果，是规范中的公理。</p>
      <p>ECMAScript 语言角度，语言值通过 SameValue 抽象操作及其递归调用比较相等性。这些比较算法决定 ECMAScript 语言值的<em>语言同一性</em>。</p>
      <p>规范值中，无规范同一性的例子包括但不限于：数学值和扩展数学值；ECMAScript 源文本、代理对、指令序言等；UTF-16 码元；Unicode 码点；枚举；抽象操作（包括语法导向操作、宿主钩子等）；有序对。有规范同一性的例子包括但不限于：各种记录（包括属性描述符、PrivateElements 等）；解析节点；列表；<emu-xref href="#sec-set-and-relation-specification-type">集合</emu-xref>与关系；抽象闭包；数据块；私有名称；执行上下文及上下文栈；代理标识符；WaiterList 记录。</p>
      <p>对所有 ECMAScript 语言值，除由 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 生成的 Symbol 外，规范同一性与语言同一性一致。无规范同一性且无语言同一性的 ECMAScript 语言值包括 <emu-xref href="#sec-ecmascript-language-types-undefined-type">*undefined*</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-null-type">*null*</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-boolean-type">Boolean</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-string-type">String</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-number-type">Number</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-bigint-type">BigInt</emu-xref>。有规范同一性和语言同一性的 ECMAScript 语言值包括 <emu-xref href="#sec-ecmascript-language-types-symbol-type">Symbol</emu-xref>（非 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 生成）和 <emu-xref href="#sec-object-type">Object</emu-xref>。由 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 生成的 Symbol 有规范同一性但无语言同一性。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript 数据类型和值</h1>
  <p>本规范中的算法操作的值都具有相关的类型。可能的值类型正是本条款中定义的类型。类型进一步分为 ECMAScript 语言类型和规范类型。</p>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript 语言类型</h1>
    <p><dfn variants="ECMAScript language types">ECMAScript 语言类型</dfn>对应于 ECMAScript 编程人员可直接通过 ECMAScript 语言操作的值。ECMAScript 语言类型包括 Undefined、Null、Boolean、String、Symbol、Number、BigInt 和 Object。<dfn variants="ECMAScript language values">ECMAScript 语言值</dfn>是指具有 ECMAScript 语言类型特征的值。</p>

    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>Undefined 类型</h1>
      <p>Undefined 类型只有一个值，称为 *undefined*。任何尚未赋值的变量，其值均为 *undefined*。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>Null 类型</h1>
      <p>Null 类型只有一个值，称为 *null*。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>Boolean 类型</h1>
      <p><dfn variants="is a Boolean,is not a Boolean">Boolean 类型</dfn>表示一个逻辑实体，具有两个值，分别为 *true* 和 *false*。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>String 类型</h1>
      <p><dfn variants="is a String,is not a String">String 类型</dfn>是所有有序的零个或多个 16 位无符号整数值（“元素”）序列的集合，最大长度为 2<sup>53</sup> - 1 个元素。String 类型通常用于表示 ECMAScript 程序中的文本数据，此时每个元素都被视为一个 UTF-16 码元值。每个元素被认为在序列中占据一个位置，这些位置用非负整数索引。第一个元素（如果有）索引为 0，第二个元素索引为 1，依此类推。String 的长度即其包含的元素（即 16 位值）数。空字符串长度为零，因此不含任何元素。</p>
      <p>未解释字符串内容的 ECMAScript 操作不施加进一步语义。解释字符串值的操作则将每个元素视为单个 UTF-16 码元。然而，ECMAScript 不限制这些码元的值或相互关系，因此进一步将字符串内容解释为 UTF-16 编码的 Unicode 码点序列时，必须考虑不规范的子序列。此类操作会对数值在闭区间 0xD800 到 0xDBFF 的码元（Unicode 标准定义为 <dfn id="leading-surrogate" variants="leading surrogates">前导代理</dfn>，或正式称为 <dfn id="high-surrogate-code-unit" variants="high-surrogate code units">高代理码元</dfn>）以及闭区间 0xDC00 到 0xDFFF 的码元（定义为 <dfn id="trailing-surrogate" variants="trailing surrogates">后导代理</dfn>，或正式称为 <dfn id="low-surrogate-code-unit" variants="low-surrogate code units">低代理码元</dfn>）做如下处理：</p>
      <ul>
        <li>
          既不是前导代理也不是后导代理的码元，按其数值解释为码点。
        </li>
        <li>
          两个码元组成的序列，第一个码元 _c1_ 为前导代理，第二个码元 _c2_ 为后导代理，则为一个<dfn id="surrogate-pair" variants="surrogate pairs">代理对</dfn>，按码点值 (_c1_ - 0xD800) × 0x400 + (_c2_ - 0xDC00) + 0x10000 解释。（见 <emu-xref href="#sec-utf16decodesurrogatepair"></emu-xref>）
        </li>
        <li>
          独立的前导代理或后导代理码元（未作为代理对的一部分），按其数值解释为码点。
        </li>
      </ul>
      <p>可使用 `String.prototype.normalize`（见 <emu-xref href="#sec-string.prototype.normalize"></emu-xref>）显式规范化字符串值。`String.prototype.localeCompare`（见 <emu-xref href="#sec-string.prototype.localecompare"></emu-xref>）会在内部规范化字符串值，但其它操作不会隐式规范化其操作的字符串。操作结果除非另有说明，否则不具备语言或区域敏感性。</p>
      <emu-note>
        <p>该设计的理由是使字符串实现尽量简单且高效。如果 ECMAScript 源文本为标准化形式 C，则字符串字面量也一定是标准化的，只要其中不包含 Unicode 转义序列。</p>
      </emu-note>
      <p>在本规范中，“the <dfn id="string-concatenation">string-concatenation</dfn> of _A_, _B_, ...”（每个参数为字符串值、码元或码元序列）表示顺序连接每个参数的码元后得到的字符串值。</p>
      <p>“the <dfn id="substring">substring</dfn> of _S_ from _inclusiveStart_ to _exclusiveEnd_”（_S_ 为字符串值或码元序列，_inclusiveStart_ 和 _exclusiveEnd_ 为整数）表示从索引 _inclusiveStart_ 到紧邻索引 _exclusiveEnd_ 之前的顺序码元组成的字符串值（当 _inclusiveStart_ = _exclusiveEnd_ 时为空字符串）。若省略 "to" 后缀，则 _exclusiveEnd_ 取 _S_ 的长度。</p>
      <p>
        “<dfn id="ASCII-word-characters">the ASCII word characters</dfn>”表示如下字符串值，仅包含 Unicode 基本拉丁区的所有字母和数字以及 U+005F（下划线）：<br>
        *"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"*。<br>
        出于历史原因，在多种算法中具有特殊意义。
      </p>

      <emu-clause id="sec-stringindexof" type="abstract operation">
        <h1>
          StringIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 的长度。
          1. 如果 _searchValue_ 是空字符串且 _fromIndex_ ≤ _len_，返回 _fromIndex_。
          1. 令 _searchLen_ 为 _searchValue_ 的长度。
          1. 对每个满足 _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_ 的整数 _i_，按升序执行
            1. 令 _candidate_ 为 _string_ 从 _i_ 到 _i_ + _searchLen_ 的子串。
            1. 如果 _candidate_ 等于 _searchValue_，返回 _i_。
          1. 返回 ~not-found~。
        </emu-alg>
        <emu-note>
          <p>如果 _searchValue_ 是空字符串且 _fromIndex_ ≤ _string_ 的长度，则返回 _fromIndex_。空字符串在字符串的每个位置都可找到，包括最后一个码元之后。</p>
        </emu-note>
        <emu-note>
          <p>如果 _fromIndex_ + _searchValue_ 的长度大于 _string_ 的长度，则本算法总是返回 ~not-found~。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-stringlastindexof" type="abstract operation">
        <h1>
          StringLastIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 的长度。
          1. 令 _searchLen_ 为 _searchValue_ 的长度。
          1. Assert: _fromIndex_ + _searchLen_ ≤ _len_。
          1. 对每个满足 0 ≤ _i_ ≤ _fromIndex_ 的整数 _i_，按降序执行
            1. 令 _candidate_ 为 _string_ 从 _i_ 到 _i_ + _searchLen_ 的子串。
            1. 如果 _candidate_ 等于 _searchValue_，返回 _i_。
          1. 返回 ~not-found~。
        </emu-alg>
        <emu-note>
          <p>如果 _searchValue_ 是空字符串，则算法返回 _fromIndex_。空字符串在字符串的每个位置都可找到，包括最后一个码元之后。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>Symbol 类型</h1>
      <p><dfn variants="is a Symbol,is not a Symbol">Symbol 类型</dfn>是所有可用作对象属性键的非字符串值的集合（<emu-xref href="#sec-object-type"></emu-xref>）。</p>
      <p>每个 Symbol 都是唯一且不可变的。</p>
      <p>每个 Symbol 都有一个不可变的 [[Description]] 内部槽，其值为字符串或 *undefined*。</p>

      <emu-clause id="sec-well-known-symbols">
        <h1>知名 Symbol</h1>
        <p>知名 Symbol 是规范算法明确引用的内建 Symbol 值。它们通常用作属性键，这些属性的值作为规范算法的扩展点。除非另有说明，知名 Symbol 在所有 realm（<emu-xref href="#sec-code-realms"></emu-xref>）间共享。</p>
        <p>在本规范中，知名 Symbol 使用标准的 <emu-xref href="#sec-well-known-intrinsic-objects">内在记号</emu-xref>引用，其中内在对象为 <emu-xref href="#table-well-known-symbols"></emu-xref> 所列值之一。</p>
        <emu-note>规范的早期版本采用 @@name 记号，而本版本采用 %Symbol.name%。具体包括：@@asyncIterator、@@hasInstance、@@isConcatSpreadable、@@<emu-not-ref>iterator</emu-not-ref>、@@match、@@matchAll、@@replace、@@search、@@species、@@split、@@toPrimitive、@@toStringTag 和 @@unscopables。</emu-note>
        <emu-table id="table-well-known-symbols" caption="知名 Symbol" oldids="table-1">
          <table>
            <thead>
              <tr>
                <th>
                  规范名称
                </th>
                <th>
                  [[Description]]
                </th>
                <th>
                  值及用途
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                <dfn>%Symbol.asyncIterator%</dfn>
              </td>
              <td>
                *"Symbol.asyncIterator"*
              </td>
              <td>
                返回对象默认异步迭代器的方法。由 `for`-`await`-`of` 语句语义调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.hasInstance%</dfn>
              </td>
              <td>
                *"Symbol.hasInstance"*
              </td>
              <td>
                判断构造函数对象是否识别某对象为其实例的方法。由 `instanceof` 运算符语义调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.isConcatSpreadable%</dfn>
              </td>
              <td>
                *"Symbol.isConcatSpreadable"*
              </td>
              <td>
                一个布尔属性，若为 true 则 <emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref> 会将对象按数组元素展开。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.iterator%</dfn>
              </td>
              <td>
                *"Symbol.iterator"*
              </td>
              <td>
                返回对象默认迭代器的方法。由 for-of 语句语义调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.match%</dfn>
              </td>
              <td>
                *"Symbol.match"*
              </td>
              <td>
                正则表达式方法，用于匹配字符串。由 <emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.matchAll%</dfn>
              </td>
              <td>
                *"Symbol.matchAll"*
              </td>
              <td>
                正则表达式方法，返回迭代器，用于遍历字符串的所有匹配项。由 <emu-xref href="#sec-string.prototype.matchall">`String.prototype.matchAll`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.replace%</dfn>
              </td>
              <td>
                *"Symbol.replace"*
              </td>
              <td>
                正则表达式方法，用于替换字符串中的匹配子串。由 <emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.search%</dfn>
              </td>
              <td>
                *"Symbol.search"*
              </td>
              <td>
                正则表达式方法，返回匹配字符串的索引。由 <emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.species%</dfn>
              </td>
              <td>
                *"Symbol.species"*
              </td>
              <td>
                一个函数属性，是用于创建派生对象的构造函数。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.split%</dfn>
              </td>
              <td>
                *"Symbol.split"*
              </td>
              <td>
                正则表达式方法，用于在匹配索引处分割字符串。由 <emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toPrimitive%</dfn>
              </td>
              <td>
                *"Symbol.toPrimitive"*
              </td>
              <td>
                将对象转换为对应原始值的方法。由 ToPrimitive 抽象操作调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toStringTag%</dfn>
              </td>
              <td>
                *"Symbol.toStringTag"*
              </td>
              <td>
                用于创建对象默认字符串描述的字符串属性。通过内建方法 <emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref> 访问。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.unscopables%</dfn>
              </td>
              <td>
                *"Symbol.unscopables"*
              </td>
              <td>
                一个对象属性，其自身和继承的属性名是关联对象的 `with` 环境绑定中被排除的属性名。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-numeric-types">
      <h1>数值类型</h1>
      <p>ECMAScript 有两种内建数值类型：Number 和 BigInt。以下抽象操作定义于这些数值类型之上。“结果”列显示返回类型，同时指明部分调用可能返回异常完成。</p>
      <emu-table id="table-numeric-type-ops" caption="数值类型操作">
        <table>
          <thead>
            <tr>
              <th>
                操作
              </th>
              <th>
                示例源码
              </th>
              <th>
                在...的求值语义中调用
              </th>
              <th>
                结果
              </th>
            </tr>
          </thead>

          <tr>
            <td>
              Number::unaryMinus
            </td>
            <td rowspan="2">
              `-x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unary-minus-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unaryMinus
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseNOT
            </td>
            <td rowspan="2">
              `~x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-bitwise-not-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseNOT
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::exponentiate
            </td>
            <td rowspan="2">
              `x&nbsp;**&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-exp-operator" title></emu-xref>
              and <emu-xref href="#sec-math.pow" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::exponentiate
            </td>
            <td>
              返回正常完成的 BigInt 或抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::multiply
            </td>
            <td rowspan="2">
              `x&nbsp;*&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::multiply
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::divide
            </td>
            <td rowspan="2">
              `x&nbsp;/&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::divide
            </td>
            <td>
              返回正常完成的 BigInt 或抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::remainder
            </td>
            <td rowspan="2">
              `x&nbsp;%&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::remainder
            </td>
            <td>
              返回正常完成的 BigInt 或抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::add
            </td>
            <td rowspan="2">
              `x ++`<br>
              `++ x`<br>
              `x&nbsp;+&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-increment-operator" title></emu-xref>,
              and <emu-xref href="#sec-addition-operator-plus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::add
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::subtract
            </td>
            <td rowspan="2">
              `x --`<br>
              `-- x`<br>
              `x&nbsp;-&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-decrement-operator" title></emu-xref>,
              and <emu-xref href="#sec-subtraction-operator-minus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::subtract
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::leftShift
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&lt;&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-left-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::leftShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::signedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-signed-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::signedRightShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::unsignedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unsigned-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unsignedRightShift
            </td>
            <td>
              抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::lessThan
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&nbsp;y`<br>
              `x&nbsp;>&nbsp;y`<br>
              `x&nbsp;&lt;=&nbsp;y`<br>
              `x&nbsp;>=&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-relational-operators" title></emu-xref>,
              via <emu-xref href="#sec-islessthan" title></emu-xref>
            </td>
            <td>
              Boolean 或 *undefined*（用于无序输入）
            </td>
          </tr>

          <tr>
            <td>
              BigInt::lessThan
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::equal
            </td>
            <td rowspan="2">
              `x&nbsp;==&nbsp;y`<br>
              `x&nbsp;!=&nbsp;y`<br>
              `x&nbsp;===&nbsp;y`<br>
              `x&nbsp;!==&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-equality-operators" title></emu-xref>,
              via <emu-xref href="#sec-isstrictlyequal" title></emu-xref>
            </td>
            <td rowspan="2">
              Boolean
            </td>
          </tr>
          <tr>
            <td>
              BigInt::equal
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValue
            </td>
            <td>
              `Object.is(x, y)`
            </td>
            <td>
              对象内部方法，
              via <emu-xref href="#sec-samevalue" title></emu-xref>，
              用于测试精确值相等性
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValueZero
            </td>
            <td>
              `[x].includes(y)`
            </td>
            <td>
              via <emu-xref href="#sec-samevaluezero" title></emu-xref>，
              用于测试值相等性，忽略 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub> 的区别，如 Array、Map 和 Set 方法
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseAND
            </td>
            <td rowspan="2">
              `x&nbsp;&amp;&nbsp;y`
            </td>
            <td rowspan="6">
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseAND
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseXOR
            </td>
            <td rowspan="2">
              `x&nbsp;^&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseXOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseOR
            </td>
            <td rowspan="2">
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::toString
            </td>
            <td rowspan="2">
              `String(x)`
            </td>
            <td rowspan="2">
              多种表达式和内建函数，via <emu-xref href="#sec-tostring" title></emu-xref>
            </td>
            <td rowspan="2">
              String
            </td>
          </tr>
          <tr>
            <td>
              BigInt::toString
            </td>
          </tr>
        </table>
      </emu-table>
      <p>由于数值类型通常无法在不丢失精度或截断的情况下进行转换，ECMAScript 语言不提供这些类型之间的隐式转换。程序员必须显式调用 `Number` 和 `BigInt` 函数来在调用需要另一种类型的函数时进行类型转换。</p>
      <emu-note>
        <p>ECMAScript 的第一版及后续版本为某些运算符提供了可能丢失精度或截断的隐式数值转换。为了兼容旧代码，这些传统的隐式转换仍然保留，但对于 BigInt 不再提供，以最大程度减少程序员出错的机会，并为将来版本支持更广泛的 <em>值类型</em> 留下空间。</p>
      </emu-note>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>Number 类型</h1>
        <p><dfn variants="是 Number,不是 Number">Number 类型</dfn>一共有 18,437,736,874,454,810,627 个值（即 <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>），表示 IEEE 754-2019 binary64 双精度浮点数值，遵循 IEEE 二进制浮点运算标准。不同于 IEEE 标准的 9,007,199,254,740,990 个 NaN 值（即 <emu-eqn>2<sup>53</sup> - 2</emu-eqn>），ECMAScript 将这些 NaN 都表示为一个特殊的 *NaN* 值。（注意，*NaN* 值可由表达式 `NaN` 得到。）在某些实现中，外部代码可能能区分不同的 NaN，但这种行为由实现定义；对于 ECMAScript 代码，所有 *NaN* 都无法区分。</p>
        <emu-note>
          <p>将 Number 值存入 ArrayBuffer（参见 <emu-xref href="#sec-arraybuffer-objects"></emu-xref>）或 SharedArrayBuffer（参见 <emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>）后观察到的比特模式，不一定与 ECMAScript 内部表示该 Number 值的方式一致。</p>
        </emu-note>
        <p>还有两个特殊值，称为 *正无穷* 和 *负无穷*。为了简便，分别用符号 *+∞*<sub>𝔽</sub> 和 *-∞*<sub>𝔽</sub> 表示。（注意，这两个无限值可由表达式 `+Infinity`（或简写为 `Infinity`）和 `-Infinity` 得到。）</p>
        <p>其余 18,437,736,874,454,810,624 个值（即 <emu-eqn>2<sup>64</sup> - 2<sup>53</sup></emu-eqn>）称为 <dfn id="finite">有限</dfn>数值。这些数值一半为正，一半为负，对于每一个有限的正数，都有一个相同绝对值的负数。</p>
        <p>注意，存在 *正零* 和 *负零*。为了简便，分别用符号 *+0*<sub>𝔽</sub> 和 *-0*<sub>𝔽</sub> 表示。（注意，这两个零值可由表达式 `+0`（或简写为 `0`）和 `-0` 得到。）</p>
        <p>18,437,736,874,454,810,622 个有限非零值（即 <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>）分为两类：</p>
        <p>其中 18,428,729,675,200,069,632 个（即 <emu-eqn>2<sup>64</sup> - 2<sup>54</sup></emu-eqn>）是规格化的，形式为：</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>其中 _s_ 为 1 或 -1，_m_ 是区间 [2<sup>52</sup>, 2<sup>53</sup>) 内的整数，_e_ 为 [-1074, 971] 间的整数。</p>
        <p>剩下的 9,007,199,254,740,990 个值（即 <emu-eqn>2<sup>53</sup> - 2</emu-eqn>）是非规格化的，形式为：</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>其中 _s_ 为 1 或 -1，_m_ 是 (0, 2<sup>52</sup>) 区间的整数，_e_ 等于 -1074。</p>
        <p>注意，所有绝对值不超过 2<sup>53</sup> 的正负整数都能用 Number 类型表示。整数 0 在 Number 类型中有两种表示：*+0*<sub>𝔽</sub> 和 *-0*<sub>𝔽</sub>。</p>
        <p>有限数值如果非零且表达式中的整数 _m_ 为奇数，则称其为 <em>奇有效数字</em>；否则为 <em>偶有效数字</em>。</p>
        <p>在本规范中，“<dfn id="number-value-for" oldids="number-value">_x_ 的 Number 值</dfn>”表示 _x_ 是某个精确的数学实数（甚至可能是无理数如 π），其 Number 值按如下方式选取：取所有有限 Number 类型值的集合，去掉 *-0*<sub>𝔽</sub> 并加上两个 Number 类型不可表示的值，即 2<sup>1024</sup>（即 <emu-eqn>+1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>）和 <emu-eqn>-2<sup>1024</sup></emu-eqn>（即 <emu-eqn>-1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>）。选取与 _x_ 最接近的集合成员。如果有两个值一样接近，则选有效数字为偶数的那个；这时额外的两个值 2<sup>1024</sup> 和 <emu-eqn>-2<sup>1024</sup></emu-eqn> 被认为是偶有效数字。最后，如果选中 2<sup>1024</sup>，则用 *+∞*<sub>𝔽</sub> 替换；如果选中 <emu-eqn>-2<sup>1024</sup></emu-eqn>，则用 *-∞*<sub>𝔽</sub> 替换；如果选中 *+0*<sub>𝔽</sub>，则仅当 _x_ &lt; 0 时替换为 *-0*<sub>𝔽</sub>；其他选中的值不变。结果就是 _x_ 的 Number 值。（此过程与 IEEE 754-2019 的 roundTiesToEven 模式完全一致。）</p>
        <p>+∞ 的 Number 值为 *+∞*<sub>𝔽</sub>，-∞ 的 Number 值为 *-∞*<sub>𝔽</sub>。</p>
        <p>某些 ECMAScript 运算符只处理范围特定的整数，比如 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 或 [0, 2<sup>16</sup> - 1]。这些运算符接受任意 Number 类型值，但会先将其转换为预期范围的整数。具体转换见 <emu-xref href="#sec-type-conversion"></emu-xref>。</p>

        <emu-clause id="sec-numeric-types-number-unaryMinus" type="numeric method">
          <h1>
            Number::unaryMinus (
              _x_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *NaN*。
            1. 返回 _x_ 的相反数；即生成一个数值，大小相同，符号相反。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseNOT" type="numeric method">
          <h1>
            Number::bitwiseNOT (
              _x_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _oldValue_ 为 ! ToInt32(_x_)。
            1. 返回 _oldValue_ 的按位取反。结果的数学值正好能表示为一个 32 位补码二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-exponentiate" type="numeric method" oldids="sec-applying-the-exp-operator">
          <h1>
            Number::exponentiate (
              _base_: 一个 Number,
              _exponent_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>返回一个实现近似的值，表示 _base_ 的 _exponent_ 次幂。</dd>
          </dl>
          <emu-alg>
            1. 如果 _exponent_ 是 *NaN*，返回 *NaN*。
            1. 如果 _exponent_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *NaN*，返回 *NaN*。
            1. 如果 _base_ 是 *+∞*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *-∞*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-∞*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
              1. 否则：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-0*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *+0*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-0*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
              1. 否则：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-∞*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
            1. 断言：_base_ 是有限值且不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>。
            1. 如果 _exponent_ 是 *+∞*<sub>𝔽</sub>：
              1. 如果 abs(ℝ(_base_)) > 1，返回 *+∞*<sub>𝔽</sub>。
              1. 如果 abs(ℝ(_base_)) = 1，返回 *NaN*。
              1. 如果 abs(ℝ(_base_)) &lt; 1，返回 *+0*<sub>𝔽</sub>。
            1. 如果 _exponent_ 是 *-∞*<sub>𝔽</sub>：
              1. 如果 abs(ℝ(_base_)) > 1，返回 *+0*<sub>𝔽</sub>。
              1. 如果 abs(ℝ(_base_)) = 1，返回 *NaN*。
              1. 如果 abs(ℝ(_base_)) &lt; 1，返回 *+∞*<sub>𝔽</sub>。
            1. 断言：_exponent_ 是有限值且不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>。
            1. 如果 _base_ &lt; *-0*<sub>𝔽</sub> 且 _exponent_ 不是整数 Number，返回 *NaN*。
            1. 返回一个实现近似的 Number 值，表示 ℝ(_base_) 的 ℝ(_exponent_) 次幂。
          </emu-alg>
          <emu-note>
            <p>当 _base_ 为 *1*<sub>𝔽</sub> 或 *-1*<sub>𝔽</sub>，且 _exponent_ 为 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，或当 _base_ 为 *1*<sub>𝔽</sub> 且 _exponent_ 为 *NaN* 时，_base_ `**` _exponent_ 的结果与 IEEE 754-2019 不同。ECMAScript 第一版规定此操作结果为 *NaN*，而后续 IEEE 754 修订版规定为 *1*<sub>𝔽</sub>。此处保留 ECMAScript 历史行为以兼容。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-multiply" type="numeric method" oldids="sec-applying-the-mul-operator">
          <h1>
            Number::multiply (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>按 IEEE 754-2019 双精度算术规则执行乘法，得到 _x_ 和 _y_ 的乘积。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 或 _y_ 是 *NaN*，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _y_ > *+0*<sub>𝔽</sub>，返回 _x_。
              1. 返回 -_x_。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>：
              1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _x_ > *+0*<sub>𝔽</sub>，返回 _y_。
              1. 返回 -_y_。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *-0*<sub>𝔽</sub> 或 _y_ &lt; *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
              1. 否则，返回 *-0*<sub>𝔽</sub>。
            1. 如果 _y_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _x_ &lt; *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
              1. 否则，返回 *-0*<sub>𝔽</sub>。
            1. 返回 𝔽(ℝ(_x_) × ℝ(_y_))。
          </emu-alg>
          <emu-note>
            <p>有限精度乘法是可交换的，但不总是结合的。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-divide" type="numeric method" oldids="sec-applying-the-div-operator">
          <h1>
            Number::divide (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>按 IEEE 754-2019 双精度算术规则执行除法，得到 _x_ 除以 _y_ 的商，其中 _x_ 为被除数，_y_ 为除数。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 或 _y_ 是 *NaN*，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _y_ 是 *+0*<sub>𝔽</sub> 或 _y_ > *+0*<sub>𝔽</sub>，返回 _x_。
              1. 返回 -_x_。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub>：
              1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 _x_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>；否则返回 *-0*<sub>𝔽</sub>。
            1. 如果 _y_ 是 *-∞*<sub>𝔽</sub>：
              1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 _x_ > *+0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _y_ > *+0*<sub>𝔽</sub>，返回 _x_。
              1. 返回 -_x_。
            1. 如果 _y_ 是 *+0*<sub>𝔽</sub>：
              1. 如果 _x_ > *+0*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>；否则返回 *-∞*<sub>𝔽</sub>。
            1. 如果 _y_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _x_ > *+0*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
            1. 返回 𝔽(ℝ(_x_) / ℝ(_y_))。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-remainder" type="numeric method" oldids="sec-applying-the-mod-operator">
          <h1>
            Number::remainder (
              _n_: 一个 Number,
              _d_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>产生隐式除法的余数，其中 _n_ 为被除数，_d_ 为除数。</dd>
          </dl>
          <emu-alg>
            1. 如果 _n_ 或 _d_ 是 *NaN*，返回 *NaN*。
            1. 如果 _n_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _d_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 _n_。
            1. 如果 _d_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
            1. 断言：_n_ 和 _d_ 都是有限且非零值。
            1. 令 _quotient_ 为 ℝ(_n_) / ℝ(_d_)。
            1. 令 _q_ 为 truncate(_quotient_)。
            1. 令 _r_ 为 ℝ(_n_) - (ℝ(_d_) × _q_)。
            1. 如果 _r_ = 0 且 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回 𝔽(_r_)。
          </emu-alg>
          <emu-note>
            <p>C 和 C++ 的余数运算符只接受整数操作数；而 ECMAScript 也接受浮点数操作数。</p>
          </emu-note>
          <emu-note>浮点数余数运算 `%` 的结果与 IEEE 754-2019 中定义的“余数”操作不同。IEEE 的余数操作基于四舍五入除法，而非截断除法，因此行为不同于通常的 <emu-not-ref>整数</emu-not-ref> 余数运算符。ECMAScript 定义 `%` 运算针对浮点数时的行为类似于 Java <emu-not-ref>整数</emu-not-ref> 余数运算符；可与 C 库函数 fmod 作比较。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-add" type="numeric method" oldids="sec-applying-the-additive-operators-to-numbers">
          <h1>
            Number::add (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>按 IEEE 754-2019 双精度算术规则执行加法，产生两个参数的和。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 或 _y_ 是 *NaN*，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 且 _y_ 是 *-∞*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _x_ 是 *-∞*<sub>𝔽</sub> 且 _y_ 是 *+∞*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 _x_。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 _y_。
            1. 断言：_x_ 和 _y_ 都是有限值。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回 𝔽(ℝ(_x_) + ℝ(_y_))。
          </emu-alg>
          <emu-note>
            <p>有限精度加法是可交换的，但不总是结合的。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-subtract" type="numeric method">
          <h1>
            Number::subtract (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>执行减法，产生操作数的差值；_x_ 为被减数，_y_ 为减数。</dd>
          </dl>
          <emu-alg>
            1. 返回 Number::add(_x_, Number::unaryMinus(_y_))。
          </emu-alg>
          <emu-note>
            <p>始终有 `x - y` 的结果与 `x + (-y)` 相同。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-leftShift" type="numeric method">
          <h1>
            Number::leftShift (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToInt32(_x_)。
            1. 令 _rNum_ 为 ! ToUint32(_y_)。
            1. 令 _shiftCount_ 为 ℝ(_rNum_) 模 32。
            1. 返回将 _lNum_ 左移 _shiftCount_ 位的结果。结果的数学值正好能表示为 32 位补码二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-signedRightShift" type="numeric method">
          <h1>
            Number::signedRightShift (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToInt32(_x_)。
            1. 令 _rNum_ 为 ! ToUint32(_y_)。
            1. 令 _shiftCount_ 为 ℝ(_rNum_) 模 32。
            1. 返回将 _lNum_ 进行符号扩展右移 _shiftCount_ 位的结果。最高位会被扩展。结果的数学值正好能表示为 32 位补码二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-unsignedRightShift" type="numeric method">
          <h1>
            Number::unsignedRightShift (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToUint32(_x_)。
            1. 令 _rNum_ 为 ! ToUint32(_y_)。
            1. 令 _shiftCount_ 为 ℝ(_rNum_) 模 32。
            1. 返回将 _lNum_ 进行零填充右移 _shiftCount_ 位的结果。空出的位用零填充。结果的数学值正好能表示为 32 位无符号二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-lessThan" type="numeric method">
          <h1>
            Number::lessThan (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean 或 *undefined*
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *undefined*。
            1. 如果 _y_ 是 *NaN*，返回 *undefined*。
            1. 如果 _x_ 等于 _y_，返回 *false*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _y_ 是 *-∞*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *-∞*<sub>𝔽</sub>，返回 *true*。
            1. 断言：_x_ 和 _y_ 都是有限值。
            1. 如果 ℝ(_x_) &lt; ℝ(_y_)，返回 *true*；否则返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-equal" type="numeric method">
          <h1>
            Number::equal (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *false*。
            1. 如果 _y_ 是 *NaN*，返回 *false*。
            1. 如果 _x_ 等于 _y_，返回 *true*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValue" type="numeric method">
          <h1>
            Number::sameValue (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 和 _y_ 都是 *NaN*，返回 *true*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 等于 _y_，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValueZero" type="numeric method">
          <h1>
            Number::sameValueZero (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 和 _y_ 都是 *NaN*，返回 *true*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _x_ 等于 _y_，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numberbitwiseop" type="abstract operation">
          <h1>
            NumberBitwiseOp (
              _op_: `&amp;`, `^`, 或 `|`,
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToInt32(_x_)。
            1. 令 _rNum_ 为 ! ToInt32(_y_)。
            1. 令 _lBits_ 为表示 ℝ(_lNum_) 的 32 位补码二进制串。
            1. 令 _rBits_ 为表示 ℝ(_rNum_) 的 32 位补码二进制串。
            1. 如果 _op_ 是 `&amp;`：
              1. 令 _result_ 为对 _lBits_ 和 _rBits_ 应用按位与操作的结果。
            1. 否则如果 _op_ 是 `^`：
              1. 令 _result_ 为对 _lBits_ 和 _rBits_ 应用按位异或操作的结果。
            1. 否则：
              1. 断言 _op_ 为 `|`。
              1. 令 _result_ 为对 _lBits_ 和 _rBits_ 应用按位或操作的结果。
            1. 返回由 32 位补码二进制串 _result_ 表示的整数的 Number 值。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseAND" type="numeric method">
          <h1>
            Number::bitwiseAND (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 NumberBitwiseOp(`&amp;`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseXOR" type="numeric method">
          <h1>
            Number::bitwiseXOR (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 NumberBitwiseOp(`^`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseOR" type="numeric method">
          <h1>
            Number::bitwiseOR (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 NumberBitwiseOp(`|`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-tostring" type="numeric method" oldids="sec-tostring-applied-to-the-number-type">
          <h1>
            Number::toString (
              _x_: 一个 Number,
              _radix_: 2 到 36 之间的整数,
            ): 一个字符串
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>用基数 _radix_ 的位置数字系统将 _x_ 表示为字符串。用基数 _r_ 时，数字取自 *"0123456789abcdefghijklmnopqrstuvwxyz"* 的前 _r_ 个码位。表示绝对值大于等于 *1*<sub>𝔽</sub> 的数时，结果不会包含前导零。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *"NaN"*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *"0"*。
            1. 如果 _x_ &lt; *-0*<sub>𝔽</sub>，返回 *"-"* 与 Number::toString(-_x_, _radix_) 的拼接字符串。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub>，返回 *"Infinity"*。
            1. [id="step-number-tostring-intermediate-values"] 令 _n_、_k_、_s_ 为整数，满足 _k_ ≥ 1，_radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>，𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) 为 _x_，且 _k_ 尽可能小。注意 _k_ 是用基数 _radix_ 表示 _s_ 时的位数，_s_ 不能被 _radix_ 整除，且最低位未必唯一。
            1. 如果 _radix_ ≠ 10 或 _n_ 在 -5 到 21 的区间内：
              1. 如果 _n_ ≥ _k_：
                1. 返回拼接字符串：
                  * 用基数 _radix_ 表示 _s_ 的 _k_ 位数字
                  * _n_ - _k_ 个 0x0030（数字零）码位
              1. 否则如 _n_ > 0：
                1. 返回拼接字符串：
                  * 用基数 _radix_ 表示 _s_ 的最高 _n_ 位数字
                  * 0x002E（英文句点）
                  * 剩余 _k_ - _n_ 位数字
              1. 否则：
                1. 断言：_n_ ≤ 0。
                1. 返回拼接字符串：
                  * 0x0030（数字零）码位
                  * 0x002E（英文句点）
                  * -_n_ 个 0x0030（数字零）码位
                  * 用基数 _radix_ 表示 _s_ 的 _k_ 位数字
            1. 注意：此时输入会用科学 E 记数法表示，如 `1.2e+3`。
            1. 断言：_radix_ 为 10。
            1. 如果 _n_ &lt; 0：
              1. 令 _exponentSign_ 为 0x002D（减号）。
            1. 否则：
              1. 令 _exponentSign_ 为 0x002B（加号）。
            1. 如果 _k_ = 1：
              1. 返回拼接字符串：
                * _s_ 的单一数字码位
                * 0x0065（小写字母 e）
                * _exponentSign_
                * abs(_n_ - 1) 的十进制表示码位
            1. 返回拼接字符串：
              * _s_ 十进制表示的最高位数字码位
              * 0x002E（英文句点）
              * _s_ 十进制表示的剩余 _k_ - 1 位码位
              * 0x0065（小写字母 e）
              * _exponentSign_
              * abs(_n_ - 1) 的十进制表示码位
          </emu-alg>
          <emu-note>
            <p>以下观察可为实现提供参考，但不是标准的规范要求：</p>
            <ul>
              <li>
                除 *-0*<sub>𝔽</sub> 外，任意 Number 值 x 都满足 ToNumber(ToString(x)) === x。
              </li>
              <li>
                步骤 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 中 _s_ 的最低位不总是唯一确定。
              </li>
            </ul>
          </emu-note>
          <emu-note>
            <p>对于提供比上述规则更精确转换的实现，建议参考如下步骤 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 的替代版本：</p>
            <emu-alg replaces-step="step-number-tostring-intermediate-values">
              1. 令 _n_、_k_、_s_ 为整数，满足 _k_ ≥ 1，_radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>，𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) 为 _x_，且 _k_ 尽可能小。如果有多个 _s_，选择 _s_ × _radix_<sup>_n_ - _k_</sup> 最接近 ℝ(_x_) 的那个；如有两个结果，选偶数的那个。注意 _k_ 是用基数 _radix_ 表示 _s_ 的位数，且 _s_ 不能被 _radix_ 整除。
            </emu-alg>
          </emu-note>
          <emu-note>
            <p>ECMAScript 实现者可参考 David M. Gay 关于浮点数二进制到十进制转换的论文和代码：</p>
            <p>
              Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). 1990 年 11 月 30 日。参见<br>
              <a href="https://ampl.com/_archive/first-website/REFS/rounding.pdf">https://ampl.com/_archive/first-website/REFS/rounding.pdf</a>。相关代码见<br>
              <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> 以及<br>
              <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a>，也可在多个 `netlib` 镜像站点找到。
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>BigInt 类型</h1>
        <p><dfn variants="是 BigInt,不是 BigInt">BigInt 类型</dfn>表示整数值。该值可以为任意大小，不受特定位宽限制。通常，除非另有说明，相关操作都设计为返回精确的数学答案。对于二元运算，BigInt 被视为二进制补码字符串，负数则被视为左边有无限个被置位的位。</p>

        <emu-clause id="sec-numeric-types-bigint-unaryMinus" type="numeric method">
          <h1>
            BigInt::unaryMinus (
              _x_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = *0*<sub>ℤ</sub>，返回 *0*<sub>ℤ</sub>。
            1. 返回 -_x_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseNOT" type="numeric method">
          <h1>
            BigInt::bitwiseNOT (
              _x_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>返回 _x_ 的按位取反（一元补码）。</dd>
          </dl>
          <emu-alg>
            1. 返回 -_x_ - *1*<sub>ℤ</sub>。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-exponentiate" type="numeric method">
          <h1>
            BigInt::exponentiate (
              _base_: 一个 BigInt,
              _exponent_: 一个 BigInt,
            ): 正常返回一个 BigInt 或抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _exponent_ &lt; *0*<sub>ℤ</sub>，抛出 *RangeError* 异常。
            1. 如果 _base_ = *0*<sub>ℤ</sub> 且 _exponent_ = *0*<sub>ℤ</sub>，返回 *1*<sub>ℤ</sub>。
            1. 返回 _base_ 的 _exponent_ 次幂。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-multiply" type="numeric method">
          <h1>
            BigInt::multiply (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 _x_ × _y_。
          </emu-alg>
          <emu-note>即使结果的位宽远大于输入，返回的也是精确的数学答案。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-divide" type="numeric method">
          <h1>
            BigInt::divide (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 正常返回一个 BigInt 或抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _y_ = *0*<sub>ℤ</sub>，抛出 *RangeError* 异常。
            1. 令 _quotient_ 为 ℝ(_x_) / ℝ(_y_)。
            1. 返回 ℤ(truncate(_quotient_))。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-remainder" type="numeric method">
          <h1>
            BigInt::remainder (
              _n_: 一个 BigInt,
              _d_: 一个 BigInt,
            ): 正常返回一个 BigInt 或抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _d_ = *0*<sub>ℤ</sub>，抛出 *RangeError* 异常。
            1. 如果 _n_ = *0*<sub>ℤ</sub>，返回 *0*<sub>ℤ</sub>。
            1. 令 _quotient_ 为 ℝ(_n_) / ℝ(_d_)。
            1. 令 _q_ 为 ℤ(truncate(_quotient_))。
            1. 返回 _n_ - (_d_ × _q_)。
          </emu-alg>
          <emu-note>结果的符号与被除数一致。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-add" type="numeric method">
          <h1>
            BigInt::add (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 _x_ + _y_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-subtract" type="numeric method">
          <h1>
            BigInt::subtract (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 _x_ - _y_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-leftShift" type="numeric method">
          <h1>
            BigInt::leftShift (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _y_ &lt; *0*<sub>ℤ</sub>，
              1. 返回 ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>))。
            1. 返回 _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>。
          </emu-alg>
          <emu-note>此处的语义应等价于按位移位，将 BigInt 视为无限长度的二进制补码数字串。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-signedRightShift" type="numeric method">
          <h1>
            BigInt::signedRightShift (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigInt::leftShift(_x_, -_y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-unsignedRightShift" type="numeric method">
          <h1>
            BigInt::unsignedRightShift (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-lessThan" type="numeric method">
          <h1>
            BigInt::lessThan (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 ℝ(_x_) &lt; ℝ(_y_)，返回 *true*；否则返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-equal" type="numeric method" oldids="sec-numeric-types-bigint-sameValue,sec-numeric-types-bigint-sameValueZero">
          <h1>
            BigInt::equal (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 ℝ(_x_) = ℝ(_y_)，返回 *true*；否则返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryand" type="abstract operation">
          <h1>
            BinaryAnd (
              _x_: 0 或 1,
              _y_: 0 或 1,
            ): 0 或 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = 1 且 _y_ = 1，返回 1。
            1. 否则，返回 0。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryor" type="abstract operation">
          <h1>
            BinaryOr (
              _x_: 0 或 1,
              _y_: 0 或 1,
            ): 0 或 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = 1 或 _y_ = 1，返回 1。
            1. 否则，返回 0。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryxor" type="abstract operation">
          <h1>
            BinaryXor (
              _x_: 0 或 1,
              _y_: 0 或 1,
            ): 0 或 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = 1 且 _y_ = 0，返回 1。
            1. 否则如果 _x_ = 0 且 _y_ = 1，返回 1。
            1. 否则，返回 0。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-bigintbitwiseop" type="abstract operation">
          <h1>
            BigIntBitwiseOp (
              _op_: `&amp;`, `^`, 或 `|`,
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _x_ 为 ℝ(_x_)。
            1. 令 _y_ 为 ℝ(_y_)。
            1. 令 _result_ 为 0。
            1. 令 _shift_ 为 0。
            1. 重复，直到 (_x_ = 0 或 _x_ = -1) 且 (_y_ = 0 或 _y_ = -1) 为止，
              1. 令 _xDigit_ 为 _x_ 模 2。
              1. 令 _yDigit_ 为 _y_ 模 2。
              1. 如果 _op_ 是 `&amp;`，
                1. 令 _result_ 为 _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_)。
              1. 否则如果 _op_ 是 `|`，
                1. 令 _result_ 为 _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_)。
              1. 否则，
                1. 断言：_op_ 为 `^`。
                1. 令 _result_ 为 _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_)。
              1. 令 _shift_ 为 _shift_ + 1。
              1. 令 _x_ 为 (_x_ - _xDigit_) / 2。
              1. 令 _y_ 为 (_y_ - _yDigit_) / 2。
            1. 如果 _op_ 是 `&amp;`，
              1. 令 _tmp_ 为 BinaryAnd(_x_ 模 2, _y_ 模 2)。
            1. 否则如果 _op_ 是 `|`，
              1. 令 _tmp_ 为 BinaryOr(_x_ 模 2, _y_ 模 2)。
            1. 否则，
              1. 断言：_op_ 为 `^`。
              1. 令 _tmp_ 为 BinaryXor(_x_ 模 2, _y_ 模 2)。
            1. 如果 _tmp_ ≠ 0，
              1. 令 _result_ 为 _result_ - 2<sup>_shift_</sup>。
              1. 注意：此操作会扩展符号位。
            1. 返回 _result_ 的 BigInt 值。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseAND" type="numeric method">
          <h1>
            BigInt::bitwiseAND (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigIntBitwiseOp(`&amp;`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseXOR" type="numeric method">
          <h1>
            BigInt::bitwiseXOR (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigIntBitwiseOp(`^`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseOR" type="numeric method">
          <h1>
            BigInt::bitwiseOR (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigIntBitwiseOp(`|`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-tostring" type="numeric method">
          <h1>
            BigInt::toString (
              _x_: 一个 BigInt,
              _radix_: 2 到 36 之间的整数,
            ): 一个字符串
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>用基数 _radix_ 的位置数字系统将 _x_ 表示为字符串。用基数 _r_ 表示 BigInt 时，数字取自 *"0123456789abcdefghijklmnopqrstuvwxyz"* 的前 _r_ 个码位。除 *0*<sub>ℤ</sub> 外，BigInt 的表示不会包含前导零。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ &lt; *0*<sub>ℤ</sub>，返回 *"-"* 和 BigInt::toString(-_x_, _radix_) 的拼接字符串。
            1. 返回用基数 _radix_ 表示 _x_ 的字符串值。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-type">
      <h1>对象类型</h1>
      <p>每个 <dfn variants="是 Object,不是 Object">Object 类型</dfn>的实例，也简称为“对象”，表示一组属性的集合。每个属性要么是数据属性，要么是访问器属性：</p>
      <ul>
        <li>
          <dfn variants="数据属性">数据属性</dfn>将一个键值与一个 ECMAScript 语言值以及一组布尔属性关联起来。
        </li>
        <li>
          <dfn variants="访问器属性">访问器属性</dfn>将一个键值与一个或两个访问器函数以及一组布尔属性关联起来。访问器函数用于存储或获取与该属性相关联的 ECMAScript 语言值。
        </li>
      </ul>
      <p>对象的属性通过属性键唯一标识。<dfn id="property-key" variants="属性键" oldids="sec-ispropertykey">属性键</dfn>可以是字符串或符号。所有字符串和符号，包括空字符串，都是有效的属性键。<dfn id="property-name">属性名</dfn>是属性键为字符串的情况。</p>
      <p><dfn id="integer-index" variants="整数索引,integer-indexed">整数索引</dfn>是属性名 _n_，满足 CanonicalNumericIndexString(_n_) 返回一个在 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>53</sup> - 1) 的闭区间内的整数 Number。<dfn id="array-index" variants="数组索引">数组索引</dfn>是整数索引 _n_，且 CanonicalNumericIndexString(_n_) 返回一个在 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>32</sup> - 2) 的闭区间内的整数 Number。</p>
      <emu-note>
        <p>每个非负安全整数都有对应的整数索引。每个 32 位无符号整数（除 <emu-eqn>2<sup>32</sup> - 1</emu-eqn>）都有对应的数组索引。*"-0"* 既不是整数索引，也不是数组索引。</p>
      </emu-note>
      <p>属性键用于访问属性及其值。属性有两种访问方式：<em>获取</em>和<em>设置</em>，分别对应值的读取和赋值。可通过 get 和 set 访问的属性包括作为对象直接组成部分的<em>自身属性</em>和通过属性继承关系由其他关联对象提供的<em>继承属性</em>。继承属性可以是关联对象的自身属性或继承属性。对象的每个自身属性都必须有一个与该对象其他自身属性不同的键值。</p>
      <p>所有对象在逻辑上都是属性的集合，但对象有多种形式，不同形式在访问和操作属性时语义有所区别。参见 <emu-xref href="#sec-object-internal-methods-and-internal-slots"></emu-xref> 以了解对象的多种形式定义。</p>
      <p>此外，某些对象可调用，被称为函数或函数对象，详见下文。所有 ECMAScript 中的函数都是 Object 类型成员。</p>

      <emu-clause id="sec-property-attributes">
        <h1>属性特性</h1>
        <p>本规范使用属性（attributes）来定义和解释对象属性的状态，详见 <emu-xref href="#table-object-property-attributes"></emu-xref>。除非明确说明，每个属性的初始值为其默认值。</p>
        <emu-table id="table-object-property-attributes" caption="对象属性的特性" oldids="table-2,table-3,table-4,table-data-property-attributes,table-accessor-property-attributes,table-default-attribute-values">
          <table>
            <thead>
              <tr>
                <th>特性名称</th>
                <th>适用属性类型</th>
                <th>值域</th>
                <th>默认值</th>
                <th>描述</th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                数据属性
              </td>
              <td>
                一个 ECMAScript 语言值
              </td>
              <td>
                *undefined*
              </td>
              <td>
                通过 get 访问属性时获得的值。
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                数据属性
              </td>
              <td>
                布尔值
              </td>
              <td>
                *false*
              </td>
              <td>
                如果为 *false*，则 ECMAScript 代码通过 [[Set]] 尝试改变属性的 [[Value]] 特性不会成功。
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                访问器属性
              </td>
              <td>
                对象或 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                如果值是对象，则必须为函数对象。每次对属性进行 get 访问时，调用该函数的 [[Call]] 内部方法（参见 <emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>），参数列表为空，以获取属性值。
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                访问器属性
              </td>
              <td>
                对象或 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                如果值是对象，则必须为函数对象。每次对属性进行 set 访问时，调用该函数的 [[Call]] 内部方法（参见 <emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>），参数列表只包含要赋值的值。属性的 [[Set]] 内部方法的效果可以影响后续 [[Get]] 的返回值，但不是必须的。
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                数据属性或访问器属性
              </td>
              <td>
                布尔值
              </td>
              <td>
                *false*
              </td>
              <td>
                如果为 *true*，属性会被 for-in 枚举（参见 <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>）；否则，该属性被称为不可枚举。
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                数据属性或访问器属性
              </td>
              <td>
                布尔值
              </td>
              <td>
                *false*
              </td>
              <td>
                如果为 *false*，尝试删除属性、将其从数据属性变为访问器属性或反之，以及对其特性的任何修改（除了替换已有 [[Value]] 或设置 [[Writable]] 为 *false*）都不会成功。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>对象的内部方法与内部槽</h1>
        <p>ECMAScript 中对象的实际语义通过称为<em>内部方法</em>的算法来定义。每个 ECMAScript 引擎中的对象都关联一组内部方法，定义其运行时行为。这些内部方法不是 ECMAScript 语言的一部分，仅供规范说明之用。但 ECMAScript 的每个对象都必须符合其关联的内部方法的行为，具体实现方式由实现决定。</p>
        <p>内部方法名称是多态的。意味着不同对象值在调用相同内部方法名时可以执行不同的算法。被调用的实际对象是该方法的“目标”。如果在运行时算法实现尝试使用一个对象未支持的内部方法，则抛出 *TypeError* 异常。</p>
        <p>内部槽对应于与对象、Symbol 或私有名称关联的内部状态，被 ECMAScript 规范的各种算法使用。内部槽不是对象属性，也不会被继承。根据具体内部槽的规定，这些状态可以是任意 ECMAScript 类型值或特定 ECMAScript 规范类型值。除非另有说明，内部槽在创建对象、Symbol 或私有名称时分配，不能动态添加。除非另有说明，内部槽的初始值是 *undefined*。本规范中的各种算法会创建具有内部槽的值。但 ECMAScript 语言无法直接操作内部槽。</p>
        <p>所有对象都有名为 [[PrivateElements]] 的内部槽，是一个 PrivateElements 列表，表示对象的私有字段、方法和访问器的值。初始为一个空列表。</p>
        <p>规范中用双中括号 [[ ]] 标识内部方法和内部槽。</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref> 总结了本规范用于所有 ECMAScript 创建或操作的对象所适用的<em>基本内部方法</em>。每个对象必须实现所有这些基本内部方法的算法，但并不一定所有对象都用相同的算法。</p>
        <p><dfn id="ordinary-object" variants="普通对象">普通对象</dfn>是满足以下条件的对象：</p>
        <ul>
          <li>
            对于 <emu-xref href="#table-essential-internal-methods"></emu-xref> 列出的内部方法，对象采用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中定义的方法。
          </li>
          <li>
            如果对象有 [[Call]] 内部方法，则采用 <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 或 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref> 中定义的方法。
          </li>
          <li>
            如果对象有 [[Construct]] 内部方法，则采用 <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 或 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 中定义的方法。
          </li>
        </ul>
        <p><dfn id="exotic-object" variants="特殊对象">特殊对象</dfn>是不满足普通对象条件的对象。</p>
        <p>本规范通过对象的内部方法区分不同类型的特殊对象。如果一个对象在行为上等同于某种特殊对象（如数组特殊对象或绑定函数特殊对象），但没有实现该类型指定的所有内部方法，则不被视为该类型的特殊对象。</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref>和类似表格的“签名”列描述了每个内部方法的调用模式。调用模式总包括一个括号包裹的参数名列表。如果参数名与 ECMAScript 类型名相同，则表示该参数值必须为该类型。如果内部方法显式返回值，则参数列表后跟符号“→”和返回值类型名。签名中类型名指本规范 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 定义的类型，并补充如下额外类型名。“<em>any</em>”表示值可以是任意 ECMAScript 语言类型。</p>
        <p>除了参数之外，内部方法始终能访问作为方法调用目标的对象。</p>
        <p>内部方法隐式返回一个 Completion Record，要么是包装返回类型值的正常完成，要么是抛出完成。</p>
        <emu-table id="table-essential-internal-methods" caption="基本内部方法" oldids="table-5">
          <table>
            <thead>
              <tr>
                <th>
                  内部方法
                </th>
                <th>
                  签名
                </th>
                <th>
                  描述
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[GetPrototypeOf]]
              </td>
              <td>
                ( ) <b>→</b> Object | Null
              </td>
              <td>
                获取为此对象提供继承属性的对象。*null* 表示没有继承属性。
              </td>
            </tr>
            <tr>
              <td>
                [[SetPrototypeOf]]
              </td>
              <td>
                (Object | Null) <b>→</b> Boolean
              </td>
              <td>
                将此对象与另一个提供继承属性的对象关联。传递 *null* 表示没有继承属性。返回 *true* 表示操作成功，返回 *false* 表示操作未成功。
              </td>
            </tr>
            <tr>
              <td>
                [[IsExtensible]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                判断是否允许向此对象添加新属性。
              </td>
            </tr>
            <tr>
              <td>
                [[PreventExtensions]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                控制是否可向对象添加新属性。返回 *true* 表示操作成功，*false* 表示操作失败。
              </td>
            </tr>
            <tr>
              <td>
                [[GetOwnProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Undefined | Property Descriptor
              </td>
              <td>
                返回此对象自身属性中键为 _propertyKey_ 的属性描述符，若无则返回 *undefined*。
              </td>
            </tr>
            <tr>
              <td>
                [[DefineOwnProperty]]
              </td>
              <td>
                (_propertyKey_, _PropertyDescriptor_) <b>→</b> Boolean
              </td>
              <td>
                创建或更改自身属性（键为 _propertyKey_），使其状态与 _PropertyDescriptor_ 描述一致。成功时返回 *true*，否则返回 *false*。
              </td>
            </tr>
            <tr>
              <td>
                [[HasProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                返回布尔值，表示此对象是否已有自身或继承属性，其键为 _propertyKey_。
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                (_propertyKey_, _Receiver_) <b>→</b> <em>any</em>
              </td>
              <td>
                获取此对象中键为 _propertyKey_ 的属性值。若需执行 ECMAScript 代码以获取属性值，则 _Receiver_ 作为 *this* 值用于代码执行。
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                (_propertyKey_, _value_, _Receiver_) <b>→</b> Boolean
              </td>
              <td>
                将键为 _propertyKey_ 的属性值设为 _value_。若需执行 ECMAScript 代码以设置属性值，则 _Receiver_ 作为 *this* 值用于代码执行。成功返回 *true*，否则返回 *false*。
              </td>
            </tr>
            <tr>
              <td>
                [[Delete]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                删除自身属性键为 _propertyKey_ 的属性。删除失败且属性仍在时返回 *false*，否则返回 *true*。
              </td>
            </tr>
            <tr>
              <td>
                [[OwnPropertyKeys]]
              </td>
              <td>
                ( ) <b>→</b> 属性键列表
              </td>
              <td>
                返回对象所有自身属性键的列表。
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref> 总结了函数对象支持的附加基本内部方法。<dfn id="function-object" variants="函数对象">函数对象</dfn>是支持 [[Call]] 内部方法的对象。<dfn id="constructor" variants="构造函数">构造函数</dfn>是支持 [[Construct]] 内部方法的对象。每个支持 [[Construct]] 的对象都必须支持 [[Call]]，即每个构造函数也是函数对象。因此构造函数也可称为<em>构造函数对象</em>。</p>
        <emu-table id="table-additional-essential-internal-methods-of-function-objects" caption="函数对象的附加基本内部方法" oldids="table-6">
          <table>
            <thead>
              <tr>
                <th>
                  内部方法
                </th>
                <th>
                  签名
                </th>
                <th>
                  描述
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Call]]
              </td>
              <td>
                (<em>any</em>, <em>any</em> 列表) <b>→</b> <em>any</em>
              </td>
              <td>
                执行与此对象关联的代码。通过函数调用表达式调用。方法参数为 *this* 值及调用表达式传递的参数列表。实现此方法的对象为<em>可调用</em>对象。
              </td>
            </tr>
            <tr>
              <td>
                [[Construct]]
              </td>
              <td>
                (<em>any</em> 列表, Object) <b>→</b> Object
              </td>
              <td>
                创建对象。通过 `new` 操作符或 `super` 调用。第一个参数为构造器调用或 `super` 调用的参数列表，第二个参数为最初应用 `new` 操作符的对象。实现此方法的对象为<em>构造函数</em>。函数对象不一定是构造函数，非构造函数对象没有 [[Construct]] 方法。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>普通对象和标准特殊对象的基本内部方法语义在 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 中定义。如果实现不支持对某特殊对象指定的内部方法，则尝试该用法时必须抛出 *TypeError* 异常。</p>
      </emu-clause>

      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1>基本内部方法的不变量</h1>
        <p>ECMAScript 引擎中的对象的内部方法必须符合下列不变量。普通 ECMAScript 对象以及本规范中的所有标准特殊对象都保持这些不变量。ECMAScript Proxy 对象通过对 [[ProxyHandler]] 对象上的 trap 调用结果进行运行时检查来保持这些不变量。</p>
        <p>任何实现提供的特殊对象也必须为这些对象保持这些不变量。违反这些不变量可能导致 ECMAScript 代码行为不可预测并引发安全问题。但违反这些不变量决不能影响实现的内存安全。</p>
        <p>实现不得以任何方式绕过这些不变量，比如提供不强制不变量的方法接口来实现基本内部方法。</p>
        <h2>定义：</h2>
        <ul>
          <li>
            内部方法的<em>目标</em>是调用该内部方法的对象。
          </li>
          <li>
            如果目标的 [[IsExtensible]] 方法返回 *false* 或 [[PreventExtensions]] 方法返回 *true*，则称为<em>不可扩展</em>。
          </li>
          <li>
            <em>不存在</em>属性指在不可扩展目标对象上不存在的自身属性。
          </li>
          <li>
            所有对 <em>SameValue</em> 的引用均依照 SameValue 算法定义。
          </li>
        </ul>
        <h2>返回值：</h2>
        <p>任何内部方法返回的值必须是一个 Completion Record，包含以下之一：</p>
        <ul>
          <li>[[Type]] = ~normal~，[[Target]] = ~empty~，[[Value]] = 该内部方法下方“正常返回类型”对应的值，或</li>
          <li>[[Type]] = ~throw~，[[Target]] = ~empty~，[[Value]] = 任意 ECMAScript 语言值。</li>
        </ul>
        <emu-note>
          <p>内部方法不得返回 continue、break 或 return 类型的 Completion Record。</p>
        </emu-note>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Object 或 Null。
          </li>
          <li>
            如果目标为不可扩展，且 [[GetPrototypeOf]] 返回值 _V_，则未来对 [[GetPrototypeOf]] 的调用都应返回与 _V_ SameValue 的值。
          </li>
        </ul>
        <emu-note>
          <p>对象的原型链应有限（即从任意对象递归调用 [[GetPrototypeOf]] 最终应到达 *null*）。但如果原型链中包含未采用普通对象定义的特殊对象，则无法作为对象级不变量强制此要求。出现环形原型链时，访问对象属性可能导致无限循环。</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] ( _V_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果目标为不可扩展，[[SetPrototypeOf]] 必须返回 *false*，除非 _V_ 与目标已观察到的 [[GetPrototypeOf]] 值 SameValue。
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 [[IsExtensible]] 返回 *false*，则未来对目标的所有 [[IsExtensible]] 调用都必须返回 *false*。
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 [[PreventExtensions]] 返回 *true*，则未来对目标的所有 [[IsExtensible]] 调用都必须返回 *false*，且目标被视为不可扩展。
          </li>
        </ul>
        <h2>[[GetOwnProperty]] ( _P_ )</h2>
        <ul>
          <li>
            正常返回类型为 Property Descriptor 或 Undefined。
          </li>
          <li>
            如果返回值为 Property Descriptor，必须是完整的 Property Descriptor。
          </li>
          <li>
            如果 _P_ 被描述为不可配置、不可写的自身数据属性，则未来对 [[GetOwnProperty]] ( _P_ ) 的所有调用都必须返回 [[Value]] 与 _P_ 的 [[Value]] 属性 SameValue 的 Property Descriptor。
          </li>
          <li>
            如果 _P_ 除 [[Writable]] 和 [[Value]] 外的属性可能随时间变化，或属性可能被删除，则 _P_ 的 [[Configurable]] 属性必须为 *true*。
          </li>
          <li>
            如果 [[Writable]] 属性可能从 *false* 变为 *true*，则 [[Configurable]] 属性必须为 *true*。
          </li>
          <li>
            如果目标为不可扩展且 _P_ 不存在，则未来对目标的所有 [[GetOwnProperty]] (_P_) 调用都必须描述 _P_ 为不存在（即返回 *undefined*）。
          </li>
        </ul>
        <emu-note>
          <p>由第三条不变量可知，如果某属性被描述为数据属性且可能随时间返回不同值，则无论是否暴露机制修改值，只要有可能，[[Writable]] 和 [[Configurable]] 属性至少有一个必须为 *true*。</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] ( _P_, _Desc_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            除非满足以下之一，否则 [[DefineOwnProperty]] 必须返回 *false*，如果 _P_ 已被观察为目标的不可配置自身属性：
            <ol>
              <li>
                _P_ 是可写数据属性。不可配置且可写的数据属性可以变为不可配置且不可写的数据属性。
              </li>
              <li>
                _Desc_ 的所有属性与 _P_ 的属性 SameValue。
              </li>
            </ol>
          </li>
          <li>
            如果目标为不可扩展且 _P_ 是不存在的自身属性，则 [[DefineOwnProperty]] (_P_, _Desc_) 必须返回 *false*。即不可扩展对象不能添加新属性。
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身数据或访问器属性，则 [[HasProperty]] 必须返回 *true*。
          </li>
        </ul>
        <h2>[[Get]] ( _P_, _Receiver_ )</h2>
        <ul>
          <li>
            正常返回类型为任意 ECMAScript 语言类型。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置、不可写自身数据属性且值为 _V_，则 [[Get]] 必须返回与 _V_ SameValue 的值。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身访问器属性且 [[Get]] 属性为 *undefined*，则 [[Get]] 操作必须返回 *undefined*。
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置、不可写自身数据属性，则除非 _V_ 与 _P_ 的 [[Value]] 属性 SameValue，[[Set]] 必须返回 *false*。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身访问器属性且 [[Set]] 属性为 *undefined*，则 [[Set]] 操作必须返回 *false*。
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身数据或访问器属性，则 [[Delete]] 必须返回 *false*。
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 List。
          </li>
          <li>
            返回的 List 不能有重复项。
          </li>
          <li>
            返回的 List 的每个元素必须是属性键。
          </li>
          <li>
            返回的 List 至少含有所有已观察到的不可配置自身属性的键。
          </li>
          <li>
            如果目标为不可扩展，则返回的 List 只能包含所有可通过 [[GetOwnProperty]] 观察到的自身属性键。
          </li>
        </ul>
        <h2>[[Call]] ( )</h2>
        <ul>
          <li>
            正常返回类型为任意 ECMAScript 语言类型。
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Object。
          </li>
          <li>
            目标还必须有 [[Call]] 内部方法。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>知名内置对象</h1>
        <p>知名内置对象是本规范的算法显式引用的内置对象，通常具有特定于“域”（realm）的身份。除非另有说明，每个内置对象实际对应一组类似对象，每个域各一个。</p>
        <p>在本规范中，%name% 表示当前域关联的对应名称的内置对象。%name.a.b% 表示在执行任何 ECMAScript 代码之前，访问内置对象 %name% 的属性 "a"，再访问该属性的 "b" 属性。当前域和其内置对象的确定见 <emu-xref href="#sec-execution-contexts"></emu-xref>。知名内置对象列表见 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>。</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="知名内置对象" oldids="table-7">
          <table>
            <thead>
              <tr>
                <th>
                  内置名称
                </th>
                <th>
                  全局名称
                </th>
                <th>
                  ECMAScript 语言关联
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                `AggregateError` 构造函数（参见 <emu-xref href="#sec-aggregate-error-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                Array 构造函数（参见 <emu-xref href="#sec-array-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                ArrayBuffer 构造函数（参见 <emu-xref href="#sec-arraybuffer-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                数组迭代器对象的原型（参见 <emu-xref href="#sec-array-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Async-from-Sync 迭代器对象的原型（参见 <emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                async 函数对象的构造函数（参见 <emu-xref href="#sec-async-function-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                async 生成器函数对象的构造函数（参见 <emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                async 生成器对象的原型（参见 <emu-xref href="#sec-asyncgenerator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                所有标准内置 async 迭代器对象的间接继承对象
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                `Atomics` 对象（参见 <emu-xref href="#sec-atomics-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                BigInt 构造函数（参见 <emu-xref href="#sec-bigint-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                BigInt64Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                BigUint64Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                Boolean 构造函数（参见 <emu-xref href="#sec-boolean-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                DataView 构造函数（参见 <emu-xref href="#sec-dataview-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                Date 构造函数（参见 <emu-xref href="#sec-date-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                `decodeURI` 函数（参见 <emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                `decodeURIComponent` 函数（参见 <emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                `encodeURI` 函数（参见 <emu-xref href="#sec-encodeuri-uri"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                `encodeURIComponent` 函数（参见 <emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                Error 构造函数（参见 <emu-xref href="#sec-error-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                `eval` 函数（参见 <emu-xref href="#sec-eval-x"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                EvalError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                FinalizationRegistry 构造函数（参见 <emu-xref href="#sec-finalization-registry-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float16Array%
              </td>
              <td>
                `Float16Array`
              </td>
              <td>
                Float16Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                Float32Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                Float64Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                For-In 迭代器对象的原型（参见 <emu-xref href="#sec-for-in-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                Function 构造函数（参见 <emu-xref href="#sec-function-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                生成器函数对象的构造函数（参见 <emu-xref href="#sec-generatorfunction-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                生成器对象的原型（参见 <emu-xref href="#sec-generator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                Int8Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                Int16Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                Int32Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                `isFinite` 函数（参见 <emu-xref href="#sec-isfinite-number"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                `isNaN` 函数（参见 <emu-xref href="#sec-isnan-number"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Iterator%
              </td>
              <td>
                `Iterator`
              </td>
              <td>
                `Iterator` 构造函数（参见 <emu-xref href="#sec-iterator-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %IteratorHelperPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator Helper 对象的原型（参见 <emu-xref href="#sec-%iteratorhelperprototype%-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                `JSON` 对象（参见 <emu-xref href="#sec-json-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                Map 构造函数（参见 <emu-xref href="#sec-map-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Map 迭代器对象的原型（参见 <emu-xref href="#sec-map-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                `Math` 对象（参见 <emu-xref href="#sec-math-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                Number 构造函数（参见 <emu-xref href="#sec-number-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                Object 构造函数（参见 <emu-xref href="#sec-object-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                `parseFloat` 函数（参见 <emu-xref href="#sec-parsefloat-string"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                `parseInt` 函数（参见 <emu-xref href="#sec-parseint-string-radix"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                Promise 构造函数（参见 <emu-xref href="#sec-promise-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                Proxy 构造函数（参见 <emu-xref href="#sec-proxy-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                RangeError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                ReferenceError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                `Reflect` 对象（参见 <emu-xref href="#sec-reflect-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                RegExp 构造函数（参见 <emu-xref href="#sec-regexp-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                正则表达式字符串迭代器对象的原型（参见 <emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                Set 构造函数（参见 <emu-xref href="#sec-set-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Set 迭代器对象的原型（参见 <emu-xref href="#sec-set-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                SharedArrayBuffer 构造函数（参见 <emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                String 构造函数（参见 <emu-xref href="#sec-string-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                字符串迭代器对象的原型（参见 <emu-xref href="#sec-string-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                Symbol 构造函数（参见 <emu-xref href="#sec-symbol-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                SyntaxError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                一个函数对象，总是抛出新的 %TypeError% 实例
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                所有类型化数组构造函数的超类（参见 <emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                TypeError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                Uint8Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                Uint8ClampedArray 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                Uint16Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                Uint32Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                URIError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                WeakMap 构造函数（参见 <emu-xref href="#sec-weakmap-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                WeakRef 构造函数（参见 <emu-xref href="#sec-weak-ref-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                WeakSet 构造函数（参见 <emu-xref href="#sec-weakset-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WrapForValidIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator.from 返回的包装迭代器对象的原型（参见 <emu-xref href="#sec-%wrapforvaliditeratorprototype%-object"></emu-xref>）
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>更多条目见 <emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript 规范类型</h1>
    <p>规范类型对应于算法中用于描述 ECMAScript 语言结构和 ECMAScript 语言类型语义的元值。规范类型包括 Reference Record、List、Completion Record、Property Descriptor、Environment Record、Abstract Closure 和 Data Block。规范类型值是规范中的产物，不一定对应于 ECMAScript 实现中的具体实体。规范类型值可用于描述 ECMAScript 表达式求值的中间结果，但这些值不能作为对象的属性或 ECMAScript 语言变量的值存储。</p>

    <emu-clause id="sec-enum-specification-type">
      <h1>枚举规范类型</h1>
      <p><dfn variants="enum,enums">枚举</dfn>是规范内部使用的值，不能被 ECMAScript 代码直接观察。枚举用 ~无衬线体~ 表示。例如，Completion Record 的 [[Type]] 字段会取 ~normal~、~return~ 或 ~throw~ 等值。枚举除了名称外没有其他特性。枚举的名称仅用于与其他枚举区分，并不暗示其在上下文中的用途或意义。</p>
    </emu-clause>

    <emu-clause id="sec-list-and-record-specification-type">
      <h1>List 和 Record 规范类型</h1>
      <p><dfn variants="Lists">List</dfn> 类型用于解释参数列表（参见 <emu-xref href="#sec-argument-lists"></emu-xref>）在 `new` 表达式、函数调用以及需要简单有序值列表的其他算法中的求值。List 类型的值就是包含各个值的有序元素序列，序列长度可任意。List 的元素可用 0 起始的索引随机访问。为方便记号，可用类似数组的语法访问 List 元素。例如，_arguments_[2] 表示 List _arguments_ 的第 3 个元素。</p>
      <p>当算法遍历 List 元素但未指定顺序时，使用 List 元素的原有顺序。</p>
      <p>在本规范中，为方便记号，可用字面量语法表达新的 List 值。例如，« 1, 2 » 定义了一个有两个元素的 List 值，每个元素初始化为特定值。空 List 可写作 « »。</p>
      <p>在本规范中，“_A_、_B_... 的<dfn id="list-concatenation">列表拼接</dfn>”（每个参数都是可能为空的 List）表示一个新 List，其元素是各参数元素（按顺序）拼接而成。</p>
      <p>对于字符串 List，“按<dfn id="lexicographic-code-unit-order">字典序码位顺序</dfn>排序”意指按较短字符串长度以内各码位的数值排序，如相等则短字符串排前，详见抽象操作 IsLessThan。</p>
      <p><dfn variants="Records">Record</dfn> 类型用于规范算法中的数据聚合。Record 类型值由一个或多个具名字段组成，每个字段的值为 ECMAScript 语言值或规范值。字段名总用双括号包裹，例如 [[Value]]。</p>
      <p>在规范中，为方便记号，可用类似对象字面量的语法表达 Record 值。例如，{ [[Field1]]: 42, [[Field2]]: *false*, [[Field3]]: ~empty~ } 表示一个包含三个字段的 Record 值，每个字段初始化为特定值。字段名顺序无关紧要，未列出的字段视为不存在。</p>
      <p>在规范文本和算法中，可用点号表示法引用 Record 的某个字段。例如，若 R 为上文的 Record，则 R.[[Field2]] 表示“R 的 [[Field2]] 字段”。</p>
      <p>常用字段组合的 Record 可以命名，并作为字面量前缀，以标识描述的聚合类型。例如：PropertyDescriptor { [[Value]]: 42, [[Writable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>

    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>Set 和 Relation 规范类型</h1>
      <p><em>Set</em> 类型用于说明内存模型中无序元素集合。它不同于 ECMAScript 集合类型 Set。为区分，规范中 ECMAScript 集合类型始终称为“Set 对象”。Set 类型值是元素集合，每个元素只出现一次。元素可加入或移除集合，集合之间可以并集、交集或相减。</p>
      <p><dfn variants="Relations">Relation</dfn> 类型用于说明集合上的约束。Relation 类型值是其值域上的有序对集合。例如，事件上的 Relation 是事件有序对的集合。若 Relation _R_，值域中的 _a_ 和 _b_，则 _a_ _R_ _b_ 表示有序对 (_a_, _b_) 属于 _R_。Relation 是满足某些条件的<dfn id="least-relation">最小 Relation</dfn>，即满足条件的最小 Relation。</p>
      <p><dfn variants="strict partial orders">严格偏序</dfn>是满足以下条件的 Relation 值 _R_。</p>
      <ul>
        <li>
          <p>对 _R_ 的值域内所有 _a_、_b_、_c_：</p>
          <ul>
            <li>不存在 _a_ _R_ _a_，且</li>
            <li>若 _a_ _R_ _b_ 且 _b_ _R_ _c_，则 _a_ _R_ _c_。</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>上述两个条件分别称为反自反性和传递性。</p>
      </emu-note>
      <p><dfn variants="strict total orders">严格全序</dfn>是满足以下条件的 Relation 值 _R_。</p>
      <ul>
        <li>
          <p>对 _R_ 的值域内所有 _a_、_b_、_c_：</p>
          <ul>
            <li>_a_ 等于 _b_ 或 _a_ _R_ _b_ 或 _b_ _R_ _a_，且</li>
            <li>不存在 _a_ _R_ _a_，且</li>
            <li>若 _a_ _R_ _b_ 且 _b_ _R_ _c_，则 _a_ _R_ _c_。</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>上述三个条件分别称为全序性、反自反性和传递性。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-completion-record-specification-type">
      <h1>Completion Record 规范类型</h1>
      <p><dfn variants="Completion Records">Completion Record</dfn> 规范类型用于解释运行时值和控制流的传播，如语句（`break`、`continue`、`return` 和 `throw`）实现的非局部控制转移行为。</p>
      <p>Completion Record 包含 <emu-xref href="#table-completion-record-fields"></emu-xref> 定义的字段。</p>
      <emu-table id="table-completion-record-fields" caption="Completion Record 字段" oldids="table-8">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              ~normal~、~break~、~continue~、~return~ 或 ~throw~
            </td>
            <td>
              发生的完成类型。
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              除 Completion Record 外的任何值
            </td>
            <td>
              产生的值。
            </td>
          </tr>
          <tr>
            <td>
              [[Target]]
            </td>
            <td>
              字符串或 ~empty~
            </td>
            <td>
              用于定向控制转移的目标标签。
            </td>
          </tr>
        </table>
      </emu-table>
      <p>下列术语有时用于指代 Completion Record：</p>
      <ul>
        <li><dfn variants="normal completions">正常完成</dfn>指 [[Type]] 值为 ~normal~ 的 Completion Record。</li>
        <li><dfn variants="break completions">break 完成</dfn>指 [[Type]] 值为 ~break~ 的 Completion Record。</li>
        <li><dfn variants="continue completions">continue 完成</dfn>指 [[Type]] 值为 ~continue~ 的 Completion Record。</li>
        <li><dfn variants="return completions">return 完成</dfn>指 [[Type]] 值为 ~return~ 的 Completion Record。</li>
        <li><dfn variants="throw completions">throw 完成</dfn>指 [[Type]] 值为 ~throw~ 的 Completion Record。</li>
        <li><dfn variants="abrupt completions">异常完成</dfn>指 [[Type]] 值不是 ~normal~ 的 Completion Record。</li>
        <li>“<dfn variants="normal completions containing">包含某类型值的正常完成</dfn>”指 [[Value]] 字段为该类型值的正常完成。</li>
      </ul>
      <p>规范中定义的可调用对象只返回正常完成或 throw 完成。返回其他类型的 Completion Record 属于编辑错误。</p>
      <p>实现自定义的可调用对象也必须只返回正常完成或 throw 完成。</p>

      <emu-clause id="sec-normalcompletion" type="abstract operation">
        <h1>
          NormalCompletion (
            _value_: 除 Completion Record 外的任何值,
          ): 正常完成
        </h1>
        <dl class="header">
          <dt>跳过 return 检查</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. 返回 Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throwcompletion" type="abstract operation">
        <h1>
          ThrowCompletion (
            _value_: 一个 ECMAScript 语言值,
          ): throw 完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returncompletion" type="abstract operation">
        <h1>
          ReturnCompletion (
            _value_: 一个 ECMAScript 语言值,
          ): return 完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-updateempty" type="abstract operation">
        <h1>
          UpdateEmpty (
            _completionRecord_: 一个 Completion Record,
            _value_: 除 Completion Record 外的任何值,
          ): 一个 Completion Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：若 _completionRecord_ 是 return 完成或 throw 完成，则 _completionRecord_.[[Value]] 不是 ~empty~。
          1. 若 _completionRecord_.[[Value]] 不是 ~empty~，返回 ? _completionRecord_。
          1. 返回 Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>Reference Record 规范类型</h1>
      <p><dfn variants="Reference Records">Reference Record</dfn> 类型用于解释如 `delete`、`typeof`、赋值运算符、`super` 关键字等操作的行为。例如，赋值的左操作数应产生一个 Reference Record。</p>
      <p>Reference Record 是已解析的名称或（可能尚未解析的）属性绑定；其字段定义见 <emu-xref href="#table-reference-record-fields"></emu-xref>。</p>

      <emu-table id="table-reference-record-fields" caption="Reference Record 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td oldids="sec-getbase,ao-getbase">[[Base]]</td>
            <td>一个 ECMAScript 语言值、Environment Record 或 ~unresolvable~</td>
            <td>持有绑定的值或 Environment Record。[[Base]] 为 ~unresolvable~ 表示绑定无法解析。</td>
          </tr>
          <tr>
            <td oldids="sec-getreferencedname,ao-getreferencedname">[[ReferencedName]]</td>
            <td>一个 ECMAScript 语言值或 Private Name</td>
            <td>绑定的名称。若 [[Base]] 为 Environment Record，则总为字符串。否则，可能为除字符串和符号外的 ECMAScript 语言值，直到执行 ToPropertyKey。</td>
          </tr>
          <tr>
            <td oldids="sec-isstrictreference,ao-isstrictreference">[[Strict]]</td>
            <td>布尔值</td>
            <td>若 Reference Record 来源于严格模式代码，则为 *true*，否则为 *false*。</td>
          </tr>
          <tr>
            <td>[[ThisValue]]</td>
            <td>一个 ECMAScript 语言值或 ~empty~</td>
            <td>若非 ~empty~，则代表用 `super` 关键字表达的属性绑定，称为 <dfn id="super-reference-record" oldids="super-reference" variants="Super Reference Records">Super Reference Record</dfn>，其 [[Base]] 不会是 Environment Record。此时 [[ThisValue]] 字段保存创建 Reference Record 时的 *this* 值。</td>
          </tr>
        </table>
      </emu-table>

      <p>本规范使用以下抽象操作处理 Reference Record：</p>

      <emu-clause id="sec-ispropertyreference" type="abstract operation" oldids="ao-ispropertyreference">
        <h1>
          IsPropertyReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[Base]] 为 ~unresolvable~，返回 *false*。
          1. 若 _V_.[[Base]] 为 Environment Record，返回 *false*；否则返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" type="abstract operation" oldids="ao-isunresolvablereference">
        <h1>
          IsUnresolvableReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[Base]] 为 ~unresolvable~，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" type="abstract operation" oldids="ao-issuperreference">
        <h1>
          IsSuperReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[ThisValue]] 非 ~empty~，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isprivatereference" type="abstract operation">
        <h1>
          IsPrivateReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[ReferencedName]] 是 Private Name，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvalue" type="abstract operation">
        <h1>
          GetValue (
            _V_: 一个 Reference Record 或 ECMAScript 语言值,
          ): 返回包含 ECMAScript 语言值的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_ 不是 Reference Record，返回 _V_。
          1. 若 IsUnresolvableReference(_V_) 为 *true*，抛出 *ReferenceError* 异常。
          1. 若 IsPropertyReference(_V_) 为 *true*，
            1. [id="step-getvalue-toobject"] 令 _baseObj_ 为 ? ToObject(_V_.[[Base]])。
            1. 若 IsPrivateReference(_V_) 为 *true*，
              1. 返回 ? PrivateGet(_baseObj_, _V_.[[ReferencedName]])。
            1. 若 _V_.[[ReferencedName]] 不是属性键，
              1. 令 _V_.[[ReferencedName]] 为 ? ToPropertyKey(_V_.[[ReferencedName]])。
            1. 返回 ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_))。
          1. 否则，
            1. 令 _base_ 为 _V_.[[Base]]。
            1. 断言：_base_ 是 Environment Record。
            1. 返回 ? <emu-meta effects="user-code">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]])（参见 <emu-xref href="#sec-environment-records"></emu-xref>）。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-getvalue-toobject"></emu-xref> 可能创建的对象仅在上述抽象操作和普通对象 [[Get]] 内部方法中可访问。实现可选择避免实际创建该对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" type="abstract operation">
        <h1>
          PutValue (
            _V_: 一个 Reference Record 或 ECMAScript 语言值,
            _W_: 一个 ECMAScript 语言值,
          ): 返回包含 ~unused~ 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_ 不是 Reference Record，抛出 *ReferenceError* 异常。
          1. 若 IsUnresolvableReference(_V_) 为 *true*，
            1. 若 _V_.[[Strict]] 为 *true*，抛出 *ReferenceError* 异常。
            1. 令 _globalObj_ 为 GetGlobalObject()。
            1. 执行 ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*)。
            1. 返回 ~unused~。
          1. 若 IsPropertyReference(_V_) 为 *true*，
            1. [id="step-putvalue-toobject"] 令 _baseObj_ 为 ? ToObject(_V_.[[Base]])。
            1. 若 IsPrivateReference(_V_) 为 *true*，
              1. 返回 ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_)。
            1. 若 _V_.[[ReferencedName]] 不是属性键，
              1. 令 _V_.[[ReferencedName]] 为 ? ToPropertyKey(_V_.[[ReferencedName]])。
            1. 令 _succeeded_ 为 ? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_))。
            1. 若 _succeeded_ 为 *false* 且 _V_.[[Strict]] 为 *true*，抛出 *TypeError* 异常。
            1. 返回 ~unused~。
          1. 否则，
            1. 令 _base_ 为 _V_.[[Base]]。
            1. 断言：_base_ 是 Environment Record。
            1. 返回 ? <emu-meta effects="user-code">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]])（参见 <emu-xref href="#sec-environment-records"></emu-xref>）。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-putvalue-toobject"></emu-xref> 可能创建的对象仅在上述抽象操作和普通对象 [[Set]] 内部方法中可访问。实现可选择避免实际创建该对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getthisvalue" type="abstract operation">
        <h1>
          GetThisValue (
            _V_: 一个 Reference Record,
          ): 一个 ECMAScript 语言值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsPropertyReference(_V_) 为 *true*。
          1. 若 IsSuperReference(_V_) 为 *true*，返回 _V_.[[ThisValue]]；否则返回 _V_.[[Base]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: 一个 Reference Record,
            _W_: 一个 ECMAScript 语言值,
          ): 返回包含 ~unused~ 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsUnresolvableReference(_V_) 为 *false*。
          1. 令 _base_ 为 _V_.[[Base]]。
          1. 断言：_base_ 是 Environment Record。
          1. 返回 ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeprivatereference" type="abstract operation">
        <h1>
          MakePrivateReference (
            _baseValue_: 一个 ECMAScript 语言值,
            _privateIdentifier_: 字符串,
          ): 一个 Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
          1. 断言：_privateEnv_ 不为 *null*。
          1. 令 _privateName_ 为 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)。
          1. 返回 Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-descriptor-specification-type">
      <h1>Property Descriptor 规范类型</h1>
      <p><dfn variants="Property Descriptors">Property Descriptor</dfn> 类型用于解释对象属性特性的操作及具现。Property Descriptor 是一个包含零个或多个字段的 Record，每个字段名为特性名，值为 <emu-xref href="#sec-property-attributes"></emu-xref> 所定义的特性值。本规范用 “PropertyDescriptor” 作为字面量描述 Property Descriptor Record 的标签名称。</p>
      <p>Property Descriptor 值可根据某些字段的存在或用途进一步分为数据 Property Descriptor 和访问器 Property Descriptor。包含 [[Value]] 或 [[Writable]] 字段的为数据 Property Descriptor；包含 [[Get]] 或 [[Set]] 字段的为访问器 Property Descriptor。任意 Property Descriptor 都可包含 [[Enumerable]] 和 [[Configurable]] 字段。Property Descriptor 值不能同时为数据和访问器 Property Descriptor，但可以两者都不是（此时为通用 Property Descriptor）。<dfn>完全填充的 Property Descriptor</dfn>指为访问器 Property Descriptor 或数据 Property Descriptor 且已定义所有对应字段（见 <emu-xref href="#table-object-property-attributes"></emu-xref>）。</p>
      <p>本规范用以下抽象操作处理 Property Descriptor 值：</p>

      <emu-clause id="sec-isaccessordescriptor" type="abstract operation">
        <h1>
          IsAccessorDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 有 [[Get]] 字段，返回 *true*。
          1. 若 _Desc_ 有 [[Set]] 字段，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdatadescriptor" type="abstract operation">
        <h1>
          IsDataDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 有 [[Value]] 字段，返回 *true*。
          1. 若 _Desc_ 有 [[Writable]] 字段，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isgenericdescriptor" type="abstract operation">
        <h1>
          IsGenericDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，返回 *false*。
          1. 若 IsDataDescriptor(_Desc_) 为 *true*，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frompropertydescriptor" type="abstract operation">
        <h1>
          FromPropertyDescriptor (
            _Desc_: 一个 Property Descriptor 或 *undefined*,
          ): 一个对象或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 为 *undefined*，返回 *undefined*。
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 断言：_obj_ 是可扩展的普通对象且无自身属性。
          1. 若 _Desc_ 有 [[Value]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"value"*, _Desc_.[[Value]])。
          1. 若 _Desc_ 有 [[Writable]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"writable"*, _Desc_.[[Writable]])。
          1. 若 _Desc_ 有 [[Get]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"get"*, _Desc_.[[Get]])。
          1. 若 _Desc_ 有 [[Set]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"set"*, _Desc_.[[Set]])。
          1. 若 _Desc_ 有 [[Enumerable]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"enumerable"*, _Desc_.[[Enumerable]])。
          1. 若 _Desc_ 有 [[Configurable]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"configurable"*, _Desc_.[[Configurable]])。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-topropertydescriptor" type="abstract operation">
        <h1>
          ToPropertyDescriptor (
            _Obj_: 一个 ECMAScript 语言值,
          ): 返回包含 Property Descriptor 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Obj_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _desc_ 为一个初始无字段的新 Property Descriptor。
          1. 令 _hasEnumerable_ 为 ? HasProperty(_Obj_, *"enumerable"*)。
          1. 若 _hasEnumerable_ 为 *true*，
            1. 令 _enumerable_ 为 ToBoolean(? Get(_Obj_, *"enumerable"*))。
            1. 设置 _desc_.[[Enumerable]] 为 _enumerable_。
          1. 令 _hasConfigurable_ 为 ? HasProperty(_Obj_, *"configurable"*)。
          1. 若 _hasConfigurable_ 为 *true*，
            1. 令 _configurable_ 为 ToBoolean(? Get(_Obj_, *"configurable"*))。
            1. 设置 _desc_.[[Configurable]] 为 _configurable_。
          1. 令 _hasValue_ 为 ? HasProperty(_Obj_, *"value"*)。
          1. 若 _hasValue_ 为 *true*，
            1. 令 _value_ 为 ? Get(_Obj_, *"value"*)。
            1. 设置 _desc_.[[Value]] 为 _value_。
          1. 令 _hasWritable_ 为 ? HasProperty(_Obj_, *"writable"*)。
          1. 若 _hasWritable_ 为 *true*，
            1. 令 _writable_ 为 ToBoolean(? Get(_Obj_, *"writable"*))。
            1. 设置 _desc_.[[Writable]] 为 _writable_。
          1. 令 _hasGet_ 为 ? HasProperty(_Obj_, *"get"*)。
          1. 若 _hasGet_ 为 *true*，
            1. 令 _getter_ 为 ? Get(_Obj_, *"get"*)。
            1. 若 IsCallable(_getter_) 为 *false* 且 _getter_ 不为 *undefined*，抛出 *TypeError* 异常。
            1. 设置 _desc_.[[Get]] 为 _getter_。
          1. 令 _hasSet_ 为 ? HasProperty(_Obj_, *"set"*)。
          1. 若 _hasSet_ 为 *true*，
            1. 令 _setter_ 为 ? Get(_Obj_, *"set"*)。
            1. 若 IsCallable(_setter_) 为 *false* 且 _setter_ 不为 *undefined*，抛出 *TypeError* 异常。
            1. 设置 _desc_.[[Set]] 为 _setter_。
          1. 若 _desc_ 有 [[Get]] 字段或 [[Set]] 字段，
            1. 若 _desc_ 有 [[Value]] 字段或 [[Writable]] 字段，抛出 *TypeError* 异常。
          1. 返回 _desc_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-completepropertydescriptor" type="abstract operation">
        <h1>
          CompletePropertyDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _like_ 为 Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。
          1. 若 IsGenericDescriptor(_Desc_) 为 *true* 或 IsDataDescriptor(_Desc_) 为 *true*，
            1. 若 _Desc_ 无 [[Value]] 字段，设置 _Desc_.[[Value]] 为 _like_.[[Value]]。
            1. 若 _Desc_ 无 [[Writable]] 字段，设置 _Desc_.[[Writable]] 为 _like_.[[Writable]]。
          1. 否则，
            1. 若 _Desc_ 无 [[Get]] 字段，设置 _Desc_.[[Get]] 为 _like_.[[Get]]。
            1. 若 _Desc_ 无 [[Set]] 字段，设置 _Desc_.[[Set]] 为 _like_.[[Set]]。
          1. 若 _Desc_ 无 [[Enumerable]] 字段，设置 _Desc_.[[Enumerable]] 为 _like_.[[Enumerable]]。
          1. 若 _Desc_ 无 [[Configurable]] 字段，设置 _Desc_.[[Configurable]] 为 _like_.[[Configurable]]。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-and-environment-record-specification-types">
      <h1>Environment Record 规范类型</h1>
      <p>Environment Record 类型用于解释嵌套函数和块中的名称解析行为。此类型及其操作定义见 <emu-xref href="#sec-environment-records"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-closure">
      <h1>Abstract Closure 规范类型</h1>
      <p><dfn variants="Abstract Closures">Abstract Closure</dfn> 规范类型用于引用算法步骤及一组值。Abstract Closure 是元值，用函数调用风格如 _closure_(_arg1_, _arg2_) 调用。和抽象操作类似，调用时执行 Abstract Closure 描述的算法步骤。</p>
      <p>创建 Abstract Closure 的算法步骤，用 “capture” 和别名列表描述需捕获的值。创建时，按别名捕获当时关联的值。指定 Abstract Closure 被调用时的算法步骤时，每个捕获值都用其别名引用。</p>
      <p>若 Abstract Closure 返回 Completion Record，则必须是正常完成或 throw 完成。</p>
      <p>Abstract Closure 通常作为其他算法的一部分内联创建，示例如下：</p>
      <emu-alg example>
        1. 令 _addend_ 为 41。
        1. 令 _closure_ 为新建 Abstract Closure，参数 (_x_)，捕获 _addend_，调用时执行以下步骤：
          1. 返回 _x_ + _addend_。
        1. 令 _val_ 为 _closure_(1)。
        1. 断言：_val_ 为 42。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-data-blocks">
      <h1>数据块</h1>
      <p><dfn variants="Data Blocks">Data Block</dfn> 规范类型用于描述一段独立且可变的字节（8 位）数值序列。<dfn variants="byte values">字节值</dfn>是 0 到 255 的整数。Data Block 值创建时拥有固定数量字节，每个初始值为 0。</p>
      <p>在规范中，为方便记号，可用类似数组的语法访问 Data Block 的各字节。该记号将 Data Block 视为 0 起始<emu-not-ref>整数索引</emu-not-ref>的字节序列。例如，若 _db_ 为 5 字节 Data Block，则 _db_[2] 用于访问第 3 个字节。</p>
      <p>可被多个 agent 并发引用的驻留于内存的数据块称为 <dfn variants="Shared Data Blocks">Shared Data Block</dfn>。Shared Data Block 有一个用于相等性测试的<em>无地址</em>身份：它不是绑定到任何进程的虚拟地址，而是与所代表的内存位置集合绑定。只有包含的内存位置集合相等，两数据块才相等，否则不等且其集合交集为空。Shared Data Block 可与 Data Block 区分。</p>
      <p>Shared Data Block 的语义由内存模型通过 Shared Data Block 事件定义。下述抽象操作引入 Shared Data Block 事件，并作为求值语义与内存模型事件语义的接口。事件构成候选执行，内存模型对其进行筛选。完整语义参见内存模型。</p>
      <p>Shared Data Block 事件由内存模型定义的 Record 表示。</p>
      <p>本规范用以下抽象操作处理 Data Block 值：</p>

      <emu-clause id="sec-createbytedatablock" type="abstract operation">
        <h1>
          CreateByteDataBlock (
            _size_: 非负整数,
          ): 返回包含 Data Block 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _size_ > 2<sup>53</sup> - 1，抛出 *RangeError* 异常。
          1. 令 _db_ 为由 _size_ 字节组成的新 Data Block 值。若无法创建该 Data Block，抛出 *RangeError* 异常。
          1. 将 _db_ 的所有字节设为 0。
          1. 返回 _db_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createsharedbytedatablock" type="abstract operation">
        <h1>
          CreateSharedByteDataBlock (
            _size_: 非负整数,
          ): 返回包含 Shared Data Block 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _db_ 为由 _size_ 字节组成的新 Shared Data Block 值。若无法创建该 Shared Data Block，抛出 *RangeError* 异常。
          1. 令 _execution_ 为当前 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
          1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
          1. 令 _zero_ 为 « 0 »。
          1. 对 _db_ 的每个索引 _i_，
            1. 将 WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } 添加到 _eventsRecord_.[[EventList]]。
          1. 返回 _db_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-copydatablockbytes" type="abstract operation">
        <h1>
          CopyDataBlockBytes (
            _toBlock_: Data Block 或 Shared Data Block,
            _toIndex_: 非负整数,
            _fromBlock_: Data Block 或 Shared Data Block,
            _fromIndex_: 非负整数,
            _count_: 非负整数,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_fromBlock_ 和 _toBlock_ 是不同值。
          1. 令 _fromSize_ 为 _fromBlock_ 的字节数。
          1. 断言：_fromIndex_ + _count_ ≤ _fromSize_。
          1. 令 _toSize_ 为 _toBlock_ 的字节数。
          1. 断言：_toIndex_ + _count_ ≤ _toSize_。
          1. 当 _count_ > 0 时重复：
            1. 若 _fromBlock_ 是 Shared Data Block，
              1. 令 _execution_ 为当前 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
              1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
              1. 令 _bytes_ 为仅有一个由非确定性选择的字节值的 List。
              1. 注：在实现中，_bytes_ 是底层硬件非原子读指令的结果。非确定性由内存模型语义规定，以描述弱一致性硬件的可观察行为。
              1. 令 _readEvent_ 为 ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }。
              1. 将 _readEvent_ 添加到 _eventsRecord_.[[EventList]]。
              1. 将 Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } 添加到 _execution_.[[ChosenValues]]。
              1. 若 _toBlock_ 是 Shared Data Block，
                1. 将 WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } 添加到 _eventsRecord_.[[EventList]]。
              1. 否则，
                1. 设置 _toBlock_[_toIndex_] 为 _bytes_[0]。
            1. 否则，
              1. 断言：_toBlock_ 不是 Shared Data Block。
              1. 设置 _toBlock_[_toIndex_] 为 _fromBlock_[_fromIndex_]。
            1. 设置 _toIndex_ 为 _toIndex_ + 1。
            1. 设置 _fromIndex_ 为 _fromIndex_ + 1。
            1. 设置 _count_ 为 _count_ - 1。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-privateelement-specification-type">
      <h1>PrivateElement 规范类型</h1>
      <p>PrivateElement 类型是用于规范私有类字段、方法和访问器的 Record。虽然 PrivateElement 不用 Property Descriptor，但私有字段的行为类似于不可配置、不可枚举、可写的数据属性，私有方法类似于不可配置、不可枚举、不可写的数据属性，私有访问器类似于不可配置、不可枚举的访问器属性。</p>
      <p>PrivateElement 类型的值是包含 <emu-xref href="#table-privateelement-fields"></emu-xref> 定义字段的 Record。此类值称为 <dfn variants="PrivateElement">PrivateElements</dfn>。</p>
      <emu-table id="table-privateelement-fields" caption="PrivateElement 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>存在时 [[Kind]] 字段的值</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Key]]
            </td>
            <td>
              所有
            </td>
            <td>
              Private Name
            </td>
            <td>
              字段、方法或访问器的名称。
            </td>
          </tr>
          <tr>
            <td>
              [[Kind]]
            </td>
            <td>
              所有
            </td>
            <td>
              ~field~、~method~ 或 ~accessor~
            </td>
            <td>
              元素类型。
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              ~field~ 和 ~method~
            </td>
            <td>
              一个 ECMAScript 语言值
            </td>
            <td>
              字段的值。
            </td>
          </tr>
          <tr>
            <td>
              [[Get]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              函数对象或 *undefined*
            </td>
            <td>
              私有访问器的 getter。
            </td>
          </tr>
          <tr>
            <td>
              [[Set]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              函数对象或 *undefined*
            </td>
            <td>
              私有访问器的 setter。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-classfielddefinition-record-specification-type">
      <h1>ClassFieldDefinition Record 规范类型</h1>
      <p>ClassFieldDefinition 类型是用于规范类字段的 Record。</p>
      <p>ClassFieldDefinition 类型的值是包含 <emu-xref href="#table-classfielddefinition-fields"></emu-xref> 定义字段的 Record。此类值称为 <dfn variants="ClassFieldDefinition Record">ClassFieldDefinition Records</dfn>。</p>
      <emu-table id="table-classfielddefinition-fields" caption="ClassFieldDefinition Record 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Name]]
            </td>
            <td>
              Private Name、字符串或符号
            </td>
            <td>
              字段的名称。
            </td>
          </tr>
          <tr>
            <td>
              [[Initializer]]
            </td>
            <td>
              ECMAScript 函数对象或 ~empty~
            </td>
            <td>
              字段的初始化器（如有）。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-private-names">
      <h1>Private Name</h1>
      <p><dfn variants="Private Names">Private Name</dfn> 规范类型用于描述全局唯一值（即使与其他 Private Name 外观一致也不同），用于表示私有类元素（字段、方法或访问器）的键。每个 Private Name 有不可变的 [[Description]] 内部槽，为字符串。Private Name 可通过 PrivateFieldAdd 或 PrivateMethodOrAccessorAdd 安装到任意 ECMAScript 对象上，然后可用 PrivateGet 和 PrivateSet 读取或写入。</p>
    </emu-clause>

    <emu-clause id="sec-classstaticblockdefinition-record-specification-type">
      <h1>ClassStaticBlockDefinition Record 规范类型</h1>
      <p><dfn variants="ClassStaticBlockDefinition Records">ClassStaticBlockDefinition Record</dfn> 是用于封装类静态初始化块可执行代码的 Record 值。</p>
      <p>ClassStaticBlockDefinition Record 包含 <emu-xref href="#table-classstaticblockdefinition-record-fields"></emu-xref> 列出的字段。</p>
      <emu-table id="table-classstaticblockdefinition-record-fields" caption="ClassStaticBlockDefinition Record 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BodyFunction]]
            </td>
            <td>
              一个 ECMAScript 函数对象
            </td>
            <td>
              类静态初始化时要调用的函数对象。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>抽象操作 (Abstract Operations)</h1>
  <p>这些操作不属于 ECMAScript 语言本身；它们仅在此定义，用于辅助描述 ECMAScript 语言语义。本规范其余部分还定义了其他更专业的抽象操作。</p>

  <emu-clause id="sec-type-conversion">
    <h1>类型转换 (Type Conversion)</h1>
    <p>ECMAScript 语言会按需隐式执行自动类型转换。为澄清某些结构的语义，有必要定义一组转换类抽象操作。转换抽象操作是多态的；它们可以接受任意 ECMAScript 语言类型的值。但不会与其它规范类型（specification types）一起使用。</p>
    <p>BigInt 类型在 ECMAScript 语言中没有隐式转换；程序员必须显式调用 BigInt 以从其他类型转换值。</p>

    <emu-clause id="sec-toprimitive" type="abstract operation" oldids="table-9">
      <h1>
        ToPrimitive (
        _input_: 一个 ECMAScript 语言值,
        可选 _preferredType_: ~string~ 或 ~number~,
        ): 返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将参数 _input_ 转换为非 Object 的类型。如果一个对象可以转换为多个不同的原始类型，它可利用可选提示 _preferredType_ 来偏向该类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _input_ 是一个 Object，则
          1. 令 _exoticToPrim_ 为 ? GetMethod(_input_, %Symbol.toPrimitive%)。
          1. 如果 _exoticToPrim_ 不为 *undefined*，则
            1. 如果 _preferredType_ 不存在，
              1. 令 _hint_ 为 *"default"*。
            1. 否则如果 _preferredType_ 是 ~string~，
              1. 令 _hint_ 为 *"string"*。
            1. 否则，
              1. 断言：_preferredType_ 是 ~number~。
              1. 令 _hint_ 为 *"number"*。
            1. 令 _result_ 为 ? Call(_exoticToPrim_, _input_, « _hint_ »)。
            1. 如果 _result_ 不是一个 Object，返回 _result_。
            1. 抛出 *TypeError* 异常。
          1. 如果 _preferredType_ 不存在，令 _preferredType_ 为 ~number~。
          1. 返回 ? OrdinaryToPrimitive(_input_, _preferredType_)。
        1. 返回 _input_。
      </emu-alg>
      <emu-note>
        <p>当 ToPrimitive 未带 hint 被调用时，一般表现为 hint 为 ~number~。但对象可通过定义 %Symbol.toPrimitive% 方法来覆写此行为。本规范中只有 Date（参见 <emu-xref href="#sec-date.prototype-%symbol.toprimitive%"></emu-xref>）和 Symbol 对象（参见 <emu-xref href="#sec-symbol.prototype-%symbol.toprimitive%"></emu-xref>）覆写默认行为。Date 在缺少 hint 时将其视为 ~string~。</p>
      </emu-note>

      <emu-clause id="sec-ordinarytoprimitive" type="abstract operation">
        <h1>
          OrdinaryToPrimitive (
            _O_: 一个 Object,
            _hint_: ~string~ 或 ~number~,
          ): 返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _hint_ 是 ~string~，则
            1. 令 _methodNames_ 为 « *"toString"*, *"valueOf"* »。
          1. 否则，
            1. 令 _methodNames_ 为 « *"valueOf"*, *"toString"* »。
          1. 对于 _methodNames_ 的每个元素 _name_，执行
            1. 令 _method_ 为 ? Get(_O_, _name_)。
            1. 如果 IsCallable(_method_) 是 *true*，则
              1. 令 _result_ 为 ? Call(_method_, _O_)。
              1. 如果 _result_ 不是一个 Object，返回 _result_。
          1. 抛出 *TypeError* 异常。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toboolean" oldids="table-toboolean-conversions,sec-IsHTMLDDA-internal-slot-to-boolean" type="abstract operation">
      <h1>
        ToBoolean (
          _argument_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 Boolean 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 Boolean，返回 _argument_。
        1. 如果 _argument_ 是 *undefined*、*null*、*+0*<sub>𝔽</sub>、*-0*<sub>𝔽</sub>、*NaN*、*0*<sub>ℤ</sub> 或空字符串，返回 *false*。
        1. [id="step-to-boolean-web-compat-insertion-point", normative-optional] 如果宿主是 web 浏览器或支持 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>，则
          1. 如果 _argument_ 是 Object 且具有 [[IsHTMLDDA]] 内部槽，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumeric" type="abstract operation">
      <h1>
        ToNumeric (
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含 Number 或 BigInt 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回 _value_ 转换后的 Number 或 BigInt。</dd>
      </dl>
      <emu-alg>
        1. 令 _primValue_ 为 ? ToPrimitive(_value_, ~number~)。
        1. 如果 _primValue_ 是 BigInt，返回 _primValue_。
        1. 返回 ? <emu-meta suppress-effects="user-code">ToNumber(_primValue_)</emu-meta>。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumber" oldids="table-tonumber-conversions" type="abstract operation">
      <h1>
        ToNumber (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 Number 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 Number，返回 _argument_。
        1. 如果 _argument_ 是 Symbol 或 BigInt，抛出 *TypeError* 异常。
        1. 如果 _argument_ 是 *undefined*，返回 *NaN*。
        1. 如果 _argument_ 是 *null* 或 *false*，返回 *+0*<sub>𝔽</sub>。
        1. 如果 _argument_ 是 *true*，返回 *1*<sub>𝔽</sub>。
        1. 如果 _argument_ 是 String，返回 StringToNumber(_argument_)。
        1. 断言：_argument_ 是一个 Object。
        1. 令 _primValue_ 为 ? ToPrimitive(_argument_, ~number~)。
        1. 断言：_primValue_ 不是 Object。
        1. 返回 ? ToNumber(_primValue_)。
      </emu-alg>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>应用于 String 类型的 ToNumber</h1>
        <p>抽象操作 StringToNumber 规定如何使用下列语法将一个 String 值转换为 Number 值。</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringNumericLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

          StrWhiteSpace :::
            StrWhiteSpaceChar StrWhiteSpace?

          StrWhiteSpaceChar :::
            WhiteSpace
            LineTerminator

          StrNumericLiteral :::
            StrDecimalLiteral
            NonDecimalIntegerLiteral[~Sep]

          StrDecimalLiteral :::
            StrUnsignedDecimalLiteral
            `+` StrUnsignedDecimalLiteral
            `-` StrUnsignedDecimalLiteral

          StrUnsignedDecimalLiteral :::
            `Infinity`
            DecimalDigits[~Sep] `.` DecimalDigits[~Sep]? ExponentPart[~Sep]?
            `.` DecimalDigits[~Sep] ExponentPart[~Sep]?
            DecimalDigits[~Sep] ExponentPart[~Sep]?
        </emu-grammar>
        <p>未在上方显式定义的语法符号，采用数字字面量词法语法 (<emu-xref href="#sec-literals-numeric-literals"></emu-xref>) 中的定义。</p>
        <emu-note>
          <p>需要注意 |StringNumericLiteral| 与 |NumericLiteral| 语法之间的一些差异：</p>
          <ul>
            <li>|StringNumericLiteral| 可包含前导和/或尾随空白及/或行终止符。</li>
            <li>十进制的 |StringNumericLiteral| 可以有任意数量的前导 `0`。</li>
            <li>十进制的 |StringNumericLiteral| 可以包含 `+` 或 `-` 来表示符号。</li>
            <li>空的或只含空白的 |StringNumericLiteral| 被转换为 *+0*<sub>𝔽</sub>。</li>
            <li>`Infinity` 和 `-Infinity` 被识别为 |StringNumericLiteral| 而非 |NumericLiteral|。</li>
            <li>|StringNumericLiteral| 不能包含 |BigIntLiteralSuffix|。</li>
            <li>|StringNumericLiteral| 不能包含 |NumericLiteralSeparator|。</li>
          </ul>
        </emu-note>

        <emu-clause id="sec-stringtonumber" type="abstract operation">
          <h1>
            StringToNumber (
              _str_: 一个 String,
            ): 一个 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _literal_ 为 ParseText(_str_, |StringNumericLiteral|)。
            1. 如果 _literal_ 是一个错误列表，返回 *NaN*。
            1. 返回 _literal_ 的 StringNumericValue。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-stringnumericvalue" type="sdo" oldids="sec-runtime-semantics-mv-s">
          <h1>运行时语义：StringNumericValue ( ): 一个 Number</h1>
          <dl class="header">
          </dl>
          <emu-note>
            <p>将 |StringNumericLiteral| 转换为 Number 值的整体过程与确定 |NumericLiteral| 的 NumericValue 类似（参见 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>），但细节有所不同。</p>
          </emu-note>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. 返回 *+0*<sub>𝔽</sub>。
          </emu-alg>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. 返回 |StrNumericLiteral| 的 StringNumericValue。
          </emu-alg>
          <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
          <emu-alg>
            1. 返回 𝔽(|NonDecimalIntegerLiteral| 的 MV)。
          </emu-alg>
          <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
          <emu-alg>
            1. 令 _a_ 为 |StrUnsignedDecimalLiteral| 的 StringNumericValue。
            1. 如果 _a_ 是 *+0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回 -_a_。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
          <emu-alg>
            1. 返回 *+∞*<sub>𝔽</sub>。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
          <emu-alg>
            1. 令 _a_ 为第一个 |DecimalDigits| 的 MV。
            1. 如果第二个 |DecimalDigits| 存在，则
              1. 令 _b_ 为第二个 |DecimalDigits| 的 MV。
              1. 令 _n_ 为第二个 |DecimalDigits| 的码点数量。
            1. 否则，
              1. 令 _b_ 为 0。
              1. 令 _n_ 为 0。
            1. 如果 |ExponentPart| 存在，令 _e_ 为其 MV；否则令 _e_ 为 0。
            1. 返回 RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>)。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. 令 _b_ 为 |DecimalDigits| 的 MV。
            1. 如果 |ExponentPart| 存在，令 _e_ 为其 MV；否则令 _e_ 为 0。
            1. 令 _n_ 为 |DecimalDigits| 的码点数量。
            1. 返回 RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>)。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. 令 _a_ 为 |DecimalDigits| 的 MV。
            1. 如果 |ExponentPart| 存在，令 _e_ 为其 MV；否则令 _e_ 为 0。
            1. 返回 RoundMVResult(_a_ × 10<sup>_e_</sup>)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-roundmvresult" type="abstract operation">
          <h1>
            RoundMVResult (
              _n_: 一个数学值,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>以实现定义的方式将 _n_ 转换为 Number。对本抽象操作而言，若一位数字不是 0，或其左侧与右侧存在非零数字，则该位为有效数字。此处“数学值的表示所表示的数学值”与“数学值的十进制表示”互为逆过程。</dd>
          </dl>
          <emu-alg>
            1. 如果 _n_ 的十进制表示有不超过 20 个有效数字，返回 𝔽(_n_)。
            1. 令 _option1_ 为将 _n_ 十进制表示中第 20 位之后的每个有效数字替换为 0 后所表示的数学值。
            1. 令 _option2_ 为将 _n_ 十进制表示中第 20 位之后的每个有效数字替换为 0，然后对第 20 位进位（必要时连锁进位）后所表示的数学值。
            1. 令 _chosen_ 为实现定义地在 _option1_ 与 _option2_ 中选择的其中一个。
            1. 返回 𝔽(_chosen_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tointegerorinfinity" type="abstract operation" oldids="sec-tointeger">
      <h1>
        ToIntegerOrInfinity (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整数、+&infin;、- &infin; 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为其 Number 值去掉小数部分后的整数；若该 Number 值为无穷大，则转换为 +∞ 或 -∞。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 0。
        1. 如果 _number_ 是 *+∞*<sub>𝔽</sub>，返回 +∞。
        1. 如果 _number_ 是 *-∞*<sub>𝔽</sub>，返回 -∞。
        1. 返回 truncate(ℝ(_number_))。
      </emu-alg>
      <emu-note>
        𝔽(ToIntegerOrInfinity(_x_)) 对任意 _x_ 都不会返回 *-0*<sub>𝔽</sub>。截断小数部分在将 _x_ 转换为数学值之后执行。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint32" type="abstract operation">
      <h1>
        ToInt32 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>32</sup> 个整型 Number 值之一，范围为 𝔽(-2<sup>31</sup>) 到 𝔽(2<sup>31</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int32bit_ 为 _int_ modulo 2<sup>32</sup>。
        1. 如果 _int32bit_ ≥ 2<sup>31</sup>，返回 𝔽(_int32bit_ - 2<sup>32</sup>)；否则返回 𝔽(_int32bit_)。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>ToInt32 是幂等的：对其输出再次应用结果不变。</li>
          <li>对所有 _x_，ToInt32(ToUint32(_x_)) 与 ToInt32(_x_) 相同。（为保持此性质，*+∞*<sub>𝔽</sub> 与 *-∞*<sub>𝔽</sub> 被映射为 *+0*<sub>𝔽</sub>。）</li>
          <li>ToInt32 将 *-0*<sub>𝔽</sub> 映射为 *+0*<sub>𝔽</sub>。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-touint32" type="abstract operation">
      <h1>
        ToUint32 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>32</sup> 个整型 Number 值之一，范围为 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>32</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int32bit_ 为 _int_ modulo 2<sup>32</sup>。
        1. [id="step-touint32-return"] 返回 𝔽(_int32bit_)。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>步骤 <emu-xref href="#step-touint32-return"></emu-xref> 是 ToUint32 与 ToInt32 的唯一差别。</li>
          <li>ToUint32 幂等。</li>
          <li>对所有 _x_，ToUint32(ToInt32(_x_)) 与 ToUint32(_x_) 相同。（为保持此性质，*+∞*<sub>𝔽</sub> 与 *-∞*<sub>𝔽</sub> 被映射为 *+0*<sub>𝔽</sub>。）</li>
          <li>ToUint32 将 *-0*<sub>𝔽</sub> 映射为 *+0*<sub>𝔽</sub>。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint16" type="abstract operation">
      <h1>
        ToInt16 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>16</sup> 个整型 Number 之一，范围 𝔽(-2<sup>15</sup>) 到 𝔽(2<sup>15</sup> - 1)。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int16bit_ 为 _int_ modulo 2<sup>16</sup>。
        1. 如果 _int16bit_ ≥ 2<sup>15</sup>，返回 𝔽(_int16bit_ - 2<sup>16</sup>)；否则返回 𝔽(_int16bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint16" type="abstract operation">
      <h1>
        ToUint16 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>16</sup> 个整型 Number 之一，范围 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>16</sup> - 1)。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. [id="step-touint16-mod"] 令 _int16bit_ 为 _int_ modulo 2<sup>16</sup>。
        1. 返回 𝔽(_int16bit_)。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>在步骤 <emu-xref href="#step-touint16-mod"></emu-xref> 中把 2<sup>16</sup> 代替 2<sup>32</sup> 是 ToUint32 与 ToUint16 的唯一差别。</li>
          <li>ToUint16 将 *-0*<sub>𝔽</sub> 映射为 *+0*<sub>𝔽</sub>。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint8" type="abstract operation">
      <h1>
        ToInt8 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>8</sup> 个整型 Number 之一，范围 *-128*<sub>𝔽</sub> 到 *127*<sub>𝔽</sub>。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int8bit_ 为 _int_ modulo 2<sup>8</sup>。
        1. 如果 _int8bit_ ≥ 2<sup>7</sup>，返回 𝔽(_int8bit_ - 2<sup>8</sup>)；否则返回 𝔽(_int8bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8" type="abstract operation">
      <h1>
        ToUint8 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>8</sup> 个整型 Number 之一，范围 *+0*<sub>𝔽</sub> 到 *255*<sub>𝔽</sub>。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int8bit_ 为 _int_ modulo 2<sup>8</sup>。
        1. 返回 𝔽(_int8bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8clamp" type="abstract operation">
      <h1>
        ToUint8Clamp (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>对 _argument_ 进行钳制并取整，结果为 2<sup>8</sup> 个整型 Number 之一，范围 *+0*<sub>𝔽</sub> 到 *255*<sub>𝔽</sub>。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 是 *NaN*，返回 *+0*<sub>𝔽</sub>。
        1. 令 _mv_ 为 _number_ 的扩展数学值。
        1. 令 _clamped_ 为 _mv_ 在 0 与 255 之间钳制的结果。
        1. 令 _f_ 为 floor(_clamped_)。
        1. 如果 _clamped_ &lt; _f_ + 0.5，返回 𝔽(_f_)。
        1. 如果 _clamped_ > _f_ + 0.5，返回 𝔽(_f_ + 1)。
        1. 如果 _f_ 是偶数，返回 𝔽(_f_)；否则返回 𝔽(_f_ + 1)。
      </emu-alg>
      <emu-note>
        <p>不同于大多数整数转换操作，ToUint8Clamp 会四舍五入而不是截断非整数值，它使用“round half to even”平分舍入规则，不同于 <emu-xref href="#sec-math.round">`Math.round`</emu-xref> 的“round half up”。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-tobigint" type="abstract operation">
      <h1>
        ToBigInt (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 BigInt 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 BigInt；若需要从 Number 的隐式转换则抛出。</dd>
      </dl>
      <emu-alg>
        1. 令 _prim_ 为 ? ToPrimitive(_argument_, ~number~)。
        1. 返回 _prim_ 在 <emu-xref href="#table-tobigint"></emu-xref> 中对应的值。
      </emu-alg>
      <emu-table id="table-tobigint" caption="BigInt 转换">
        <table>
          <thead>
            <tr>
              <th>
                参数类型
              </th>
              <th>
                结果
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              若 _prim_ 为 *true* 返回 `1n`，若为 *false* 返回 `0n`。
            </td>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              返回 _prim_。
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              <emu-alg>
                1. 令 _n_ 为 StringToBigInt(_prim_)。
                1. 如果 _n_ 是 *undefined*，抛出 *SyntaxError* 异常。
                1. 返回 _n_。
              </emu-alg>
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-stringtobigint" type="abstract operation">
      <h1>
        StringToBigInt (
          _str_: 一个 String,
        ): 一个 BigInt 或 *undefined*
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _literal_ 为 ParseText(_str_, |StringIntegerLiteral|)。
        1. 如果 _literal_ 是一个错误列表，返回 *undefined*。
        1. 令 _mv_ 为 _literal_ 的 MV。
        1. 断言：_mv_ 是整数。
        1. 返回 ℤ(_mv_)。
      </emu-alg>

      <emu-clause id="sec-stringintegerliteral-grammar">
        <h1>StringIntegerLiteral 语法</h1>
        <p>StringToBigInt 使用以下语法。</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringIntegerLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?

          StrIntegerLiteral :::
            SignedInteger[~Sep]
            NonDecimalIntegerLiteral[~Sep]
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-mv-for-stringintegerliteral">
        <h1>运行时语义：MV</h1>
        <ul>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace?</emu-grammar> 的 MV 为 0。
          </li>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?</emu-grammar> 的 MV 为 |StrIntegerLiteral| 的 MV。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tobigint64" type="abstract operation">
      <h1>
        ToBigInt64 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 BigInt 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>64</sup> 个 BigInt 之一，范围 ℤ(-2<sup>63</sup>) 到 ℤ(2<sup>63</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _n_ 为 ? ToBigInt(_argument_)。
        1. 令 _int64bit_ 为 ℝ(_n_) modulo 2<sup>64</sup>。
        1. 如果 _int64bit_ ≥ 2<sup>63</sup>，返回 ℤ(_int64bit_ - 2<sup>64</sup>)；否则返回 ℤ(_int64bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tobiguint64" type="abstract operation">
      <h1>
        ToBigUint64 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 BigInt 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>64</sup> 个 BigInt 之一，范围 *0*<sub>ℤ</sub> 到 ℤ(2<sup>64</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _n_ 为 ? ToBigInt(_argument_)。
        1. 令 _int64bit_ 为 ℝ(_n_) modulo 2<sup>64</sup>。
        1. 返回 ℤ(_int64bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tostring" oldids="table-tostring-conversions" type="abstract operation">
      <h1>
        ToString (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个 String 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 String 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 String，返回 _argument_。
        1. 如果 _argument_ 是 Symbol，抛出 *TypeError* 异常。
        1. 如果 _argument_ 是 *undefined*，返回 *"undefined"*。
        1. 如果 _argument_ 是 *null*，返回 *"null"*。
        1. 如果 _argument_ 是 *true*，返回 *"true"*。
        1. 如果 _argument_ 是 *false*，返回 *"false"*。
        1. 如果 _argument_ 是 Number，返回 Number::toString(_argument_, 10)。
        1. 如果 _argument_ 是 BigInt，返回 BigInt::toString(_argument_, 10)。
        1. 断言：_argument_ 是 Object。
        1. 令 _primValue_ 为 ? ToPrimitive(_argument_, ~string~)。
        1. 断言：_primValue_ 不是 Object。
        1. 返回 ? ToString(_primValue_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-toobject" type="abstract operation" oldids="table-toobject-conversions,table-13">
      <h1>
        ToObject (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个 Object 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 Object 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 *undefined* 或 *null*，抛出 *TypeError* 异常。
        1. 如果 _argument_ 是 Boolean，返回一个新 Boolean 对象，其 [[BooleanData]] 内部槽设为 _argument_。详见 <emu-xref href="#sec-boolean-objects"></emu-xref>。
        1. 如果 _argument_ 是 Number，返回一个新 Number 对象，其 [[NumberData]] 设为 _argument_。详见 <emu-xref href="#sec-number-objects"></emu-xref>。
        1. 如果 _argument_ 是 String，返回一个新 String 对象，其 [[StringData]] 设为 _argument_。详见 <emu-xref href="#sec-string-objects"></emu-xref>。
        1. 如果 _argument_ 是 Symbol，返回一个新 Symbol 对象，其 [[SymbolData]] 设为 _argument_。详见 <emu-xref href="#sec-symbol-objects"></emu-xref>。
        1. 如果 _argument_ 是 BigInt，返回一个新 BigInt 对象，其 [[BigIntData]] 设为 _argument_。详见 <emu-xref href="#sec-bigint-objects"></emu-xref>。
        1. 断言：_argument_ 是一个 Object。
        1. 返回 _argument_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-topropertykey" type="abstract operation">
      <h1>
        ToPropertyKey (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个属性键的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为可用作属性键的值。</dd>
      </dl>
      <emu-alg>
        1. 令 _key_ 为 ? ToPrimitive(_argument_, ~string~)。
        1. 如果 _key_ 是 Symbol，则
          1. 返回 _key_。
        1. 返回 ! ToString(_key_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolength" type="abstract operation">
      <h1>
        ToLength (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含非负整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 钳制并截断为可用于类数组对象 length 的非负整型 Number。</dd>
      </dl>
      <emu-alg>
        1. 令 _len_ 为 ? ToIntegerOrInfinity(_argument_)。
        1. 如果 _len_ ≤ 0，返回 *+0*<sub>𝔽</sub>。
        1. 返回 𝔽(min(_len_, 2<sup>53</sup> - 1))。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalnumericindexstring" type="abstract operation">
      <h1>
        CanonicalNumericIndexString (
          _argument_: 一个 String,
        ): 一个 Number 或 *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>如果 _argument_ 是 *"-0"* 或者完全匹配某个 Number 值 _n_ 的 ToString(_n_)，则返回该 Number 值；否则返回 *undefined*。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 *"-0"*，返回 *-0*<sub>𝔽</sub>。
        1. 令 _n_ 为 ! ToNumber(_argument_)。
        1. 如果 ! ToString(_n_) 是 _argument_，返回 _n_。
        1. 返回 *undefined*。
      </emu-alg>
      <p><dfn variants="canonical numeric strings">规范数值字符串</dfn>是对其执行 CanonicalNumericIndexString 抽象操作不返回 *undefined* 的任意字符串。</p>
    </emu-clause>

    <emu-clause id="sec-toindex" type="abstract operation">
      <h1>
        ToIndex (
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含非负整数的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _value_ 转换为整数，若其为非负且对应整数索引则返回该整数；否则抛出异常。</dd>
      </dl>
      <emu-alg>
        1. 令 _integer_ 为 ? ToIntegerOrInfinity(_value_)。
        1. 如果 _integer_ 不在 0 到 2<sup>53</sup> - 1（含）内，抛出 *RangeError* 异常。
        1. 返回 _integer_。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>测试与比较操作 (Testing and Comparison Operations)</h1>

    <emu-clause id="sec-requireobjectcoercible" type="abstract operation" oldids="table-requireobjectcoercible-results,table-14">
      <h1>
        RequireObjectCoercible (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>若 _argument_ 不能通过 ToObject 转换为对象则抛出错误。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 *undefined* 或 *null*，抛出 *TypeError* 异常。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isarray" type="abstract operation">
      <h1>
        IsArray (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 如果 _argument_ 是 Array exotic object，返回 *true*。
        1. 如果 _argument_ 是 Proxy exotic object，则
          1. 执行 ? ValidateNonRevokedProxy(_argument_)。
          1. 令 _proxyTarget_ 为 _argument_.[[ProxyTarget]]。
          1. 返回 ? IsArray(_proxyTarget_)。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iscallable" type="abstract operation">
      <h1>
        IsCallable (
          _argument_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断 _argument_ 是否为具有 [[Call]] 内部方法的可调用函数。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 如果 _argument_ 具有 [[Call]] 内部方法，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isconstructor" type="abstract operation">
      <h1>
        IsConstructor (
          _argument_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断 _argument_ 是否为具有 [[Construct]] 内部方法的函数对象。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 如果 _argument_ 具有 [[Construct]] 内部方法，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isextensible-o" type="abstract operation">
      <h1>
        IsExtensible (
          _O_: 一个 Object,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于判断是否可向 _O_ 添加额外属性。</dd>
      </dl>
      <emu-alg>
        1. 返回 ? <emu-meta effects="user-code">_O_.[[IsExtensible]]</emu-meta>()。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isregexp" type="abstract operation">
      <h1>
        IsRegExp (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 令 _matcher_ 为 ? Get(_argument_, %Symbol.match%)。
        1. 如果 _matcher_ 不为 *undefined*，返回 ToBoolean(_matcher_)。
        1. 如果 _argument_ 有 [[RegExpMatcher]] 内部槽，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstringwellformedunicode" type="abstract operation">
      <h1>
        静态语义: IsStringWellFormedUnicode (
        _string_: 一个 String,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _string_ 视为 UTF-16 编码的代码点序列（见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>），判断其是否为 <a href="http://www.unicode.org/glossary/#well_formed_code_unit_sequence">well formed</a> UTF-16 序列。</dd>
      </dl>
      <emu-alg>
        1. 令 _len_ 为 _string_ 的长度。
        1. 令 _k_ 为 0。
        1. 循环，当 _k_ &lt; _len_，
          1. 令 _cp_ 为 CodePointAt(_string_, _k_)。
          1. 如果 _cp_.[[IsUnpairedSurrogate]] 是 *true*，返回 *false*。
          1. 设 _k_ 为 _k_ + _cp_.[[CodeUnitCount]]。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sametype" type="abstract operation">
      <h1>
        SameType (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断两个参数是否是相同类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _x_ 是 *undefined* 且 _y_ 是 *undefined*，返回 *true*。
        1. 如果 _x_ 是 *null* 且 _y_ 是 *null*，返回 *true*。
        1. 如果 _x_ 是 Boolean 且 _y_ 是 Boolean，返回 *true*。
        1. 如果 _x_ 是 Number 且 _y_ 是 Number，返回 *true*。
        1. 如果 _x_ 是 BigInt 且 _y_ 是 BigInt，返回 *true*。
        1. 如果 _x_ 是 Symbol 且 _y_ 是 Symbol，返回 *true*。
        1. 如果 _x_ 是 String 且 _y_ 是 String，返回 *true*。
        1. 如果 _x_ 是 Object 且 _y_ 是 Object，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-samevalue" type="abstract operation">
      <h1>
        SameValue (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断两个参数是否为同一值。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *false*，返回 *false*。
        1. 如果 _x_ 是 Number，则
          1. 返回 Number::sameValue(_x_, _y_)。
        1. 返回 SameValueNonNumber(_x_, _y_)。
      </emu-alg>
      <emu-note>
        <p>该算法与严格相等算法不同之处在于：它将所有 *NaN* 视为等价，并区分 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub>。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluezero" type="abstract operation">
      <h1>
        SameValueZero (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断是否为同一值（忽略 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub> 的差别）。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *false*，返回 *false*。
        1. 如果 _x_ 是 Number，则
          1. 返回 Number::sameValueZero(_x_, _y_)。
        1. 返回 SameValueNonNumber(_x_, _y_)。
      </emu-alg>
      <emu-note>
        <p>SameValueZero 与 SameValue 唯一差别是它认为 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub> 等价。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" type="abstract operation" oldids="sec-samevaluenonnumeric">
      <h1>
        SameValueNonNumber (
          _x_: 一个 ECMAScript 语言值（非 Number),
          _y_: 一个 ECMAScript 语言值（非 Number),
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：SameType(_x_, _y_) 为 *true*。
        1. 如果 _x_ 是 *undefined* 或 *null*，返回 *true*。
        1. 如果 _x_ 是 BigInt，则
          1. 返回 BigInt::equal(_x_, _y_)。
        1. 如果 _x_ 是 String，则
          1. 如果 _x_ 与 _y_ 长度相同且相同位置的代码单元相同，返回 *true*；否则返回 *false*。
        1. 如果 _x_ 是 Boolean，则
          1. 若都为 *true* 或都为 *false*，返回 *true*；否则返回 *false*。
        1. NOTE: 其他 ECMAScript 语言值按身份比较。
        1. 如果 _x_ 是 _y_，返回 *true*；否则返回 *false*。
      </emu-alg>
      <emu-note>
        为了阐述目的，本算法中一些分支被单独列出，即便不是必须。
      </emu-note>
      <emu-note>
        “_x_ 是 _y_” 的具体含义详见 <emu-xref href="#sec-identity"></emu-xref>。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islessthan" type="abstract operation" oldids="sec-abstract-relational-comparison">
      <h1>
        IsLessThan (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
          _LeftFirst_: 一个 Boolean,
        ): 返回包含 Boolean 或 *undefined* 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>提供 _x_ &lt; _y_ 的语义，返回 *true*、*false* 或 *undefined*（表示至少一个操作数为 *NaN*）。_LeftFirst_ 标志控制可能具副作用的操作执行顺序，以符合 ECMAScript 自左向右求值规则。若 _LeftFirst_ 为 *true*，_x_ 对应的表达式位于 _y_ 左侧；否则顺序反转并需先对 _y_ 执行操作。</dd>
      </dl>
      <emu-alg>
        1. 如果 _LeftFirst_ 为 *true*，则
          1. 令 _px_ 为 ? ToPrimitive(_x_, ~number~)。
          1. 令 _py_ 为 ? ToPrimitive(_y_, ~number~)。
        1. 否则，
          1. NOTE: 需反转求值顺序以保持自左向右求值。
          1. 令 _py_ 为 ? ToPrimitive(_y_, ~number~)。
          1. 令 _px_ 为 ? ToPrimitive(_x_, ~number~)。
        1. [id="step-arc-string-check"] 如果 _px_ 是 String 且 _py_ 是 String，则
          1. 令 _lx_ 为 _px_ 的长度。
          1. 令 _ly_ 为 _py_ 的长度。
          1. 对每个整数 _i_，0 ≤ _i_ &lt; min(_lx_, _ly_) 递增：
            1. 令 _cx_ 为 _px_ 索引 _i_ 的代码单元数值。
            1. 令 _cy_ 为 _py_ 索引 _i_ 的代码单元数值。
            1. 如果 _cx_ &lt; _cy_，返回 *true*。
            1. 如果 _cx_ > _cy_，返回 *false*。
          1. 如果 _lx_ &lt; _ly_，返回 *true*；否则返回 *false*。
        1. 否则，
          1. 如果 _px_ 是 BigInt 且 _py_ 是 String，则
            1. 令 _ny_ 为 StringToBigInt(_py_)。
            1. 如果 _ny_ 是 *undefined*，返回 *undefined*。
            1. 返回 BigInt::lessThan(_px_, _ny_)。
          1. 如果 _px_ 是 String 且 _py_ 是 BigInt，则
            1. 令 _nx_ 为 StringToBigInt(_px_)。
            1. 如果 _nx_ 是 *undefined*，返回 *undefined*。
            1. 返回 BigInt::lessThan(_nx_, _py_)。
          1. NOTE: 因 _px_ 与 _py_ 是原始值，求值顺序无关。
          1. 令 _nx_ 为 ? <emu-meta suppress-effects="user-code">ToNumeric(_px_)</emu-meta>。
          1. 令 _ny_ 为 ? <emu-meta suppress-effects="user-code">ToNumeric(_py_)</emu-meta>。
          1. 如果 SameType(_nx_, _ny_) 为 *true*，则
            1. 如果 _nx_ 是 Number，
              1. 返回 Number::lessThan(_nx_, _ny_)。
            1. 否则，
              1. 断言：_nx_ 是 BigInt。
              1. 返回 BigInt::lessThan(_nx_, _ny_)。
          1. 断言：_nx_ 是 BigInt 且 _ny_ 是 Number，或 _nx_ 是 Number 且 _ny_ 是 BigInt。
          1. 如果 _nx_ 或 _ny_ 是 *NaN*，返回 *undefined*。
          1. 如果 _nx_ 是 *-∞*<sub>𝔽</sub> 或 _ny_ 是 *+∞*<sub>𝔽</sub>，返回 *true*。
          1. 如果 _nx_ 是 *+∞*<sub>𝔽</sub> 或 _ny_ 是 *-∞*<sub>𝔽</sub>，返回 *false*。
          1. 如果 ℝ(_nx_) &lt; ℝ(_ny_)，返回 *true*；否则返回 *false*。
      </emu-alg>
      <emu-note>
        <p>步骤 <emu-xref href="#step-arc-string-check"></emu-xref> 与加法运算符 `+` 算法 (<emu-xref href="#sec-applystringornumericbinaryoperator"></emu-xref>) 中的步骤 <emu-xref href="#step-binary-op-string-check"></emu-xref> 不同之处在于这里使用逻辑与，而非逻辑或。</p>
      </emu-note>
      <emu-note>
        <p>字符串比较使用 UTF-16 代码单元的简单字典序，不使用 Unicode 中更复杂的按语义等价或排序规则。因此按 Unicode 标准规范等价但不同规范化形式的字符串可能判定为不相等；含代理对的字符串按代码单元排序与按代码点排序可能不同。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islooselyequal" type="abstract operation" oldids="sec-abstract-equality-comparison,sec-IsHTMLDDA-internal-slot-aec">
      <h1>
        IsLooselyEqual (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`==` 运算符的语义。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *true*，则
          1. 返回 IsStrictlyEqual(_x_, _y_)。
        1. 如果 _x_ 是 *null* 且 _y_ 是 *undefined*，返回 *true*。
        1. 如果 _x_ 是 *undefined* 且 _y_ 是 *null*，返回 *true*。
        1. [id="step-abstract-equality-comparison-web-compat-insertion-point", normative-optional] 若宿主是 web 浏览器或支持 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>：
          1. 若 _x_ 是 Object、具有 [[IsHTMLDDA]] 且 _y_ 是 *undefined* 或 *null*，返回 *true*。
          1. 若 _x_ 是 *undefined* 或 *null*，_y_ 是具有 [[IsHTMLDDA]] 的 Object，返回 *true*。
        1. 如果 _x_ 是 Number 且 _y_ 是 String，返回 ! IsLooselyEqual(_x_, ! ToNumber(_y_))。
        1. 如果 _x_ 是 String 且 _y_ 是 Number，返回 ! IsLooselyEqual(! ToNumber(_x_), _y_)。
        1. 如果 _x_ 是 BigInt 且 _y_ 是 String，则
          1. 令 _n_ 为 StringToBigInt(_y_)。
          1. 如果 _n_ 是 *undefined*，返回 *false*。
          1. 返回 ! IsLooselyEqual(_x_, _n_)。
        1. 如果 _x_ 是 String 且 _y_ 是 BigInt，返回 ! IsLooselyEqual(_y_, _x_)。
        1. 如果 _x_ 是 Boolean，返回 ! IsLooselyEqual(! ToNumber(_x_), _y_)。
        1. 如果 _y_ 是 Boolean，返回 ! IsLooselyEqual(_x_, ! ToNumber(_y_))。
        1. 如果 _x_ 是 String / Number / BigInt / Symbol 且 _y_ 是 Object，返回 ! IsLooselyEqual(_x_, ? ToPrimitive(_y_))。
        1. 如果 _x_ 是 Object 且 _y_ 是 String / Number / BigInt / Symbol，返回 ! IsLooselyEqual(? ToPrimitive(_x_), _y_)。
        1. 如果 (_x_ BigInt 且 _y_ Number) 或 (_x_ Number 且 _y_ BigInt)，则
          1. 若 _x_ 非有限或 _y_ 非有限，返回 *false*。
          1. 若 ℝ(_x_) = ℝ(_y_)，返回 *true*；否则返回 *false*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstrictlyequal" type="abstract operation" oldids="sec-strict-equality-comparison">
      <h1>
        IsStrictlyEqual (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`===` 运算符的语义。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *false*，返回 *false*。
        1. 如果 _x_ 是 Number，则
          1. 返回 Number::equal(_x_, _y_)。
        1. 返回 SameValueNonNumber(_x_, _y_)。
      </emu-alg>
      <emu-note>
        <p>该算法与 SameValue 算法在带符号零和 NaN 的处理上不同。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-objects">
    <h1>对象操作 (Operations on Objects)</h1>

    <emu-clause id="sec-makebasicobject" type="abstract operation">
      <h1>
        MakeBasicObject (
          _internalSlotsList_: 一个内部槽名称的 List,
        ): 一个 Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>是所有算法创建 ECMAScript 对象（普通或特殊）的基础，它抽出创建所有对象的通用步骤并集中化对象创建。</dd>
      </dl>

      <emu-alg>
        1. 将 _internalSlotsList_ 设为其与 « [[PrivateElements]] » 的列表拼接。
        1. 令 _obj_ 为一个新创建的对象，对 _internalSlotsList_ 中每个名称建一个内部槽。
        1. NOTE: 如 <emu-xref href="#sec-object-internal-methods-and-internal-slots" title></emu-xref> 所述，除非另有说明，每个内部槽初始值为 *undefined*。
        1. 设置 _obj_.[[PrivateElements]] 为一个新的空 List。
        1. 将 _obj_ 的基本内部方法设为 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 指定的普通对象默认定义。
        1. 断言：若调用者不会同时覆写 _obj_ 的 [[GetPrototypeOf]] 和 [[SetPrototypeOf]]，则 _internalSlotsList_ 包含 [[Prototype]]。
        1. 断言：若调用者不会全部覆写 _obj_ 的 [[SetPrototypeOf]]、[[IsExtensible]]、[[PreventExtensions]]，则 _internalSlotsList_ 包含 [[Extensible]]。
        1. 如果 _internalSlotsList_ 包含 [[Extensible]]，设 _obj_.[[Extensible]] 为 *true*。
        1. 返回 _obj_。
      </emu-alg>

      <emu-note>
        <p>在本规范中，特殊对象（exotic objects）通过如 ArrayCreate、BoundFunctionCreate 等抽象操作创建：先调用 MakeBasicObject 得到基础对象，再覆写其部分或全部内部方法。为封装特殊对象创建，其基本内部方法不会在这些操作之外被修改。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-o-p" type="abstract operation">
      <h1>
        Get (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于获取对象特定属性的值。</dd>
      </dl>
      <emu-alg>
        1. 返回 ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _O_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getv" type="abstract operation">
      <h1>
        GetV (
          _V_: 一个 ECMAScript 语言值,
          _P_: 一个属性键,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于获取一个 ECMAScript 语言值特定属性的值；若该值不是对象，则通过类型对应的包装对象执行属性查找。</dd>
      </dl>
      <emu-alg>
        1. 令 _O_ 为 ? ToObject(_V_)。
        1. 返回 ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _V_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-set-o-p-v-throw" type="abstract operation">
      <h1>
        Set (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
          _Throw_: 一个 Boolean,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>设置对象特定属性的值，_V_ 是新值。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? <emu-meta effects="user-code">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_)。
        1. 若 _success_ 为 *false* 且 _Throw_ 为 *true*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdataproperty" type="abstract operation">
      <h1>
        CreateDataProperty (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建对象的一个新的自身属性。</dd>
      </dl>
      <emu-alg>
        1. 令 _newDesc_ 为 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
        1. 返回 ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_)。
      </emu-alg>
      <emu-note>
        <p>此操作创建的属性特性与语言赋值运算符新建属性时的默认特性相同。通常该属性不存在；若已存在且不可配置，或 _O_ 不可扩展，则 [[DefineOwnProperty]] 返回 *false*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createdatapropertyorthrow" type="abstract operation">
      <h1>
        CreateDataPropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建对象一个新的自身属性。如果该属性更新无法执行则抛出 *TypeError*。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? CreateDataProperty(_O_, _P_, _V_)。
        1. 若 _success_ 为 *false*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>与 CreateDataProperty 类似，但失败时抛出异常。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createnonenumerabledatapropertyorthrow" type="abstract operation">
      <h1>
        CreateNonEnumerableDataPropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个新的不可枚举自身数据属性（普通对象）。</dd>
      </dl>
      <emu-alg>
        1. 断言：_O_ 是可扩展、普通对象，且无不可配置属性。
        1. 令 _newDesc_ 为 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。
        1. 执行 ! DefinePropertyOrThrow(_O_, _P_, _newDesc_)。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>特性与赋值运算符默认值相同，唯独 [[Enumerable]] 为 *false*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-definepropertyorthrow" type="abstract operation">
      <h1>
        DefinePropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _desc_: 一个 Property Descriptor,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>以会在失败时抛出 *TypeError* 的方式调用对象的 [[DefineOwnProperty]]。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_)。
        1. 若 _success_ 为 *false*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-deletepropertyorthrow" type="abstract operation">
      <h1>
        DeletePropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>移除对象的指定自身属性；若属性不可配置则抛出异常。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? <emu-meta effects="user-code">_O_.[[Delete]]</emu-meta>(_P_)。
        1. 若 _success_ 为 *false*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getmethod" type="abstract operation">
      <h1>
        GetMethod (
          _V_: 一个 ECMAScript 语言值,
          _P_: 一个属性键,
        ): 返回包含函数对象或 *undefined* 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>获取一个 ECMAScript 语言值的指定属性值，并期望其为函数。</dd>
      </dl>
      <emu-alg>
        1. 令 _func_ 为 ? GetV(_V_, _P_)。
        1. 如果 _func_ 是 *undefined* 或 *null*，返回 *undefined*。
        1. 如果 IsCallable(_func_) 为 *false*，抛出 *TypeError*。
        1. 返回 _func_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasproperty" type="abstract operation">
      <h1>
        HasProperty (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断对象是否具有指定键的属性（自身或继承）。</dd>
      </dl>
      <emu-alg>
        1. 返回 ? <emu-meta effects="user-code">_O_.[[HasProperty]]</emu-meta>(_P_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasownproperty" type="abstract operation">
      <h1>
        HasOwnProperty (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断对象是否具有指定键的自身属性。</dd>
      </dl>
      <emu-alg>
        1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 如果 _desc_ 是 *undefined*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-call" type="abstract operation">
      <h1>
        Call (
        _F_: 一个 ECMAScript 语言值,
        _V_: 一个 ECMAScript 语言值,
        可选 _argumentsList_: 一个 ECMAScript 语言值的 List,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用函数对象的 [[Call]] 内部方法。_F_ 是函数对象，_V_ 为 *this* 值，_argumentsList_ 为传递的参数列表。若 _argumentsList_ 不存在，使用新的空 List。</dd>
      </dl>
      <emu-alg>
        1. 若 _argumentsList_ 不存在，设其为新空 List。
        1. 若 IsCallable(_F_) 为 *false*，抛出 *TypeError*。
        1. 返回 ? <emu-meta effects="user-code">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-construct" type="abstract operation">
      <h1>
        Construct (
        _F_: 一个 constructor,
        可选 _argumentsList_: ECMAScript 语言值 List,
        可选 _newTarget_: 一个 constructor,
        ): 返回包含一个 Object 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用函数对象的 [[Construct]] 内部方法。_argumentsList_ 与 _newTarget_ 为对应参数；若 _argumentsList_ 缺省，用新空 List；若 _newTarget_ 缺省，用 _F_。</dd>
      </dl>
      <emu-alg>
        1. 若 _newTarget_ 不存在，设为 _F_。
        1. 若 _argumentsList_ 不存在，设为新空 List。
        1. 返回 ? <emu-meta effects="user-code">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_)。
      </emu-alg>
      <emu-note>
        <p>若 _newTarget_ 不存在，等价于：`new F(...argumentsList)`。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-setintegritylevel" type="abstract operation">
      <h1>
        SetIntegrityLevel (
          _O_: 一个 Object,
          _level_: ~sealed~ 或 ~frozen~,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>固定对象自身属性集合。</dd>
      </dl>
      <emu-alg>
        1. 令 _status_ 为 ? _O_.[[PreventExtensions]]()。
        1. 若 _status_ 为 *false*，返回 *false*。
        1. 令 _keys_ 为 ? _O_.[[OwnPropertyKeys]]()。
        1. 如果 _level_ 为 ~sealed~，则
          1. 对 _keys_ 中每个 _k_：
            1. 执行 ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* })。
        1. 否则，
          1. 断言：_level_ 为 ~frozen~。
          1. 对 _keys_ 中每个 _k_：
            1. 令 _currentDesc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)。
            1. 若 _currentDesc_ 不为 *undefined*，则
              1. 如果 IsAccessorDescriptor(_currentDesc_) 为 *true*，
                1. 令 _desc_ 为 PropertyDescriptor { [[Configurable]]: *false* }。
              1. 否则，
                1. 令 _desc_ 为 PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }。
              1. 执行 ? DefinePropertyOrThrow(_O_, _k_, _desc_)。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-testintegritylevel" type="abstract operation">
      <h1>
        TestIntegrityLevel (
          _O_: 一个 Object,
          _level_: ~sealed~ 或 ~frozen~,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断对象自身属性集合是否已固定。</dd>
      </dl>
      <emu-alg>
        1. 令 _extensible_ 为 ? IsExtensible(_O_)。
        1. 若 _extensible_ 为 *true*，返回 *false*。
        1. NOTE: 若对象可扩展，不检查属性。
        1. 令 _keys_ 为 ? _O_.[[OwnPropertyKeys]]()。
        1. 对 _keys_ 中每个 _k_：
          1. 令 _currentDesc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)。
          1. 若 _currentDesc_ 不为 *undefined*，则
            1. 若 _currentDesc_.[[Configurable]] 为 *true*，返回 *false*。
            1. 若 _level_ 为 ~frozen~ 且 IsDataDescriptor(_currentDesc_) 为 *true*，则
              1. 若 _currentDesc_.[[Writable]] 为 *true*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createarrayfromlist" type="abstract operation">
      <h1>
        CreateArrayFromList (
          _elements_: 一个 ECMAScript 语言值的 List,
        ): 一个 Array
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个其元素由 _elements_ 提供的数组。</dd>
      </dl>
      <emu-alg>
        1. 令 _array_ 为 ! ArrayCreate(0)。
        1. 令 _n_ 为 0。
        1. 对 _elements_ 中每个 _e_：
          1. 执行 ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_)。
          1. 设 _n_ 为 _n_ + 1。
        1. 返回 _array_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-lengthofarraylike" type="abstract operation">
      <h1>
        LengthOfArrayLike (
          _obj_: 一个 Object,
        ): 返回包含非负整数的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回类数组对象 *"length"* 属性的值。</dd>
      </dl>
      <emu-alg>
        1. 返回 ℝ(? ToLength(? Get(_obj_, *"length"*))).
      </emu-alg>
      <p><dfn variants="array-like objects">类数组对象</dfn> 指此操作能正常完成的任意对象。</p>
      <emu-note>
        通常类数组对象也具有一些整型索引属性，但这不是定义要求。
      </emu-note>
      <emu-note>
        Array 和 String 对象是类数组对象的例子。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createlistfromarraylike" type="abstract operation">
      <h1>
        CreateListFromArrayLike (
        _obj_: 一个 ECMAScript 语言值,
        可选 _validElementTypes_: ~all~ 或 ~property-key~,
        ): 返回包含 ECMAScript 语言值 List 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个 List，其元素由 _obj_ 的按索引属性提供；_validElementTypes_ 指定允许的元素类型。</dd>
      </dl>
      <emu-alg>
        1. 若 _validElementTypes_ 不存在，设为 ~all~。
        1. 若 _obj_ 不是 Object，抛出 *TypeError*。
        1. 令 _len_ 为 ? LengthOfArrayLike(_obj_)。
        1. 令 _list_ 为新空 List。
        1. 令 _index_ 为 0。
        1. 当 _index_ &lt; _len_：
          1. 令 _indexName_ 为 ! ToString(𝔽(_index_))。
          1. 令 _next_ 为 ? Get(_obj_, _indexName_)。
          1. 若 _validElementTypes_ 为 ~property-key~ 且 _next_ 不是属性键，抛出 *TypeError*。
          1. 将 _next_ 附加到 _list_。
          1. 设 _index_ 为 _index_ + 1。
        1. 返回 _list_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-invoke" type="abstract operation">
      <h1>
        Invoke (
        _V_: 一个 ECMAScript 语言值,
        _P_: 一个属性键,
        可选 _argumentsList_: ECMAScript 语言值 List,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用一个 ECMAScript 语言值的方法属性，_V_ 既作为查找点又作为 *this* 值。_argumentsList_ 为传入参数，缺省用空 List。</dd>
      </dl>

      <emu-alg>
        1. 若 _argumentsList_ 不存在，设为新空 List。
        1. 令 _func_ 为 ? GetV(_V_, _P_)。
        1. 返回 ? Call(_func_, _V_, _argumentsList_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryhasinstance" type="abstract operation">
      <h1>
        OrdinaryHasInstance (
          _C_: 一个 ECMAScript 语言值,
          _O_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>实现默认算法：判断 _O_ 是否继承自 _C_ 提供的实例继承路径。</dd>
      </dl>
      <emu-alg>
        1. 若 IsCallable(_C_) 为 *false*，返回 *false*。
        1. 若 _C_ 有 [[BoundTargetFunction]] 内部槽，则
          1. 令 _BC_ 为 _C_.[[BoundTargetFunction]]。
          1. 返回 ? InstanceofOperator(_O_, _BC_)。
        1. 若 _O_ 不是 Object，返回 *false*。
        1. 令 _P_ 为 ? Get(_C_, *"prototype"*)。
        1. 若 _P_ 不是 Object，抛出 *TypeError*。
        1. 循环：
          1. 设 _O_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
          1. 若 _O_ 是 *null*，返回 *false*。
          1. 若 SameValue(_P_, _O_) 为 *true*，返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-speciesconstructor" type="abstract operation">
      <h1>
        SpeciesConstructor (
          _O_: 一个 Object,
          _defaultConstructor_: 一个 constructor,
        ): 返回包含 constructor 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>获取用于创建从 _O_ 派生的新对象的构造函数；若从 _O_ 开始找不到 %Symbol.species% 属性则使用 _defaultConstructor_。</dd>
      </dl>
      <emu-alg>
        1. 令 _C_ 为 ? Get(_O_, *"constructor"*)。
        1. 若 _C_ 是 *undefined*，返回 _defaultConstructor_。
        1. 若 _C_ 不是 Object，抛出 *TypeError*。
        1. 令 _S_ 为 ? Get(_C_, %Symbol.species%)。
        1. 若 _S_ 是 *undefined* 或 *null*，返回 _defaultConstructor_。
        1. 若 IsConstructor(_S_) 为 *true*，返回 _S_。
        1. 抛出 *TypeError*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-enumerableownproperties" type="abstract operation" oldids="sec-enumerableownpropertynames">
      <h1>
        EnumerableOwnProperties (
          _O_: 一个 Object,
          _kind_: ~key~, ~value~, 或 ~key+value~,
        ): 返回包含 ECMAScript 语言值 List 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _ownKeys_ 为 ? <emu-meta effects="user-code">_O_.[[OwnPropertyKeys]]</emu-meta>()。
        1. 令 _results_ 为新空 List。
        1. 对 _ownKeys_ 中每个 _key_：
          1. 如果 _key_ 是 String，则
            1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)。
            1. 若 _desc_ 不为 *undefined* 且 _desc_.[[Enumerable]] 为 *true*，则
              1. 如果 _kind_ 为 ~key~，
                1. 将 _key_ 加入 _results_。
              1. 否则，
                1. 令 _value_ 为 ? Get(_O_, _key_)。
                1. 若 _kind_ 为 ~value~，
                  1. 将 _value_ 加入 _results_。
                1. 否则，
                  1. 断言：_kind_ 为 ~key+value~。
                  1. 令 _entry_ 为 CreateArrayFromList(« _key_, _value_ »)。
                  1. 将 _entry_ 加入 _results_。
        1. 返回 _results_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getfunctionrealm" type="abstract operation">
      <h1>
        GetFunctionRealm (
          _obj_: 一个函数对象,
        ): 返回包含 Realm Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _obj_ 有 [[Realm]] 内部槽，
          1. 返回 _obj_.[[Realm]]。
        1. 若 _obj_ 是绑定函数特殊对象，
          1. 令 _boundTargetFunction_ 为 _obj_.[[BoundTargetFunction]]。
          1. 返回 ? GetFunctionRealm(_boundTargetFunction_)。
        1. 若 _obj_ 是 Proxy 特殊对象，
          1. 执行 ? ValidateNonRevokedProxy(_obj_)。
          1. 令 _proxyTarget_ 为 _obj_.[[ProxyTarget]]。
          1. 断言：_proxyTarget_ 是函数对象。
          1. 返回 ? GetFunctionRealm(_proxyTarget_)。
        1. [id="step-getfunctionrealm-default-return"] 返回当前 Realm Record。
      </emu-alg>
      <emu-note>
        <p>仅当 _obj_ 是无 [[Realm]] 内部槽的非标准函数特殊对象时才会到达步骤 <emu-xref href="#step-getfunctionrealm-default-return"></emu-xref>。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-copydataproperties" type="abstract operation">
      <h1>
        CopyDataProperties (
          _target_: 一个 Object,
          _source_: 一个 ECMAScript 语言值,
          _excludedItems_: 一个属性键的 List,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _source_ 是 *undefined* 或 *null*，返回 ~unused~。
        1. 令 _from_ 为 ! ToObject(_source_)。
        1. 令 _keys_ 为 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]</emu-meta>()。
        1. 对 _keys_ 中每个 _nextKey_：
          1. 令 _excluded_ 为 *false*。
          1. 对 _excludedItems_ 中每个 _e_：
            1. 若 SameValue(_e_, _nextKey_) 为 *true*，
              1. 设 _excluded_ 为 *true*。
          1. 若 _excluded_ 为 *false*，则
            1. 令 _desc_ 为 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_)。
            1. 若 _desc_ 不为 *undefined* 且 _desc_.[[Enumerable]] 为 *true*，
              1. 令 _propValue_ 为 ? Get(_from_, _nextKey_)。
              1. 执行 ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_)。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>此处的 target 总是新创建且在抛错情况下不可被直接访问。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-privateelementfind" type="abstract operation">
      <h1>
        PrivateElementFind (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
        ): 一个 PrivateElement 或 ~empty~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _O_.[[PrivateElements]] 包含 PrivateElement _pe_ 且 _pe_.[[Key]] 是 _P_，
          1. 返回 _pe_。
        1. 返回 ~empty~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatefieldadd" type="abstract operation">
      <h1>
        PrivateFieldAdd (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若宿主是 web 浏览器，
          1. 执行 ? HostEnsureCanAddPrivateElement(_O_)。
        1. 令 _entry_ 为 PrivateElementFind(_O_, _P_)。
        1. 若 _entry_ 不为 ~empty~，抛出 *TypeError*。
        1. 将 PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ } 附加到 _O_.[[PrivateElements]]。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatemethodoraccessoradd" type="abstract operation">
      <h1>
        PrivateMethodOrAccessorAdd (
          _O_: 一个 Object,
          _method_: 一个 PrivateElement,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_method_.[[Kind]] 是 ~method~ 或 ~accessor~。
        1. 若宿主是 web 浏览器，
          1. 执行 ? HostEnsureCanAddPrivateElement(_O_)。
        1. 令 _entry_ 为 PrivateElementFind(_O_, _method_.[[Key]])。
        1. 若 _entry_ 不为 ~empty~，抛出 *TypeError*。
        1. 将 _method_ 附加到 _O_.[[PrivateElements]]。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>私有方法与访问器的值在实例之间共享，不会为每个实例复制。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostensurecanaddprivateelement" type="host-defined abstract operation">
      <h1>
        HostEnsureCanAddPrivateElement (
          _O_: 一个 Object,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>允许宿主环境阻止某些宿主定义特殊对象添加私有元素。</dd>
      </dl>
      <p>实现需符合：</p>
      <ul>
        <li>若 _O_ 不是宿主定义的特殊对象，则返回 NormalCompletion(~unused~) 且不做其它步骤。</li>
        <li>对相同参数的两次调用返回同种 Completion Record。</li>
      </ul>
      <p>默认实现为返回 NormalCompletion(~unused~)。</p>
      <p>仅由作为 web 浏览器的 ECMAScript 宿主调用。</p>
    </emu-clause>

    <emu-clause id="sec-privateget" type="abstract operation">
      <h1>
        PrivateGet (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _entry_ 为 PrivateElementFind(_O_, _P_)。
        1. 若 _entry_ 是 ~empty~，抛出 *TypeError*。
        1. 若 _entry_.[[Kind]] 是 ~field~ 或 ~method~，
          1. 返回 _entry_.[[Value]]。
        1. 断言：_entry_.[[Kind]] 是 ~accessor~。
        1. 若 _entry_.[[Get]] 是 *undefined*，抛出 *TypeError*。
        1. 令 _getter_ 为 _entry_.[[Get]]。
        1. 返回 ? Call(_getter_, _O_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privateset" type="abstract operation">
      <h1>
        PrivateSet (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _entry_ 为 PrivateElementFind(_O_, _P_)。
        1. 若 _entry_ 是 ~empty~，抛出 *TypeError*。
        1. 若 _entry_.[[Kind]] 是 ~field~，则
          1. 设 _entry_.[[Value]] 为 _value_。
        1. 否则如果 _entry_.[[Kind]] 是 ~method~，
          1. 抛出 *TypeError*。
        1. 否则，
          1. 断言：_entry_.[[Kind]] 是 ~accessor~。
          1. 若 _entry_.[[Set]] 是 *undefined*，抛出 *TypeError*。
          1. 令 _setter_ 为 _entry_.[[Set]]。
          1. 执行 ? Call(_setter_, _O_, « _value_ »)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definefield" type="abstract operation">
      <h1>
        DefineField (
          _receiver_: 一个 Object,
          _fieldRecord_: 一个 ClassFieldDefinition Record,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _fieldName_ 为 _fieldRecord_.[[Name]]。
        1. 令 _initializer_ 为 _fieldRecord_.[[Initializer]]。
        1. 如果 _initializer_ 不是 ~empty~，
          1. 令 _initValue_ 为 ? Call(_initializer_, _receiver_)。
        1. 否则，
          1. 令 _initValue_ 为 *undefined*。
        1. 若 _fieldName_ 是 Private Name，
          1. 执行 ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_)。
        1. 否则，
          1. 断言：_fieldName_ 是属性键。
          1. 执行 ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializeinstanceelements" type="abstract operation">
      <h1>
        InitializeInstanceElements (
          _O_: 一个 Object,
          _constructor_: 一个 ECMAScript 函数对象,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _methods_ 为 _constructor_.[[PrivateMethods]]。
        1. 对 _methods_ 中每个 PrivateElement _method_：
          1. 执行 ? PrivateMethodOrAccessorAdd(_O_, _method_)。
        1. 令 _fields_ 为 _constructor_.[[Fields]]。
        1. 对 _fields_ 中每个 _fieldRecord_：
          1. 执行 ? DefineField(_O_, _fieldRecord_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-value-to-keyed-group" type="abstract operation">
      <h1>
        AddValueToKeyedGroup (
          _groups_: 一个包含 [[Key]] (ECMAScript 语言值) 与 [[Elements]] (值 List) 字段的 Record List,
          _key_: 一个 ECMAScript 语言值,
          _value_: 一个 ECMAScript 语言值,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 对 _groups_ 中每个 Record { [[Key]], [[Elements]] } _g_：
          1. 若 SameValue(_g_.[[Key]], _key_) 为 *true*，则
            1. 断言：恰有一个元素符合。
            1. 将 _value_ 加入 _g_.[[Elements]]。
            1. 返回 ~unused~。
        1. 令 _group_ 为 Record { [[Key]]: _key_, [[Elements]]: « _value_ » }。
        1. 将 _group_ 加入 _groups_。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-groupby" type="abstract operation">
      <h1>
        GroupBy (
          _items_: 一个 ECMAScript 语言值,
          _callback_: 一个 ECMAScript 语言值,
          _keyCoercion_: ~property~ 或 ~collection~,
        ): 返回包含带 [[Key]] 与 [[Elements]] 字段的 Record List 的正常完成，或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 执行 ? RequireObjectCoercible(_items_)。
        1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError*。
        1. 令 _groups_ 为新空 List。
        1. 令 _iteratorRecord_ 为 ? GetIterator(_items_, ~sync~)。
        1. 令 _k_ 为 0。
        1. 循环：
          1. 若 _k_ ≥ 2<sup>53</sup> - 1，则
            1. 令 _error_ 为 ThrowCompletion(新建 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iteratorRecord_, _error_)。
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 若 _next_ 是 ~done~，
            1. 返回 _groups_。
          1. 令 _value_ 为 _next_。
          1. 令 _key_ 为 Completion(Call(_callback_, *undefined*, « _value_, 𝔽(_k_) »))。
          1. IfAbruptCloseIterator(_key_, _iteratorRecord_)。
          1. 若 _keyCoercion_ 为 ~property~，则
            1. 设 _key_ 为 Completion(ToPropertyKey(_key_))。
            1. IfAbruptCloseIterator(_key_, _iteratorRecord_)。
          1. 否则，
            1. 断言：_keyCoercion_ 为 ~collection~。
            1. 设 _key_ 为 CanonicalizeKeyedCollectionKey(_key_)。
          1. 执行 AddValueToKeyedGroup(_groups_, _key_, _value_)。
          1. 设 _k_ 为 _k_ + 1。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-SetterThatIgnoresPrototypeProperties" type="abstract operation">
      <h1>
        SetterThatIgnoresPrototypeProperties (
          _thisValue_: 一个 ECMAScript 语言值,
          _home_: 一个 Object,
          _p_: 一个属性键,
          _v_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _thisValue_ 不是 Object，
          1. 抛出 *TypeError*。
        1. 如果 SameValue(_thisValue_, _home_) 为 *true*，
          1. NOTE: 此处抛出模拟在严格模式下给 _home_ 不可写数据属性赋值。
          1. 抛出 *TypeError*。
        1. 令 _desc_ 为 ? _thisValue_.[[GetOwnProperty]](_p_)。
        1. 若 _desc_ 是 *undefined*，
          1. 执行 ? CreateDataPropertyOrThrow(_thisValue_, _p_, _v_)。
        1. 否则，
          1. 执行 ? Set(_thisValue_, _p_, _v_, *true*)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>迭代器对象操作 (Operations on Iterator Objects)</h1>
    <p>参见通用迭代接口 (<emu-xref href="#sec-iteration"></emu-xref>)。</p>

    <emu-clause id="sec-iterator-records">
      <h1>Iterator Records</h1>
      <p><dfn variants="Iterator Records">Iterator Record</dfn> 是一个 Record，用于封装迭代器或异步迭代器及其 `next` 方法。</p>
      <p>Iterator Record 拥有 <emu-xref href="#table-iterator-record-fields"></emu-xref> 所列字段。</p>
      <emu-table id="table-iterator-record-fields" caption="Iterator Record 字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Iterator]]
            </td>
            <td>
              一个 Object
            </td>
            <td>
              符合迭代器或异步迭代器接口的对象。
            </td>
          </tr>
          <tr>
            <td>
              [[NextMethod]]
            </td>
            <td>
              一个 ECMAScript 语言值
            </td>
            <td>
              [[Iterator]] 对象的 `next` 方法。
            </td>
          </tr>
          <tr>
            <td>
              [[Done]]
            </td>
            <td>
              一个 Boolean
            </td>
            <td>
              迭代器是否已完成或被关闭。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-getiteratordirect" type="abstract operation">
      <h1>
        GetIteratorDirect (
          _obj_: 一个 Object,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _nextMethod_ 为 ? Get(_obj_, *"next"*)。
        1. 令 _iteratorRecord_ 为 Iterator Record { [[Iterator]]: _obj_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }。
        1. 返回 _iteratorRecord_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorfrommethod" type="abstract operation">
      <h1>
        GetIteratorFromMethod (
          _obj_: 一个 ECMAScript 语言值,
          _method_: 一个函数对象,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _iterator_ 为 ? Call(_method_, _obj_)。
        1. 若 _iterator_ 不是 Object，抛出 *TypeError*。
        1. 返回 ? GetIteratorDirect(_iterator_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiterator" type="abstract operation">
      <h1>
        GetIterator (
          _obj_: 一个 ECMAScript 语言值,
          _kind_: ~sync~ 或 ~async~,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _kind_ 为 ~async~，则
          1. 令 _method_ 为 ? GetMethod(_obj_, %Symbol.asyncIterator%)。
          1. 若 _method_ 是 *undefined*，则
            1. 令 _syncMethod_ 为 ? GetMethod(_obj_, %Symbol.iterator%)。
            1. 若 _syncMethod_ 是 *undefined*，抛出 *TypeError*。
            1. 令 _syncIteratorRecord_ 为 ? GetIteratorFromMethod(_obj_, _syncMethod_)。
            1. 返回 CreateAsyncFromSyncIterator(_syncIteratorRecord_)。
        1. 否则，
          1. 令 _method_ 为 ? GetMethod(_obj_, %Symbol.iterator%)。
        1. 若 _method_ 是 *undefined*，抛出 *TypeError*。
        1. 返回 ? GetIteratorFromMethod(_obj_, _method_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorflattenable" type="abstract operation">
      <h1>
        GetIteratorFlattenable (
          _obj_: 一个 ECMAScript 语言值,
          _primitiveHandling_: ~iterate-string-primitives~ 或 ~reject-primitives~,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _obj_ 不是 Object，则
          1. 若 _primitiveHandling_ 为 ~reject-primitives~，抛出 *TypeError*。
          1. 断言：_primitiveHandling_ 为 ~iterate-string-primitives~。
          1. 若 _obj_ 不是 String，抛出 *TypeError*。
        1. 令 _method_ 为 ? GetMethod(_obj_, %Symbol.iterator%)。
        1. 若 _method_ 是 *undefined*，
          1. 令 _iterator_ 为 _obj_。
        1. 否则，
          1. 令 _iterator_ 为 ? Call(_method_, _obj_)。
        1. 若 _iterator_ 不是 Object，抛出 *TypeError*。
        1. 返回 ? GetIteratorDirect(_iterator_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratornext" type="abstract operation">
      <h1>
        IteratorNext (
        _iteratorRecord_: 一个 Iterator Record,
        可选 _value_: 一个 ECMAScript 语言值,
        ): 返回包含一个 Object 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _value_ 不存在，
          1. 令 _result_ 为 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]))。
        1. 否则，
          1. 令 _result_ 为 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »))。
        1. 若 _result_ 是 throw completion，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 返回 ? _result_。
        1. 设 _result_ 为 ! _result_。
        1. 若 _result_ 不是 Object，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 抛出 *TypeError*。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorcomplete" type="abstract operation">
      <h1>
        IteratorComplete (
          _iteratorResult_: 一个 Object,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 返回 ToBoolean(? Get(_iteratorResult_, *"done"*))。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorvalue" type="abstract operation">
      <h1>
        IteratorValue (
          _iteratorResult_: 一个 Object,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 返回 ? Get(_iteratorResult_, *"value"*)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstep" type="abstract operation">
      <h1>
        IteratorStep (
          _iteratorRecord_: 一个 Iterator Record,
        ): 返回包含一个 Object 或 ~done~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用 _iteratorRecord_.[[NextMethod]] 请求下一个值；若迭代结束返回 ~done~，否则返回 IteratorResult 对象。</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为 ? IteratorNext(_iteratorRecord_)。
        1. 令 _done_ 为 Completion(IteratorComplete(_result_))。
        1. 若 _done_ 是 throw completion，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 返回 ? _done_。
        1. 设 _done_ 为 ! _done_。
        1. 若 _done_ 为 *true*，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 返回 ~done~。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstepvalue" type="abstract operation">
      <h1>
        IteratorStepValue (
          _iteratorRecord_: 一个 Iterator Record,
        ): 返回包含 ECMAScript 语言值或 ~done~ 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>与 IteratorStep 类似，但若有值则直接返回值，否则 ~done~。</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为 ? IteratorStep(_iteratorRecord_)。
        1. 若 _result_ 是 ~done~，
          1. 返回 ~done~。
        1. 令 _value_ 为 Completion(IteratorValue(_result_))。
        1. 若 _value_ 是 throw completion，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
        1. 返回 ? _value_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorclose" type="abstract operation">
      <h1>
        IteratorClose (
          _iteratorRecord_: 一个 Iterator Record,
          _completion_: 一个 Completion Record,
        ): 一个 Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>通知迭代器执行其完成状态下的收尾动作。</dd>
      </dl>
      <emu-alg>
        1. 断言：_iteratorRecord_.[[Iterator]] 是 Object。
        1. 令 _iterator_ 为 _iteratorRecord_.[[Iterator]]。
        1. 令 _innerResult_ 为 Completion(GetMethod(_iterator_, *"return"*))。
        1. 若 _innerResult_ 是 normal completion，
          1. 令 _return_ 为 _innerResult_.[[Value]]。
          1. 若 _return_ 是 *undefined*，返回 ? _completion_。
          1. 设 _innerResult_ 为 Completion(Call(_return_, _iterator_))。
        1. 若 _completion_ 是 throw completion，返回 ? _completion_。
        1. 若 _innerResult_ 是 throw completion，返回 ? _innerResult_。
        1. 若 _innerResult_.[[Value]] 不是 Object，抛出 *TypeError*。
        1. 返回 ? _completion_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ifabruptcloseiterator" aoid="IfAbruptCloseIterator">
      <h1>IfAbruptCloseIterator ( _value_, _iteratorRecord_ )</h1>
      <p>IfAbruptCloseIterator 是使用 Iterator Record 相关步骤的简写。形如：</p>
      <emu-alg>
        1. IfAbruptCloseIterator(_value_, _iteratorRecord_)。
      </emu-alg>
      <p>等价于：</p>
      <emu-alg>
        1. 断言：_value_ 是 Completion Record。
        1. 若 _value_ 是 abrupt completion，返回 ? IteratorClose(_iteratorRecord_, _value_)。
        1. 否则，设 _value_ 为 ! _value_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asynciteratorclose" type="abstract operation">
      <h1>
        AsyncIteratorClose (
          _iteratorRecord_: 一个 Iterator Record,
          _completion_: 一个 Completion Record,
        ): 一个 Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>通知异步迭代器执行其完成状态下的收尾动作。</dd>
      </dl>
      <emu-alg>
        1. 断言：_iteratorRecord_.[[Iterator]] 是 Object。
        1. 令 _iterator_ 为 _iteratorRecord_.[[Iterator]]。
        1. 令 _innerResult_ 为 Completion(GetMethod(_iterator_, *"return"*))。
        1. 若 _innerResult_ 是 normal completion，
          1. 令 _return_ 为 _innerResult_.[[Value]]。
          1. 若 _return_ 是 *undefined*，返回 ? _completion_。
          1. 设 _innerResult_ 为 Completion(Call(_return_, _iterator_))。
          1. 若 _innerResult_ 是 normal completion，设其为 Completion(Await(_innerResult_.[[Value]]))。
        1. 若 _completion_ 是 throw completion，返回 ? _completion_。
        1. 若 _innerResult_ 是 throw completion，返回 ? _innerResult_。
        1. 若 _innerResult_.[[Value]] 不是 Object，抛出 *TypeError*。
        1. 返回 ? _completion_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createiteratorresultobject" type="abstract operation">
      <h1>
        CreateIteratorResultObject (
          _value_: 一个 ECMAScript 语言值,
          _done_: 一个 Boolean,
        ): 一个符合 IteratorResult 接口的 Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个符合 IteratorResult 接口的对象。</dd>
      </dl>
      <emu-alg>
        1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
        1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_)。
        1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"done"*, _done_)。
        1. 返回 _obj_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistiteratorRecord" type="abstract operation" oldids="sec-createlistiterator,sec-listiteratornext-functions,sec-listiterator-next">
      <h1>
        CreateListIteratorRecord (
          _list_: 一个 ECMAScript 语言值的 List,
        ): 一个 Iterator Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个 Iterator Record，其 [[NextMethod]] 依次返回 _list_ 的元素。</dd>
      </dl>
      <emu-alg>
        1. 令 _closure_ 为一个新建的 Abstract Closure（无参数），捕获 _list_，被调用时：
          1. 对 _list_ 中每个 _E_：
            1. 执行 ? GeneratorYield(CreateIteratorResultObject(_E_, *false*))。
          1. 返回 NormalCompletion(*undefined*)。
        1. 令 _iterator_ 为 CreateIteratorFromClosure(_closure_, ~empty~, %Iterator.prototype%)。
        1. 返回 Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorPrototype.next%, [[Done]]: *false* }。
      </emu-alg>
      <emu-note>
        <p>该列表迭代器对象对 ECMAScript 代码不可直接访问。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-iteratortolist" oldids="sec-iterabletolist" type="abstract operation">
      <h1>
        IteratorToList (
          _iteratorRecord_: 一个 Iterator Record,
        ): 返回包含 ECMAScript 语言值 List 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _values_ 为新空 List。
        1. 循环：
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 若 _next_ 是 ~done~，
            1. 返回 _values_。
          1. 将 _next_ 加入 _values_。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>语法指引操作 (Syntax-Directed Operations)</h1>
  <p>除了本节定义的操作外，规范其余部分还定义了许多专门的语法指引操作。</p>

  <emu-clause id="sec-evaluation" type="sdo">
    <h1>运行时语义：Evaluation ( ): 一个 Completion Record</h1>
    <dl class="header">
      <dt>effects</dt>
      <dd>user-code</dd>
    </dl>
    <emu-note>
      本操作的定义分布在本规范“ECMAScript Language”各章节中。每个定义出现在相关产生式首次定义之后。
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>作用域分析 (Scope Analysis)</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>静态语义：BoundNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* 在本规范中用作模块默认导出的合成名称（当它没有其它名称时）。模块的 [[Environment]] 中会以该名称创建一个条目并保存相应的值，对该模块调用 <emu-xref href="#sec-resolveexport" title></emu-xref> 解析名为 *"default"* 的导出会返回一个 [[BindingName]] 为 *"\*default\*"* 的 ResolvedBinding Record，随后它在模块的 [[Environment]] 中解析为上述的值。此举仅为规范书写方便，使匿名默认导出能与其它导出统一解析。该 *"\*default\*"* 字符串在 ECMAScript 代码及模块链接算法中不可见。</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. 返回仅含 |Identifier| 的 StringValue 的列表。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. 返回 « *"yield"* »。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. 返回 « *"await"* »。
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingList| 的 BoundNames。
      </emu-alg>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingList| 的 BoundNames。
        1. 令 _names2_ 为 |LexicalBinding| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 |BindingPattern| 的 BoundNames。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |VariableDeclarationList| 的 BoundNames。
        1. 令 _names2_ 为 |VariableDeclaration| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 |BindingPattern| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingPropertyList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingRestProperty| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingRestElement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingElementList| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingElementList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingRestElement| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingPropertyList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingProperty| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingElementList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingElisionElement| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. 返回 |BindingElement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. 返回 |BindingElement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingPattern| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. 返回 |ForBinding| 的 BoundNames。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |FormalParameterList| 的 BoundNames。
        1. 令 _names2_ 为 |FunctionRestParameter| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |FormalParameterList| 的 BoundNames。
        1. 令 _names2_ 为 |FormalParameter| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 覆盖的 |ArrowFormalParameters|。
        1. 返回 _formals_ 的 BoundNames。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. 令 _head_ 为 |CoverCallExpressionAndAsyncArrowHead| 覆盖的 |AsyncArrowHead|。
        1. 返回 _head_ 的 BoundNames。
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 返回 |ImportClause| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ImportedDefaultBinding| 的 BoundNames。
        1. 令 _names2_ 为 |NameSpaceImport| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ImportedDefaultBinding| 的 BoundNames。
        1. 令 _names2_ 为 |NamedImports| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ImportsList| 的 BoundNames。
        1. 令 _names2_ 为 |ImportSpecifier| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. 返回 |ImportedBinding| 的 BoundNames。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. 返回 |VariableStatement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. 返回 |Declaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _declarationNames_ 为 |HoistableDeclaration| 的 BoundNames。
        1. 若 _declarationNames_ 不含 *"\*default\*"*，将 *"\*default\*"* 添加到 _declarationNames_。
        1. 返回 _declarationNames_。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _declarationNames_ 为 |ClassDeclaration| 的 BoundNames。
        1. 若 _declarationNames_ 不含 *"\*default\*"*，将 *"\*default\*"* 添加到 _declarationNames_。
        1. 返回 _declarationNames_。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-declarationpart" type="sdo">
      <h1>静态语义：DeclarationPart ( ): 一个 Parse Node</h1>
      <dl class="header">
      </dl>
      <emu-grammar>HoistableDeclaration : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration|。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : GeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |GeneratorDeclaration|。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncFunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |AsyncFunctionDeclaration|。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncGeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |AsyncGeneratorDeclaration|。
      </emu-alg>
      <emu-grammar>Declaration : ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |ClassDeclaration|。
      </emu-alg>
      <emu-grammar>Declaration : LexicalDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |LexicalDeclaration|。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>静态语义：IsConstantDeclaration ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. 返回 |LetOrConst| 的 IsConstantDeclaration。
      </emu-alg>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>无需将 `export default` |AssignmentExpression| 视作常量声明，因为不存在语法允许对用于引用模块默认对象的内部绑定名赋值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallydeclarednames" oldids="sec-block-static-semantics-lexicallydeclarednames,sec-switch-statement-static-semantics-lexicallydeclarednames,sec-labelled-statements-static-semantics-lexicallydeclarednames,sec-function-definitions-static-semantics-lexicallydeclarednames,sec-arrow-function-definitions-static-semantics-lexicallydeclarednames,sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames,sec-scripts-static-semantics-lexicallydeclarednames,sec-module-semantics-static-semantics-lexicallydeclarednames" type="sdo">
      <h1>静态语义：LexicallyDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 LexicallyDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 LexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |LabelledStatement| 的 LexicallyDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回 |Declaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _names1_ 为其 LexicallyDeclaredNames；否则 _names1_ 为新空列表。
        1. 令 _names2_ 为 |DefaultClause| 的 LexicallyDeclaredNames。
        1. 若第二个 |CaseClauses| 存在，令 _names3_ 为其 LexicallyDeclaredNames；否则 _names3_ 为新空列表。
        1. 返回 _names1_、_names2_、_names3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |CaseClauses| 的 LexicallyDeclaredNames。
        1. 令 _names2_ 为 |CaseClause| 的 LexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 LexicallyDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyDeclaredNames。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyDeclaredNames。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyDeclaredNames。
      </emu-alg>
      <emu-note>
        <p>|Script| 顶层的函数声明按 var 声明处理，而非按词法声明处理。</p>
      </emu-note>
      <emu-note>
        <p>|Module| 的 LexicallyDeclaredNames 包含其所有导入绑定的名称。</p>
      </emu-note>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ModuleItemList| 的 LexicallyDeclaredNames。
        1. 令 _names2_ 为 |ModuleItem| 的 LexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |ImportDeclaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. 若 |ExportDeclaration| 为 `export` |VariableStatement|，返回一个新的空列表。
        1. 返回 |ExportDeclaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
      <emu-alg>
        1. 返回 |StatementListItem| 的 LexicallyDeclaredNames。
      </emu-alg>
      <emu-note>
        <p>|Module| 顶层的函数声明按词法声明处理，而非按 var 声明。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" oldids="sec-block-static-semantics-lexicallyscopeddeclarations,sec-switch-statement-static-semantics-lexicallyscopeddeclarations,sec-labelled-statements-static-semantics-lexicallyscopeddeclarations,sec-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations,sec-scripts-static-semantics-lexicallyscopeddeclarations,sec-module-semantics-static-semantics-lexicallyscopeddeclarations,sec-exports-static-semantics-lexicallyscopeddeclarations" type="sdo">
      <h1>静态语义：LexicallyScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 LexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 LexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |LabelledStatement| 的 LexicallyScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |Declaration| 的 DeclarationPart 的列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _declarations1_ 为其 LexicallyScopedDeclarations；否则 _declarations1_ 为新空列表。
        1. 令 _declarations2_ 为 |DefaultClause| 的 LexicallyScopedDeclarations。
        1. 若第二个 |CaseClauses| 存在，令 _declarations3_ 为其 LexicallyScopedDeclarations；否则 _declarations3_ 为新空列表。
        1. 返回 _declarations1_、_declarations2_、_declarations3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |CaseClauses| 的 LexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |CaseClause| 的 LexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 LexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 « |FunctionDeclaration| »。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |ModuleItemList| 的 LexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |ModuleItem| 的 LexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |Declaration| 的 DeclarationPart 的列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |HoistableDeclaration| 的 DeclarationPart 的列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |ClassDeclaration| 的列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 返回仅含本 |ExportDeclaration| 的列表。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-vardeclarednames" oldids="sec-statement-semantics-static-semantics-vardeclarednames,sec-block-static-semantics-vardeclarednames,sec-variable-statement-static-semantics-vardeclarednames,sec-if-statement-static-semantics-vardeclarednames,sec-do-while-statement-static-semantics-vardeclarednames,sec-while-statement-static-semantics-vardeclarednames,sec-for-statement-static-semantics-vardeclarednames,sec-for-in-and-for-of-statements-static-semantics-vardeclarednames,sec-with-statement-static-semantics-vardeclarednames,sec-switch-statement-static-semantics-vardeclarednames,sec-labelled-statements-static-semantics-vardeclarednames,sec-try-statement-static-semantics-vardeclarednames,sec-function-definitions-static-semantics-vardeclarednames,sec-arrow-function-definitions-static-semantics-vardeclarednames,sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames,sec-scripts-static-semantics-vardeclarednames,sec-module-semantics-static-semantics-vardeclarednames" type="sdo">
      <h1>静态语义：VarDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
      <emu-alg>
        1. 返回 |VariableDeclarationList| 的 BoundNames。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为第一个 |Statement| 的 VarDeclaredNames。
        1. 令 _names2_ 为第二个 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |VariableDeclarationList| 的 BoundNames。
        1. 令 _names2_ 为 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ForBinding| 的 BoundNames。
        1. 令 _names2_ 为 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-note>
        <p>本节由附件 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _names1_ 为其 VarDeclaredNames；否则 _names1_ 为新空列表。
        1. 令 _names2_ 为 |DefaultClause| 的 VarDeclaredNames。
        1. 若第二个 |CaseClauses| 存在，令 _names3_ 为其 VarDeclaredNames；否则 _names3_ 为新空列表。
        1. 返回 _names1_、_names2_、_names3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |CaseClauses| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |CaseClause| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |Block| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |Catch| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |Block| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |Finally| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |Block| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |Catch| 的 VarDeclaredNames。
        1. 令 _names3_ 为 |Finally| 的 VarDeclaredNames。
        1. 返回 _names1_、_names2_、_names3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ModuleItemList| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |ModuleItem| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. 若 |ExportDeclaration| 为 `export` |VariableStatement|，返回 |ExportDeclaration| 的 BoundNames。
        1. 返回一个新的空列表。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-varscopeddeclarations" oldids="sec-statement-semantics-static-semantics-varscopeddeclarations,sec-block-static-semantics-varscopeddeclarations,sec-variable-statement-static-semantics-varscopeddeclarations,sec-if-statement-static-semantics-varscopeddeclarations,sec-do-while-statement-static-semantics-varscopeddeclarations,sec-while-statement-static-semantics-varscopeddeclarations,sec-for-statement-static-semantics-varscopeddeclarations,sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations,sec-with-statement-static-semantics-varscopeddeclarations,sec-switch-statement-static-semantics-varscopeddeclarations,sec-labelled-statements-static-semantics-varscopeddeclarations,sec-try-statement-static-semantics-varscopeddeclarations,sec-function-definitions-static-semantics-varscopeddeclarations,sec-arrow-function-definitions-static-semantics-varscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations,sec-scripts-static-semantics-varscopeddeclarations,sec-module-semantics-static-semantics-varscopeddeclarations" type="sdo">
      <h1>静态语义：VarScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 « |VariableDeclaration| »。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |VariableDeclarationList| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 « |VariableDeclaration| » 的列表拼接。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为第一个 |Statement| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为第二个 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |VariableDeclarationList| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 « |ForBinding| »。
        1. 令 _declarations2_ 为 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-note>
        <p>本节由附件 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _declarations1_ 为其 VarScopedDeclarations；否则 _declarations1_ 为新空列表。
        1. 令 _declarations2_ 为 |DefaultClause| 的 VarScopedDeclarations。
        1. 若第二个 |CaseClauses| 存在，令 _declarations3_ 为其 VarScopedDeclarations；否则 _declarations3_ 为新空列表。
        1. 返回 _declarations1_、_declarations2_、_declarations3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |CaseClauses| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |CaseClause| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |Block| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Catch| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |Block| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Finally| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |Block| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Catch| 的 VarScopedDeclarations。
        1. 令 _declarations3_ 为 |Finally| 的 VarScopedDeclarations。
        1. 返回 _declarations1_、_declarations2_、_declarations3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |ModuleItemList| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |ModuleItem| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. 若 |ExportDeclaration| 为 `export` |VariableStatement|，返回 |VariableStatement| 的 VarScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallydeclarednames" oldids="sec-block-static-semantics-toplevellexicallydeclarednames,sec-labelled-statements-static-semantics-toplevellexicallydeclarednames" type="sdo">
      <h1>静态语义：TopLevelLexicallyDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 TopLevelLexicallyDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 TopLevelLexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 返回一个新的空列表。
        1. 返回 |Declaration| 的 BoundNames。
      </emu-alg>
      <emu-note>
        <p>函数或脚本顶层中，函数声明按 var 声明而非词法声明处理。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallyscopeddeclarations" oldids="sec-block-static-semantics-toplevellexicallyscopeddeclarations,sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations" type="sdo">
      <h1>静态语义：TopLevelLexicallyScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 TopLevelLexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 返回一个新的空列表。
        1. 返回 « |Declaration| »。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvardeclarednames" oldids="sec-block-static-semantics-toplevelvardeclarednames,sec-labelled-statements-static-semantics-toplevelvardeclarednames" type="sdo">
      <h1>静态语义：TopLevelVarDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 TopLevelVarDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 TopLevelVarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 返回 |HoistableDeclaration| 的 BoundNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarDeclaredNames。
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-note>
        <p>函数或脚本顶层的内部函数声明按 var 声明处理。</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarDeclaredNames。
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration| 的 BoundNames。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvarscopeddeclarations" oldids="sec-block-static-semantics-toplevelvarscopeddeclarations,sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations" type="sdo">
      <h1>静态语义：TopLevelVarScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 TopLevelVarScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 TopLevelVarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarScopedDeclarations。
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 令 _declaration_ 为 |HoistableDeclaration| 的 DeclarationPart。
          1. 返回 « _declaration_ »。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarScopedDeclarations。
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 « |FunctionDeclaration| »。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-labels">
    <h1>标签 (Labels)</h1>

    <emu-clause id="sec-static-semantics-containsduplicatelabels" oldids="sec-statement-semantics-static-semantics-containsduplicatelabels,sec-block-static-semantics-containsduplicatelabels,sec-if-statement-static-semantics-containsduplicatelabels,sec-do-while-statement-static-semantics-containsduplicatelabels,sec-while-statement-static-semantics-containsduplicatelabels,sec-for-statement-static-semantics-containsduplicatelabels,sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels,sec-with-statement-static-semantics-containsduplicatelabels,sec-switch-statement-static-semantics-containsduplicatelabels,sec-labelled-statements-static-semantics-containsduplicatelabels,sec-try-statement-static-semantics-containsduplicatelabels,sec-function-definitions-static-semantics-containsduplicatelabels,sec-module-semantics-static-semantics-containsduplicatelabels" type="sdo">
      <h1>
        静态语义：ContainsDuplicateLabels (
          _labelSet_: 一个字符串列表,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |StatementList| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |StatementListItem| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicate_ 为第一个 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicate_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，则
          1. 若第一个 |CaseClauses| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |DefaultClause| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 不存在，返回 *false*。
        1. 返回第二个 |CaseClauses| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |CaseClauses| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |CaseClause| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 若 _labelSet_ 包含 _label_，返回 *true*。
        1. 令 _newLabelSet_ 为 _labelSet_ 与 « _label_ » 的列表拼接。
        1. 返回 |LabelledItem| 的 ContainsDuplicateLabels（参数 _newLabelSet_）。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |Catch| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 若 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |Catch| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |ModuleItemList| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |ModuleItem| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedbreaktarget" oldids="sec-statement-semantics-static-semantics-containsundefinedbreaktarget,sec-block-static-semantics-containsundefinedbreaktarget,sec-if-statement-static-semantics-containsundefinedbreaktarget,sec-do-while-statement-static-semantics-containsundefinedbreaktarget,sec-while-statement-static-semantics-containsundefinedbreaktarget,sec-for-statement-static-semantics-containsundefinedbreaktarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget,sec-break-statement-static-semantics-containsundefinedbreaktarget,sec-with-statement-static-semantics-containsundefinedbreaktarget,sec-switch-statement-static-semantics-containsundefinedbreaktarget,sec-labelled-statements-static-semantics-containsundefinedbreaktarget,sec-try-statement-static-semantics-containsundefinedbreaktarget,sec-function-definitions-static-semantics-containsundefinedbreaktarget,sec-module-semantics-static-semantics-containsundefinedbreaktarget" type="sdo">
      <h1>
        静态语义：ContainsUndefinedBreakTarget (
          _labelSet_: 一个字符串列表,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |StatementList| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |StatementListItem| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为第一个 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. 若 _labelSet_ 不包含 |LabelIdentifier| 的 StringValue，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，则
          1. 若第一个 |CaseClauses| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |DefaultClause| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 不存在，返回 *false*。
        1. 返回第二个 |CaseClauses| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |CaseClauses| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |CaseClause| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 令 _newLabelSet_ 为 _labelSet_ 与 « _label_ » 的列表拼接。
        1. 返回 |LabelledItem| 的 ContainsUndefinedBreakTarget（参数 _newLabelSet_）。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Catch| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 若 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |Catch| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |ModuleItemList| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |ModuleItem| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedcontinuetarget" oldids="sec-statement-semantics-static-semantics-containsundefinedcontinuetarget,sec-block-static-semantics-containsundefinedcontinuetarget,sec-if-statement-static-semantics-containsundefinedcontinuetarget,sec-do-while-statement-static-semantics-containsundefinedcontinuetarget,sec-while-statement-static-semantics-containsundefinedcontinuetarget,sec-for-statement-static-semantics-containsundefinedcontinuetarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget,sec-continue-statement-static-semantics-containsundefinedcontinuetarget,sec-with-statement-static-semantics-containsundefinedcontinuetarget,sec-switch-statement-static-semantics-containsundefinedcontinuetarget,sec-labelled-statements-static-semantics-containsundefinedcontinuetarget,sec-try-statement-static-semantics-containsundefinedcontinuetarget,sec-function-definitions-static-semantics-containsundefinedcontinuetarget,sec-module-semantics-static-semantics-containsundefinedcontinuetarget" type="sdo">
      <h1>
        静态语义：ContainsUndefinedContinueTarget (
          _iterationSet_: 一个字符串列表,
          _labelSet_: 一个字符串列表,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>Statement : BlockStatement</emu-grammar>
      <emu-alg>
        1. 返回 |BlockStatement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. 令 _newIterationSet_ 为 _iterationSet_ 与 _labelSet_ 的列表拼接。
        1. 返回 |IterationStatement| 的 ContainsUndefinedContinueTarget（参数 _newIterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |StatementList| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |StatementListItem| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为第一个 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. 若 _iterationSet_ 不包含 |LabelIdentifier| 的 StringValue，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，则
          1. 若第一个 |CaseClauses| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 若 |DefaultClause| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 不存在，返回 *false*。
        1. 返回第二个 |CaseClauses| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |CaseClauses| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |CaseClause| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 令 _newLabelSet_ 为 _labelSet_ 与 « _label_ » 的列表拼接。
        1. 返回 |LabelledItem| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 _newLabelSet_）。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Catch| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 若 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 若 |Catch| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |ModuleItemList| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |ModuleItem| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-function-name-inference">
    <h1>函数名称推断 (Function Name Inference)</h1>

    <emu-clause id="sec-static-semantics-hasname" oldids="sec-semantics-static-semantics-hasname,sec-function-definitions-static-semantics-hasname,sec-arrow-function-definitions-static-semantics-hasname,sec-generator-function-definitions-static-semantics-hasname,sec-async-generator-function-definitions-static-semantics-hasname,sec-class-definitions-static-semantics-hasname,sec-async-function-definitions-static-semantics-HasName,sec-async-arrow-function-definitions-static-semantics-HasName" type="sdo">
      <h1>静态语义：HasName ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 如果 _expr_ 的 IsFunctionDefinition 为 *false*，返回 *false*。
        1. 返回 _expr_ 的 HasName。
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ArrowFunction :
          ArrowParameters `=>` ConciseBody

        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

        ClassExpression :
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isfunctiondefinition" oldids="sec-semantics-static-semantics-isfunctiondefinition,sec-grouping-operator-static-semantics-isfunctiondefinition,sec-static-semantics-static-semantics-isfunctiondefinition,sec-update-expressions-static-semantics-isfunctiondefinition,sec-unary-operators-static-semantics-isfunctiondefinition,sec-exp-operator-static-semantics-isfunctiondefinition,sec-multiplicative-operators-static-semantics-isfunctiondefinition,sec-additive-operators-static-semantics-isfunctiondefinition,sec-bitwise-shift-operators-static-semantics-isfunctiondefinition,sec-relational-operators-static-semantics-isfunctiondefinition,sec-equality-operators-static-semantics-isfunctiondefinition,sec-binary-bitwise-operators-static-semantics-isfunctiondefinition,sec-binary-logical-operators-static-semantics-isfunctiondefinition,sec-conditional-operator-static-semantics-isfunctiondefinition,sec-assignment-operators-static-semantics-isfunctiondefinition,sec-comma-operator-static-semantics-isfunctiondefinition,sec-function-definitions-static-semantics-isfunctiondefinition,sec-generator-function-definitions-static-semantics-isfunctiondefinition,sec-async-generator-function-definitions-static-semantics-isfunctiondefinition,sec-class-definitions-static-semantics-isfunctiondefinition,sec-async-function-definitions-static-semantics-IsFunctionDefinition" type="sdo">
      <h1>静态语义：IsFunctionDefinition ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 返回 _expr_ 的 IsFunctionDefinition。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          RegularExpressionLiteral
          TemplateLiteral

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isanonymousfunctiondefinition" type="abstract operation">
      <h1>
        静态语义：IsAnonymousFunctionDefinition (
          _expr_: 一个 |AssignmentExpression| Parse Node、一个 |Initializer| Parse Node、或一个 |Expression| Parse Node,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于判定其参数是否为未绑定名称的函数定义。</dd>
      </dl>
      <emu-alg>
        1. 如果 _expr_ 的 IsFunctionDefinition 为 *false*，返回 *false*。
        1. 令 _hasName_ 为 _expr_ 的 HasName。
        1. 如果 _hasName_ 为 *true*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isidentifierref" oldids="sec-semantics-static-semantics-isidentifierref,sec-static-semantics-static-semantics-isidentifierref" type="sdo">
      <h1>静态语义：IsIdentifierRef ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
          CoverParenthesizedExpressionAndArrowParameterList

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-namedevaluation" oldids="sec-grouping-operator-runtime-semantics-namedevaluation,sec-function-definitions-runtime-semantics-namedevaluation,sec-arrow-function-definitions-runtime-semantics-namedevaluation,sec-generator-function-definitions-runtime-semantics-namedevaluation,sec-asyncgenerator-definitions-namedevaluation,sec-class-definitions-runtime-semantics-namedevaluation,sec-async-function-definitions-runtime-semantics-namedevaluation,sec-async-arrow-function-definitions-runtime-semantics-namedevaluation" type="sdo">
      <h1>
        运行时语义：NamedEvaluation (
          _name_: 一个属性键或一个 Private Name,
        ): 返回包含一个函数对象的正常完成或一个异常完成
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 返回 ? _expr_ 的 NamedEvaluation（参数 _name_）。
      </emu-alg>
      <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
      <emu-alg>
        1. 断言：IsAnonymousFunctionDefinition(|Expression|) 为 *true*。
        1. 返回 ? |Expression| 的 NamedEvaluation（参数 _name_）。
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionExpression| 的 InstantiateOrdinaryFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |GeneratorExpression| 的 InstantiateGeneratorFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncGeneratorExpression| 的 InstantiateAsyncGeneratorFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncFunctionExpression| 的 InstantiateAsyncFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 返回 |ArrowFunction| 的 InstantiateArrowFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncArrowFunction| 的 InstantiateAsyncArrowFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |ClassExpression| 匹配的源文本。
        1. 返回 ? |ClassTail| 的 ClassDefinitionEvaluation（参数 *undefined*, _name_, _sourceText_）。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        静态语义：Contains (
          _symbol_: 一个语法符号,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>本规范中未列于下表的每个语法产生式替代都隐式具有如下默认的 Contains 定义：</p>
      <emu-alg>
        1. 对该解析节点的每个子节点 _child_，执行
          1. 若 _child_ 是 _symbol_ 的一个实例，返回 *true*。
          1. 若 _child_ 是一个非终结符实例，则
            1. 令 _contained_ 为 _child_ Contains _symbol_ 的结果。
            1. 若 _contained_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>依赖子结构的静态语义规则通常不会深入函数定义内部。</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <emu-alg>
        1. 如果 _symbol_ 是 |ClassBody|，返回 *true*。
        1. 如果 _symbol_ 是 |ClassHeritage|，则
          1. 若 |ClassHeritage| 存在，返回 *true*；否则返回 *false*。
        1. 若 |ClassHeritage| 存在，则
          1. 若 |ClassHeritage| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 |ClassBody| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-note>
        <p>依赖子结构的静态语义规则通常不会深入类主体，除了 |PropertyName|。</p>
      </emu-note>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>依赖子结构的静态语义规则通常不会深入 `static` 初始化块。</p>
      </emu-note>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 不在 |NewTarget|、|SuperProperty|、|SuperCall|、`super`、`this` 之列，返回 *false*。
        1. 若 |ArrowParameters| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 |ConciseBody| Contains _symbol_。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ArrowFormalParameters|。
        1. 返回 _formals_ Contains _symbol_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 不在 |NewTarget|、|SuperProperty|、|SuperCall|、`super`、`this` 之列，返回 *false*。
        1. 返回 |AsyncConciseBody| Contains _symbol_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 不在 |NewTarget|、|SuperProperty|、|SuperCall|、`super`、`this` 之列，返回 *false*。
        1. 令 _head_ 为 |CoverCallExpressionAndAsyncArrowHead| 所覆盖的 |AsyncArrowHead|。
        1. 若 _head_ Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 |AsyncConciseBody| Contains _symbol_。
      </emu-alg>
      <emu-note>
        <p>Contains 用于在 |ArrowFunction| 或 |AsyncArrowFunction| 中检测 `new.target`、`this` 和 `super` 的使用。</p>
      </emu-note>
      <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
      <emu-alg>
        1. 如果 _symbol_ 是 |MethodDefinition|，返回 *true*。
        1. 返回 |MethodDefinition| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 |MemberExpression| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 是保留字 `super`，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 |CallExpression| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 |OptionalChain| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-computedpropertycontains" oldids="sec-object-initializer-static-semantics-computedpropertycontains,sec-method-definitions-static-semantics-computedpropertycontains,sec-generator-function-definitions-static-semantics-computedpropertycontains,sec-async-generator-function-definitions-static-semantics-computedpropertycontains,sec-class-definitions-static-semantics-computedpropertycontains,sec-async-function-definitions-static-semantics-ComputedPropertyContains" type="sdo">
      <h1>
        静态语义：ComputedPropertyContains (
          _symbol_: 一个语法符号,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ClassElementName : PrivateIdentifier

        PropertyName : LiteralPropertyName
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
      <emu-alg>
        1. 返回 |ComputedPropertyName| Contains _symbol_ 的结果。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. 令 _inList_ 为 |ClassElementList| 的 ComputedPropertyContains（参数 _symbol_）。
        1. 若 _inList_ 为 *true*，返回 *true*。
        1. 返回 |ClassElement| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>其它 (Miscellaneous)</h1>
    <p>这些操作在规范的多个位置被使用。</p>

    <emu-clause id="sec-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        运行时语义：InstantiateFunctionObject (
          _env_: 一个 Environment Record,
          _privateEnv_: 一个 PrivateEnvironment Record 或 *null*,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration| 的 InstantiateOrdinaryFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |GeneratorDeclaration| 的 InstantiateGeneratorFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncGeneratorDeclaration| 的 InstantiateAsyncGeneratorFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncFunctionDeclaration| 的 InstantiateAsyncFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindinginitialization" oldids="sec-identifiers-runtime-semantics-bindinginitialization,sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization" type="sdo">
      <h1>
        运行时语义：BindingInitialization (
          _value_: 一个 ECMAScript 语言值,
          _environment_: 一个 Environment Record 或 *undefined*,
        ): 返回包含 ~unused~ 的正常完成或一个异常完成
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>当 _environment_ 传入 *undefined* 时表示应使用 PutValue 操作来赋值初始化值。对于 `var` 语句以及某些非严格函数的形式参数列表即是这种情况（参见 <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>）。在这些情况下词法绑定在其初始化器求值前被提升并预初始化。</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 |Identifier| 的 StringValue。
        1. 返回 ? InitializeBoundName(_name_, _value_, _environment_)。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. 返回 ? InitializeBoundName(*"yield"*, _value_, _environment_)。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. 返回 ? InitializeBoundName(*"await"*, _value_, _environment_)。
      </emu-alg>
      <emu-grammar>BindingPattern : ObjectBindingPattern</emu-grammar>
      <emu-alg>
        1. 执行 ? RequireObjectCoercible(_value_)。
        1. 返回 ? |ObjectBindingPattern| 的 BindingInitialization（参数 _value_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingPattern : ArrayBindingPattern</emu-grammar>
      <emu-alg>
        1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
        1. 令 _result_ 为 Completion(|ArrayBindingPattern| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）)。
        1. 如果 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _result_)。
        1. 返回 ? _result_。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>
        ObjectBindingPattern :
          `{` BindingPropertyList `}`
          `{` BindingPropertyList `,` `}`
      </emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingPropertyList| 的 PropertyBindingInitialization（参数 _value_, _environment_）。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 令 _excludedNames_ 为新的空列表。
        1. 返回 ? |BindingRestProperty| 的 RestBindingInitialization（参数 _value_, _environment_, _excludedNames_）。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 令 _excludedNames_ 为 ? |BindingPropertyList| 的 PropertyBindingInitialization（参数 _value_, _environment_）。
        1. 返回 ? |BindingRestProperty| 的 RestBindingInitialization（参数 _value_, _environment_, _excludedNames_）。
      </emu-alg>

      <emu-clause id="sec-initializeboundname" type="abstract operation">
        <h1>
          InitializeBoundName (
            _name_: 一个 String,
            _value_: 一个 ECMAScript 语言值,
            _environment_: 一个 Environment Record 或 *undefined*,
          ): 返回包含 ~unused~ 的正常完成或一个异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _environment_ 不为 *undefined*，则
            1. 执行 ! _environment_.InitializeBinding(_name_, _value_)。
            1. 返回 ~unused~。
          1. 否则，
            1. 令 _lhs_ 为 ? ResolveBinding(_name_)。
            1. 返回 ? PutValue(_lhs_, _value_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        运行时语义：IteratorBindingInitialization (
          _iteratorRecord_: 一个 Iterator Record,
          _environment_: 一个 Environment Record 或 *undefined*,
        ): 返回包含 ~unused~ 的正常完成或一个异常完成
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>当 _environment_ 为 *undefined* 时表示应使用 PutValue 操作来赋初始化值。这用于非严格函数的形式参数列表，在那种情况下形式参数绑定会被预初始化以应对同名参数出现的可能。</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. 返回 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 如果 |Elision| 存在，则
          1. 执行 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
        1. 返回 ? |BindingRestElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingElementList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingElementList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 如果 |Elision| 存在，则
          1. 执行 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
        1. 返回 ? |BindingRestElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingElementList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |BindingElisionElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. 执行 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
        1. 返回 ? |BindingElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _lhs_ 为 ? ResolveBinding(_bindingId_, _environment_)。
        1. 令 _v_ 为 *undefined*。
        1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 不是 ~done~，则
            1. 设 _v_ 为 _next_。
        1. 如果 |Initializer| 存在且 _v_ 为 *undefined*，则
          1. 如果 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
            1. 设 _v_ 为 ? |Initializer| 的 NamedEvaluation（参数 _bindingId_）。
          1. 否则，
            1. 令 _defaultValue_ 为 ? |Initializer| 的 Evaluation。
            1. 设 _v_ 为 ? GetValue(_defaultValue_)。
        1. 如果 _environment_ 为 *undefined*，返回 ? PutValue(_lhs_, _v_)。
        1. 返回 ? InitializeReferencedBinding(_lhs_, _v_)。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. 令 _v_ 为 *undefined*。
        1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 不是 ~done~，则
            1. 设 _v_ 为 _next_。
        1. 如果 |Initializer| 存在且 _v_ 为 *undefined*，则
          1. 令 _defaultValue_ 为 ? |Initializer| 的 Evaluation。
          1. 设 _v_ 为 ? GetValue(_defaultValue_)。
        1. 返回 ? |BindingPattern| 的 BindingInitialization（参数 _v_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 令 _lhs_ 为 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_)。
        1. 令 _A_ 为 ! ArrayCreate(0)。
        1. 令 _n_ 为 0。
        1. 重复，
          1. 令 _next_ 为 ~done~。
          1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 设 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 是 ~done~，则
            1. 如果 _environment_ 为 *undefined*，返回 ? PutValue(_lhs_, _A_)。
            1. 返回 ? InitializeReferencedBinding(_lhs_, _A_)。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)。
          1. 设 _n_ 为 _n_ + 1。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. 令 _A_ 为 ! ArrayCreate(0)。
        1. 令 _n_ 为 0。
        1. 重复，
          1. 令 _next_ 为 ~done~。
          1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 设 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 是 ~done~，则
            1. 返回 ? |BindingPattern| 的 BindingInitialization（参数 _A_, _environment_）。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)。
          1. 设 _n_ 为 _n_ + 1。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 执行 ? |FormalParameterList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |FunctionRestParameter| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 执行 ? |FormalParameterList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |FormalParameter| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 令 _v_ 为 *undefined*。
        1. 断言：_iteratorRecord_.[[Done]] 为 *false*。
        1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
        1. 如果 _next_ 不是 ~done~，则
          1. 设 _v_ 为 _next_。
        1. 返回 ? |BindingIdentifier| 的 BindingInitialization（参数 _v_, _environment_）。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ArrowFormalParameters|。
        1. 返回 ? _formals_ 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 令 _v_ 为 *undefined*。
        1. 断言：_iteratorRecord_.[[Done]] 为 *false*。
        1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
        1. 如果 _next_ 不是 ~done~，则
          1. 设 _v_ 为 _next_。
        1. 返回 ? |BindingIdentifier| 的 BindingInitialization（参数 _v_, _environment_）。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-assignmenttargettype" oldids="sec-identifiers-static-semantics-assignmenttargettype,sec-identifiers-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype,sec-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-grouping-operator-static-semantics-assignmenttargettype,sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget,sec-static-semantics-static-semantics-assignmenttargettype,sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-update-expressions-static-semantics-assignmenttargettype,sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget,sec-unary-operators-static-semantics-assignmenttargettype,sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget,sec-exp-operator-static-semantics-assignmenttargettype,sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget,sec-multiplicative-operators-static-semantics-assignmenttargettype,sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget,sec-additive-operators-static-semantics-assignmenttargettype,sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget,sec-bitwise-shift-operators-static-semantics-assignmenttargettype,sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget,sec-relational-operators-static-semantics-assignmenttargettype,sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget,sec-equality-operators-static-semantics-assignmenttargettype,sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-bitwise-operators-static-semantics-assignmenttargettype,sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-logical-operators-static-semantics-assignmenttargettype,sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-conditional-operator-static-semantics-assignmenttargettype,sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget,sec-assignment-operators-static-semantics-assignmenttargettype,sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget,sec-comma-operator-static-semantics-assignmenttargettype,sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" type="sdo">
      <h1>静态语义：AssignmentTargetType ( ): ~simple~、~web-compat~ 或 ~invalid~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. 如果 IsStrict(this |IdentifierReference|) 为 *true* 且 |Identifier| 的 StringValue 是 *"eval"* 或 *"arguments"*，返回 ~invalid~。
        1. 返回 ~simple~。
      </emu-alg>
      <emu-grammar>
        IdentifierReference :
          `yield`
          `await`

        CallExpression :
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MemberExpression `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 ~simple~。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          CoverParenthesizedExpressionAndArrowParameterList
      </emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 返回 _expr_ 的 AssignmentTargetType。
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. [id="step-assignmenttargettype-web-compat", normative-optional] 如果宿主是 Web 浏览器或以其他方式支持 <emu-xref href="#sec-runtime-errors-for-function-call-assignment-targets" title></emu-xref> 且 IsStrict(this |CallExpression|) 为 *false*，则
          1. 返回 ~web-compat~。
        1. 返回 ~invalid~。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral

        CallExpression :
          SuperCall
          ImportCall
          CallExpression TemplateLiteral

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression TemplateLiteral
          `new` MemberExpression Arguments

        NewTarget :
          `new` `.` `target`

        ImportMeta :
          `import` `.` `meta`

        LeftHandSideExpression :
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 ~invalid~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-propname" oldids="sec-object-initializer-static-semantics-propname,sec-method-definitions-static-semantics-propname,sec-generator-function-definitions-static-semantics-propname,sec-async-generator-function-definitions-static-semantics-propname,sec-class-definitions-static-semantics-propname,sec-async-function-definitions-static-semantics-PropName" type="sdo">
      <h1>静态语义：PropName ( ): 一个 String 或 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
      <emu-alg>
        1. 返回 |IdentifierReference| 的 StringValue。
      </emu-alg>
      <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 返回 |PropertyName| 的 PropName。
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : IdentifierName

        AttributeKey : IdentifierName
      </emu-grammar>
      <emu-alg>
        1. 返回 |IdentifierName| 的 StringValue。
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : StringLiteral

        AttributeKey : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. 返回 |StringLiteral| 的 SV。
      </emu-alg>
      <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
      <emu-alg>
        1. 令 _nbr_ 为 |NumericLiteral| 的 NumericValue。
        1. 返回 ! ToString(_nbr_)。
      </emu-alg>
      <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>可执行代码与执行上下文 (Executable Code and Execution Contexts)</h1>

  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>环境记录 (Environment Records)</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn> 是一种规范类型，用于基于 ECMAScript 代码的词法嵌套结构，将 |Identifier| 与特定变量及函数建立关联。通常一个 Environment Record 与某个特定的 ECMAScript 语法结构关联，如 |FunctionDeclaration|、|BlockStatement| 或 |TryStatement| 的 |Catch| 子句。每当这类代码被求值时，就会新建一个 Environment Record，用来记录该代码创建的标识符绑定。</p>
    <p>每个 Environment Record 都有一个 [[OuterEnv]] 字段，其值为 *null* 或指向一个外层 Environment Record，用来建模 Environment Record 值的逻辑嵌套。一个（内层）Environment Record 的外层引用指向在逻辑上包围它的 Environment Record。外层 Environment Record 当然也可以再有自己的外层引用。一个 Environment Record 可以作为多个内层 Environment Record 的外层环境。例如，若一个 |FunctionDeclaration| 内含两个嵌套的 |FunctionDeclaration|，那么这两个嵌套函数的 Environment Record 的外层 Environment Record 都是外层函数当前求值对应的 Environment Record。</p>
    <p>Environment Record 纯属规范机制，不需要对应到 ECMAScript 实现中的任何具体产物。ECMAScript 程序无法直接访问或操纵这些值。</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>Environment Record 类型层次 (The Environment Record Type Hierarchy)</h1>
      <p>可以将 Environment Record 看作是一个简单的面向对象层次结构：Environment Record 是一个抽象类，具有三个具体子类：Declarative Environment Record、Object Environment Record 和 Global Environment Record。Function Environment Record 与 Module Environment Record 是 Declarative Environment Record 的子类。</p>
      <ul>
        <li>
          <p>Environment Record (抽象)</p>
          <ul>
            <li>
              <p><em>Declarative Environment Record</em> 用于定义 ECMAScript 语言语法元素（如 |FunctionDeclaration|、|VariableDeclaration|、|Catch| 子句）对标识符绑定与 ECMAScript 语言值直接关联所产生的效果。</p>
              <ul>
                <li>
                  <p><em>Function Environment Record</em> 对应一次 ECMAScript 函数对象的调用，包含该函数顶层声明的绑定；它可以建立新的 `this` 绑定，并捕获支持 `super` 方法调用所需的状态。</p>
                </li>
                <li>
                  <p><em>Module Environment Record</em> 包含 |Module| 的顶层声明绑定，也包含该 |Module| 显式导入的绑定。其 [[OuterEnv]] 为一个 Global Environment Record。</p>
                </li>
              </ul>
            </li>
            <li>
              <p><em>Object Environment Record</em> 用于定义类似 |WithStatement| 那样把标识符绑定关联到某对象属性的 ECMAScript 元素的效果。</p>
            </li>
            <li>
              <p><em>Global Environment Record</em> 用于 |Script| 的全局声明。它没有外层环境；其 [[OuterEnv]] 为 *null*。它可被预填充标识符绑定，并包含一个关联的全局对象，该对象的属性提供部分全局环境的标识符绑定。随着 ECMAScript 代码执行，可以向全局对象增加属性或修改初始属性。</p>
            </li>
          </ul>
        </li>
      </ul>

      <p>Environment Record 抽象类包含 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> 中定义的抽象规范方法。这些抽象方法在各具体子类上有不同的具体算法。</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Environment Record 的抽象方法" oldids="table-15">
        <table>
          <thead>
            <tr>
              <th>
                方法
              </th>
              <th>
                目的
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              判断 Environment Record 是否存在字符串值 _N_ 的绑定；存在返回 *true*，否则返回 *false*。
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              创建一个新的、未初始化的可变绑定。字符串 _N_ 为名称文本。若布尔参数 _D_ 为 *true*，该绑定之后可删除。
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              创建新的、未初始化的不可变绑定。字符串 _N_ 为名称文本。若 _S_ 为 *true*，初始化后再设置将始终抛出异常（与引用该绑定的操作是否严格模式无关）。
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              为已存在但未初始化的绑定设置值。_N_ 为名称文本，_V_ 为任意 ECMAScript 语言类型的值。
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              为已存在的可变绑定设置值 _V_。_S_ 为布尔标记；若 _S_ 为 *true* 且绑定无法被设置则抛出 *TypeError*。
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              返回已存在绑定的值。_S_ 标记引用是否源自严格模式（或需要严格语义）。若 _S_ 为 *true* 且绑定不存在抛 *ReferenceError*。若绑定存在但未初始化，无论 _S_ 值为何都抛 *ReferenceError*。
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              删除名称为 _N_ 的绑定。存在则移除并返回 *true*；存在但不可移除返回 *false*；不存在返回 *true*。
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              判断是否建立 `this` 绑定；是返回 *true*，否则 *false*。
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              判断是否建立 `super` 方法绑定；是返回 *true*，否则 *false*。若返回 *true* 则表明该记录是 Function Environment Record（反之不一定）。
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              若该 Environment Record 与 `with` 语句关联则返回其对象；否则返回 *undefined*。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>声明式环境记录 (Declarative Environment Records)</h1>
        <p>每个 <dfn variants="Declarative Environment Records">Declarative Environment Record</dfn> 与一个 ECMAScript 程序作用域关联，该作用域包含变量、常量、let、class、module、import 以及（或）函数声明。Declarative Environment Record 绑定其作用域内声明定义的标识符集合。</p>

        <emu-clause id="sec-declarative-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>判定参数标识符是否在记录绑定的标识符之中。</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_ 对 _N_ 有绑定，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新的未初始化可变绑定。_envRec_ 中不得已存在该名称绑定。若 _D_ 为 *true*，新绑定标记为可删除。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 尚无 _N_ 绑定。
            1. 在 _envRec_ 中创建 _N_ 的可变绑定并记录其未初始化。若 _D_ 为 *true*，记录该绑定可被后续 DeleteBinding 删除。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新的未初始化不可变绑定。不得已存在绑定。若 _S_ 为 *true*，新绑定标记为严格绑定。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 尚无 _N_ 绑定。
            1. 在 _envRec_ 中创建 _N_ 的不可变绑定并记录其未初始化。若 _S_ 为 *true*，记录其为严格绑定。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>将名称为 _N_ 的当前绑定的值设为 _V_。必须已存在未初始化绑定。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 必须有 _N_ 的未初始化绑定。
            1. 将 _envRec_ 中 _N_ 的绑定值设为 _V_。
            1. <emu-not-ref>记录</emu-not-ref> _envRec_ 中 _N_ 的绑定已被初始化。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或一个抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>尝试将名称为 _N_ 的当前绑定的值改为 _V_。通常已有该绑定，但在少见情况下可能没有。若绑定为不可变且 _S_ 为 *true*，抛 *TypeError*。</dd>
          </dl>
          <emu-alg>
            1. [id="step-setmutablebinding-missing-binding"] 若 _envRec_ 无 _N_ 绑定，则
              1. 若 _S_ 为 *true*，抛 *ReferenceError*。
              1. 执行 ! _envRec_.CreateMutableBinding(_N_, *true*)。
              1. 执行 ! _envRec_.InitializeBinding(_N_, _V_)。
              1. 返回 ~unused~。
            1. 若 _envRec_ 中 _N_ 的绑定是严格绑定，将 _S_ 设为 *true*。
            1. 若 _envRec_ 中 _N_ 的绑定尚未初始化，则
              1. 抛 *ReferenceError*。
            1. 否则若为可变绑定，
              1. 将其值改为 _V_。
            1. 否则，
              1. 断言：正在尝试修改不可变绑定的值。
              1. 若 _S_ 为 *true*，抛 *TypeError*。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>导致在步骤 <emu-xref href="#step-setmutablebinding-missing-binding"></emu-xref> 出现缺失绑定的 ECMAScript 示例：</p>
            <pre><code class="javascript">function f() { eval("var x; x = (delete x, 0);"); }</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或一个抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回名称为 _N_ 的绑定值。若绑定存在但未初始化，无论 _S_ 值为何都抛 *ReferenceError*。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 有 _N_ 的绑定。
            1. 若其为未初始化绑定，抛 *ReferenceError*。
            1. 返回当前绑定于 _N_ 的值。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>只能删除已显式标记为可删除的绑定。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 有 _N_ 的绑定。
            1. 若该绑定不可删除，返回 *false*。
            1. 从 _envRec_ 移除该绑定。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>普通 Declarative Environment Record（即既不是 Function 也不是 Module Environment Record）不提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>普通 Declarative Environment Record 不提供 `super` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>对象环境记录 (Object Environment Records)</h1>
        <p>每个 <dfn variants="Object Environment Records">Object Environment Record</dfn> 关联一个称为其 <em>binding object</em> 的对象。它绑定该对象属性名中与字符串标识符名称直接对应的集合。不是 |IdentifierName| 形式字符串的属性键不计入。集合包含自有与继承属性，与其 [[Enumerable]] 属性设置无关。由于对象属性可动态添加/删除，对应绑定集合可能随任何添加或删除属性的操作产生副作用而变化。副作用新增的绑定被视为可变绑定，即使对应属性的 Writable 为 *false*。Object Environment Record 不存在不可变绑定。</p>
        <p>为 `with` 语句（<emu-xref href="#sec-with-statement"></emu-xref>）创建的 Object Environment Record 可以在函数调用中将其绑定对象作为隐式 *this* 值。该能力由布尔字段 [[IsWithEnvironment]] 控制。</p>
        <p>Object Environment Record 具有 <emu-xref href="#table-additional-fields-of-object-environment-records"></emu-xref> 所列附加状态字段。</p>
        <emu-table id="table-additional-fields-of-object-environment-records" caption="Object Environment Record 的附加字段">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[BindingObject]]
              </td>
              <td>
                一个 Object
              </td>
              <td>
                此 Environment Record 的绑定对象。
              </td>
            </tr>
            <tr>
              <td>
                [[IsWithEnvironment]]
              </td>
              <td>
                一个 Boolean
              </td>
              <td>
                指示该记录是否为 `with` 语句创建。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-object-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>判定其绑定对象是否有名为 _N_ 的属性。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 令 _foundBinding_ 为 ? HasProperty(_bindingObject_, _N_)。
            1. 若 _foundBinding_ 为 *false*，返回 *false*。
            1. 若 _envRec_.[[IsWithEnvironment]] 为 *false*，返回 *true*。
            1. 令 _unscopables_ 为 ? Get(_bindingObject_, %Symbol.unscopables%)。
            1. 若 _unscopables_ 是 Object，则
              1. 令 _blocked_ 为 ToBoolean(? Get(_unscopables_, _N_))。
              1. 若 _blocked_ 为 *true*，返回 *false*。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>在绑定对象上创建名为 _N_ 的属性，并初始化为 *undefined*。若 _D_ 为 *true*，新属性的 [[Configurable]] 设为 *true*，否则为 *false*。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 执行 ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ })。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>通常 _envRec_ 不会已有 _N_ 绑定；若已存在，DefinePropertyOrThrow 的语义可能替换、遮蔽或抛出异常。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>Object Environment Record 的 CreateImmutableBinding 具体方法在本规范中从未使用。</p>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>将名称为 _N_ 的当前绑定的值设为 _V_。</dd>
          </dl>
          <emu-alg>
            1. 执行 ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*)。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>在本规范中，对 Object Environment Record 调用 CreateMutableBinding 后立即调用 InitializeBinding，因此不显式跟踪其初始化状态。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>尝试将绑定对象名为 _N_ 的属性值设为 _V_。该属性通常已存在；若不存在或当前不可写，错误处理由 _S_ 决定。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 令 _stillExists_ 为 ? HasProperty(_bindingObject_, _N_)。
            1. 若 _stillExists_ 为 *false* 且 _S_ 为 *true*，抛 *ReferenceError*。
            1. 执行 ? Set(_bindingObject_, _N_, _V_, _S_)。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回绑定对象名为 _N_ 的属性值。若属性不存在，结果取决于 _S_。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 令 _value_ 为 ? HasProperty(_bindingObject_, _N_)。
            1. 若 _value_ 为 *false*，则
              1. 若 _S_ 为 *false*，返回 *undefined*；否则抛 *ReferenceError*。
            1. 返回 ? Get(_bindingObject_, _N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>只能删除其环境对象上 [[Configurable]] 为 *true* 的属性对应的绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 返回 ? <emu-meta effects="user-code">_bindingObject_.[[Delete]]</emu-meta>(_N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>Object Environment Record 不提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>Object Environment Record 不提供 `super` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): 一个 Object 或 *undefined*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_.[[IsWithEnvironment]] 为 *true*，返回 _envRec_.[[BindingObject]]。
            1. 否则返回 *undefined*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records" oldids="function-environment">
        <h1>函数环境记录 (Function Environment Records)</h1>
        <p><dfn variants="Function Environment Records">Function Environment Record</dfn> 是一个 Declarative Environment Record，表示函数的顶层作用域，并且若函数不是 |ArrowFunction|，则提供 `this` 绑定。若一个非 |ArrowFunction| 函数引用 `super`，其 Function Environment Record 也包含执行 `super` 方法调用所需的状态。</p>
        <p>Function Environment Record 有 <emu-xref href="#table-additional-fields-of-function-environment-records"></emu-xref> 中列出的附加状态字段。</p>
        <emu-table id="table-additional-fields-of-function-environment-records" caption="Function Environment Record 的附加字段" oldids="table-16">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                一个 ECMAScript 语言值
              </td>
              <td>
                此次函数调用使用的 *this* 值。
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                ~lexical~, ~initialized~, 或 ~uninitialized~
              </td>
              <td>
                若为 ~lexical~，表明是 |ArrowFunction|，无本地 *this*。
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                一个 ECMAScript 函数对象
              </td>
              <td>
                其调用导致此 Environment Record 被创建的函数对象。
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                一个 constructor 或 *undefined*
              </td>
              <td>
                若由 [[Construct]] 创建，则为该内部方法 _newTarget_ 参数；否则为 *undefined*。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>Function Environment Record 支持 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> 中列出的所有 Declarative Environment Record 方法，除 HasThisBinding 与 HasSuperBinding 外与其规范相同；另外支持 <emu-xref href="#table-additional-methods-of-function-environment-records"></emu-xref> 中列出的方法：</p>
        <emu-table id="table-additional-methods-of-function-environment-records" caption="Function Environment Record 的附加方法" oldids="table-17">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                返回该 Environment Record 的 `this` 绑定值，若尚未初始化则抛 *ReferenceError*。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-bindthisvalue" type="abstract operation">
          <h1>
            BindThisValue (
              _envRec_: 一个 Function Environment Record,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>设置 _envRec_.[[ThisValue]] 并记录其已初始化。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_.[[ThisBindingStatus]] 不为 ~lexical~。
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~initialized~，抛 *ReferenceError*。
            1. 设 _envRec_.[[ThisValue]] 为 _V_。
            1. 设 _envRec_.[[ThisBindingStatus]] 为 ~initialized~。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): 一个 Boolean</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~lexical~，返回 *false*；否则返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): 一个 Boolean</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~lexical~，返回 *false*。
            1. 若 _envRec_.[[FunctionObject]].[[HomeObject]] 为 *undefined*，返回 *false*；否则返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): 一个包含 ECMAScript 语言值的正常完成或抛出完成</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_.[[ThisBindingStatus]] 不为 ~lexical~。
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~uninitialized~，抛 *ReferenceError*。
            1. 返回 _envRec_.[[ThisValue]]。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getsuperbase" type="abstract operation">
          <h1>
            GetSuperBase (
              _envRec_: 一个 Function Environment Record,
            ): 一个 Object、*null* 或 *undefined*
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>返回在 _envRec_ 中绑定 `super` 属性访问的基对象。若为 *undefined*，表示该访问将产生运行时错误。</dd>
          </dl>
          <emu-alg>
            1. 令 _home_ 为 _envRec_.[[FunctionObject]].[[HomeObject]]。
            1. 若 _home_ 为 *undefined*，返回 *undefined*。
            1. 断言：_home_ 是普通对象。
            1. 返回 ! _home_.[[GetPrototypeOf]]()。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>全局环境记录 (Global Environment Records)</h1>
        <p><dfn variants="Global Environment Records">Global Environment Record</dfn> 表示在同一 realm 中处理的所有 ECMAScript |Script| 元素共享的最外层作用域。提供内置全局（<emu-xref href="#sec-global-object"></emu-xref>）、全局对象属性以及所有顶层声明（<emu-xref href="#sec-static-semantics-toplevellexicallyscopeddeclarations"></emu-xref>，<emu-xref href="#sec-static-semantics-toplevelvarscopeddeclarations"></emu-xref>）的绑定。</p>
        <p>Global Environment Record 在逻辑上是单一记录，但被描述为封装一个 Object Environment Record 和一个 Declarative Environment Record 的复合体。Object Environment Record 的基对象为关联 Realm Record 的全局对象。该全局对象是其 GetThisBinding 具体方法返回的值。Object 组件包含内置全局与由 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableStatement| 引入的全局代码绑定；其余声明的绑定位于 Declarative 组件。</p>
        <p>可以直接在全局对象上创建属性，因此 Object 组件可能同时包含通过声明显式创建的绑定与作为全局对象属性隐式创建的绑定。为区分通过声明显式创建的绑定，Global Environment Record 维护使用 CreateGlobalVarBinding 与 CreateGlobalFunctionBinding 创建的名称列表。</p>
        <p>Global Environment Record 具有 <emu-xref href="#table-additional-fields-of-global-environment-records"></emu-xref> 中的附加字段和 <emu-xref href="#table-additional-methods-of-global-environment-records"></emu-xref> 中的附加方法。</p>
        <emu-table id="table-additional-fields-of-global-environment-records" caption="Global Environment Record 的附加字段" oldids="table-18">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ObjectRecord]]
              </td>
              <td>
                一个 Object Environment Record
              </td>
              <td>
                绑定对象是全局对象，包含全局内置绑定以及全局代码中 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableDeclaration| 的绑定。
              </td>
            </tr>
            <tr>
              <td>
                [[GlobalThisValue]]
              </td>
              <td>
                一个 Object
              </td>
              <td>
                全局作用域中 `this` 返回的值；宿主可提供任意 ECMAScript Object。
              </td>
            </tr>
            <tr>
              <td>
                [[DeclarativeRecord]]
              </td>
              <td>
                一个 Declarative Environment Record
              </td>
              <td>
                <emu-not-ref>包含</emu-not-ref> 全局代码中除 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableDeclaration| 外所有声明的绑定。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-additional-methods-of-global-environment-records" caption="Global Environment Record 的附加方法" oldids="table-19">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                返回该 Environment Record 的 `this` 绑定。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-global-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>判定参数标识符是否被该记录绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，返回 *true*。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.HasBinding</emu-meta>(_N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新的未初始化可变绑定，存于关联的 DeclarativeRecord 中，不得已存在；若 _D_ 为 *true*，标记为可删除。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，抛 *TypeError*。
            1. 返回 ! _DclRec_.CreateMutableBinding(_N_, _D_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建新未初始化不可变绑定。不得已存在。若 _S_ 为 *true*，标记为严格绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，抛 *TypeError*。
            1. 返回 ! _DclRec_.CreateImmutableBinding(_N_, _S_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>将名称为 _N_ 的当前绑定值设为 _V_；必须已存在未初始化绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ! _DclRec_.InitializeBinding(_N_, _V_)。
            1. 断言：若存在绑定则位于 Object Environment Record 中。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>尝试更改名称为 _N_ 的当前绑定值为 _V_。若为不可变绑定且 _S_ 为 *true*，抛 *TypeError*。若属性不存在或不可写，处理取决于 _S_。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ? _DclRec_.SetMutableBinding(_N_, _V_, _S_)。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回名称为 _N_ 的绑定值。若为未初始化绑定抛 *ReferenceError*。若属性不存在或不可写，处理取决于 _S_。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ? _DclRec_.GetBindingValue(_N_, _S_)。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>只能删除被标记为可删除的绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ! _DclRec_.DeleteBinding(_N_)。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? HasOwnProperty(_globalObject_, _N_)。
            1. 若 _existingProp_ 为 *true*，则
              1. 返回 ? <emu-meta effects="user-code">_ObjRec_.DeleteBinding</emu-meta>(_N_)。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *true*。
          </emu-alg>
          <emu-note>
            <p>Global Environment Record 始终提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>Global Environment Record 不提供 `super` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): 一个包含 Object 的正常完成</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 _envRec_.[[GlobalThisValue]]。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-haslexicaldeclaration" type="abstract operation">
          <h1>
            HasLexicalDeclaration (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个 Boolean
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判断参数标识符是否在 _envRec_ 中以 |LexicalDeclaration| 或 |ClassDeclaration| 等词法声明创建。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 返回 ! _DclRec_.HasBinding(_N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasrestrictedglobalproperty" type="abstract operation">
          <h1>
            HasRestrictedGlobalProperty (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判断参数标识符是否为不得被全局词法绑定遮蔽的全局对象属性之名。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)。
            1. 若 _existingProp_ 为 *undefined*，返回 *false*。
            1. 若 _existingProp_.[[Configurable]] 为 *true*，返回 *false*。
            1. 返回 *true*。
          </emu-alg>
          <emu-note>
            <p>可直接在全局对象上存在非声明创建的属性。不能创建与全局对象不可配置属性同名的全局词法绑定，例如 *"undefined"*。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalvar" type="abstract operation">
          <h1>
            CanDeclareGlobalVar (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判定同参数 _N_ 调用 CreateGlobalVarBinding 是否会成功；允许冗余 var 声明以及针对已存在全局对象属性的 var 声明。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _hasProperty_ 为 ? HasOwnProperty(_globalObject_, _N_)。
            1. 若 _hasProperty_ 为 *true*，返回 *true*。
            1. 返回 ? IsExtensible(_globalObject_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalfunction" type="abstract operation">
          <h1>
            CanDeclareGlobalFunction (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判定同参数 _N_ 调用 CreateGlobalFunctionBinding 是否会成功。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)。
            1. 若 _existingProp_ 为 *undefined*，返回 ? IsExtensible(_globalObject_)。
            1. 若 _existingProp_.[[Configurable]] 为 *true*，返回 *true*。
            1. 若 IsDataDescriptor(_existingProp_) 为 *true* 且 _existingProp_ 具属性 { [[Writable]]: *true*, [[Enumerable]]: *true* }，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalvarbinding" type="abstract operation">
          <h1>
            CreateGlobalVarBinding (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>在关联的 Object Environment Record 中创建并初始化可变绑定。若已存在则复用并视为已初始化。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _hasProperty_ 为 ? HasOwnProperty(_globalObject_, _N_)。
            1. 令 _extensible_ 为 ? IsExtensible(_globalObject_)。
            1. 若 _hasProperty_ 为 *false* 且 _extensible_ 为 *true*，则
              1. 执行 ? <emu-meta effects="user-code">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_)。
              1. 执行 ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*)。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalfunctionbinding" type="abstract operation">
          <h1>
            CreateGlobalFunctionBinding (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>在关联 Object Environment Record 中创建并初始化可变绑定；若已存在则替换。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)。
            1. 若 _existingProp_ 为 *undefined* 或其 [[Configurable]] 为 *true*，则
              1. 令 _desc_ 为 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }。
            1. 否则，
              1. 令 _desc_ 为 PropertyDescriptor { [[Value]]: _V_ }。
            1. 执行 ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_)。
            1. [id="step-createglobalfunctionbinding-set"] 执行 ? Set(_globalObject_, _N_, _V_, *false*)。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>全局函数声明总以全局对象自有属性表示；若可行，重配置为标准属性集。步骤 <emu-xref href="#step-createglobalfunctionbinding-set"></emu-xref> 等价于调用 InitializeBinding，且若 _globalObject_ 为 Proxy 将产生相同的 trap 调用序列。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-module-environment-records" oldids="module-environment">
        <h1>模块环境记录 (Module Environment Records)</h1>
        <p><dfn variants="Module Environment Records">Module Environment Record</dfn> 是一个 Declarative Environment Record，用于表示 ECMAScript |Module| 的外层作用域。除普通可变与不可变绑定外，还提供不可变的 import 绑定，这些绑定间接访问另一个 Environment Record 中的目标绑定。</p>
        <p>Module Environment Record 支持 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> 中列出的所有 Declarative Environment Record 方法，除 GetBindingValue、DeleteBinding、HasThisBinding 与 GetThisBinding 外与其规范相同；另外支持 <emu-xref href="#table-additional-methods-of-module-environment-records"></emu-xref> 中的方法：</p>
        <emu-table id="table-additional-methods-of-module-environment-records" caption="Module Environment Record 的附加方法" oldids="table-20">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                返回该 Environment Record 的 `this` 绑定值。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-module-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Module Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回名称为 _N_ 的绑定值；若为间接绑定则返回目标绑定的值。若存在但未初始化抛 *ReferenceError*。</dd>
          </dl>
          <emu-alg>
            1. 断言：_S_ 为 *true*。
            1. 断言：_envRec_ 有 _N_ 绑定。
            1. 若 _N_ 的绑定是间接绑定，则
              1. 令 _M_ 与 _N2_ 为创建该绑定时提供的间接值。
              1. 令 _targetEnv_ 为 _M_.[[Environment]]。
              1. 若 _targetEnv_ 为 ~empty~，抛 *ReferenceError*。
              1. 返回 ? <emu-meta effects="user-code">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*)。
            1. 若 _envRec_ 中 _N_ 的绑定为未初始化，抛 *ReferenceError*。
            1. 返回当前绑定于 _N_ 的值。
          </emu-alg>
          <emu-note>
            <p>_S_ 始终为 *true*，因为 |Module| 总是严格模式。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>Module Environment Record 的 DeleteBinding 具体方法在本规范中从未使用。</p>
          <emu-note>
            <p>Module Environment Record 仅用于严格代码，并且早期错误规则阻止在严格代码中对解析到模块环境绑定的 Reference Record 使用 delete。见 <emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *true*。
          </emu-alg>
          <emu-note>
            <p>Module Environment Record 始终提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): 一个包含 *undefined* 的正常完成</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createimportbinding" type="abstract operation">
          <h1>
            CreateImportBinding (
              _envRec_: 一个 Module Environment Record,
              _N_: 一个 String,
              _M_: 一个 Module Record,
              _N2_: 一个 String,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新已初始化不可变间接绑定；不得已存在。_N2_ 是 _M_ 的 Module Environment Record 中存在的绑定名。访问该新绑定的值将间接访问目标绑定的值。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 尚无 _N_ 绑定。
            1. 断言：当 _M_.[[Environment]] 实例化时会有 _N2_ 的直接绑定。
            1. 在 _envRec_ 中创建引用 _M_ 与 _N2_ 的不可变间接绑定并记录其已初始化。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>环境记录操作 (Environment Record Operations)</h1>
      <p>下列抽象操作用于在本规范中对 Environment Record 进行操作：</p>

      <emu-clause id="sec-getidentifierreference" type="abstract operation">
        <h1>
          GetIdentifierReference (
            _env_: 一个 Environment Record 或 *null*,
            _name_: 一个 String,
            _strict_: 一个 Boolean,
          ): 一个包含 Reference Record 的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _env_ 为 *null*，则
            1. 返回 Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }。
          1. 令 _exists_ 为 ? <emu-meta effects="user-code">_env_.HasBinding</emu-meta>(_name_)。
          1. 若 _exists_ 为 *true*，则
            1. 返回 Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }。
          1. 否则，
            1. 令 _outer_ 为 _env_.[[OuterEnv]]。
            1. 返回 ? GetIdentifierReference(_outer_, _name_, _strict_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newdeclarativeenvironment" type="abstract operation">
        <h1>
          NewDeclarativeEnvironment (
            _E_: 一个 Environment Record 或 *null*,
          ): 一个 Declarative Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个不含绑定的新 Declarative Environment Record。
          1. 设 _env_.[[OuterEnv]] 为 _E_。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newobjectenvironment" type="abstract operation">
        <h1>
          NewObjectEnvironment (
            _O_: 一个 Object,
            _W_: 一个 Boolean,
            _E_: 一个 Environment Record 或 *null*,
          ): 一个 Object Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个新 Object Environment Record。
          1. 设 _env_.[[BindingObject]] 为 _O_。
          1. 设 _env_.[[IsWithEnvironment]] 为 _W_。
          1. 设 _env_.[[OuterEnv]] 为 _E_。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" type="abstract operation">
        <h1>
          NewFunctionEnvironment (
            _F_: 一个 ECMAScript 函数对象,
            _newTarget_: 一个 Object 或 *undefined*,
          ): 一个 Function Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个不含绑定的新 Function Environment Record。
          1. 设 _env_.[[FunctionObject]] 为 _F_。
          1. 若 _F_.[[ThisMode]] 为 ~lexical~，设 _env_.[[ThisBindingStatus]] 为 ~lexical~。
          1. 否则设 _env_.[[ThisBindingStatus]] 为 ~uninitialized~。
          1. 设 _env_.[[NewTarget]] 为 _newTarget_。
          1. 设 _env_.[[OuterEnv]] 为 _F_.[[Environment]]。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newglobalenvironment" type="abstract operation">
        <h1>
          NewGlobalEnvironment (
            _G_: 一个 Object,
            _thisValue_: 一个 Object,
          ): 一个 Global Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _objRec_ 为 NewObjectEnvironment(_G_, *false*, *null*)。
          1. 令 _dclRec_ 为 NewDeclarativeEnvironment(*null*)。
          1. 令 _env_ 为一个新 Global Environment Record。
          1. 设 _env_.[[ObjectRecord]] 为 _objRec_。
          1. 设 _env_.[[GlobalThisValue]] 为 _thisValue_。
          1. 设 _env_.[[DeclarativeRecord]] 为 _dclRec_。
          1. 设 _env_.[[OuterEnv]] 为 *null*。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" type="abstract operation">
        <h1>
          NewModuleEnvironment (
            _E_: 一个 Environment Record,
          ): 一个 Module Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个不含绑定的新 Module Environment Record。
          1. 设 _env_.[[OuterEnv]] 为 _E_。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-privateenvironment-records">
    <h1>PrivateEnvironment 记录 (PrivateEnvironment Records)</h1>
    <p><dfn id="privateenvironment-record" variants="PrivateEnvironment Records">PrivateEnvironment Record</dfn> 是一种规范机制，用于基于 ECMAScript 代码中 |ClassDeclaration| 与 |ClassExpression| 的词法嵌套结构跟踪 Private Name。它们与 Environment Record 类似但不同。每个 PrivateEnvironment Record 与一个 |ClassDeclaration| 或 |ClassExpression| 关联。每次此类 class 被求值时，会创建一个新的 PrivateEnvironment Record 来记录该 class 声明的 Private Name。</p>
    <p>每个 PrivateEnvironment Record 拥有 <emu-xref href="#table-privateenvironment-records"></emu-xref> 中定义的字段。</p>
    <emu-table id="table-privateenvironment-records" caption="PrivateEnvironment Record 字段">
      <table>
        <thead>
          <tr>
            <th>
              字段名
            </th>
            <th>
              值类型
            </th>
            <th>
              含义
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[OuterPrivateEnvironment]]
          </td>
          <td>
            一个 PrivateEnvironment Record 或 *null*
          </td>
          <td>
            最近包围的 class 的 PrivateEnvironment Record。若与此 PrivateEnvironment Record 关联的 class 未被任何其他 class 包含则为 *null*。
          </td>
        </tr>
        <tr>
          <td>
            [[Names]]
          </td>
          <td>
            一个 Private Name 列表
          </td>
          <td>
            该 class 声明的 Private Name。
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-privateenvironment-record-operations">
      <h1>PrivateEnvironment Record 操作 (PrivateEnvironment Record Operations)</h1>
      <p>以下抽象操作用于在本规范中对 PrivateEnvironment Record 进行操作：</p>

      <emu-clause id="sec-newprivateenvironment" type="abstract operation">
        <h1>
          NewPrivateEnvironment (
            _outerPrivateEnv_: a PrivateEnvironment Record or *null*,
          ): a PrivateEnvironment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _names_ 为一个新的空 List。
          1. 返回 PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivateEnv_, [[Names]]: _names_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-resolve-private-identifier" type="abstract operation">
        <h1>
          ResolvePrivateIdentifier (
            _privateEnv_: a PrivateEnvironment Record,
            _identifier_: a String,
          ): a Private Name
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _names_ 为 _privateEnv_.[[Names]]。
          1. 对于 _names_ 中每个 Private Name _pn_，执行
            1. 若 _pn_.[[Description]] 为 _identifier_，则
              1. 返回 _pn_。
          1. 令 _outerPrivateEnv_ 为 _privateEnv_.[[OuterPrivateEnvironment]]。
          1. 断言：_outerPrivateEnv_ 不为 *null*。
          1. 返回 ResolvePrivateIdentifier(_outerPrivateEnv_, _identifier_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realm</h1>
    <p>在被求值之前，所有 ECMAScript 代码都必须与一个 <dfn id="realm" variants="realms">realm</dfn> 相关联。概念上，realm 由一组内在对象、一个 ECMAScript 全局环境、在该全局环境作用域内加载的所有 ECMAScript 代码，以及其他关联状态与资源组成。</p>
    <p>在本规范中，一个 realm 表示为具有 <emu-xref href="#table-realm-record-fields"></emu-xref> 中字段的 <dfn id="realm-record" variants="Realm Records">Realm Record</dfn>：</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record 字段" oldids="table-21">
      <table>
        <thead>
          <tr>
            <th>
              字段名
            </th>
            <th>
              值
            </th>
            <th>
              含义
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[AgentSignifier]]
          </td>
          <td>
            一个 agent 标识符
          </td>
          <td>
            拥有该 realm 的 agent
          </td>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td>
            一个 Record，其字段名为内在 key，值为对象
          </td>
          <td>
            与该 realm 关联的代码使用的内在值
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td>
            一个 Object
          </td>
          <td>
            该 realm 的全局对象
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td>
            一个 Global Environment Record
          </td>
          <td>
            该 realm 的全局环境
          </td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td>
            一个 Record 列表，字段 [[Site]] (一个 |TemplateLiteral| Parse Node) 与 [[Array]] (一个 Array)
          </td>
          <td>
            <p>模板对象按 realm 独立规范化，使用其 Realm Record 的 [[TemplateMap]]。每个 [[Site]] 值是一个 |TemplateLiteral| Parse Node。其关联的 [[Array]] 是传递给 tag 函数的对应模板对象。</p>
            <emu-note>一旦某 Parse Node 变为不可达，对应 [[Array]] 也不可达；实现移除该对条目将不可观察。</emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[LoadedModules]]
          </td>
          <td>
            一个 LoadedModuleRequest Record 列表
          </td>
          <td>
            <p>从该 realm 导入的 specifier 字符串到解析后 Module Record 的映射。该列表不包含两个不同 Record _r1_ 与 _r2_ 使得 ModuleRequestsEqual(_r1_, _r2_) 为 *true*。</p>
            <emu-note>
              如 HostLoadImportedModule 中所述 (<emu-xref href="#note-HostLoadImportedModule-referrer-Realm-Record"></emu-xref>)，Realm Record 中的 [[LoadedModules]] 仅在在没有活动 script 或 module 的上下文中运行 `import()` 表达式时使用。
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            任意 (默认值为 *undefined*)
          </td>
          <td>
            为需要与 Realm Record 关联附加信息的宿主保留的字段。
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-initializehostdefinedrealm" type="abstract operation" oldids="sec-createrealm,sec-setrealmglobalobject">
      <h1>InitializeHostDefinedRealm ( ): either a normal completion containing ~unused~ or a throw completion</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _realm_ 为一个新的 Realm Record。
        1. 执行 CreateIntrinsics(_realm_)。
        1. 设 _realm_.[[AgentSignifier]] 为 AgentSignifier()。
        1. 设 _realm_.[[TemplateMap]] 为一个新的空 List。
        1. 令 _newContext_ 为一个新的执行上下文。
        1. 将 _newContext_ 的 Function 设为 *null*。
        1. 将 _newContext_ 的 Realm 设为 _realm_。
        1. 将 _newContext_ 的 ScriptOrModule 设为 *null*。
        1. 将 _newContext_ 压入执行上下文栈；_newContext_ 现在是运行执行上下文。
        1. 若宿主要求使用一个特殊对象作为 _realm_ 的全局对象，则
          1. 令 _global_ 为以宿主定义方式创建的此对象。
        1. 否则，
          1. 令 _global_ 为 OrdinaryObjectCreate(_realm_.[[Intrinsics]].[[%Object.prototype%]])。
        1. 若宿主要求 _realm_ 全局作用域中的 `this` 绑定返回不同于全局对象的对象，则
          1. 令 _thisValue_ 为以宿主定义方式创建的该对象。
        1. 否则，
          1. 令 _thisValue_ 为 _global_。
        1. 设 _realm_.[[GlobalObject]] 为 _global_。
        1. 设 _realm_.[[GlobalEnv]] 为 NewGlobalEnvironment(_global_, _thisValue_)。
        1. 执行 ? SetDefaultGlobalBindings(_realm_)。
        1. 在 _global_ 上创建任意宿主定义的全局对象属性。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createintrinsics" type="abstract operation">
      <h1>
        CreateIntrinsics (
          _realmRec_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 将 _realmRec_.[[Intrinsics]] 设为一个新的 Record。
        1. [declared="steps,name,length,slots,prototype"] 按 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref> 中的值设置 _realmRec_.[[Intrinsics]] 的字段。字段名为该表第一列列出的名称。每个字段的值为一个根据 <emu-xref href="#sec-global-object"></emu-xref> 至 <emu-xref href="#sec-reflection"></emu-xref> 中各对象规范完全递归填充属性值的新对象。所有对象属性值均为新创建对象。所有内置函数对象通过执行 CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) 创建，其中 _steps_ 是本规范给出的该函数定义，_name_ 是函数 *"name"* 属性初始值，_length_ 是函数 *"length"* 属性初始值，_slots_ 是函数指定内部槽名称列表（若有），_prototype_ 是指定的 [[Prototype]] 内部槽值。内在对象及其属性的创建顺序必须避免依赖尚未创建的对象。
        1. 执行 AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setdefaultglobalbindings" type="abstract operation">
      <h1>
        SetDefaultGlobalBindings (
          _realmRec_: a Realm Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _global_ 为 _realmRec_.[[GlobalObject]]。
        1. 对 <emu-xref href="#sec-global-object"></emu-xref> 条款中指定的全局对象的每个属性，执行
          1. 令 _name_ 为该属性名的 String 值。
          1. 令 _desc_ 为该属性的完全填充数据属性描述符，包含该属性指定的特性。对于 <emu-xref href="#sec-function-properties-of-the-global-object"></emu-xref>、<emu-xref href="#sec-constructor-properties-of-the-global-object"></emu-xref> 或 <emu-xref href="#sec-other-properties-of-the-global-object"></emu-xref> 中列出的属性，其 [[Value]] 为来自 _realmRec_ 的对应内在对象。
          1. 执行 ? DefinePropertyOrThrow(_global_, _name_, _desc_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>执行上下文 (Execution Contexts)</h1>
    <p><dfn variants="execution contexts">execution context</dfn> 是规范装置，用于跟踪 ECMAScript 实现对代码的运行时求值。在任意时刻，每个 agent 最多只有一个实际执行代码的执行上下文，称为该 agent 的 <dfn id="running-execution-context" variants="running execution contexts">运行执行上下文 (running execution context)</dfn>。本规范中所有对运行执行上下文的引用均指当前 agent 的运行执行上下文。</p>
    <p><dfn id="execution-context-stack" variants="execution context stacks">执行上下文栈 (execution context stack)</dfn> 用于跟踪执行上下文。运行执行上下文始终是该栈的顶部元素。当控制从当前运行执行上下文关联的可执行代码转移到不与其关联的可执行代码时，会创建一个新的执行上下文。新执行上下文被压入栈顶并成为运行执行上下文。</p>
    <p>执行上下文包含跟踪其关联代码执行进度所需的实现特定状态。每个执行上下文至少具有 <emu-xref href="#table-state-components-for-all-execution-contexts"></emu-xref> 中列出的状态组成部分。</p>
    <emu-table id="table-state-components-for-all-execution-contexts" caption="所有执行上下文的状态组成部分" oldids="table-22">
      <table>
        <thead>
          <tr>
            <th>
              组成部分
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            code evaluation state
          </td>
          <td>
            执行、暂停与恢复该上下文关联代码求值所需的任意状态。
          </td>
        </tr>
        <tr>
          <td>
            Function
          </td>
          <td>
            若该上下文正在求值某函数对象的代码，则为该函数对象；若求值 |Script| 或 |Module|，该值为 *null*。
          </td>
        </tr>
        <tr>
          <td>
            Realm
          </td>
          <td>
            关联代码访问 ECMAScript 资源所用的 Realm Record。
          </td>
        </tr>
        <tr>
          <td>
            ScriptOrModule
          </td>
          <td>
            关联代码来源的 Module Record 或 Script Record。若不存在来源脚本或模块（如 InitializeHostDefinedRealm 创建的初始执行上下文），该值为 *null*。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>运行执行上下文对代码的求值可在本规范定义的各种点被挂起。一旦挂起，另一个执行上下文可成为运行执行上下文并开始求值其代码。之后某个时间，被挂起的执行上下文可再次成为运行执行上下文并从之前挂起的位置继续。运行执行上下文在不同上下文间的转换通常按堆栈后进先出方式，但某些 ECMAScript 特性需要非 LIFO 的转换。</p>
    <p>运行执行上下文 Realm 组成部分的值也称为 <dfn id="current-realm">当前 Realm Record</dfn>。运行执行上下文 Function 组成部分的值也称为 <dfn id="active-function-object">活动函数对象 (active function object)</dfn>。</p>
    <p><dfn id="ecmascript-code-execution-context" variants="ECMAScript code execution context">ECMAScript 代码执行上下文</dfn> 具有 <emu-xref href="#table-additional-state-components-for-ecmascript-code-execution-contexts"></emu-xref> 中列出的附加状态组成部分。</p>
    <emu-table id="table-additional-state-components-for-ecmascript-code-execution-contexts" caption="ECMAScript 代码执行上下文的附加状态组成部分" oldids="table-23">
      <table>
        <thead>
          <tr>
            <th>
              组成部分
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            标识用于解析该上下文中代码标识符引用的 Environment Record。
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            标识在该上下文中由 |VariableStatement| 创建绑定的 Environment Record。
          </td>
        </tr>
        <tr>
          <td>
            PrivateEnvironment
          </td>
          <td>
            标识持有最近包围 class 中 |ClassElement| 创建的 Private Name 的 PrivateEnvironment Record。若无包围 class 则为 *null*。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>执行上下文的 LexicalEnvironment 与 VariableEnvironment 组成部分始终是 Environment Record。</p>
    <p>表示 Generator 求值的执行上下文具有 <emu-xref href="#table-additional-state-components-for-generator-execution-contexts"></emu-xref> 中列出的附加状态组成部分。</p>
    <emu-table id="table-additional-state-components-for-generator-execution-contexts" caption="Generator 执行上下文的附加状态组成部分" oldids="table-24">
      <table>
        <thead>
          <tr>
            <th>
              组成部分
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Generator
          </td>
          <td>
            该执行上下文正在求值的 Generator。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>大多数情况下，只有运行执行上下文（执行上下文栈顶）被本规范内算法直接操作。因此当未限定使用 “LexicalEnvironment” 与 “VariableEnvironment” 时，指的是运行执行上下文的那些组成部分。</p>
    <p>执行上下文纯属规范机制，不必对应 ECMAScript 实现中的具体实体。ECMAScript 代码无法直接访问或观察执行上下文。</p>

    <emu-clause id="sec-getactivescriptormodule" type="abstract operation">
      <h1>GetActiveScriptOrModule ( ): a Script Record, a Module Record, or *null*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>基于运行执行上下文确定运行脚本或模块。</dd>
      </dl>

      <emu-alg>
        1. 若执行上下文栈为空，返回 *null*。
        1. 令 _ec_ 为执行上下文栈顶端第一个其 ScriptOrModule 组成部分不为 *null* 的执行上下文。
        1. 若不存在此执行上下文，返回 *null*；否则返回 _ec_ 的 ScriptOrModule。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvebinding" type="abstract operation">
      <h1>
        ResolveBinding (
          _name_: a String,
          optional _env_: an Environment Record or *undefined*,
        ): either a normal completion containing a Reference Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于确定 _name_ 的绑定。_env_ 可显式提供要搜索绑定的 Environment Record。</dd>
      </dl>
      <emu-alg>
        1. 若 _env_ 未提供或 _env_ 为 *undefined*，则
          1. 设 _env_ 为运行执行上下文的 LexicalEnvironment。
        1. 断言：_env_ 是一个 Environment Record。
        1. 令 _strict_ 为正被求值的语法产生式的 IsStrict 结果。
        1. 返回 ? GetIdentifierReference(_env_, _name_, _strict_)。
      </emu-alg>
      <emu-note>
        <p>ResolveBinding 的结果始终是一个 [[ReferencedName]] 字段为 _name_ 的 Reference Record。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getthisenvironment" type="abstract operation">
      <h1>GetThisEnvironment ( ): an Environment Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>查找当前提供关键字 `this` 绑定的 Environment Record。</dd>
      </dl>
      <emu-alg>
        1. 令 _env_ 为运行执行上下文的 LexicalEnvironment。
        1. [id="step-getthisenvironment-loop"] 重复，
          1. 令 _exists_ 为 _env_.HasThisBinding()。
          1. 若 _exists_ 为 *true*，返回 _env_。
          1. 令 _outer_ 为 _env_.[[OuterEnv]]。
          1. 断言：_outer_ 不为 *null*。
          1. 设 _env_ 为 _outer_。
      </emu-alg>
      <emu-note>
        <p>步骤 <emu-xref href="#step-getthisenvironment-loop"></emu-xref> 中的循环总会终止，因为环境链最后以具有 `this` 绑定的全局环境结束。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-resolvethisbinding" type="abstract operation">
      <h1>ResolveThisBinding ( ): either a normal completion containing an ECMAScript language value or a throw completion</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>使用运行执行上下文的 LexicalEnvironment 确定关键字 `this` 的绑定。</dd>
      </dl>
      <emu-alg>
        1. 令 _envRec_ 为 GetThisEnvironment()。
        1. 返回 ? _envRec_.GetThisBinding()。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getnewtarget" type="abstract operation">
      <h1>GetNewTarget ( ): an Object or *undefined*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>使用运行执行上下文的 LexicalEnvironment 确定 NewTarget 值。</dd>
      </dl>
      <emu-alg>
        1. 令 _envRec_ 为 GetThisEnvironment()。
        1. 断言：_envRec_ 有 [[NewTarget]] 字段。
        1. 返回 _envRec_.[[NewTarget]]。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getglobalobject" type="abstract operation">
      <h1>GetGlobalObject ( ): an Object</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回当前运行执行上下文使用的全局对象。</dd>
      </dl>
      <emu-alg>
        1. 令 _currentRealm_ 为当前 Realm Record。
        1. 返回 _currentRealm_.[[GlobalObject]]。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-jobs" oldids="sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue">
    <h1>作业 (Jobs) 以及用于入队作业的宿主操作</h1>
    <p><dfn id="job" variants="Jobs">Job（作业）</dfn> 是一个无参数的抽象闭包（Abstract Closure），当当前没有其它 ECMAScript 计算正在进行时，它会启动一次 ECMAScript 计算。</p>
    <p>作业由 ECMAScript 宿主环境在特定 agent 中调度执行。本规范描述宿主挂钩 HostEnqueueGenericJob、HostEnqueueFinalizationRegistryCleanupJob、HostEnqueuePromiseJob 与 HostEnqueueTimeoutJob 来调度作业。本规范中的宿主挂钩按对作业调度施加的附加约束进行组织。宿主可定义额外的抽象操作来调度作业。此类操作接受一个 Job 抽象闭包和一个 realm（一个 Realm Record 或 *null*）作为参数。若提供了 Realm Record，则这些操作会在拥有该 realm 的 agent 中，于未来某个时间安排执行该作业。若改为为 realm 提供 *null*，则该作业不求值 ECMAScript 代码。它们的实现必须符合以下要求：</p>

    <ul>
      <li>在未来某个时间点，当相应 agent 中没有正在运行的上下文且该 agent 的执行上下文栈为空时，实现必须：
        <ol>
          <li>执行任何宿主定义的准备步骤。</li>
          <li><emu-not-ref>调用</emu-not-ref>该 Job 抽象闭包。</li>
          <li>执行任何宿主定义的清理步骤，之后执行上下文栈必须再次为空。</li>
        </ol>
      </li>
      <li>在一个 agent 中任意时间只能有一个 Job 正在被求值。</li>
      <li>一旦开始求值某个 Job，在该 agent 中必须先运行至完成，之后才可开始另一个 Job 的求值。</li>
      <li>该抽象闭包必须返回一个正常完成（normal completion），并自行处理错误。</li>
    </ul>

    <emu-note>
      宿主环境在调度方面不需要对所有 Job 一视同仁。例如，Web 浏览器与 Node.js 将处理 Promise 的 Job 视为比其它工作更高的优先级；未来特性可能添加不会设为如此高优先级的 Job。
    </emu-note>

    <p>在任意时间，若下列条件全部成立，则 _scriptOrModule_（一个 Script Record、Module Record 或 *null*）是<dfn id="job-activescriptormodule">活动脚本或模块 (active script or module)</dfn>：</p>
    <ul>
      <li>GetActiveScriptOrModule() 的结果为 _scriptOrModule_。</li>
      <li>若 _scriptOrModule_ 是 Script Record 或 Module Record，令 _ec_ 为执行上下文栈顶端第一个其 ScriptOrModule 组成部分为 _scriptOrModule_ 的执行上下文。_ec_ 的 Realm 组成部分为 _scriptOrModule_.[[Realm]]。</li>
    </ul>

    <p>在任意时间，若以下条件全部成立，则某次执行<dfn id="job-preparedtoevaluatecode">已准备好求值 ECMAScript 代码 (prepared to evaluate ECMAScript code)</dfn>：</p>
    <ul>
      <li>执行上下文栈不为空。</li>
      <li>执行上下文栈顶端执行上下文的 Realm 组成部分是一个 Realm Record。</li>
    </ul>

    <emu-note>
      <p>宿主环境可以通过向执行上下文栈压入执行上下文来准备执行求值代码。具体步骤由实现定义。</p>
      <p>Realm 的具体选择由宿主环境决定。这个初始执行上下文与 Realm 仅在任何回调函数被调用之前使用。当与某个 Job 相关的回调（如 Promise 处理器）被调用时，该调用会压入其自身的执行上下文与 Realm。</p>
    </emu-note>

    <p>特定种类的 Job 还有额外的一致性要求。</p>

    <emu-clause id="sec-jobcallback-records">
      <h1>JobCallback 记录 (JobCallback Records)</h1>
      <p><dfn variants="JobCallback Records">JobCallback Record</dfn> 是用于存储一个函数对象与一个宿主定义值的 Record。通过宿主入队的 Job 调用的函数对象可能具备额外的宿主定义上下文。为传播该状态，Job 抽象闭包不应直接捕获并调用函数对象；应改用 HostMakeJobCallback 与 HostCallJobCallback。</p>
      <emu-note>
        <p>例如，WHATWG HTML 规范（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）使用该宿主定义值来传播 Promise 回调的 incumbent settings object。</p>
      </emu-note>
      <p>JobCallback Record 具有 <emu-xref href="#table-jobcallback-records"></emu-xref> 中列出的字段。</p>
      <emu-table id="table-jobcallback-records" caption="JobCallback Record 字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Callback]]
            </td>
            <td>
              一个函数对象
            </td>
            <td>
              当该 Job 被调用时要调用的函数。
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              任意（默认值 ~empty~）
            </td>
            <td>
              保留给宿主使用的字段。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-hostmakejobcallback" type="host-defined abstract operation">
      <h1>
        HostMakeJobCallback (
          _callback_: a function object,
        ): a JobCallback Record
      </h1>
      <dl class="header">
      </dl>
      <p>HostMakeJobCallback 的实现必须符合以下要求：</p>
      <ul>
        <li>它必须返回一个 [[Callback]] 字段为 _callback_ 的 JobCallback Record。</li>
      </ul>
      <p>HostMakeJobCallback 的默认实现被调用时执行下列步骤：</p>
      <emu-alg>
        1. 返回 JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }。
      </emu-alg>
      <p>不是 Web 浏览器的 ECMAScript 宿主必须使用 HostMakeJobCallback 的默认实现。</p>
      <emu-note>
        <p>调用发生在回调被传入负责最终调度并运行它的函数之时。例如，`promise.then(thenAction)` 在调用 `Promise.prototype.then` 时对 `thenAction` 调用 MakeJobCallback，而不是在调度 reaction Job 时。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostcalljobcallback" type="host-defined abstract operation">
      <h1>
        HostCallJobCallback (
          _jobCallback_: a JobCallback Record,
          _V_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <p>HostCallJobCallback 的实现必须符合以下要求：</p>
      <ul>
        <li>它必须执行并返回 Call(_jobCallback_.[[Callback]], _V_, _argumentsList_) 的结果。</li>
      </ul>
      <emu-note>
        <p>该要求意味着宿主不能改变本规范定义的函数对象的 [[Call]] 行为。</p>
      </emu-note>
      <p>HostCallJobCallback 的默认实现被调用时执行下列步骤：</p>
      <emu-alg>
        1. 断言：IsCallable(_jobCallback_.[[Callback]]) 为 *true*。
        1. 返回 ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)。
      </emu-alg>
      <p>不是 Web 浏览器的 ECMAScript 宿主必须使用 HostCallJobCallback 的默认实现。</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuegenericjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueGenericJob (
          _job_: a Job Abstract Closure,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>在 _realm_.[[AgentSignifier]] 所指示的 agent 中，将 _job_ 安排于未来某个时间在 realm _realm_ 中执行。与该算法一起使用的抽象闭包意在不带额外约束（如优先级与排序）地调度。</dd>
      </dl>
      <p>HostEnqueueGenericJob 的实现必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求。</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuepromisejob" type="host-defined abstract operation">
      <h1>
        HostEnqueuePromiseJob (
          _job_: a Job Abstract Closure,
          _realm_: a Realm Record or *null*,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>安排 _job_ 于未来某个时间执行。与该算法一起使用的抽象闭包意在与 Promise 处理相关，或以与 Promise 处理操作同等优先级被调度。</dd>
      </dl>

      <p>HostEnqueuePromiseJob 的实现必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求并且满足以下附加要求：</p>
      <ul>
        <li>若 _realm_ 不为 *null*，则每次 _job_ 被调用时，实现必须执行实现定义步骤，使得在 _job_ 调用时执行已准备好求值 ECMAScript 代码。</li>
        <li>令 _scriptOrModule_ 为调用 HostEnqueuePromiseJob 时的 GetActiveScriptOrModule()。若 _realm_ 不为 *null*，则每次 _job_ 被调用时，实现必须执行实现定义步骤，使得在 _job_ 调用时 _scriptOrModule_ 为活动脚本或模块。</li>
        <li>作业必须按调度它们的各次 HostEnqueuePromiseJob 调用的顺序运行。</li>
      </ul>

      <emu-note>
        <p>由 NewPromiseResolveThenableJob 返回的 Job 的 _realm_ 通常是对 _then_ 函数对象调用 GetFunctionRealm 的结果。由 NewPromiseReactionJob 返回的 Job 的 _realm_ 通常是对处理器（若该处理器不为 *undefined*）调用 GetFunctionRealm 的结果。若处理器为 *undefined*，_realm_ 为 *null*。对于这两类 Job，当 GetFunctionRealm 异常完成（例如在被撤销的 Proxy 上调用）时，_realm_ 为调用 GetFunctionRealm 时的当前 Realm Record。当 _realm_ 为 *null* 时，不会执行用户 ECMAScript 代码，也不会创建新的 ECMAScript 对象（例如 Error 对象）。例如，WHATWG HTML 规范（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）使用 _realm_ 来检查脚本是否可运行，以及与 <a href="https://html.spec.whatwg.org/#entry">entry</a> 概念相关。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostenqueuetimeoutjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueTimeoutJob (
          _timeoutJob_: a Job Abstract Closure,
          _realm_: a Realm Record,
          _milliseconds_: a non-negative finite Number,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>在 _realm_.[[AgentSignifier]] 所指示的 agent 中，将 _timeoutJob_ 安排于至少 _milliseconds_ 毫秒之后在 realm _realm_ 中执行。</dd>
      </dl>
      <p>HostEnqueueTimeoutJob 的实现必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agents">
    <h1>Agents（代理）</h1>

    <p><dfn id="agent" variants="agents">agent（代理）</dfn> 由一组 ECMAScript 执行上下文、一个执行上下文栈、一个运行执行上下文、一个 <dfn id="agent-record" variants="Agent Records">Agent Record</dfn> 以及一个 <dfn id="executing-thread" variants="executing threads">执行线程 (executing thread)</dfn> 组成。除执行线程外，agent 的各组成部分只属于该 agent 本身。</p>
    <p>agent 的执行线程独立于其它 agent 在其执行上下文上执行算法步骤；但是一个执行线程可被多个 agent 共享，前提是共享该线程的 agent 中没有其 Agent Record 的 [[CanBlock]] 字段为 *true* 的。</p>
    <emu-note>
      <p>例如，一些 Web 浏览器会在多个互不相关的标签页间共享单一执行线程。</p>
    </emu-note>
    <p>当一个 agent 的执行线程在执行算法步骤时，该 agent 就是这些步骤的 <dfn id="surrounding-agent" variants="surrounding agents">包围 agent (surrounding agent)</dfn>。这些步骤通过该包围 agent 访问其持有的规范级执行对象：运行执行上下文、执行上下文栈以及 Agent Record 的字段。</p>
    <p><dfn variants="agent signifiers">agent signifier（代理标识符）</dfn> 是用于标识一个 Agent 的全局唯一不透明值。</p>
    <emu-table id="table-agent-record" caption="Agent Record 字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>a Boolean</td>
          <td>用于算法 GetValueFromBuffer 与 SetValueInBuffer 所需参数 <em>isLittleEndian</em> 的默认值。选择由实现定义，应为实现效率最高的选项。一旦被观察到便不可改变。</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>a Boolean</td>
          <td>决定该 agent 是否可以阻塞。</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>an agent signifier</td>
          <td>在其 agent 集群内唯一标识该 agent。</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>a Boolean</td>
          <td>若对单<emu-not-ref>字节值</emu-not-ref>的原子操作无锁则为 *true*，否则 *false*。</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>a Boolean</td>
          <td>若对双<emu-not-ref>字节值</emu-not-ref>的原子操作无锁则为 *true*，否则 *false*。</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>a Boolean</td>
          <td>若对八<emu-not-ref>字节值</emu-not-ref>的原子操作无锁则为 *true*，否则 *false*。</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>a candidate execution Record</td>
          <td>参见内存模型。</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>a List of either Objects or Symbols</td>
          <td>初始为空 List，表示在当前 Job 结束前需保持存活的对象和/或 symbol 列表。</td>
        </tr>
        <tr>
          <td>[[ModuleAsyncEvaluationCount]]</td>
          <td>an integer</td>
          <td>初始为 0，用于为异步或具有异步依赖的模块的 [[AsyncEvaluationOrder]] 字段分配递增唯一值。</td>
        </tr>
      </table>
    </emu-table>

    <p>一旦 [[Signifier]]、[[IsLockFree1]] 与 [[IsLockFree2]] 的值被 agent 集群中的任一 agent 观察到，它们就不可更改。</p>

    <emu-note>
      <p>[[IsLockFree1]] 与 [[IsLockFree2]] 的值不一定由硬件决定，也可反映可能随时间与实现而变的实现选择。</p>

      <p>没有 [[IsLockFree4]] 字段：4 字节原子操作总是无锁。</p>

      <p>实际上，如果某原子操作用任何形式的锁实现，该操作就不是无锁的。无锁不意味着无等待（wait-free）：完成一个无锁原子操作需要的机器步骤数没有上界。</p>

      <p>某大小 <em>n</em> 的原子访问无锁并不意味着对同大小 <em>n</em> 的非原子访问具备（感知的）原子性；具体来说，非原子访问仍可能分解为多个独立的内存访问。详见 ReadSharedMemory 与 WriteSharedMemory。</p>
    </emu-note>

    <emu-note>
      <p>agent 是规范机制，不需对应 ECMAScript 实现中的实际产物。</p>
    </emu-note>

    <emu-clause id="sec-agentsignifier" type="abstract operation">
      <h1>AgentSignifier ( ): an agent signifier</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _AR_ 为包围 agent 的 Agent Record。
        1. 返回 _AR_.[[Signifier]]。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-agentcansuspend" type="abstract operation">
      <h1>AgentCanSuspend ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _AR_ 为包围 agent 的 Agent Record。
        1. 返回 _AR_.[[CanBlock]]。
      </emu-alg>
      <emu-note>
        <p>在某些环境中，对某个 agent 来说暂停可能并不合适。例如，在 Web 浏览器环境中，可能不允许暂停文档的主事件处理线程，但允许 worker 的事件处理线程暂停。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-IncrementModuleAsyncEvaluationCount" type="abstract operation">
      <h1>IncrementModuleAsyncEvaluationCount ( ): an integer</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _AR_ 为包围 agent 的 Agent Record。
        1. 令 _count_ 为 _AR_.[[ModuleAsyncEvaluationCount]]。
        1. 设 _AR_.[[ModuleAsyncEvaluationCount]] 为 _count_ + 1。
        1. 返回 _count_。
      </emu-alg>
      <emu-note>
        <p>该值仅用于追踪待定模块之间的相对求值顺序。实现可在没有待定模块时不可观察地将 [[ModuleAsyncEvaluationCount]] 重置为 0。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agent-clusters">
    <h1>Agent Clusters（代理集群）</h1>

    <p><dfn variants="agent clusters">agent cluster（代理集群）</dfn> 是能够通过操作共享内存进行通信的最大化的一组 agent。</p>

    <emu-note>
      <p>不同 agent 内的程序可能通过未指明的方式共享内存。至少，共享内存可包含 SharedArrayBuffer 的底层存储。</p>

      <p>可能存在只能通过消息传递通信而不能共享内存的 agent；它们永远不在同一个 agent cluster 中。</p>
    </emu-note>

    <p>每个 agent 恰好属于一个 agent cluster。</p>

    <emu-note>
      <p>集群中的 agent 不必在某个时间点全部“活着”。如果 agent <b>A</b> 创建了 agent <b>B</b>，随后 <b>A</b> 终止，而 <b>B</b> 又创建 agent <b>C</b>，如果 <b>A</b> 可以与 <b>B</b> 共享某些内存且 <b>B</b> 可以与 <b>C</b> 共享某些内存，则三个 agent 仍在同一集群。</p>
    </emu-note>

    <p>同一集群内所有 agent 在其各自 Agent Record 的 [[LittleEndian]] 字段上必须具有相同的值。</p>

    <emu-note>
      <p>若集群中不同 agent 的 [[LittleEndian]] 值不同，就难以在多字节数据上使用共享内存。</p>
    </emu-note>

    <p>同一集群内所有 agent 在其 [[IsLockFree1]] 字段上必须具有相同值；[[IsLockFree2]] 字段同理。</p>

    <p>同一集群内所有 agent 在其 [[Signifier]] 字段上必须具有不同值。</p>

    <p>嵌入环境可在 agent 不知情或不配合的情况下停用（停止前向进展）或激活（恢复前向进展）一个 agent。若这样做，不得使集群中某些 agent 长期保持激活而另一些被无限期停用。</p>

    <emu-note>
      <p>上述限制的目的是避免某个 agent 因另一个被停用的 agent 而死锁或饥饿。例如，若一个生命周期独立于任何窗口文档的 HTML shared worker 被允许与这样一个独立文档的 dedicated worker 共享内存，而该文档及其 dedicated worker 被停用时 dedicated worker 持有某个锁（如文档被推入窗口历史），随后 shared worker 尝试获取该锁，那么 shared worker 会被阻塞直到 dedicated worker 被重新激活（如果会的话）。同时其它试图从其它窗口访问该 shared worker 的 worker 会饥饿。</p>

      <p>该限制意味着无法在不属于同一“暂停/唤醒”集体的 agent 之间共享内存。</p>
    </emu-note>

    <p>嵌入环境可以在未提前通知或未获得集群内其它 agent 协作的情况下终止某个 agent。若某 agent 的终止不是其自身或集群内其它 agent 的程序化行为，而是由集群外部因素导致，则嵌入环境必须在两个策略中择一：要么终止该集群所有 agent，要么提供可靠的 API 让集群内 agent 协调，以便至少一个仍存活的成员能够检测到该终止，并且终止数据中包含足以标识被终止 agent 的信息。</p>

    <emu-note>
      <p>此类终止的例子包括：操作系统或用户终止在独立进程中运行的 agent；当按 agent 资源统计显示某 agent 失控时，嵌入环境终止与其它 agent 在同一进程内运行的该 agent。</p>
    </emu-note>

    <p>下列每个规范值以及从它们可传递抵达的值，恰好属于一个 agent cluster：</p>
    <ul>
      <li>candidate execution Record</li>
      <li>Shared Data Block</li>
      <li>WaiterList Record</li>
    </ul>

    <p>在集群中任何 agent 求值任意 ECMAScript 代码之前，集群中所有 agent 的 Agent Record 的 [[CandidateExecution]] 字段被设为初始 candidate execution。初始 candidate execution 是一个空的 candidate execution，其 [[EventsRecords]] 字段是一个 List，其中为每个 agent 含有一个 Agent Events Record，其 [[AgentSignifier]] 字段为该 agent 的 agent signifier，而 [[EventList]] 与 [[AgentSynchronizesWith]] 字段是空 List。</p>

    <emu-note>
      <p>同一 agent cluster 中所有 agent 在其 Agent Record 的 [[CandidateExecution]] 字段共享同一个 candidate execution。candidate execution 是内存模型使用的规范机制。</p>
    </emu-note>

    <emu-note>
      <p>agent cluster 是规范机制，不需对应 ECMAScript 实现中的实际产物。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forward-progress">
    <h1>Forward Progress（前向进展）</h1>
    <p>某 agent <em>取得前向进展 (make forward progress)</em> 指其执行根据本规范的一次求值步骤。</p>
    <p>当一个 agent 的运行执行上下文同步且无限期地等待外部事件时，该 agent 变为 <em>阻塞 (blocked)</em>。只有 Agent Record 的 [[CanBlock]] 字段为 *true* 的 agent 才能以此方式阻塞。<em>未阻塞 (unblocked)</em> 的 agent 指未阻塞的。</p>

    <p>实现必须确保：</p>
    <ul>
      <li>每个拥有专用执行线程且未阻塞的 agent 最终取得前向进展</li>
      <li>共享一个执行线程的一组 agent 中，总有一个 agent 最终取得前向进展</li>
      <li>一个 agent 不得导致另一个 agent 阻塞，除非通过提供阻塞的显式 API</li>
    </ul>

    <emu-note>
      <p>这一点与内存模型中的活性保证一起，确保所有 ~seq-cst~ 写入最终对所有 agent 可观察。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-weakref-processing-model">
    <h1>WeakRef 与 FinalizationRegistry 目标的处理模型</h1>

    <emu-clause id="sec-weakref-invariants">
      <h1>目标 (Objectives)</h1>

      <p>本规范不保证任何对象或 symbol 会被垃圾回收。非存活的对象或 symbol 可能在很长时间后才被释放，甚至永不释放。基于此，本规范在描述被垃圾回收触发的行为时使用 “may”。</p>

      <p>WeakRef 与 FinalizationRegistry 的语义基于在特定时间点发生的两个操作：</p>

      <ul>
        <li>
          当调用 `WeakRef.prototype.deref` 时，该引用对象（若未返回 *undefined*）被保持存活，以便后续同步访问也返回相同值。该列表在使用 ClearKeptObjects 抽象操作完成同步工作后被重置。
        </li>

        <li>
          当某个已注册到 FinalizationRegistry 的对象或 symbol 变得不可达后，在同步 ECMAScript 执行完成后，最终可能调用该 FinalizationRegistry 的清理回调。FinalizationRegistry 的清理通过 CleanupFinalizationRegistry 抽象操作执行。
        </li>
      </ul>

      <p>上述两个动作（ClearKeptObjects 或 CleanupFinalizationRegistry）都不得打断同步 ECMAScript 执行。由于宿主可以组合更长的同步 ECMAScript 执行段，本规范将 ClearKeptObjects 与 CleanupFinalizationRegistry 的调度推迟到宿主环境。</p>

      <p>一些 ECMAScript 实现包含在后台（包括 ECMAScript 空闲时）运行的垃圾回收器。让宿主环境调度 CleanupFinalizationRegistry 允许其恢复 ECMAScript 执行以运行 finalizer 工作，可能释放被持有的值，降低整体内存占用。</p>
    </emu-clause>

    <emu-clause id="sec-liveness">
      <h1>存活性 (Liveness)</h1>

      <p>对于一组对象和/或 symbol _S_，相对于 _S_ 的一次 <dfn>假设的 WeakRef-oblivious（弱引用无感）</dfn> 执行是指：任何将其 referent 属于 _S_ 的 WeakRef 的抽象操作 WeakRefDeref 总是返回 *undefined* 的执行。</p>

      <emu-note>
        WeakRef-obliviousness 与 liveness 一起捕获两个概念：其一，WeakRef 本身不会保持其 referent 存活；其二，存活性中的循环不意味着某值存活。具体地，若判定 _v_ 的存活性依赖判定某 WeakRef referent _r_ 的存活性，则 _r_ 的存活性不能假定 _v_ 的存活性，否则是循环论证。
      </emu-note>
      <emu-note>
        WeakRef-obliviousness 针对对象或 symbol 的集合而不是单个值定义，以处理循环。若对单个值定义，则一个循环中的 WeakRef referent 会被视为存活，即便其身份仅通过循环中其它 WeakRef referent 被观察。
      </emu-note>
      <emu-note>
        口语化地，若包含某个对象或 symbol 的每个集合都是存活的，则我们说该对象或 symbol 存活。
      </emu-note>

      <p>在求值任意时刻，若下列任一条件成立，则对象和/或 symbol 集合 _S_ 被视为 <dfn>live（存活）</dfn>：</p>

      <ul>
        <li>
          _S_ 中任一元素包含于任一 agent 的 [[KeptAlive]] List 中。
        </li>
        <li>
          存在相对于 _S_ 的某个未来合法的假设 WeakRef-oblivious 执行，在其中观察到 _S_ 中任一值的身份。
        </li>
      </ul>
      <emu-note>
        第二个条件旨在捕获这样的直觉：若一个值的身份可通过非 WeakRef 手段观察到，则该值是存活的。值的身份可通过严格相等比较或作为 Map 的键被观察到。
      </emu-note>
      <emu-note>
        <p>对象或 symbol 出现在某字段、内部槽或属性中并不意味着该值存活。例如若该值从未被返回给程序，则不可被观察。</p>

        <p>这适用于 WeakMap 的键、WeakSet 的成员，以及 FinalizationRegistry Cell 记录的 [[WeakRefTarget]] 与 [[UnregisterToken]] 字段。</p>

        <p>上述定义意味着：若 WeakMap 中的某键不存活，则其对应的值也不必定存活。</p>
      </emu-note>
      <emu-note>
        Liveness 是保证引擎不得清空哪些 WeakRef 的下界。此处定义的 liveness 是不可判定的。实际中，引擎使用 reachability 等保守近似，存在较大实现自由度。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-execution">
      <h1>执行 (Execution)</h1>

      <p>在任意时刻，若一组对象和/或 symbol _S_ 不存活，ECMAScript 实现可原子地执行以下步骤：</p>

      <emu-alg>
        1. 对于 _S_ 的每个元素 _value_，执行
          1. 对每个 WeakRef _ref_（_ref_.[[WeakRefTarget]] 为 _value_），执行
            1. 设 _ref_.[[WeakRefTarget]] 为 ~empty~。
          1. 对每个 FinalizationRegistry _fg_（_fg_.[[Cells]] 含有记录 _cell_ 且 _cell_.[[WeakRefTarget]] 为 _value_），执行
            1. 设 _cell_.[[WeakRefTarget]] 为 ~empty~。
            1. 可选：执行 HostEnqueueFinalizationRegistryCleanupJob(_fg_)。
          1. 对每个 WeakMap _map_（_map_.[[WeakMapData]] 含有记录 _r_ 且 _r_.[[Key]] 为 _value_），执行
            1. 设 _r_.[[Key]] 为 ~empty~。
            1. 设 _r_.[[Value]] 为 ~empty~。
          1. 对每个 WeakSet _set_（_set_.[[WeakSetData]] 含有 _value_），执行
            1. 将 _set_.[[WeakSetData]] 中值为 _value_ 的元素替换为值为 ~empty~ 的元素。
      </emu-alg>

      <emu-note>
        <p>结合存活性的定义，本条款规定了实现可针对 WeakRef 应用的优化。</p>

        <p>可能存在在不观察对象身份的情况下访问对象的情形。诸如死变量消除、对非逃逸对象属性的标量替换等优化在对象身份未被观察时允许进行。因此，这些优化可在可观察范围内清空指向此类对象的 WeakRef。</p>

        <p>另一方面，若对象身份可被观察且该对象位于某 WeakRef 的 [[WeakRefTarget]] 内部槽中，则诸如重新物化（rematerialization）等会在可观察层面清空该 WeakRef 的优化被禁止。</p>

        <p>由于调用 HostEnqueueFinalizationRegistryCleanupJob 是可选的，注册在 FinalizationRegistry 中的对象不必定保持该 FinalizationRegistry 存活。实现可基于任何理由省略 FinalizationRegistry 回调，例如 FinalizationRegistry 自身变为“死”，或应用正在关闭。</p>
      </emu-note>
      <emu-note>
        <p>实现不要求针对最大的不存活对象或 symbol 集合清空 WeakRef。</p>
        <p>若实现选择一个不存活集合 _S_ 来清空 WeakRef，此定义要求它同时清空 _S_ 中所有值的 WeakRef。换言之，实现不能只清空指向值 _v_ 的 WeakRef 而保留其它可能在执行中观察到 _v_ 的 WeakRef 未清空。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-host-hooks">
      <h1>宿主挂钩 (Host Hooks)</h1>

      <emu-clause id="sec-host-cleanup-finalization-registry" type="host-defined abstract operation">
        <h1>
          HostEnqueueFinalizationRegistryCleanupJob (
            _finalizationRegistry_: a FinalizationRegistry,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <p>令 _cleanupJob_ 为一个无参数的新 Job 抽象闭包，它捕获 _finalizationRegistry_ 并在被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _cleanupResult_ 为 Completion(CleanupFinalizationRegistry(_finalizationRegistry_))。
          1. 若 _cleanupResult_ 为异常完成，执行任意宿主定义步骤以报告错误。
          1. 返回 ~unused~。
        </emu-alg>
        <p>HostEnqueueFinalizationRegistryCleanupJob 的实现将 _cleanupJob_ 安排于未来某个时间（若可能）执行，并且还必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求。</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-clear-kept-objects" type="abstract operation">
    <h1>ClearKeptObjects ( ): ~unused~</h1>
    <dl class="header">
      <dt>description</dt>
      <dd>期望 ECMAScript 实现在一次同步的 ECMAScript 执行序列完成后调用 ClearKeptObjects。</dd>
    </dl>
    <emu-alg>
      1. 令 _agentRecord_ 为包围 agent 的 Agent Record。
      1. 设 _agentRecord_.[[KeptAlive]] 为一个新的空 List。
      1. 返回 ~unused~。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-addtokeptobjects" type="abstract operation">
    <h1>
      AddToKeptObjects (
        _value_: an Object or a Symbol,
      ): ~unused~
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. 令 _agentRecord_ 为包围 agent 的 Agent Record。
      1. 将 _value_ 追加到 _agentRecord_.[[KeptAlive]]。
      1. 返回 ~unused~。
    </emu-alg>
    <emu-note>
      当抽象操作 AddToKeptObjects 以某目标对象或 symbol 被调用时，它把该目标加入一个列表；在调用 ClearKeptObjects 之前，该列表会对目标保持强引用。
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-cleanup-finalization-registry" type="abstract operation">
    <h1>
      CleanupFinalizationRegistry (
        _finalizationRegistry_: a FinalizationRegistry,
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. 断言：_finalizationRegistry_ 具有 [[Cells]] 与 [[CleanupCallback]] 内部槽。
      1. 令 _callback_ 为 _finalizationRegistry_.[[CleanupCallback]]。
      1. 当 _finalizationRegistry_.[[Cells]] 含有某记录 _cell_ 且 _cell_.[[WeakRefTarget]] 为 ~empty~ 时，实现可以执行以下步骤：
        1. 任选一个这样的 _cell_。
        1. 从 _finalizationRegistry_.[[Cells]] 中移除 _cell_。
        1. 执行 ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »)。
      1. 返回 ~unused~。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-canbeheldweakly" type="abstract operation">
    <h1>
      CanBeHeldWeakly (
        _v_: an ECMAScript language value,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>当且仅当 _v_ 适合作为弱引用使用时返回 *true*。只有适合作为弱引用使用的值才能成为 WeakMap 的键、WeakSet 的元素、WeakRef 的 target，或 FinalizationRegistry 的某个 target。</dd>
    </dl>
    <emu-alg>
      1. 若 _v_ 是一个 Object，返回 *true*。
      1. 若 _v_ 是一个 Symbol 且 KeyForSymbol(_v_) 为 *undefined*，返回 *true*。
      1. 返回 *false*。
    </emu-alg>
    <emu-note>
      <p>没有 <emu-xref href="#sec-identity">语言身份 (language identity)</emu-xref> 的语言值可以在没有先前引用的情况下被重新生成，不适合作为弱引用。由 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 产生的 Symbol 值与其他 Symbol 不同，它不具有语言身份，因此也不适合作为弱引用。<emu-xref href="#sec-well-known-symbols">Well-known symbols</emu-xref> 很可能永远不会被回收，但由于其数量有限，仍被视为适合用作弱引用，可通过多种实现手段管理。然而，在一个存活的 WeakMap 中与某个 well-known symbol 关联的任何值都不太可能被回收，可能在实现中“泄漏”内存资源。</p>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>普通与特异（Exotic）对象的行为 (Ordinary and Exotic Objects Behaviours)</h1>

  <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
    <h1>普通对象的内部方法与内部槽 (Ordinary Object Internal Methods and Internal Slots)</h1>
    <p>所有普通对象都有名为 [[Prototype]] 的内部槽。该内部槽的值要么是 *null* 要么是一个对象，用于实现继承。假设一个名为 _P_ 的属性在普通对象 _O_ 上缺失，但存在于其 [[Prototype]] 对象上。如果 _P_ 指向 [[Prototype]] 对象上的数据属性，则 _O_ 在“取值”访问（get access）时继承它，使其表现得仿佛 _P_ 是 _O_ 的一个属性。如果 _P_ 指向 [[Prototype]] 对象上的可写数据属性，在 _O_ 上对 _P_ 进行“设值”访问（set access）会在 _O_ 上创建一个名为 _P_ 的新数据属性。如果 _P_ 指向 [[Prototype]] 对象上的不可写数据属性，在 _O_ 上对 _P_ 的设值访问会失败。如果 _P_ 指向 [[Prototype]] 对象上的访问器属性（accessor property），则该访问器在 _O_ 上同时被继承用于 get 与 set 访问。</p>
    <p>每个普通对象都有一个布尔值内部槽 [[Extensible]]，用于满足 <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 中规定的与可扩展性相关的内部方法不变式。也就是说，一旦对象的 [[Extensible]] 内部槽被设为 *false*，就不再可能向该对象添加属性、修改该对象 [[Prototype]] 内部槽的值，或随后将 [[Extensible]] 的值重新改为 *true*。</p>
    <p>在下面的算法描述中，假设 _O_ 是一个普通对象，_P_ 是一个属性键值，_V_ 是任意 ECMAScript 语言值，_Desc_ 是一个 Property Descriptor 记录。</p>
    <p>每个普通对象内部方法委派给一个同名的抽象操作。如果该抽象操作依赖另一个内部方法，那么会在 _O_ 上调用该内部方法，而不是直接调用同名的抽象操作。这些语义确保当普通对象的内部方法应用到特异（exotic）对象时，被重写的内部方法能够被调用。</p>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): 一个正常完成，包含一个 Object 或 *null*</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryGetPrototypeOf(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinarygetprototypeof" type="abstract operation">
        <h1>
          OrdinaryGetPrototypeOf (
            _O_: an Object,
          ): an Object or *null*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 _O_.[[Prototype]]。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): 一个正常完成，包含一个 Boolean
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinarySetPrototypeOf(_O_, _V_)。
      </emu-alg>

      <emu-clause id="sec-ordinarysetprototypeof" type="abstract operation">
        <h1>
          OrdinarySetPrototypeOf (
            _O_: an Object,
            _V_: an Object or *null*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _current_ 为 _O_.[[Prototype]]。
          1. 若 SameValue(_V_, _current_) 为 *true*，返回 *true*。
          1. 令 _extensible_ 为 _O_.[[Extensible]]。
          1. 若 _extensible_ 为 *false*，返回 *false*。
          1. 令 _p_ 为 _V_。
          1. 令 _done_ 为 *false*。
          1. [id="step-ordinarysetprototypeof-loop"] 当 _done_ 为 *false* 重复，
            1. 若 _p_ 为 *null*，则
              1. 设 _done_ 为 *true*。
            1. 否则若 SameValue(_p_, _O_) 为 *true*，则
              1. 返回 *false*。
            1. 否则，
              1. 若 _p_.[[GetPrototypeOf]] 不是 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref> 中定义的普通对象内部方法，设 _done_ 为 *true*。
              1. 否则，将 _p_ 设为 _p_.[[Prototype]]。
          1. 设 _O_.[[Prototype]] 为 _V_。
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-ordinarysetprototypeof-loop"></emu-xref> 中的循环保证：任何仅包含使用普通对象定义之 [[GetPrototypeOf]] 和 [[SetPrototypeOf]] 的对象的原型链中不会出现循环。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): 一个正常完成，包含一个 Boolean</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryIsExtensible(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryisextensible" type="abstract operation">
        <h1>
          OrdinaryIsExtensible (
            _O_: an Object,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 _O_.[[Extensible]]。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): 一个正常完成，包含 *true*</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryPreventExtensions(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinarypreventextensions" type="abstract operation">
        <h1>
          OrdinaryPreventExtensions (
            _O_: an Object,
          ): *true*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 将 _O_.[[Extensible]] 设为 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): 一个正常完成，包含一个 Property Descriptor 或 *undefined*
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryGetOwnProperty(_O_, _P_)。
      </emu-alg>

      <emu-clause id="sec-ordinarygetownproperty" type="abstract operation">
        <h1>
          OrdinaryGetOwnProperty (
            _O_: an Object,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _O_ 不存在键为 _P_ 的自身属性，返回 *undefined*。
          1. 令 _D_ 为一个新建的无字段 Property Descriptor。
          1. 令 _X_ 为 _O_ 的键为 _P_ 的自身属性。
          1. 若 _X_ 是数据属性，则
            1. 设 _D_.[[Value]] 为 _X_ 的 [[Value]] 特性的值。
            1. 设 _D_.[[Writable]] 为 _X_ 的 [[Writable]] 特性的值。
          1. 否则，
            1. 断言：_X_ 是访问器属性。
            1. 设 _D_.[[Get]] 为 _X_ 的 [[Get]] 特性的值。
            1. 设 _D_.[[Set]] 为 _X_ 的 [[Set]] 特性的值。
          1. 设 _D_.[[Enumerable]] 为 _X_ 的 [[Enumerable]] 特性的值。
          1. 设 _D_.[[Configurable]] 为 _X_ 的 [[Configurable]] 特性的值。
          1. 返回 _D_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)。
      </emu-alg>

      <emu-clause id="sec-ordinarydefineownproperty" type="abstract operation">
        <h1>
          OrdinaryDefineOwnProperty (
            _O_: an Object,
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _current_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 令 _extensible_ 为 ? IsExtensible(_O_)。
          1. 返回 ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iscompatiblepropertydescriptor" type="abstract operation">
        <h1>
          IsCompatiblePropertyDescriptor (
            _Extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _Current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 ValidateAndApplyPropertyDescriptor(*undefined*, *""*, _Extensible_, _Desc_, _Current_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateandapplypropertydescriptor" type="abstract operation">
        <h1>
          ValidateAndApplyPropertyDescriptor (
            _O_: an Object or *undefined*,
            _P_: a property key,
            _extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>当且仅当 _Desc_ 可以在指定 _extensibility_ 与当前属性 _current_ 的条件下，作为某对象的属性（维护 <emu-xref href="#sec-invariants-of-the-essential-internal-methods">不变式</emu-xref>）被应用时，返回 *true*。当应用可行且 _O_ 不为 *undefined* 时，会对名为 _P_ 的属性执行（必要时创建）。</dd>
        </dl>
        <emu-alg>
          1. 断言：_P_ 是一个属性键。
          1. 若 _current_ 为 *undefined*，则
            1. 若 _extensible_ 为 *false*，返回 *false*。
            1. 若 _O_ 为 *undefined*，返回 *true*。
            1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，则
              1. 在对象 _O_ 上创建名为 _P_ 的自身访问器属性，其 [[Get]]、[[Set]]、[[Enumerable]]、[[Configurable]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 否则，
              1. 在对象 _O_ 上创建名为 _P_ 的自身数据属性，其 [[Value]]、[[Writable]]、[[Enumerable]]、[[Configurable]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 返回 *true*。
          1. 断言：_current_ 为一个完全填充的 Property Descriptor。
          1. 若 _Desc_ 不含任何字段，返回 *true*。
          1. 若 _current_.[[Configurable]] 为 *false*，则
            1. 若 _Desc_ 含 [[Configurable]] 且 _Desc_.[[Configurable]] 为 *true*，返回 *false*。
            1. 若 _Desc_ 含 [[Enumerable]] 且 _Desc_.[[Enumerable]] 不等于 _current_.[[Enumerable]]，返回 *false*。
            1. 若 IsGenericDescriptor(_Desc_) 为 *false* 且 IsAccessorDescriptor(_Desc_) 不等于 IsAccessorDescriptor(_current_)，返回 *false*。
            1. 若 IsAccessorDescriptor(_current_) 为 *true*，则
              1. 若 _Desc_ 含 [[Get]] 且 SameValue(_Desc_.[[Get]], _current_.[[Get]]) 为 *false*，返回 *false*。
              1. 若 _Desc_ 含 [[Set]] 且 SameValue(_Desc_.[[Set]], _current_.[[Set]]) 为 *false*，返回 *false*。
            1. 否则若 _current_.[[Writable]] 为 *false*，则
              1. 若 _Desc_ 含 [[Writable]] 且 _Desc_.[[Writable]] 为 *true*，返回 *false*。
              1. NOTE: SameValue 对 *NaN* 返回 *true*（可能通过其他方式区分）。此处返回可确保 _O_ 任何已有属性保持不变。
              1. 若 _Desc_ 含 [[Value]] 字段，返回 SameValue(_Desc_.[[Value]], _current_.[[Value]])。
          1. 若 _O_ 不为 *undefined*，则
            1. 若 IsDataDescriptor(_current_) 为 *true* 且 IsAccessorDescriptor(_Desc_) 为 *true*，则
              1. 若 _Desc_ 含 [[Configurable]]，令 _configurable_ 为 _Desc_.[[Configurable]]；否则令 _configurable_ 为 _current_.[[Configurable]]。
              1. 若 _Desc_ 含 [[Enumerable]]，令 _enumerable_ 为 _Desc_.[[Enumerable]]；否则令 _enumerable_ 为 _current_.[[Enumerable]]。
              1. 用一个访问器属性替换对象 _O_ 上名为 _P_ 的属性，其 [[Configurable]]、[[Enumerable]] 分别设为 _configurable_、_enumerable_，其 [[Get]]、[[Set]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 否则若 IsAccessorDescriptor(_current_) 为 *true* 且 IsDataDescriptor(_Desc_) 为 *true*，则
              1. 若 _Desc_ 含 [[Configurable]]，令 _configurable_ 为 _Desc_.[[Configurable]]；否则令 _configurable_ 为 _current_.[[Configurable]]。
              1. 若 _Desc_ 含 [[Enumerable]]，令 _enumerable_ 为 _Desc_.[[Enumerable]]；否则令 _enumerable_ 为 _current_.[[Enumerable]]。
              1. 用一个数据属性替换对象 _O_ 上名为 _P_ 的属性，其 [[Configurable]]、[[Enumerable]] 分别设为 _configurable_、_enumerable_，其 [[Value]]、[[Writable]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 否则，
              1. 对 _Desc_ 的每个字段，将对象 _O_ 上名为 _P_ 的属性对应特性设为该字段的值。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinaryHasProperty(_O_, _P_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryhasproperty" type="abstract operation">
        <h1>
          OrdinaryHasProperty (
            _O_: an Object,
            _P_: a property key,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _hasOwn_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _hasOwn_ 不为 *undefined*，返回 *true*。
          1. 令 _parent_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
          1. 若 _parent_ 不为 *null*，则
            1. 返回 ? <emu-meta effects="user-code">_parent_.[[HasProperty]]</emu-meta>(_P_)。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): 一个正常完成（包含 ECMAScript 语言值）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>

      <emu-alg>
        1. 返回 ? OrdinaryGet(_O_, _P_, _Receiver_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryget" type="abstract operation">
        <h1>
          OrdinaryGet (
            _O_: an Object,
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _desc_ 为 *undefined*，则
            1. 令 _parent_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
            1. 若 _parent_ 为 *null*，返回 *undefined*。
            1. 返回 ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_)。
          1. 若 IsDataDescriptor(_desc_) 为 *true*，返回 _desc_.[[Value]]。
          1. 断言：IsAccessorDescriptor(_desc_) 为 *true*。
          1. 令 _getter_ 为 _desc_.[[Get]]。
          1. 若 _getter_ 为 *undefined*，返回 *undefined*。
          1. 返回 ? Call(_getter_, _Receiver_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinarySet(_O_, _P_, _V_, _Receiver_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryset" type="abstract operation">
        <h1>
          OrdinarySet (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 令 _ownDesc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 返回 ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarysetwithowndescriptor" type="abstract operation">
        <h1>
          OrdinarySetWithOwnDescriptor (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
            _ownDesc_: a Property Descriptor or *undefined*,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 若 _ownDesc_ 为 *undefined*，则
            1. 令 _parent_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
            1. 若 _parent_ 不为 *null*，则
              1. 返回 ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_)。
            1. 否则，
              1. 将 _ownDesc_ 设为 PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
          1. 若 IsDataDescriptor(_ownDesc_) 为 *true*，则
            1. 若 _ownDesc_.[[Writable]] 为 *false*，返回 *false*。
            1. 若 _Receiver_ 不是 Object，返回 *false*。
            1. 令 _existingDescriptor_ 为 ? <emu-meta effects="user-code">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_)。
            1. 若 _existingDescriptor_ 不为 *undefined*，则
              1. 若 IsAccessorDescriptor(_existingDescriptor_) 为 *true*，返回 *false*。
              1. 若 _existingDescriptor_.[[Writable]] 为 *false*，返回 *false*。
              1. 令 _valueDesc_ 为 PropertyDescriptor { [[Value]]: _V_ }。
              1. 返回 ? <emu-meta effects="user-code">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_)。
            1. 否则，
              1. 断言：_Receiver_ 目前没有属性 _P_。
              1. 返回 ? CreateDataProperty(_Receiver_, _P_, _V_)。
          1. 断言：IsAccessorDescriptor(_ownDesc_) 为 *true*。
          1. 令 _setter_ 为 _ownDesc_.[[Set]]。
          1. 若 _setter_ 为 *undefined*，返回 *false*。
          1. 执行 ? Call(_setter_, _Receiver_, « _V_ »)。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinaryDelete(_O_, _P_)。
      </emu-alg>

      <emu-clause id="sec-ordinarydelete" type="abstract operation">
        <h1>
          OrdinaryDelete (
            _O_: an Object,
            _P_: a property key,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _desc_ 为 *undefined*，返回 *true*。
          1. 若 _desc_.[[Configurable]] 为 *true*，则
            1. 从 _O_ 中移除名为 _P_ 的自身属性。
            1. 返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 一个正常完成，包含一个属性键 List</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryOwnPropertyKeys(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryownpropertykeys" type="abstract operation">
        <h1>
          OrdinaryOwnPropertyKeys (
            _O_: an Object,
          ): a List of property keys
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 令 _keys_ 为一个新的空 List。
          1. 对 _O_ 的每个自身属性键 _P_，若 _P_ 是数组索引，按数字索引升序：
            1. 将 _P_ 追加至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_，若 _P_ 是 String 且不是数组索引，按属性创建的时间顺序：
            1. 将 _P_ 追加至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_，若 _P_ 是 Symbol，按属性创建时间顺序：
            1. 将 _P_ 追加至 _keys_。
          1. 返回 _keys_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinaryobjectcreate" type="abstract operation" oldids="sec-objectcreate">
      <h1>
        OrdinaryObjectCreate (
          _proto_: an Object or *null*,
          optional _additionalInternalSlotsList_: a List of names of internal slots,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于指定在运行时创建新的普通对象。_additionalInternalSlotsList_ 包含必须定义为该对象一部分的额外内部槽名称（除 [[Prototype]] 与 [[Extensible]] 之外）。若未提供 _additionalInternalSlotsList_，则使用一个新的空 List。</dd>
      </dl>
      <emu-alg>
        1. 令 _internalSlotsList_ 为 « [[Prototype]], [[Extensible]] »。
        1. 若 _additionalInternalSlotsList_ 存在，将 _internalSlotsList_ 设为 _internalSlotsList_ 与 _additionalInternalSlotsList_ 的列表连接。
        1. 令 _O_ 为 MakeBasicObject(_internalSlotsList_)。
        1. 将 _O_.[[Prototype]] 设为 _proto_。
        1. 返回 _O_。
      </emu-alg>

      <emu-note>
        <p>尽管 OrdinaryObjectCreate 除调用 MakeBasicObject 外做的事情很少，使用它明确传达了要创建一个“普通”对象而非特异对象的意图。因此，在本规范中，它不会被任何随后修改对象内部方法、从而使结果变为“非普通”的算法调用。创建特异对象的操作会直接调用 MakeBasicObject。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinarycreatefromconstructor" type="abstract operation">
      <h1>
        OrdinaryCreateFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
          optional _internalSlotsList_: a List of names of internal slots,
        ): either a normal completion containing an Object or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>它创建一个普通对象，其 [[Prototype]] 值取自构造函数的 *"prototype"* 属性（若存在）。否则使用由 _intrinsicDefaultProto_ 命名的内在对象作为 [[Prototype]]。_internalSlotsList_ 包含需要定义的额外内部槽名称。若未提供 _internalSlotsList_，则使用新的空 List。</dd>
      </dl>
      <emu-alg>
        1. 断言：_intrinsicDefaultProto_ 是本规范对某内在对象的名称；对应对象必须是用作 [[Prototype]] 值的内在对象。
        1. 令 _proto_ 为 ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_)。
        1. 若 _internalSlotsList_ 存在，令 _slotsList_ 为 _internalSlotsList_。
        1. 否则，令 _slotsList_ 为一个新的空 List。
        1. 返回 OrdinaryObjectCreate(_proto_, _slotsList_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getprototypefromconstructor" type="abstract operation">
      <h1>
        GetPrototypeFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
        ): either a normal completion containing an Object or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>决定与特定构造函数对应之对象应使用的 [[Prototype]] 值。该值若构造函数具有 *"prototype"* 属性则从中取得，否则使用由 _intrinsicDefaultProto_ 命名的内在对象作为 [[Prototype]]。</dd>
      </dl>
      <emu-alg>
        1. 断言：_intrinsicDefaultProto_ 是本规范对某内在对象的名称；对应对象必须是用作对象 [[Prototype]] 值的内在对象。
        1. 令 _proto_ 为 ? Get(_constructor_, *"prototype"*)。
        1. 若 _proto_ 不是 Object，则
          1. 令 _realm_ 为 ? GetFunctionRealm(_constructor_)。
          1. 将 _proto_ 设为 _realm_ 中名为 _intrinsicDefaultProto_ 的内在对象。
        1. 返回 _proto_。
      </emu-alg>
      <emu-note>
        <p>若 _constructor_ 未提供 [[Prototype]] 值，则使用的默认值取自 _constructor_ 函数所属的 realm，而非当前运行执行上下文。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-requireinternalslot" type="abstract operation">
      <h1>
        RequireInternalSlot (
          _O_: an ECMAScript language value,
          _internalSlot_: an internal slot name,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>除非 _O_ 是一个 Object 且拥有给定内部槽，否则抛出异常。</dd>
      </dl>
      <emu-alg>
        1. 若 _O_ 不是 Object，抛出 *TypeError* 异常。
        1. 若 _O_ 不具有内部槽 _internalSlot_，抛出 *TypeError* 异常。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript 函数对象 (ECMAScript Function Objects)</h1>
    <p>ECMAScript 函数对象封装了带参数的、闭包于某词法环境之上的 ECMAScript 代码，并支持对该代码的动态求值。一个 ECMAScript 函数对象是一个普通对象，具有与其它普通对象相同的内部槽与内部方法。ECMAScript 函数对象的代码可以是严格模式代码（<emu-xref href="#sec-strict-mode-code"></emu-xref>）或非严格代码。其代码为严格模式代码的 ECMAScript 函数对象称为 <dfn id="strict-function" variants="strict functions">严格函数 (strict function)</dfn>。其代码不是严格模式代码的称为 <dfn id="non-strict-function" variants="non-strict functions">非严格函数 (non-strict function)</dfn>。</p>
    <p>除 [[Extensible]] 与 [[Prototype]] 之外，ECMAScript 函数对象还具有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="ECMAScript 函数对象的内部槽 (Internal Slots of ECMAScript Function Objects)" oldids="table-27">
      <table>
        <thead>
          <tr>
            <th>
              内部槽 (Internal Slot)
            </th>
            <th>
              类型 (Type)
            </th>
            <th>
              描述 (Description)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[Environment]]
          </td>
          <td>
            an Environment Record
          </td>
          <td>
            函数闭包所捕获的 Environment Record。作为求值该函数代码时的外层环境。
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateEnvironment]]
          </td>
          <td>
            a PrivateEnvironment Record or *null*
          </td>
          <td>
            函数闭包所捕获的 Private Names 的 PrivateEnvironment Record。若函数在语法上不被包含于 class 内则为 *null*。在求值该函数代码时，作为内部类的外层 PrivateEnvironment。
          </td>
        </tr>
        <tr>
          <td>
            [[FormalParameters]]
          </td>
          <td>
            a Parse Node
          </td>
          <td>
            定义函数形式参数列表的源文本根解析节点。
          </td>
        </tr>
        <tr>
          <td>
            [[ECMAScriptCode]]
          </td>
          <td>
            a Parse Node
          </td>
          <td>
            定义函数函数体的源文本根解析节点。
          </td>
        </tr>
        <tr>
          <td>
            [[ConstructorKind]]
          </td>
          <td>
            ~base~ or ~derived~
          </td>
          <td>
            指示该函数是否为派生类构造器。
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            a Realm Record
          </td>
          <td>
            函数被创建时所在的 realm；在求值该函数时提供所有被访问的内在对象。
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            a Script Record or a Module Record
          </td>
          <td>
            函数被创建所在的脚本或模块。
          </td>
        </tr>
        <tr>
          <td>
            [[ThisMode]]
          </td>
          <td>
            ~lexical~, ~strict~, or ~global~
          </td>
          <td>
            定义在函数形式参数与函数体内 `this` 引用如何解释。~lexical~ 表示 `this` 引用词法包围函数的 *this* 值。~strict~ 表示使用调用该函数时提供的 *this* 值而不加修改。~global~ 表示 *undefined* 或 *null* 的 *this* 值被解释为对全局对象的引用，其它 *this* 值会先传入 ToObject。
          </td>
        </tr>
        <tr>
          <td>
            [[Strict]]
          </td>
          <td>
            a Boolean
          </td>
          <td>
            若该函数为严格函数则为 *true*，若为非严格函数则为 *false*。
          </td>
        </tr>
        <tr>
          <td>
            [[HomeObject]]
          </td>
          <td>
            an Object
          </td>
          <td>
            若函数使用 `super`，此槽为其 `super` 属性查找起始的对象（通过该对象的 [[GetPrototypeOf]]）。
          </td>
        </tr>
        <tr>
          <td>
            [[SourceText]]
          </td>
          <td>
            a sequence of Unicode code points
          </td>
          <td>
            定义该函数的<emu-xref href="#sec-source-text">源文本</emu-xref>。
          </td>
        </tr>
        <tr>
          <td>
            [[Fields]]
          </td>
          <td>
            a List of ClassFieldDefinition Records
          </td>
          <td>
            若该函数是一个 class，则此列表为该类的非静态字段及其初始化器的记录。
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateMethods]]
          </td>
          <td>
            a List of PrivateElements
          </td>
          <td>
            若该函数是一个 class，则此列表表示该类的非静态私有方法与访问器。
          </td>
        </tr>
        <tr>
          <td>
            [[ClassFieldInitializerName]]
          </td>
          <td>
            a String, a Symbol, a Private Name, or ~empty~
          </td>
          <td>
            若函数作为类字段的初始化器创建，则为对该字段进行 NamedEvaluation 所使用的名称；否则为 ~empty~。
          </td>
        </tr>
        <tr>
          <td>
            [[IsClassConstructor]]
          </td>
          <td>
            a Boolean
          </td>
          <td>
            指示该函数是否为类构造器。（若为 *true*，调用其 [[Call]] 将立即抛出 *TypeError* 异常。）
          </td>
        </tr>
      </table>
    </emu-table>
    <p>所有 ECMAScript 函数对象都具有此处定义的 [[Call]] 内部方法。作为构造器的 ECMAScript 函数还额外具有 [[Construct]] 内部方法。</p>

    <emu-clause id="sec-ecmascript-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): 一个正常完成（包含 ECMAScript 语言值）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个 ECMAScript 函数对象 _F_</dd>
      </dl>
      <emu-alg>
        1. 令 _callerContext_ 为当前运行执行上下文。
        1. 令 _calleeContext_ 为 PrepareForOrdinaryCall(_F_, *undefined*)。
        1. 断言：_calleeContext_ 现在是运行执行上下文。
        1. 若 _F_.[[IsClassConstructor]] 为 *true*，则
          1. 令 _error_ 为一个新创建的 *TypeError* 对象。
          1. NOTE: _error_ 在 _calleeContext_ 中、使用 _F_ 关联的 Realm Record 创建。
          1. 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
          1. 返回 ThrowCompletion(_error_)。
        1. 执行 OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_)。
        1. 令 _result_ 为 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_))。
        1. [id="step-call-pop-context-stack"] 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
        1. 若 _result_ 是一个 return completion，返回 _result_.[[Value]]。
        1. 断言：_result_ 是一个 throw completion。
        1. 返回 ? _result_。
      </emu-alg>
      <emu-note>
        <p>当在步骤 <emu-xref href="#step-call-pop-context-stack"></emu-xref> 中把 _calleeContext_ 自执行上下文栈移除时，若它被一个可访问的 Generator 挂起并保留以供后续恢复，则不得销毁它。</p>
      </emu-note>

      <emu-clause id="sec-prepareforordinarycall" type="abstract operation">
        <h1>
          PrepareForOrdinaryCall (
            _F_: an ECMAScript function object,
            _newTarget_: an Object or *undefined*,
          ): an execution context
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _callerContext_ 为当前运行执行上下文。
          1. 令 _calleeContext_ 为一个新的 ECMAScript 代码执行上下文。
          1. 将 _calleeContext_ 的 Function 设为 _F_。
          1. 令 _calleeRealm_ 为 _F_.[[Realm]]。
          1. 将 _calleeContext_ 的 Realm 设为 _calleeRealm_。
          1. 将 _calleeContext_ 的 ScriptOrModule 设为 _F_.[[ScriptOrModule]]。
          1. 令 _localEnv_ 为 NewFunctionEnvironment(_F_, _newTarget_)。
          1. 将 _calleeContext_ 的 LexicalEnvironment 设为 _localEnv_。
          1. 将 _calleeContext_ 的 VariableEnvironment 设为 _localEnv_。
          1. 将 _calleeContext_ 的 PrivateEnvironment 设为 _F_.[[PrivateEnvironment]]。
          1. 若 _callerContext_ 尚未被挂起，则挂起 _callerContext_。
          1. 将 _calleeContext_ 压入执行上下文栈；_calleeContext_ 现在是运行执行上下文。
          1. NOTE: 之后产生的任何异常对象与 _calleeRealm_ 关联。
          1. 返回 _calleeContext_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallbindthis" type="abstract operation">
        <h1>
          OrdinaryCallBindThis (
            _F_: an ECMAScript function object,
            _calleeContext_: an execution context,
            _thisArgument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _thisMode_ 为 _F_.[[ThisMode]]。
          1. 若 _thisMode_ 为 ~lexical~，返回 ~unused~。
          1. 令 _calleeRealm_ 为 _F_.[[Realm]]。
          1. 令 _localEnv_ 为 _calleeContext_ 的 LexicalEnvironment。
          1. 若 _thisMode_ 为 ~strict~，则
            1. 令 _thisValue_ 为 _thisArgument_。
          1. 否则，
            1. 若 _thisArgument_ 是 *undefined* 或 *null*，则
              1. 令 _globalEnv_ 为 _calleeRealm_.[[GlobalEnv]]。
              1. 断言：_globalEnv_ 是一个 Global Environment Record。
              1. 令 _thisValue_ 为 _globalEnv_.[[GlobalThisValue]]。
            1. 否则，
              1. 令 _thisValue_ 为 ! ToObject(_thisArgument_)。
              1. NOTE: ToObject 使用 _calleeRealm_ 产生包装对象。
          1. 断言：_localEnv_ 是一个 Function Environment Record。
          1. 断言：下一步不会返回一个 abrupt completion，因为 _localEnv_.[[ThisBindingStatus]] 不是 ~initialized~。
          1. 执行 ! BindThisValue(_localEnv_, _thisValue_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-evaluatebody" type="sdo">
        <h1>
          运行时语义：EvaluateBody (
            _functionObject_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateFunctionBody of |FunctionBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateConciseBody of |ConciseBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateGeneratorBody of |GeneratorBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          AsyncGeneratorBody : FunctionBody
        </emu-grammar>
        <emu-alg>
          1. Return ? EvaluateAsyncGeneratorBody of |AsyncGeneratorBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          AsyncFunctionBody : FunctionBody
        </emu-grammar>
        <emu-alg>
          1. Return ? EvaluateAsyncFunctionBody of |AsyncFunctionBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          AsyncConciseBody : ExpressionBody
        </emu-grammar>
        <emu-alg>
          1. Return ? EvaluateAsyncConciseBody of |AsyncConciseBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          Initializer :
            `=` AssignmentExpression
        </emu-grammar>
        <emu-alg>
          1. Assert: _argumentsList_ is empty.
          1. Assert: _functionObject_.[[ClassFieldInitializerName]] is not ~empty~.
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _functionObject_.[[ClassFieldInitializerName]].
          1. Else,
            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Return ReturnCompletion(_value_).
        </emu-alg>
        <emu-note>
          <p>尽管字段初始化器构成了函数边界，调用 FunctionDeclarationInstantiation 没有可观察效果，因此省略。</p>
        </emu-note>
        <emu-grammar>
          ClassStaticBlockBody : ClassStaticBlockStatementList
        </emu-grammar>
        <emu-alg>
          1. Assert: _argumentsList_ is empty.
          1. Return ? EvaluateClassStaticBlockBody of |ClassStaticBlockBody| with argument _functionObject_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallevaluatebody" type="abstract operation">
        <h1>
          OrdinaryCallEvaluateBody (
            _F_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return ? EvaluateBody of _F_.[[ECMAScriptCode]] with arguments _F_ and _argumentsList_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 一个正常完成（包含 Object）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个 ECMAScript 函数对象 _F_</dd>
      </dl>
      <emu-alg>
        1. 令 _callerContext_ 为当前运行执行上下文。
        1. 令 _kind_ 为 _F_.[[ConstructorKind]]。
        1. 若 _kind_ 为 ~base~，则
          1. 令 _thisArgument_ 为 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*)。
        1. 令 _calleeContext_ 为 PrepareForOrdinaryCall(_F_, _newTarget_)。
        1. 断言：_calleeContext_ 现在是运行执行上下文。
        1. 若 _kind_ 为 ~base~，则
          1. 执行 OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_)。
          1. 令 _initializeResult_ 为 Completion(InitializeInstanceElements(_thisArgument_, _F_))。
          1. 若 _initializeResult_ 是一个 abrupt completion，则
            1. 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
            1. 返回 ? _initializeResult_。
        1. 令 _constructorEnv_ 为 _calleeContext_ 的 LexicalEnvironment。
        1. 令 _result_ 为 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_))。
        1. 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
        1. 若 _result_ 是一个 throw completion，则
          1. 返回 ? _result_。
        1. 断言：_result_ 是一个 return completion。
        1. 若 _result_.[[Value]] 是一个 Object，返回 _result_.[[Value]]。
        1. 若 _kind_ 为 ~base~，返回 _thisArgument_。
        1. 若 _result_.[[Value]] 不是 *undefined*，抛出 *TypeError* 异常。
        1. 令 _thisBinding_ 为 ? _constructorEnv_.GetThisBinding()。
        1. 断言：_thisBinding_ 是一个 Object。
        1. 返回 _thisBinding_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" type="abstract operation" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>
        OrdinaryFunctionCreate (
          _functionPrototype_: an Object,
          _sourceText_: a sequence of Unicode code points,
          _ParameterList_: a Parse Node,
          _Body_: a Parse Node,
          _thisMode_: ~lexical-this~ or ~non-lexical-this~,
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于在运行时创建一个具有默认 [[Call]] 内部方法且无 [[Construct]] 内部方法（但后续可通过诸如 MakeConstructor 的操作增加）的新函数。_sourceText_ 是待创建函数语法定义的源文本。</dd>
      </dl>
      <emu-alg>
        1. 令 _internalSlotsList_ 为 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。
        1. 令 _F_ 为 OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_)。
        1. 将 _F_.[[Call]] 设为 <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 中指定的定义。
        1. 将 _F_.[[SourceText]] 设为 _sourceText_。
        1. 将 _F_.[[FormalParameters]] 设为 _ParameterList_。
        1. 将 _F_.[[ECMAScriptCode]] 设为 _Body_。
        1. 令 _Strict_ 为 IsStrict(_Body_)。
        1. 将 _F_.[[Strict]] 设为 _Strict_。
        1. 若 _thisMode_ 为 ~lexical-this~，将 _F_.[[ThisMode]] 设为 ~lexical~。
        1. 否则若 _Strict_ 为 *true*，将 _F_.[[ThisMode]] 设为 ~strict~。
        1. 否则，将 _F_.[[ThisMode]] 设为 ~global~。
        1. 将 _F_.[[IsClassConstructor]] 设为 *false*。
        1. 将 _F_.[[Environment]] 设为 _env_。
        1. 将 _F_.[[PrivateEnvironment]] 设为 _privateEnv_。
        1. 将 _F_.[[ScriptOrModule]] 设为 GetActiveScriptOrModule()。
        1. 将 _F_.[[Realm]] 设为当前 Realm Record。
        1. 将 _F_.[[HomeObject]] 设为 *undefined*。
        1. 将 _F_.[[Fields]] 设为一个新的空 List。
        1. 将 _F_.[[PrivateMethods]] 设为一个新的空 List。
        1. 将 _F_.[[ClassFieldInitializerName]] 设为 ~empty~。
        1. 令 _len_ 为 _ParameterList_ 的 ExpectedArgumentCount。
        1. 执行 SetFunctionLength(_F_, _len_)。
        1. 返回 _F_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addrestrictedfunctionproperties" type="abstract operation">
      <h1>
        AddRestrictedFunctionProperties (
          _F_: a function object,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_realm_.[[Intrinsics]].[[%ThrowTypeError%]] 存在并已初始化。
        1. 令 _thrower_ 为 _realm_.[[Intrinsics]].[[%ThrowTypeError%]]。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"caller"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"arguments"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 返回 ~unused~。
      </emu-alg>

      <emu-clause id="sec-%throwtypeerror%">
        <h1>%ThrowTypeError% ( )</h1>
        <p>该函数是 <dfn>%ThrowTypeError%</dfn> 内在对象。</p>
        <p>它是一个匿名内置函数对象，并在每个 realm 中各定义一次。</p>
        <p>当被调用时执行以下步骤：</p>
        <emu-alg>
          1. 抛出 *TypeError* 异常。
        </emu-alg>
        <p>此函数的 [[Extensible]] 内部槽的值为 *false*。</p>
        <p>该函数的 *"length"* 属性具备特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <p>该函数的 *"name"* 属性具备特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-makeconstructor" type="abstract operation">
      <h1>
        MakeConstructor (
          _F_: an ECMAScript function object or a built-in function object,
          optional _writablePrototype_: a Boolean,
          optional _prototype_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _F_ 转换为构造器。</dd>
      </dl>
      <emu-alg>
        1. 若 _F_ 是 ECMAScript 函数对象，则
          1. 断言：IsConstructor(_F_) 为 *false*。
          1. 断言：_F_ 是一个可扩展对象且无 *"prototype"* 自身属性。
          1. 将 _F_.[[Construct]] 设为 <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 中指定的定义。
        1. 否则，
          1. 将 _F_.[[Construct]] 设为 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 中指定的定义。
        1. 将 _F_.[[ConstructorKind]] 设为 ~base~。
        1. 若未提供 _writablePrototype_，将 _writablePrototype_ 设为 *true*。
        1. 若未提供 _prototype_，则
          1. 将 _prototype_ 设为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ! DefinePropertyOrThrow(_prototype_, *"constructor"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeclassconstructor" type="abstract operation">
      <h1>
        MakeClassConstructor (
          _F_: an ECMAScript function object,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_F_.[[IsClassConstructor]] 为 *false*。
        1. 将 _F_.[[IsClassConstructor]] 设为 *true*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" type="abstract operation">
      <h1>
        MakeMethod (
          _F_: an ECMAScript function object,
          _homeObject_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _F_ 配置为一个方法。</dd>
      </dl>
      <emu-alg>
        1. 断言：_homeObject_ 是一个普通对象。
        1. 将 _F_.[[HomeObject]] 设为 _homeObject_。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definemethodproperty" oldids="sec-createmethodproperty" type="abstract operation">
      <h1>
        DefineMethodProperty (
          _homeObject_: an Object,
          _key_: a property key or Private Name,
          _closure_: a function object,
          _enumerable_: a Boolean,
        ): either a normal completion containing either a PrivateElement or ~unused~, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_homeObject_ 是一个普通、可扩展对象。
        1. 若 _key_ 是一个 Private Name，则
          1. 返回 PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ }。
        1. 否则，
          1. 令 _desc_ 为 PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }。
          1. 执行 ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_)。
          1. NOTE: DefinePropertyOrThrow 只有在尝试定义 _key_ 为 *"prototype"* 的类静态方法时才会返回一个 abrupt completion。
          1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionname" type="abstract operation">
      <h1>
        SetFunctionName (
          _F_: a function object,
          _name_: a property key or Private Name,
          optional _prefix_: a String,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>为 _F_ 添加一个 *"name"* 属性。</dd>
      </dl>
      <emu-alg>
        1. 断言：_F_ 是一个可扩展对象，且没有 *"name"* 自身属性。
        1. 若 _name_ 是一个 Symbol，则
          1. 令 _description_ 为 _name_.[[Description]]。
          1. 若 _description_ 为 *undefined*，将 _name_ 设为空字符串。
          1. 否则，将 _name_ 设为 *"["*、_description_、*" ]"* 的字符串连接。
        1. 否则若 _name_ 是一个 Private Name，则
          1. 将 _name_ 设为 _name_.[[Description]]。
        1. 若 _F_ 具有 [[InitialName]] 内部槽，则
          1. 将 _F_.[[InitialName]] 设为 _name_。
        1. 若提供了 _prefix_，则
          1. 将 _name_ 设为 _prefix_、代码单元 0x0020 (SPACE)、_name_ 的字符串连接。
          1. 若 _F_ 具有 [[InitialName]] 内部槽，则
            1. NOTE: 下述步骤中的选择在本抽象操作每次执行时独立决定。
            1. 可选地，将 _F_.[[InitialName]] 设为 _name_。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"name"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionlength" type="abstract operation">
      <h1>
        SetFunctionLength (
          _F_: a function object,
          _length_: a non-negative integer or +&infin;,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>为 _F_ 添加一个 *"length"* 属性。</dd>
      </dl>
      <emu-alg>
        1. 断言：_F_ 是一个可扩展对象，且没有 *"length"* 自身属性。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-functiondeclarationinstantiation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ 是为其建立执行上下文的函数对象。</dd>
      </dl>
      <emu-note>
        <p>当为求值一个 ECMAScript 函数建立执行上下文时，会创建一个新的 Function Environment Record，并在其中实例化每个形式参数的绑定。函数体内的每个声明也会被实例化。若函数形式参数不包含任何默认值初始化器，则函数体声明与参数在同一个 Environment Record 中实例化。若存在默认值参数初始化器，则为函数体声明创建第二个 Environment Record。形式参数与函数在 FunctionDeclarationInstantiation 过程中被初始化。所有其它绑定在函数体求值期间初始化。</p>
      </emu-note>
      <p>被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _calleeContext_ 为当前运行执行上下文。
        1. 令 _code_ 为 _func_.[[ECMAScriptCode]]。
        1. 令 _strict_ 为 _func_.[[Strict]]。
        1. 令 _formals_ 为 _func_.[[FormalParameters]]。
        1. 令 _parameterNames_ 为 _formals_ 的 BoundNames。
        1. 若 _parameterNames_ 含有任意重复项，令 _hasDuplicates_ 为 *true*；否则令其为 *false*。
        1. 令 _simpleParameterList_ 为 IsSimpleParameterList of _formals_。
        1. 令 _hasParameterExpressions_ 为 ContainsExpression of _formals_。
        1. 令 _varNames_ 为 _code_ 的 VarDeclaredNames。
        1. 令 _varDeclarations_ 为 _code_ 的 VarScopedDeclarations。
        1. 令 _lexicalNames_ 为 _code_ 的 LexicallyDeclaredNames。
        1. 令 _functionNames_ 为一个新的空 List。
        1. 令 _functionsToInitialize_ 为一个新的空 List。
        1. 依逆序遍历 _varDeclarations_ 中每个元素 _d_，执行
          1. 若 _d_ 既不是 |VariableDeclaration| 也不是 |ForBinding| 也不是 |BindingIdentifier|，则
            1. 断言：_d_ 是 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration| 或 |AsyncGeneratorDeclaration| 之一。
            1. 令 _fn_ 为 _d_ 的 BoundNames 唯一元素。
            1. 若 _functionNames_ 不包含 _fn_，则
              1. 将 _fn_ 插入 _functionNames_ 首部。
              1. NOTE: 若同名函数声明出现多次，使用最后一个声明。
              1. 将 _d_ 插入 _functionsToInitialize_ 首部。
        1. 令 _argumentsObjectNeeded_ 为 *true*。
        1. 若 _func_.[[ThisMode]] 为 ~lexical~，则
          1. NOTE: 箭头函数永远没有 arguments 对象。
          1. 将 _argumentsObjectNeeded_ 设为 *false*。
        1. 否则若 _parameterNames_ 包含 *"arguments"*，则
          1. 将 _argumentsObjectNeeded_ 设为 *false*。
        1. 否则若 _hasParameterExpressions_ 为 *false*，则
          1. 若 _functionNames_ 包含 *"arguments"* 或 _lexicalNames_ 包含 *"arguments"*，则
            1. 将 _argumentsObjectNeeded_ 设为 *false*。
        1. 若 _strict_ 为 *true* 或 _hasParameterExpressions_ 为 *false*，则
          1. NOTE: 参数只需一个 Environment Record，因为严格模式代码中的 `eval` 调用不能创建对外可见的新绑定。
          1. 令 _env_ 为 _calleeContext_ 的 LexicalEnvironment。
        1. 否则，
          1. NOTE: 需要单独的 Environment Record 以确保形式参数列表中的直接 eval 创建的绑定不在参数声明的环境内。
          1. 令 _calleeEnv_ 为 _calleeContext_ 的 LexicalEnvironment。
          1. 令 _env_ 为 NewDeclarativeEnvironment(_calleeEnv_)。
          1. 断言：_calleeContext_ 的 VariableEnvironment 与 _calleeEnv_ 相同。
          1. 将 _calleeContext_ 的 LexicalEnvironment 设为 _env_。
        1. 对 _parameterNames_ 中每个字符串 _paramName_，执行
          1. 令 _alreadyDeclared_ 为 ! _env_.HasBinding(_paramName_)。
          1. NOTE: 早期错误确保重复参数名只可出现在无参数默认值或 rest 参数的非严格函数中。
          1. 若 _alreadyDeclared_ 为 *false*，则
            1. 执行 ! _env_.CreateMutableBinding(_paramName_, *false*)。
            1. 若 _hasDuplicates_ 为 *true*，则
              1. 执行 ! _env_.InitializeBinding(_paramName_, *undefined*)。
        1. 若 _argumentsObjectNeeded_ 为 *true*，则
          1. 若 _strict_ 为 *true* 或 _simpleParameterList_ 为 *false*，则
            1. 令 _ao_ 为 CreateUnmappedArgumentsObject(_argumentsList_)。
          1. 否则，
            1. NOTE: 仅对没有 rest 参数、没有任何参数默认值初始化器、且无解构参数的非严格函数提供映射 arguments 对象。
            1. 令 _ao_ 为 CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_)。
          1. 若 _strict_ 为 *true*，则
            1. 执行 ! _env_.CreateImmutableBinding(*"arguments"*, *false*)。
            1. NOTE: 严格模式代码的早期错误阻止对该绑定的赋值，因此其可变性不可观察。
          1. 否则，
            1. 执行 ! _env_.CreateMutableBinding(*"arguments"*, *false*)。
          1. 执行 ! _env_.InitializeBinding(*"arguments"*, _ao_)。
          1. 令 _parameterBindings_ 为 _parameterNames_ 与 « *"arguments"* » 的列表连接。
        1. 否则，
          1. 令 _parameterBindings_ 为 _parameterNames_。
        1. 令 _iteratorRecord_ 为 CreateListIteratorRecord(_argumentsList_)。
        1. 若 _hasDuplicates_ 为 *true*，则
          1. 令 _usedEnv_ 为 *undefined*。
        1. 否则，
          1. 令 _usedEnv_ 为 _env_。
        1. NOTE: 下列步骤不会返回 ReturnCompletion，因为在表达式位置唯一产生此类完成的方式是使用 |YieldExpression|，而其在参数列表中已由 <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref> 与 <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref> 的早期错误规则禁止。
        1. 执行 ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _usedEnv_。
        1. 若 _hasParameterExpressions_ 为 *false*，则
          1. NOTE: 参数与顶层 var 只需一个 Environment Record。
          1. 令 _instantiatedVarNames_ 为 _parameterBindings_ 的拷贝。
          1. 对 _varNames_ 中每个元素 _n_，执行
            1. 若 _instantiatedVarNames_ 不含 _n_，则
              1. 将 _n_ 追加至 _instantiatedVarNames_。
              1. 执行 ! _env_.CreateMutableBinding(_n_, *false*)。
              1. 执行 ! _env_.InitializeBinding(_n_, *undefined*)。
          1. 令 _varEnv_ 为 _env_。
        1. 否则，
          1. NOTE: 需要单独的 Environment Record 以确保形式参数列表中的表达式创建的闭包无法见到函数体内的声明。
          1. 令 _varEnv_ 为 NewDeclarativeEnvironment(_env_)。
          1. 将 _calleeContext_ 的 VariableEnvironment 设为 _varEnv_。
          1. 令 _instantiatedVarNames_ 为一个新的空 List。
          1. 对 _varNames_ 中每个元素 _n_，执行
            1. 若 _instantiatedVarNames_ 不含 _n_，则
              1. 将 _n_ 追加至 _instantiatedVarNames_。
              1. 执行 ! _varEnv_.CreateMutableBinding(_n_, *false*)。
              1. 若 _parameterBindings_ 不含 _n_，或 _functionNames_ 含 _n_，则
                1. 令 _initialValue_ 为 *undefined*。
              1. 否则，
                1. 令 _initialValue_ 为 ! _env_.GetBindingValue(_n_, *false*)。
              1. 执行 ! _varEnv_.InitializeBinding(_n_, _initialValue_)。
              1. NOTE: 与形式参数同名的 var 最初具有与对应已初始化参数相同的值。
        1. 若 _strict_ 为 *true*，则
          1. 令 _lexEnv_ 为 _varEnv_。
        1. 否则，
          1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point", normative-optional] 若宿主是 Web 浏览器或以其它方式支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>，则
            1. 对任意 |Block|、|CaseClause|、|DefaultClause| _x_ 的 |StatementList| 中直接包含，且 _code_ Contains _x_ 为 *true* 的每个 |FunctionDeclaration| _f_，执行
              1. 令 _F_ 为 _f_ 的 |BindingIdentifier| 的 StringValue。
              1. 若用以 _F_ 为 |BindingIdentifier| 的 |VariableStatement| 替换该 |FunctionDeclaration| _f_ 不会为 _func_ 产生早期错误，且 _parameterNames_ 不含 _F_，则
                1. NOTE: 仅当 _F_ 既不是 VarDeclaredName、也不是形式参数名、也不是另一个 |FunctionDeclaration| 时才在此实例化 _F_ 的 var 绑定。
                1. 若 _instantiatedVarNames_ 不含 _F_ 且 _F_ 不是 *"arguments"*，则
                  1. 执行 ! _varEnv_.CreateMutableBinding(_F_, *false*)。
                  1. 执行 ! _varEnv_.InitializeBinding(_F_, *undefined*)。
                  1. 将 _F_ 追加至 _instantiatedVarNames_。
                1. [id="step-functiondeclarationinstantiation-alt-funcdecl-eval"] 当 |FunctionDeclaration| _f_ 被求值时，用以下步骤取代 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 中的 |FunctionDeclaration| Evaluation 算法：
                  1. 令 _fEnv_ 为当前运行执行上下文的 VariableEnvironment。
                  1. 令 _bEnv_ 为当前运行执行上下文的 LexicalEnvironment。
                  1. 令 _fObj_ 为 ! _bEnv_.GetBindingValue(_F_, *false*)。
                  1. 执行 ! _fEnv_.SetMutableBinding(_F_, _fObj_, *false*)。
                  1. 返回 ~unused~。
          1. 令 _lexEnv_ 为 NewDeclarativeEnvironment(_varEnv_)。
          1. NOTE: 非严格函数为顶层词法声明使用一个单独的 Environment Record，以便直接 eval 能确定 eval 代码引入的 var 作用域声明是否与预先存在的顶层词法作用域声明冲突。严格函数不需要此步骤，因为严格直接 eval 总是将所有声明放入新的 Environment Record。
        1. 将 _calleeContext_ 的 LexicalEnvironment 设为 _lexEnv_。
        1. 令 _lexDeclarations_ 为 _code_ 的 LexicallyScopedDeclarations。
        1. 对 _lexDeclarations_ 中每个元素 _d_，执行
          1. NOTE: 词法声明的名字不可能与函数/生成器声明、形式参数或 var 名相同。词法声明的名字在此仅被实例化但未初始化。
          1. 对 _d_ 的 BoundNames 中每个元素 _dn_，执行
            1. 若 IsConstantDeclaration of _d_ 为 *true*，则
              1. 执行 ! _lexEnv_.CreateImmutableBinding(_dn_, *true*)。
            1. 否则，
              1. 执行 ! _lexEnv_.CreateMutableBinding(_dn_, *false*)。
        1. 令 _privateEnv_ 为 _calleeContext_ 的 PrivateEnvironment。
        1. 对 _functionsToInitialize_ 中每个 Parse Node _f_，执行
          1. 令 _fn_ 为 _f_ 的 BoundNames 唯一元素。
          1. 令 _fo_ 为 InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_。
          1. 执行 ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-function-objects">
    <h1>内置函数对象 (Built-in Function Objects)</h1>
    <p>内置函数对象是普通对象；它必须符合 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中对普通对象的要求。</p>
    <p>除每个普通对象所需的内部槽（见 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>）外，内置函数对象还必须具有下列内部槽：</p>
    <ul>
      <li>[[Realm]]：一个 Realm Record，表示创建该函数的 realm。</li>
      <li>[[InitialName]]：一个 String，函数的初始名称，被 <emu-xref href="#sec-function.prototype.tostring"></emu-xref> 使用。</li>
    </ul>
    <p>内置函数对象的 [[Prototype]] 内部槽初始值为 %Function.prototype%，除非另有规定。</p>
    <p>内置函数对象必须具有符合 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref> 定义的 [[Call]] 内部方法。</p>
    <p>仅当被描述为 “constructor” 或本规范中的某个算法显式设置其 [[Construct]] 内部方法时，内置函数对象才具有 [[Construct]]。该 [[Construct]] 必须符合 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 的定义。</p>
    <p>实现可以提供未在本规范中定义的额外内置函数对象。</p>

    <emu-clause id="sec-built-in-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>内置函数对象 _F_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-built-in-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 返回一个包含 Object 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>内置函数对象 _F_（当该方法存在时）</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为 ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_)。
        1. 断言：_result_ 是一个 Object。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-builtincallorconstruct" type="abstract operation">
      <h1>
        BuiltinCallOrConstruct (
          _F_: a built-in function object,
          _thisArgument_: an ECMAScript language value or ~uninitialized~,
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor or *undefined*,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _callerContext_ 为正在运行的执行上下文。
        1. 若 _callerContext_ 尚未被挂起，则挂起 _callerContext_。
        1. 令 _calleeContext_ 为一个新的执行上下文。
        1. 将 _calleeContext_ 的 Function 设为 _F_。
        1. 令 _calleeRealm_ 为 _F_.[[Realm]]。
        1. 将 _calleeContext_ 的 Realm 设为 _calleeRealm_。
        1. 将 _calleeContext_ 的 ScriptOrModule 设为 *null*。
        1. 执行任何实现定义的、对 _calleeContext_ 必要的初始化。
        1. 将 _calleeContext_ 压入执行上下文栈；_calleeContext_ 现在为运行执行上下文。
        1. [id="step-call-builtin-function-result"] 令 _result_ 为 <emu-meta effects="user-code">对 _F_ 的求值</emu-meta> 且符合其规范描述的完成记录结果。若 _thisArgument_ 为 ~uninitialized~，则 *this* 值未初始化；否则由 _thisArgument_ 提供 *this* 值。_argumentsList_ 提供具名参数。_newTarget_ 提供 NewTarget 值。
        1. 注：若 _F_ 在本文档中定义，其“规范描述”即通过算法步骤或其他方式给出的行为。
        1. 将 _calleeContext_ 自执行上下文栈移除并恢复 _callerContext_ 为运行执行上下文。
        1. 返回 ? _result_。
      </emu-alg>
      <emu-note>
        <p>当 _calleeContext_ 被自执行上下文栈移除时，若其已被可访问的 Generator 挂起并被保留以供后续恢复，则不得销毁它。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createbuiltinfunction" type="abstract operation">
      <h1>
        CreateBuiltinFunction (
          _behaviour_: an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification,
          _length_: a non-negative integer or +&infin;,
          _name_: a property key or a Private Name,
          _additionalInternalSlotsList_: a List of names of internal slots,
          optional _realm_: a Realm Record,
          optional _prototype_: an Object or *null*,
          optional _prefix_: a String,
        ): 一个内置函数对象
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_additionalInternalSlotsList_ 含必须作为该对象一部分定义的额外内部槽名称。此操作创建一个内置函数对象。</dd>
      </dl>
      <emu-alg>
        1. 若未提供 _realm_，则将 _realm_ 设为当前 Realm Record。
        1. 若未提供 _prototype_，则将 _prototype_ 设为 _realm_.[[Intrinsics]].[[%Function.prototype%]]。
        1. 令 _internalSlotsList_ 为包含 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 要求的全部内部槽名称的列表，用于即将创建的内置函数对象。
        1. 将 _additionalInternalSlotsList_ 的各元素追加到 _internalSlotsList_。
        1. 令 _func_ 为一个新的内置函数对象；当被调用时，使用所提供实参作为 _behaviour_ 指定的对应形参值执行 _behaviour_ 描述的动作。该新函数对象具有名称为 _internalSlotsList_ 各元素的内部槽，以及一个 [[InitialName]] 内部槽。
        1. 将 _func_.[[Prototype]] 设为 _prototype_。
        1. 将 _func_.[[Extensible]] 设为 *true*。
        1. 将 _func_.[[Realm]] 设为 _realm_。
        1. 将 _func_.[[InitialName]] 设为 *null*。
        1. 执行 SetFunctionLength(_func_, _length_)。
        1. 若未提供 _prefix_，则
          1. 执行 SetFunctionName(_func_, _name_)。
        1. 否则，
          1. 执行 SetFunctionName(_func_, _name_, _prefix_)。
        1. 返回 _func_。
      </emu-alg>
      <p>本规范中定义的每个内置函数均通过调用 CreateBuiltinFunction 抽象操作创建。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>内置特异对象的内部方法与内部槽 (Built-in Exotic Object Internal Methods and Slots)</h1>
    <p>本规范定义了多种内置特异对象。除少数特定情形外，它们与普通对象的行为相似。以下特异对象除非下文明确另行规定，否则使用普通对象的内部方法：</p>

    <emu-clause id="sec-bound-function-exotic-objects">
      <h1>绑定函数特异对象 (Bound Function Exotic Objects)</h1>
      <p>绑定函数特异对象是包装另一个函数对象的特异对象。它是可调用的（具有 [[Call]]，可能具有 [[Construct]]）。调用它通常导致调用其被包装的函数。</p>

      <p>若对象的 [[Call]] 与（若适用）[[Construct]] 内部方法使用以下实现，且其他基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中的定义，则该对象是一个 <dfn id="bound-function-exotic-object" variants="bound function exotic objects">绑定函数特异对象</dfn>。这些方法在 BoundFunctionCreate 中安装。</p>

      <p>绑定函数特异对象不具有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中 ECMAScript 函数对象的内部槽；它们改为（除 [[Prototype]] 与 [[Extensible]] 外）具有 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 所列的内部槽。</p>
      <emu-table id="table-internal-slots-of-bound-function-exotic-objects" caption="绑定函数特异对象的内部槽 (Internal Slots of Bound Function Exotic Objects)" oldids="table-28">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BoundTargetFunction]]
            </td>
            <td>
              a callable Object
            </td>
            <td>
              被包装的函数对象。
            </td>
          </tr>
          <tr>
            <td>
              [[BoundThis]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              调用被包装函数时始终作为 *this* 的值。
            </td>
          </tr>
          <tr>
            <td>
              [[BoundArguments]]
            </td>
            <td>
              a List of ECMAScript language values
            </td>
            <td>
              在任何调用中用作被包装函数前置实参的值列表。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-bound-function-exotic-objects-call-thisargument-argumentslist" type="internal method">
        <h1>
          [[Call]] (
            _thisArgument_: an ECMAScript language value,
            _argumentsList_: a List of ECMAScript language values,
          ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>绑定函数特异对象 _F_</dd>
        </dl>
        <emu-alg>
          1. 令 _target_ 为 _F_.[[BoundTargetFunction]]。
          1. 令 _boundThis_ 为 _F_.[[BoundThis]]。
          1. 令 _boundArgs_ 为 _F_.[[BoundArguments]]。
          1. 令 _args_ 为 _boundArgs_ 与 _argumentsList_ 的列表连接。
          1. 返回 ? Call(_target_, _boundThis_, _args_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bound-function-exotic-objects-construct-argumentslist-newtarget" type="internal method">
        <h1>
          [[Construct]] (
            _argumentsList_: a List of ECMAScript language values,
            _newTarget_: a constructor,
          ): 返回一个包含 Object 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>绑定函数特异对象 _F_</dd>
        </dl>
        <emu-alg>
          1. 令 _target_ 为 _F_.[[BoundTargetFunction]]。
          1. 断言：IsConstructor(_target_) 为 *true*。
          1. 令 _boundArgs_ 为 _F_.[[BoundArguments]]。
          1. 令 _args_ 为 _boundArgs_ 与 _argumentsList_ 的列表连接。
          1. 若 SameValue(_F_, _newTarget_) 为 *true*，则将 _newTarget_ 设为 _target_。
          1. 返回 ? Construct(_target_, _args_, _newTarget_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundfunctioncreate" type="abstract operation">
        <h1>
          BoundFunctionCreate (
            _targetFunction_: a function object,
            _boundThis_: an ECMAScript language value,
            _boundArgs_: a List of ECMAScript language values,
          ): 返回一个包含 function object 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的绑定函数特异对象。</dd>
        </dl>
        <emu-alg>
          1. 令 _proto_ 为 ? <emu-meta effects="user-code">_targetFunction_.[[GetPrototypeOf]]</emu-meta>()。
          1. 令 _internalSlotsList_ 为 « [[Prototype]], [[Extensible]] » 与 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 中内部槽列表的连接。
          1. 令 _obj_ 为 MakeBasicObject(_internalSlotsList_)。
          1. 将 _obj_.[[Prototype]] 设为 _proto_。
          1. 按 <emu-xref href="#sec-bound-function-exotic-objects-call-thisargument-argumentslist"></emu-xref> 所述设置 _obj_.[[Call]]。
          1. 若 IsConstructor(_targetFunction_) 为 *true*，则
            1. 按 <emu-xref href="#sec-bound-function-exotic-objects-construct-argumentslist-newtarget"></emu-xref> 所述设置 _obj_.[[Construct]]。
          1. 将 _obj_.[[BoundTargetFunction]] 设为 _targetFunction_。
          1. 将 _obj_.[[BoundThis]] 设为 _boundThis_。
          1. 将 _obj_.[[BoundArguments]] 设为 _boundArgs_。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-exotic-objects">
      <h1>数组特异对象 (Array Exotic Objects)</h1>
      <p>Array 是对数组索引属性键（见 <emu-xref href="#sec-object-type"></emu-xref>）做特殊处理的特异对象。属性名为数组索引的属性也称为 <em>element</em>。每个 Array 有一个不可配置的 *"length"* 属性，其值始终是数学值严格小于 2<sup>32</sup> 的非负整数 Number。*"length"* 的值在数值上大于其每个名称为数组索引的自身属性的名称；当 Array 的自身属性被创建或改变时，为保持该不变式，会按需要调整其他属性。具体地，当添加一个名称为数组索引的自身属性时，必要时将 *"length"* 的值改为该索引数值加一；当 *"length"* 值被改变时，删除所有名称为数组索引且其值不小于新 length 的自身属性。该约束仅适用于 Array 的自身属性，不受其原型链上继承的 *"length"* 或数组索引属性影响。</p>

      <p>若对象的 [[DefineOwnProperty]] 内部方法使用以下实现，且其其它基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中的定义，则其为 <dfn id="array-exotic-object" variants="Array exotic objects">数组特异对象</dfn>（简称 Array）。这些方法在 ArrayCreate 中安装。</p>

      <emu-clause id="sec-array-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>数组特异对象 _A_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 为 *"length"*，则
            1. 返回 ? ArraySetLength(_A_, _Desc_)。
          1. 否则若 _P_ 是数组索引，则
            1. 令 _lengthDesc_ 为 OrdinaryGetOwnProperty(_A_, *"length"*)。
            1. 断言：_lengthDesc_ 不为 *undefined*。
            1. 断言：IsDataDescriptor(_lengthDesc_) 为 *true*。
            1. 断言：_lengthDesc_.[[Configurable]] 为 *false*。
            1. 令 _length_ 为 _lengthDesc_.[[Value]]。
            1. 断言：_length_ 是非负整数 Number。
            1. 令 _index_ 为 ! ToUint32(_P_)。
            1. 若 _index_ ≥ _length_ 且 _lengthDesc_.[[Writable]] 为 *false*，返回 *false*。
            1. 令 _succeeded_ 为 ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_)。
            1. 若 _succeeded_ 为 *false*，返回 *false*。
            1. 若 _index_ ≥ _length_，则
              1. 将 _lengthDesc_.[[Value]] 设为 _index_ + *1*<sub>𝔽</sub>。
              1. 将 _succeeded_ 设为 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _lengthDesc_)。
              1. 断言：_succeeded_ 为 *true*。
            1. 返回 *true*。
          1. 返回 ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraycreate" type="abstract operation">
        <h1>
          ArrayCreate (
            _length_: a non-negative integer,
            optional _proto_: an Object,
          ): 返回一个包含数组特异对象的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的 Array。</dd>
        </dl>
        <emu-alg>
          1. 若 _length_ > 2<sup>32</sup> - 1，抛出 *RangeError* 异常。
          1. 若未提供 _proto_，则设 _proto_ 为 %Array.prototype%。
          1. 令 _A_ 为 MakeBasicObject(« [[Prototype]], [[Extensible]] »)。
          1. 将 _A_.[[Prototype]] 设为 _proto_。
          1. 按 <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref> 规定设置 _A_.[[DefineOwnProperty]]。
          1. 执行 ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arrayspeciescreate" type="abstract operation">
        <h1>
          ArraySpeciesCreate (
            _originalArray_: an Object,
            _length_: a non-negative integer,
          ): 返回一个包含 Object 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定通过由 _originalArray_ 派生的构造函数创建新的 Array 或相似对象；不强制该构造函数返回 Array。</dd>
        </dl>
        <emu-alg>
          1. 令 _isArray_ 为 ? IsArray(_originalArray_)。
          1. 若 _isArray_ 为 *false*，返回 ? ArrayCreate(_length_)。
          1. 令 _C_ 为 ? Get(_originalArray_, *"constructor"*)。
          1. 若 IsConstructor(_C_) 为 *true*，则
            1. 令 _thisRealm_ 为当前 Realm Record。
            1. 令 _realmC_ 为 ? GetFunctionRealm(_C_)。
            1. 若 _thisRealm_ 与 _realmC_ 不是同一 Realm Record，则
              1. 若 SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) 为 *true*，将 _C_ 设为 *undefined*。
          1. 若 _C_ 是一个 Object，则
            1. 将 _C_ 设为 ? Get(_C_, %Symbol.species%)。
            1. 若 _C_ 为 *null*，将 _C_ 设为 *undefined*。
          1. 若 _C_ 为 *undefined*，返回 ? ArrayCreate(_length_)。
          1. 若 IsConstructor(_C_) 为 *false*，抛出 *TypeError* 异常。
          1. 返回 ? Construct(_C_, « 𝔽(_length_) »)。
        </emu-alg>
        <emu-note>
          <p>若 _originalArray_ 使用非当前执行上下文 realm 的标准内置 Array 构造器创建，则新 Array 使用当前执行上下文的 realm 创建，以保持与历史浏览器行为兼容。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-arraysetlength" type="abstract operation">
        <h1>
          ArraySetLength (
            _A_: an Array,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 不含 [[Value]] 字段，则
            1. 返回 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _Desc_)。
          1. 令 _newLenDesc_ 为 _Desc_ 的拷贝。
          1. [id="step-arraysetlength-newlen"] 令 _newLen_ 为 ? ToUint32(_Desc_.[[Value]])。
          1. [id="step-arraysetlength-numberlen"] 令 _numberLen_ 为 ? ToNumber(_Desc_.[[Value]])。
          1. 若 SameValueZero(_newLen_, _numberLen_) 为 *false*，抛出 *RangeError* 异常。
          1. 将 _newLenDesc_.[[Value]] 设为 _newLen_。
          1. 令 _oldLenDesc_ 为 OrdinaryGetOwnProperty(_A_, *"length"*)。
          1. 断言：_oldLenDesc_ 不为 *undefined*。
          1. 断言：IsDataDescriptor(_oldLenDesc_) 为 *true*。
          1. 断言：_oldLenDesc_.[[Configurable]] 为 *false*。
          1. 令 _oldLen_ 为 _oldLenDesc_.[[Value]]。
          1. 若 _newLen_ ≥ _oldLen_，则
            1. 返回 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_)。
          1. 若 _oldLenDesc_.[[Writable]] 为 *false*，返回 *false*。
          1. 若 _newLenDesc_ 无 [[Writable]] 字段或 _newLenDesc_.[[Writable]] 为 *true*，则
            1. 令 _newWritable_ 为 *true*。
          1. 否则，
            1. 注：若某些元素无法删除，则延迟将 [[Writable]] 设为 *false*。
            1. 令 _newWritable_ 为 *false*。
            1. 将 _newLenDesc_.[[Writable]] 设为 *true*。
          1. 令 _succeeded_ 为 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_)。
          1. 若 _succeeded_ 为 *false*，返回 *false*。
          1. 对 _A_ 的每个自身属性键 _P_，若 _P_ 是数组索引且 ! ToUint32(_P_) ≥ _newLen_，按递减数值索引顺序：
            1. 令 _deleteSucceeded_ 为 ! _A_.[[Delete]](_P_)。
            1. 若 _deleteSucceeded_ 为 *false*，则
              1. 将 _newLenDesc_.[[Value]] 设为 ! ToUint32(_P_) + *1*<sub>𝔽</sub>。
              1. 若 _newWritable_ 为 *false*，将 _newLenDesc_.[[Writable]] 设为 *false*。
              1. 执行 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_)。
              1. 返回 *false*。
          1. 若 _newWritable_ 为 *false*，则
            1. 将 _succeeded_ 设为 ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Writable]]: *false* })。
            1. 断言：_succeeded_ 为 *true*。
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>在步骤 <emu-xref href="#step-arraysetlength-newlen"></emu-xref> 与 <emu-xref href="#step-arraysetlength-numberlen"></emu-xref> 中，若 _Desc_.[[Value]] 是对象，其 `valueOf` 方法被调用两次（历史遗留行为）。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-exotic-objects">
      <h1>字符串特异对象 (String Exotic Objects)</h1>
      <p>String 对象是封装一个 String 值并暴露与该值中各代码单元元素对应的虚拟整数索引数据属性的特异对象。字符串特异对象始终具有名为 *"length"* 的数据属性，其值为封装的 String 长度。代码单元数据属性与 *"length"* 属性均不可写且不可配置。</p>

      <p>若对象的 [[GetOwnProperty]]、[[DefineOwnProperty]] 与 [[OwnPropertyKeys]] 内部方法使用以下实现，且其他基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中的定义，则该对象是 <dfn id="string-exotic-object" variants="String exotic objects">字符串特异对象</dfn>（或简称 String 对象）。这些方法在 StringCreate 中安装。</p>

      <p>字符串特异对象拥有与普通对象相同的内部槽，另有 [[StringData]] 内部槽。</p>

      <emu-clause id="sec-string-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回一个包含 Property Descriptor 或 *undefined* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>字符串特异对象 _S_</dd>
        </dl>
        <emu-alg>
          1. 令 _desc_ 为 OrdinaryGetOwnProperty(_S_, _P_)。
          1. 若 _desc_ 不为 *undefined*，返回 _desc_。
          1. 返回 StringGetOwnProperty(_S_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>字符串特异对象 _S_</dd>
        </dl>
        <emu-alg>
          1. 令 _stringDesc_ 为 StringGetOwnProperty(_S_, _P_)。
          1. 若 _stringDesc_ 不为 *undefined*，则
            1. 令 _extensible_ 为 _S_.[[Extensible]]。
            1. 返回 IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_)。
          1. 返回 ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 返回一个包含属性键列表的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>字符串特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 令 _keys_ 为一个新的空列表。
          1. 令 _str_ 为 _O_.[[StringData]]。
          1. 断言：_str_ 是一个 String。
          1. 令 _len_ 为 _str_ 的长度。
          1. 对每个整数 _i_（0 ≤ _i_ < _len_，按升序）：
            1. 追加 ! ToString(𝔽(_i_)) 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 是数组索引 且 ! ToIntegerOrInfinity(_P_) ≥ _len_，按数值索引升序）：
            1. 追加 _P_ 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 String 且非数组索引，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 Symbol，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 返回 _keys_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringcreate" type="abstract operation">
        <h1>
          StringCreate (
            _value_: a String,
            _prototype_: an Object,
          ): 一个字符串特异对象
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的字符串特异对象。</dd>
        </dl>
        <emu-alg>
          1. 令 _S_ 为 MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »)。
          1. 将 _S_.[[Prototype]] 设为 _prototype_。
          1. 将 _S_.[[StringData]] 设为 _value_。
          1. 按 <emu-xref href="#sec-string-exotic-objects-getownproperty-p"></emu-xref> 规定设置 _S_.[[GetOwnProperty]]。
          1. 按 <emu-xref href="#sec-string-exotic-objects-defineownproperty-p-desc"></emu-xref> 规定设置 _S_.[[DefineOwnProperty]]。
          1. 按 <emu-xref href="#sec-string-exotic-objects-ownpropertykeys"></emu-xref> 规定设置 _S_.[[OwnPropertyKeys]]。
          1. 令 _length_ 为 _value_ 的长度。
          1. 执行 ! DefinePropertyOrThrow(_S_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _S_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringgetownproperty" type="abstract operation">
        <h1>
          StringGetOwnProperty (
            _S_: an Object that has a [[StringData]] internal slot,
            _P_: a property key,
          ): 一个 Property Descriptor 或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _P_ 不是 String，返回 *undefined*。
          1. 令 _index_ 为 CanonicalNumericIndexString(_P_)。
          1. 若 _index_ 不是整数 Number，返回 *undefined*。
          1. 若 _index_ 为 *-0*<sub>𝔽</sub> 或 _index_ &lt; *-0*<sub>𝔽</sub>，返回 *undefined*。
          1. 令 _str_ 为 _S_.[[StringData]]。
          1. 断言：_str_ 是 String。
          1. 令 _len_ 为 _str_ 的长度。
          1. 若 ℝ(_index_) ≥ _len_，返回 *undefined*。
          1. 令 _resultStr_ 为从 ℝ(_index_) 到 ℝ(_index_) + 1 的 _str_ 子串。
          1. 返回 PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arguments-exotic-objects">
      <h1>Arguments 特异对象 (Arguments Exotic Objects)</h1>

      <p>大多数 ECMAScript 函数向其代码提供一个 arguments 对象。依据函数定义特征，该对象要么是普通对象，要么是 arguments 特异对象。arguments 特异对象的数组索引属性映射到其关联函数一次调用的形式参数绑定。</p>

      <p>若对象的内部方法按以下实现（未指明者使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 的定义），则为 <dfn id="arguments-exotic-object" variants="arguments exotic objects">arguments 特异对象</dfn>。这些方法在 CreateMappedArgumentsObject 中安装。</p>

      <emu-note>
        <p>虽 CreateUnmappedArgumentsObject 归入本条款，但它创建的是普通对象而非 arguments 特异对象。</p>
      </emu-note>

      <p>Arguments 特异对象与普通对象具有相同内部槽，并另有 [[ParameterMap]]。普通 arguments 对象也有 [[ParameterMap]]，其值恒为 *undefined*，仅被 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 用来识别。</p>

      <emu-note>
        <p>数值名称小于对应函数形式参数个数的整数索引数据属性初始与执行上下文中的参数绑定共享其值；修改其一会影响另一方。删除并重新定义该属性或将其改为访问器属性会打破这种对应。普通 arguments 对象的属性值仅是实参副本，不与形式参数动态联动。</p>
      </emu-note>
      <emu-note>
        <p>ParameterMap 对象及其属性值是描述 arguments 对象与参数绑定对应关系的机制；它们对 ECMAScript 代码不可直接观察，实现无需实际创建。</p>
      </emu-note>
      <emu-note>
        <p>普通 arguments 对象定义一个名为 *"callee"* 的不可配置访问器属性，访问时抛出 *TypeError*。在 arguments 特异对象上 *"callee"* 有更具体含义。普通变体的定义防止实现以其他方式定义它。</p>
      </emu-note>
      <emu-note>
        <p>历史上 arguments 特异对象实现包含 *"caller"* 访问器。ECMAScript 2017 之前规范在普通 arguments 对象上要求其抛出。此扩展已弃用，相关要求被移除。</p>
      </emu-note>

      <emu-clause id="sec-arguments-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回包含 Property Descriptor 或 *undefined* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _desc_ 为 OrdinaryGetOwnProperty(_args_, _P_)。
          1. 若 _desc_ 为 *undefined*，返回 *undefined*。
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 若 _isMapped_ 为 *true*，则
            1. 将 _desc_.[[Value]] 设为 ! Get(_map_, _P_)。
          1. 返回 _desc_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 令 _newArgDesc_ 为 _Desc_。
          1. 若 _isMapped_ 为 *true* 且 IsDataDescriptor(_Desc_) 为 *true*，则
            1. 若 _Desc_ 不含 [[Value]] 字段、含 [[Writable]] 字段且 _Desc_.[[Writable]] 为 *false*，则
              1. 将 _newArgDesc_ 设为 _Desc_ 的拷贝。
              1. 将 _newArgDesc_.[[Value]] 设为 ! Get(_map_, _P_)。
          1. 令 _allowed_ 为 ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_)。
          1. 若 _allowed_ 为 *false*，返回 *false*。
          1. 若 _isMapped_ 为 *true*，则
            1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，则
              1. 执行 ! _map_.[[Delete]](_P_)。
            1. 否则，
              1. 若 _Desc_ 含 [[Value]] 字段，则
                1. 断言：下面的 Set 会成功，因为被映射的形式参数总是可写。
                1. 执行 ! Set(_map_, _P_, _Desc_.[[Value]], *false*)。
              1. 若 _Desc_ 含 [[Writable]] 字段且 _Desc_.[[Writable]] 为 *false*，则
                1. 执行 ! _map_.[[Delete]](_P_)。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 若 _isMapped_ 为 *false*，则
            1. 返回 ? OrdinaryGet(_args_, _P_, _Receiver_)。
          1. 否则，
            1. 断言：_map_ 包含 _P_ 的形式参数映射。
            1. 返回 ! Get(_map_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 若 SameValue(_args_, _Receiver_) 为 *false*，则
            1. 令 _isMapped_ 为 *false*。
          1. 否则，
            1. 令 _map_ 为 _args_.[[ParameterMap]]。
            1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 若 _isMapped_ 为 *true*，则
            1. 断言：以下 Set 会成功，因为被映射形式参数总是可写。
            1. 执行 ! Set(_map_, _P_, _V_, *false*)。
          1. 返回 ? OrdinarySet(_args_, _P_, _V_, _Receiver_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 令 _result_ 为 ? OrdinaryDelete(_args_, _P_)。
          1. 若 _result_ 为 *true* 且 _isMapped_ 为 *true*，则
            1. 执行 ! _map_.[[Delete]](_P_)。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createunmappedargumentsobject" type="abstract operation">
        <h1>
          CreateUnmappedArgumentsObject (
            _argumentsList_: a List of ECMAScript language values,
          ): 一个普通对象
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _argumentsList_ 中元素个数。
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »)。
          1. 将 _obj_.[[ParameterMap]] 设为 *undefined*。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _len_ 重复：
            1. 令 _val_ 为 _argumentsList_[_index_]。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_)。
            1. 将 _index_ 设为 _index_ + 1。
          1. 执行 ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createmappedargumentsobject" type="abstract operation">
        <h1>
          CreateMappedArgumentsObject (
            _func_: an Object,
            _formals_: a Parse Node,
            _argumentsList_: a List of ECMAScript language values,
            _env_: an Environment Record,
          ): 一个 arguments 特异对象
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_formals_ 不含 rest 参数、任何绑定模式或初始化器；可包含重复标识符。
          1. 令 _len_ 为 _argumentsList_ 元素个数。
          1. 令 _obj_ 为 MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »)。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-getownproperty-p"></emu-xref> 设置 _obj_.[[GetOwnProperty]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-defineownproperty-p-desc"></emu-xref> 设置 _obj_.[[DefineOwnProperty]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-get-p-receiver"></emu-xref> 设置 _obj_.[[Get]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-set-p-v-receiver"></emu-xref> 设置 _obj_.[[Set]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-delete-p"></emu-xref> 设置 _obj_.[[Delete]]。
          1. 将 _obj_.[[Prototype]] 设为 %Object.prototype%。
          1. 令 _map_ 为 OrdinaryObjectCreate(*null*)。
          1. 将 _obj_.[[ParameterMap]] 设为 _map_。
          1. 令 _parameterNames_ 为 _formals_ 的 BoundNames。
          1. 令 _numberOfParameters_ 为 _parameterNames_ 元素个数。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _len_ 重复：
            1. 令 _val_ 为 _argumentsList_[_index_]。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_)。
            1. 将 _index_ 设为 _index_ + 1。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 令 _mappedNames_ 为新空列表。
          1. 将 _index_ 设为 _numberOfParameters_ - 1。
          1. 当 _index_ ≥ 0 重复：
            1. 令 _name_ 为 _parameterNames_[_index_]。
            1. 若 _mappedNames_ 不含 _name_，则
              1. 追加 _name_ 至 _mappedNames_。
              1. 若 _index_ &lt; _len_，则
                1. 令 _g_ 为 MakeArgGetter(_name_, _env_)。
                1. 令 _p_ 为 MakeArgSetter(_name_, _env_)。
                1. 执行 ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
            1. 将 _index_ 设为 _index_ - 1。
          1. 执行 ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 返回 _obj_。
        </emu-alg>

        <emu-clause id="sec-makearggetter" type="abstract operation">
          <h1>
            MakeArgGetter (
              _name_: a String,
              _env_: an Environment Record,
            ): 一个函数对象
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>创建一个内置函数对象，执行时返回 _env_ 中对 _name_ 的绑定值。</dd>
          </dl>
          <emu-alg>
            1. 令 _getterClosure_ 为一个新的无参数 Abstract Closure，捕获 _name_ 与 _env_，调用时执行：
              1. 返回 NormalCompletion(! _env_.GetBindingValue(_name_, *false*))。
            1. 令 _getter_ 为 CreateBuiltinFunction(_getterClosure_, 0, *""*, « »)。
            1. 注：_getter_ 不会被 ECMAScript 代码直接访问。
            1. 返回 _getter_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-makeargsetter" type="abstract operation">
          <h1>
            MakeArgSetter (
              _name_: a String,
              _env_: an Environment Record,
            ): 一个函数对象
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>创建一个内置函数对象，执行时设置 _env_ 中 _name_ 的绑定值。</dd>
          </dl>
          <emu-alg>
            1. 令 _setterClosure_ 为一个带参数 (_value_) 的新 Abstract Closure，捕获 _name_ 与 _env_，调用时执行：
              1. 返回 NormalCompletion(! _env_.SetMutableBinding(_name_, _value_, *false*))。
            1. 令 _setter_ 为 CreateBuiltinFunction(_setterClosure_, 1, *""*, « »)。
            1. 注：_setter_ 不会被 ECMAScript 代码直接访问。
            1. 返回 _setter_。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-exotic-objects" oldids="sec-integer-indexed-exotic-objects">
      <h1>TypedArray 特异对象 (TypedArray Exotic Objects)</h1>
      <p>TypedArray 是对规范数字字符串属性键做特殊处理的特异对象，使用其中属于界内整数索引的子集访问同类型元素，并在不遍历原型链的情况下确保其余索引缺失的不变式。</p>
      <emu-note>
        <p>由于对任意 Number _n_，ToString(_n_) 为规范数字字符串，实现可在无需真实字符串转换的情况下将 Number 当作属性键。</p>
      </emu-note>
      <p>TypedArrays 拥有普通对象的内部槽，并额外具有 [[ViewedArrayBuffer]]、[[TypedArrayName]]、[[ContentType]]、[[ByteLength]]、[[ByteOffset]]、[[ArrayLength]]。</p>
      <p>若对象的 [[PreventExtensions]]、[[GetOwnProperty]]、[[HasProperty]]、[[DefineOwnProperty]]、[[Get]]、[[Set]]、[[Delete]]、[[OwnPropertyKeys]] 内部方法使用本节定义，且其它基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 的定义，则其为 <dfn id="typedarray" oldids="integer-indexed-exotic-object" variants="TypedArrays">TypedArray</dfn>。这些方法由 TypedArrayCreate 安装。</p>

      <emu-clause id="sec-typedarray-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): 返回一个包含 Boolean 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 注：<emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 中的可扩展性不变式不允许在 _O_ 仍可能获得（或失去后再获得）属性时返回 *true*；当底层缓冲区重分配且涉及整数索引属性时可能发生该情况。
          1. 若 IsTypedArrayFixedLength(_O_) 为 *false*，返回 *false*。
          1. 返回 OrdinaryPreventExtensions(_O_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-getownproperty" oldids="sec-integer-indexed-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回包含 Property Descriptor 或 *undefined* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 令 _value_ 为 TypedArrayGetElement(_O_, _numericIndex_)。
              1. 若 _value_ 为 *undefined*，返回 *undefined*。
              1. 返回 PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
          1. 返回 OrdinaryGetOwnProperty(_O_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-hasproperty" oldids="sec-integer-indexed-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): 返回包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，返回 IsValidIntegerIndex(_O_, _numericIndex_)。
          1. 返回 ? OrdinaryHasProperty(_O_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-defineownproperty" oldids="sec-integer-indexed-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 若 IsValidIntegerIndex(_O_, _numericIndex_) 为 *false*，返回 *false*。
              1. 若 _Desc_ 有 [[Configurable]] 且为 *false*，返回 *false*。
              1. 若 _Desc_ 有 [[Enumerable]] 且为 *false*，返回 *false*。
              1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，返回 *false*。
              1. 若 _Desc_ 有 [[Writable]] 且为 *false*，返回 *false*。
              1. 若 _Desc_ 有 [[Value]] 字段，执行 ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]])。
              1. 返回 *true*。
          1. 返回 ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-get" oldids="sec-integer-indexed-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): 返回包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 返回 TypedArrayGetElement(_O_, _numericIndex_)。
          1. 返回 ? OrdinaryGet(_O_, _P_, _Receiver_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-set" oldids="sec-integer-indexed-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): 返回包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 若 SameValue(_O_, _Receiver_) 为 *true*，则
                1. 执行 ? TypedArraySetElement(_O_, _numericIndex_, _V_)。
                1. 返回 *true*。
              1. 若 IsValidIntegerIndex(_O_, _numericIndex_) 为 *false*，返回 *true*。
          1. 返回 ? OrdinarySet(_O_, _P_, _V_, _Receiver_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-delete" oldids="sec-integer-indexed-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): 返回包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 若 IsValidIntegerIndex(_O_, _numericIndex_) 为 *false*，返回 *true*；否则返回 *false*。
          1. 返回 ! OrdinaryDelete(_O_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-ownpropertykeys" oldids="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 返回包含属性键列表的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 令 _keys_ 为新空列表。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *false*，则
            1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
            1. 对每个整数 _i_（0 ≤ _i_ < _length_，升序）：
              1. 追加 ! ToString(𝔽(_i_)) 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 String 且不是整数索引，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 Symbol，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 返回 _keys_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-with-buffer-witness-records" oldids="sec-integer-indexed-object-with-buffer-witness-records">
        <h1>带缓冲区见证记录的 TypedArray (TypedArray With Buffer Witness Records)</h1>
        <p><dfn variants="TypedArray With Buffer Witness Records">TypedArray With Buffer Witness Record</dfn> 是用于封装一个 TypedArray 及其被查看缓冲区缓存字节长度的 Record；当缓冲区为可增长 SharedArrayBuffer 时用于确保字节长度数据块的共享内存读取仅发生一次。</p>
        <p>其字段列于 <emu-xref href="#table-typedarray-with-buffer-witness-record-fields"></emu-xref>。</p>
        <emu-table id="table-typedarray-with-buffer-witness-record-fields" oldids="table-integer-indexed-object-with-buffer-witness-record-fields" caption="TypedArray With Buffer Witness Record 字段">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a TypedArray
              </td>
              <td>
                其缓冲区字节长度被加载的 TypedArray。
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                记录创建时对象 [[ViewedArrayBuffer]] 的字节长度。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-maketypedarraywithbufferwitnessrecord" oldids="sec-makeintegerindexedobjectwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeTypedArrayWithBufferWitnessRecord (
            _obj_: a TypedArray,
            _order_: ~seq-cst~ or ~unordered~,
          ): 一个 TypedArray With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _buffer_ 为 _obj_.[[ViewedArrayBuffer]]。
          1. 若 IsDetachedBuffer(_buffer_) 为 *true*，则
            1. 令 _byteLength_ 为 ~detached~。
          1. 否则，
            1. 令 _byteLength_ 为 ArrayBufferByteLength(_buffer_, _order_)。
          1. 返回 TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraycreate" oldids="sec-integerindexedobjectcreate" type="abstract operation">
        <h1>
          TypedArrayCreate (
            _prototype_: an Object,
          ): 一个 TypedArray
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的 TypedArray。</dd>
        </dl>
        <emu-alg>
          1. 令 _internalSlotsList_ 为 « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »。
          1. 令 _A_ 为 MakeBasicObject(_internalSlotsList_)。
          1. 按 <emu-xref href="#sec-typedarray-preventextensions"></emu-xref> 设置 _A_.[[PreventExtensions]]。
          1. 按 <emu-xref href="#sec-typedarray-getownproperty"></emu-xref> 设置 _A_.[[GetOwnProperty]]。
          1. 按 <emu-xref href="#sec-typedarray-hasproperty"></emu-xref> 设置 _A_.[[HasProperty]]。
          1. 按 <emu-xref href="#sec-typedarray-defineownproperty"></emu-xref> 设置 _A_.[[DefineOwnProperty]]。
          1. 按 <emu-xref href="#sec-typedarray-get"></emu-xref> 设置 _A_.[[Get]]。
          1. 按 <emu-xref href="#sec-typedarray-set"></emu-xref> 设置 _A_.[[Set]]。
          1. 按 <emu-xref href="#sec-typedarray-delete"></emu-xref> 设置 _A_.[[Delete]]。
          1. 按 <emu-xref href="#sec-typedarray-ownpropertykeys"></emu-xref> 设置 _A_.[[OwnPropertyKeys]]。
          1. 将 _A_.[[Prototype]] 设为 _prototype_。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraybytelength" oldids="sec-integerindexedobjectbytelength" type="abstract operation">
        <h1>
          TypedArrayByteLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): 一个非负整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，返回 0。
          1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _length_ = 0，返回 0。
          1. 令 _O_ 为 _taRecord_.[[Object]]。
          1. 若 _O_.[[ByteLength]] 不为 ~auto~，返回 _O_.[[ByteLength]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 返回 _length_ × _elementSize_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraylength" oldids="sec-integerindexedobjectlength" type="abstract operation">
        <h1>
          TypedArrayLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): 一个非负整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsTypedArrayOutOfBounds(_taRecord_) 为 *false*。
          1. 令 _O_ 为 _taRecord_.[[Object]]。
          1. 若 _O_.[[ArrayLength]] 不为 ~auto~，返回 _O_.[[ArrayLength]]。
          1. 断言：IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) 为 *false*。
          1. 令 _byteOffset_ 为 _O_.[[ByteOffset]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 令 _byteLength_ 为 _taRecord_.[[CachedBufferByteLength]]。
          1. 断言：_byteLength_ 不为 ~detached~。
          1. 返回 floor((_byteLength_ - _byteOffset_) / _elementSize_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayoutofbounds" oldids="sec-isintegerindexedobjectoutofbounds" type="abstract operation">
        <h1>
          IsTypedArrayOutOfBounds (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): 一个 Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>检查任一数值属性是否引用了底层缓冲区边界外的索引。</dd>
        </dl>
        <emu-alg>
          1. 令 _O_ 为 _taRecord_.[[Object]]。
          1. 令 _bufferByteLength_ 为 _taRecord_.[[CachedBufferByteLength]]。
          1. 断言：IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 为 *true* 当且仅当 _bufferByteLength_ 为 ~detached~。
          1. 若 _bufferByteLength_ 为 ~detached~，返回 *true*。
          1. 令 _byteOffsetStart_ 为 _O_.[[ByteOffset]]。
          1. 若 _O_.[[ArrayLength]] 为 ~auto~，则
            1. 令 _byteOffsetEnd_ 为 _bufferByteLength_。
          1. 否则，
            1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
            1. 令 _byteOffsetEnd_ 为 _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_。
          1. 若 _byteOffsetStart_ > _bufferByteLength_ 或 _byteOffsetEnd_ > _bufferByteLength_，返回 *true*。
          1. 注：长度为 0 的 TypedArray 不视为越界。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayfixedlength" type="abstract operation">
        <h1>
          IsTypedArrayFixedLength (
            _O_: a TypedArray,
          ): 一个 Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _O_.[[ArrayLength]] 为 ~auto~，返回 *false*。
          1. 令 _buffer_ 为 _O_.[[ViewedArrayBuffer]]。
          1. 若 IsFixedLengthArrayBuffer(_buffer_) 为 *false* 且 IsSharedArrayBuffer(_buffer_) 为 *false*，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isvalidintegerindex" type="abstract operation">
        <h1>
          IsValidIntegerIndex (
            _O_: a TypedArray,
            _index_: a Number,
          ): 一个 Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 为 *true*，返回 *false*。
          1. 若 _index_ 不是整数 Number，返回 *false*。
          1. 若 _index_ 为 *-0*<sub>𝔽</sub> 或 _index_ &lt; *-0*<sub>𝔽</sub>，返回 *false*。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~)。
          1. 注：当 _O_ 的底层缓冲是可增长 SharedArrayBuffer 时，边界检查不是同步操作。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，返回 *false*。
          1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
          1. 若 ℝ(_index_) ≥ _length_，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraygetelement" oldids="sec-integerindexedelementget" type="abstract operation">
        <h1>
          TypedArrayGetElement (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Number, a BigInt, 或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsValidIntegerIndex(_O_, _index_) 为 *false*，返回 *undefined*。
          1. 令 _offset_ 为 _O_.[[ByteOffset]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 令 _byteIndexInBuffer_ 为 (ℝ(_index_) × _elementSize_) + _offset_。
          1. 令 _elementType_ 为 TypedArrayElementType(_O_)。
          1. 返回 GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraysetelement" oldids="sec-integerindexedelementset" type="abstract operation">
        <h1>
          TypedArraySetElement (
            _O_: a TypedArray,
            _index_: a Number,
            _value_: an ECMAScript language value,
          ): 返回包含 ~unused~ 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _O_.[[ContentType]] 为 ~bigint~，令 _numValue_ 为 ? ToBigInt(_value_)；否则令 _numValue_ 为 ? ToNumber(_value_)。
          1. 若 IsValidIntegerIndex(_O_, _index_) 为 *true*，则
            1. 令 _offset_ 为 _O_.[[ByteOffset]]。
            1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
            1. 令 _byteIndexInBuffer_ 为 (ℝ(_index_) × _elementSize_) + _offset_。
            1. 令 _elementType_ 为 TypedArrayElementType(_O_)。
            1. 执行 SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-note>
          <p>此操作表面上总是成功；当写入越界或底层 ArrayBuffer 已分离时不产生效果。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation">
        <h1>
          IsArrayBufferViewOutOfBounds (
            _O_: a TypedArray or a DataView,
          ): 一个 Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>检查 TypedArray 的数值属性或 DataView 方法是否可能引用底层数据块范围之外的值；为上游规范提供便利。</dd>
        </dl>
        <emu-alg>
          1. 若 _O_ 具有 [[DataView]] 内部槽，则
            1. 令 _viewRecord_ 为 MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~)。
            1. 返回 IsViewOutOfBounds(_viewRecord_)。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 返回 IsTypedArrayOutOfBounds(_taRecord_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-module-namespace-exotic-objects">
      <h1>模块命名空间特异对象 (Module Namespace Exotic Objects)</h1>
      <p>模块命名空间特异对象是一个暴露 ECMAScript |Module| 导出绑定的特异对象（见 <emu-xref href="#sec-exports"></emu-xref>）。其字符串键自身属性与该 |Module| 导出的绑定名一一对应，包括通过 `export *` 间接导出的绑定。每个字符串键属性的键即对应导出绑定名的 StringValue。这些是其全部字符串键属性。每个此类属性特性为 { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }。模块命名空间特异对象不可扩展。</p>
      <p>若对象的 [[GetPrototypeOf]]、[[SetPrototypeOf]]、[[IsExtensible]]、[[PreventExtensions]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[HasProperty]]、[[Get]]、[[Set]]、[[Delete]]、[[OwnPropertyKeys]] 内部方法使用本节定义，且其它基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 的定义，则其为 <dfn id="module-namespace-exotic-object" variants="module namespace exotic objects">模块命名空间特异对象</dfn>。这些方法由 ModuleNamespaceCreate 安装。</p>
      <p>模块命名空间特异对象具有 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref> 定义的内部槽。</p>
      <emu-table id="table-internal-slots-of-module-namespace-exotic-objects" caption="模块命名空间特异对象的内部槽 (Internal Slots of Module Namespace Exotic Objects)" oldids="table-29">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Module]]
            </td>
            <td>
              a Module Record
            </td>
            <td>
              此命名空间暴露其导出的 Module Record。
            </td>
          </tr>
          <tr>
            <td>
              [[Exports]]
            </td>
            <td>
              a List of Strings
            </td>
            <td>
              作为该对象自身属性暴露的导出名称字符串列表，按字典序代码单元顺序排序。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-module-namespace-exotic-objects-getprototypeof" type="internal method">
        <h1>[[GetPrototypeOf]] ( ): 返回一个包含 *null* 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *null*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 返回 ! SetImmutablePrototype(_O_, _V_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-isextensible" type="internal method">
        <h1>[[IsExtensible]] ( ): 返回一个包含 *false* 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): 返回一个包含 *true* 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回一个包含 Property Descriptor 或 *undefined* 的正常完成，或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，返回 OrdinaryGetOwnProperty(_O_, _P_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 不含 _P_，返回 *undefined*。
          1. 令 _value_ 为 ? _O_.[[Get]](_P_, _O_)。
          1. 返回 PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，返回 ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)。
          1. 令 _current_ 为 ? _O_.[[GetOwnProperty]](_P_)。
          1. 若 _current_ 为 *undefined*，返回 *false*。
          1. 若 _Desc_ 有 [[Configurable]] 且为 *true*，返回 *false*。
          1. 若 _Desc_ 有 [[Enumerable]] 且为 *false*，返回 *false*。
          1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，返回 *false*。
          1. 若 _Desc_ 有 [[Writable]] 且为 *false*，返回 *false*。
          1. 若 _Desc_ 有 [[Value]] 字段，返回 SameValue(_Desc_.[[Value]], _current_.[[Value]])。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，返回 ! OrdinaryHasProperty(_O_, _P_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 含 _P_，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，则
            1. 返回 ! OrdinaryGet(_O_, _P_, _Receiver_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 不含 _P_，返回 *undefined*。
          1. 令 _m_ 为 _O_.[[Module]]。
          1. 令 _binding_ 为 _m_.ResolveExport(_P_)。
          1. 断言：_binding_ 是 ResolvedBinding Record。
          1. 令 _targetModule_ 为 _binding_.[[Module]]。
          1. 断言：_targetModule_ 不为 *undefined*。
          1. 若 _binding_.[[BindingName]] 为 ~namespace~，则
            1. 返回 GetModuleNamespace(_targetModule_)。
          1. 令 _targetEnv_ 为 _targetModule_.[[Environment]]。
          1. 若 _targetEnv_ 为 ~empty~，抛出 *ReferenceError* 异常。
          1. 返回 ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*)。
        </emu-alg>
        <emu-note>
          <p>ResolveExport 无副作用；对相同参数组合多次调用结果必须一致。实现可预先计算或缓存每个命名空间对象 [[Exports]] 的 ResolveExport 结果。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 *false* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，则
            1. 返回 ! OrdinaryDelete(_O_, _P_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 含 _P_，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 返回一个包含属性键列表的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 令 _symbolKeys_ 为 OrdinaryOwnPropertyKeys(_O_)。
          1. 返回 _exports_ 与 _symbolKeys_ 的列表连接结果。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulenamespacecreate" type="abstract operation">
        <h1>
          ModuleNamespaceCreate (
            _module_: a Module Record,
            _exports_: a List of Strings,
          ): 一个模块命名空间特异对象
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的模块命名空间特异对象。</dd>
        </dl>
        <emu-alg>
          1. 断言：_module_.[[Namespace]] 为 ~empty~。
          1. 令 _internalSlotsList_ 为 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref> 中列出的内部槽列表。
          1. 令 _M_ 为 MakeBasicObject(_internalSlotsList_)。
          1. 将 _M_ 的基本内部方法设为 <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> 中的定义。
          1. 将 _M_.[[Module]] 设为 _module_。
          1. 令 _sortedExports_ 为对 _exports_ 元素按字典序代码单元排序后的列表。
          1. 将 _M_.[[Exports]] 设为 _sortedExports_。
          1. 创建 _M_ 的自身属性以对应 <emu-xref href="#sec-module-namespace-objects"></emu-xref> 中的定义。
          1. 将 _module_.[[Namespace]] 设为 _M_。
          1. 返回 _M_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-immutable-prototype-exotic-objects">
      <h1>不可变原型特异对象 (Immutable Prototype Exotic Objects)</h1>
      <p>不可变原型特异对象是其 [[Prototype]] 内部槽一旦初始化即不再改变的特异对象。</p>

      <p>若对象的 [[SetPrototypeOf]] 内部方法使用以下实现（其它基本内部方法可视具体对象采用任意实现），则该对象是 <dfn id="immutable-prototype-exotic-object" variants="immutable prototype exotic objects">不可变原型特异对象</dfn>。</p>

      <emu-note>
        <p>与其它特异对象不同，不可变原型特异对象没有专门的创建抽象操作；因它们仅用于 %Object.prototype% 与宿主环境，宿主环境中相关对象可能在其它方面也是特异的，需单独的创建过程。</p>
      </emu-note>

      <emu-clause id="sec-immutable-prototype-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>不可变原型特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 返回 ? SetImmutablePrototype(_O_, _V_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set-immutable-prototype" type="abstract operation">
        <h1>
          SetImmutablePrototype (
            _O_: an Object,
            _V_: an Object or *null*,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _current_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
          1. 若 SameValue(_V_, _current_) 为 *true*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
    <h1>Proxy 对象的内部方法与内部槽 (Proxy Object Internal Methods and Internal Slots)</h1>
    <p>Proxy 对象是一种特异对象，其关键内部方法部分由 ECMAScript 代码实现。每个 Proxy 对象都有名为 [[ProxyHandler]] 的内部槽。[[ProxyHandler]] 的值要么是一个对象（称为该 proxy 的 <em>handler 对象</em>），要么是 *null*。handler 对象的方法（见 <emu-xref href="#table-proxy-handler-methods"></emu-xref>）可用于增强一个或多个 Proxy 内部方法的实现。每个 Proxy 对象还具有名为 [[ProxyTarget]] 的内部槽，其值是一个对象或 *null*。该对象称为 proxy 的 <em>target 对象</em>。</p>

    <p>若一个对象的关键内部方法（若适用包括 [[Call]] 与 [[Construct]]）使用本节的定义，则该对象为 <dfn id="proxy-exotic-object" variants="Proxy exotic objects">Proxy 特异对象</dfn>。这些内部方法在 ProxyCreate 中安装。</p>

    <emu-table id="table-proxy-handler-methods" caption="Proxy 处理器方法 (Proxy Handler Methods)" oldids="table-30">
      <table>
        <thead>
          <tr>
            <th>
              内部方法 (Internal Method)
            </th>
            <th>
              处理器方法 (Handler Method)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[GetPrototypeOf]]
          </td>
          <td>
            `getPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[SetPrototypeOf]]
          </td>
          <td>
            `setPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[IsExtensible]]
          </td>
          <td>
            `isExtensible`
          </td>
        </tr>
        <tr>
          <td>
            [[PreventExtensions]]
          </td>
          <td>
            `preventExtensions`
          </td>
        </tr>
        <tr>
          <td>
            [[GetOwnProperty]]
          </td>
          <td>
            `getOwnPropertyDescriptor`
          </td>
        </tr>
        <tr>
          <td>
            [[DefineOwnProperty]]
          </td>
          <td>
            `defineProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[HasProperty]]
          </td>
          <td>
            `has`
          </td>
        </tr>
        <tr>
          <td>
            [[Get]]
          </td>
          <td>
            `get`
          </td>
        </tr>
        <tr>
          <td>
            [[Set]]
          </td>
          <td>
            `set`
          </td>
        </tr>
        <tr>
          <td>
            [[Delete]]
          </td>
          <td>
            `deleteProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[OwnPropertyKeys]]
          </td>
          <td>
            `ownKeys`
          </td>
        </tr>
        <tr>
          <td>
            [[Call]]
          </td>
          <td>
            `apply`
          </td>
        </tr>
        <tr>
          <td>
            [[Construct]]
          </td>
          <td>
            `construct`
          </td>
        </tr>
      </table>
    </emu-table>
    <p>当调用某个 handler 方法以提供 Proxy 内部方法的实现时，会将该 proxy 的 target 对象作为参数传入。handler 对象不一定具备每个关键内部方法对应的 trap；如果缺少对应 trap，则在 proxy 上调用该内部方法会转发到 target 对象上的对应内部方法。</p>
    <p>Proxy 对象的 [[ProxyHandler]] 与 [[ProxyTarget]] 内部槽在创建时总被初始化，通常不可再修改。某些 Proxy 被创建为可随后被 <em>撤销（revoked）</em>。当一个 proxy 被撤销时，其 [[ProxyHandler]] 与 [[ProxyTarget]] 被设为 *null*，使得后续对该 Proxy 的内部方法调用抛出 *TypeError* 异常。</p>
    <p>由于 Proxy 允许内部方法实现由任意 ECMAScript 代码提供，可能定义出其 handler 方法违反 <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 中不变式的 Proxy。该处定义的一些内部方法不变式是关键完整性不变式；本节给出的 Proxy 内部方法会显式强制这些不变式。ECMAScript 实现必须在所有可能的不变式违例情况下保持健壮。</p>
    <p>以下算法中，假设 _O_ 为一个 ECMAScript Proxy 对象，_P_ 为属性键值，_V_ 为任意 ECMAScript 语言值，_Desc_ 为一个 Property Descriptor 记录。</p>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): 返回一个包含 Object 或 *null* 的正常完成，或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"getPrototypeOf"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>()。
        1. 令 _handlerProto_ 为 ? Call(_trap_, _handler_, « _target_ »)。
        1. 若 _handlerProto_ 既不是 Object 且也不是 *null*，抛出 *TypeError* 异常。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _extensibleTarget_ 为 *true*，返回 _handlerProto_。
        1. 令 _targetProto_ 为 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>()。
        1. 若 SameValue(_handlerProto_, _targetProto_) 为 *false*，抛出 *TypeError* 异常。
        1. 返回 _handlerProto_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[GetPrototypeOf]] 强制以下不变式：</p>
        <ul>
          <li>
            结果必须是 Object 或 *null*。
          </li>
          <li>
            若 target 不可扩展，对 Proxy 调用 [[GetPrototypeOf]] 的结果须与对其 target 调用的结果相同。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"setPrototypeOf"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_V_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _extensibleTarget_ 为 *true*，返回 *true*。
        1. 令 _targetProto_ 为 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>()。
        1. 若 SameValue(_V_, _targetProto_) 为 *false*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[SetPrototypeOf]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是一个 Boolean。
          </li>
          <li>
            若 target 不可扩展，参数值必须与对 target 调用 [[GetPrototypeOf]] 的结果相同。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): 返回一个包含 Boolean 的正常完成或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"isExtensible"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? IsExtensible(_target_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_ »))。
        1. 令 _targetResult_ 为 ? IsExtensible(_target_)。
        1. 若 _booleanTrapResult_ 不等于 _targetResult_，抛出 *TypeError* 异常。
        1. 返回 _booleanTrapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[IsExtensible]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是 Boolean。
          </li>
          <li>
            对 Proxy 的调用结果必须与对其 target 的调用结果一致。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): 返回一个包含 Boolean 的正常完成或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"preventExtensions"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta>。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_ »))。
        1. 若 _booleanTrapResult_ 为 *true*，则
          1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
          1. 若 _extensibleTarget_ 为 *true*，抛出 *TypeError* 异常。
        1. 返回 _booleanTrapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[PreventExtensions]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是 Boolean。
          </li>
          <li>
            仅当 target 的 [[IsExtensible]] 为 *false* 时才可返回 *true*。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): 返回一个包含 Property Descriptor 或 *undefined* 的正常完成，或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"getOwnPropertyDescriptor"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 令 _trapResultObj_ 为 ? Call(_trap_, _handler_, « _target_, _P_ »)。
        1. 若 _trapResultObj_ 不是 Object 且也不是 *undefined*，抛出 *TypeError* 异常。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _trapResultObj_ 为 *undefined*，则
          1. 若 _targetDesc_ 为 *undefined*，返回 *undefined*。
          1. 若 _targetDesc_.[[Configurable]] 为 *false*，抛出 *TypeError* 异常。
          1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
          1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
          1. 返回 *undefined*。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 令 _resultDesc_ 为 ? ToPropertyDescriptor(_trapResultObj_)。
        1. 执行 CompletePropertyDescriptor(_resultDesc_)。
        1. 令 _valid_ 为 IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_)。
        1. 若 _valid_ 为 *false*，抛出 *TypeError* 异常。
        1. 若 _resultDesc_.[[Configurable]] 为 *false*，则
          1. 若 _targetDesc_ 为 *undefined* 或 _targetDesc_.[[Configurable]] 为 *true*，则
            1. 抛出 *TypeError* 异常。
          1. 若 _resultDesc_ 含 [[Writable]] 且 _resultDesc_.[[Writable]] 为 *false*，则
            1. 断言：_targetDesc_ 含 [[Writable]]。
            1. 若 _targetDesc_.[[Writable]] 为 *true*，抛出 *TypeError* 异常。
        1. 返回 _resultDesc_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[GetOwnProperty]] 强制以下不变式：</p>
        <ul>
          <li>
            结果必须是 Object 或 *undefined*。
          </li>
          <li>
            若 target 上存在一个不可配置自身属性，不得报告其不存在。
          </li>
          <li>
            若 target 不可扩展且存在该自身属性，不得报告其不存在。
          </li>
          <li>
            若 target 不可扩展且不存在该自身属性，不得报告其存在。
          </li>
          <li>
            不得报告某属性为不可配置，除非它在 target 上为不可配置自身属性。
          </li>
          <li>
            不得同时报告某属性为不可配置且不可写，除非它在 target 上为不可配置且不可写自身属性。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"defineProperty"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_)。
        1. 令 _descObj_ 为 FromPropertyDescriptor(_Desc_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _Desc_ 含 [[Configurable]] 且 _Desc_.[[Configurable]] 为 *false*，则
          1. 令 _settingConfigFalse_ 为 *true*。
        1. 否则，
          1. 令 _settingConfigFalse_ 为 *false*。
        1. 若 _targetDesc_ 为 *undefined*，则
          1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
          1. 若 _settingConfigFalse_ 为 *true*，抛出 *TypeError* 异常。
        1. 否则，
          1. 若 IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _settingConfigFalse_ 为 *true* 且 _targetDesc_.[[Configurable]] 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsDataDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Configurable]] 为 *false* 且 _targetDesc_.[[Writable]] 为 *true*，则
            1. 若 _Desc_ 含 [[Writable]] 且 _Desc_.[[Writable]] 为 *false*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[DefineOwnProperty]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若 target 不可扩展，不得添加新属性。
          </li>
          <li>
            不得创建不可配置属性，除非 target 上已有对应不可配置自身属性。
          </li>
          <li>
            不得创建既不可配置又不可写属性，除非 target 上已有对应不可配置且不可写自身属性。
          </li>
          <li>
            若属性在 target 上已有对应属性，则用给定描述符通过 [[DefineOwnProperty]] 作用于 target 不会抛出异常。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"has"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_P_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，则
          1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _targetDesc_ 不为 *undefined*，则
            1. 若 _targetDesc_.[[Configurable]] 为 *false*，抛出 *TypeError* 异常。
            1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
            1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
        1. 返回 _booleanTrapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[HasProperty]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若 target 上存在不可配置自身属性，不得报告其不存在。
          </li>
          <li>
            若 target 不可扩展且存在该自身属性，不得报告其不存在。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"get"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_P_, _Receiver_)。
        1. 令 _trapResult_ 为 ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »)。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _targetDesc_ 不为 *undefined* 且 _targetDesc_.[[Configurable]] 为 *false*，则
          1. 若 IsDataDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Writable]] 为 *false*，则
            1. 若 SameValue(_trapResult_, _targetDesc_.[[Value]]) 为 *false*，抛出 *TypeError* 异常。
          1. 若 IsAccessorDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Get]] 为 *undefined*，则
            1. 若 _trapResult_ 不为 *undefined*，抛出 *TypeError* 异常。
        1. 返回 _trapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[Get]] 强制以下不变式：</p>
        <ul>
          <li>
            若 target 上对应属性为不可写、不可配置的自身数据属性，则读取结果必须与其值相同。
          </li>
          <li>
            若 target 上对应属性为不可配置自身访问器属性且其 [[Get]] 为 *undefined*，则读取结果必须为 *undefined*。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"set"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _targetDesc_ 不为 *undefined* 且 _targetDesc_.[[Configurable]] 为 *false*，则
          1. 若 IsDataDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Writable]] 为 *false*，则
            1. 若 SameValue(_V_, _targetDesc_.[[Value]]) 为 *false*，抛出 *TypeError* 异常。
          1. 若 IsAccessorDescriptor(_targetDesc_) 为 *true*，则
            1. 若 _targetDesc_.[[Set]] 为 *undefined*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[Set]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若 target 上对应属性为不可写且不可配置的数据属性，不得改为不同的值。
          </li>
          <li>
            若 target 上对应属性为不可配置自身访问器属性且其 [[Set]] 为 *undefined*，不得设置该属性值。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"deleteProperty"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_P_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _targetDesc_ 为 *undefined*，返回 *true*。
        1. 若 _targetDesc_.[[Configurable]] 为 *false*，抛出 *TypeError* 异常。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[Delete]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若属性在 target 上是不可配置自身属性，不得报告其已删除。
          </li>
          <li>
            若属性在 target 上是自身属性且 target 不可扩展，不得报告其已删除。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 返回一个包含属性键列表的正常完成或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"ownKeys"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>。
        1. 令 _trapResultArray_ 为 ? Call(_trap_, _handler_, « _target_ »)。
        1. 令 _trapResult_ 为 ? CreateListFromArrayLike(_trapResultArray_, ~property-key~)。
        1. 若 _trapResult_ 含任何重复项，抛出 *TypeError* 异常。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 令 _targetKeys_ 为 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>。
        1. 断言：_targetKeys_ 是属性键列表。
        1. 断言：_targetKeys_ 不含重复项。
        1. 令 _targetConfigurableKeys_ 为新空列表。
        1. 令 _targetNonconfigurableKeys_ 为新空列表。
        1. 对 _targetKeys_ 中每个元素 _key_：
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_)。
          1. 若 _desc_ 不为 *undefined* 且 _desc_.[[Configurable]] 为 *false*，则
            1. 将 _key_ 追加至 _targetNonconfigurableKeys_。
          1. 否则，
            1. 将 _key_ 追加至 _targetConfigurableKeys_。
        1. 若 _extensibleTarget_ 为 *true* 且 _targetNonconfigurableKeys_ 为空，则
          1. 返回 _trapResult_。
        1. 令 _uncheckedResultKeys_ 为包含 _trapResult_ 各元素的新列表。
        1. 对 _targetNonconfigurableKeys_ 中每个 _key_：
          1. 若 _uncheckedResultKeys_ 不含 _key_，抛出 *TypeError* 异常。
          1. 从 _uncheckedResultKeys_ 移除 _key_。
        1. 若 _extensibleTarget_ 为 *true*，返回 _trapResult_。
        1. 对 _targetConfigurableKeys_ 中每个 _key_：
          1. 若 _uncheckedResultKeys_ 不含 _key_，抛出 *TypeError* 异常。
          1. 从 _uncheckedResultKeys_ 移除 _key_。
        1. 若 _uncheckedResultKeys_ 非空，抛出 *TypeError* 异常。
        1. 返回 _trapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[OwnPropertyKeys]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是一个列表。
          </li>
          <li>
            返回列表不含重复项。
          </li>
          <li>
            列表中每个元素都是属性键。
          </li>
          <li>
            列表必须包含 target 所有不可配置自身属性的键。
          </li>
          <li>
            若 target 不可扩展，则列表必须精确包含其全部自身属性键且不含其他值。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"apply"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? Call(_target_, _thisArgument_, _argumentsList_)。
        1. 令 _argArray_ 为 CreateArrayFromList(_argumentsList_)。
        1. 返回 ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ »)。
      </emu-alg>
      <emu-note>
        <p>仅当 [[ProxyTarget]] 初始值是一个具有 [[Call]] 内部方法的对象时，Proxy 特异对象才具有 [[Call]]。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 返回一个包含 Object 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 断言：IsConstructor(_target_) 为 *true*。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"construct"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? Construct(_target_, _argumentsList_, _newTarget_)。
        1. 令 _argArray_ 为 CreateArrayFromList(_argumentsList_)。
        1. 令 _newObj_ 为 ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ »)。
        1. 若 _newObj_ 不是 Object，抛出 *TypeError* 异常。
        1. 返回 _newObj_。
      </emu-alg>
      <emu-note>
        <p>仅当 [[ProxyTarget]] 初始值是一个具有 [[Construct]] 内部方法的对象时，Proxy 特异对象才具有 [[Construct]]。</p>
      </emu-note>
      <emu-note>
        <p>Proxy 的 [[Construct]] 强制以下不变式：</p>
        <ul>
          <li>
            结果必须是一个 Object。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-validatenonrevokedproxy" type="abstract operation">
      <h1>
        ValidateNonRevokedProxy (
          _proxy_: a Proxy exotic object,
        ): 返回一个包含 ~unused~ 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>若 _proxy_ 已被撤销则抛出 *TypeError* 异常。</dd>
      </dl>
      <emu-alg>
        1. 若 _proxy_.[[ProxyTarget]] 为 *null*，抛出 *TypeError* 异常。
        1. 断言：_proxy_.[[ProxyHandler]] 不为 *null*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-proxycreate" type="abstract operation">
      <h1>
        ProxyCreate (
          _target_: an ECMAScript language value,
          _handler_: an ECMAScript language value,
        ): 返回一个包含 Proxy 特异对象的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于指定创建新的 Proxy 对象。</dd>
      </dl>
      <emu-alg>
        1. 若 _target_ 不是 Object，抛出 *TypeError* 异常。
        1. 若 _handler_ 不是 Object，抛出 *TypeError* 异常。
        1. 令 _P_ 为 MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »)。
        1. 设置 _P_ 的关键内部方法（除 [[Call]] 与 [[Construct]]）为 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots"></emu-xref> 中的定义。
        1. 若 IsCallable(_target_) 为 *true*，则
          1. 按 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist"></emu-xref> 设置 _P_.[[Call]]。
          1. 若 IsConstructor(_target_) 为 *true*，则
            1. 按 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget"></emu-xref> 设置 _P_.[[Construct]]。
        1. 将 _P_.[[ProxyTarget]] 设为 _target_。
        1. 将 _P_.[[ProxyHandler]] 设为 _handler_。
        1. 返回 _P_。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-source-code">
  <h1>ECMAScript 语言：源码文本 (ECMAScript Language: Source Text)</h1>

  <emu-clause id="sec-source-text">
    <h1>源码文本 (Source Text)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      SourceCharacter ::
        &gt; 任意 Unicode 码点 (any Unicode code point)
    </emu-grammar>
    <p><dfn>ECMAScript 源码文本 (ECMAScript source text)</dfn> 是一串 Unicode 码点。所有从 U+0000 到 U+10FFFF 的 Unicode 码点值（包括代理项码点 surrogate code points）在 ECMAScript 语法允许的地方都可以出现在 ECMAScript 源码文本中。用于存储与交换 ECMAScript 源码文本的实际编码方式与本规范无关。无论外部源码的字符编码为何，符合规范的 ECMAScript 实现都按其等价的 |SourceCharacter| 序列来处理源码文本，每个 |SourceCharacter| 即一个 Unicode 码点。符合规范的实现不需要对源码文本进行任何规范化，也不需要表现得仿佛进行了规范化。</p>
    <p>组合字符序列 (combining character sequence) 的各组成部分被分别当作单独的 Unicode 码点对待，即便用户可能把整个序列视为一个字符。</p>
    <emu-note>
      <p>在字符串字面量、正则表达式字面量、模板字面量与标识符中，任意 Unicode 码点也可以通过显式表示其数值的 Unicode 转义序列来书写。在注释中，这样的转义序列被视为注释的一部分而等效忽略。</p>
      <p>在 Unicode 转义序列的行为上，ECMAScript 与 Java 编程语言不同。在 Java 程序中，如果 Unicode 转义序列 `\\u000A`（例如）出现在单行注释内，它会被解释为行终止符（U+000A 是 LINE FEED (LF)），因此下一个码点不再属于该注释。同样地，如果 `\\u000A` 出现在 Java 的字符串字面量中，它也被视为行终止符；行终止符不允许出现在字符串字面量内部——必须写作 `\\n` 而不是 `\\u000A` 才能使 LF 成为字符串值的一部分。在 ECMAScript 程序中，注释里的 Unicode 转义序列从不被解释，因此不会导致注释终止。类似地，ECMAScript 程序中字符串字面量里的 Unicode 转义序列始终贡献其字面意义，绝不会被解释成行终止符或可能终止字符串字面量的码点。</p>
    </emu-note>

    <emu-clause id="sec-utf16encodecodepoint" type="abstract operation" oldids="sec-utf16encoding,sec-codepointtoutf16codeunits">
      <h1>
        静态语义：UTF16EncodeCodePoint (
          _cp_: a Unicode code point,
        ): a String
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：0 ≤ _cp_ ≤ 0x10FFFF。
        1. 若 _cp_ ≤ 0xFFFF，返回由数值为 _cp_ 的代码单元组成的 String 值。
        1. 令 _cu1_ 为数值为 floor((_cp_ - 0x10000) / 0x400) + 0xD800 的代码单元。
        1. 令 _cu2_ 为数值为 ((_cp_ - 0x10000) modulo 0x400) + 0xDC00 的代码单元。
        1. 返回 _cu1_ 与 _cu2_ 的字符串连接。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointstostring" type="abstract operation" oldids="sec-utf16encode">
      <h1>
        静态语义：CodePointsToString (
          _text_: a sequence of Unicode code points,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _text_ 按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 所述转换为一个 String 值。</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为空字符串。
        1. 对 _text_ 的每个码点 _cp_，执行
          1. 将 _result_ 设为 _result_ 与 UTF16EncodeCodePoint(_cp_) 的字符串连接。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-utf16decodesurrogatepair" type="abstract operation" oldids="sec-utf16decode,utf16decodesurrogatepair">
      <h1>
        静态语义：UTF16SurrogatePairToCodePoint (
          _lead_: a code unit,
          _trail_: a code unit,
        ): a code point
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将组成 UTF-16 代理项对的两个代码单元转换为一个码点。</dd>
      </dl>
      <emu-alg>
        1. 断言：_lead_ 是前导代理项 (leading surrogate) 且 _trail_ 是尾随代理项 (trailing surrogate)。
        1. 令 _cp_ 为 (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000。
        1. 返回码点 _cp_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointat" type="abstract operation">
      <h1>
        静态语义：CodePointAt (
          _string_: a String,
          _position_: a non-negative integer,
        ): a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 所述将 _string_ 解释为 UTF-16 编码的码点序列，并从索引 _position_ 的代码单元开始读取单个码点。</dd>
      </dl>
      <emu-alg>
        1. 令 _size_ 为 _string_ 的长度。
        1. 断言：_position_ ≥ 0 且 _position_ &lt; _size_。
        1. 令 _first_ 为 _string_ 中索引 _position_ 的代码单元。
        1. 令 _cp_ 为数值等于 _first_ 数值的码点。
        1. 若 _first_ 既不是前导代理项也不是尾随代理项，则
          1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }。
        1. 若 _first_ 是尾随代理项或 _position_ + 1 = _size_，则
          1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }。
        1. 令 _second_ 为 _string_ 中索引 _position_ + 1 的代码单元。
        1. 若 _second_ 不是尾随代理项，则
          1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }。
        1. 将 _cp_ 设为 UTF16SurrogatePairToCodePoint(_first_, _second_)。
        1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-stringtocodepoints" type="abstract operation" oldids="sec-utf16decodestring">
      <h1>
        静态语义：StringToCodePoints (
          _string_: a String,
        ): a List of code points
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回将 _string_ 按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 作为 UTF-16 编码 Unicode 文本解释后得到的 Unicode 码点序列。</dd>
      </dl>
      <emu-alg>
        1. 令 _codePoints_ 为一个新的空 List。
        1. 令 _size_ 为 _string_ 的长度。
        1. 令 _position_ 为 0。
        1. 当 _position_ &lt; _size_ 循环：
          1. 令 _cp_ 为 CodePointAt(_string_, _position_)。
          1. 将 _cp_.[[CodePoint]] 追加到 _codePoints_。
          1. 将 _position_ 设为 _position_ + _cp_.[[CodeUnitCount]]。
        1. 返回 _codePoints_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parsetext" type="abstract operation">
      <h1>
        静态语义：ParseText (
          _sourceText_: a String or a sequence of Unicode code points,
          _goalSymbol_: a nonterminal in one of the ECMAScript grammars,
        ): a Parse Node or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _sourceText_ 是 String，则将 _sourceText_ 设为 StringToCodePoints(_sourceText_)。
        1. 试图以 _goalSymbol_ 为目标符号解析 _sourceText_，并分析解析结果中的任何提前错误 (early error) 条件。解析与提前错误检测可按实现自定义方式交错进行。
        1. 若解析成功且未发现提前错误，返回解析生成的 parse tree 根部的 Parse Node（_goalSymbol_ 的一个实例）。
        1. 否则，返回一个包含一个或多个 *SyntaxError* 对象的 List，表示语法错误和/或提前错误。若存在多个错误，其数量与顺序由实现定义，但至少要有一个。
      </emu-alg>
      <emu-note>
        <p>考虑某段文本在某处有一个提前错误，在其后又有语法错误。一个先解析后检测提前错误的实现可能只报告语法错误而未继续提前错误阶段。一个交错实现可能报告提前错误而不再寻找语法错误。第三种实现可能两者都报告。以上行为都符合规范。</p>
      </emu-note>
      <emu-note>
        <p>另见 <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 条款。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-types-of-source-code">
    <h1>源码类型 (Types of Source Code)</h1>
    <p>ECMAScript 代码有四种类型：</p>
    <ul>
      <li>
        <dfn>全局代码 (Global code)</dfn> 是作为 ECMAScript |Script| 处理的源码文本。某个 |Script| 的全局代码不包含被解析为 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction|、|AsyncArrowFunction|、|ClassDeclaration| 或 |ClassExpression| 的任何源码。
      </li>
      <li>
        <dfn>Eval 代码 (Eval code)</dfn> 是传给内置 `eval` 函数的源码文本。更精确地说，如果传给内置 `eval` 的参数是 String，则其被视作 ECMAScript |Script|。一次特定 `eval` 调用的 eval 代码即该 |Script| 的全局代码部分。
      </li>
      <li>
        <p><dfn>函数代码 (Function code)</dfn> 是被解析以提供 ECMAScript 函数对象 [[ECMAScriptCode]] 与 [[FormalParameters]] 内部槽（见 <emu-xref href="#sec-ecmascript-function-objects"></emu-xref>）值的源码。某个函数的函数代码不包含被解析为内嵌 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction|、|AsyncArrowFunction|、|ClassDeclaration| 或 |ClassExpression| 的源码。</p>
        <p>此外，如果上述引用的源码被解析为：</p>
        <ul>
          <li>|FunctionDeclaration| 或 |FunctionExpression| 的 |FormalParameters| 与 |FunctionBody|，</li>
          <li>|GeneratorDeclaration| 或 |GeneratorExpression| 的 |FormalParameters| 与 |GeneratorBody|，</li>
          <li>|AsyncFunctionDeclaration| 或 |AsyncFunctionExpression| 的 |FormalParameters| 与 |AsyncFunctionBody|，或</li>
          <li>|AsyncGeneratorDeclaration| 或 |AsyncGeneratorExpression| 的 |FormalParameters| 与 |AsyncGeneratorBody|，</li>
        </ul>
        <p>则该声明或表达式的 |BindingIdentifier|（若存在）所匹配的源码文本也包含在对应函数的函数代码中。</p>
      </li>
      <li>
        <dfn>模块代码 (Module code)</dfn> 是作为 |ModuleBody| 提供的源码文本。它是在模块初始化时被直接求值的代码。某个模块的模块代码不包含被解析为内嵌 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction|、|AsyncArrowFunction|、|ClassDeclaration| 或 |ClassExpression| 的源码。
      </li>
    </ul>
    <emu-note>
      <p>函数代码通常以函数定义 (<emu-xref href="#sec-function-definitions"></emu-xref>)、箭头函数定义 (<emu-xref href="#sec-arrow-function-definitions"></emu-xref>)、方法定义 (<emu-xref href="#sec-method-definitions"></emu-xref>)、生成器函数定义 (<emu-xref href="#sec-generator-function-definitions"></emu-xref>)、异步函数定义 (<emu-xref href="#sec-async-function-definitions"></emu-xref>)、异步生成器函数定义 (<emu-xref href="#sec-async-generator-function-definitions"></emu-xref>) 以及异步箭头函数 (<emu-xref href="#sec-async-arrow-function-definitions"></emu-xref>) 的函数体形式提供。函数代码还来自 Function 构造器 (<emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>)、GeneratorFunction 构造器 (<emu-xref href="#sec-generatorfunction"></emu-xref>)、AsyncFunction 构造器 (<emu-xref href="#sec-async-function-constructor-arguments"></emu-xref>) 与 AsyncGeneratorFunction 构造器 (<emu-xref href="#sec-asyncgeneratorfunction"></emu-xref>) 的参数。</p>
    </emu-note>
    <emu-note>
      <p>将 |BindingIdentifier| 包含在函数代码中的实际作用是：即便外围代码不是严格模式，只要函数体内含有 "use strict" 指令，该函数名的 |BindingIdentifier| 也会应用严格模式早期错误规则。</p>
    </emu-note>

    <emu-clause id="sec-directive-prologues-and-the-use-strict-directive">
      <h1>指令序言与 Use Strict 指令 (Directive Prologues and the Use Strict Directive)</h1>
      <p><dfn id="directive-prologue" variants="Directive Prologues">指令序言 (Directive Prologue)</dfn> 是出现在 |FunctionBody|、|ScriptBody| 或 |ModuleBody| 起始位置处、作为初始 |StatementListItem| 或 |ModuleItem| 的最长 |ExpressionStatement| 序列，并且序列中每个 |ExpressionStatement| 完全由一个 |StringLiteral| 标记及其后紧随的分号组成。该分号可以显式出现，也可由自动分号插入 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) 插入。指令序言可以是空序列。</p>
      <p><dfn id="use-strict-directive" variants="Use Strict Directives">Use Strict 指令 (Use Strict Directive)</dfn> 是指令序言中的一个 |ExpressionStatement|，其 |StringLiteral| 精确为代码点序列 `"use strict"` 或 `'use strict'`。Use Strict 指令不允许包含 |EscapeSequence| 或 |LineContinuation|。</p>
      <p>指令序言可包含多个 Use Strict 指令；实现可以在发生这种情况时发出警告。</p>
      <emu-note>
        <p>指令序言中的 |ExpressionStatement| 在包含它的产生式求值时会被正常求值。实现可以为指令序言中出现、且不是 Use Strict 指令的 |ExpressionStatement| 定义实现特定的含义。如果存在合适的通知机制，实现若在指令序言中遇到既不是 Use Strict 指令又没有实现定义语义的 |ExpressionStatement|，应发出警告。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-strict-mode-code">
      <h1>严格模式代码 (Strict Mode Code)</h1>
      <p>一个 ECMAScript 语法单元可以用不受限模式或严格模式语法与语义处理 (<emu-xref href="#sec-strict-variant-of-ecmascript"></emu-xref>)。以下情况中代码被解释为 <dfn>严格模式代码 (strict mode code)</dfn>：</p>
      <ul>
        <li>
          若全局代码以包含 Use Strict 指令的指令序言开始，则该全局代码为严格模式代码。
        </li>
        <li>
          模块代码始终是严格模式代码。
        </li>
        <li>
          |ClassDeclaration| 或 |ClassExpression| 的所有部分都是严格模式代码。
        </li>
        <li>
          若 eval 代码以包含 Use Strict 指令的指令序言开始，或对 `eval` 的直接调用位于严格模式代码中，则该 eval 代码为严格模式代码。
        </li>
        <li>
          若关联的 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction| 或 |AsyncArrowFunction| 处于严格模式代码中，或其 [[ECMAScriptCode]] 内部槽值所来源的代码以包含 Use Strict 指令的指令序言开始，则函数代码为严格模式代码。
        </li>
        <li>
          若作为内置 Function、Generator、AsyncFunction、AsyncGenerator 构造器的参数提供的函数代码的最后一个参数是 String，且其作为 |FunctionBody| 处理后以包含 Use Strict 指令的指令序言开始，则该函数代码为严格模式代码。
        </li>
      </ul>
      <p>不是严格模式代码的 ECMAScript 代码称为 <dfn id="non-strict-code">非严格代码 (non-strict code)</dfn>。</p>

      <emu-clause id="sec-isstrict" type="abstract operation">
        <h1>
          静态语义：IsStrict (
            _node_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _node_ 匹配的源码文本是严格模式代码，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-non-ecmascript-functions">
      <h1>非 ECMAScript 函数 (Non-ECMAScript Functions)</h1>
      <p>ECMAScript 实现可以支持求值其执行行为以宿主自定义的非 ECMAScript 可执行代码形式表达的函数特异对象。一个函数对象是否在 ECMAScript 代码中定义或是否是内置函数，对调用或被其调用的 ECMAScript 代码而言不可观察。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-lexical-grammar">
  <h1>ECMAScript 语言：词法语法 (ECMAScript Language: Lexical Grammar)</h1>
  <p>ECMAScript |Script| 或 |Module| 的源码文本首先被转换为输入元素序列，这些输入元素包括记号 (token)、行终止符、注释或空白。源码从左到右扫描，反复取能形成下一个输入元素的最长可能码点序列。</p>
  <p>在若干情形下，词法输入元素的识别会对消费这些输入元素的句法语法上下文敏感，因此词法语法需要多个目标符号。|InputElementHashbangOrRegExp| 目标用于 |Script| 或 |Module| 的开始处。|InputElementRegExpOrTemplateTail| 目标用于允许出现 |RegularExpressionLiteral|、|TemplateMiddle| 或 |TemplateTail| 的句法语境。|InputElementRegExp| 目标符号用于所有允许 |RegularExpressionLiteral| 但不允许 |TemplateMiddle| 或 |TemplateTail| 的句法语境。|InputElementTemplateTail| 目标用于所有允许 |TemplateMiddle| 或 |TemplateTail| 但不允许 |RegularExpressionLiteral| 的句法语境。所有其它语境中，使用 |InputElementDiv| 作为词法目标符号。</p>
  <emu-note>
    <p>使用多个词法目标可确保不存在会影响自动分号插入的词法二义性。例如，没有任何句法语境同时允许以除法或除法赋值开头以及以 |RegularExpressionLiteral| 开头。这一点不受分号插入影响（见 <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）；在如下示例中：</p>
    <pre><code class="javascript">
      a = b
      /hi/g.exec(c).map(d);
    </code></pre>
    <p>当一个 |LineTerminator| 之后第一个非空白、非注释码点为 U+002F (SOLIDUS)，且句法上下文允许除法或除法赋值时，不会在该 |LineTerminator| 处插入分号。也就是说，上例被解释为与下列代码相同：</p>
    <pre><code class="javascript">
      a = b / hi / g.exec(c).map(d);
    </code></pre>
  </emu-note>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    InputElementDiv ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      RightBracePunctuator

    InputElementRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RightBracePunctuator
      RegularExpressionLiteral

    InputElementRegExpOrTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RegularExpressionLiteral
      TemplateSubstitutionTail

    InputElementTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      TemplateSubstitutionTail

    InputElementHashbangOrRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      HashbangComment
      RegularExpressionLiteral
  </emu-grammar>

  <emu-clause id="sec-unicode-format-control-characters">
    <h1>Unicode 格式控制字符 (Unicode Format-Control Characters)</h1>
    <p>Unicode 格式控制字符（即 Unicode 字符数据库中类别 “Cf” 的字符，例如 LEFT-TO-RIGHT MARK 或 RIGHT-TO-LEFT MARK）是用于在缺乏更高层协议（如标记语言）时控制一段文本排版的控制码。</p>
    <p>允许在源码文本中使用格式控制字符有助于编辑与显示。所有格式控制字符可出现在注释中，以及字符串字面量、模板字面量和正则表达式字面量中。</p>
    <p>U+FEFF (ZERO WIDTH NO-BREAK SPACE) 是一种主要用于文本开头以标记其为 Unicode 并允许检测编码与字节序的格式控制字符。用于该目的的 &lt;ZWNBSP> 字符有时也可能在文本开头之后出现，例如连接文件的结果。在 ECMAScript 源码文本中，除注释、字符串字面量、模板字面量和正则表达式字面量外，&lt;ZWNBSP> 码点被视为空白字符（见 <emu-xref href="#sec-white-space"></emu-xref>）。</p>
  </emu-clause>

  <emu-clause id="sec-white-space">
    <h1>空白 (White Space)</h1>
    <p>空白码点用于提升源码可读性并分隔记号（不可再分的词法单元），除此之外没有意义。空白码点可出现在任意两个记号之间以及输入开头或结尾。空白码点可出现在 |StringLiteral|、|RegularExpressionLiteral|、|Template| 或 |TemplateSubstitutionTail| 内部，此时它们是字面量值组成部分的有效码点；也可出现在 |Comment| 内，但不能出现在其它类型的记号内部。</p>
    <p>ECMAScript 的空白码点列于 <emu-xref href="#table-white-space-code-points"></emu-xref>。</p>
    <emu-table id="table-white-space-code-points" caption="空白码点 (White Space Code Points)" oldids="table-32">
      <table>
        <thead>
          <tr>
            <th>
              Code Points
            </th>
            <th>
              名称 (Name)
            </th>
            <th>
              缩写 (Abbreviation)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+0009`
          </td>
          <td>
            CHARACTER TABULATION
          </td>
          <td>
            &lt;TAB>
          </td>
        </tr>
        <tr>
          <td>
            `U+000B`
          </td>
          <td>
            LINE TABULATION
          </td>
          <td>
            &lt;VT>
          </td>
        </tr>
        <tr>
          <td>
            `U+000C`
          </td>
          <td>
            FORM FEED (FF)
          </td>
          <td>
            &lt;FF>
          </td>
        </tr>
        <tr>
          <td>
            `U+FEFF`
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP>
          </td>
        </tr>
        <tr>
          <td>
            any code point in general category “Space_Separator”
          </td>
          <td>
          </td>
          <td>
            &lt;USP>
          </td>
        </tr>
      </table>
    </emu-table>
    <emu-note>
      <p>U+0020 (SPACE) 与 U+00A0 (NO-BREAK SPACE) 码点属于 &lt;USP>。</p>
    </emu-note>
    <emu-note>
      <p>除 <emu-xref href="#table-white-space-code-points"></emu-xref> 所列码点外，ECMAScript |WhiteSpace| 有意排除所有具有 Unicode “White_Space” 属性但不属于一般类别 “Space_Separator”(“Zs”) 的码点。</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WhiteSpace ::
        &lt;TAB&gt;
        &lt;VT&gt;
        &lt;FF&gt;
        &lt;ZWNBSP&gt;
        &lt;USP&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-line-terminators">
    <h1>行终止符 (Line Terminators)</h1>
    <p>与空白码点类似，行终止符码点用于提升源码可读性并分隔记号。但与空白码点不同，行终止符会对句法语法行为产生影响。一般而言，行终止符可出现在任意两个记号之间，但也有少数位置为句法语法所禁止。行终止符还影响自动分号插入过程（见 <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）。行终止符不能出现在除 |StringLiteral|、|Template| 或 |TemplateSubstitutionTail| 之外的任何记号内部。&lt;LF> 与 &lt;CR> 行终止符除作为 |LineContinuation| 的一部分外，不能出现在 |StringLiteral| 记号内。</p>
    <p>|MultiLineComment| 内可以出现行终止符，但 |SingleLineComment| 内不能。</p>
    <p>行终止符包含在正则表达式 `\\s` 类所匹配的空白码点集合中。</p>
    <p>ECMAScript 行终止符码点列于 <emu-xref href="#table-line-terminator-code-points"></emu-xref>。</p>
    <emu-table id="table-line-terminator-code-points" caption="行终止符码点 (Line Terminator Code Points)" oldids="table-33">
      <table>
        <thead>
          <tr>
            <th>
              Code Point
            </th>
            <th>
              Unicode 名称 (Unicode Name)
            </th>
            <th>
              缩写 (Abbreviation)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+000A`
          </td>
          <td>
            LINE FEED (LF)
          </td>
          <td>
            &lt;LF>
          </td>
        </tr>
        <tr>
          <td>
            `U+000D`
          </td>
          <td>
            CARRIAGE RETURN (CR)
          </td>
          <td>
            &lt;CR>
          </td>
        </tr>
        <tr>
          <td>
            `U+2028`
          </td>
          <td>
            LINE SEPARATOR
          </td>
          <td>
            &lt;LS>
          </td>
        </tr>
        <tr>
          <td>
            `U+2029`
          </td>
          <td>
            PARAGRAPH SEPARATOR
          </td>
          <td>
            &lt;PS>
          </td>
        </tr>
      </table>
    </emu-table>
    <p>只有 <emu-xref href="#table-line-terminator-code-points"></emu-xref> 中的 Unicode 码点被视为行终止符。其它换行或断行的 Unicode 码点不会被视为行终止符，但若满足 <emu-xref href="#table-white-space-code-points"></emu-xref> 所列要求，则被视为空白。序列 &lt;CR>&lt;LF> 常用作行终止符；在报告行号时应将其视为单个 |SourceCharacter|。</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LineTerminator ::
        &lt;LF&gt;
        &lt;CR&gt;
        &lt;LS&gt;
        &lt;PS&gt;

      LineTerminatorSequence ::
        &lt;LF&gt;
        &lt;CR&gt; [lookahead != &lt;LF&gt;]
        &lt;LS&gt;
        &lt;PS&gt;
        &lt;CR&gt; &lt;LF&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-comments">
    <h1>注释 (Comments)</h1>
    <p>注释可以是单行或多行。多行注释不能嵌套。</p>
    <p>由于单行注释可包含除 |LineTerminator| 码点外的任意 Unicode 码点，并且根据“一段记号总是尽可能长”的通则，单行注释总是从 `//` 标记到该行末端的全部码点。然而，行末的 |LineTerminator| 不视为单行注释的一部分；它被词法语法单独识别并进入供句法语法使用的输入元素流。这一点很重要，因为这意味着单行注释的有无不影响自动分号插入（见 <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）。</p>
    <p>注释的行为类似空白并被丢弃；但若 |MultiLineComment| 含有行终止符码点，则整个注释在句法解析目的上被视为一个 |LineTerminator|。</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Comment ::
        MultiLineComment
        SingleLineComment

      MultiLineComment ::
        `/*` MultiLineCommentChars? `*/`

      MultiLineCommentChars ::
        MultiLineNotAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      PostAsteriskCommentChars ::
        MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      MultiLineNotAsteriskChar ::
        SourceCharacter but not `*`

      MultiLineNotForwardSlashOrAsteriskChar ::
        SourceCharacter but not one of `/` or `*`

      SingleLineComment ::
        `//` SingleLineCommentChars?

      SingleLineCommentChars ::
        SingleLineCommentChar SingleLineCommentChars?

      SingleLineCommentChar ::
        SourceCharacter but not LineTerminator
    </emu-grammar>
    <p>本节若干产生式在 <emu-xref href="#sec-html-like-comments"></emu-xref> 中给出替代定义。</p>
  </emu-clause>

  <emu-clause id="sec-hashbang">
    <h1>Hashbang 注释 (Hashbang Comments)</h1>

    <p>Hashbang 注释对位置敏感，并且与其它类型注释一样从句法语法的输入元素流中被丢弃。</p>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      HashbangComment ::
        `#!` SingleLineCommentChars?
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-tokens">
    <h1>记号 (Tokens)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CommonToken ::
        IdentifierName
        PrivateIdentifier
        Punctuator
        NumericLiteral
        StringLiteral
        Template
    </emu-grammar>
    <emu-note>
      <p>|DivPunctuator|、|RegularExpressionLiteral|、|RightBracePunctuator| 与 |TemplateSubstitutionTail| 产生式派生的额外记号未包含在 |CommonToken| 中。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-names-and-keywords">
    <h1>名称与关键字 (Names and Keywords)</h1>
    <p>|IdentifierName| 与 |ReservedWord| 是按 Unicode 标准附件 #31《标识符与模式语法》中“默认标识符语法”解释的记号，并带有少量修改。|ReservedWord| 是 |IdentifierName| 的枚举子集。句法语法将 |Identifier| 定义为不是 |ReservedWord| 的 |IdentifierName|。Unicode 标识符语法基于 Unicode 标准规定的字符属性。符合规范的 ECMAScript 实现必须将 Unicode 标准最新版本中指定类别的码点视为属于这些类别。实现可以识别 Unicode 后续版本定义的标识符码点。</p>
    <emu-note>
      <p>本标准特别增加：U+0024 (DOLLAR SIGN) 与 U+005F (LOW LINE) 可在 |IdentifierName| 任意位置使用。</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrivateIdentifier ::
        `#` IdentifierName

      IdentifierName ::
        IdentifierStart
        IdentifierName IdentifierPart

      IdentifierStart ::
        IdentifierStartChar
        `\` UnicodeEscapeSequence

      IdentifierPart ::
        IdentifierPartChar
        `\` UnicodeEscapeSequence

      IdentifierStartChar ::
        UnicodeIDStart
        `$`
        `_`

      IdentifierPartChar ::
        UnicodeIDContinue
        `$`

      // emu-format ignore
      AsciiLetter :: one of
        `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
        `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

      UnicodeIDStart ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;

      UnicodeIDContinue ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;
    </emu-grammar>
    <p>非终结符 |UnicodeEscapeSequence| 的定义见 <emu-xref href="#sec-literals-string-literals"></emu-xref>。</p>
    <emu-note>
      <p>非终结符 |IdentifierPart| 通过 |UnicodeIDContinue| 派生 `_`。</p>
    </emu-note>
    <emu-note>
      <p>具有 Unicode 属性 “ID_Start” 与 “ID_Continue” 的码点集合分别包含具有 “Other_ID_Start” 与 “Other_ID_Continue” 属性的码点。</p>
    </emu-note>

    <emu-clause id="sec-identifier-names">
      <h1>标识符名称 (Identifier Names)</h1>
      <p>|IdentifierName| 中允许使用 Unicode 转义序列，它们贡献单个等于该 |UnicodeEscapeSequence| 的 IdentifierCodePoint 的 Unicode 码点。前导的 `\\` 不贡献码点。|UnicodeEscapeSequence| 不能用于为本来无效的 |IdentifierName| 提供码点。换言之，如果将 `\\` |UnicodeEscapeSequence| 序列替换为其贡献的 |SourceCharacter|，结果仍须是一个有效的 |IdentifierName|，并且与原始 |IdentifierName| 拥有完全相同的 |SourceCharacter| 序列。本规范中对 |IdentifierName| 的所有解释都基于其实际码点，无论是否通过转义序列写出。</p>
      <p>两个根据 Unicode 标准规范等价的 |IdentifierName|，除非在替换每个 |UnicodeEscapeSequence| 后由完全相同的码点序列表示，否则<em>不</em>相等。</p>

      <emu-clause id="sec-identifier-names-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>IdentifierStart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            若 |UnicodeEscapeSequence| 的 IdentifierCodePoint 不是 |IdentifierStartChar| 词法产生式匹配的某个 Unicode 码点，则为语法错误。
          </li>
        </ul>
        <emu-grammar>IdentifierPart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            若 |UnicodeEscapeSequence| 的 IdentifierCodePoint 不是 |IdentifierPartChar| 词法产生式匹配的某个 Unicode 码点，则为语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoints" type="sdo">
        <h1>静态语义：IdentifierCodePoints ( ): 码点列表 (a List of code points)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierName :: IdentifierStart</emu-grammar>
        <emu-alg>
          1. 令 _cp_ 为 |IdentifierStart| 的 IdentifierCodePoint。
          1. 返回 « _cp_ »。
        </emu-alg>
        <emu-grammar>IdentifierName :: IdentifierName IdentifierPart</emu-grammar>
        <emu-alg>
          1. 令 _cps_ 为所派生 |IdentifierName| 的 IdentifierCodePoints。
          1. 令 _cp_ 为 |IdentifierPart| 的 IdentifierCodePoint。
          1. 返回 _cps_ 与 « _cp_ » 的列表连接。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoint" type="sdo">
        <h1>静态语义：IdentifierCodePoint ( ): 一个码点 (a code point)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. 返回 |IdentifierStartChar| 匹配的码点。
        </emu-alg>
        <emu-grammar>IdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. 返回 |IdentifierPartChar| 匹配的码点。
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. 返回数值为 |Hex4Digits| 的 MV 的码点。
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. 返回数值为 |CodePoint| 的 MV 的码点。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-keywords-and-reserved-words" oldids="sec-reserved-words,sec-keywords,sec-future-reserved-words">
      <h1>关键字与保留字 (Keywords and Reserved Words)</h1>
      <p><dfn variants="keywords">关键字 (keyword)</dfn> 是匹配 |IdentifierName| 且具有句法用途的记号；即出现在某个句法产生式中以打字机字体（固定宽度）字面形式的词。ECMAScript 的关键字包括 `if`、`while`、`async`、`await` 等。</p>
      <p><dfn variants="reserved words">保留字 (reserved word)</dfn> 是不能用作标识符的 |IdentifierName|。许多关键字是保留字，但有些不是；还有一些只在特定上下文中被保留。`if` 与 `while` 是保留字。`await` 仅在 async 函数与模块内部被保留。`async` 不是保留字；它可自由用作变量名或语句标签。</p>
      <p>本规范结合语法产生式与早期错误规则来指明哪些名称是有效标识符，哪些是保留字。下列 |ReservedWord| 列表中除 `await` 与 `yield` 外的所有记号无条件被保留。`await` 与 `yield` 的例外通过带参数的句法产生式在 <emu-xref href="#sec-identifiers"></emu-xref> 中指定。最后，多条早期错误规则限制有效标识符集合，见 <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>、<emu-xref href="#sec-let-and-const-declarations-static-semantics-early-errors"></emu-xref>、<emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-early-errors"></emu-xref> 与 <emu-xref href="#sec-class-definitions-static-semantics-early-errors"></emu-xref>。概括而言，标识符名称有五类：</p>
      <ul>
        <li>
          <p>始终允许且不是关键字的，如 `Math`、`window`、`toString`、`_`；</p>
        </li>
        <li>
          <p>永不允许的，即下表 |ReservedWord|（除 `await`、`yield`）；</p>
        </li>
        <li>
          <p>上下文允许的，即 `await` 与 `yield`；</p>
        </li>
        <li>
          <p>在严格模式中上下文不允许的：`let`、`static`、`implements`、`interface`、`package`、`private`、`protected`、`public`；</p>
        </li>
        <li>
          <p>始终允许但在某些句法产生式（|Identifier| 不允许处）又作为关键字出现的：`as`、`async`、`from`、`get`、`meta`、`of`、`set`、`target`。</p>
        </li>
      </ul>
      <p><dfn variants="conditional keywords">条件关键字 (conditional keyword)</dfn> 或 <dfn variants="contextual keywords">上下文关键字 (contextual keyword)</dfn> 常用于指代后三类，它们在某些上下文可作标识符，在另一些上下文作关键字。</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        // emu-format ignore
        ReservedWord :: one of
          `await`
          `break`
          `case` `catch` `class` `const` `continue`
          `debugger` `default` `delete` `do`
          `else` `enum` `export` `extends`
          `false` `finally` `for` `function`
          `if` `import` `in` `instanceof`
          `new` `null`
          `return`
          `super` `switch`
          `this` `throw` `true` `try` `typeof`
          `var` `void`
          `while` `with`
          `yield`
      </emu-grammar>
      <emu-note>
        <p>依据 <emu-xref href="#sec-grammar-notation"></emu-xref>，语法中的关键字匹配特定 |SourceCharacter| 序列的字面串。关键字中的码点不能通过 `\\` |UnicodeEscapeSequence| 表达。</p>
        <p>|IdentifierName| 可包含 `\\` |UnicodeEscapeSequence|，但不能通过拼写 `els\u{65}` 来声明名为 “else” 的变量。<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref> 的早期错误规则会排除 StringValue 与保留字相同的标识符。</p>
      </emu-note>
      <emu-note>
        <p>`enum` 当前尚未作为关键字使用。它是一个<em>未来保留字</em>，为未来语言扩展保留。</p>
        <p>同样地，`implements`、`interface`、`package`、`private`、`protected`、`public` 在严格模式中是未来保留字。</p>
      </emu-note>
      <emu-note>
        <p>`arguments` 与 `eval` 不是关键字，但在严格模式中有一些限制。参见 <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>、<emu-xref href="#sec-static-semantics-assignmenttargettype"></emu-xref>、<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>、<emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref>、<emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref> 与 <emu-xref href="#sec-async-function-definitions-static-semantics-early-errors"></emu-xref>。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-punctuators">
    <h1>标点符号 (Punctuators)</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Punctuator ::
        OptionalChainingPunctuator
        OtherPunctuator

      OptionalChainingPunctuator ::
        `?.` [lookahead &notin; DecimalDigit]

      // emu-format ignore
      OtherPunctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||` `??`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `&amp;&amp;=` `||=` `??=`
        `=&gt;`

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-ecmascript-language-lexical-grammar-literals">
    <h1>字面量 (Literals)</h1>

    <emu-clause id="sec-null-literals">
      <h1>Null 字面量 (Null Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NullLiteral ::
          `null`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-boolean-literals">
      <h1>布尔字面量 (Boolean Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BooleanLiteral ::
          `true`
          `false`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-literals-numeric-literals" oldids="sec-additional-syntax-numeric-literals">
      <h1>数值字面量 (Numeric Literals)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NumericLiteralSeparator ::
          `_`

        NumericLiteral ::
          DecimalLiteral
          DecimalBigIntegerLiteral
          NonDecimalIntegerLiteral[+Sep]
          NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
          LegacyOctalIntegerLiteral

        DecimalBigIntegerLiteral ::
          `0` BigIntLiteralSuffix
          NonZeroDigit DecimalDigits[+Sep]? BigIntLiteralSuffix
          NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

        NonDecimalIntegerLiteral[Sep] ::
          BinaryIntegerLiteral[?Sep]
          OctalIntegerLiteral[?Sep]
          HexIntegerLiteral[?Sep]

        BigIntLiteralSuffix ::
          `n`

        DecimalLiteral ::
          DecimalIntegerLiteral `.` DecimalDigits[+Sep]? ExponentPart[+Sep]?
          `.` DecimalDigits[+Sep] ExponentPart[+Sep]?
          DecimalIntegerLiteral ExponentPart[+Sep]?

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit
          NonZeroDigit NumericLiteralSeparator? DecimalDigits[+Sep]
          NonOctalDecimalIntegerLiteral

        DecimalDigits[Sep] ::
          DecimalDigit
          DecimalDigits[?Sep] DecimalDigit
          [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`

        ExponentPart[Sep] ::
          ExponentIndicator SignedInteger[?Sep]

        ExponentIndicator :: one of
          `e` `E`

        SignedInteger[Sep] ::
          DecimalDigits[?Sep]
          `+` DecimalDigits[?Sep]
          `-` DecimalDigits[?Sep]

        BinaryIntegerLiteral[Sep] ::
          `0b` BinaryDigits[?Sep]
          `0B` BinaryDigits[?Sep]

        BinaryDigits[Sep] ::
          BinaryDigit
          BinaryDigits[?Sep] BinaryDigit
          [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

        BinaryDigit :: one of
          `0` `1`

        OctalIntegerLiteral[Sep] ::
          `0o` OctalDigits[?Sep]
          `0O` OctalDigits[?Sep]

        OctalDigits[Sep] ::
          OctalDigit
          OctalDigits[?Sep] OctalDigit
          [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

        LegacyOctalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalIntegerLiteral OctalDigit

        NonOctalDecimalIntegerLiteral ::
          `0` NonOctalDigit
          LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
          NonOctalDecimalIntegerLiteral DecimalDigit

        LegacyOctalLikeDecimalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalLikeDecimalIntegerLiteral OctalDigit

        OctalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7`

        NonOctalDigit :: one of
          `8` `9`

        HexIntegerLiteral[Sep] ::
          `0x` HexDigits[?Sep]
          `0X` HexDigits[?Sep]

        HexDigits[Sep] ::
          HexDigit
          HexDigits[?Sep] HexDigit
          [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

        // emu-format ignore
        HexDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`
      </emu-grammar>
      <p>|NumericLiteral| 之后紧接的下一个 |SourceCharacter| 不能是 |IdentifierStart| 或 |DecimalDigit|。</p>
      <emu-note>
        <p>例如：`3in` 是错误，而不是两个输入元素 `3` 与 `in`。</p>
      </emu-note>

      <emu-clause id="sec-numeric-literals-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>
          NumericLiteral :: LegacyOctalIntegerLiteral

          DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
        </emu-grammar>
        <ul>
          <li>若 IsStrict(this production) 为 *true* 则为语法错误。</li>
        </ul>
        <emu-note>在非严格代码中，该语法为 Legacy。</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-mv" oldids="sec-additional-syntax-numeric-literals-status-semantics">
        <h1>静态语义：MV (Static Semantics: MV)</h1>
        <p>数值字面量表示 Number 类型或 BigInt 类型的值。</p>
        <ul>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits</emu-grammar> 的 MV 为 |DecimalIntegerLiteral| 的 MV 加上 (|DecimalDigits| 的 MV × 10<sup>-_n_</sup>)，其中 _n_ 为 |DecimalDigits| 中（排除所有 |NumericLiteralSeparator|）码点数。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart</emu-grammar> 的 MV 为 |DecimalIntegerLiteral| 的 MV × 10<sup>_e_</sup>，其中 _e_ 为 |ExponentPart| 的 MV。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart</emu-grammar> 的 MV 为 (|DecimalIntegerLiteral| 的 MV + (|DecimalDigits| 的 MV × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>，其中 _n_ 为 |DecimalDigits| 中（排除所有 |NumericLiteralSeparator|）码点数，_e_ 为 |ExponentPart| 的 MV。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits</emu-grammar> 的 MV 为 |DecimalDigits| 的 MV × 10<sup>-_n_</sup>，_n_ 同上。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: `.` DecimalDigits ExponentPart</emu-grammar> 的 MV 为 |DecimalDigits| 的 MV × 10<sup>_e_ - _n_</sup>，_n_ 同上，_e_ 为 |ExponentPart| 的 MV。
          </li>
          <li>
            <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral ExponentPart</emu-grammar> 的 MV 为 |DecimalIntegerLiteral| 的 MV × 10<sup>_e_</sup>。
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: `0`</emu-grammar> 的 MV 为 0。
          </li>
          <li>
            <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparator? DecimalDigits</emu-grammar> 的 MV 为 (|NonZeroDigit| 的 MV × 10<sup>_n_</sup>) + |DecimalDigits| 的 MV，_n_ 同上。
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits DecimalDigit</emu-grammar> 的 MV 为 (|DecimalDigits| 的 MV × 10) + |DecimalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit</emu-grammar> 的 MV 为 (|DecimalDigits| 的 MV × 10) + |DecimalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>ExponentPart :: ExponentIndicator SignedInteger</emu-grammar> 的 MV 为 |SignedInteger| 的 MV。
          </li>
          <li>
            <emu-grammar>SignedInteger :: `-` DecimalDigits</emu-grammar> 的 MV 为 |DecimalDigits| 的 MV 的相反数。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `0`</emu-grammar>、<emu-grammar>HexDigit :: `0`</emu-grammar>、<emu-grammar>OctalDigit :: `0`</emu-grammar>、<emu-grammar>LegacyOctalEscapeSequence :: `0`</emu-grammar>、<emu-grammar>BinaryDigit :: `0`</emu-grammar> 的 MV 均为 0。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `1`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `1`</emu-grammar> 或 <emu-grammar>HexDigit :: `1`</emu-grammar> 或 <emu-grammar>OctalDigit :: `1`</emu-grammar> 或 <emu-grammar>BinaryDigit :: `1`</emu-grammar> 的 MV 为 1。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `2`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `2`</emu-grammar> 或 <emu-grammar>HexDigit :: `2`</emu-grammar> 或 <emu-grammar>OctalDigit :: `2`</emu-grammar> 的 MV 为 2。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `3`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `3`</emu-grammar> 或 <emu-grammar>HexDigit :: `3`</emu-grammar> 或 <emu-grammar>OctalDigit :: `3`</emu-grammar> 的 MV 为 3。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `4`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `4`</emu-grammar> 或 <emu-grammar>HexDigit :: `4`</emu-grammar> 或 <emu-grammar>OctalDigit :: `4`</emu-grammar> 的 MV 为 4。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `5`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `5`</emu-grammar> 或 <emu-grammar>HexDigit :: `5`</emu-grammar> 或 <emu-grammar>OctalDigit :: `5`</emu-grammar> 的 MV 为 5。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `6`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `6`</emu-grammar> 或 <emu-grammar>HexDigit :: `6`</emu-grammar> 或 <emu-grammar>OctalDigit :: `6`</emu-grammar> 的 MV 为 6。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `7`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `7`</emu-grammar> 或 <emu-grammar>HexDigit :: `7`</emu-grammar> 或 <emu-grammar>OctalDigit :: `7`</emu-grammar> 的 MV 为 7。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `8`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `8`</emu-grammar> 或 <emu-grammar>NonOctalDigit :: `8`</emu-grammar> 或 <emu-grammar>HexDigit :: `8`</emu-grammar> 的 MV 为 8。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: `9`</emu-grammar> 或 <emu-grammar>NonZeroDigit :: `9`</emu-grammar> 或 <emu-grammar>NonOctalDigit :: `9`</emu-grammar> 或 <emu-grammar>HexDigit :: `9`</emu-grammar> 的 MV 为 9。
          </li>
          <li>
            <emu-grammar>HexDigit :: `a`</emu-grammar> 或 <emu-grammar>HexDigit :: `A`</emu-grammar> 的 MV 为 10。
          </li>
          <li>
            <emu-grammar>HexDigit :: `b`</emu-grammar> 或 <emu-grammar>HexDigit :: `B`</emu-grammar> 的 MV 为 11。
          </li>
          <li>
            <emu-grammar>HexDigit :: `c`</emu-grammar> 或 <emu-grammar>HexDigit :: `C`</emu-grammar> 的 MV 为 12。
          </li>
          <li>
            <emu-grammar>HexDigit :: `d`</emu-grammar> 或 <emu-grammar>HexDigit :: `D`</emu-grammar> 的 MV 为 13。
          </li>
          <li>
            <emu-grammar>HexDigit :: `e`</emu-grammar> 或 <emu-grammar>HexDigit :: `E`</emu-grammar> 的 MV 为 14。
          </li>
          <li>
            <emu-grammar>HexDigit :: `f`</emu-grammar> 或 <emu-grammar>HexDigit :: `F`</emu-grammar> 的 MV 为 15。
          </li>
          <li>
            <emu-grammar>BinaryDigits :: BinaryDigits BinaryDigit</emu-grammar> 的 MV 为 (|BinaryDigits| 的 MV × 2) + |BinaryDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>BinaryDigits :: BinaryDigits NumericLiteralSeparator BinaryDigit</emu-grammar> 的 MV 为同上。
          </li>
          <li>
            <emu-grammar>OctalDigits :: OctalDigits OctalDigit</emu-grammar> 的 MV 为 (|OctalDigits| 的 MV × 8) + |OctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>OctalDigits :: OctalDigits NumericLiteralSeparator OctalDigit</emu-grammar> 的 MV 同上。
          </li>
          <li>
            <emu-grammar>LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral OctalDigit</emu-grammar> 的 MV 为 (|LegacyOctalIntegerLiteral| 的 MV × 8) + |OctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit</emu-grammar> 的 MV 为 (|LegacyOctalLikeDecimalIntegerLiteral| 的 MV × 10) + |NonOctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral DecimalDigit</emu-grammar> 的 MV 为 (|NonOctalDecimalIntegerLiteral| 的 MV × 10) + |DecimalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>LegacyOctalLikeDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral OctalDigit</emu-grammar> 的 MV 为 (|LegacyOctalLikeDecimalIntegerLiteral| 的 MV × 10) + |OctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> 的 MV 为 (|HexDigits| 的 MV × 16) + |HexDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>HexDigits :: HexDigits NumericLiteralSeparator HexDigit</emu-grammar> 的 MV 同上。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-numericvalue" type="sdo">
        <h1>静态语义：NumericValue ( ): Number 或 BigInt</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NumericLiteral :: DecimalLiteral</emu-grammar>
        <emu-alg>
          1. 返回 RoundMVResult(|DecimalLiteral| 的 MV)。
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 返回 𝔽(|NonDecimalIntegerLiteral| 的 MV)。
        </emu-alg>
        <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. 返回 𝔽(|LegacyOctalIntegerLiteral| 的 MV)。
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. 返回 |NonDecimalIntegerLiteral| 的 MV 对应的 BigInt 值。
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: `0` BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. 返回 *0*<sub>ℤ</sub>。
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. 返回 |NonZeroDigit| 的 MV 对应的 BigInt 值。
        </emu-alg>
        <emu-grammar>
          DecimalBigIntegerLiteral ::
            NonZeroDigit DecimalDigits BigIntLiteralSuffix
            NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
        </emu-grammar>
        <emu-alg>
          1. 令 _n_ 为 |DecimalDigits| 中（排除所有 |NumericLiteralSeparator|）码点数。
          1. 令 _mv_ 为 (|NonZeroDigit| 的 MV × 10<sup>_n_</sup>) + |DecimalDigits| 的 MV。
          1. 返回 ℤ(_mv_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-string-literals" oldids="sec-additional-syntax-string-literals">
      <h1>字符串字面量 (String Literals)</h1>
      <emu-note>
        <p>字符串字面量是 0 个或更多 Unicode 码点，被单引号或双引号包围。Unicode 码点也可用转义序列表达。除闭合引号码点、U+005C (REVERSE SOLIDUS)、U+000D (CARRIAGE RETURN)、U+000A (LINE FEED) 外，所有码点都可直接出现在字符串字面量中。任何码点都可以转义形式出现。字符串字面量求值为 ECMAScript String 值。生成这些 String 值时 Unicode 码点按 <emu-xref href="#sec-utf16encodecodepoint"></emu-xref> 中定义进行 UTF-16 编码。基本多文种平面 (BMP) 内的码点编码为单个代码单元，其它码点编码为两个代码单元。</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        StringLiteral ::
          `"` DoubleStringCharacters? `"`
          `'` SingleStringCharacters? `'`

        DoubleStringCharacters ::
          DoubleStringCharacter DoubleStringCharacters?

        SingleStringCharacters ::
          SingleStringCharacter SingleStringCharacters?

        DoubleStringCharacter ::
          SourceCharacter but not one of `"` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        SingleStringCharacter ::
          SourceCharacter but not one of `'` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        LineContinuation ::
          `\` LineTerminatorSequence

        EscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          LegacyOctalEscapeSequence
          NonOctalDecimalEscapeSequence
          HexEscapeSequence
          UnicodeEscapeSequence

        CharacterEscapeSequence ::
          SingleEscapeCharacter
          NonEscapeCharacter

        SingleEscapeCharacter :: one of
          `'` `"` `\` `b` `f` `n` `r` `t` `v`

        NonEscapeCharacter ::
          SourceCharacter but not one of EscapeCharacter or LineTerminator

        EscapeCharacter ::
          SingleEscapeCharacter
          DecimalDigit
          `x`
          `u`

        LegacyOctalEscapeSequence ::
          `0` [lookahead &isin; { `8`, `9` }]
          NonZeroOctalDigit [lookahead &notin; OctalDigit]
          ZeroToThree OctalDigit [lookahead &notin; OctalDigit]
          FourToSeven OctalDigit
          ZeroToThree OctalDigit OctalDigit

        NonZeroOctalDigit ::
          OctalDigit but not `0`

        ZeroToThree :: one of
          `0` `1` `2` `3`

        FourToSeven :: one of
          `4` `5` `6` `7`

        NonOctalDecimalEscapeSequence :: one of
          `8` `9`

        HexEscapeSequence ::
          `x` HexDigit HexDigit

        UnicodeEscapeSequence ::
          `u` Hex4Digits
          `u{` CodePoint `}`

        Hex4Digits ::
          HexDigit HexDigit HexDigit HexDigit
      </emu-grammar>
      <p>非终结符 |HexDigit| 定义见 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>。|SourceCharacter| 定义见 <emu-xref href="#sec-source-text"></emu-xref>。</p>
      <emu-note>
        <p>&lt;LF> 与 &lt;CR> 不能出现在字符串字面量中，除非作为 |LineContinuation| 的一部分以生成空码点序列。要在字符串字面量值中包含它们，应使用 `\\n` 或 `\\u000A` 等转义序列。</p>
      </emu-note>

      <emu-clause id="sec-string-literals-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>
          EscapeSequence ::
            LegacyOctalEscapeSequence
            NonOctalDecimalEscapeSequence
        </emu-grammar>
        <ul>
          <li>若 IsStrict(this production) 为 *true* 则为语法错误。</li>
        </ul>
        <emu-note>在非严格代码中，该语法为 Legacy。</emu-note>
        <emu-note>
          <p>字符串字面量可能位于使封闭代码进入 <emu-xref href="#sec-strict-mode-code">严格模式</emu-xref> 的 Use Strict 指令之前，实现必须谨慎对这些字面量执行上述规则。例如，下列源码包含语法错误：</p>
          <pre><code class="javascript">
            function invalid() { "\7"; "use strict"; }
          </code></pre>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sv" oldids="sec-string-literals-static-semantics-stringvalue,sec-additional-syntax-string-literals-static-semantics" type="sdo">
        <h1>静态语义：SV ( ): 一个 String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            <p>字符串字面量表示 String 类型值。SV 通过对字面量各部分的递归应用生成 String 值。在此过程中，字符串字面量中的某些 Unicode 码点按下文或 <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 描述被视为具有数学值。</p>
          </dd>
        </dl>
        <ul>
          <li>
            <emu-grammar>StringLiteral :: `"` `"`</emu-grammar> 的 SV 是空字符串。
          </li>
          <li>
            <emu-grammar>StringLiteral :: `'` `'`</emu-grammar> 的 SV 是空字符串。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters</emu-grammar> 的 SV 为 |DoubleStringCharacter| 的 SV 与 |DoubleStringCharacters| 的 SV 的字符串连接。
          </li>
          <li>
            <emu-grammar>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters</emu-grammar> 的 SV 同理。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: SourceCharacter but not one of `"` or `\` or LineTerminator</emu-grammar> 的 SV 为对 |SourceCharacter| 匹配码点执行 UTF16EncodeCodePoint 的结果。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: &lt;LS&gt;</emu-grammar> 的 SV 为包含代码单元 0x2028 的字符串。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: &lt;PS&gt;</emu-grammar> 的 SV 为包含代码单元 0x2029 的字符串。
          </li>
          <li>
            <emu-grammar>DoubleStringCharacter :: LineContinuation</emu-grammar> 的 SV 为空字符串。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: SourceCharacter but not one of `'` or `\` or LineTerminator</emu-grammar> 的 SV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: &lt;LS&gt;</emu-grammar> 的 SV 为代码单元 0x2028。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: &lt;PS&gt;</emu-grammar> 的 SV 为代码单元 0x2029。
          </li>
          <li>
            <emu-grammar>SingleStringCharacter :: LineContinuation</emu-grammar> 的 SV 为空字符串。
          </li>
          <li>
            <emu-grammar>EscapeSequence :: `0`</emu-grammar> 的 SV 为代码单元 0x0000。
          </li>
          <li>
            <emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> 的 SV 为由 <emu-xref href="#table-string-single-character-escape-sequences"></emu-xref> 中确定数值的代码单元。
          </li>
        </ul>
        <emu-table id="table-string-single-character-escape-sequences" caption="字符串单字符转义序列 (String Single Character Escape Sequences)" oldids="table-34">
          <table>
            <thead>
              <tr>
                <th>
                  转义序列 (Escape Sequence)
                </th>
                <th>
                  代码单元值 (Code Unit Value)
                </th>
                <th>
                  Unicode 字符名 (Unicode Character Name)
                </th>
                <th>
                  符号 (Symbol)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `\\b`
              </td>
              <td>
                `0x0008`
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                &lt;BS>
              </td>
            </tr>
            <tr>
              <td>
                `\\t`
              </td>
              <td>
                `0x0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `\\n`
              </td>
              <td>
                `0x000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `\\v`
              </td>
              <td>
                `0x000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `\\f`
              </td>
              <td>
                `0x000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `\\r`
              </td>
              <td>
                `0x000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
            <tr>
              <td>
                `\\"`
              </td>
              <td>
                `0x0022`
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `"`
              </td>
            </tr>
            <tr>
              <td>
                `\\'`
              </td>
              <td>
                `0x0027`
              </td>
              <td>
                APOSTROPHE
              </td>
              <td>
                `'`
              </td>
            </tr>
            <tr>
              <td>
                `\\\\`
              </td>
              <td>
                `0x005C`
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\`
              </td>
            </tr>
          </table>
        </emu-table>
        <ul>
          <li>
            <emu-grammar>NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator</emu-grammar> 的 SV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> 的 SV 为数值为 |LegacyOctalEscapeSequence| MV 的代码单元。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalEscapeSequence :: `8`</emu-grammar> 的 SV 为代码单元 0x0038 (DIGIT EIGHT)。
          </li>
          <li>
            <emu-grammar>NonOctalDecimalEscapeSequence :: `9`</emu-grammar> 的 SV 为代码单元 0x0039 (DIGIT NINE)。
          </li>
          <li>
            <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> 的 SV 为数值为 |HexEscapeSequence| MV 的代码单元。
          </li>
          <li>
            <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> 的 SV 为数值为 |Hex4Digits| MV 的代码单元。
          </li>
          <li>
            <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> 的 SV 为对 |CodePoint| MV 执行 UTF16EncodeCodePoint 的结果。
          </li>
          <li>
            <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> 的 SV 为代码单元 0x0000 (NULL)。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-string-literals-static-semantics-mv">
        <h1>静态语义：MV</h1>
        <ul>
          <li>
            <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit</emu-grammar> 的 MV 为 (8 × |ZeroToThree| 的 MV) + |OctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>LegacyOctalEscapeSequence :: FourToSeven OctalDigit</emu-grammar> 的 MV 为 (8 × |FourToSeven| 的 MV) + |OctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit</emu-grammar> 的 MV 为 (64 (即 8<sup>2</sup>) × |ZeroToThree| 的 MV) + (8 × 第一个 |OctalDigit| 的 MV) + 第二个 |OctalDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `0`</emu-grammar> 的 MV 为 0。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `1`</emu-grammar> 的 MV 为 1。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `2`</emu-grammar> 的 MV 为 2。
          </li>
          <li>
            <emu-grammar>ZeroToThree :: `3`</emu-grammar> 的 MV 为 3。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `4`</emu-grammar> 的 MV 为 4。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `5`</emu-grammar> 的 MV 为 5。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `6`</emu-grammar> 的 MV 为 6。
          </li>
          <li>
            <emu-grammar>FourToSeven :: `7`</emu-grammar> 的 MV 为 7。
          </li>
          <li>
            <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> 的 MV 为 (16 × 第一个 |HexDigit| 的 MV) + 第二个 |HexDigit| 的 MV。
          </li>
          <li>
            <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> 的 MV 为 (0x1000 × 第一个 |HexDigit| 的 MV) + (0x100 × 第二个 |HexDigit| 的 MV) + (0x10 × 第三个 |HexDigit| 的 MV) + 第四个 |HexDigit| 的 MV。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-regular-expression-literals">
      <h1>正则表达式字面量 (Regular Expression Literals)</h1>
      <emu-note>
        <p>正则表达式字面量是一个输入元素，每次求值它都会转换为一个 RegExp 对象（见 <emu-xref href="#sec-regexp-regular-expression-objects"></emu-xref>）。程序中两个正则字面量即便内容相同，求值得到的两个正则对象也永远不会 `===`。RegExp 对象也可在运行时通过 `new RegExp` 或以函数形式调用构造器创建（见 <emu-xref href="#sec-regexp-constructor"></emu-xref>）。</p>
      </emu-note>
      <p>下列产生式描述正则表达式字面量的语法，供输入元素扫描器定位字面量结束。由 |RegularExpressionBody| 与 |RegularExpressionFlags| 组成的源码随后再用更严格的 ECMAScript 正则语法（<emu-xref href="#sec-patterns"></emu-xref>）解析。</p>
      <p>实现可扩展 <emu-xref href="#sec-patterns"></emu-xref> 定义的 ECMAScript 正则语法，但不得扩展以下定义的 |RegularExpressionBody|、|RegularExpressionFlags| 及其依赖的产生式。</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        RegularExpressionLiteral ::
          `/` RegularExpressionBody `/` RegularExpressionFlags

        RegularExpressionBody ::
          RegularExpressionFirstChar RegularExpressionChars

        RegularExpressionChars ::
          [empty]
          RegularExpressionChars RegularExpressionChar

        RegularExpressionFirstChar ::
          RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionChar ::
          RegularExpressionNonTerminator but not one of `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionBackslashSequence ::
          `\` RegularExpressionNonTerminator

        RegularExpressionNonTerminator ::
          SourceCharacter but not LineTerminator

        RegularExpressionClass ::
          `[` RegularExpressionClassChars `]`

        RegularExpressionClassChars ::
          [empty]
          RegularExpressionClassChars RegularExpressionClassChar

        RegularExpressionClassChar ::
          RegularExpressionNonTerminator but not one of `]` or `\`
          RegularExpressionBackslashSequence

        RegularExpressionFlags ::
          [empty]
          RegularExpressionFlags IdentifierPartChar
      </emu-grammar>
      <emu-note>
        <p>正则字面量不能为空；序列 `//` 表示单行注释而不是空正则。若需空正则，使用 `/(?:)/`。</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-bodytext" type="sdo">
        <h1>静态语义：BodyText ( ): source text</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. 返回识别为 |RegularExpressionBody| 的源码文本。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-flagtext" type="sdo">
        <h1>静态语义：FlagText ( ): source text</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. 返回识别为 |RegularExpressionFlags| 的源码文本。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literal-lexical-components">
      <h1>模板字面量词法组件 (Template Literal Lexical Components)</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Template ::
          NoSubstitutionTemplate
          TemplateHead

        NoSubstitutionTemplate ::
          ``` TemplateCharacters? ```

        TemplateHead ::
          ``` TemplateCharacters? `${`

        TemplateSubstitutionTail ::
          TemplateMiddle
          TemplateTail

        TemplateMiddle ::
          `}` TemplateCharacters? `${`

        TemplateTail ::
          `}` TemplateCharacters? ```

        TemplateCharacters ::
          TemplateCharacter TemplateCharacters?

        TemplateCharacter ::
          `$` [lookahead != `{`]
          `\` TemplateEscapeSequence
          `\` NotEscapeSequence
          LineContinuation
          LineTerminatorSequence
          SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

        TemplateEscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          UnicodeEscapeSequence

        NotEscapeSequence ::
          `0` DecimalDigit
          DecimalDigit but not `0`
          `x` [lookahead &notin; HexDigit]
          `x` HexDigit [lookahead &notin; HexDigit]
          `u` [lookahead &notin; HexDigit] [lookahead != `{`]
          `u` HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` `{` [lookahead &notin; HexDigit]
          `u` `{` NotCodePoint [lookahead &notin; HexDigit]
          `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]

        NotCodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| > 0x10FFFF]

        CodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| &le; 0x10FFFF]
      </emu-grammar>
      <emu-note>
        <p>|TemplateSubstitutionTail| 由 |InputElementTemplateTail| 可选词法目标使用。</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-tv" type="sdo" oldids="sec-static-semantics-tv-and-trv">
        <h1>静态语义：TV ( ): String 或 *undefined*</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>模板字面量组件由 TV 解释为 String 类型值。TV 用来构造模板对象的索引组件（俗称 template values）。在 TV 中，转义序列被替换为其表示码点的 UTF-16 代码单元。</dd>
        </dl>
        <ul>
          <li>
            <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> 的 TV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> 的 TV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> 的 TV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateTail :: `}` ```</emu-grammar> 的 TV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> 的 TV 若任一子 TV 为 *undefined* 则为 *undefined*；否则为二者字符串连接。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> 的 TV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `$`</emu-grammar> 的 TV 为代码单元 0x0024 (DOLLAR SIGN)。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> 的 TV 为 |TemplateEscapeSequence| 的 SV。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> 的 TV 为 *undefined*。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> 的 TV 为 |LineTerminatorSequence| 的 TRV。
          </li>
          <li>
            <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> 的 TV 为空字符串。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-trv" type="sdo">
        <h1>静态语义：TRV ( ): String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>模板字面量组件由 TRV 解释为 String 类型值。TRV 用来构造模板对象的原始组件（raw values）。TRV 与 TV 类似，区别在于 TRV 中转义序列按字面出现形式解释。</dd>
        </dl>
        <ul>
          <li>
            <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> 的 TRV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> 的 TRV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> 的 TRV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateTail :: `}` ```</emu-grammar> 的 TRV 为空字符串。
          </li>
          <li>
            <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> 的 TRV 为子 TRV 的字符串连接。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> 的 TRV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `$`</emu-grammar> 的 TRV 为代码单元 0x0024。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> 的 TRV 为代码单元 0x005C (REVERSE SOLIDUS) 与 |TemplateEscapeSequence| TRV 的连接。
          </li>
          <li>
            <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> 的 TRV 为代码单元 0x005C 与 |NotEscapeSequence| TRV 的连接。
          </li>
          <li>
            <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> 的 TRV 为代码单元 0x0030 (DIGIT ZERO)。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `0` DecimalDigit</emu-grammar> 的 TRV 为 0x0030 与 |DecimalDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `x` [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为代码单元 0x0078。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `x` HexDigit [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为 0x0078 与 |HexDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` [lookahead &notin; HexDigit] [lookahead != `{`]</emu-grammar> 的 TRV 为代码单元 0x0075。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` HexDigit [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为 0x0075 与 |HexDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为 0x0075 与两个 |HexDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为 0x0075 与三个 |HexDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` `{` [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为 0x0075 与 0x007B 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` `{` NotCodePoint [lookahead &notin; HexDigit]</emu-grammar> 的 TRV 为 0x0075、0x007B 与 |NotCodePoint| TRV 的连接。
          </li>
          <li>
            <emu-grammar>NotEscapeSequence :: `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]</emu-grammar> 的 TRV 为 0x0075、0x007B 与 |CodePoint| TRV 的连接。
          </li>
          <li>
            <emu-grammar>DecimalDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</emu-grammar> 的 TRV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> 的 TRV 为 |NonEscapeCharacter| 的 SV。
          </li>
          <li>
            <emu-grammar>SingleEscapeCharacter :: one of `'` `"` `\` `b` `f` `n` `r` `t` `v`</emu-grammar> 的 TRV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> 的 TRV 为 0x0078 与两个 |HexDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> 的 TRV 为 0x0075 与 |Hex4Digits| TRV 的连接。
          </li>
          <li>
            <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> 的 TRV 为 0x0075、0x007B、|CodePoint| TRV、0x007D 的连接。
          </li>
          <li>
            <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> 的 TRV 为四个 |HexDigit| TRV 的连接。
          </li>
          <li>
            <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> 的 TRV 为 |HexDigits| TRV 与 |HexDigit| TRV 连接。
          </li>
          <li>
            <emu-grammar>HexDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`</emu-grammar> 的 TRV 为对应码点 UTF16EncodeCodePoint 结果。
          </li>
          <li>
            <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> 的 TRV 为代码单元 0x005C 与 |LineTerminatorSequence| TRV 连接。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;LF&gt;</emu-grammar> 的 TRV 为代码单元 0x000A。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;</emu-grammar> 的 TRV 为代码单元 0x000A。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;LS&gt;</emu-grammar> 的 TRV 为代码单元 0x2028。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;PS&gt;</emu-grammar> 的 TRV 为代码单元 0x2029。
          </li>
          <li>
            <emu-grammar>LineTerminatorSequence :: &lt;CR&gt; &lt;LF&gt;</emu-grammar> 的 TRV 为代码单元 0x000A。
          </li>
        </ul>
        <emu-note>
          <p>TV 不包含 |LineContinuation| 的代码单元，而 TRV 包含。&lt;CR>&lt;LF> 与 &lt;CR> |LineTerminatorSequence| 在 TV 与 TRV 中均规范化为 &lt;LF>。要包含 &lt;CR> 或 &lt;CR>&lt;LF>，需要显式 |TemplateEscapeSequence|。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>自动分号插入 (Automatic Semicolon Insertion)</h1>
    <p>大多数 ECMAScript 语句与声明必须以分号结束。此类分号可在源码中显式出现。为方便起见，在某些情形下可以省略；在这些情形中，认为分号被自动插入到源码记号流中。</p>

    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace="asi-rules">
      <h1>自动分号插入的规则 (Rules of Automatic Semicolon Insertion)</h1>
      <p>下列规则中，“token” 指根据 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref> 所述当前词法目标符号识别出的实际词法记号。</p>
      <p>分号插入有三条基本规则：</p>
      <ol>
        <li>
          <p>当从左到右解析源码时遇到一个不被任何语法产生式允许的记号（称为 <em>违规记号 (offending token)</em>）时，如果满足以下任一条件，则在其前自动插入分号：</p>
          <ul>
            <li>
              违规记号与前一个记号之间至少有一个 |LineTerminator|。
            </li>
            <li>
              违规记号是 `}`。
            </li>
            <li>
              前一个记号是 `)`，且插入的分号会被解析为 do-while 语句（<emu-xref href="#sec-do-while-statement"></emu-xref>）的结束分号。
            </li>
          </ul>
        </li>
        <li>
          当从左到右解析时，如果到达输入记号流末尾且解析器无法将其解析为目标非终结符的单一实例，则在末尾自动插入分号。
        </li>
        <li>
          当从左到右解析时遇到的记号在某个产生式中被允许，但该产生式是<em>受限产生式 (restricted production)</em> 且该记号将成为紧随 “[no |LineTerminator| here]” 注解之后的终结符或非终结符的首记号（故称为受限记号），且受限记号与前一记号之间至少有一个 |LineTerminator|，则在该受限记号前自动插入分号。
        </li>
      </ol>
      <p>然而，上述规则受一个额外覆盖条件：若自动插入的分号会被解析为空语句，或将成为 `for` 语句（见 <emu-xref href="#sec-for-statement"></emu-xref>）头部的两个分号之一，则不会自动插入。</p>
      <emu-note>
        <p>以下是语法中唯一的受限产生式：</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          YieldExpression[In, Await] :
            `yield`
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

          AsyncFunctionDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
            [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncFunctionExpression :
            `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncMethod[Yield, Await] :
            `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncGeneratorDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
            [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorExpression :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorMethod[Yield, Await] :
            `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncArrowFunction[In, Yield, Await] :
            `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
            CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

          AsyncArrowHead :
            `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
        </emu-grammar>
        <p>这些受限产生式的实际效果：</p>
        <ul>
          <li>
            当遇到可被解析为后缀 `++` 或 `--` 运算符的记号，且其与前一记号之间至少有一个 |LineTerminator|，则在该运算符前自动插入分号。
          </li>
          <li>
            当遇到 `continue`、`break`、`return`、`throw` 或 `yield`，且其后一个记号前存在 |LineTerminator|，则在该关键字后自动插入分号。
          </li>
          <li>
            当箭头函数参数后紧跟的 `=>` 前出现 |LineTerminator| 时，自动插入分号并导致该 `=>` 处语法错误。
          </li>
          <li>
            当 `async` 后在期望的 `function`、|IdentifierName| 或 `(` 之前出现 |LineTerminator|，自动插入分号且后续不再与该 `async` 归为同一表达式或类元素。
          </li>
          <li>
            当 `async` 后在期望的 `*` 之前出现 |LineTerminator|，自动插入分号并导致该标点语法错误。
          </li>
        </ul>
        <p>对程序员的实践建议：</p>
        <ul>
          <li>
            后缀 `++` / `--` 应与其操作数位于同一行。
          </li>
          <li>
            `return`、`throw` 语句中的 |Expression| 或 `yield` 表达式中的 |AssignmentExpression| 应与关键字位于同一行。
          </li>
          <li>
            `break`、`continue` 语句中的 |LabelIdentifier| 应与各自关键字在同一行。
          </li>
          <li>
            箭头函数参数部分结尾与 `=>` 应位于同一行。
          </li>
          <li>
            异步函数或方法前的 `async` 应与紧随其后的记号在同一行。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>自动分号插入示例 (Examples of Automatic Semicolon Insertion)</h1>
      <em>本节为非规范性内容。</em>
      <p>源码</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>即便考虑自动分号插入规则，也不是有效 ECMAScript 语句。相比之下，源码</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>也不是有效语句，但会被自动分号插入转换为：</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>其为有效语句。</p>
      <p>源码</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>不是有效语句，且不会被修改，因为分号对 `for` 头部必要；自动分号插入不会插入 `for` 头部的两个分号之一。</p>
      <p>源码</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>被转换为：</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>`a + b` 不作为 `return` 语句返回值，因为 |LineTerminator| 将其与 `return` 分隔。</p>
      </emu-note>
      <p>源码</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>转换为：</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>`++` 不作为应用于 `b` 的后缀运算符，因为 `b` 与 `++` 之间存在 |LineTerminator|。</p>
      </emu-note>
      <p>源码</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>不是有效语句，且在 `else` 前不会自动插入分号，即便此处没有适用的语法产生式，因为插入分号会形成空语句。</p>
      <p>源码</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p><em>不会</em> 被转换，因为第二行以括号表达式开始可被解释为函数调用的实参列表：</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>若赋值语句必须以左括号开始，建议在前一语句末尾显式写分号，而不是依赖自动分号插入。</p>
    </emu-clause>

    <emu-clause id="sec-interesting-cases-of-automatic-semicolon-insertion">
      <h1>自动分号插入的有趣情形 (Interesting Cases of Automatic Semicolon Insertion)</h1>
      <em>本节为非规范性内容。</em>
      <p>ECMAScript 程序可以通过依赖自动分号插入以极少分号的风格编写。如前述，分号不会在每个换行处插入，并且插入可能依赖跨行的多个记号。</p>

      <p>随着新语法特性的加入，可能增加新的产生式，使之前依赖自动分号插入的行在解析时改变其产生式。</p>

      <p>本节中，若某处是否插入分号取决于其前源码，则视为“有趣”情形。剩余内容描述本版本 ECMAScript 中若干此类情形。</p>

      <emu-clause id="sec-asi-interesting-cases-in-statement-lists">
        <h1>语句列表中的自动分号插入有趣情形 (Interesting Cases ... in Statement Lists)</h1>
        <p>在 |StatementList| 中，许多 |StatementListItem| 以可省略的分号结尾。根据上述规则，在一行表达式结尾处，若下一行以以下任一开头则需要分号：</p>
        <ul>
          <li><strong>左括号 (<code>(</code>)</strong>。缺少分号会将两行合并为 |CallExpression|。</li>
          <li><strong>左方括号 (<code>[</code>)</strong>。缺少分号会解析为属性访问而非 |ArrayLiteral| 或 |ArrayAssignmentPattern|。</li>
          <li><strong>模板字面量 (<code>`</code>)</strong>。缺少分号会合并为带前一个表达式为 |MemberExpression| 的标签模板（<emu-xref href="#sec-tagged-templates"></emu-xref>）。</li>
          <li><strong>一元 <code>+</code> 或 <code>-</code></strong>。缺少分号会被解释为相应二元运算的一部分。</li>
          <li><strong>正则表达式字面量</strong>。缺少分号时，若正则含标志，可能被解析为 `/` |MultiplicativeOperator|。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-asi-cases-with-no-lineterminator-here">
        <h1>与 “[no |LineTerminator| here]” 相关的自动分号插入情形 (Cases ... “[no |LineTerminator| here]”)</h1>
        <em>本节为非规范性内容。</em>
        <p>ECMAScript 包含含 “[no |LineTerminator| here]” 的语法产生式。这些产生式有时用于在语法中表达可选操作数。在这些位置引入 |LineTerminator| 会通过采用不含可选操作数的产生式改变源码的语法结构。</p>

        <p>本节其余内容描述本版本中使用 “[no |LineTerminator| here]” 的若干产生式。</p>

        <emu-clause id="sec-no-lineterminator-here-automatic-semicolon-insertion-list">
          <h1>含可选操作数与 “[no |LineTerminator| here]” 的产生式列表</h1>
          <ul>
            <li>|UpdateExpression|。</li>
            <li>|ContinueStatement|。</li>
            <li>|BreakStatement|。</li>
            <li>|ReturnStatement|。</li>
            <li>|YieldExpression|。</li>
            <li>异步函数定义（<emu-xref href="#sec-async-function-definitions"></emu-xref>）与函数定义（<emu-xref href="#sec-function-definitions"></emu-xref>）的关系。</li>
          </ul>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript 语言：表达式 (ECMAScript Language: Expressions)</h1>

  <emu-clause id="sec-identifiers">
    <h1>标识符 (Identifiers)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      IdentifierReference[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      BindingIdentifier[Yield, Await] :
        Identifier
        `yield`
        `await`

      LabelIdentifier[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      Identifier :
        IdentifierName but not ReservedWord
    </emu-grammar>

    <emu-note>
      <p>`yield` 与 `await` 在语法中被允许作为 |BindingIdentifier|，稍后通过静态语义禁止，是为了阻止在如下情形发生自动分号插入：</p>
      <pre><code class="javascript">
        let
        await 0;
      </code></pre>
    </emu-note>

    <emu-clause id="sec-identifiers-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <ul>
        <li>
          若 IsStrict(this production) 为 *true* 且 |Identifier| 的 StringValue 为 *"arguments"* 或 *"eval"*，则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          若 IsStrict(this production) 为 *true* 则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          若句法语法的目标符号为 |Module| 则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `yield`
      </emu-grammar>
      <ul>
        <li>
          若此产生式具有 <sub>[Yield]</sub> 参数则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `await`
      </emu-grammar>
      <ul>
        <li>
          若此产生式具有 <sub>[Await]</sub> 参数则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference[Yield, Await] : Identifier

        BindingIdentifier[Yield, Await] : Identifier

        LabelIdentifier[Yield, Await] : Identifier
      </emu-grammar>
      <ul>
        <li>
          若此产生式具有 <sub>[Yield]</sub> 参数且 |Identifier| 的 StringValue 为 *"yield"*，则为语法错误。
        </li>
        <li>
          若此产生式具有 <sub>[Await]</sub> 参数且 |Identifier| 的 StringValue 为 *"await"*，则为语法错误。
        </li>
      </ul>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <ul>
        <li>
          若 IsStrict(this phrase) 为 *true* 且 |IdentifierName| 的 StringValue 为 *"implements"*、*"interface"*、*"let"*、*"package"*、*"private"*、*"protected"*、*"public"*、*"static"* 或 *"yield"* 之一，则为语法错误。
        </li>
        <li>
          若句法语法目标符号为 |Module| 且 |IdentifierName| 的 StringValue 为 *"await"*，则为语法错误。
        </li>
        <li>
          若 |IdentifierName| 的 StringValue 等于某 |ReservedWord| 的 StringValue 且该 |ReservedWord| 不是 `yield` 或 `await`，则为语法错误。
        </li>
      </ul>
      <emu-note>
        <p>|IdentifierName| 的 StringValue 会规范化其中的任意 Unicode 转义序列，因此不能通过转义来写出与某 |ReservedWord| 码点序列相同的 |Identifier|。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-stringvalue" oldids="sec-identifiers-static-semantics-stringvalue,sec-identifier-names-static-semantics-stringvalue" type="sdo">
      <h1>静态语义：StringValue ( ): 一个 String</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        IdentifierName ::
          IdentifierStart
          IdentifierName IdentifierPart
      </emu-grammar>
      <emu-alg>
        1. 令 _idTextUnescaped_ 为 |IdentifierName| 的 IdentifierCodePoints。
        1. 返回 CodePointsToString(_idTextUnescaped_)。
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <emu-alg>
        1. 返回 *"yield"*。
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <emu-alg>
        1. 返回 *"await"*。
      </emu-alg>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <emu-alg>
        1. 返回 |IdentifierName| 的 StringValue。
      </emu-alg>
      <emu-grammar>
        PrivateIdentifier ::
          `#` IdentifierName
      </emu-grammar>
      <emu-alg>
        1. 返回 0x0023 (NUMBER SIGN) 与 |IdentifierName| 的 StringValue 的字符串连接。
      </emu-alg>
      <emu-grammar>
        ModuleExportName : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. 返回 |StringLiteral| 的 SV。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. 返回 ? ResolveBinding(StringValue of |Identifier|)。
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. 返回 ? ResolveBinding(*"yield"*)。
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. 返回 ? ResolveBinding(*"await"*)。
      </emu-alg>
      <emu-note>
        <p>对一个 |IdentifierReference| 求值的结果总是 Reference 类型的值。</p>
      </emu-note>
      <emu-note>
        <p>在非严格代码中，关键字 `yield` 可以作为标识符使用。对该 |IdentifierReference| 求值会解析 `yield` 的绑定，好像它是一个普通 |Identifier|。早期错误限制保证此求值只会出现在非严格代码。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-primary-expression">
    <h1>基础表达式 (Primary Expression)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        AsyncGeneratorExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await, ~Tagged]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>补充语法 (Supplemental Syntax)</h2>
    <p>
      当处理产生式实例：<br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      时，使用如下语法细化对 |CoverParenthesizedExpressionAndArrowParameterList| 的解释：
    </p>
    <emu-grammar type="definition">
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-this-keyword">
      <h1>`this` 关键字 (The `this` Keyword)</h1>

      <emu-clause id="sec-this-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. 返回 ? ResolveThisBinding()。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifier-reference">
      <h1>标识符引用 (Identifier Reference)</h1>
      <p>关于 |IdentifierReference| 见 <emu-xref href="#sec-identifiers"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-literals">
      <h1>字面量 (Literals)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        Literal :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-literals-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>Literal : NullLiteral</emu-grammar>
        <emu-alg>
          1. 返回 *null*。
        </emu-alg>
        <emu-grammar>Literal : BooleanLiteral</emu-grammar>
        <emu-alg>
          1. 若 |BooleanLiteral| 为记号 `false`，返回 *false*。
          1. 若 |BooleanLiteral| 为记号 `true`，返回 *true*。
        </emu-alg>
        <emu-grammar>Literal : NumericLiteral</emu-grammar>
        <emu-alg>
          1. 返回 <emu-xref href="#sec-literals-numeric-literals"></emu-xref> 中定义的 |NumericLiteral| 的 NumericValue。
        </emu-alg>
        <emu-grammar>Literal : StringLiteral</emu-grammar>
        <emu-alg>
          1. 返回 <emu-xref href="#sec-static-semantics-sv"></emu-xref> 中定义的 |StringLiteral| 的 SV。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-initializer">
      <h1>数组初始化器 (Array Initializer)</h1>
      <emu-note>
        <p>|ArrayLiteral| 是描述数组初始化的表达式：一个由零个或多个表达式（各代表一个数组元素）构成的列表，置于方括号内。元素不必是字面量；数组初始化器每次求值都会重新求各元素表达式。</p>
      </emu-note>
      <p>数组元素可在列表的开头、中间或结尾省略。若元素列表中的一个逗号未被 |AssignmentExpression| 前导（例如在开头或跟在另一个逗号后），则缺失的数组元素会计入 Array 的 length 并增加后续元素索引。被省略的数组元素未定义。若在数组末尾省略元素，该元素不计入 Array 的 length。</p>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]
          Elision? SpreadElement[?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-arrayaccumulation" oldids="sec-static-semantics-elisionwidth" type="sdo">
        <h1>
          运行时语义：ArrayAccumulation (Runtime Semantics: ArrayAccumulation) (
          _array_: 一个 Array,
          _nextIndex_: 一个整数,
          ): 返回一个含整数的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. 令 _len_ 为 _nextIndex_ + 1。
          1. 执行 ? Set(_array_, *"length"*, 𝔽(_len_), *true*)。
          1. 注：若 _len_ 超过 2<sup>32</sup> - 1，上一步会抛出。
          1. 返回 _len_。
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. 返回 ? ArrayAccumulation of |Elision| with arguments _array_ and (_nextIndex_ + 1)。
        </emu-alg>
        <emu-grammar>ElementList : Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 若存在 |Elision|，则
            1. 将 _nextIndex_ 设为 ? ArrayAccumulation of |Elision|，参数 _array_ 与 _nextIndex_。
          1. 令 _initResult_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _initValue_ 为 ? GetValue(_initResult_)。
          1. 执行 ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_)。
          1. 返回 _nextIndex_ + 1。
        </emu-alg>
        <emu-grammar>ElementList : Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. 若存在 |Elision|，则
            1. 将 _nextIndex_ 设为 ? ArrayAccumulation of |Elision|，参数 _array_ 与 _nextIndex_。
          1. 返回 ? ArrayAccumulation of |SpreadElement|，参数 _array_ 与 _nextIndex_。
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 将 _nextIndex_ 设为 ? ArrayAccumulation of |ElementList|，参数 _array_ 与 _nextIndex_。
          1. 若存在 |Elision|，则
            1. 将 _nextIndex_ 设为 ? ArrayAccumulation of |Elision|，参数 _array_ 与 _nextIndex_。
          1. 令 _initResult_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _initValue_ 为 ? GetValue(_initResult_)。
          1. 执行 ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_)。
          1. 返回 _nextIndex_ + 1。
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. 将 _nextIndex_ 设为 ? ArrayAccumulation of |ElementList|，参数 _array_ 与 _nextIndex_。
          1. 若存在 |Elision|，则
            1. 将 _nextIndex_ 设为 ? ArrayAccumulation of |Elision|，参数 _array_ 与 _nextIndex_。
          1. 返回 ? ArrayAccumulation of |SpreadElement|，参数 _array_ 与 _nextIndex_。
        </emu-alg>
        <emu-grammar>SpreadElement : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _spreadRef_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _spreadObj_ 为 ? GetValue(_spreadRef_)。
          1. 令 _iteratorRecord_ 为 ? GetIterator(_spreadObj_, ~sync~)。
          1. 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 若 _next_ 为 ~done~，返回 _nextIndex_。
            1. 执行 ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_)。
            1. 将 _nextIndex_ 设为 _nextIndex_ + 1。
        </emu-alg>
        <emu-note>
          <p>使用 CreateDataPropertyOrThrow 以确保即使内置 Array 原型对象被修改（导致用 [[Set]] 无法创建新自有属性），数组自有属性仍能被定义。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ArrayLiteral : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. 令 _array_ 为 ! ArrayCreate(0)。
          1. 若存在 |Elision|，则
            1. 执行 ? ArrayAccumulation of |Elision|，参数 _array_ 与 0。
          1. 返回 _array_。
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `]`</emu-grammar>
        <emu-alg>
          1. 令 _array_ 为 ! ArrayCreate(0)。
          1. 执行 ? ArrayAccumulation of |ElementList|，参数 _array_ 与 0。
          1. 返回 _array_。
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. 令 _array_ 为 ! ArrayCreate(0)。
          1. 令 _nextIndex_ 为 ? ArrayAccumulation of |ElementList|，参数 _array_ 与 0。
          1. 若存在 |Elision|，则
            1. 执行 ? ArrayAccumulation of |Elision|，参数 _array_ 与 _nextIndex_。
          1. 返回 _array_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>对象初始化器 (Object Initializer)</h1>
      <emu-note>
        <p>对象初始化器是描述对象初始化的表达式，其形式类似字面量。它是零个或多个属性键及其关联值的列表，置于花括号中。值不必是字面量；对象初始化器每次求值都会重新求各值。</p>
      </emu-note>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| 见 <emu-xref href="#sec-method-definitions"></emu-xref>。</p>
      </emu-note>
      <emu-note>
        <p>在某些上下文中，|ObjectLiteral| 作为更受限次级语法的覆盖语法使用。|CoverInitializedName| 产生式的存在是为了完整覆盖这些次级语法。但在期望实际 |ObjectLiteral| 的正常上下文中使用该产生式会导致早期语法错误。</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors" oldids="sec-__proto__-property-names-in-object-initializers">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            若 HasDirectSuper(|MethodDefinition|) 为 *true* 则为语法错误。
          </li>
          <li>
            若 |MethodDefinition| 的 PrivateBoundIdentifiers 非空则为语法错误。
          </li>
        </ul>
        <p>除了描述实际对象初始化器，|ObjectLiteral| 产生式也作为 |ObjectAssignmentPattern| 的覆盖语法，并可能作为 |CoverParenthesizedExpressionAndArrowParameterList| 一部分被识别。当 |ObjectLiteral| 出现在需要 |ObjectAssignmentPattern| 的上下文中时，下列早期错误规则<b>不</b>适用；初始解析 |CoverParenthesizedExpressionAndArrowParameterList| 或 |CoverCallExpressionAndAsyncArrowHead| 时也不适用。</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            若有源码匹配该产生式则为语法错误。
          </li>
        </ul>
        <emu-note>
          <p>该产生式存在是为了让 |ObjectLiteral| 作为 |ObjectAssignmentPattern| 的覆盖语法；它不可能出现在实际对象初始化器中。</p>
        </emu-note>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <ul>
          <li>
            若 |PropertyDefinitionList| 的 PropertyNameList 含有 *"__proto__"* 的重复条目，且其中至少两个来自形如 <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar> 的产生式，则为语法错误。若该 |ObjectLiteral| 位于为 ParseJSON 解析的 |Script| 中（见 ParseJSON 的 <emu-xref href="#step-json-parse-parse"></emu-xref> 步骤），不适用此规则。
          </li>
        </ul>
        <emu-note>
          <p>PropertyNameList 返回的列表不包含通过 |ComputedPropertyName| 定义的属性名。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-iscomputedpropertykey" type="sdo">
        <h1>静态语义：IsComputedPropertyKey ( ): Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-propertynamelist" type="sdo">
        <h1>静态语义：PropertyNameList ( ): 字符串列表 (a List of Strings)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinition</emu-grammar>
        <emu-alg>
          1. 令 _propName_ 为 |PropertyDefinition| 的 PropName。
          1. 若 _propName_ 为 ~empty~，返回空新列表。
          1. 返回 « _propName_ »。
        </emu-alg>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. 令 _list_ 为 |PropertyDefinitionList| 的 PropertyNameList。
          1. 令 _propName_ 为 |PropertyDefinition| 的 PropName。
          1. 若 _propName_ 为 ~empty~，返回 _list_。
          1. 返回 _list_ 与 « _propName_ » 的列表连接。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ObjectLiteral : `{` `}`</emu-grammar>
        <emu-alg>
          1. 返回 OrdinaryObjectCreate(%Object.prototype%)。
        </emu-alg>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ? PropertyDefinitionEvaluation of |PropertyDefinitionList|，参数 _obj_。
          1. 返回 _obj_。
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. 返回 |IdentifierName| 的 StringValue。
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. 返回 |StringLiteral| 的 SV。
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. 令 _nbr_ 为 |NumericLiteral| 的 NumericValue。
          1. 返回 ! ToString(_nbr_)。
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. 令 _exprValue_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _propName_ 为 ? GetValue(_exprValue_)。
          1. 返回 ? ToPropertyKey(_propName_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydefinitionevaluation" oldids="sec-object-initializer-runtime-semantics-propertydefinitionevaluation" type="sdo">
        <h1>
          运行时语义：PropertyDefinitionEvaluation (Runtime Semantics: PropertyDefinitionEvaluation) (
          _object_: 一个 Object,
          ): 返回含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. 执行 ? PropertyDefinitionEvaluation of |PropertyDefinitionList|，参数 _object_。
          1. 执行 ? PropertyDefinitionEvaluation of |PropertyDefinition|，参数 _object_。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _exprValue_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _fromValue_ 为 ? GetValue(_exprValue_)。
          1. 令 _excludedNames_ 为新空列表。
          1. 执行 ? CopyDataProperties(_object_, _fromValue_, _excludedNames_)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. 令 _propName_ 为 |IdentifierReference| 的 StringValue。
          1. 令 _exprValue_ 为 ? Evaluation of |IdentifierReference|。
          1. 令 _propValue_ 为 ? GetValue(_exprValue_)。
          1. 断言：_object_ 是普通、可扩展且无不可配置属性的对象。
          1. 执行 ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _propKey_ 为 ? Evaluation of |PropertyName|。
          1. 若此 |PropertyDefinition| 位于为 ParseJSON 求值的 |Script| 中（见 ParseJSON 的 <emu-xref href="#step-json-parse-eval"></emu-xref> 步骤），则
            1. 令 _isProtoSetter_ 为 *false*。
          1. 否则若 _propKey_ 为 *"__proto__"* 且 IsComputedPropertyKey(|PropertyName|) 为 *false*，则
            1. 令 _isProtoSetter_ 为 *true*。
          1. 否则，
            1. 令 _isProtoSetter_ 为 *false*。
          1. 若 IsAnonymousFunctionDefinition(|AssignmentExpression|) 为 *true* 且 _isProtoSetter_ 为 *false*，则
            1. 令 _propValue_ 为 ? NamedEvaluation of |AssignmentExpression|，参数 _propKey_。
          1. 否则，
            1. 令 _exprValueRef_ 为 ? Evaluation of |AssignmentExpression|。
            1. 令 _propValue_ 为 ? GetValue(_exprValueRef_)。
          1. 若 _isProtoSetter_ 为 *true*，则
            1. 若 _propValue_ 是 Object 或 _propValue_ 为 *null*，则
              1. 执行 ! <emu-meta effects="user-code">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_)。
            1. 返回 ~unused~。
          1. 断言：_object_ 是普通、可扩展且无不可配置属性的对象。
          1. 执行 ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <emu-alg>
          1. 执行 ? MethodDefinitionEvaluation of |MethodDefinition|，参数 _object_ 和 *true*。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-defining-expressions">
      <h1>定义函数的表达式 (Function Defining Expressions)</h1>
      <p>见 <emu-xref href="#sec-function-definitions"></emu-xref> 关于 <emu-grammar>PrimaryExpression : FunctionExpression</emu-grammar>。</p>
      <p>见 <emu-xref href="#sec-generator-function-definitions"></emu-xref> 关于 <emu-grammar>PrimaryExpression : GeneratorExpression</emu-grammar>。</p>
      <p>见 <emu-xref href="#sec-class-definitions"></emu-xref> 关于 <emu-grammar>PrimaryExpression : ClassExpression</emu-grammar>。</p>
      <p>见 <emu-xref href="#sec-async-function-definitions"></emu-xref> 关于 <emu-grammar>PrimaryExpression : AsyncFunctionExpression</emu-grammar>。</p>
      <p>见 <emu-xref href="#sec-async-generator-function-definitions"></emu-xref> 关于 <emu-grammar>PrimaryExpression : AsyncGeneratorExpression</emu-grammar>。</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>正则表达式字面量 (Regular Expression Literals)</h1>
      <h2>语法 (Syntax)</h2>
      <p>见 <emu-xref href="#sec-literals-regular-expression-literals"></emu-xref>。</p>

      <emu-clause id="sec-primary-expression-regular-expression-literals-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <ul>
          <li>
            若 IsValidRegularExpressionLiteral(|RegularExpressionLiteral|) 为 *false* 则为语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-isvalidregularexpressionliteral" type="abstract operation">
        <h1>
          静态语义：IsValidRegularExpressionLiteral (
            _literal_: 一个 |RegularExpressionLiteral| Parse Node,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>判断参数是否为有效的正则表达式字面量。</dd>
        </dl>
        <emu-alg>
          1. 令 _flags_ 为 _literal_ 的 FlagText。
          1. 若 _flags_ 含有除 `d`、`g`、`i`、`m`、`s`、`u`、`v`、`y` 之外任意码点，或某码点出现多次，返回 *false*。
          1. 若 _flags_ 含 `u`，设 _u_ 为 *true*；否则 *false*。
          1. 若 _flags_ 含 `v`，设 _v_ 为 *true*；否则 *false*。
          1. 令 _patternText_ 为 _literal_ 的 BodyText。
          1. 若 _u_ 为 *false* 且 _v_ 为 *false*，则
            1. 令 _stringValue_ 为 CodePointsToString(_patternText_)。
            1. 将 _patternText_ 设为解释 _stringValue_ 的每个 16 位元素为 Unicode BMP 码点后的码点序列（不执行 UTF-16 解码组合）。
          1. 令 _parseResult_ 为 ParsePattern(_patternText_, _u_, _v_)。
          1. 若 _parseResult_ 是 Parse Node，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regular-expression-literals-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <emu-alg>
          1. 令 _pattern_ 为 CodePointsToString(BodyText of |RegularExpressionLiteral|)。
          1. 令 _flags_ 为 CodePointsToString(FlagText of |RegularExpressionLiteral|)。
          1. 返回 ! RegExpCreate(_pattern_, _flags_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literals">
      <h1>模板字面量 (Template Literals)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        TemplateLiteral[Yield, Await, Tagged] :
          NoSubstitutionTemplate
          SubstitutionTemplate[?Yield, ?Await, ?Tagged]

        SubstitutionTemplate[Yield, Await, Tagged] :
          TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

        TemplateSpans[Yield, Await, Tagged] :
          TemplateTail
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

        TemplateMiddleList[Yield, Await, Tagged] :
          TemplateMiddle Expression[+In, ?Yield, ?Await]
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-template-early-errors" oldids="sec-primary-expression-template-literals-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
        </emu-grammar>
        <ul>
          <li>
            若未设置 <sub>[Tagged]</sub> 参数且 |NoSubstitutionTemplate| Contains |NotEscapeSequence|，则为语法错误。
          </li>
        </ul>

        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            若以 *false* 为参数的 |TemplateLiteral| 的 TemplateStrings 中元素数 ≥ 2<sup>32</sup>，则为语法错误。
          </li>
        </ul>

        <emu-grammar>
          SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            若未设置 <sub>[Tagged]</sub> 参数且 |TemplateHead| Contains |NotEscapeSequence|，则为语法错误。
          </li>
        </ul>

        <emu-grammar>
          TemplateSpans[Yield, Await, Tagged] : TemplateTail
        </emu-grammar>
        <ul>
          <li>
            若未设置 <sub>[Tagged]</sub> 参数且 |TemplateTail| Contains |NotEscapeSequence|，则为语法错误。
          </li>
        </ul>

        <emu-grammar>
          TemplateMiddleList[Yield, Await, Tagged] :
            TemplateMiddle Expression[+In, ?Yield, ?Await]
            TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        </emu-grammar>
        <ul>
          <li>
            若未设置 <sub>[Tagged]</sub> 参数且 |TemplateMiddle| Contains |NotEscapeSequence|，则为语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-templatestrings" type="sdo">
        <h1>
          静态语义：TemplateStrings (Static Semantics: TemplateStrings) (
          _raw_: Boolean,
          ): 一个由 String 或 *undefined* 组成的列表
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. 返回 « TemplateString(|NoSubstitutionTemplate|, _raw_) »。
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. 令 _head_ 为 « TemplateString(|TemplateHead|, _raw_) »。
          1. 令 _tail_ 为 |TemplateSpans| 的 TemplateStrings，参数 _raw_。
          1. 返回 _head_ 与 _tail_ 的列表连接。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. 返回 « TemplateString(|TemplateTail|, _raw_) »。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. 令 _middle_ 为 |TemplateMiddleList| 的 TemplateStrings，参数 _raw_。
          1. 令 _tail_ 为 « TemplateString(|TemplateTail|, _raw_) »。
          1. 返回 _middle_ 与 _tail_ 的列表连接。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. 返回 « TemplateString(|TemplateMiddle|, _raw_) »。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. 令 _front_ 为 |TemplateMiddleList| 的 TemplateStrings，参数 _raw_。
          1. 令 _last_ 为 « TemplateString(|TemplateMiddle|, _raw_) »。
          1. 返回 _front_ 与 _last_ 的列表连接。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-templatestring" type="abstract operation">
        <h1>
          静态语义：TemplateString (Static Semantics: TemplateString) (
          _templateToken_: 一个 |NoSubstitutionTemplate|、|TemplateHead|、|TemplateMiddle| 或 |TemplateTail| Parse Node,
          _raw_: Boolean,
          ): 一个 String 或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _raw_ 为 *true*，则
            1. 令 _string_ 为 _templateToken_ 的 TRV。
          1. 否则，
            1. 令 _string_ 为 _templateToken_ 的 TV。
          1. 返回 _string_。
        </emu-alg>
        <emu-note>
          <p>若 _raw_ 为 *false* 且 _templateToken_ 含 |NotEscapeSequence|，该操作返回 *undefined*；其它情况返回 String。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-gettemplateobject" type="abstract operation">
        <h1>
          GetTemplateObject (
            _templateLiteral_: 一个 Parse Node,
          ): 一个 Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _realm_ 为当前 Realm Record。
          1. 令 _templateRegistry_ 为 _realm_.[[TemplateMap]]。
          1. 对 _templateRegistry_ 中每个元素 _e_：
            1. 若 _e_.[[Site]] 与 _templateLiteral_ 是同一 Parse Node，则
              1. 返回 _e_.[[Array]]。
          1. 令 _rawStrings_ 为 _templateLiteral_ 的 TemplateStrings，参数 *true*。
          1. 断言：_rawStrings_ 是 String 列表。
          1. 令 _cookedStrings_ 为 _templateLiteral_ 的 TemplateStrings，参数 *false*。
          1. 令 _count_ 为 _cookedStrings_ 元素数量。
          1. 断言：_count_ ≤ 2<sup>32</sup> - 1。
          1. 令 _template_ 为 ! ArrayCreate(_count_)。
          1. 令 _rawObj_ 为 ! ArrayCreate(_count_)。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _count_ 重复：
            1. 令 _prop_ 为 ! ToString(𝔽(_index_))。
            1. 令 _cookedValue_ 为 _cookedStrings_[_index_]。
            1. 执行 ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* })。
            1. 令 _rawValue_ 为 _rawStrings_[_index_] 的 String 值。
            1. 执行 ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* })。
            1. 将 _index_ 设为 _index_ + 1。
          1. 执行 ! SetIntegrityLevel(_rawObj_, ~frozen~)。
          1. 执行 ! DefinePropertyOrThrow(_template_, *"raw"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 执行 ! SetIntegrityLevel(_template_, ~frozen~)。
          1. 将记录 { [[Site]]: _templateLiteral_, [[Array]]: _template_ } 附加到 _realm_.[[TemplateMap]]。
          1. 返回 _template_。
        </emu-alg>
        <emu-note>
          <p>创建模板对象不会导致突然完成。</p>
        </emu-note>
        <emu-note>
          <p>同一 realm 中程序代码里的每个 |TemplateLiteral| 关联一个用于求值标签模板（<emu-xref href="#sec-template-literals-runtime-semantics-evaluation"></emu-xref>）的唯一模板对象。模板对象被冻结；同一标签模板每次求值复用同一个模板对象。是首次求值惰性创建还是提前创建是实现细节，对 ECMAScript 代码不可观察。</p>
        </emu-note>
        <emu-note>
          <p>规范未来版本可能为模板对象定义额外不可枚举属性。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-substitutionevaluation" type="sdo">
        <h1>运行时语义：SubstitutionEvaluation ( ): 返回含 ECMAScript 语言值列表的正常完成或一个突然完成</h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. 返回 ? SubstitutionEvaluation of |TemplateMiddleList|。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. 令 _subRef_ 为 ? Evaluation of |Expression|。
          1. 令 _sub_ 为 ? GetValue(_subRef_)。
          1. 返回 « _sub_ »。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. 令 _preceding_ 为 ? SubstitutionEvaluation of |TemplateMiddleList|。
          1. 令 _nextRef_ 为 ? Evaluation of |Expression|。
          1. 令 _next_ 为 ? GetValue(_nextRef_)。
          1. 返回 _preceding_ 与 « _next_ » 的列表连接。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. 返回 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 中定义的 |NoSubstitutionTemplate| 的 TV。
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. 令 _head_ 为 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 中定义的 |TemplateHead| 的 TV。
          1. 令 _subRef_ 为 ? Evaluation of |Expression|。
          1. 令 _sub_ 为 ? GetValue(_subRef_)。
          1. 令 _middle_ 为 ? ToString(_sub_)。
          1. 令 _tail_ 为 ? Evaluation of |TemplateSpans|。
          1. 返回 _head_、_middle_ 与 _tail_ 的字符串连接。
        </emu-alg>
        <emu-note>
          <p>对 |Expression| 值的字符串转换语义类似 `String.prototype.concat` 而非 `+` 运算符。</p>
        </emu-note>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. 返回 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 中定义的 |TemplateTail| 的 TV。
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. 令 _head_ 为 ? Evaluation of |TemplateMiddleList|。
          1. 令 _tail_ 为 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 中定义的 |TemplateTail| 的 TV。
          1. 返回 _head_ 与 _tail_ 的字符串连接。
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. 令 _head_ 为 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 中定义的 |TemplateMiddle| 的 TV。
          1. 令 _subRef_ 为 ? Evaluation of |Expression|。
          1. 令 _sub_ 为 ? GetValue(_subRef_)。
          1. 令 _middle_ 为 ? ToString(_sub_)。
          1. 返回 _head_ 与 _middle_ 的字符串连接。
        </emu-alg>
        <emu-note>
          <p>对 |Expression| 值的字符串转换语义类似 `String.prototype.concat` 而非 `+` 运算符。</p>
        </emu-note>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. 令 _rest_ 为 ? Evaluation of |TemplateMiddleList|。
          1. 令 _middle_ 为 <emu-xref href="#sec-template-literal-lexical-components"></emu-xref> 中定义的 |TemplateMiddle| 的 TV。
          1. 令 _subRef_ 为 ? Evaluation of |Expression|。
          1. 令 _sub_ 为 ? GetValue(_subRef_)。
          1. 令 _last_ 为 ? ToString(_sub_)。
          1. 返回 _rest_、_middle_、_last_ 的字符串连接。
        </emu-alg>
        <emu-note>
          <p>对 |Expression| 值的字符串转换语义类似 `String.prototype.concat` 而非 `+` 运算符。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-grouping-operator">
      <h1>分组运算符 (The Grouping Operator)</h1>

      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            |CoverParenthesizedExpressionAndArrowParameterList| 必须覆盖一个 |ParenthesizedExpression|。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
          1. 返回 ? Evaluation of _expr_。
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. 返回 ? Evaluation of |Expression|。其结果可能是 Reference 类型。
        </emu-alg>
        <emu-note>
          <p>该算法不对 |Expression| 的 Evaluation 结果执行 GetValue。其主要动机是允许对括号表达式应用 `delete`、`typeof` 等运算符。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>左值表达式 (Left-Hand-Side Expressions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget
        ImportMeta

      NewTarget :
        `new` `.` `target`

      ImportMeta :
        `import` `.` `meta`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      OptionalExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

      OptionalChain[Yield, Await] :
        `?.` Arguments[?Yield, ?Await]
        `?.` `[` Expression[+In, ?Yield, ?Await] `]`
        `?.` IdentifierName
        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]
        `?.` PrivateIdentifier
        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        OptionalChain[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        OptionalChain[?Yield, ?Await] `.` IdentifierName
        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        OptionalChain[?Yield, ?Await] `.` PrivateIdentifier

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>补充语法 (Supplemental Syntax)</h2>
    <p>
      当处理产生式实例：<br>
      <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar><br>
      时，使用下列语法细化对 |CoverCallExpressionAndAsyncArrowHead| 的解释：
    </p>
    <emu-grammar type="definition">
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics">
      <h1>静态语义 (Static Semantics)</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>
          OptionalChain :
            `?.` TemplateLiteral
            OptionalChain TemplateLiteral
        </emu-grammar>
        <ul>
          <li>
            若有源码匹配该产生式则为语法错误。
          </li>
        </ul>
        <emu-note>
          <p>该产生式存在是为了阻止自动分号插入规则（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）应用于以下代码：</p>
          <pre><code class="javascript">
            a?.b
            `c`
          </code></pre>
          <p>使其被解释为两个合法语句。其目的在于与没有可选链的类似代码保持一致：</p>
          <pre><code class="javascript">
            a.b
            `c`
          </code></pre>
          <p>后者是一个合法语句，且自动分号插入不适用。</p>
        </emu-note>

        <emu-grammar>
          ImportMeta :
            `import` `.` `meta`
        </emu-grammar>
        <ul>
          <li>
            若句法目标符号不是 |Module| 则为语法错误。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-accessors">
      <h1>属性访问器 (Property Accessors)</h1>
      <emu-note>
        <p>属性按名称访问，可以使用点号表示法：</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|<br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>也可以使用方括号表示法：</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`<br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>点号表示法可以通过以下句法转换来解释：</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>其行为与</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>相同；类似地</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>其行为与</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>相同，其中 &lt;<i>identifier-name-string</i>> 为 |IdentifierName| 的 StringValue。</p>
      </emu-note>

      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |MemberExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 令 _strict_ 为 IsStrict(this |MemberExpression|)。
          1. 返回 ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_)。
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |MemberExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 令 _strict_ 为 IsStrict(this |MemberExpression|)。
          1. 返回 EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_)。
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |MemberExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 令 _fieldNameString_ 为 |PrivateIdentifier| 的 StringValue。
          1. 返回 MakePrivateReference(_baseValue_, _fieldNameString_)。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |CallExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 令 _strict_ 为 IsStrict(this |CallExpression|)。
          1. 返回 ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_)。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |CallExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 令 _strict_ 为 IsStrict(this |CallExpression|)。
          1. 返回 EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_)。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |CallExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 令 _fieldNameString_ 为 |PrivateIdentifier| 的 StringValue。
          1. 返回 MakePrivateReference(_baseValue_, _fieldNameString_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-expression-key" type="abstract operation" oldids="sec-evaluate-expression-key-property-access">
      <h1>
        EvaluatePropertyAccessWithExpressionKey (
          _baseValue_: 一个 ECMAScript 语言值,
          _expression_: 一个 |Expression| Parse Node,
          _strict_: 一个 Boolean,
        ): 返回一个含 Reference Record 的正常完成或一个突然完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _propertyNameReference_ 为 ? Evaluation of _expression_。
        1. 令 _propertyNameValue_ 为 ? GetValue(_propertyNameReference_)。
        1. 注：在大多数情况下，会在此步骤后立即对 _propertyNameValue_ 执行 ToPropertyKey。但在 `a[b] = c` 的情形下，会延迟到 `c` 求值之后。
        1. 返回 Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameValue_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-identifier-key" type="abstract operation" oldids="sec-evaluate-identifier-key-property-access">
      <h1>
        EvaluatePropertyAccessWithIdentifierKey (
          _baseValue_: 一个 ECMAScript 语言值,
          _identifierName_: 一个 |IdentifierName| Parse Node,
          _strict_: 一个 Boolean,
        ): 一个 Reference Record
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _propertyNameString_ 为 _identifierName_ 的 StringValue。
        1. 返回 Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-new-operator">
      <h1>`new` 运算符 (The `new` Operator)</h1>

      <emu-clause id="sec-new-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateNew(|NewExpression|, ~empty~)。
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateNew(|MemberExpression|, |Arguments|)。
        </emu-alg>

        <emu-clause id="sec-evaluatenew" type="abstract operation">
          <h1>
            EvaluateNew (
              _constructExpr_: 一个 |NewExpression| Parse Node 或 |MemberExpression| Parse Node,
              _arguments_: ~empty~ 或一个 |Arguments| Parse Node,
            ): 返回一个含 ECMAScript 语言值的正常完成或一个突然完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _ref_ 为 ? Evaluation of _constructExpr_。
            1. 令 _constructor_ 为 ? GetValue(_ref_)。
            1. 若 _arguments_ 为 ~empty~，则
              1. 令 _argList_ 为新空列表。
            1. 否则，
              1. 令 _argList_ 为 ? ArgumentListEvaluation of _arguments_。
            1. 若 IsConstructor(_constructor_) 为 *false*，抛出 *TypeError* 异常。
            1. 返回 ? Construct(_constructor_, _argList_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-calls">
      <h1>函数调用 (Function Calls)</h1>

      <emu-clause id="sec-function-calls-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 |CoverCallExpressionAndAsyncArrowHead| 覆盖的 |CallMemberExpression|。
          1. 令 _memberExpr_ 为 _expr_ 的 |MemberExpression|。
          1. 令 _arguments_ 为 _expr_ 的 |Arguments|。
          1. 令 _ref_ 为 ? Evaluation of _memberExpr_。
          1. 令 _func_ 为 ? GetValue(_ref_)。
          1. 若 _ref_ 是 Reference Record，IsPropertyReference(_ref_) 为 *false*，且 _ref_.[[ReferencedName]] 为 *"eval"*，则
            1. 若 SameValue(_func_, %eval%) 为 *true*，则
              1. 令 _argList_ 为 ? ArgumentListEvaluation of _arguments_。
              1. 若 _argList_ 无元素，返回 *undefined*。
              1. 令 _evalArg_ 为 _argList_ 的第一个元素。
              1. 若 IsStrict(this |CallExpression|) 为 *true*，令 _strictCaller_ 为 *true*；否则为 *false*。
              1. [id="step-callexpression-evaluation-direct-eval"] 返回 ? PerformEval(_evalArg_, _strictCaller_, *true*)。
          1. 令 _thisCall_ 为 this |CallExpression|。
          1. 令 _tailCall_ 为 IsInTailPosition(_thisCall_)。
          1. 返回 ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_)。
        </emu-alg>
        <p>执行步骤 <emu-xref href="#step-callexpression-evaluation-direct-eval"></emu-xref> 的 |CallExpression| 求值是一次<dfn variants="direct evals">直接 eval (direct eval)</dfn>。</p>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. 令 _ref_ 为 ? Evaluation of |CallExpression|。
          1. 令 _func_ 为 ? GetValue(_ref_)。
          1. 令 _thisCall_ 为 this |CallExpression|。
          1. 令 _tailCall_ 为 IsInTailPosition(_thisCall_)。
          1. 返回 ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluatecall" type="abstract operation" oldids="sec-evaluatedirectcall">
        <h1>
          EvaluateCall (
            _func_: 一个 ECMAScript 语言值,
            _ref_: 一个 ECMAScript 语言值或 Reference Record,
            _arguments_: 一个 Parse Node,
            _tailPosition_: 一个 Boolean,
          ): 返回一个含 ECMAScript 语言值的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _ref_ 是 Reference Record，则
            1. 若 IsPropertyReference(_ref_) 为 *true*，则
              1. 令 _thisValue_ 为 GetThisValue(_ref_)。
            1. 否则，
              1. 令 _refEnv_ 为 _ref_.[[Base]]。
              1. 断言：_refEnv_ 是一个 Environment Record。
              1. 令 _thisValue_ 为 _refEnv_.WithBaseObject()。
          1. 否则，
            1. 令 _thisValue_ 为 *undefined*。
          1. 令 _argList_ 为 ? ArgumentListEvaluation of _arguments_。
          1. 若 _func_ 不是 Object，抛出 *TypeError* 异常。
          1. 若 IsCallable(_func_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _tailPosition_ 为 *true*，执行 PrepareForTailCall()。
          1. 返回 ? Call(_func_, _thisValue_, _argList_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-super-keyword">
      <h1>`super` 关键字 (The `super` Keyword)</h1>

      <emu-clause id="sec-super-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>SuperProperty : `super` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. 令 _env_ 为 GetThisEnvironment()。
          1. 令 _actualThis_ 为 ? _env_.GetThisBinding()。
          1. 令 _propertyNameReference_ 为 ? Evaluation of |Expression|。
          1. 令 _propertyNameValue_ 为 ? GetValue(_propertyNameReference_)。
          1. 令 _strict_ 为 IsStrict(this |SuperProperty|)。
          1. 注：在大多数情况下，会在此步骤后立即对 _propertyNameValue_ 执行 ToPropertyKey。但在 `super[b] = c` 的情形下，会延迟到 `c` 求值后。
          1. 返回 MakeSuperPropertyReference(_actualThis_, _propertyNameValue_, _strict_)。
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. 令 _env_ 为 GetThisEnvironment()。
          1. 令 _actualThis_ 为 ? _env_.GetThisBinding()。
          1. 令 _propertyKey_ 为 |IdentifierName| 的 StringValue。
          1. 令 _strict_ 为 IsStrict(this |SuperProperty|)。
          1. 返回 MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_)。
        </emu-alg>
        <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. 令 _newTarget_ 为 GetNewTarget()。
          1. 断言：_newTarget_ 是一个构造函数。
          1. 令 _func_ 为 GetSuperConstructor()。
          1. 令 _argList_ 为 ? ArgumentListEvaluation of |Arguments|。
          1. 若 IsConstructor(_func_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _result_ 为 ? Construct(_func_, _argList_, _newTarget_)。
          1. 令 _thisER_ 为 GetThisEnvironment()。
          1. 断言：_thisER_ 是一个 Function Environment Record。
          1. 执行 ? BindThisValue(_thisER_, _result_)。
          1. 令 _F_ 为 _thisER_.[[FunctionObject]]。
          1. 断言：_F_ 是一个 ECMAScript 函数对象。
          1. 执行 ? InitializeInstanceElements(_result_, _F_)。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getsuperconstructor" type="abstract operation">
        <h1>GetSuperConstructor ( ): 一个 ECMAScript 语言值</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _envRec_ 为 GetThisEnvironment()。
          1. 断言：_envRec_ 是一个 Function Environment Record。
          1. 令 _activeFunction_ 为 _envRec_.[[FunctionObject]]。
          1. 断言：_activeFunction_ 是一个 ECMAScript 函数对象。
          1. 令 _superConstructor_ 为 ! _activeFunction_.[[GetPrototypeOf]]()。
          1. 返回 _superConstructor_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makesuperpropertyreference" type="abstract operation">
        <h1>
          MakeSuperPropertyReference (
            _actualThis_: 一个 ECMAScript 语言值,
            _propertyKey_: 一个 ECMAScript 语言值,
            _strict_: 一个 Boolean,
          ): 一个 Super Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为 GetThisEnvironment()。
          1. 断言：_env_.HasSuperBinding() 为 *true*。
          1. 断言：_env_ 是一个 Function Environment Record。
          1. 令 _baseValue_ 为 GetSuperBase(_env_)。
          1. 返回 Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-argument-lists">
      <h1>参数列表 (Argument Lists)</h1>
      <emu-note>
        <p>对参数列表的求值会产生一个值的 List。</p>
      </emu-note>

      <emu-clause id="sec-runtime-semantics-argumentlistevaluation" oldids="sec-template-literals-runtime-semantics-argumentlistevaluation,sec-argument-lists-runtime-semantics-argumentlistevaluation" type="sdo">
        <h1>运行时语义：ArgumentListEvaluation ( ): 返回一个含 ECMAScript 语言值列表的正常完成或一个突然完成</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Arguments : `(` `)`</emu-grammar>
        <emu-alg>
          1. 返回一个新的空列表。
        </emu-alg>
        <emu-grammar>ArgumentList : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _ref_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _arg_ 为 ? GetValue(_ref_)。
          1. 返回 « _arg_ »。
        </emu-alg>
        <emu-grammar>ArgumentList : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _list_ 为新空列表。
          1. 令 _spreadRef_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _spreadObj_ 为 ? GetValue(_spreadRef_)。
          1. 令 _iteratorRecord_ 为 ? GetIterator(_spreadObj_, ~sync~)。
          1. 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 若 _next_ 为 ~done~，返回 _list_。
            1. 将 _next_ 追加到 _list_。
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _precedingArgs_ 为 ? ArgumentListEvaluation of |ArgumentList|。
          1. 令 _ref_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _arg_ 为 ? GetValue(_ref_)。
          1. 返回 _precedingArgs_ 与 « _arg_ » 的列表连接。
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. 令 _precedingArgs_ 为 ? ArgumentListEvaluation of |ArgumentList|。
          1. 令 _spreadRef_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _iteratorRecord_ 为 ? GetIterator(? GetValue(_spreadRef_), ~sync~)。
          1. 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 若 _next_ 为 ~done~，返回 _precedingArgs_。
            1. 将 _next_ 追加到 _precedingArgs_。
        </emu-alg>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. 令 _templateLiteral_ 为 this |TemplateLiteral|。
          1. 令 _siteObj_ 为 GetTemplateObject(_templateLiteral_)。
          1. 返回 « _siteObj_ »。
        </emu-alg>
        <emu-grammar>TemplateLiteral : SubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. 令 _templateLiteral_ 为 this |TemplateLiteral|。
          1. 令 _siteObj_ 为 GetTemplateObject(_templateLiteral_)。
          1. 令 _remaining_ 为 ? ArgumentListEvaluation of |SubstitutionTemplate|。
          1. 返回 « _siteObj_ » 与 _remaining_ 的列表连接。
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. 令 _firstSubRef_ 为 ? Evaluation of |Expression|。
          1. 令 _firstSub_ 为 ? GetValue(_firstSubRef_)。
          1. 令 _restSub_ 为 ? SubstitutionEvaluation of |TemplateSpans|。
          1. 断言：_restSub_ 是一个可为空的列表。
          1. 返回 « _firstSub_ » 与 _restSub_ 的列表连接。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-optional-chains">
      <h1>可选链 (Optional Chains)</h1>
      <emu-note>可选链是一个或多个属性访问与函数调用组成的链，其首个访问以 `?.` 记号开始。</emu-note>

      <emu-clause id="sec-optional-chaining-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>
          OptionalExpression :
            MemberExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |MemberExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 若 _baseValue_ 是 *undefined* 或 *null*，则
            1. 返回 *undefined*。
          1. 返回 ? ChainEvaluation of |OptionalChain|，参数 _baseValue_ 与 _baseReference_。
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            CallExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |CallExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 若 _baseValue_ 是 *undefined* 或 *null*，则
            1. 返回 *undefined*。
          1. 返回 ? ChainEvaluation of |OptionalChain|，参数 _baseValue_ 与 _baseReference_。
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            OptionalExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. 令 _baseReference_ 为 ? Evaluation of |OptionalExpression|。
          1. 令 _baseValue_ 为 ? GetValue(_baseReference_)。
          1. 若 _baseValue_ 是 *undefined* 或 *null*，则
            1. 返回 *undefined*。
          1. 返回 ? ChainEvaluation of |OptionalChain|，参数 _baseValue_ 与 _baseReference_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-optional-chaining-chain-evaluation" type="sdo">
        <h1>
          运行时语义：ChainEvaluation (Runtime Semantics: ChainEvaluation) (
          _baseValue_: 一个 ECMAScript 语言值,
          _baseReference_: 一个 ECMAScript 语言值或 Reference Record,
          ): 返回一个含 ECMAScript 语言值或 Reference Record 的正常完成，或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>
        <emu-alg>
          1. 令 _thisChain_ 为 this |OptionalChain|。
          1. 令 _tailCall_ 为 IsInTailPosition(_thisChain_)。
          1. 返回 ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_)。
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. 令 _strict_ 为 IsStrict(this |OptionalChain|)。
          1. 返回 ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_)。
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
        <emu-alg>
          1. 令 _strict_ 为 IsStrict(this |OptionalChain|)。
          1. 返回 EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_)。
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. 令 _fieldNameString_ 为 |PrivateIdentifier| 的 StringValue。
          1. 返回 MakePrivateReference(_baseValue_, _fieldNameString_)。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>
        <emu-alg>
          1. 令 _optionalChain_ 为 |OptionalChain|。
          1. 令 _newReference_ 为 ? ChainEvaluation of _optionalChain_，参数 _baseValue_ 与 _baseReference_。
          1. 令 _newValue_ 为 ? GetValue(_newReference_)。
          1. 令 _thisChain_ 为 this |OptionalChain|。
          1. 令 _tailCall_ 为 IsInTailPosition(_thisChain_)。
          1. 返回 ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_)。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. 令 _optionalChain_ 为 |OptionalChain|。
          1. 令 _newReference_ 为 ? ChainEvaluation of _optionalChain_，参数 _baseValue_ 与 _baseReference_。
          1. 令 _newValue_ 为 ? GetValue(_newReference_)。
          1. 令 _strict_ 为 IsStrict(this |OptionalChain|)。
          1. 返回 ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_)。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. 令 _optionalChain_ 为 |OptionalChain|。
          1. 令 _newReference_ 为 ? ChainEvaluation of _optionalChain_，参数 _baseValue_ 与 _baseReference_。
          1. 令 _newValue_ 为 ? GetValue(_newReference_)。
          1. 令 _strict_ 为 IsStrict(this |OptionalChain|)。
          1. 返回 EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_)。
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. 令 _optionalChain_ 为 |OptionalChain|。
          1. 令 _newReference_ 为 ? ChainEvaluation of _optionalChain_，参数 _baseValue_ 与 _baseReference_。
          1. 令 _newValue_ 为 ? GetValue(_newReference_)。
          1. 令 _fieldNameString_ 为 |PrivateIdentifier| 的 StringValue。
          1. 返回 MakePrivateReference(_newValue_, _fieldNameString_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>Import 调用 (Import Calls)</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateImportCall(|AssignmentExpression|)。
        </emu-alg>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateImportCall(第一个 |AssignmentExpression|, 第二个 |AssignmentExpression|)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          EvaluateImportCall (
          _specifierExpression_: 一个 Parse Node,
          可选 _optionsExpression_: 一个 Parse Node,
          ): 返回一个含 Promise 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _referrer_ 为 GetActiveScriptOrModule()。
          1. 若 _referrer_ 为 *null*，将 _referrer_ 设为当前 Realm Record。
          1. 令 _specifierRef_ 为 ? Evaluation of _specifierExpression_。
          1. 令 _specifier_ 为 ? GetValue(_specifierRef_)。
          1. 若存在 _optionsExpression_，则
            1. 令 _optionsRef_ 为 ? Evaluation of _optionsExpression_。
            1. 令 _options_ 为 ? GetValue(_optionsRef_)。
          1. 否则，
            1. 令 _options_ 为 *undefined*。
          1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
          1. 令 _specifierString_ 为 Completion(ToString(_specifier_))。
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_)。
          1. 令 _attributes_ 为新空列表。
          1. 若 _options_ 不为 *undefined*，则
            1. 若 _options_ 不是 Object，则
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新建的 *TypeError* 对象 »)。
              1. 返回 _promiseCapability_.[[Promise]]。
            1. 令 _attributesObj_ 为 Completion(Get(_options_, *"with"*))。
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_)。
            1. 若 _attributesObj_ 不为 *undefined*，则
              1. 若 _attributesObj_ 不是 Object，则
                1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新建的 *TypeError* 对象 »)。
                1. 返回 _promiseCapability_.[[Promise]]。
              1. 令 _entries_ 为 Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~))。
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_)。
              1. 对 _entries_ 中每个元素 _entry_：
                1. 令 _key_ 为 ! Get(_entry_, *"0"*)。
                1. 令 _value_ 为 ! Get(_entry_, *"1"*)。
                1. 若 _key_ 是 String，则
                  1. 若 _value_ 不是 String，则
                    1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新建的 *TypeError* 对象 »)。
                    1. 返回 _promiseCapability_.[[Promise]]。
                  1. 将 ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } 追加到 _attributes_。
            1. 若 AllImportAttributesSupported(_attributes_) 为 *false*，则
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 新建的 *TypeError* 对象 »)。
              1. 返回 _promiseCapability_.[[Promise]]。
            1. 按 [[Key]] 字段字典序（将字段值视为 UTF-16 代码单元序列）对 _attributes_ 排序。注：排序唯一可观察之处是宿主被禁止基于枚举顺序改变行为。
          1. 令 _moduleRequest_ 为新 ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_ }。
          1. 执行 HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_)。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            _promiseCapability_: 一个 PromiseCapability Record,
            _moduleCompletion_: 一个含 Module Record 的正常完成或一个 throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>它完成最初由 <emu-xref href="#sec-import-calls">`import()`</emu-xref> 调用开始的动态导入过程，适当地 resolve 或 reject 该调用返回的 promise。</dd>
        </dl>
        <emu-alg>
          1. 若 _moduleCompletion_ 是突然完成，则
            1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »)。
            1. 返回 ~unused~。
          1. 令 _module_ 为 _moduleCompletion_.[[Value]]。
          1. 令 _loadPromise_ 为 _module_.LoadRequestedModules()。
          1. 令 _rejectedClosure_ 为带参数 (_reason_)、捕获 _promiseCapability_ 的新抽象闭包，调用时执行：
            1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »)。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _onRejected_ 为 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »)。
          1. 令 _linkAndEvaluateClosure_ 为无参数、捕获 _module_、_promiseCapability_、_onRejected_ 的新抽象闭包，调用时执行：
            1. 令 _link_ 为 Completion(_module_.Link())。
            1. 若 _link_ 是突然完成，则
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »)。
              1. 返回 NormalCompletion(*undefined*)。
            1. 令 _evaluatePromise_ 为 _module_.Evaluate()。
            1. 令 _fulfilledClosure_ 为无参数、捕获 _module_ 与 _promiseCapability_ 的新抽象闭包，调用时执行：
              1. 令 _namespace_ 为 GetModuleNamespace(_module_)。
              1. 执行 ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »)。
              1. 返回 NormalCompletion(*undefined*)。
            1. 令 _onFulfilled_ 为 CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »)。
            1. 执行 PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_)。
            1. 返回 ~unused~。
          1. 令 _linkAndEvaluate_ 为 CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *""*, « »)。
          1. 执行 PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tagged-templates">
      <h1>带标签模板 (Tagged Templates)</h1>
      <emu-note>
        <p>带标签模板是一个函数调用，其调用参数来源于 |TemplateLiteral|（<emu-xref href="#sec-template-literals"></emu-xref>）。实际参数包含一个模板对象（<emu-xref href="#sec-gettemplateobject"></emu-xref>）以及对 |TemplateLiteral| 内嵌表达式求值得到的值。</p>
      </emu-note>

      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. 令 _tagRef_ 为 ? Evaluation of |MemberExpression|。
          1. 令 _tagFunc_ 为 ? GetValue(_tagRef_)。
          1. 令 _thisCall_ 为 this |MemberExpression|。
          1. 令 _tailCall_ 为 IsInTailPosition(_thisCall_)。
          1. 返回 ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_)。
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. 令 _tagRef_ 为 ? Evaluation of |CallExpression|。
          1. 令 _tagFunc_ 为 ? GetValue(_tagRef_)。
          1. 令 _thisCall_ 为 this |CallExpression|。
          1. 令 _tailCall_ 为 IsInTailPosition(_thisCall_)。
          1. 返回 ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-meta-properties">
      <h1>元属性 (Meta Properties)</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. 返回 GetNewTarget()。
        </emu-alg>

        <emu-grammar>ImportMeta : `import` `.` `meta`</emu-grammar>
        <emu-alg>
          1. 令 _module_ 为 GetActiveScriptOrModule()。
          1. 断言：_module_ 是一个 Source Text Module Record。
          1. 令 _importMeta_ 为 _module_.[[ImportMeta]]。
          1. 若 _importMeta_ 为 ~empty~，则
            1. 将 _importMeta_ 设为 OrdinaryObjectCreate(*null*)。
            1. 令 _importMetaValues_ 为 HostGetImportMetaProperties(_module_)。
            1. 对 _importMetaValues_ 中每个 Record { [[Key]], [[Value]] } _p_：
              1. 执行 ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]])。
            1. 执行 HostFinalizeImportMeta(_importMeta_, _module_)。
            1. 将 _module_.[[ImportMeta]] 设为 _importMeta_。
            1. 返回 _importMeta_。
          1. 否则，
            1. 断言：_importMeta_ 是一个 Object。
            1. 返回 _importMeta_。
        </emu-alg>

        <emu-clause id="sec-hostgetimportmetaproperties" type="host-defined abstract operation">
          <h1>
            HostGetImportMetaProperties (
              _moduleRecord_: 一个 Module Record,
            ): 一个具有 [[Key]]（属性键）与 [[Value]]（ECMAScript 语言值）字段的 Record 列表
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>允许宿主为 `import.meta` 返回的对象提供属性键与值。</dd>
          </dl>

          <p>HostGetImportMetaProperties 的默认实现是返回一个新的空列表。</p>
        </emu-clause>

        <emu-clause id="sec-hostfinalizeimportmeta" type="host-defined abstract operation">
          <h1>
            HostFinalizeImportMeta (
              _importMeta_: 一个 Object,
              _moduleRecord_: 一个 Module Record,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>允许宿主执行额外操作以准备将 `import.meta` 返回的对象暴露给 ECMAScript 代码。</dd>
          </dl>

          <p>大多数宿主仅需定义 HostGetImportMetaProperties，并保持 HostFinalizeImportMeta 的默认行为。但 HostFinalizeImportMeta 为需要在对象暴露前直接操作该对象的宿主提供“逃生口”。</p>

          <p>HostFinalizeImportMeta 的默认实现是返回 ~unused~。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-update-expressions">
    <h1>更新表达式 (Update Expressions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
        `++` UnaryExpression[?Yield, ?Await]
        `--` UnaryExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-update-expressions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
      </emu-grammar>
      <ul>
        <li>
          若 |LeftHandSideExpression| 的 AssignmentTargetType 为 ~invalid~，则属于早期语法错误。
        </li>
      </ul>

      <emu-grammar>
        UpdateExpression :
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <ul>
        <li>
          若 |UnaryExpression| 的 AssignmentTargetType 为 ~invalid~，则属于早期语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-postfix-increment-operator">
      <h1>后缀自增运算符 (Postfix Increment Operator)</h1>

      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. 令 _lhs_ 为 ? Evaluation of |LeftHandSideExpression|。<br>
          1. 若 |LeftHandSideExpression| 的 AssignmentTargetType 为 ~web-compat~，抛出 *ReferenceError* 异常。<br>
          1. 令 _oldValue_ 为 ? ToNumeric(? GetValue(_lhs_))。<br>
          1. 若 _oldValue_ 是 Number，则
            1. 令 _newValue_ 为 Number::add(_oldValue_, *1*<sub>𝔽</sub>)。
          1. 否则，
            1. 断言：_oldValue_ 为 BigInt。
            1. 令 _newValue_ 为 BigInt::add(_oldValue_, *1*<sub>ℤ</sub>)。
          1. 执行 ? PutValue(_lhs_, _newValue_)。
          1. 返回 _oldValue_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-postfix-decrement-operator">
      <h1>后缀自减运算符 (Postfix Decrement Operator)</h1>

      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. 令 _lhs_ 为 ? Evaluation of |LeftHandSideExpression|。<br>
          1. 若 |LeftHandSideExpression| 的 AssignmentTargetType 为 ~web-compat~，抛出 *ReferenceError* 异常。<br>
          1. 令 _oldValue_ 为 ? ToNumeric(? GetValue(_lhs_))。<br>
          1. 若 _oldValue_ 是 Number，则
            1. 令 _newValue_ 为 Number::subtract(_oldValue_, *1*<sub>𝔽</sub>)。
          1. 否则，
            1. 断言：_oldValue_ 为 BigInt。
            1. 令 _newValue_ 为 BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>)。
          1. 执行 ? PutValue(_lhs_, _newValue_)。
          1. 返回 _oldValue_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-increment-operator">
      <h1>前缀自增运算符 (Prefix Increment Operator)</h1>

      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 若 |UnaryExpression| 的 AssignmentTargetType 为 ~web-compat~，抛出 *ReferenceError* 异常。<br>
          1. 令 _oldValue_ 为 ? ToNumeric(? GetValue(_expr_))。<br>
          1. 若 _oldValue_ 是 Number，则
            1. 令 _newValue_ 为 Number::add(_oldValue_, *1*<sub>𝔽</sub>)。
          1. 否则，
            1. 断言：_oldValue_ 为 BigInt。
            1. 令 _newValue_ 为 BigInt::add(_oldValue_, *1*<sub>ℤ</sub>)。
          1. 执行 ? PutValue(_expr_, _newValue_)。
          1. 返回 _newValue_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-decrement-operator">
      <h1>前缀自减运算符 (Prefix Decrement Operator)</h1>

      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 若 |UnaryExpression| 的 AssignmentTargetType 为 ~web-compat~，抛出 *ReferenceError* 异常。<br>
          1. 令 _oldValue_ 为 ? ToNumeric(? GetValue(_expr_))。<br>
          1. 若 _oldValue_ 是 Number，则
            1. 令 _newValue_ 为 Number::subtract(_oldValue_, *1*<sub>𝔽</sub>)。
          1. 否则，
            1. 断言：_oldValue_ 为 BigInt。
            1. 令 _newValue_ 为 BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>)。
          1. 执行 ? PutValue(_expr_, _newValue_)。
          1. 返回 _newValue_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unary-operators">
    <h1>一元运算符 (Unary Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-delete-operator">
      <h1>`delete` 运算符 (The `delete` Operator)</h1>

      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            若 IsStrict(|UnaryExpression|) 为 *true* 且派生的 |UnaryExpression| 为 <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>、<emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>、<emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>、<emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar> 或 <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>，则为语法错误。
          </li>
          <li>
            <p>
              若派生的 |UnaryExpression| 为<br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar><br>
              且 |CoverParenthesizedExpressionAndArrowParameterList| 最终派生出一个短语，若将其替换 |UnaryExpression| 会根据这些规则产生语法错误，则该情况为语法错误。此规则递归应用。
            </p>
          </li>
        </ul>
        <emu-note>
          <p>最后一条规则意味着诸如 `delete (((foo)))` 的表达式会因为递归应用首条规则而产生早期错误。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _ref_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 若 _ref_ 不是 Reference Record，返回 *true*。<br>
          1. 若 IsUnresolvableReference(_ref_) 为 *true*，则
            1. 断言：_ref_.[[Strict]] 为 *false*。
            1. 返回 *true*。
          1. 若 IsPropertyReference(_ref_) 为 *true*，则
            1. 断言：IsPrivateReference(_ref_) 为 *false*。
            1. 若 IsSuperReference(_ref_) 为 *true*，抛出 *ReferenceError* 异常。
            1. [id="step-delete-operator-toobject"] 令 _baseObj_ 为 ? ToObject(_ref_.[[Base]])。
            1. 若 _ref_.[[ReferencedName]] 不是属性键，则
              1. 设 _ref_.[[ReferencedName]] 为 ? ToPropertyKey(_ref_.[[ReferencedName]])。
            1. 令 _deleteStatus_ 为 ? <emu-meta effects="user-code">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]])。
            1. 若 _deleteStatus_ 为 *false* 且 _ref_.[[Strict]] 为 *true*，抛出 *TypeError* 异常。
            1. 返回 _deleteStatus_。
          1. 否则，
            1. 令 _base_ 为 _ref_.[[Base]]。
            1. 断言：_base_ 是 Environment Record。
            1. 返回 ? <emu-meta effects="user-code">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]])。
        </emu-alg>
        <emu-note>
          <p>在严格模式代码中出现的 `delete` 运算符，如果其 |UnaryExpression| 是对变量、函数参数或函数名的直接引用，则抛出 *SyntaxError*；另外，若删除的属性具有 { [[Configurable]]: *false* }（或以其他方式不可删除），则抛出 *TypeError*。</p>
        </emu-note>
        <emu-note>
          <p>步骤 <emu-xref href="#step-delete-operator-toobject"></emu-xref> 可能创建的对象在该抽象操作及普通对象 [[Delete]] 内部方法之外不可访问，实现可选择避免实际创建该对象。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-void-operator">
      <h1>`void` 运算符 (The `void` Operator)</h1>

      <emu-clause id="sec-void-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `void` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 执行 ? GetValue(_expr_)。<br>
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>必须调用 GetValue（即使其结果未使用），因为它可能具有可观察的副作用。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>`typeof` 运算符 (The `typeof` Operator)</h1>

      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation" oldids="table-typeof-operator-results,sec-IsHTMLDDA-internal-slot-typeof" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _val_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 若 _val_ 是 Reference Record，则
            1. 若 IsUnresolvableReference(_val_) 为 *true*，返回 *"undefined"*。
          1. 设 _val_ 为 ? GetValue(_val_)。
          1. 若 _val_ 为 *undefined*，返回 *"undefined"*。
          1. 若 _val_ 为 *null*，返回 *"object"*。
          1. 若 _val_ 为 String，返回 *"string"*。
          1. 若 _val_ 为 Symbol，返回 *"symbol"*。
          1. 若 _val_ 为 Boolean，返回 *"boolean"*。
          1. 若 _val_ 为 Number，返回 *"number"*。
          1. 若 _val_ 为 BigInt，返回 *"bigint"*。
          1. 断言：_val_ 为 Object。
          1. [id="step-typeof-web-compat-insertion-point", normative-optional] 若宿主是 web 浏览器或否则支持 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>，则
            1. 若 _val_ 拥有 [[IsHTMLDDA]] 内部槽，返回 *"undefined"*。
          1. 若 _val_ 拥有 [[Call]] 内部方法，返回 *"function"*。
          1. 返回 *"object"*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-plus-operator">
      <h1>一元 `+` 运算符 (Unary `+` Operator)</h1>
      <emu-note>
        <p>一元 + 运算符将其操作数转换为 Number 类型。</p>
      </emu-note>

      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 返回 ? ToNumber(? GetValue(_expr_))。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-minus-operator">
      <h1>一元 `-` 运算符 (Unary `-` Operator)</h1>
      <emu-note>
        <p>一元 `-` 运算符将其操作数先转换为数值再取相反数。对 *+0*<sub>𝔽</sub> 取负得到 *-0*<sub>𝔽</sub>；对 *-0*<sub>𝔽</sub> 取负得到 *+0*<sub>𝔽</sub>。</p>
      </emu-note>

      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 令 _oldValue_ 为 ? ToNumeric(? GetValue(_expr_))。<br>
          1. 若 _oldValue_ 是 Number，则
            1. 返回 Number::unaryMinus(_oldValue_)。
          1. 否则，
            1. 断言：_oldValue_ 为 BigInt。
            1. 返回 BigInt::unaryMinus(_oldValue_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-bitwise-not-operator">
      <h1>按位取反运算符 (Bitwise NOT Operator `~`)</h1>

      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 令 _oldValue_ 为 ? ToNumeric(? GetValue(_expr_))。<br>
          1. 若 _oldValue_ 是 Number，则
            1. 返回 Number::bitwiseNOT(_oldValue_)。
          1. 否则，
            1. 断言：_oldValue_ 为 BigInt。
            1. 返回 BigInt::bitwiseNOT(_oldValue_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-logical-not-operator">
      <h1>逻辑非运算符 (Logical NOT Operator `!`)</h1>

      <emu-clause id="sec-logical-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>UnaryExpression : `!` UnaryExpression</emu-grammar>
        <emu-alg>
          1. 令 _expr_ 为 ? Evaluation of |UnaryExpression|。<br>
          1. 令 _oldValue_ 为 ToBoolean(? GetValue(_expr_))。<br>
          1. 若 _oldValue_ 为 *true*，返回 *false*。<br>
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>幂运算符 (Exponentiation Operator)</h1>
    <h2>语法 (Syntax)</h2>

    <emu-grammar type="definition">
      ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-multiplicative-operators">
    <h1>乘法类运算符 (Multiplicative Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      MultiplicativeExpression[Yield, Await] :
        ExponentiationExpression[?Yield, ?Await]
        MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

      MultiplicativeOperator : one of
        `*` `/` `%`
    </emu-grammar>
    <emu-note>
      <ul>
        <li>`*` 运算符执行乘法，产生其操作数的乘积。</li>
        <li>`/` 运算符执行除法，产生其操作数的商。</li>
        <li>`%` 运算符产生隐含除法后的余数。</li>
      </ul>
    </emu-note>

    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. 令 _opText_ 为 |MultiplicativeOperator| 匹配的源文本。<br>
        1. 返回 ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-additive-operators">
    <h1>加法类运算符 (Additive Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-addition-operator-plus">
      <h1>加法运算符 (The Addition Operator `+`)</h1>
      <emu-note>
        <p>加法运算符执行字符串连接或数值加法。</p>
      </emu-note>

      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-subtraction-operator-minus">
      <h1>减法运算符 (The Subtraction Operator `-`)</h1>
      <emu-note>
        <p>`-` 运算符执行减法，产生操作数之差。</p>
      </emu-note>

      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|)。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bitwise-shift-operators">
    <h1>位移运算符 (Bitwise Shift Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ShiftExpression[Yield, Await] :
        AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-left-shift-operator">
      <h1>左移运算符 (The Left Shift Operator `&lt;&lt;`)</h1>
      <emu-note>
        <p>对左操作数按右操作数指定的位数执行按位左移。</p>
      </emu-note>

      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `&lt;&lt;`, |AdditiveExpression|)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-signed-right-shift-operator">
      <h1>带符号右移运算符 (The Signed Right Shift Operator `>>`)</h1>
      <emu-note>
        <p>对左操作数按右操作数指定的位数执行带符号（符号位填充）按位右移。</p>
      </emu-note>

      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>无符号右移运算符 (The Unsigned Right Shift Operator `>>>`)</h1>
      <emu-note>
        <p>对左操作数按右操作数指定的位数执行零填充按位右移。</p>
      </emu-note>

      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. 返回 ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|)。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relational-operators">
    <h1>关系运算符 (Relational Operators)</h1>
    <emu-note>
      <p>关系运算符求值结果总是 Boolean，表示操作数之间关系是否成立。</p>
    </emu-note>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      RelationalExpression[In, Yield, Await] :
        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
        [+In] PrivateIdentifier `in` ShiftExpression[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p><sub>[In]</sub> 语法参数用于避免把关系表达式中的 `in` 运算符与 `for` 语句中的 `in` 混淆。</p>
    </emu-note>

    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 令 _r_ 为 ? IsLessThan(_lVal_, _rVal_, *true*)。<br>
        1. 若 _r_ 为 *undefined*，返回 *false*；否则返回 _r_。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 令 _r_ 为 ? IsLessThan(_rVal_, _lVal_, *false*)。<br>
        1. 若 _r_ 为 *undefined*，返回 *false*；否则返回 _r_。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 令 _r_ 为 ? IsLessThan(_rVal_, _lVal_, *false*)。<br>
        1. 若 _r_ 为 *true* 或 *undefined*，返回 *false*；否则返回 *true*。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 令 _r_ 为 ? IsLessThan(_lVal_, _rVal_, *true*)。<br>
        1. 若 _r_ 为 *true* 或 *undefined*，返回 *false*；否则返回 *true*。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `instanceof` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 返回 ? InstanceofOperator(_lVal_, _rVal_)。
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 若 _rVal_ 不是 Object，抛出 *TypeError* 异常。<br>
        1. 返回 ? HasProperty(_rVal_, ? ToPropertyKey(_lVal_))。
      </emu-alg>
      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 令 _privateIdentifier_ 为 |PrivateIdentifier| 的 StringValue。<br>
        1. 令 _rRef_ 为 ? Evaluation of |ShiftExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 若 _rVal_ 不是 Object，抛出 *TypeError* 异常。<br>
        1. 令 _privateEnv_ 为正在运行的执行上下文的 PrivateEnvironment。<br>
        1. 断言：_privateEnv_ 非 *null*。<br>
        1. 令 _privateName_ 为 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)。<br>
        1. 若 PrivateElementFind(_rVal_, _privateName_) 非 ~empty~，返回 *true*。<br>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-instanceofoperator" type="abstract operation">
      <h1>
        InstanceofOperator (
          _V_: an ECMAScript language value,
          _target_: an ECMAScript language value,
        ): 返回一个含 Boolean 的正常完成或一个 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>实现判定 _V_ 是否为 _target_ 实例的通用算法：若 _target_ 定义 %Symbol.hasInstance% 方法则调用之，否则检查 _target_ 的 *"prototype"* 属性值是否出现在 _V_ 的原型链上。</dd>
      </dl>
      <emu-alg>
        1. 若 _target_ 不是 Object，抛出 *TypeError* 异常。<br>
        1. 令 _instOfHandler_ 为 ? GetMethod(_target_, %Symbol.hasInstance%)。<br>
        1. 若 _instOfHandler_ 不为 *undefined*，则
          1. 返回 ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »))。
        1. [id="step-instanceof-check-function"] 若 IsCallable(_target_) 为 *false*，抛出 *TypeError* 异常。<br>
        1. [id="step-instanceof-fallback"] 返回 ? OrdinaryHasInstance(_target_, _V_)。
      </emu-alg>
      <emu-note>
        <p>步骤 <emu-xref href="#step-instanceof-check-function"></emu-xref> 与 <emu-xref href="#step-instanceof-fallback"></emu-xref> 兼容早期未使用 %Symbol.hasInstance% 定义 `instanceof` 语义的版本。若对象未定义或继承该方法，则使用默认语义。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-equality-operators">
    <h1>相等运算符 (Equality Operators)</h1>
    <emu-note>
      <p>相等运算符求值结果总是 Boolean，表示两操作数之间命名关系是否成立。</p>
    </emu-note>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-equality-operators-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>EqualityExpression : EqualityExpression `==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |EqualityExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 返回 ? IsLooselyEqual(_rVal_, _lVal_)。
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!=` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |EqualityExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 令 _r_ 为 ? IsLooselyEqual(_rVal_, _lVal_)。<br>
        1. 若 _r_ 为 *true*，返回 *false*；否则返回 *true*。
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `===` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |EqualityExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 返回 IsStrictlyEqual(_rVal_, _lVal_)。
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |EqualityExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 令 _rRef_ 为 ? Evaluation of |RelationalExpression|。<br>
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。<br>
        1. 令 _r_ 为 IsStrictlyEqual(_rVal_, _lVal_)。<br>
        1. 若 _r_ 为 *true*，返回 *false*；否则返回 *true*。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>可通过 `\`${a}\` == \`${b}\`` 强制字符串比较。</li>
          <li>可通过 `+a == +b` 强制数值比较。</li>
          <li>可通过 `!a == !b` 强制布尔比较。</li>
        </ul>
      </emu-note>
      <emu-note>
        <p>相等运算符保持以下不变式：</p>
        <ul>
          <li>`A != B` 等价于 `!(A == B)`。</li>
          <li>`A == B` 等价于 `B == A`，除求值顺序外。</li>
        </ul>
      </emu-note>
      <emu-note>
        <p>相等运算符并非总是传递。例如可能存在两个不同的 String 对象，各表示相同的字符串值；它们分别与该字符串字面值 `==` 为 *true*，但二者彼此 `==` 为 *false*。示例：</p>
        <ul>
          <li>`new String("a") == "a"` 与 `"a" == new String("a")` 均为 *true*。</li>
          <li>`new String("a") == new String("a")` 为 *false*。</li>
        </ul>
      </emu-note>
      <emu-note>
        <p>字符串比较对代码单元序列执行简单相等测试，不使用 Unicode 规范中更复杂的语义性字符/字符串等价与排序定义。故按 Unicode 标准正则等价的字符串值可能测试为不等；此算法假设两者已规范化。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-bitwise-operators">
    <h1>二元按位运算符 (Binary Bitwise Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]

      BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]

      BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression</emu-grammar>
      <emu-alg>
        1. 返回 ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&amp;`, |EqualityExpression|)。
      </emu-alg>
      <emu-grammar>BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression</emu-grammar>
      <emu-alg>
        1. 返回 ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|)。
      </emu-alg>
      <emu-grammar>BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression</emu-grammar>
      <emu-alg>
        1. 返回 ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-logical-operators">
    <h1>二元逻辑运算符 (Binary Logical Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]

      LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]

      CoalesceExpression[In, Yield, Await] :
        CoalesceExpressionHead[?In, ?Yield, ?Await] `??` BitwiseORExpression[?In, ?Yield, ?Await]

      CoalesceExpressionHead[In, Yield, Await] :
        CoalesceExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await]

      ShortCircuitExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        CoalesceExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`&amp;&amp;` 与 `||` 运算符产生的值不一定是 Boolean，而总是两个操作数表达式之一的值。</p>
    </emu-note>

    <emu-clause id="sec-binary-logical-operators-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |LogicalANDExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 若 ToBoolean(_lVal_) 为 *false*，返回 _lVal_。<br>
        1. 令 _rRef_ 为 ? Evaluation of |BitwiseORExpression|。<br>
        1. 返回 ? GetValue(_rRef_)。
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |LogicalORExpression|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 若 ToBoolean(_lVal_) 为 *true*，返回 _lVal_。<br>
        1. 令 _rRef_ 为 ? Evaluation of |LogicalANDExpression|。<br>
        1. 返回 ? GetValue(_rRef_)。
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |CoalesceExpressionHead|。<br>
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。<br>
        1. 若 _lVal_ 为 *undefined* 或 *null*，则
          1. 令 _rRef_ 为 ? Evaluation of |BitwiseORExpression|。
          1. 返回 ? GetValue(_rRef_)。
        1. 否则，
          1. 返回 _lVal_。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-conditional-operator">
    <h1>条件运算符 ( `? :` ) (Conditional Operator ( `? :` ))</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ConditionalExpression[In, Yield, Await] :
        ShortCircuitExpression[?In, ?Yield, ?Await]
        ShortCircuitExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>ECMAScript 中 |ConditionalExpression| 的语法与 C 和 Java 略有不同；后两者允许第二个子表达式是 |Expression|，但限制第三个表达式是 |ConditionalExpression|。ECMAScript 这样设计的动机是允许条件两支任一侧控制一个赋值表达式，并移除“逗号表达式作为中间表达式”这一令人困惑且基本无用的情形。</p>
    </emu-note>

    <emu-clause id="sec-conditional-operator-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |ShortCircuitExpression|。<br>
        1. 令 _lVal_ 为 ToBoolean(? GetValue(_lRef_))。<br>
        1. 若 _lVal_ 为 *true*，则
          1. 令 _trueRef_ 为 ? Evaluation of 第一个 |AssignmentExpression|。<br>
          1. 返回 ? GetValue(_trueRef_)。<br>
        1. 否则，
          1. 令 _falseRef_ 为 ? Evaluation of 第二个 |AssignmentExpression|。<br>
          1. 返回 ? GetValue(_falseRef_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-assignment-operators">
    <h1>赋值运算符 (Assignment Operators)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `&amp;&amp;=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `||=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `??=` AssignmentExpression[?In, ?Yield, ?Await]

      // emu-format ignore
      AssignmentOperator : one of
        `*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`
    </emu-grammar>

    <emu-clause id="sec-assignment-operators-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <ul>
        <li>
          若 |LeftHandSideExpression| 是 |ObjectLiteral| 或 |ArrayLiteral|，则 |LeftHandSideExpression| 必须覆盖一个 |AssignmentPattern|。
        </li>
        <li>
          若 |LeftHandSideExpression| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，且其 AssignmentTargetType 为 ~invalid~，则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          若 |LeftHandSideExpression| 的 AssignmentTargetType 为 ~invalid~，则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          若 |LeftHandSideExpression| 的 AssignmentTargetType 不是 ~simple~，则为语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 若 |LeftHandSideExpression| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，则
          1. 令 _lRef_ 为 ? Evaluation of |LeftHandSideExpression|。
          1. 若 |LeftHandSideExpression| 的 AssignmentTargetType 为 ~web-compat~，抛出 *ReferenceError* 异常。
          1. 若 IsAnonymousFunctionDefinition(|AssignmentExpression|) 为 *true* 且 IsIdentifierRef of |LeftHandSideExpression| 为 *true*，则
            1. 令 _lhs_ 为 |LeftHandSideExpression| 的 StringValue。
            1. 令 _rVal_ 为 ? NamedEvaluation of |AssignmentExpression|，参数 _lhs_。
          1. 否则，
            1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
            1. 令 _rVal_ 为 ? GetValue(_rRef_)。
          1. [id="step-assignmentexpression-evaluation-simple-putvalue"] 执行 ? PutValue(_lRef_, _rVal_)。
          1. 返回 _rVal_。
        1. 令 _assignmentPattern_ 为 |LeftHandSideExpression| 覆盖的 |AssignmentPattern|。
        1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。
        1. 执行 ? DestructuringAssignmentEvaluation of _assignmentPattern_，参数 _rVal_。
        1. 返回 _rVal_。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |LeftHandSideExpression|。
        1. 若 |LeftHandSideExpression| 的 AssignmentTargetType 为 ~web-compat~，抛出 *ReferenceError* 异常。
        1. [id="step-assignmentexpression-evaluation-compound-getvalue"] 令 _lVal_ 为 ? GetValue(_lRef_)。
        1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。
        1. 令 _assignmentOpText_ 为 |AssignmentOperator| 所匹配的源文本。
        1. 令 _opText_ 为下表中与 _assignmentOpText_ 关联的 Unicode 码点序列：
          <figure>
            <!-- emu-format ignore -->
            <table class="lightweight-table">
              <thead>
                <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>
              </thead>
              <tr><td> `**=`              </td><td> `**`           </td></tr>
              <tr><td> `*=`               </td><td> `*`            </td></tr>
              <tr><td> `/=`               </td><td> `/`            </td></tr>
              <tr><td> `%=`               </td><td> `%`            </td></tr>
              <tr><td> `+=`               </td><td> `+`            </td></tr>
              <tr><td> `-=`               </td><td> `-`            </td></tr>
              <tr><td> `&lt;&lt;=`        </td><td> `&lt;&lt;`     </td></tr>
              <tr><td> `&gt;&gt;=`        </td><td> `&gt;&gt;`     </td></tr>
              <tr><td> `&gt;&gt;&gt;=`    </td><td> `&gt;&gt;&gt;` </td></tr>
              <tr><td> `&amp;=`           </td><td> `&amp;`        </td></tr>
              <tr><td> `^=`               </td><td> `^`            </td></tr>
              <tr><td> `|=`               </td><td> `|`            </td></tr>
            </table>
          </figure>
        1. 令 _r_ 为 ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_)。
        1. [id="step-assignmentexpression-evaluation-compound-putvalue"] 执行 ? PutValue(_lRef_, _r_)。
        1. 返回 _r_。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `&amp;&amp;=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |LeftHandSideExpression|。
        1. [id="step-assignmentexpression-evaluation-lgcl-and-getvalue"] 令 _lVal_ 为 ? GetValue(_lRef_)。
        1. 若 ToBoolean(_lVal_) 为 *false*，返回 _lVal_。
        1. 若 IsAnonymousFunctionDefinition(|AssignmentExpression|) 为 *true* 且 IsIdentifierRef of |LeftHandSideExpression| 为 *true*，则
          1. 令 _lhs_ 为 |LeftHandSideExpression| 的 StringValue。
          1. 令 _rVal_ 为 ? NamedEvaluation of |AssignmentExpression|，参数 _lhs_。
        1. 否则，
          1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _rVal_ 为 ? GetValue(_rRef_)。
        1. [id="step-assignmentexpression-evaluation-lgcl-and-putvalue"] 执行 ? PutValue(_lRef_, _rVal_)。
        1. 返回 _rVal_。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `||=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |LeftHandSideExpression|。
        1. [id="step-assignmentexpression-evaluation-lgcl-or-getvalue"] 令 _lVal_ 为 ? GetValue(_lRef_)。
        1. 若 ToBoolean(_lVal_) 为 *true*，返回 _lVal_。
        1. 若 IsAnonymousFunctionDefinition(|AssignmentExpression|) 为 *true* 且 IsIdentifierRef of |LeftHandSideExpression| 为 *true*，则
          1. 令 _lhs_ 为 |LeftHandSideExpression| 的 StringValue。
          1. 令 _rVal_ 为 ? NamedEvaluation of |AssignmentExpression|，参数 _lhs_。
        1. 否则，
          1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _rVal_ 为 ? GetValue(_rRef_)。
        1. [id="step-assignmentexpression-evaluation-lgcl-or-putvalue"] 执行 ? PutValue(_lRef_, _rVal_)。
        1. 返回 _rVal_。
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `??=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |LeftHandSideExpression|。
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-getvalue"] 令 _lVal_ 为 ? GetValue(_lRef_)。
        1. 若 _lVal_ 既不是 *undefined* 也不是 *null*，返回 _lVal_。
        1. 若 IsAnonymousFunctionDefinition(|AssignmentExpression|) 为 *true* 且 IsIdentifierRef of |LeftHandSideExpression| 为 *true*，则
          1. 令 _lhs_ 为 |LeftHandSideExpression| 的 StringValue。
          1. 令 _rVal_ 为 ? NamedEvaluation of |AssignmentExpression|，参数 _lhs_。
        1. 否则，
          1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
          1. 令 _rVal_ 为 ? GetValue(_rRef_)。
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-putvalue"] 执行 ? PutValue(_lRef_, _rVal_)。
        1. 返回 _rVal_。
      </emu-alg>
      <emu-note>
        <p>当该表达式出现在严格模式代码中时，若步骤 <emu-xref href="#step-assignmentexpression-evaluation-simple-putvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-compound-getvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-getvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-getvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-getvalue"></emu-xref> 中的 _lRef_ 是不可解析引用，则抛出 *ReferenceError*。另外，若步骤 <emu-xref href="#step-assignmentexpression-evaluation-compound-putvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-putvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-putvalue"></emu-xref>、<emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-putvalue"></emu-xref> 中的 _lRef_ 引用一个 { [[Writable]]: *false* } 的数据属性、[[Set]] 为 *undefined* 的访问器属性，或对象中不存在且该对象的 IsExtensible 结果为 *false* 的属性，则抛出 *TypeError*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-applystringornumericbinaryoperator" type="abstract operation">
      <h1>
        ApplyStringOrNumericBinaryOperator (
          _lVal_: 一个 ECMAScript 语言值,
          _opText_: `**`, `*`, `/`, `%`, `+`, `-`, `&lt;&lt;`, `&gt;&gt;`, `&gt;&gt;&gt;`, `&amp;`, `^`, 或 `|`,
          _rVal_: 一个 ECMAScript 语言值,
        ): 返回一个含 String、BigInt 或 Number 的正常完成，或一个 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _opText_ 是 `+`，则
          1. [id="step-binary-op-toprimitive-lval"] 令 _lPrim_ 为 ? ToPrimitive(_lVal_)。
          1. [id="step-binary-op-toprimitive-rval"] 令 _rPrim_ 为 ? ToPrimitive(_rVal_)。
          1. [id="step-binary-op-string-check"] 若 _lPrim_ 为 String 或 _rPrim_ 为 String，则
            1. 令 _lStr_ 为 ? ToString(_lPrim_)。
            1. 令 _rStr_ 为 ? ToString(_rPrim_)。
            1. 返回 _lStr_ 与 _rStr_ 的字符串连接。
          1. 设 _lVal_ 为 _lPrim_。
          1. 设 _rVal_ 为 _rPrim_。
        1. 注：此时必为数值运算。
        1. 令 _lNum_ 为 ? ToNumeric(_lVal_)。
        1. 令 _rNum_ 为 ? ToNumeric(_rVal_)。
        1. 若 SameType(_lNum_, _rNum_) 为 *false*，抛出 *TypeError* 异常。
        1. 若 _lNum_ 为 BigInt，则
          1. 若 _opText_ 为 `**`，返回 ? BigInt::exponentiate(_lNum_, _rNum_)。
          1. 若 _opText_ 为 `/`，返回 ? BigInt::divide(_lNum_, _rNum_)。
          1. 若 _opText_ 为 `%`，返回 ? BigInt::remainder(_lNum_, _rNum_)。
          1. 若 _opText_ 为 `>>>`，返回 ? BigInt::unsignedRightShift(_lNum_, _rNum_)。
          1. 令 _operation_ 为下表中与 _opText_ 关联的抽象操作：
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_   </th><th> _operation_              </th></tr>
                </thead>
                <tbody>
                  <tr><td> `*`        </td><td> BigInt::multiply         </td></tr>
                  <tr><td> `+`        </td><td> BigInt::add              </td></tr>
                  <tr><td> `-`        </td><td> BigInt::subtract         </td></tr>
                  <tr><td> `&lt;&lt;` </td><td> BigInt::leftShift        </td></tr>
                  <tr><td> `&gt;&gt;` </td><td> BigInt::signedRightShift </td></tr>
                  <tr><td> `&amp;`    </td><td> BigInt::bitwiseAND       </td></tr>
                  <tr><td> `^`        </td><td> BigInt::bitwiseXOR       </td></tr>
                  <tr><td> `|`        </td><td> BigInt::bitwiseOR        </td></tr>
                </tbody>
              </table>
            </figure>
        1. 否则，
          1. 断言：_lNum_ 为 Number。
          1. 令 _operation_ 为下表中与 _opText_ 关联的抽象操作：
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_       </th><th> _operation_                </th></tr>
                </thead>
                <tbody>
                  <tr><td> `**`           </td><td> Number::exponentiate       </td></tr>
                  <tr><td> `*`            </td><td> Number::multiply           </td></tr>
                  <tr><td> `/`            </td><td> Number::divide             </td></tr>
                  <tr><td> `%`            </td><td> Number::remainder          </td></tr>
                  <tr><td> `+`            </td><td> Number::add                </td></tr>
                  <tr><td> `-`            </td><td> Number::subtract           </td></tr>
                  <tr><td> `&lt;&lt;`     </td><td> Number::leftShift          </td></tr>
                  <tr><td> `&gt;&gt;`     </td><td> Number::signedRightShift   </td></tr>
                  <tr><td> `&gt;&gt;&gt;` </td><td> Number::unsignedRightShift </td></tr>
                  <tr><td> `&amp;`        </td><td> Number::bitwiseAND         </td></tr>
                  <tr><td> `^`            </td><td> Number::bitwiseXOR         </td></tr>
                  <tr><td> `|`            </td><td> Number::bitwiseOR          </td></tr>
                </tbody>
              </table>
            </figure>
        1. 返回 _operation_(_lNum_, _rNum_)。
      </emu-alg>
      <emu-note>
        <p>步骤 <emu-xref href="#step-binary-op-toprimitive-lval"></emu-xref> 与 <emu-xref href="#step-binary-op-toprimitive-rval"></emu-xref> 中对 ToPrimitive 的调用不提供 hint。除 Date 外的所有标准对象在缺省 hint 时按 ~number~ 处理；Date 按 ~string~ 处理；特异对象可按其他方式处理。</p>
      </emu-note>
      <emu-note>
        <p>步骤 <emu-xref href="#step-binary-op-string-check"></emu-xref> 与 IsLessThan 算法的步骤 <emu-xref href="#step-arc-string-check"></emu-xref> 不同：它使用逻辑“或”而不是逻辑“与”。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-evaluatestringornumericbinaryexpression" type="abstract operation">
      <h1>
        EvaluateStringOrNumericBinaryExpression (
          _leftOperand_: 一个 Parse Node,
          _opText_: 一个 Unicode 码点序列,
          _rightOperand_: 一个 Parse Node,
        ): 返回一个含 String、BigInt 或 Number 的正常完成，或一个突然完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of _leftOperand_。
        1. 令 _lVal_ 为 ? GetValue(_lRef_)。
        1. 令 _rRef_ 为 ? Evaluation of _rightOperand_。
        1. 令 _rVal_ 为 ? GetValue(_rRef_)。
        1. 返回 ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-destructuring-assignment">
      <h1>解构赋值 (Destructuring Assignment)</h1>
      <h2>补充语法 (Supplemental Syntax)</h2>
      <p>
        在处理产生式实例：<br>
        <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar><br>
        时，对 |LeftHandSideExpression| 的解释通过下列语法细化：
      </p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-assignment-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <ul>
          <li>
            若 |IdentifierReference| 的 AssignmentTargetType 不是 ~simple~，则为语法错误。
          </li>
        </ul>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <ul>
          <li>
            若 |DestructuringAssignmentTarget| 是 |ArrayLiteral| 或 |ObjectLiteral|，则为语法错误。
          </li>
        </ul>
        <emu-grammar>DestructuringAssignmentTarget : LeftHandSideExpression</emu-grammar>
        <ul>
          <li>
            若 |LeftHandSideExpression| 是 |ObjectLiteral| 或 |ArrayLiteral|，则其必须覆盖一个 |AssignmentPattern|。
          </li>
          <li>
            若 |LeftHandSideExpression| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，且其 AssignmentTargetType 不是 ~simple~，则为语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-destructuringassignmentevaluation" type="sdo">
        <h1>
          运行时语义：DestructuringAssignmentEvaluation (
            _value_: 一个 ECMAScript 语言值,
          ): 返回一个含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ObjectAssignmentPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_value_)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>
          ObjectAssignmentPattern :
            `{` AssignmentPropertyList `}`
            `{` AssignmentPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_value_)。
          1. 执行 ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList|，参数 _value_。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_value_)。
          1. 令 _excludedNames_ 为新空列表。
          1. 返回 ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty|，参数 _value_ 与 _excludedNames_。
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentPropertyList `,` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_value_)。
          1. 令 _excludedNames_ 为 ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList|，参数 _value_。
          1. 返回 ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty|，参数 _value_ 与 _excludedNames_。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
          1. 返回 ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~))。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
          1. 令 _result_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |Elision|，参数 _iteratorRecord_)。
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _result_)。
          1. 返回 _result_。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]`</emu-grammar>
        <emu-alg>
          1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
          1. 若存在 |Elision|，则
            1. 令 _status_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |Elision|，参数 _iteratorRecord_)。
            1. 若 _status_ 是突然完成，则
              1. 断言：_iteratorRecord_.[[Done]] 为 *true*。
              1. 返回 ? _status_。
          1. 令 _result_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement|，参数 _iteratorRecord_)。
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _result_)。
          1. 返回 _result_。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `]`</emu-grammar>
        <emu-alg>
          1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
          1. 令 _result_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList|，参数 _iteratorRecord_)。
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _result_)。
          1. 返回 _result_。
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision? AssignmentRestElement? `]`</emu-grammar>
        <emu-alg>
          1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
          1. 令 _status_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList|，参数 _iteratorRecord_)。
          1. 若 _status_ 是突然完成，则
            1. 若 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _status_)。
            1. 返回 ? _status_。
          1. 若存在 |Elision|，则
            1. 设 _status_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |Elision|，参数 _iteratorRecord_)。
            1. 若 _status_ 是突然完成，则
              1. 断言：_iteratorRecord_.[[Done]] 为 *true*。
              1. 返回 ? _status_。
          1. 若存在 |AssignmentRestElement|，则
            1. 设 _status_ 为 Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement|，参数 _iteratorRecord_)。
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _status_)。
          1. 返回 ? _status_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydestructuringassignmentevaluation" type="sdo">
        <h1>
          运行时语义：PropertyDestructuringAssignmentEvaluation (
            _value_: 一个 ECMAScript 语言值,
          ): 返回一个含属性键列表的正常完成或一个突然完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>收集所有被解构的属性键列表。</dd>
        </dl>
        <emu-grammar>AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty</emu-grammar>
        <emu-alg>
          1. 令 _propertyNames_ 为 ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList|，参数 _value_。
          1. 令 _nextNames_ 为 ? PropertyDestructuringAssignmentEvaluation of |AssignmentProperty|，参数 _value_。
          1. 返回 _propertyNames_ 与 _nextNames_ 的列表连接。
        </emu-alg>

        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <emu-alg>
          1. 令 _P_ 为 |IdentifierReference| 的 StringValue。
          1. 令 _lRef_ 为 ? ResolveBinding(_P_)。
          1. 令 _v_ 为 ? GetV(_value_, _P_)。
          1. 若存在 |Initializer| 且 _v_ 为 *undefined*，则
            1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
              1. 设 _v_ 为 ? NamedEvaluation of |Initializer|，参数 _P_。
            1. 否则，
              1. 令 _defaultValue_ 为 ? Evaluation of |Initializer|。
              1. 设 _v_ 为 ? GetValue(_defaultValue_)。
          1. 执行 ? PutValue(_lRef_, _v_)。
          1. 返回 « _P_ »。
        </emu-alg>

        <emu-grammar>AssignmentProperty : PropertyName `:` AssignmentElement</emu-grammar>
        <emu-alg>
          1. 令 _name_ 为 ? Evaluation of |PropertyName|。
          1. 执行 ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement|，参数 _value_ 与 _name_。
          1. 返回 « _name_ »。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-restdestructuringassignmentevaluation" type="sdo">
        <h1>
          运行时语义：RestDestructuringAssignmentEvaluation (
            _value_: 一个 ECMAScript 语言值,
            _excludedNames_: 一个属性键列表,
          ): 返回一个含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. 令 _lRef_ 为 ? Evaluation of |DestructuringAssignmentTarget|。
          1. 令 _restObj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ? CopyDataProperties(_restObj_, _value_, _excludedNames_)。
          1. 返回 ? PutValue(_lRef_, _restObj_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation" type="sdo">
        <h1>
          运行时语义：IteratorDestructuringAssignmentEvaluation (
            _iteratorRecord_: 一个 Iterator Record,
          ): 返回一个含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. 返回 ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement|，参数 _iteratorRecord_。
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. 执行 ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList|，参数 _iteratorRecord_。
          1. 返回 ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement|，参数 _iteratorRecord_。
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. 返回 ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement|，参数 _iteratorRecord_。
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. 执行 ? IteratorDestructuringAssignmentEvaluation of |Elision|，参数 _iteratorRecord_。
          1. 返回 ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement|，参数 _iteratorRecord_。
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 执行 ? IteratorStep(_iteratorRecord_)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. 执行 ? IteratorDestructuringAssignmentEvaluation of |Elision|，参数 _iteratorRecord_。
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 执行 ? IteratorStep(_iteratorRecord_)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. 若 |DestructuringAssignmentTarget| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，则
            1. 令 _lRef_ 为 ? Evaluation of |DestructuringAssignmentTarget|。
          1. 令 _value_ 为 *undefined*。
          1. 若 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 若 _next_ 非 ~done~，则
              1. 设 _value_ 为 _next_。
          1. 若存在 |Initializer| 且 _value_ 为 *undefined*，则
            1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true* 且 IsIdentifierRef of |DestructuringAssignmentTarget| 为 *true*，则
              1. 令 _target_ 为 |DestructuringAssignmentTarget| 的 StringValue。
              1. 令 _v_ 为 ? NamedEvaluation of |Initializer|，参数 _target_。
            1. 否则，
              1. 令 _defaultValue_ 为 ? Evaluation of |Initializer|。
              1. 令 _v_ 为 ? GetValue(_defaultValue_)。
          1. 否则，
            1. 令 _v_ 为 _value_。
          1. 若 |DestructuringAssignmentTarget| 是 |ObjectLiteral| 或 |ArrayLiteral|，则
            1. 令 _nestedAssignmentPattern_ 为 |DestructuringAssignmentTarget| 覆盖的 |AssignmentPattern|。
            1. 返回 ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_，参数 _v_。
          1. 返回 ? PutValue(_lRef_, _v_)。
        </emu-alg>
        <emu-note>
          <p>通过在访问迭代器或求 |Initializer| 之前先求值非解构模式的 |DestructuringAssignmentTarget|，保持自左向右的求值顺序。</p>
        </emu-note>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. 若 |DestructuringAssignmentTarget| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，则
            1. 令 _lRef_ 为 ? Evaluation of |DestructuringAssignmentTarget|。
          1. 令 _A_ 为 ! ArrayCreate(0)。
          1. 令 _n_ 为 0。
          1. 当 _iteratorRecord_.[[Done]] 为 *false* 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 若 _next_ 非 ~done~，则
              1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)。
              1. 设 _n_ 为 _n_ + 1。
          1. 若 |DestructuringAssignmentTarget| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，则
            1. 返回 ? PutValue(_lRef_, _A_)。
          1. 令 _nestedAssignmentPattern_ 为 |DestructuringAssignmentTarget| 覆盖的 |AssignmentPattern|。
          1. 返回 ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_，参数 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation" type="sdo">
        <h1>
          运行时语义：KeyedDestructuringAssignmentEvaluation (
            _value_: 一个 ECMAScript 语言值,
            _propertyName_: 一个属性键,
          ): 返回一个含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. 若 |DestructuringAssignmentTarget| 既不是 |ObjectLiteral| 也不是 |ArrayLiteral|，则
            1. 令 _lRef_ 为 ? Evaluation of |DestructuringAssignmentTarget|。
          1. 令 _v_ 为 ? GetV(_value_, _propertyName_)。
          1. 若存在 |Initializer| 且 _v_ 为 *undefined*，则
            1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true* 且 IsIdentifierRef of |DestructuringAssignmentTarget| 为 *true*，则
              1. 令 _target_ 为 |DestructuringAssignmentTarget| 的 StringValue。
              1. 令 _rhsValue_ 为 ? NamedEvaluation of |Initializer|，参数 _target_。
            1. 否则，
              1. 令 _defaultValue_ 为 ? Evaluation of |Initializer|。
              1. 令 _rhsValue_ 为 ? GetValue(_defaultValue_)。
          1. 否则，
            1. 令 _rhsValue_ 为 _v_。
          1. 若 |DestructuringAssignmentTarget| 是 |ObjectLiteral| 或 |ArrayLiteral|，则
            1. 令 _assignmentPattern_ 为 |DestructuringAssignmentTarget| 覆盖的 |AssignmentPattern|。
            1. 返回 ? DestructuringAssignmentEvaluation of _assignmentPattern_，参数 _rhsValue_。
          1. 返回 ? PutValue(_lRef_, _rhsValue_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-comma-operator">
    <h1>逗号运算符 ( `,` )</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-comma-operator-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _lRef_ 为 ? Evaluation of |Expression|。
        1. 执行 ? GetValue(_lRef_)。
        1. 令 _rRef_ 为 ? Evaluation of |AssignmentExpression|。
        1. 返回 ? GetValue(_rRef_)。
      </emu-alg>
      <emu-note>
        <p>必须调用 GetValue（即使其结果未被使用），因为它可能具有可观察的副作用。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript 语言：语句与声明 (ECMAScript Language: Statements and Declarations)</h1>
  <h2>语法 (Syntax)</h2>
  <emu-grammar type="definition">
    Statement[Yield, Await, Return] :
      BlockStatement[?Yield, ?Await, ?Return]
      VariableStatement[?Yield, ?Await]
      EmptyStatement
      ExpressionStatement[?Yield, ?Await]
      IfStatement[?Yield, ?Await, ?Return]
      BreakableStatement[?Yield, ?Await, ?Return]
      ContinueStatement[?Yield, ?Await]
      BreakStatement[?Yield, ?Await]
      [+Return] ReturnStatement[?Yield, ?Await]
      WithStatement[?Yield, ?Await, ?Return]
      LabelledStatement[?Yield, ?Await, ?Return]
      ThrowStatement[?Yield, ?Await]
      TryStatement[?Yield, ?Await, ?Return]
      DebuggerStatement

    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] :
      FunctionDeclaration[?Yield, ?Await, ?Default]
      GeneratorDeclaration[?Yield, ?Await, ?Default]
      AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
      AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] :
      IterationStatement[?Yield, ?Await, ?Return]
      SwitchStatement[?Yield, ?Await, ?Return]
  </emu-grammar>

  <emu-clause id="sec-statement-semantics">
    <h1>语句语义 (Statement Semantics)</h1>

    <emu-clause id="sec-statement-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        HoistableDeclaration :
          GeneratorDeclaration
          AsyncFunctionDeclaration
          AsyncGeneratorDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 ~empty~.
      </emu-alg>
      <emu-grammar>
        HoistableDeclaration : FunctionDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 ? Evaluation of |FunctionDeclaration|.
      </emu-alg>
      <emu-grammar>
        BreakableStatement :
          IterationStatement
          SwitchStatement
      </emu-grammar>
      <emu-alg>
        1. 令 _newLabelSet_ 为新空 List。
        1. 返回 ? LabelledEvaluation of 此 |BreakableStatement|，参数 _newLabelSet_。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-block">
    <h1>块 (Block)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      BlockStatement[Yield, Await, Return] :
        Block[?Yield, ?Await, ?Return]

      Block[Yield, Await, Return] :
        `{` StatementList[?Yield, ?Await, ?Return]? `}`

      StatementList[Yield, Await, Return] :
        StatementListItem[?Yield, ?Await, ?Return]
        StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

      StatementListItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        Declaration[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-block-static-semantics-early-errors" oldids="sec-block-duplicates-allowed-static-semantics">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <ul>
        <li>
          <p>若 |StatementList| 的 LexicallyDeclaredNames 含有重复条目则为语法错误<span normative-optional>；除非宿主是 web 浏览器或支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 且以下两条件同时为真：</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) 为 *false*。</li>
            <li>重复条目仅由 FunctionDeclarations 绑定。</li>
          </ul>
        </li>
        <li>
          若 |StatementList| 的 LexicallyDeclaredNames 中任一元素也出现在其 VarDeclaredNames 中，则为语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-block-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. 令 _oldEnv_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _blockEnv_ 为 NewDeclarativeEnvironment(_oldEnv_)。
        1. 执行 BlockDeclarationInstantiation(|StatementList|, _blockEnv_)。
        1. 将当前执行上下文的 LexicalEnvironment 设为 _blockEnv_。
        1. 令 _blockValue_ 为 Completion(Evaluation of |StatementList|)。
        1. 将当前执行上下文的 LexicalEnvironment 设回 _oldEnv_。
        1. 返回 ? _blockValue_。
      </emu-alg>
      <emu-note>
        <p>无论控制如何离开 |Block|，LexicalEnvironment 均会恢复到之前状态。</p>
      </emu-note>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _sl_ 为 ? Evaluation of |StatementList|。
        1. 令 _s_ 为 Completion(Evaluation of |StatementListItem|)。
        1. 返回 ? UpdateEmpty(_s_, _sl_)。
      </emu-alg>
      <emu-note>
        <p>|StatementList| 的值是其中最后一个产生值的项。例如下列对 `eval` 的调用都返回 1：</p>
        <pre><code class="javascript">
          eval("1;;;;;")
          eval("1;{}")
          eval("1;var a;")
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-blockdeclarationinstantiation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: 一个 Parse Node,
          _env_: 一个 Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ 是块主体对应的 Parse Node。_env_ 是要在其中创建绑定的 Environment Record。</dd>
      </dl>
      <emu-note>
        <p>当求值一个 |Block| 或 |CaseBlock| 时会创建新的 Declarative Environment Record，并为块内每个块级变量、常量、函数、类实例化绑定。</p>
      </emu-note>
      <p>调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _declarations_ 为 _code_ 的 LexicallyScopedDeclarations。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 对 _declarations_ 中每个元素 _d_：
          1. 对 _d_ 的 BoundNames 每个元素 _dn_：
            1. 若 IsConstantDeclaration of _d_ 为 *true*，则
              1. 执行 ! _env_.CreateImmutableBinding(_dn_, *true*)。
            1. 否则，
              1. [id="step-blockdeclarationinstantiation-createmutablebinding", normative-optional] 若宿主是 web 浏览器或支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>，则
                1. 若 ! _env_.HasBinding(_dn_) 为 *false*，执行 ! _env_.CreateMutableBinding(_dn_, *false*)。
              1. 否则，
                1. 执行 ! _env_.CreateMutableBinding(_dn_, *false*)。
          1. 若 _d_ 是 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration| 或 |AsyncGeneratorDeclaration|，则
            1. 令 _fn_ 为 _d_ 的唯一 BoundName。
            1. 令 _fo_ 为 InstantiateFunctionObject of _d_，参数 _env_ 与 _privateEnv_。
            1. [id="step-blockdeclarationinstantiation-initializebinding", normative-optional] 若宿主是 web 浏览器或支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>，则
              1. 若 _env_ 中 _fn_ 的绑定是未初始化，执行 ! _env_.InitializeBinding(_fn_, _fo_)。
              1. 否则，
                1. 断言：_d_ 是 |FunctionDeclaration|。
                1. 执行 ! _env_.SetMutableBinding(_fn_, _fo_, *false*)。
            1. 否则，
              1. 执行 ! _env_.InitializeBinding(_fn_, _fo_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>声明与变量语句 (Declarations and the Variable Statement)</h1>

    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let 与 Const 声明 (Let and Const Declarations)</h1>
      <emu-note>
        <p>`let` 与 `const` 声明的变量作用域为当前执行上下文的 LexicalEnvironment。变量在其包含的 Environment Record 实例化时创建，但在其 |LexicalBinding| 求值前不可访问。带 |Initializer| 的 |LexicalBinding| 其变量在求值时（而非创建时）赋值为 |Initializer| 的 |AssignmentExpression| 结果。`let` 声明中无 |Initializer| 的 |LexicalBinding| 在求值时变量被赋值 *undefined*。</p>
      </emu-note>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await] `;`

        LetOrConst :
          `let`
          `const`

        BindingList[In, Yield, Await] :
          LexicalBinding[?In, ?Yield, ?Await]
          BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]

        LexicalBinding[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <ul>
          <li>
            若 |BindingList| 的 BoundNames 含 *"let"*，语法错误。
          </li>
          <li>
            若 |BindingList| 的 BoundNames 含重复条目，语法错误。
          </li>
        </ul>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <ul>
          <li>
            若未出现 |Initializer| 且包含该 |LexicalBinding| 的 |LexicalDeclaration| 的 IsConstantDeclaration 为 *true*，语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. 执行 ? Evaluation of |BindingList|。
          1. 返回 ~empty~。
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. 执行 ? Evaluation of |BindingList|。
          1. 返回 ? Evaluation of |LexicalBinding|。
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. 令 _lhs_ 为 ! ResolveBinding(StringValue of |BindingIdentifier|)。
          1. 执行 ! InitializeReferencedBinding(_lhs_, *undefined*)。
          1. 返回 ~empty~。
        </emu-alg>
        <emu-note>
          <p>静态语义确保此形式不会出现在 `const` 声明中。</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
          1. 令 _lhs_ 为 ! ResolveBinding(_bindingId_)。
          1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
            1. 令 _value_ 为 ? NamedEvaluation of |Initializer|，参数 _bindingId_。
          1. 否则，
            1. 令 _rhs_ 为 ? Evaluation of |Initializer|。
            1. 令 _value_ 为 ? GetValue(_rhs_)。
          1. 执行 ! InitializeReferencedBinding(_lhs_, _value_)。
          1. 返回 ~empty~。
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. 令 _rhs_ 为 ? Evaluation of |Initializer|。
          1. 令 _value_ 为 ? GetValue(_rhs_)。
          1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
          1. 返回 ? BindingInitialization of |BindingPattern|，参数 _value_ 与 _env_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-variable-statement">
      <h1>变量语句 (Variable Statement)</h1>
      <emu-note>
        <p>`var` 声明的变量作用域为当前执行上下文的 VariableEnvironment。此类变量在其环境记录实例化时创建并初始化为 *undefined*。在同一 VariableEnvironment 作用域中，相同 |BindingIdentifier| 可以出现在多个 |VariableDeclaration| 中，但这些声明共同定义一个变量。带 |Initializer| 的 |VariableDeclaration| 在执行时赋值，而非创建时。</p>
      </emu-note>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        VariableStatement[Yield, Await] :
          `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`

        VariableDeclarationList[In, Yield, Await] :
          VariableDeclaration[?In, ?Yield, ?Await]
          VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]

        VariableDeclaration[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-variable-statement-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. 执行 ? Evaluation of |VariableDeclarationList|。
          1. 返回 ~empty~。
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. 执行 ? Evaluation of |VariableDeclarationList|。
          1. 返回 ? Evaluation of |VariableDeclaration|。
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. 返回 ~empty~。
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
          1. 令 _lhs_ 为 ? ResolveBinding(_bindingId_)。
          1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
            1. 令 _value_ 为 ? NamedEvaluation of |Initializer|，参数 _bindingId_。
          1. 否则，
            1. 令 _rhs_ 为 ? Evaluation of |Initializer|。
            1. 令 _value_ 为 ? GetValue(_rhs_)。
          1. [id="step-vardecllist-evaluation-putvalue"] 执行 ? PutValue(_lhs_, _value_)。
          1. 返回 ~empty~。
        </emu-alg>
        <emu-note>
          <p>若 |VariableDeclaration| 嵌套于 with 语句，且其 |BindingIdentifier| 与 with 绑定对象的属性同名，则步骤 <emu-xref href="#step-vardecllist-evaluation-putvalue"></emu-xref> 会把 _value_ 赋给该属性，而不是 VariableEnvironment 中的变量绑定。</p>
        </emu-note>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. 令 _rhs_ 为 ? Evaluation of |Initializer|。
          1. 令 _rVal_ 为 ? GetValue(_rhs_)。
          1. 返回 ? BindingInitialization of |BindingPattern|，参数 _rVal_ 与 *undefined*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>解构绑定模式 (Destructuring Binding Patterns)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization" type="sdo">
        <h1>
          运行时语义：PropertyBindingInitialization (
            _value_: 一个 ECMAScript 语言值,
            _environment_: 一个 Environment Record 或 *undefined*,
          ): 返回一个含属性键列表的正常完成或一个突然完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>收集所有绑定的属性名列表。</dd>
        </dl>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. 令 _boundNames_ 为 ? PropertyBindingInitialization of |BindingPropertyList|，参数 _value_ 与 _environment_。
          1. 令 _nextNames_ 为 ? PropertyBindingInitialization of |BindingProperty|，参数 _value_ 与 _environment_。
          1. 返回列表连接 _boundNames_ 与 _nextNames_。
        </emu-alg>

        <emu-grammar>BindingProperty : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. 令 _name_ 为 |SingleNameBinding| 的 BoundNames 唯一元素。
          1. 执行 ? KeyedBindingInitialization of |SingleNameBinding|，参数 _value_、_environment_、_name_。
          1. 返回 « _name_ »。
        </emu-alg>

        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. 令 _P_ 为 ? Evaluation of |PropertyName|。
          1. 执行 ? KeyedBindingInitialization of |BindingElement|，参数 _value_、_environment_、_P_。
          1. 返回 « _P_ »。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          运行时语义：RestBindingInitialization (
            _value_: 一个 ECMAScript 语言值,
            _environment_: 一个 Environment Record 或 *undefined*,
            _excludedNames_: 属性键列表,
          ): 返回含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. 令 _lhs_ 为 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_)。
          1. 令 _restObj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ? CopyDataProperties(_restObj_, _value_, _excludedNames_)。
          1. 若 _environment_ 为 *undefined*，返回 ? PutValue(_lhs_, _restObj_)。
          1. 返回 ? InitializeReferencedBinding(_lhs_, _restObj_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          运行时语义：KeyedBindingInitialization (
            _value_: 一个 ECMAScript 语言值,
            _environment_: 一个 Environment Record 或 *undefined*,
            _propertyName_: 一个属性键,
          ): 返回含 ~unused~ 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>当 _environment_ 传 *undefined* 表示需使用 PutValue 赋值。这发生在非严格函数形参列表等场景；此时形参绑定已预初始化，以应对重复名称。</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. 令 _v_ 为 ? GetV(_value_, _propertyName_)。
          1. 若存在 |Initializer| 且 _v_ 为 *undefined*，则
            1. 令 _defaultValue_ 为 ? Evaluation of |Initializer|。
            1. 设 _v_ 为 ? GetValue(_defaultValue_)。
          1. 返回 ? BindingInitialization of |BindingPattern|，参数 _v_ 与 _environment_。
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
          1. 令 _lhs_ 为 ? ResolveBinding(_bindingId_, _environment_)。
          1. 令 _v_ 为 ? GetV(_value_, _propertyName_)。
          1. 若存在 |Initializer| 且 _v_ 为 *undefined*，则
            1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
              1. 设 _v_ 为 ? NamedEvaluation of |Initializer|，参数 _bindingId_。
            1. 否则，
              1. 令 _defaultValue_ 为 ? Evaluation of |Initializer|。
              1. 设 _v_ 为 ? GetValue(_defaultValue_)。
          1. 若 _environment_ 为 *undefined*，返回 ? PutValue(_lhs_, _v_)。
          1. 返回 ? InitializeReferencedBinding(_lhs_, _v_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-empty-statement">
    <h1>空语句 (Empty Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      EmptyStatement :
        `;`
    </emu-grammar>

    <emu-clause id="sec-empty-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>EmptyStatement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-expression-statement">
    <h1>表达式语句 (Expression Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ExpressionStatement[Yield, Await] :
        [lookahead &notin; { `{`, `function`, `async` [no LineTerminator here] `function`, `class`, `let` `[` }] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>|ExpressionStatement| 不能以 U+007B `{` 开始以避免与 |Block| 歧义；不能以 `function` 或 `class` 开头以避免与 |FunctionDeclaration|、|GeneratorDeclaration| 或 |ClassDeclaration| 歧义；不能以 `async function` 开头避免与 |AsyncFunctionDeclaration| 或 |AsyncGeneratorDeclaration| 歧义；不能以 `let [` 开头避免与以数组绑定模式为首绑定的 `let` |LexicalDeclaration| 歧义。</p>
    </emu-note>

    <emu-clause id="sec-expression-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ExpressionStatement : Expression `;`</emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |Expression|。
        1. 返回 ? GetValue(_exprRef_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-if-statement">
    <h1>`if` 语句 (The `if` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      IfStatement[Yield, Await, Return] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] [lookahead != `else`]
    </emu-grammar>
    <emu-note>lookahead 限制 [lookahead ≠ `else`] 以传统方式解决“悬挂的 else”问题：当关联的 `if` 有歧义时，将 `else` 归属最近的尚未匹配的 `if`。</emu-note>

    <emu-clause id="sec-if-statement-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <ul>
        <li>若 IsLabelledFunction(第一个 |Statement|) 为 *true*，语法错误。</li>
        <li>若 IsLabelledFunction(第二个 |Statement|) 为 *true*，语法错误。</li>
      </ul>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>若 IsLabelledFunction(|Statement|) 为 *true*，语法错误。</li>
      </ul>
      <emu-note>
        <p>仅当实现了 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 中的扩展时才需应用此规则。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-if-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |Expression|。
        1. 令 _exprValue_ 为 ToBoolean(? GetValue(_exprRef_))。
        1. 若 _exprValue_ 为 *true*，则
          1. 令 _stmtCompletion_ 为 Completion(Evaluation of 第一个 |Statement|)。
        1. 否则，
          1. 令 _stmtCompletion_ 为 Completion(Evaluation of 第二个 |Statement|)。
        1. 返回 ? UpdateEmpty(_stmtCompletion_, *undefined*)。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |Expression|。
        1. 令 _exprValue_ 为 ToBoolean(? GetValue(_exprRef_))。
        1. 若 _exprValue_ 为 *false*，返回 *undefined*。
        1. 否则，
          1. 令 _stmtCompletion_ 为 Completion(Evaluation of |Statement|)。
          1. 返回 ? UpdateEmpty(_stmtCompletion_, *undefined*)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>迭代语句 (Iteration Statements)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      IterationStatement[Yield, Await, Return] :
        DoWhileStatement[?Yield, ?Await, ?Return]
        WhileStatement[?Yield, ?Await, ?Return]
        ForStatement[?Yield, ?Await, ?Return]
        ForInOfStatement[?Yield, ?Await, ?Return]
    </emu-grammar>

    <emu-clause id="sec-iteration-statements-semantics">
      <h1>语义 (Semantics)</h1>

      <emu-clause id="sec-loopcontinues" type="abstract operation">
        <h1>
          LoopContinues (
            _completion_: 一个 Completion Record,
            _labelSet_: 字符串列表,
          ): 一个 Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _completion_ 是 normal 完成，返回 *true*。
          1. 若 _completion_ 不是 continue 完成，返回 *false*。
          1. 若 _completion_.[[Target]] 为 ~empty~，返回 *true*。
          1. 若 _labelSet_ 含 _completion_.[[Target]]，返回 *true*。
            1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>在 |IterationStatement| 的 |Statement| 部分可以使用 |ContinueStatement| 开启新一轮迭代。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-loopevaluation" type="sdo">
        <h1>
          运行时语义：LoopEvaluation (
            _labelSet_: 字符串列表,
          ): 返回含 ECMAScript 语言值的正常或突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>IterationStatement : DoWhileStatement</emu-grammar>
        <emu-alg>
          1. 返回 ? DoWhileLoopEvaluation of |DoWhileStatement|，参数 _labelSet_。
        </emu-alg>
        <emu-grammar>IterationStatement : WhileStatement</emu-grammar>
        <emu-alg>
          1. 返回 ? WhileLoopEvaluation of |WhileStatement|，参数 _labelSet_。
        </emu-alg>
        <emu-grammar>IterationStatement : ForStatement</emu-grammar>
        <emu-alg>
          1. 返回 ? ForLoopEvaluation of |ForStatement|，参数 _labelSet_。
        </emu-alg>
        <emu-grammar>IterationStatement : ForInOfStatement</emu-grammar>
        <emu-alg>
          1. 返回 ? ForInOfLoopEvaluation of |ForInOfStatement|，参数 _labelSet_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-do-while-statement">
      <h1>`do`-`while` 语句 (The `do`-`while` Statement)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        DoWhileStatement[Yield, Await, Return] :
          `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
      </emu-grammar>

      <emu-clause id="sec-do-while-statement-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <ul>
          <li>若 IsLabelledFunction(|Statement|) 为 *true*，语法错误。</li>
        </ul>
        <emu-note>
          <p>仅当实现了 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 的扩展时需应用此规则。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-dowhileloopevaluation" oldids="sec-do-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          运行时语义：DoWhileLoopEvaluation (
            _labelSet_: 字符串列表,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. 令 _V_ 为 *undefined*。
          1. 重复，
            1. 令 _stmtResult_ 为 Completion(Evaluation of |Statement|)。
            1. 若 LoopContinues(_stmtResult_, _labelSet_) 为 *false*，返回 ? UpdateEmpty(_stmtResult_, _V_)。
            1. 若 _stmtResult_.[[Value]] 非 ~empty~，令 _V_ = 该值。
            1. 令 _exprRef_ 为 ? Evaluation of |Expression|。
            1. 令 _exprValue_ 为 ? GetValue(_exprRef_)。
            1. 若 ToBoolean(_exprValue_) 为 *false*，返回 _V_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-while-statement">
      <h1>`while` 语句 (The `while` Statement)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        WhileStatement[Yield, Await, Return] :
          `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-while-statement-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <ul>
          <li>若 IsLabelledFunction(|Statement|) 为 *true*，语法错误。</li>
        </ul>
        <emu-note>
          <p>仅当实现了 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 扩展时需应用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-whileloopevaluation" oldids="sec-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          运行时语义：WhileLoopEvaluation (
            _labelSet_: 字符串列表,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. 令 _V_ 为 *undefined*。
          1. 重复，
            1. 令 _exprRef_ 为 ? Evaluation of |Expression|。
            1. 令 _exprValue_ 为 ? GetValue(_exprRef_)。
            1. 若 ToBoolean(_exprValue_) 为 *false*，返回 _V_。
            1. 令 _stmtResult_ 为 Completion(Evaluation of |Statement|)。
            1. 若 LoopContinues(_stmtResult_, _labelSet_) 为 *false*，返回 ? UpdateEmpty(_stmtResult_, _V_)。
            1. 若 _stmtResult_.[[Value]] 非 ~empty~，设 _V_ 为该值。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-statement">
      <h1>`for` 语句 (The `for` Statement)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        ForStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-for-statement-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>
          ForStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <ul>
          <li>若 IsLabelledFunction(|Statement|) 为 *true*，语法错误。</li>
        </ul>
        <emu-note>
          <p>仅当实现 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 扩展时适用。</p>
        </emu-note>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <ul>
          <li>若 |LexicalDeclaration| 的 BoundNames 中任一元素出现在 |Statement| 的 VarDeclaredNames 中，语法错误。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          运行时语义：ForLoopEvaluation (
            _labelSet_: 字符串列表,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. 若首个 |Expression| 存在，令 _exprRef_ 为其求值；执行 ? GetValue(_exprRef_)。
          1. 若第二个存在，令 _test_ 为该表达式，否则 ~empty~。
          1. 若第三个存在，令 _increment_ 为该表达式，否则 ~empty~。
          1. 返回 ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_)。
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. 执行 ? Evaluation of |VariableDeclarationList|。
          1. 若首个 |Expression| 存在令 _test_ = 它，否则 ~empty~。
          1. 若第二个 |Expression| 存在令 _increment_ = 它，否则 ~empty~。
          1. 返回 ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_)。
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. 令 _oldEnv_ 为当前执行上下文的 LexicalEnvironment。
          1. 令 _loopEnv_ 为 NewDeclarativeEnvironment(_oldEnv_)。
          1. 令 _isConst_ 为 |LexicalDeclaration| 的 IsConstantDeclaration。
          1. 令 _boundNames_ 为 |LexicalDeclaration| 的 BoundNames。
          1. 对 _boundNames_ 中每个 _dn_：
            1. 若 _isConst_ 为 *true*，执行 ! _loopEnv_.CreateImmutableBinding(_dn_, *true*)。
            1. 否则执行 ! _loopEnv_.CreateMutableBinding(_dn_, *false*)。
          1. 设置当前执行上下文 LexicalEnvironment 为 _loopEnv_。
          1. 令 _forDcl_ 为 Completion(Evaluation of |LexicalDeclaration|)。
          1. 若 _forDcl_ 为突然完成：
            1. 恢复 LexicalEnvironment 为 _oldEnv_。
            1. 返回 ? _forDcl_。
          1. 若 _isConst_ 为 *false*，令 _perIterationLets_ = _boundNames_；否则为空列表。
          1. 若首个 |Expression| 存在令 _test_ 为其，否则 ~empty~。
          1. 若第二个 |Expression| 存在令 _increment_ 为其，否则 ~empty~。
          1. 令 _bodyResult_ 为 Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_))。
          1. 恢复 LexicalEnvironment 为 _oldEnv_。
          1. 返回 ? _bodyResult_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" type="abstract operation">
        <h1>
          ForBodyEvaluation (
            _test_: |Expression| Parse Node 或 ~empty~,
            _increment_: |Expression| Parse Node 或 ~empty~,
            _stmt_: |Statement| Parse Node,
            _perIterationBindings_: 字符串列表,
            _labelSet_: 字符串列表,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 令 _V_ = *undefined*。
          1. 执行 ? CreatePerIterationEnvironment(_perIterationBindings_)。
          1. 重复：
            1. 若 _test_ 非 ~empty~：
              1. 令 _testRef_ 为 ? Evaluation of _test_。
              1. 令 _testValue_ 为 ? GetValue(_testRef_)。
              1. 若 ToBoolean(_testValue_) 为 *false*，返回 _V_。
            1. 令 _result_ 为 Completion(Evaluation of _stmt_)。
            1. 若 LoopContinues(_result_, _labelSet_) 为 *false*，返回 ? UpdateEmpty(_result_, _V_)。
            1. 若 _result_.[[Value]] 非 ~empty~，设 _V_ 为该值。
            1. 执行 ? CreatePerIterationEnvironment(_perIterationBindings_)。
            1. 若 _increment_ 非 ~empty~：
              1. 令 _incRef_ 为 ? Evaluation of _increment_。
              1. 执行 ? GetValue(_incRef_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" type="abstract operation">
        <h1>
          CreatePerIterationEnvironment (
            _perIterationBindings_: 字符串列表,
          ): 返回 ~unused~ 的正常或抛出完成
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 若 _perIterationBindings_ 非空：
            1. 令 _lastIterationEnv_ 为当前执行上下文的 LexicalEnvironment。
            1. 令 _outer_ 为 _lastIterationEnv_.[[OuterEnv]]。
            1. 断言 _outer_ 非 *null*。
            1. 令 _thisIterationEnv_ 为 NewDeclarativeEnvironment(_outer_)。
            1. 对 _perIterationBindings_ 中每个 _bn_：
              1. 执行 ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*)。
              1. 令 _lastValue_ 为 ? _lastIterationEnv_.GetBindingValue(_bn_, *true*)。
              1. 执行 ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_)。
            1. 将当前 LexicalEnvironment 设为 _thisIterationEnv_。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>`for`-`in`、`for`-`of` 与 `for`-`await`-`of` 语句</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; { `let`, `async` `of` }] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await] :
          LetOrConst ForBinding[?Yield, ?Await]

        ForBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await]
          BindingPattern[?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>若 IsLabelledFunction(|Statement|) 为 *true*，语法错误。</li>
        </ul>
        <emu-note>
          <p>仅在实现 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 扩展时适用。</p>
        </emu-note>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>若 |LeftHandSideExpression| 为 |ObjectLiteral| 或 |ArrayLiteral|，其必须覆盖一个 |AssignmentPattern|。</li>
          <li>否则若其 AssignmentTargetType 为 ~invalid~，语法错误。</li>
        </ul>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>若 |ForDeclaration| 的 BoundNames 含 *"let"*，语法错误。</li>
          <li>若 BoundNames 的任一元素出现在 |Statement| 的 VarDeclaredNames 中，语法错误。</li>
          <li>若 BoundNames 含重复条目，语法错误。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-isdestructuring" oldids="sec-static-semantics-static-semantics-isdestructuring,sec-for-in-and-for-of-statements-static-semantics-isdestructuring" type="sdo">
        <h1>静态语义：IsDestructuring ( ): Boolean</h1>
        <dl class="header"></dl>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. 若 |PrimaryExpression| 是 |ObjectLiteral| 或 |ArrayLiteral|，返回 *true*。
          1. 否则返回 *false*。
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            MemberExpression `.` PrivateIdentifier

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
            OptionalExpression
        </emu-grammar>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. 返回 IsDestructuring of |ForBinding|。
        </emu-alg>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>ForBinding : BindingPattern</emu-grammar>
        <emu-alg>
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginitialization" oldids="sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization" type="sdo">
        <h1>
          运行时语义：ForDeclarationBindingInitialization (
            _value_: ECMAScript 语言值,
            _environment_: Environment Record 或 *undefined*,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-note>
          <p>传 *undefined* 表示应使用 PutValue 赋值。适用于 `var` 语句以及某些非严格函数形参（参见 <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>）。这些场景下词法绑定被提升并预初始化。</p>
        </emu-note>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. 返回 ? BindingInitialization of |ForBinding|，参数 _value_ 与 _environment_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          运行时语义：ForDeclarationBindingInstantiation (
            _environment_: 一个 Declarative Environment Record,
          ): ~unused~
        </h1>
        <dl class="header"></dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. 对 |ForBinding| 的 BoundNames 每个 _name_：
            1. 若 IsConstantDeclaration of |LetOrConst| 为 *true*，执行 ! _environment_.CreateImmutableBinding(_name_, *true*)。
            1. 否则执行 ! _environment_.CreateMutableBinding(_name_, *false*)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofloopevaluation" oldids="sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          运行时语义：ForInOfLoopEvaluation (
            _labelSet_: 字符串列表,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. 令 _keyResult_ 为 ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_)。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_)。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_)。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_)。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_)。
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_)。
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~)。
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~)。
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. _keyResult_ ← ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~)。
          1. 返回 ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~)。
        </emu-alg>
        <emu-note>
          <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofheadevaluation" type="abstract operation" oldids="sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">
        <h1>
          ForIn/OfHeadEvaluation (
            _uninitializedBoundNames_: 字符串列表,
            _expr_: |Expression| 或 |AssignmentExpression| Parse Node,
            _iterationKind_: ~enumerate~ / ~iterate~ / ~async-iterate~,
          ): Iterator Record 或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 令 _oldEnv_ 为当前执行上下文 LexicalEnvironment。
          1. 若 _uninitializedBoundNames_ 非空：
            1. 断言无重复。
            1. 令 _newEnv_ 为 NewDeclarativeEnvironment(_oldEnv_)。
            1. 对每个 _name_ 执行 ! _newEnv_.CreateMutableBinding(_name_, *false*)。
            1. 设置当前 LexicalEnvironment 为 _newEnv_。
          1. 令 _exprRef_ 为 Completion(Evaluation of _expr_)。
          1. 恢复 LexicalEnvironment 为 _oldEnv_。
          1. 令 _exprValue_ 为 ? GetValue(? _exprRef_)。
          1. 若 _iterationKind_ 为 ~enumerate~：
            1. 若 _exprValue_ 为 *undefined* 或 *null*：
              1. 返回 Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }。
            1. 令 _obj_ = ! ToObject(_exprValue_)。
            1. 令 _iterator_ = EnumerateObjectProperties(_obj_)。
            1. 令 _nextMethod_ = ! GetV(_iterator_, *"next"*)。
            1. 返回 Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }。
          1. 否则：
            1. 断言 _iterationKind_ 为 ~iterate~ 或 ~async-iterate~。
            1. 若为 ~async-iterate~ 则 _iteratorKind_ = ~async~ 否则 ~sync~。
            1. 返回 ? GetIterator(_exprValue_, _iteratorKind_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
          _lhs_: Parse Node,
          _stmt_: |Statement| Parse Node,
          _iteratorRecord_: Iterator Record,
          _iterationKind_: ~enumerate~ 或 ~iterate~,
          _lhsKind_: ~assignment~ / ~var-binding~ / ~lexical-binding~,
          _labelSet_: 字符串列表,
          可选 _iteratorKind_: ~sync~ / ~async~,
          ): 正常或突然完成
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 若未给出 _iteratorKind_，设为 ~sync~。
          1. 令 _oldEnv_ 为当前 LexicalEnvironment。
          1. 令 _V_ = *undefined*。
          1. 令 _destructuring_ = IsDestructuring of _lhs_。
          1. 若 _destructuring_ 为 *true* 且 _lhsKind_ 为 ~assignment~：
            1. 断言 _lhs_ 是 |LeftHandSideExpression|。
            1. 令 _assignmentPattern_ 为其覆盖的 |AssignmentPattern|。
          1. 循环：
            1. 令 _nextResult_ = ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]])。
            1. 若 _iteratorKind_ 为 ~async~，设 _nextResult_ = ? Await(_nextResult_)。
            1. 若 _nextResult_ 非 Object 抛 *TypeError*。
            1. 令 _done_ = ? IteratorComplete(_nextResult_)。
            1. 若 _done_ 为 *true*，返回 _V_。
            1. 令 _nextValue_ = ? IteratorValue(_nextResult_)。
            1. 若 _lhsKind_ 为 ~assignment~ 或 ~var-binding~：
              1. 若 _destructuring_ 为 *true*：
                1. 若 _lhsKind_ 为 ~assignment~：
                  1. 令 _status_ = Completion(DestructuringAssignmentEvaluation of _assignmentPattern_，参数 _nextValue_)。
                1. 否则 (var-binding)：
                  1. 断言 _lhs_ 为 |ForBinding|。
                  1. 令 _status_ = Completion(BindingInitialization of _lhs_, 参数 _nextValue_ 与 *undefined*)。
              1. 否则：
                1. 令 _lhsRef_ = Completion(Evaluation of _lhs_)（可重复求值）。
                1. 若 _lhsKind_ 为 ~assignment~ 且 AssignmentTargetType 为 ~web-compat~ 抛 *ReferenceError*。
                1. 若 _lhsRef_ 为突然完成则 _status_ = _lhsRef_；否则 _status_ = Completion(PutValue(_lhsRef_.[[Value]], _nextValue_))。
            1. 否则 (lexical-binding)：
              1. 断言 _lhs_ 为 |ForDeclaration|。
              1. 令 _iterationEnv_ = NewDeclarativeEnvironment(_oldEnv_)。
              1. 执行 ForDeclarationBindingInstantiation of _lhs_ 参数 _iterationEnv_。
              1. 设当前 LexicalEnvironment = _iterationEnv_。
              1. 若 _destructuring_ 为 *true*：
                1. _status_ = Completion(ForDeclarationBindingInitialization of _lhs_, 参数 _nextValue_ 与 _iterationEnv_)。
              1. 否则：
                1. 断言 _lhs_ 绑定单一名字。
                1. 令 _lhsName_ 为唯一 BoundName。
                1. 令 _lhsRef_ = ! ResolveBinding(_lhsName_)。
                1. _status_ = Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_))。
            1. 若 _status_ 为突然完成：
              1. 恢复 LexicalEnvironment 为 _oldEnv_。
              1. 若 _iteratorKind_ 为 ~async~ 返回 ? AsyncIteratorClose(_iteratorRecord_, _status_)。
              1. 若 _iterationKind_ 为 ~enumerate~ 返回 ? _status_。
              1. 否则返回 ? IteratorClose(_iteratorRecord_, _status_)。
            1. 令 _result_ 为 Completion(Evaluation of _stmt_)。
            1. 恢复 LexicalEnvironment 为 _oldEnv_。
            1. 若 LoopContinues(_result_, _labelSet_) 为 *false*：
              1. 若 _iterationKind_ 为 ~enumerate~ 返回 ? UpdateEmpty(_result_, _V_)。
              1. 否则：
                1. 设 _status_ = Completion(UpdateEmpty(_result_, _V_))。
                1. 若 _iteratorKind_ 为 ~async~ 返回 ? AsyncIteratorClose(_iteratorRecord_, _status_)。
                1. 返回 ? IteratorClose(_iteratorRecord_, _status_)。
            1. 若 _result_.[[Value]] 非 ~empty~，设 _V_ = 该值。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>
          BindingIdentifier :
            Identifier
            `yield`
            `await`
        </emu-grammar>
        <emu-alg>
          1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
          1. 返回 ? ResolveBinding(_bindingId_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-enumerate-object-properties" type="abstract operation">
        <h1>
          EnumerateObjectProperties (
            _O_: 一个 Object,
          ): 一个迭代器对象
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. 返回一个迭代器对象，其 `next` 方法按规则遍历 _O_ 的可枚举属性的字符串键。该迭代器对象不可被 ECMAScript 代码直接获取。枚举顺序未指定，但必须符合下述规则。
        </emu-alg>
        <p>迭代器的 `throw` 与 `return` 方法为 *null* 且不会被调用。`next` 决定是否返回一个属性键；不返回 Symbol 键。枚举期间可删除目标对象属性，被删且尚未处理的属性被忽略；新增属性不保证出现在当前枚举。每个名称最多返回一次。</p>
        <p>枚举包括原型链上可枚举属性；若某原型属性与已处理属性同名则跳过，不比较 [[Enumerable]]。原型对象的可枚举属性名通过再次调用 EnumerateObjectProperties 获得。目标对象的自有属性键通过其 [[OwnPropertyKeys]] 获得，属性属性值通过 [[GetOwnProperty]] 获得。</p>
        <p>另外，若 _O_ 及其原型链均非 Proxy / TypedArray / module namespace 或实现自定义 exotic，则该迭代器行为须与 CreateForInIterator(_O_) 所给迭代器一致，直到出现以下任一情况：</p>
        <ul>
          <li>原型链中任意对象的 [[Prototype]] 发生变化；</li>
          <li>_O_ 或其原型链某对象删除属性；</li>
          <li>原型链某对象新增属性；</li>
          <li>_O_ 或原型链某对象属性的 [[Enumerable]] 值改变。</li>
        </ul>

        <emu-note>
          <p>实现无需直接实现 <emu-xref href="#sec-%foriniteratorprototype%.next"></emu-xref> 的算法，只要行为一致即可。</p>
          <p>下列生成器函数是符合规则的示例：</p>
          <pre><code class="javascript">
            function* EnumerateObjectProperties(obj) {
              const visited = new Set();
              for (const key of Reflect.ownKeys(obj)) {
                if (typeof key === "symbol") continue;
                const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                if (desc) {
                  visited.add(key);
                  if (desc.enumerable) yield key;
                }
              }
              const proto = Reflect.getPrototypeOf(obj);
              if (proto === null) return;
              for (const protoKey of EnumerateObjectProperties(proto)) {
                if (!visited.has(protoKey)) yield protoKey;
              }
            }
          </code></pre>
        </emu-note>
        <emu-note>
          例外 exotic 列表基于历史实现差异，其余保持一致。
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-iterator-objects">
        <h1>For-In 迭代器对象 (For-In Iterator Objects)</h1>
        <p><dfn variants="For-In Iterator object,For-In Iterator objects">For-In Iterator</dfn> 表示对特定对象的一次具体迭代，不能被脚本直接访问，仅用于描述 EnumerateObjectProperties 的行为。</p>

        <emu-clause id="sec-createforiniterator" type="abstract operation">
          <h1>
            CreateForInIterator (
              _object_: 一个 Object,
            ): 一个 For-In Iterator
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>创建针对 _object_ 自有及继承可枚举字符串属性按特定顺序遍历的 For-In Iterator 对象。</dd>
          </dl>
          <emu-alg>
            1. 令 _iterator_ = OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »)。
            1. _iterator_.[[Object]] ← _object_。
            1. _iterator_.[[ObjectWasVisited]] ← *false*。
            1. _iterator_.[[VisitedKeys]] ← 空 List。
            1. _iterator_.[[RemainingKeys]] ← 空 List。
            1. 返回 _iterator_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%foriniteratorprototype%-object">
          <h1>%ForInIteratorPrototype% 对象</h1>
          <p><dfn>%ForInIteratorPrototype%</dfn> 对象：</p>
          <ul>
            <li>其属性被所有 For-In Iterator 对象继承；</li>
            <li>是普通对象；</li>
            <li>[[Prototype]] 为 %Iterator.prototype%；</li>
            <li>不可被脚本直接访问；</li>
            <li>具有如下属性：</li>
          </ul>

          <emu-clause id="sec-%foriniteratorprototype%.next">
            <h1>%ForInIteratorPrototype%.next ( )</h1>
            <emu-alg>
              1. 令 _O_ 为 *this*。
              1. 断言 _O_ 是 Object。
              1. 断言 _O_ 具 For-In Iterator 所有内部槽。
              1. 令 _object_ = _O_.[[Object]]。
              1. 重复：
                1. 若 _O_.[[ObjectWasVisited]] 为 *false*：
                  1. 令 _keys_ = ? <emu-meta effects="user-code">_object_.[[OwnPropertyKeys]]()</emu-meta>。
                  1. 对 _keys_ 每个 _key_：
                    1. 若 _key_ 是 String，追加到 _O_.[[RemainingKeys]]。
                  1. 设 _O_.[[ObjectWasVisited]] = *true*。
                1. 当 _O_.[[RemainingKeys]] 非空重复：
                  1. 令 _r_ 为首元素。
                  1. 移除之。
                  1. 若 _O_.[[VisitedKeys]] 不含 _r_：
                    1. 令 _desc_ = ? <emu-meta effects="user-code">_object_.[[GetOwnProperty]]</emu-meta>(_r_)。
                    1. 若 _desc_ 非 *undefined*：
                      1. 追加 _r_ 至 _O_.[[VisitedKeys]]。
                      1. 若 _desc_.[[Enumerable]] 为 *true*，返回 CreateIteratorResultObject(_r_, *false*)。
                1. 设 _object_ = ? <emu-meta effects="user-code">_object_.[[GetPrototypeOf]]()</emu-meta>。
                1. 设 _O_.[[Object]] = _object_。
                1. 设 _O_.[[ObjectWasVisited]] = *false*。
                1. 若 _object_ 为 *null*，返回 CreateIteratorResultObject(*undefined*, *true*)。
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-properties-of-for-in-iterator-instances">
          <h1>For-In 迭代器实例属性 (Properties of For-In Iterator Instances)</h1>
          <p>实例为普通对象，继承自 %ForInIteratorPrototype%，初始拥有下表内部槽：</p>
          <emu-table id="table-for-in-iterator-instance-slots" caption="For-In 迭代器实例内部槽 (Internal Slots of For-In Iterator Instances)">
            <table>
              <thead>
                <tr>
                  <th>内部槽</th>
                  <th>类型</th>
                  <th>描述</th>
                </tr>
              </thead>
              <tr>
                <td>[[Object]]</td>
                <td>Object</td>
                <td>被枚举属性的对象。</td>
              </tr>
              <tr>
                <td>[[ObjectWasVisited]]</td>
                <td>Boolean</td>
                <td>若已在 [[Object]] 上调用 [[OwnPropertyKeys]] 则 *true*，否则 *false*。</td>
              </tr>
              <tr>
                <td>[[VisitedKeys]]</td>
                <td>字符串列表</td>
                <td>迄今已发出的键。</td>
              </tr>
              <tr>
                <td>[[RemainingKeys]]</td>
                <td>字符串列表</td>
                <td>当前对象剩余未发出的键（在遍历原型链之前）。</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-continue-statement">
    <h1>`continue` 语句 (The `continue` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ContinueStatement[Yield, Await] :
        `continue` `;`
        `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-continue-statement-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>
        ContinueStatement :
          `continue` `;`
          `continue` LabelIdentifier `;`
      </emu-grammar>
      <ul>
        <li>若该 |ContinueStatement| 未（直接或间接且不跨函数或 `static` 初始化块）嵌套于 |IterationStatement|，语法错误。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-continue-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. 返回 Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }。
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 返回 Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-break-statement">
    <h1>`break` 语句 (The `break` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      BreakStatement[Yield, Await] :
        `break` `;`
        `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-break-statement-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <ul>
        <li>若该 |BreakStatement| 未（直接或间接且不跨函数或 `static` 初始化块）嵌套于 |IterationStatement| 或 |SwitchStatement|，语法错误。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-break-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. 返回 Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }。
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 返回 Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-return-statement">
    <h1>`return` 语句 (The `return` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ReturnStatement[Yield, Await] :
        `return` `;`
        `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>`return` 语句使函数终止执行并（大多数情况下）向调用者返回值；若省略 |Expression|，返回 *undefined*。在某些上下文（如 `try`/`finally`）中，返回值可能被之后的 Completion 替换。</p>
    </emu-note>

    <emu-clause id="sec-return-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ReturnStatement : `return` `;`</emu-grammar>
      <emu-alg>
        1. 返回 ReturnCompletion(*undefined*)。
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |Expression|。
        1. 令 _exprValue_ 为 ? GetValue(_exprRef_)。
        1. 若 GetGeneratorKind() 为 ~async~，设 _exprValue_ = ? Await(_exprValue_)。
        1. 返回 ReturnCompletion(_exprValue_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-with-statement" legacy>
    <h1>`with` 语句 (The `with` Statement)</h1>
    <emu-note>
      <p>不建议在新代码中使用遗留 `with` 语句；可考虑在严格和非严格模式都允许的替代方案，如 <emu-xref href="#sec-destructuring-assignment">解构赋值</emu-xref>。</p>
    </emu-note>

    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      WithStatement[Yield, Await, Return] :
        `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <emu-note>
      <p>`with` 语句把对象环境记录加入当前词法环境，然后使用扩展环境执行语句，结束后恢复原环境。</p>
    </emu-note>

    <emu-clause id="sec-with-statement-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>若 IsStrict(this production) 为 *true*，语法错误。</li>
        <li>若 IsLabelledFunction(|Statement|) 为 *true*，语法错误。</li>
      </ul>
      <emu-note>
        <p>仅在实现 <emu-xref href="#sec-labelled-function-declarations"></emu-xref> 扩展时需应用第二条。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-with-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _val_ 为 ? Evaluation of |Expression|。
        1. 令 _obj_ 为 ? ToObject(? GetValue(_val_))。
        1. 令 _oldEnv_ 为当前 LexicalEnvironment。
        1. 令 _newEnv_ 为 NewObjectEnvironment(_obj_, *true*, _oldEnv_)。
        1. 设置当前 LexicalEnvironment 为 _newEnv_。
        1. 令 _C_ 为 Completion(Evaluation of |Statement|)。
        1. 恢复 LexicalEnvironment 为 _oldEnv_。
        1. 返回 ? UpdateEmpty(_C_, *undefined*)。
      </emu-alg>
      <emu-note>
        <p>无论 |Statement| 如何结束（正常与否），LexicalEnvironment 都会被恢复。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>`switch` 语句 (The `switch` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      SwitchStatement[Yield, Await, Return] :
        `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]

      CaseBlock[Yield, Await, Return] :
        `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
        `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`

      CaseClauses[Yield, Await, Return] :
        CaseClause[?Yield, ?Await, ?Return]
        CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

      CaseClause[Yield, Await, Return] :
        `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?

      DefaultClause[Yield, Await, Return] :
        `default` `:` StatementList[?Yield, ?Await, ?Return]?
    </emu-grammar>

    <emu-clause id="sec-switch-statement-static-semantics-early-errors" oldids="sec-switch-duplicates-allowed-static-semantics">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <ul>
        <li>
          <p>若 |CaseBlock| 的 LexicallyDeclaredNames 含重复条目则语法错误<span normative-optional>；除非宿主是 web 浏览器或支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 且：</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) 为 *false*；</li>
            <li>重复条目仅由 FunctionDeclarations 绑定。</li>
          </ul>
        </li>
        <li>若 |CaseBlock| 的 LexicallyDeclaredNames 与其 VarDeclaredNames 有交集，语法错误。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseblockevaluation" type="sdo">
      <h1>
        运行时语义：CaseBlockEvaluation (
          _input_: ECMAScript 语言值,
        ): 正常或突然完成
      </h1>
      <dl class="header"></dl>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *undefined*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses `}`</emu-grammar>
      <emu-alg>
        1. _V_ ← *undefined*。
        1. _A_ ← 按源码顺序的 |CaseClause| 列表。
        1. _found_ ← *false*。
        1. 对每个 _C_ ∈ _A_：
          1. 若 _found_ 为 *false*，设 _found_ ← ? CaseClauseIsSelected(_C_, _input_)。
          1. 若 _found_ 为 *true*：
            1. _R_ ← Completion(Evaluation of _C_)。
            1. 若 _R_.[[Value]] 非 ~empty~，_V_ ← _R_.[[Value]]。
            1. 若 _R_ 为突然完成，返回 ? UpdateEmpty(_R_, _V_)。
        1. 返回 _V_。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. _V_ ← *undefined*。
        1. 若首个 |CaseClauses| 存在，_A_ ← 其 |CaseClause| 列表；否则空列表。
        1. _found_ ← *false*。
        1. 对 _A_ 中每个 _C_：
          1. 若 _found_ 为 *false*，_found_ ← ? CaseClauseIsSelected(_C_, _input_)。
          1. 若 _found_ 为 *true*：
            1. _R_ ← Completion(Evaluation of _C_)。
            1. 若 _R_.[[Value]] 非 ~empty~，_V_ ← _R_.[[Value]]。
            1. 若 _R_ 为突然完成，返回 ? UpdateEmpty(_R_, _V_)。
        1. _foundInB_ ← *false*。
        1. 若第二个 |CaseClauses| 存在，_B_ ← 其列表；否则空列表。
        1. 若 _found_ 为 *false*：
          1. 对 _B_ 中每个 _C_：
            1. 若 _foundInB_ 为 *false*，_foundInB_ ← ? CaseClauseIsSelected(_C_, _input_)。
            1. 若 _foundInB_ 为 *true*：
              1. _R_ ← Completion(Evaluation of _C_)。
              1. 若 _R_.[[Value]] 非 ~empty~，_V_ ← _R_.[[Value]]。
              1. 若 _R_ 为突然完成，返回 ? UpdateEmpty(_R_, _V_)。
        1. 若 _foundInB_ 为 *true*，返回 _V_。
        1. _defaultR_ ← Completion(Evaluation of |DefaultClause|)。
        1. 若 _defaultR_.[[Value]] 非 ~empty~，_V_ ← _defaultR_.[[Value]]。
        1. 若 _defaultR_ 为突然完成，返回 ? UpdateEmpty(_defaultR_, _V_)。
        1. 注：以下再次遍历 _B_。
        1. 对 _B_ 中每个 _C_：
          1. _R_ ← Completion(Evaluation of _C_)。
          1. 若 _R_.[[Value]] 非 ~empty~，_V_ ← _R_.[[Value]]。
          1. 若 _R_ 为突然完成，返回 ? UpdateEmpty(_R_, _V_)。
        1. 返回 _V_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseclauseisselected" type="abstract operation" oldids="sec-runtime-semantics-caseselectorevaluation">
      <h1>
        CaseClauseIsSelected (
          _C_: |CaseClause| Parse Node,
          _input_: ECMAScript 语言值,
        ): 正常完成含 Boolean 或突然完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断 _C_ 是否匹配 _input_。</dd>
      </dl>
      <emu-alg>
        1. 断言 _C_ 为产生式 <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar> 实例。
        1. 令 _exprRef_ 为 ? Evaluation of _C_ 的 |Expression|。
        1. 令 _clauseSelector_ 为 ? GetValue(_exprRef_)。
        1. 返回 IsStrictlyEqual(_input_, _clauseSelector_)。
      </emu-alg>
      <emu-note>
        <p>该操作不执行 _C_ 的 |StatementList|。|CaseBlock| 算法根据其返回值决定从哪个 |StatementList| 开始。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. _exprRef_ ← ? Evaluation of |Expression|。
        1. _switchValue_ ← ? GetValue(_exprRef_)。
        1. _oldEnv_ ← 当前 LexicalEnvironment。
        1. _blockEnv_ ← NewDeclarativeEnvironment(_oldEnv_)。
        1. 执行 BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_)。
        1. 设置 LexicalEnvironment = _blockEnv_。
        1. _R_ ← Completion(CaseBlockEvaluation of |CaseBlock|, 参数 _switchValue_)。
        1. 恢复 LexicalEnvironment = _oldEnv_。
        1. 返回 _R_。
      </emu-alg>
      <emu-note>
        <p>无论控制如何离开 |SwitchStatement|，LexicalEnvironment 皆被恢复。</p>
      </emu-note>
      <emu-grammar>CaseClause : `case` Expression `:`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList</emu-grammar>
      <emu-alg>
        1. 返回 ? Evaluation of |StatementList|。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList</emu-grammar>
      <emu-alg>
        1. 返回 ? Evaluation of |StatementList|。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-labelled-statements">
    <h1>带标签语句 (Labelled Statements)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      LabelledStatement[Yield, Await, Return] :
        LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]

      LabelledItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        FunctionDeclaration[?Yield, ?Await, ~Default]
    </emu-grammar>
    <emu-note>
      <p>|Statement| 可带标签。标签语句仅配合带标签的 `break` / `continue`；语言无 `goto`。标签递归嵌套形成“当前标签集合”。</p>
    </emu-note>

    <emu-clause id="sec-labelled-statements-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>若源码匹配该产生式则语法错误<span normative-optional>，除非源码为非严格且宿主为 web 浏览器或支持 <emu-xref href="#sec-labelled-function-declarations" title></emu-xref></span>。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-islabelledfunction" type="abstract operation">
      <h1>
        静态语义：IsLabelledFunction (
          _stmt_: |Statement| Parse Node,
        ): Boolean
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. 若 _stmt_ 不是 |LabelledStatement|，返回 *false*。
        1. 令 _item_ 为其 |LabelledItem|。
        1. 若 _item_ 是 <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>，返回 *true*。
        1. 令 _subStmt_ 为 _item_ 的 |Statement|。
        1. 返回 IsLabelledFunction(_subStmt_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 ? LabelledEvaluation of 此 |LabelledStatement|，参数 « »。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-labelledevaluation" oldids="sec-statement-semantics-runtime-semantics-labelledevaluation,sec-labelled-statements-runtime-semantics-labelledevaluation" type="sdo">
      <h1>
        运行时语义：LabelledEvaluation (
          _labelSet_: 字符串列表,
        ): 正常完成含 ECMAScript 语言值或 ~empty~，或突然完成
      </h1>
      <dl class="header"></dl>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ ← Completion(LoopEvaluation of |IterationStatement|, 参数 _labelSet_)。
        1. 若 _stmtResult_ 是 break 完成：
          1. 且 _stmtResult_.[[Target]] 为 ~empty~：
            1. 若 _stmtResult_.[[Value]] 为 ~empty~，设其为 NormalCompletion(*undefined*)；否则设为其值的 NormalCompletion。
        1. 返回 ? _stmtResult_。
      </emu-alg>
      <emu-grammar>BreakableStatement : SwitchStatement</emu-grammar>
      <emu-alg>
        1. _stmtResult_ ← Completion(Evaluation of |SwitchStatement|)。
        1. 若为 break 且 [[Target]] 为 ~empty~：
          1. 若 [[Value]] 为 ~empty~ 设为 NormalCompletion(*undefined*) 否则为该值。
        1. 返回 ? _stmtResult_。
      </emu-alg>
      <emu-note>
        <p>|BreakableStatement| 是能被无标签 |BreakStatement| 退出的语句。</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. _label_ ← StringValue of |LabelIdentifier|。
        1. _newLabelSet_ ← 连接 _labelSet_ 与 « _label_ »。
        1. _stmtResult_ ← Completion(LabelledEvaluation of |LabelledItem|, 参数 _newLabelSet_)。
        1. 若 _stmtResult_ 是 break 且 [[Target]] 为 _label_，则设为 NormalCompletion(_stmtResult_.[[Value]])。
        1. 返回 ? _stmtResult_。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 ? Evaluation of |FunctionDeclaration|。
      </emu-alg>
      <emu-grammar>
        Statement :
          BlockStatement
          VariableStatement
          EmptyStatement
          ExpressionStatement
          IfStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          WithStatement
          ThrowStatement
          TryStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 返回 ? Evaluation of |Statement|。
      </emu-alg>
      <emu-note>
        <p>|Statement| 中仅 |BreakableStatement| 与 |LabelledStatement| 在 LabelledEvaluation 有特殊语义。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-throw-statement">
    <h1>`throw` 语句 (The `throw` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ThrowStatement[Yield, Await] :
        `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-throw-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ThrowStatement : `throw` Expression `;`</emu-grammar>
      <emu-alg>
        1. _exprRef_ ← ? Evaluation of |Expression|。
        1. _exprValue_ ← ? GetValue(_exprRef_)。
        1. 返回 ThrowCompletion(_exprValue_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-try-statement">
    <h1>`try` 语句 (The `try` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      TryStatement[Yield, Await, Return] :
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

      Catch[Yield, Await, Return] :
        `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
        `catch` Block[?Yield, ?Await, ?Return]

      Finally[Yield, Await, Return] :
        `finally` Block[?Yield, ?Await, ?Return]

      CatchParameter[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`try` 语句封装可能发生异常的代码块；`catch` 提供处理逻辑；被捕获异常绑定到 |CatchParameter|。</p>
    </emu-note>

    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>|CatchParameter| 的 BoundNames 若含重复，语法错误。</li>
        <li>若其任一元素出现在 |Block| 的 LexicallyDeclaredNames 中，语法错误。</li>
        <li>若其任一元素出现在 |Block| 的 VarDeclaredNames 中语法错误<span normative-optional>；除非 |CatchParameter| 为 <emu-grammar>CatchParameter : BindingIdentifier</emu-grammar> 且宿主为 web 浏览器或支持 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref></span>。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-catchclauseevaluation" type="sdo">
      <h1>
        运行时语义：CatchClauseEvaluation (
          _thrownValue_: ECMAScript 语言值,
        ): 正常完成含 ECMAScript 语言值或 ~empty~，或突然完成
      </h1>
      <dl class="header"></dl>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. _oldEnv_ ← 当前 LexicalEnvironment。
        1. _catchEnv_ ← NewDeclarativeEnvironment(_oldEnv_)。
        1. 对 |CatchParameter| 的 BoundNames 中每个 _argName_：
          1. 执行 ! _catchEnv_.CreateMutableBinding(_argName_, *false*)。
        1. 设置 LexicalEnvironment = _catchEnv_。
        1. _status_ ← Completion(BindingInitialization of |CatchParameter|，参数 _thrownValue_ 与 _catchEnv_)。
        1. 若 _status_ 为突然完成：
          1. 恢复 LexicalEnvironment = _oldEnv_。
          1. 返回 ? _status_。
        1. _B_ ← Completion(Evaluation of |Block|)。
        1. 恢复 LexicalEnvironment = _oldEnv_。
        1. 返回 ? _B_。
      </emu-alg>
      <emu-grammar>Catch : `catch` Block</emu-grammar>
      <emu-alg>
        1. 返回 ? Evaluation of |Block|。
      </emu-alg>
      <emu-note>
        <p>无论 |Block| 如何离开，LexicalEnvironment 都被恢复。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. _B_ ← Completion(Evaluation of |Block|)。
        1. 若 _B_ 为 throw 完成，_C_ ← Completion(CatchClauseEvaluation of |Catch|, 参数 _B_.[[Value]])；否则 _C_ ← _B_。
        1. 返回 ? UpdateEmpty(_C_, *undefined*)。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. _B_ ← Completion(Evaluation of |Block|)。
        1. _F_ ← Completion(Evaluation of |Finally|)。
        1. 若 _F_ 为 normal，设 _F_ ← _B_。
        1. 返回 ? UpdateEmpty(_F_, *undefined*)。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. _B_ ← Completion(Evaluation of |Block|)。
        1. 若 _B_ 为 throw，_C_ ← Completion(CatchClauseEvaluation of |Catch|, 参数 _B_.[[Value]])；否则 _C_ ← _B_。
        1. _F_ ← Completion(Evaluation of |Finally|)。
        1. 若 _F_ 为 normal，设 _F_ ← _C_。
        1. 返回 ? UpdateEmpty(_F_, *undefined*)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-debugger-statement">
    <h1>`debugger` 语句 (The `debugger` Statement)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      DebuggerStatement :
        `debugger` `;`
    </emu-grammar>

    <emu-clause id="sec-debugger-statement-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-note>
        <p>求值 |DebuggerStatement| 时实现可在调试器下触发断点；若无调试器则无可观察效果。</p>
      </emu-note>
      <emu-grammar>DebuggerStatement : `debugger` `;`</emu-grammar>
      <emu-alg>
        1. 若实现定义的调试设施可用且启用：
          1. 执行实现定义调试动作。
          1. 返回实现定义的新 Completion Record。
        1. 否则返回 ~empty~。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript 语言：函数与类 (ECMAScript Language: Functions and Classes)</h1>
  <emu-note>
    <p>多种 ECMAScript 语言元素会创建 ECMAScript 函数对象（<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>）。此类函数的求值从其 [[Call]] 内部方法的执行开始（<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>）。</p>
  </emu-note>

  <emu-clause id="sec-parameter-lists">
    <h1>参数列表 (Parameter Lists)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      UniqueFormalParameters[Yield, Await] :
        FormalParameters[?Yield, ?Await]

      FormalParameters[Yield, Await] :
        [empty]
        FunctionRestParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,`
        FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]

      FormalParameterList[Yield, Await] :
        FormalParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]

      FunctionRestParameter[Yield, Await] :
        BindingRestElement[?Yield, ?Await]

      FormalParameter[Yield, Await] :
        BindingElement[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-parameter-lists-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
      <ul>
        <li>
          如果 |FormalParameters| 的 BoundNames 包含任意重复元素，则为语法错误。
        </li>
      </ul>
      <emu-grammar>FormalParameters : FormalParameterList</emu-grammar>
      <ul>
        <li>
          如果 |FormalParameterList| 的 IsSimpleParameterList 为 *false* 且其 BoundNames 含有任意重复元素，则为语法错误。
        </li>
      </ul>
      <emu-note>
        <p>同一个 |BindingIdentifier| 在同一个 |FormalParameterList| 中出现多次只在函数具有简单参数列表并且不是在严格模式代码中定义时才被允许。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsexpression" oldids="sec-destructuring-binding-patterns-static-semantics-containsexpression,sec-function-definitions-static-semantics-containsexpression,sec-arrow-function-definitions-static-semantics-containsexpression,sec-async-arrow-function-definitions-static-semantics-ContainsExpression" type="sdo">
      <h1>静态语义：ContainsExpression ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectBindingPattern :
          `{` `}`
          `{` BindingRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 返回 ContainsExpression of |BindingPropertyList|。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 返回 ContainsExpression of |BindingRestElement|。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 返回 ContainsExpression of |BindingElementList|。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 ContainsExpression of |BindingElementList|。
        1. 如果 _has_ 为 *true*，返回 *true*。
        1. 返回 ContainsExpression of |BindingRestElement|。
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 ContainsExpression of |BindingPropertyList|。
        1. 如果 _has_ 为 *true*，返回 *true*。
        1. 返回 ContainsExpression of |BindingProperty|。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 ContainsExpression of |BindingElementList|。
        1. 如果 _has_ 为 *true*，返回 *true*。
        1. 返回 ContainsExpression of |BindingElisionElement|。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. 返回 ContainsExpression of |BindingElement|。
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 IsComputedPropertyKey of |PropertyName|。
        1. 如果 _has_ 为 *true*，返回 *true*。
        1. 返回 ContainsExpression of |BindingElement|。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. 返回 ContainsExpression of |BindingPattern|。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 如果 ContainsExpression of |FormalParameterList| 为 *true*，返回 *true*。
        1. 返回 ContainsExpression of |FunctionRestParameter|。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 如果 ContainsExpression of |FormalParameterList| 为 *true*，返回 *true*。
        1. 返回 ContainsExpression of |FormalParameter|。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为由 |CoverParenthesizedExpressionAndArrowParameterList| 覆盖的 |ArrowFormalParameters|。
        1. 返回 ContainsExpression of _formals_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-issimpleparameterlist" oldids="sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist,sec-function-definitions-static-semantics-issimpleparameterlist,sec-arrow-function-definitions-static-semantics-issimpleparameterlist,sec-async-arrow-function-definitions-static-semantics-IsSimpleParameterList" type="sdo">
      <h1>静态语义：IsSimpleParameterList ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>FormalParameters : FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 如果 IsSimpleParameterList of |FormalParameterList| 为 *false*，返回 *false*。
        1. 返回 IsSimpleParameterList of |FormalParameter|。
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. 返回 IsSimpleParameterList of |BindingElement|。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为由 |CoverParenthesizedExpressionAndArrowParameterList| 覆盖的 |ArrowFormalParameters|。
        1. 返回 IsSimpleParameterList of _formals_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. 令 _head_ 为由 |CoverCallExpressionAndAsyncArrowHead| 覆盖的 |AsyncArrowHead|。
        1. 返回 IsSimpleParameterList of _head_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasinitializer" oldids="sec-destructuring-binding-patterns-static-semantics-hasinitializer,sec-function-definitions-static-semantics-hasinitializer" type="sdo">
      <h1>静态语义：HasInitializer ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 如果 HasInitializer of |FormalParameterList| 为 *true*，返回 *true*。
        1. 返回 HasInitializer of |FormalParameter|。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-expectedargumentcount" oldids="sec-function-definitions-static-semantics-expectedargumentcount,sec-arrow-function-definitions-static-semantics-expectedargumentcount,sec-method-definitions-static-semantics-expectedargumentcount,sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount" type="sdo">
      <h1>静态语义：ExpectedArgumentCount ( ): 一个非负整数</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FormalParameters :
          [empty]
          FunctionRestParameter
      </emu-grammar>
      <emu-alg>
        1. 返回 0。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 返回 |FormalParameterList| 的 ExpectedArgumentCount。
      </emu-alg>
      <emu-note>
        <p>|FormalParameterList| 的 ExpectedArgumentCount 是位于剩余参数或第一个带 Initializer 的 |FormalParameter| 左侧的 |FormalParameters| 数目。在第一个带初始值的参数之后仍可出现不带初始值的参数，但这些参数被视为可选，其默认值为 *undefined*。</p>
      </emu-note>
      <emu-grammar>FormalParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. 如果 HasInitializer of |FormalParameter| 为 *true*，返回 0。
        1. 返回 1。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 令 _count_ 为 |FormalParameterList| 的 ExpectedArgumentCount。
        1. 如果 HasInitializer of |FormalParameterList| 为 *true* 或 HasInitializer of |FormalParameter| 为 *true*，返回 _count_。
        1. 返回 _count_ + 1。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 返回 1。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为由 |CoverParenthesizedExpressionAndArrowParameterList| 覆盖的 |ArrowFormalParameters|。
        1. 返回 _formals_ 的 ExpectedArgumentCount。
      </emu-alg>
      <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. 如果 HasInitializer of |FormalParameter| 为 *true*，返回 0。
        1. 返回 1。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 1。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-definitions">
    <h1>函数定义 (Function Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      FunctionDeclaration[Yield, Await, Default] :
        `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionExpression :
        `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionBody[Yield, Await] :
        FunctionStatementList[?Yield, ?Await]

      FunctionStatementList[Yield, Await] :
        StatementList[?Yield, ?Await, +Return]?
    </emu-grammar>

    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          若 IsStrict(|FormalParameters|) 为 *true*，则应用 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 的早期错误规则。
        </li>
        <li>
          若出现 |BindingIdentifier| 且 IsStrict(|BindingIdentifier|) 为 *true*，并且其 StringValue 为 *"eval"* 或 *"arguments"*，则为语法错误。
        </li>
        <li>
          若 FunctionBodyContainsUseStrict(|FunctionBody|) 为 *true* 且 IsSimpleParameterList(|FormalParameters|) 为 *false*，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| 的 BoundNames 中任一元素也出现在 |FunctionBody| 的 LexicallyDeclaredNames 中，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| Contains |SuperProperty| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |FunctionBody| Contains |SuperProperty| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| Contains |SuperCall| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |FunctionBody| Contains |SuperCall| 为 *true*，则为语法错误。
        </li>
      </ul>
      <emu-note>
        <p>|FunctionBody| 的 LexicallyDeclaredNames 不包含通过 var 或 function 声明绑定的标识符。</p>
      </emu-note>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <ul>
        <li>
          若 |FunctionStatementList| 的 LexicallyDeclaredNames 含有重复条目，则为语法错误。
        </li>
        <li>
          若 |FunctionStatementList| 的 LexicallyDeclaredNames 中任一元素也出现在其 VarDeclaredNames 中，则为语法错误。
        </li>
        <li>
          若 ContainsDuplicateLabels(|FunctionStatementList|, « ») 为 *true*，则为语法错误。
        </li>
        <li>
          若 ContainsUndefinedBreakTarget(|FunctionStatementList|, « ») 为 *true*，则为语法错误。
        </li>
        <li>
          若 ContainsUndefinedContinueTarget(|FunctionStatementList|, « », « ») 为 *true*，则为语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-functionbodycontainsusestrict" oldids="sec-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>静态语义：FunctionBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. 若 |FunctionBody| 的指令序言 (Directive Prologue) 含有 Use Strict 指令，返回 *true*；否则返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluatefunctionbody" oldids="sec-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        运行时语义：EvaluateFunctionBody (
          _functionObject_: 一个 ECMAScript 函数对象,
          _argumentsList_: ECMAScript 语言值的列表,
        ): 一个 return completion 或 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. 执行 ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)。
        1. 执行 ? Evaluation of |FunctionStatementList|。
        1. 注：若上一步产生正常完成，则求值已到达 |FunctionStatementList| 末尾。
        1. 返回 ReturnCompletion(*undefined*)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionobject" oldids="sec-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        运行时语义：InstantiateOrdinaryFunctionObject (
          _env_: 一个 Environment Record,
          _privateEnv_: 一个 PrivateEnvironment Record 或 *null*,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _sourceText_ 为 |FunctionDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, _name_)。
        1. 执行 MakeConstructor(_F_)。
        1. 返回 _F_。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |FunctionDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, *"default"*)。
        1. 执行 MakeConstructor(_F_)。
        1. 返回 _F_。
      </emu-alg>
      <emu-note>
        <p>匿名 |FunctionDeclaration| 只能作为 `export default` 声明的一部分，其函数代码因此总是严格模式代码。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        运行时语义：InstantiateOrdinaryFunctionExpression (
        可选 _name_: 一个属性键或 Private Name,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |FunctionExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 执行 MakeConstructor(_closure_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 断言：_name_ 不存在。
        1. 设 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _outerEnv_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _funcEnv_ 为 NewDeclarativeEnvironment(_outerEnv_)。
        1. 执行 ! _funcEnv_.CreateImmutableBinding(_name_, *false*)。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |FunctionExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 执行 MakeConstructor(_closure_)。
        1. 执行 ! _funcEnv_.InitializeBinding(_name_, _closure_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-note>
        <p>|FunctionExpression| 中的 |BindingIdentifier| 可在其 |FunctionBody| 内部引用以实现递归调用。但与 |FunctionDeclaration| 不同，该标识符不能从包围 |FunctionExpression| 的外部作用域引用，也不会影响外部作用域。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-note>
        <p>在 FunctionDeclarationInstantiation 的步骤 <emu-xref href="#step-functiondeclarationinstantiation-alt-funcdecl-eval"></emu-xref>、GlobalDeclarationInstantiation 的步骤 <emu-xref href="#step-globaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> 以及 EvalDeclarationInstantiation 的步骤 <emu-xref href="#step-evaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> 中，<emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> 提供替代语义。</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>
        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 InstantiateOrdinaryFunctionExpression of |FunctionExpression|。
      </emu-alg>
      <emu-note>
        <p>每个通过 |FunctionDeclaration| 或 |FunctionExpression| 定义的函数会自动创建一个 *"prototype"* 属性，以便该函数可作为构造函数使用。</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *undefined*。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>箭头函数定义 (Arrow Function Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ArrowFunction[In, Yield, Await] :
        ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

      ArrowParameters[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      ConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, ~Await]
        `{` FunctionBody[~Yield, ~Await] `}`

      ExpressionBody[In, Await] :
        AssignmentExpression[?In, ~Yield, ?Await]
    </emu-grammar>
    <h2>补充语法 (Supplemental Syntax)</h2>
    <p>
      当处理产生式实例：<br>
      <emu-grammar>ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      时，使用以下语法细化对 |CoverParenthesizedExpressionAndArrowParameterList| 的解释：
    </p>
    <emu-grammar type="definition">
      ArrowFormalParameters[Yield, Await] :
        `(` UniqueFormalParameters[?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <ul>
        <li>
          若 |ArrowParameters| Contains |YieldExpression| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |ArrowParameters| Contains |AwaitExpression| 为 *true*，则为语法错误。
        </li>
        <li>
          若 ConciseBodyContainsUseStrict(|ConciseBody|) 为 *true* 且 IsSimpleParameterList(|ArrowParameters|) 为 *false*，则为语法错误。
        </li>
        <li>
          若 |ArrowParameters| 的 BoundNames 中任一元素也出现在 |ConciseBody| 的 LexicallyDeclaredNames 中，则为语法错误。
        </li>
      </ul>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <ul>
        <li>
          |CoverParenthesizedExpressionAndArrowParameterList| 必须覆盖一个 |ArrowFormalParameters|。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-concisebodycontainsusestrict" oldids="sec-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>静态语义：ConciseBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ConciseBody : `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 FunctionBodyContainsUseStrict(|FunctionBody|)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateconcisebody" oldids="sec-arrow-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        运行时语义：EvaluateConciseBody (
          _functionObject_: 一个 ECMAScript 函数对象,
          _argumentsList_: ECMAScript 语言值的列表,
        ): 一个 return completion 或 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 执行 ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)。
        1. 返回 ? Evaluation of |ExpressionBody|。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiatearrowfunctionexpression" type="sdo">
      <h1>
        运行时语义：InstantiateArrowFunctionExpression (
        可选 _name_: 一个属性键或 Private Name,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |ArrowFunction| 匹配的源文本。
        1. [id="step-arrowfunction-evaluation-functioncreate"] 令 _closure_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-note>
        <p>|ArrowFunction| 不为 `arguments`、`super`、`this` 或 `new.target` 定义局部绑定；在其内部的此类引用必须解析为词法外层环境中的绑定。尽管 |ArrowFunction| 可引用 `super`，但步骤 <emu-xref href="#step-arrowfunction-evaluation-functioncreate"></emu-xref> 创建的函数对象不会通过 MakeMethod 变成方法；包含 `super` 的 |ArrowFunction| 始终位于非 |ArrowFunction| 内，其实现 `super` 所需状态通过捕获的 _env_ 可用。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 返回 InstantiateArrowFunctionExpression of |ArrowFunction|。
      </emu-alg>
      <emu-grammar>ExpressionBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |AssignmentExpression|。
        1. 令 _exprValue_ 为 ? GetValue(_exprRef_)。
        1. 返回 ReturnCompletion(_exprValue_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>方法定义 (Method Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      MethodDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        GeneratorMethod[?Yield, ?Await]
        AsyncMethod[?Yield, ?Await]
        AsyncGeneratorMethod[?Yield, ?Await]
        `get` ClassElementName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
        `set` ClassElementName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

      PropertySetParameterList :
        FormalParameter[~Yield, ~Await]
    </emu-grammar>

    <emu-clause id="sec-method-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          若 FunctionBodyContainsUseStrict(|FunctionBody|) 为 *true* 且 IsSimpleParameterList(|UniqueFormalParameters|) 为 *false*，则为语法错误。
        </li>
        <li>
          若 |UniqueFormalParameters| 的 BoundNames 中任一元素也出现在 |FunctionBody| 的 LexicallyDeclaredNames 中，则为语法错误。
        </li>
      </ul>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          若 |PropertySetParameterList| 的 BoundNames 含重复元素，则为语法错误。
        </li>
        <li>
          若 FunctionBodyContainsUseStrict(|FunctionBody|) 为 *true* 且 IsSimpleParameterList(|PropertySetParameterList|) 为 *false*，则为语法错误。
        </li>
        <li>
          若 |PropertySetParameterList| 的 BoundNames 中任一元素也出现在 |FunctionBody| 的 LexicallyDeclaredNames 中，则为语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasdirectsuper" oldids="sec-method-definitions-static-semantics-hasdirectsuper,sec-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-function-definitions-static-semantics-HasDirectSuper" type="sdo">
      <h1>静态语义：HasDirectSuper ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 若 |UniqueFormalParameters| Contains |SuperCall| 为 *true*，返回 *true*。
        1. 返回 |FunctionBody| Contains |SuperCall|。
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionBody| Contains |SuperCall|。
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 若 |PropertySetParameterList| Contains |SuperCall| 为 *true*，返回 *true*。
        1. 返回 |FunctionBody| Contains |SuperCall|。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 若 |UniqueFormalParameters| Contains |SuperCall| 为 *true*，返回 *true*。
        1. 返回 |GeneratorBody| Contains |SuperCall|。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 若 |UniqueFormalParameters| Contains |SuperCall| 为 *true*，返回 *true*。
        1. 返回 |AsyncGeneratorBody| Contains |SuperCall|。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 若 |UniqueFormalParameters| Contains |SuperCall| 为 *true*，返回 *true*。
        1. 返回 |AsyncFunctionBody| Contains |SuperCall|。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-specialmethod" type="sdo">
      <h1>静态语义：SpecialMethod ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          GeneratorMethod
          AsyncMethod
          AsyncGeneratorMethod
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-definemethod" type="sdo">
      <h1>
        运行时语义：DefineMethod (
        _object_: 一个 Object,
        可选 _functionPrototype_: 一个 Object,
        ): 正常完成（含 [[Key]] 与 [[Closure]] 字段的 Record）或突然完成
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _propKey_ 为 ? Evaluation of |ClassElementName|。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 若 _functionPrototype_ 存在，令 _prototype_ = _functionPrototype_；否则令 _prototype_ = %Function.prototype%。
        1. 令 _sourceText_ 为 |MethodDefinition| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 MakeMethod(_closure_, _object_)。
        1. 返回 Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-methoddefinitionevaluation" oldids="sec-method-definitions-runtime-semantics-propertydefinitionevaluation,sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation,sec-asyncgenerator-definitions-propertydefinitionevaluation,sec-async-function-definitions-PropertyDefinitionEvaluation" type="sdo">
      <h1>
        运行时语义：MethodDefinitionEvaluation (
          _object_: 一个 Object,
          _enumerable_: 一个 Boolean,
        ): 正常完成（含 PrivateElement 或 ~unused~）或突然完成
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _methodDef_ 为 ? DefineMethod of |MethodDefinition|，参数 _object_。
        1. 执行 SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]])。
        1. 返回 ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_)。
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _propKey_ 为 ? Evaluation of |ClassElementName|。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |MethodDefinition| 匹配的源文本。
        1. 令 _formalParameterList_ 为产生式 <emu-grammar>FormalParameters : [empty]</emu-grammar> 的一个实例。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 MakeMethod(_closure_, _object_)。
        1. 执行 SetFunctionName(_closure_, _propKey_, *"get"*)。
        1. 若 _propKey_ 是 Private Name，则
          1. 返回 PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* }。
        1. 否则，
          1. 令 _desc_ 为 PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }。
          1. 执行 ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)。
          1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _propKey_ 为 ? Evaluation of |ClassElementName|。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |MethodDefinition| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 MakeMethod(_closure_, _object_)。
        1. 执行 SetFunctionName(_closure_, _propKey_, *"set"*)。
        1. 若 _propKey_ 是 Private Name，则
          1. 返回 PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ }。
        1. 否则，
          1. 令 _desc_ 为 PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }。
          1. 执行 ? DefinePropertyOrThrow(_object_, _propKey_, _desc_)。
          1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _propKey_ 为 ? Evaluation of |ClassElementName|。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |GeneratorMethod| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 MakeMethod(_closure_, _object_)。
        1. 执行 SetFunctionName(_closure_, _propKey_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%GeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_)。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 令 _propKey_ 为 ? Evaluation of |ClassElementName|。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncGeneratorMethod| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 MakeMethod(_closure_, _object_)。
        1. 执行 SetFunctionName(_closure_, _propKey_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_)。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 令 _propKey_ 为 ? Evaluation of |ClassElementName|。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncMethod| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 MakeMethod(_closure_, _object_)。
        1. 执行 SetFunctionName(_closure_, _propKey_)。
        1. 返回 ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>生成器函数定义 (Generator Function Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      GeneratorDeclaration[Yield, Await, Default] :
        `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
        [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorExpression :
        `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorMethod[Yield, Await] :
        `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorBody :
        FunctionBody[+Yield, ~Await]

      YieldExpression[In, Await] :
        `yield`
        `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>`yield` 后紧随的语法上下文需要使用 |InputElementRegExpOrTemplateTail| 词法目标。</p>
    </emu-note>
    <emu-note>
      <p>|YieldExpression| 不能用于生成器函数的 |FormalParameters| 内，因为 |FormalParameters| 中的表达式会在生成的 Generator 进入可恢复状态之前被求值。</p>
    </emu-note>
    <emu-note>
      <p>与生成器相关的抽象操作定义见 <emu-xref href="#sec-generator-abstract-operations"></emu-xref>。</p>
    </emu-note>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <ul>
        <li>
          若 HasDirectSuper(|GeneratorMethod|) 为 *true*，则为语法错误。
        </li>
        <li>
          若 |UniqueFormalParameters| Contains |YieldExpression| 为 *true*，则为语法错误。
        </li>
        <li>
          若 FunctionBodyContainsUseStrict(|GeneratorBody|) 为 *true* 且 IsSimpleParameterList(|UniqueFormalParameters|) 为 *false*，则为语法错误。
        </li>
        <li>
          若 |UniqueFormalParameters| 的 BoundNames 任一元素也出现在 |GeneratorBody| 的 LexicallyDeclaredNames 中，则为语法错误。
        </li>
      </ul>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>
          若 IsStrict(|FormalParameters|) 为 *true*，则应用 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 的早期错误规则。
        </li>
        <li>
          若出现 |BindingIdentifier| 且 IsStrict(|BindingIdentifier|) 为 *true*，其 StringValue 为 *"eval"* 或 *"arguments"* 则语法错误。
        </li>
        <li>
          若 FunctionBodyContainsUseStrict(|GeneratorBody|) 为 *true* 且 IsSimpleParameterList(|FormalParameters|) 为 *false*，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| 的 BoundNames 任一元素也出现在 |GeneratorBody| 的 LexicallyDeclaredNames 中，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| Contains |YieldExpression| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| Contains |SuperProperty| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |GeneratorBody| Contains |SuperProperty| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |FormalParameters| Contains |SuperCall| 为 *true*，则为语法错误。
        </li>
        <li>
          若 |GeneratorBody| Contains |SuperCall| 为 *true*，则为语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        运行时语义：EvaluateGeneratorBody (
          _functionObject_: 一个 ECMAScript 函数对象,
          _argumentsList_: ECMAScript 语言值的列表,
        ): 一个 throw completion 或 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. 执行 ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)。
        1. 令 _G_ 为 ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorPrototype%"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »)。
        1. 设 _G_.[[GeneratorBrand]] 为 ~empty~。
        1. 设 _G_.[[GeneratorState]] 为 ~suspended-start~。
        1. 执行 GeneratorStart(_G_, |FunctionBody|)。
        1. 返回 ReturnCompletion(_G_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionobject" oldids="sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        运行时语义：InstantiateGeneratorFunctionObject (
          _env_: 一个 Environment Record,
          _privateEnv_: 一个 PrivateEnvironment Record 或 *null*,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _sourceText_ 为 |GeneratorDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, _name_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%GeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 _F_。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |GeneratorDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, *"default"*)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%GeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 _F_。
      </emu-alg>
      <emu-note>
        <p>匿名 |GeneratorDeclaration| 只能作为 `export default` 声明的一部分，因此其函数代码总是严格模式代码。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        运行时语义：InstantiateGeneratorFunctionExpression (
        可选 _name_: 一个属性键或 Private Name,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |GeneratorExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%GeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 _closure_。
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 断言：_name_ 不存在。
        1. 设 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _outerEnv_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _funcEnv_ 为 NewDeclarativeEnvironment(_outerEnv_)。
        1. 执行 ! _funcEnv_.CreateImmutableBinding(_name_, *false*)。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |GeneratorExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%GeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 执行 ! _funcEnv_.InitializeBinding(_name_, _closure_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-note>
        <p>|GeneratorExpression| 中的 |BindingIdentifier| 可在其 |FunctionBody| 内被引用以实现生成器代码自递归。但与 |GeneratorDeclaration| 不同，该 |BindingIdentifier| 不可从包围 |GeneratorExpression| 的作用域引用，也不影响该外层作用域。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 InstantiateGeneratorFunctionExpression of |GeneratorExpression|。
      </emu-alg>
      <emu-grammar>YieldExpression : `yield`</emu-grammar>
      <emu-alg>
        1. 返回 ? Yield(*undefined*)。
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |AssignmentExpression|。
        1. 令 _value_ 为 ? GetValue(_exprRef_)。
        1. 返回 ? Yield(_value_)。
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` `*` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _generatorKind_ 为 GetGeneratorKind()。
        1. 断言：_generatorKind_ 为 ~sync~ 或 ~async~。
        1. 令 _exprRef_ 为 ? Evaluation of |AssignmentExpression|。
        1. 令 _value_ 为 ? GetValue(_exprRef_)。
        1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, _generatorKind_)。
        1. 令 _iterator_ 为 _iteratorRecord_.[[Iterator]]。
        1. 令 _received_ 为 NormalCompletion(*undefined*)。
        1. 重复，
          1. 若 _received_ 为 normal completion，则
            1. 令 _innerResult_ 为 ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »)。
            1. 若 _generatorKind_ 为 ~async~，设 _innerResult_ 为 ? Await(_innerResult_)。
            1. 若 _innerResult_ 不是 Object，抛出 *TypeError* 异常。
            1. 令 _done_ 为 ? IteratorComplete(_innerResult_)。
            1. 若 _done_ 为 *true*，则
              1. 返回 ? IteratorValue(_innerResult_)。
            1. 若 _generatorKind_ 为 ~async~，设 _received_ 为 Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_)))。
            1. 否则，设 _received_ 为 Completion(GeneratorYield(_innerResult_))。
          1. 否则若 _received_ 为 throw completion，则
            1. 令 _throw_ 为 ? GetMethod(_iterator_, *"throw"*)。
            1. 若 _throw_ 非 *undefined*，则
              1. 令 _innerResult_ 为 ? Call(_throw_, _iterator_, « _received_.[[Value]] »)。
              1. 若 _generatorKind_ 为 ~async~，设 _innerResult_ 为 ? Await(_innerResult_)。
              1. 注：内部迭代器 `throw` 方法抛出的异常会被传播。其正常完成与内部 `next` 类似处理。
              1. 若 _innerResult_ 不是 Object，抛出 *TypeError* 异常。
              1. 令 _done_ 为 ? IteratorComplete(_innerResult_)。
              1. 若 _done_ 为 *true*，则
                1. 返回 ? IteratorValue(_innerResult_)。
              1. 若 _generatorKind_ 为 ~async~，设 _received_ 为 Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_)))。
              1. 否则设 _received_ 为 Completion(GeneratorYield(_innerResult_))。
            1. 否则，
              1. 注：若 _iterator_ 不具有 `throw` 方法，则该抛出将终止 `yield*` 循环。但需先给予 _iterator_ 清理机会。
              1. 令 _closeCompletion_ 为 NormalCompletion(~empty~)。
              1. 若 _generatorKind_ 为 ~async~，执行 ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_)。
              1. 否则，执行 ? IteratorClose(_iteratorRecord_, _closeCompletion_)。
              1. 注：下一步抛出 *TypeError* 以指示 `yield*` 协议违规：_iterator_ 无 `throw` 方法。
              1. 抛出 *TypeError* 异常。
          1. 否则，
            1. 断言：_received_ 是 return completion。
            1. 令 _return_ 为 ? GetMethod(_iterator_, *"return"*)。
            1. 若 _return_ 为 *undefined*，则
              1. 设 _value_ 为 _received_.[[Value]]。
              1. 若 _generatorKind_ 为 ~async~，则
                1. 设 _value_ 为 ? Await(_value_)。
              1. 返回 ReturnCompletion(_value_)。
            1. 令 _innerReturnResult_ 为 ? Call(_return_, _iterator_, « _received_.[[Value]] »)。
            1. 若 _generatorKind_ 为 ~async~，设 _innerReturnResult_ 为 ? Await(_innerReturnResult_)。
            1. 若 _innerReturnResult_ 不是 Object，抛出 *TypeError* 异常。
            1. 令 _done_ 为 ? IteratorComplete(_innerReturnResult_)。
            1. 若 _done_ 为 *true*，则
              1. 设 _value_ 为 ? IteratorValue(_innerReturnResult_)。
              1. 返回 ReturnCompletion(_value_)。
            1. 若 _generatorKind_ 为 ~async~，设 _received_ 为 Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_)))。
            1. 否则设 _received_ 为 Completion(GeneratorYield(_innerReturnResult_))。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>异步生成器函数定义 (Async Generator Function Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncGeneratorDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
        [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorExpression :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorMethod[Yield, Await] :
        `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorBody :
        FunctionBody[+Yield, +Await]
    </emu-grammar>
    <emu-note>
      <p>|YieldExpression| 与 |AwaitExpression| 不能用于异步生成器函数的 |FormalParameters| 内，因为它们会在 AsyncGenerator 进入可恢复状态前被求值。</p>
    </emu-note>
    <emu-note>
      <p>与 AsyncGenerators 有关的抽象操作见 <emu-xref href="#sec-asyncgenerator-abstract-operations"></emu-xref>。</p>
    </emu-note>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <ul>
        <li>若 HasDirectSuper(|AsyncGeneratorMethod|) 为 *true*，语法错误。</li>
        <li>若 |UniqueFormalParameters| Contains |YieldExpression| 为 *true*，语法错误。</li>
        <li>若 |UniqueFormalParameters| Contains |AwaitExpression| 为 *true*，语法错误。</li>
        <li>若 FunctionBodyContainsUseStrict(|AsyncGeneratorBody|) 为 *true* 且 IsSimpleParameterList(|UniqueFormalParameters|) 为 *false*，语法错误。</li>
        <li>若 |UniqueFormalParameters| 的 BoundNames 任一元素也出现在 |AsyncGeneratorBody| 的 LexicallyDeclaredNames 中，语法错误。</li>
      </ul>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>若 IsStrict(|FormalParameters|) 为 *true*，应用 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 的早期错误规则。</li>
        <li>若出现 |BindingIdentifier| 且 IsStrict(|BindingIdentifier|) 为 *true* 且其 StringValue 为 *"eval"* 或 *"arguments"*，语法错误。</li>
        <li>若 FunctionBodyContainsUseStrict(|AsyncGeneratorBody|) 为 *true* 且 IsSimpleParameterList(|FormalParameters|) 为 *false*，语法错误。</li>
        <li>若 |FormalParameters| 的 BoundNames 任一元素也出现在 |AsyncGeneratorBody| 的 LexicallyDeclaredNames 中，语法错误。</li>
        <li>若 |FormalParameters| Contains |YieldExpression| 为 *true*，语法错误。</li>
        <li>若 |FormalParameters| Contains |AwaitExpression| 为 *true*，语法错误。</li>
        <li>若 |FormalParameters| Contains |SuperProperty| 为 *true*，语法错误。</li>
        <li>若 |AsyncGeneratorBody| Contains |SuperProperty| 为 *true*，语法错误。</li>
        <li>若 |FormalParameters| Contains |SuperCall| 为 *true*，语法错误。</li>
        <li>若 |AsyncGeneratorBody| Contains |SuperCall| 为 *true*，语法错误。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        运行时语义：EvaluateAsyncGeneratorBody (
          _functionObject_: 一个 ECMAScript 函数对象,
          _argumentsList_: ECMAScript 语言值的列表,
        ): 一个 throw completion 或 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. 执行 ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)。
        1. 令 _generator_ 为 ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorPrototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »)。
        1. 设 _generator_.[[GeneratorBrand]] 为 ~empty~。
        1. 设 _generator_.[[AsyncGeneratorState]] 为 ~suspended-start~。
        1. 执行 AsyncGeneratorStart(_generator_, |FunctionBody|)。
        1. 返回 ReturnCompletion(_generator_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionobject" oldids="sec-asyncgenerator-definitions-instantiatefunctionobject" type="sdo">
      <h1>
        运行时语义：InstantiateAsyncGeneratorFunctionObject (
          _env_: 一个 Environment Record,
          _privateEnv_: 一个 PrivateEnvironment Record 或 *null*,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _sourceText_ 为 |AsyncGeneratorDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, _name_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 _F_。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |AsyncGeneratorDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, *"default"*)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 _F_。
      </emu-alg>
      <emu-note>
        <p>匿名 |AsyncGeneratorDeclaration| 只能出现在 `export default` 声明中。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        运行时语义：InstantiateAsyncGeneratorFunctionExpression (
        可选 _name_: 一个属性键或 Private Name,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncGeneratorExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 _closure_。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 断言：_name_ 不存在。
        1. 设 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _outerEnv_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _funcEnv_ 为 NewDeclarativeEnvironment(_outerEnv_)。
        1. 执行 ! _funcEnv_.CreateImmutableBinding(_name_, *false*)。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncGeneratorExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 令 _prototype_ 为 OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
        1. 执行 ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 执行 ! _funcEnv_.InitializeBinding(_name_, _closure_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-note>
        <p>|AsyncGeneratorExpression| 中的 |BindingIdentifier| 可在其 |AsyncGeneratorBody| 内被引用以实现自递归。但与 |AsyncGeneratorDeclaration| 不同，该标识符不可从包围表达式的作用域引用，也不影响外层作用域。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>类定义 (Class Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      ClassDeclaration[Yield, Await, Default] :
        `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ClassTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

      ClassHeritage[Yield, Await] :
        `extends` LeftHandSideExpression[?Yield, ?Await]

      ClassBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]

      ClassElementList[Yield, Await] :
        ClassElement[?Yield, ?Await]
        ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        FieldDefinition[?Yield, ?Await] `;`
        `static` FieldDefinition[?Yield, ?Await] `;`
        ClassStaticBlock
        `;`

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateIdentifier

      ClassStaticBlock :
        `static` `{` ClassStaticBlockBody `}`

      ClassStaticBlockBody :
        ClassStaticBlockStatementList

      ClassStaticBlockStatementList :
        StatementList[~Yield, +Await, ~Return]?
    </emu-grammar>
    <emu-note>
      <p>类定义始终是严格模式代码。</p>
    </emu-note>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>若未出现 |ClassHeritage| 且下述算法返回 *true*，则为语法错误：</p>
          <emu-alg>
            1. 令 _constructor_ 为 |ClassBody| 的 ConstructorMethod。
            1. 若 _constructor_ 为 ~empty~，返回 *false*。
            1. 返回 HasDirectSuper(_constructor_)。
          </emu-alg>
        </li>
      </ul>
      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <ul>
        <li>
          若 |ClassElementList| 的 PrototypePropertyNameList 中出现多于一次 *"constructor"*，则语法错误。
        </li>
        <li>
          若 |ClassElementList| 的 PrivateBoundIdentifiers 含有重复条目（除非该名称仅用作一次 getter 与一次 setter 且不出现其他条目，且二者同为 static 或同为非 static），则语法错误。
        </li>
      </ul>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <ul>
        <li>
          若 |MethodDefinition| 的 PropName 不是 *"constructor"* 且 HasDirectSuper(|MethodDefinition|) 为 *true*，则语法错误。
        </li>
        <li>
          若 |MethodDefinition| 的 PropName 为 *"constructor"* 且 SpecialMethod(|MethodDefinition|) 为 *true*，则语法错误。
        </li>
      </ul>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <ul>
        <li>
          若 HasDirectSuper(|MethodDefinition|) 为 *true*，则语法错误。
        </li>
        <li>
          若 |MethodDefinition| 的 PropName 为 *"prototype"*，则语法错误。
        </li>
      </ul>

      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <ul>
        <li>|FieldDefinition| 的 PropName 若为 *"constructor"* 则语法错误。</li>
      </ul>

      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <ul>
        <li>
          |FieldDefinition| 的 PropName 若为 *"prototype"* 或 *"constructor"* 则语法错误。
        </li>
      </ul>

      <emu-grammar>
        FieldDefinition :
          ClassElementName Initializer?
      </emu-grammar>
      <ul>
        <li>若存在 |Initializer| 且 ContainsArguments(|Initializer|) 为 *true*，语法错误。</li>
        <li>若存在 |Initializer| 且 |Initializer| Contains |SuperCall| 为 *true*，语法错误。</li>
      </ul>

      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <ul>
        <li>若 |PrivateIdentifier| 的 StringValue 为 *"#constructor"*，则语法错误。</li>
      </ul>

      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <ul>
        <li>
          若 |ClassStaticBlockStatementList| 的 LexicallyDeclaredNames 含有重复条目，语法错误。
        </li>
        <li>
          若其 LexicallyDeclaredNames 任一元素也出现在 VarDeclaredNames 中，语法错误。
        </li>
        <li>
          若 ContainsDuplicateLabels(|ClassStaticBlockStatementList|, « ») 为 *true*，语法错误。
        </li>
        <li>
          若 ContainsUndefinedBreakTarget(|ClassStaticBlockStatementList|, « ») 为 *true*，语法错误。
        </li>
        <li>
          若 ContainsUndefinedContinueTarget(|ClassStaticBlockStatementList|, « », « ») 为 *true*，语法错误。
        </li>
        <li>
          若 ContainsArguments(|ClassStaticBlockStatementList|) 为 *true*，语法错误。
        </li>
        <li>
          若 |ClassStaticBlockStatementList| Contains |SuperCall| 为 *true*，语法错误。
        </li>
        <li>
          若 |ClassStaticBlockStatementList| Contains `await` 为 *true*，语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementkind" type="sdo">
      <h1>静态语义：ClassElementKind ( ): ~constructor-method~、~non-constructor-method~ 或 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. 若 |MethodDefinition| 的 PropName 为 *"constructor"*，返回 ~constructor-method~。
        1. 返回 ~non-constructor-method~。
      </emu-alg>
      <emu-grammar>
        ClassElement :
          `static` MethodDefinition
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. 返回 ~non-constructor-method~。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 ~non-constructor-method~。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-constructormethod" type="sdo">
      <h1>静态语义：ConstructorMethod ( ): 一个 |ClassElement| 解析节点或 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. 若 |ClassElement| 的 ClassElementKind 为 ~constructor-method~，返回 |ClassElement|。
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. 令 _head_ 为 |ClassElementList| 的 ConstructorMethod。
        1. 若 _head_ 非 ~empty~，返回 _head_。
        1. 若 |ClassElement| 的 ClassElementKind 为 ~constructor-method~，返回 |ClassElement|。
        1. 返回 ~empty~。
      </emu-alg>
      <emu-note>
        <p>早期错误规则确保仅存在一个名为 *"constructor"* 的方法定义，且它不是访问器属性或生成器定义。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstatic" type="sdo">
      <h1>静态语义：IsStatic ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructorelements" oldids="sec-static-semantics-nonconstructormethoddefinitions" type="sdo">
      <h1>静态语义：NonConstructorElements ( ): |ClassElement| 解析节点的列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. 若 |ClassElement| 的 ClassElementKind 为 ~non-constructor-method~，则
          1. 返回 « |ClassElement| »。
        1. 返回新空列表。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. 令 _list_ 为 |ClassElementList| 的 NonConstructorElements。
        1. 若 |ClassElement| 的 ClassElementKind 为 ~non-constructor-method~，则
          1. 将 |ClassElement| 追加至 _list_ 末尾。
        1. 返回 _list_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-prototypepropertynamelist" type="sdo">
      <h1>静态语义：PrototypePropertyNameList ( ): 属性键列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. 令 _propName_ 为 |ClassElement| 的 PropName。
        1. 若 _propName_ 为 ~empty~，返回新空列表。
        1. 若 IsStatic(|ClassElement|) 为 *true*，返回新空列表。
        1. 返回 « _propName_ »。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. 令 _list_ 为 |ClassElementList| 的 PrototypePropertyNameList。
        1. 令 _propName_ 为 |ClassElement| 的 PropName。
        1. 若 _propName_ 为 ~empty~，返回 _list_。
        1. 若 IsStatic(|ClassElement|) 为 *true*，返回 _list_。
        1. 返回 列表连接(_list_, « _propName_ »)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-allprivateidentifiersvalid" type="sdo">
      <h1>
        静态语义：AllPrivateIdentifiersValid (
          _names_: 字符串列表,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>本规范中未列出的所有产生式替代都隐式具有如下默认定义：</p>
      <emu-alg>
        1. 对该解析节点的每个子节点 _child_：
          1. 若 _child_ 是非终结符实例，则
            1. 若 AllPrivateIdentifiersValid(_child_, _names_) 为 *false*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>

      <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. 若 _names_ 包含 |PrivateIdentifier| 的 StringValue，则
          1. 返回 AllPrivateIdentifiersValid(|MemberExpression|, _names_)。
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. 若 _names_ 包含 |PrivateIdentifier| 的 StringValue，则
          1. 返回 AllPrivateIdentifiersValid(|CallExpression|, _names_)。
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. 若 _names_ 包含 |PrivateIdentifier| 的 StringValue，返回 *true*。
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. 若 _names_ 包含 |PrivateIdentifier| 的 StringValue，则
          1. 返回 AllPrivateIdentifiersValid(|OptionalChain|, _names_)。
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <emu-alg>
        1. 令 _newNames_ 为 _names_ 与 |ClassBody| 的 PrivateBoundIdentifiers 的列表连接。
        1. 返回 AllPrivateIdentifiersValid(|ClassElementList|, _newNames_)。
      </emu-alg>

      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. 若 _names_ 包含 |PrivateIdentifier| 的 StringValue，则
          1. 返回 AllPrivateIdentifiersValid(|ShiftExpression|, _names_)。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-privateboundidentifiers" type="sdo">
      <h1>静态语义：PrivateBoundIdentifiers ( ): 字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PrivateBoundIdentifiers。
      </emu-alg>

      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回仅包含 |PrivateIdentifier| 的 StringValue 的列表。
      </emu-alg>

      <emu-grammar>
        ClassElementName :
          PropertyName

        ClassElement :
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. 返回新空列表。
      </emu-alg>

      <emu-grammar>
        ClassElementList : ClassElementList ClassElement
      </emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ClassElementList| 的 PrivateBoundIdentifiers。
        1. 令 _names2_ 为 |ClassElement| 的 PrivateBoundIdentifiers。
        1. 返回 列表连接(_names1_, _names2_)。
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PrivateBoundIdentifiers。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsarguments" type="sdo">
      <h1>静态语义：ContainsArguments ( ): Boolean</h1>
      <dl class="header">
      </dl>

      <p>本规范中未列出的产生式替代默认使用以下定义：</p>
      <emu-alg>
        1. 对该节点的每个子节点 _child_：
          1. 若 _child_ 是非终结符实例：
            1. 若 ContainsArguments(_child_) 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>
        IdentifierReference : Identifier
      </emu-grammar>
      <emu-alg>
        1. 若 |Identifier| 的 StringValue 为 *"arguments"*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 ContainsArguments(|ClassElementName|)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classfielddefinitionevaluation" type="sdo">
      <h1>
        运行时语义：ClassFieldDefinitionEvaluation (
          _homeObject_: 一个对象,
        ): 正常完成（包含一个 ClassFieldDefinition Record）或突然完成
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 ? Evaluation of |ClassElementName|。
        1. 若存在 |Initializer|，则
          1. 令 _formalParameterList_ 为产生式 <emu-grammar>FormalParameters : [empty]</emu-grammar> 的一个实例。
          1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
          1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
          1. 令 _sourceText_ 为空的 Unicode 码点序列。
          1. 令 _initializer_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_)。
          1. 执行 MakeMethod(_initializer_, _homeObject_)。
          1. 设 _initializer_.[[ClassFieldInitializerName]] 为 _name_。
        1. 否则，
          1. 令 _initializer_ 为 ~empty~。
        1. 返回 ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }。
      </emu-alg>
      <emu-note>
        为 _initializer_ 创建的函数不会被 ECMAScript 代码直接访问。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classstaticblockdefinitionevaluation" type="sdo">
      <h1>
        运行时语义：ClassStaticBlockDefinitionEvaluation (
          _homeObject_: 一个对象,
        ): 一个 ClassStaticBlockDefinition Record
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. 令 _lex_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为空的 Unicode 码点序列。
        1. 令 _formalParameters_ 为产生式 <emu-grammar>FormalParameters : [empty]</emu-grammar> 的实例。
        1. [id="step-synthetic-class-static-block-fn"] 令 _bodyFunction_ 为 OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_)。
        1. 执行 MakeMethod(_bodyFunction_, _homeObject_)。
        1. 返回 ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ }。
      </emu-alg>
      <emu-note>函数 _bodyFunction_ 不会被 ECMAScript 代码直接访问。</emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        运行时语义：EvaluateClassStaticBlockBody (
          _functionObject_: 一个 ECMAScript 函数对象,
        ): 一个 return completion 或 throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. 断言：_functionObject_ 是由 ClassStaticBlockDefinitionEvaluation 步骤 <emu-xref href="#step-synthetic-class-static-block-fn"></emu-xref> 创建的合成函数。
        1. 执行 ! FunctionDeclarationInstantiation(_functionObject_, « »)。
        1. 执行 ? Evaluation of |ClassStaticBlockStatementList|。
        1. 返回 ReturnCompletion(*undefined*)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementevaluation" type="sdo">
      <h1>
        运行时语义：ClassElementEvaluation (
          _object_: 一个对象,
        ): 正常完成（包含 ClassFieldDefinition Record、ClassStaticBlockDefinition Record、PrivateElement 或 ~unused~ 之一）或突然完成
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ClassElement :
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. 返回 ? ClassFieldDefinitionEvaluation(|FieldDefinition|, _object_)。
      </emu-alg>

      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. 返回 ? MethodDefinitionEvaluation(|MethodDefinition|, _object_, *false*)。
      </emu-alg>

      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 ClassStaticBlockDefinitionEvaluation(|ClassStaticBlock|, _object_)。
      </emu-alg>

      <emu-grammar>
        ClassElement : `;`
      </emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        运行时语义：ClassDefinitionEvaluation (
          _classBinding_: 一个 String 或 *undefined*,
          _className_: 一个属性键或 Private Name,
          _sourceText_: ECMAScript 源文本,
        ): 正常完成（包含一个函数对象）或突然完成
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>为便于规范说明，私有方法与访问器与私有字段一起被包含在类实例的 [[PrivateElements]] 槽中。然而，任意给定对象要么拥有该类定义的全部私有方法与访问器，要么一个也没有。该特性被设计为允许实现选择不对每个方法或访问器单独跟踪的策略来实现私有方法与访问器。</p>
        <p>例如，实现可以将实例私有方法直接与其对应的 Private Name 关联，并为每个对象跟踪哪些类构造函数以该对象作为 `this` 值运行。随后在对象上查找一个实例私有方法的过程即是检查定义该方法的类构造函数是否已用于初始化该对象，然后返回与该 Private Name 关联的方法。</p>
        <p>这不同于私有字段：由于字段初始化器在类实例化期间可能抛出，单个对象可能只拥有某个类私有字段的真子集，因此一般必须单独跟踪私有字段。</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. 令 _env_ 为正在运行的执行上下文的 LexicalEnvironment。
        1. 令 _classEnv_ 为 NewDeclarativeEnvironment(_env_)。
        1. 若 _classBinding_ 不为 *undefined*，则
          1. 执行 ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*)。
        1. 令 _outerPrivateEnvironment_ 为正在运行的执行上下文的 PrivateEnvironment。
        1. 令 _classPrivateEnvironment_ 为 NewPrivateEnvironment(_outerPrivateEnvironment_)。
        1. 若存在 |ClassBody|，则
          1. 对 |ClassBody| 的 PrivateBoundIdentifiers 中每个字符串 _dn_：
            1. 若 _classPrivateEnvironment_.[[Names]] 包含 Private Name _pn_ 且 _pn_.[[Description]] 为 _dn_，则
              1. 断言：仅 getter/setter 成对时可能。
            1. 否则，
              1. 令 _name_ 为新的 Private Name，[[Description]] 为 _dn_。
              1. 将 _name_ 追加至 _classPrivateEnvironment_.[[Names]]。
        1. 若不存在 |ClassHeritage|，则
          1. 令 _protoParent_ 为 %Object.prototype%。
          1. 令 _constructorParent_ 为 %Function.prototype%。
        1. 否则，
          1. 将正在运行执行上下文的 LexicalEnvironment 设为 _classEnv_。
          1. 注：计算 |ClassHeritage| 时运行执行上下文的 PrivateEnvironment 为 _outerPrivateEnvironment_。
          1. 令 _superclassRef_ 为 Completion(Evaluation of |ClassHeritage|)。
          1. 将运行执行上下文的 LexicalEnvironment 设回 _env_。
          1. 令 _superclass_ 为 ? GetValue(? _superclassRef_)。
          1. 若 _superclass_ 为 *null*，则
            1. 令 _protoParent_ 为 *null*。
            1. 令 _constructorParent_ 为 %Function.prototype%。
          1. 否则若 IsConstructor(_superclass_) 为 *false*，则
            1. 抛出 *TypeError* 异常。
          1. 否则，
            1. 令 _protoParent_ 为 ? Get(_superclass_, *"prototype"*)。
            1. 若 _protoParent_ 既不是 Object 且不是 *null*，抛出 *TypeError* 异常。
            1. 令 _constructorParent_ 为 _superclass_。
        1. 令 _proto_ 为 OrdinaryObjectCreate(_protoParent_)。
        1. 若不存在 |ClassBody|，令 _constructor_ 为 ~empty~。
        1. 否则，令 _constructor_ 为 |ClassBody| 的 ConstructorMethod。
        1. 将运行执行上下文的 LexicalEnvironment 设为 _classEnv_。
        1. 将运行执行上下文的 PrivateEnvironment 设为 _classPrivateEnvironment_。
        1. 若 _constructor_ 为 ~empty~，则
          1. 令 _defaultConstructor_ 为一个不带参数且不捕获任何内容的新抽象闭包，被调用时执行：
            1. 令 _args_ 为通过 [[Call]] 或 [[Construct]] 传给此函数的参数列表。
            1. 若 NewTarget 为 *undefined*，抛出 *TypeError* 异常。
            1. 令 _F_ 为活动函数对象。
            1. 若 _F_.[[ConstructorKind]] 为 ~derived~，则
              1. 注：此分支行为类似 `constructor(...args) { super(...args); }`。最显著区别是上述 ECMAScript 源码会可观察地调用 `%Array.prototype%` 上的 %Symbol.iterator% 方法，而此函数不会。
              1. 令 _func_ 为 ! _F_.[[GetPrototypeOf]]()。
              1. 若 IsConstructor(_func_) 为 *false*，抛出 *TypeError* 异常。
              1. 令 _result_ 为 ? Construct(_func_, _args_, NewTarget)。
            1. 否则，
              1. 注：此分支类似 `constructor() {}`。
              1. 令 _result_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*)。
            1. 执行 ? InitializeInstanceElements(_result_, _F_)。
            1. 返回 NormalCompletion(_result_)。
          1. 令 _F_ 为 CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », 当前 Realm Record, _constructorParent_)。
        1. 否则，
          1. 令 _constructorInfo_ 为 ! DefineMethod of _constructor_，参数 _proto_ 与 _constructorParent_。
          1. 令 _F_ 为 _constructorInfo_.[[Closure]]。
          1. 执行 MakeClassConstructor(_F_)。
          1. 执行 SetFunctionName(_F_, _className_)。
        1. 设 _F_.[[SourceText]] 为 _sourceText_。
        1. 执行 MakeConstructor(_F_, *false*, _proto_)。
        1. 若存在 |ClassHeritage|，设 _F_.[[ConstructorKind]] 为 ~derived~。
        1. 执行 ! DefineMethodProperty(_proto_, *"constructor"*, _F_, *false*)。
        1. 若不存在 |ClassBody|，令 _elements_ 为新空 List。
        1. 否则，令 _elements_ 为 |ClassBody| 的 NonConstructorElements。
        1. 令 _instancePrivateMethods_、_staticPrivateMethods_、_instanceFields_、_staticElements_ 各为新空 List。
        1. 对 _elements_ 中每个 |ClassElement| _e_：
          1. 若 IsStatic of _e_ 为 *false*，则
            1. 令 _element_ 为 Completion(ClassElementEvaluation of _e_，参数 _proto_)。
          1. 否则，
            1. 令 _element_ 为 Completion(ClassElementEvaluation of _e_，参数 _F_)。
          1. 若 _element_ 是突然完成，
            1. 将运行执行上下文的 LexicalEnvironment 设为 _env_。
            1. 将运行执行上下文的 PrivateEnvironment 设为 _outerPrivateEnvironment_。
            1. 返回 ? _element_。
          1. 设 _element_ 为 ! _element_。
          1. 若 _element_ 是 PrivateElement，则
            1. 断言：_element_.[[Kind]] 为 ~method~ 或 ~accessor~。
            1. 若 IsStatic of _e_ 为 *false*，令 _container_ 为 _instancePrivateMethods_；否则令其为 _staticPrivateMethods_。
            1. 若 _container_ 中存在 PrivateElement _pe_ 且 _pe_.[[Key]] 为 _element_.[[Key]]，则
              1. 断言：_element_.[[Kind]] 与 _pe_.[[Kind]] 均为 ~accessor~。
              1. 若 _element_.[[Get]] 为 *undefined*，则
                1. 令 _combined_ 为 PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }。
              1. 否则，
                1. 令 _combined_ 为 PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }。
              1. 用 _combined_ 替换 _container_ 中的 _pe_。
            1. 否则，
              1. 追加 _element_ 至 _container_。
          1. 否则若 _element_ 是 ClassFieldDefinition Record，则
            1. 若 IsStatic of _e_ 为 *false*，将 _element_ 追加至 _instanceFields_；否则追加至 _staticElements_。
          1. 否则若 _element_ 是 ClassStaticBlockDefinition Record，则
            1. 追加 _element_ 至 _staticElements_。
        1. 将运行执行上下文的 LexicalEnvironment 设回 _env_。
        1. 若 _classBinding_ 不为 *undefined*，则
          1. 执行 ! _classEnv_.InitializeBinding(_classBinding_, _F_)。
        1. 设 _F_.[[PrivateMethods]] 为 _instancePrivateMethods_。
        1. 设 _F_.[[Fields]] 为 _instanceFields_。
        1. 对 _staticPrivateMethods_ 中每个 PrivateElement _method_：
          1. 执行 ! PrivateMethodOrAccessorAdd(_F_, _method_)。
        1. 对 _staticElements_ 中每个元素 _elementRecord_：
          1. 若 _elementRecord_ 是 ClassFieldDefinition Record，则
            1. 令 _result_ 为 Completion(DefineField(_F_, _elementRecord_))。
          1. 否则，
            1. 断言：_elementRecord_ 是 ClassStaticBlockDefinition Record。
            1. 令 _result_ 为 Completion(Call(_elementRecord_.[[BodyFunction]], _F_))。
          1. 若 _result_ 为突然完成，
            1. 将运行执行上下文的 PrivateEnvironment 设为 _outerPrivateEnvironment_。
            1. 返回 ? _result_。
        1. 将运行执行上下文的 PrivateEnvironment 设为 _outerPrivateEnvironment_。
        1. 返回 _F_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation" type="sdo">
      <h1>运行时语义：BindingClassDeclarationEvaluation ( ): 正常完成（包含一个函数对象）或突然完成</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 令 _className_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _sourceText_ 为 |ClassDeclaration| 匹配的源文本。
        1. 令 _value_ 为 ? ClassDefinitionEvaluation of |ClassTail|，参数 _className_、_className_ 与 _sourceText_。
        1. 令 _env_ 为正在运行的执行上下文的 LexicalEnvironment。
        1. 执行 ? InitializeBoundName(_className_, _value_, _env_)。
        1. 返回 _value_。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |ClassDeclaration| 匹配的源文本。
        1. 返回 ? ClassDefinitionEvaluation of |ClassTail|，参数 *undefined*、*"default"* 与 _sourceText_。
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> 只会作为 |ExportDeclaration| 的一部分出现，其绑定的建立由该产生式的求值动作处理。参见 <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 执行 ? BindingClassDeclarationEvaluation of 此 |ClassDeclaration|。
        1. 返回 ~empty~。
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> 仅作为 |ExportDeclaration| 的一部分出现，且不会被直接求值。</p>
      </emu-note>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |ClassExpression| 匹配的源文本。
        1. 返回 ? ClassDefinitionEvaluation of |ClassTail|，参数 *undefined*、*""* 与 _sourceText_。
      </emu-alg>
      <emu-grammar>ClassExpression : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 令 _className_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _sourceText_ 为 |ClassExpression| 匹配的源文本。
        1. 返回 ? ClassDefinitionEvaluation of |ClassTail|，参数 _className_、_className_ 与 _sourceText_。
      </emu-alg>
      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. 令 _privateIdentifier_ 为 |PrivateIdentifier| 的 StringValue。
        1. 令 _privateEnvRec_ 为运行执行上下文的 PrivateEnvironment。
        1. 令 _names_ 为 _privateEnvRec_.[[Names]]。
        1. 断言：_names_ 中恰有一个 Private Name 的 [[Description]] 为 _privateIdentifier_。
        1. 令 _privateName_ 为 _names_ 中 [[Description]] 为 _privateIdentifier_ 的 Private Name。
        1. 返回 _privateName_。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *undefined*。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>异步函数定义 (Async Function Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncFunctionDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionExpression :
        `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncMethod[Yield, Await] :
        `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionBody :
        FunctionBody[~Yield, +Await]

      AwaitExpression[Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>

    <emu-note>
      <p>当 <sub>[Await]</sub> 参数存在时，`await` 被解析为 |AwaitExpression| 的关键字。<sub>[Await]</sub> 参数在以下上下文的顶层存在，尽管在某些上下文中（例如 |FunctionBody|）该参数可能缺失：</p>
      <ul>
        <li>在 |AsyncFunctionBody| 中。</li>
        <li>在 |AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration| 或 |AsyncGeneratorExpression| 的 |FormalParameters| 中。该位置的 |AwaitExpression| 通过静态语义为语法错误。</li>
        <li>在一个 |Module| 中。</li>
      </ul>
      <p>当 |Script| 是语法目标符号时，如果 <sub>[Await]</sub> 参数缺失，`await` 可以被解析为标识符。包括以下情形：</p>
      <ul>
        <li>在 |AsyncFunctionBody| 或上述各类 |FormalParameters| 之外的任意位置。</li>
        <li>在 |FunctionExpression|、|GeneratorExpression| 或 |AsyncGeneratorExpression| 的 |BindingIdentifier| 中。</li>
      </ul>
    </emu-note>

    <emu-note>
      <p>不同于 |YieldExpression|，省略 |AwaitExpression| 的操作数是语法错误。必须等待某个值。</p>
    </emu-note>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>若 FunctionBodyContainsUseStrict(|AsyncFunctionBody|) 为 *true* 且 IsSimpleParameterList(|UniqueFormalParameters|) 为 *false*，语法错误。</li>
        <li>若 HasDirectSuper(|AsyncMethod|) 为 *true*，语法错误。</li>
        <li>若 |UniqueFormalParameters| Contains |AwaitExpression| 为 *true*，语法错误。</li>
        <li>若 |UniqueFormalParameters| 的 BoundNames 任一元素也出现在 |AsyncFunctionBody| 的 LexicallyDeclaredNames 中，语法错误。</li>
      </ul>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>若 FunctionBodyContainsUseStrict(|AsyncFunctionBody|) 为 *true* 且 IsSimpleParameterList(|FormalParameters|) 为 *false*，语法错误。</li>
        <li>若 |FormalParameters| Contains |AwaitExpression| 为 *true*，语法错误。</li>
        <li>若 IsStrict(|FormalParameters|) 为 *true*，应用 <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> 的早期错误规则。</li>
        <li>若存在 |BindingIdentifier| 且 IsStrict(|BindingIdentifier|) 为 *true* 且其 StringValue 为 *"eval"* 或 *"arguments"*，语法错误。</li>
        <li>若 |FormalParameters| 的 BoundNames 任一元素也出现在 |AsyncFunctionBody| 的 LexicallyDeclaredNames 中，语法错误。</li>
        <li>若 |FormalParameters| Contains |SuperProperty| 为 *true*，语法错误。</li>
        <li>若 |AsyncFunctionBody| Contains |SuperProperty| 为 *true*，语法错误。</li>
        <li>若 |FormalParameters| Contains |SuperCall| 为 *true*，语法错误。</li>
        <li>若 |AsyncFunctionBody| Contains |SuperCall| 为 *true*，语法错误。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionobject" oldids="sec-async-function-definitions-InstantiateFunctionObject" type="sdo">
      <h1>
        运行时语义：InstantiateAsyncFunctionObject (
          _env_: 一个 Environment Record,
          _privateEnv_: 一个 PrivateEnvironment Record 或 *null*,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _sourceText_ 为 |AsyncFunctionDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, _name_)。
        1. 返回 _F_。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |AsyncFunctionDeclaration| 匹配的源文本。
        1. 令 _F_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_F_, *"default"*)。
        1. 返回 _F_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        运行时语义：InstantiateAsyncFunctionExpression (
        可选 _name_: 一个属性键或 Private Name,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为运行执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为运行执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncFunctionExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 断言：_name_ 不存在。
        1. 设 _name_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _outerEnv_ 为运行执行上下文的 LexicalEnvironment。
        1. 令 _funcEnv_ 为 NewDeclarativeEnvironment(_outerEnv_)。
        1. 执行 ! _funcEnv_.CreateImmutableBinding(_name_, *false*)。
        1. 令 _privateEnv_ 为运行执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncFunctionExpression| 匹配的源文本。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 执行 ! _funcEnv_.InitializeBinding(_name_, _closure_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-note>
        <p>|AsyncFunctionExpression| 中的 |BindingIdentifier| 可在其 |AsyncFunctionBody| 内引用以允许函数自递归。然而，与 |FunctionDeclaration| 不同，|AsyncFunctionExpression| 中的 |BindingIdentifier| 不能被其外层作用域引用，也不影响外层作用域。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncfunctionbody" oldids="sec-async-function-definitions-EvaluateBody" type="sdo">
      <h1>
        运行时语义：EvaluateAsyncFunctionBody (
          _functionObject_: 一个 ECMAScript 函数对象,
          _argumentsList_: ECMAScript 语言值列表,
        ): 一个 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
        1. 令 _completion_ 为 Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_))。
        1. 若 _completion_ 是突然完成，则
          1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »)。
        1. 否则，
          1. 执行 AsyncFunctionStart(_promiseCapability_, |FunctionBody|)。
        1. 返回 ReturnCompletion(_promiseCapability_.[[Promise]])。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|。
      </emu-alg>
      <emu-grammar>
        AwaitExpression : `await` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. 令 _exprRef_ 为 ? Evaluation of |UnaryExpression|。
        1. 令 _value_ 为 ? GetValue(_exprRef_)。
        1. 返回 ? Await(_value_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-arrow-function-definitions">
    <h1>异步箭头函数定义 (Async Arrow Function Definitions)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      AsyncArrowFunction[In, Yield, Await] :
        `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

      AsyncConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, +Await]
        `{` AsyncFunctionBody `}`

      AsyncArrowBindingIdentifier[Yield] :
        BindingIdentifier[?Yield, +Await]

      CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>
    <h2>补充语法 (Supplemental Syntax)</h2>
    <p>
      处理产生式实例：<br>
      <emu-grammar>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody</emu-grammar><br>
      时，对 |CoverCallExpressionAndAsyncArrowHead| 的解释使用下列语法细化：
    </p>

    <emu-grammar type="definition">
      AsyncArrowHead :
        `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>若 |AsyncArrowBindingIdentifier| 的 BoundNames 任一元素也出现在 |AsyncConciseBody| 的 LexicallyDeclaredNames 中，则为语法错误。</li>
      </ul>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|CoverCallExpressionAndAsyncArrowHead| 必须覆盖一个 |AsyncArrowHead|。</li>
        <li>若 |CoverCallExpressionAndAsyncArrowHead| Contains |YieldExpression| 为 *true*，则为语法错误。</li>
        <li>若 |CoverCallExpressionAndAsyncArrowHead| Contains |AwaitExpression| 为 *true*，则为语法错误。</li>
        <li>若 |CoverCallExpressionAndAsyncArrowHead| 的 BoundNames 任一元素也出现在 |AsyncConciseBody| 的 LexicallyDeclaredNames 中，则为语法错误。</li>
        <li>若 AsyncConciseBodyContainsUseStrict(|AsyncConciseBody|) 为 *true* 且 IsSimpleParameterList(|CoverCallExpressionAndAsyncArrowHead|) 为 *false*，则为语法错误。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-asyncconcisebodycontainsusestrict" oldids="sec-async-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>静态语义：AsyncConciseBodyContainsUseStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>AsyncConciseBody : `{` AsyncFunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 FunctionBodyContainsUseStrict(|AsyncFunctionBody|)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncconcisebody" oldids="sec-async-arrow-function-definitions-EvaluateBody" type="sdo">
      <h1>
        运行时语义：EvaluateAsyncConciseBody (
          _functionObject_: 一个 ECMAScript 函数对象,
          _argumentsList_: ECMAScript 语言值列表,
        ): 一个 return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
        1. 令 _completion_ 为 Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_))。
        1. 若 _completion_ 为突然完成，则
          1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »)。
        1. 否则，
          1. 执行 AsyncFunctionStart(_promiseCapability_, |ExpressionBody|)。
        1. 返回 ReturnCompletion(_promiseCapability_.[[Promise]])。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncarrowfunctionexpression" type="sdo">
      <h1>
        运行时语义：InstantiateAsyncArrowFunctionExpression (
        可选 _name_: 一个属性键或 Private Name,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncArrowFunction| 匹配的源文本。
        1. 令 _parameters_ 为 |AsyncArrowBindingIdentifier|。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 返回 _closure_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 若 _name_ 不存在，设 _name_ 为 *""*。
        1. 令 _env_ 为当前执行上下文的 LexicalEnvironment。
        1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
        1. 令 _sourceText_ 为 |AsyncArrowFunction| 匹配的源文本。
        1. 令 _head_ 为 |CoverCallExpressionAndAsyncArrowHead| 覆盖的 |AsyncArrowHead|。
        1. 令 _parameters_ 为 _head_ 的 |ArrowFormalParameters|。
        1. 令 _closure_ 为 OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_)。
        1. 执行 SetFunctionName(_closure_, _name_)。
        1. 返回 _closure_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 返回 InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>尾位置调用 (Tail Position Calls)</h1>

    <emu-clause id="sec-isintailposition" type="abstract operation">
      <h1>
        静态语义：IsInTailPosition (
          _call_: 一个 |CallExpression| 解析节点、|MemberExpression| 解析节点或 |OptionalChain| 解析节点,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 IsStrict(_call_) 为 *false*，返回 *false*。
        1. 若 _call_ 不被包含在 |FunctionBody|、|ConciseBody| 或 |AsyncConciseBody| 内，返回 *false*。
        1. 令 _body_ 为最贴近包含 _call_ 的 |FunctionBody|、|ConciseBody| 或 |AsyncConciseBody|。
        1. 若 _body_ 是 |GeneratorBody| 的 |FunctionBody|，返回 *false*。
        1. 若 _body_ 是 |AsyncFunctionBody| 的 |FunctionBody|，返回 *false*。
        1. 若 _body_ 是 |AsyncGeneratorBody| 的 |FunctionBody|，返回 *false*。
        1. 若 _body_ 是 |AsyncConciseBody|，返回 *false*。
        1. 返回 HasCallInTailPosition(_body_, _call_) 的结果。
      </emu-alg>
      <emu-note>
        <p>尾位置调用仅在严格模式代码中定义，这是因为存在常见的非标准语言扩展（参见 <emu-xref href="#sec-addrestrictedfunctionproperties"></emu-xref>）允许观察调用者上下文链。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo" oldids="sec-statement-rules,sec-expression-rules">
      <h1>
        静态语义：HasCallInTailPosition (
          _call_: 一个 |CallExpression| 解析节点、|MemberExpression| 解析节点或 |OptionalChain| 解析节点,
        ): Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_ 是表示特定源文本范围的解析节点。以下算法比较 _call_ 与另一解析节点时，测试的是它们是否表示同一段源文本。</p>
      </emu-note>
      <emu-note>
        <p>紧随其后的 return GetValue(调用结果) 的潜在尾位置调用同样视为可能的尾位置调用。函数调用不会返回 Reference Record，因此该 GetValue 操作总会返回与函数调用结果相同的值。</p>
      </emu-note>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 HasCallInTailPosition(|StatementList|, _call_)。
        1. 若 _has_ 为 *true*，返回 *true*。
        1. 返回 HasCallInTailPosition(|StatementListItem|, _call_)。
      </emu-alg>
      <emu-grammar>
        FunctionStatementList :
          [empty]

        StatementListItem :
          Declaration

        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        ReturnStatement :
          `return` `;`

        LabelledItem :
          FunctionDeclaration

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        CaseBlock :
          `{` `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为第一个 |Statement| 的 HasCallInTailPosition(_call_)。
        1. 若 _has_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 HasCallInTailPosition(_call_)。
      </emu-alg>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement

        DoWhileStatement :
          `do` Statement `while` `(` Expression `)` `;`

        WhileStatement :
          `while` `(` Expression `)` Statement

        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement

        WithStatement :
          `with` `(` Expression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|Statement|, _call_)。
      </emu-alg>
      <emu-grammar>
        LabelledStatement :
          LabelIdentifier `:` LabelledItem
      </emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|LabelledItem|, _call_)。
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|Expression|, _call_)。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|CaseBlock|, _call_)。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 *false*。
        1. 若首个 |CaseClauses| 存在，设 _has_ 为 HasCallInTailPosition(首个 |CaseClauses|, _call_)。
        1. 若 _has_ 为 *true*，返回 *true*。
        1. 设 _has_ 为 HasCallInTailPosition(|DefaultClause|, _call_)。
        1. 若 _has_ 为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 存在，设 _has_ 为 HasCallInTailPosition(第二个 |CaseClauses|, _call_)。
        1. 返回 _has_。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为 HasCallInTailPosition(|CaseClauses|, _call_)。
        1. 若 _has_ 为 *true*，返回 *true*。
        1. 返回 HasCallInTailPosition(|CaseClause|, _call_)。
      </emu-alg>
      <emu-grammar>
        CaseClause : `case` Expression `:` StatementList?

        DefaultClause : `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回 HasCallInTailPosition(|StatementList|, _call_)。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|Catch|, _call_)。
      </emu-alg>
      <emu-grammar>
        TryStatement :
          `try` Block Finally
          `try` Block Catch Finally
      </emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|Finally|, _call_)。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|Block|, _call_)。
      </emu-alg>

      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        CallExpression :
          SuperCall
          ImportCall
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        Expression :
          AssignmentExpression
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|AssignmentExpression|, _call_)。
      </emu-alg>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 令 _has_ 为第一个 |AssignmentExpression| 的 HasCallInTailPosition(_call_)。
        1. 若 _has_ 为 *true*，返回 *true*。
        1. 返回第二个 |AssignmentExpression| 的 HasCallInTailPosition(_call_)。
      </emu-alg>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|BitwiseORExpression|, _call_)。
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|LogicalANDExpression|, _call_)。
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|BitwiseORExpression|, _call_)。
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 若此 |CallExpression| 即 _call_，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        OptionalExpression :
          MemberExpression OptionalChain
          CallExpression OptionalChain
          OptionalExpression OptionalChain
      </emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|OptionalChain|, _call_)。
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` `[` Expression `]`
          `?.` IdentifierName
          `?.` PrivateIdentifier
          OptionalChain `[` Expression `]`
          OptionalChain `.` IdentifierName
          OptionalChain `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` Arguments
          OptionalChain Arguments
      </emu-grammar>
      <emu-alg>
        1. 若此 |OptionalChain| 即 _call_，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        MemberExpression :
          MemberExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. 若此 |MemberExpression| 即 _call_，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 覆盖的 |ParenthesizedExpression|。
        1. 返回 HasCallInTailPosition(_expr_, _call_)。
      </emu-alg>
      <emu-grammar>
        ParenthesizedExpression :
          `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. 返回 HasCallInTailPosition(|Expression|, _call_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-preparefortailcall" type="abstract operation">
      <h1>PrepareForTailCall ( ): ~unused~</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：当前执行上下文在后续不会再用于求值任意 ECMAScript 代码或内建函数。调用本抽象操作之后的 Call 调用将在进行任何此类求值前创建并压入一个新的执行上下文。
        1. 丢弃与当前执行上下文关联的所有资源。
        1. 返回 ~unused~。
      </emu-alg>
      <p>尾位置调用必须在调用目标函数前释放与当前正在执行的函数执行上下文关联的任何瞬态内部资源，或复用这些资源以支持目标函数。</p>
      <emu-note>
        <p>例如，尾位置调用应当只按“目标函数激活记录大小减去调用方激活记录大小”的差额增长实现的激活记录栈；若目标函数的激活记录更小，则栈总大小应减小。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript 语言：脚本与模块</h1>

  <emu-clause id="sec-scripts">
    <h1>脚本 (Scripts)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        StatementList[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          若 |ScriptBody| 的 LexicallyDeclaredNames 含有任意重复条目，则为语法错误。
        </li>
        <li>
          若 |ScriptBody| 的 LexicallyDeclaredNames 中任一元素也出现在 |ScriptBody| 的 VarDeclaredNames 中，则为语法错误。
        </li>
      </ul>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <ul>
        <li>
          若 |StatementList| Contains `super` 为 *true*（除非包含 `super` 的源文本为正通过直接 eval 处理的 eval 代码），则为语法错误。直接 eval 中 `super` 的额外早期错误规则定义在 <emu-xref href="#sec-performeval"></emu-xref>。
        </li>
        <li>
          若 |StatementList| Contains |NewTarget| 为 *true*（除非包含 |NewTarget| 的源文本为正通过直接 eval 处理的 eval 代码），则为语法错误。直接 eval 中 |NewTarget| 的额外早期错误规则定义在 <emu-xref href="#sec-performeval"></emu-xref>。
        </li>
        <li>
          若 ContainsDuplicateLabels(|StatementList|, « ») 为 *true*，则为语法错误。
        </li>
        <li>
          若 ContainsUndefinedBreakTarget(|StatementList|, « ») 为 *true*，则为语法错误。
        </li>
        <li>
          若 ContainsUndefinedContinueTarget(|StatementList|, « », « ») 为 *true*，则为语法错误。
        </li>
        <li>
          若 AllPrivateIdentifiersValid(|StatementList|, « ») 为 *false*（除非包含 |ScriptBody| 的源文本为正通过直接 eval 处理的 eval 代码），则为语法错误。
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-scriptisstrict" oldids="sec-static-semantics-isstrict" type="sdo">
      <h1>静态语义：ScriptIsStrict ( ): Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Script : ScriptBody?</emu-grammar>
      <emu-alg>
        1. 若 |ScriptBody| 存在且 |ScriptBody| 的指令序言包含 Use Strict 指令，返回 *true*；否则返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *undefined*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-records">
      <h1>脚本记录 (Script Records)</h1>

      <p><dfn id="script-record" variants="Script Records">脚本记录</dfn>封装了正被求值的脚本的信息。每个脚本记录包含 <emu-xref href="#table-script-records"></emu-xref> 中列出的字段。</p>

      <emu-table id="table-script-records" caption="脚本记录字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值类型
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              一个 Realm Record
            </td>
            <td>
              此脚本被创建时所在的领域。
            </td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              一个 |Script| 解析节点
            </td>
            <td>
              解析此脚本源文本的结果。
            </td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              LoadedModuleRequest Record 的列表
            </td>
            <td>
              从此脚本导入的说明符字符串到已解析的 Module Record 的映射。列表不包含两个不同的记录 _r1_ 和 _r2_ 使得 ModuleRequestsEqual(_r1_, _r2_) 为 *true*。
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              任意类型（默认值为 ~empty~）
            </td>
            <td>
              为需要将额外信息与脚本关联的宿主环境保留的字段。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript 源文本,
          _realm_: 一个 Realm Record,
          _hostDefined_: 任意类型,
        ): 一个 Script Record 或非空的 *SyntaxError* 对象列表
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>基于将 _sourceText_ 解析为 |Script| 的结果创建一个 Script Record。</dd>
      </dl>

      <emu-alg>
        1. 令 _script_ 为 ParseText(_sourceText_, |Script|)。
        1. 若 _script_ 为错误列表，返回 _script_。
        1. 返回 Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }。
      </emu-alg>
      <emu-note>
        <p>实现可以在对该脚本源文本求值 ParseScript 之前解析脚本源文本并分析早期错误条件。然而，任何错误的报告必须推迟到本规范实际对该源文本执行 ParseScript 的时候。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-scriptevaluation" type="abstract operation">
      <h1>
        ScriptEvaluation (
          _scriptRecord_: 一个 Script Record,
        ): 正常完成（包含一个 ECMAScript 语言值）或突然完成
      </h1>
      <dl class="header">
      </dl>

      <emu-alg>
        1. 令 _globalEnv_ 为 _scriptRecord_.[[Realm]].[[GlobalEnv]]。
        1. 令 _scriptContext_ 为一个新的 ECMAScript 代码执行上下文。
        1. 设 _scriptContext_ 的 Function 为 *null*。
        1. 设 _scriptContext_ 的 Realm 为 _scriptRecord_.[[Realm]]。
        1. 设 _scriptContext_ 的 ScriptOrModule 为 _scriptRecord_。
        1. 设 _scriptContext_ 的 VariableEnvironment 为 _globalEnv_。
        1. 设 _scriptContext_ 的 LexicalEnvironment 为 _globalEnv_。
        1. 设 _scriptContext_ 的 PrivateEnvironment 为 *null*。
        1. 暂停正在运行的执行上下文。
        1. 将 _scriptContext_ 压入执行上下文栈；_scriptContext_ 现在成为正在运行的执行上下文。
        1. 令 _script_ 为 _scriptRecord_.[[ECMAScriptCode]]。
        1. 令 _result_ 为 Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_))。
        1. 若 _result_ 为正常完成，则
          1. 设 _result_ 为 Completion(Evaluation of _script_)。
          1. 若 _result_ 为正常完成且 _result_.[[Value]] 为 ~empty~，则
            1. 设 _result_ 为 NormalCompletion(*undefined*)。
        1. 暂停 _scriptContext_ 并从执行上下文栈中移除它。
        1. 断言：执行上下文栈非空。
        1. 恢复现在位于执行上下文栈顶的上下文作为正在运行的执行上下文。
        1. 返回 ? _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-globaldeclarationinstantiation">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: 一个 |Script| 解析节点,
          _env_: 一个 Global Environment Record,
        ): 正常完成（包含 ~unused~）或 throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_script_ 是正为其建立执行上下文的 |Script|。_env_ 是要在其中创建绑定的全局环境。</dd>
      </dl>
      <emu-note>
        <p>当为求值脚本建立执行上下文时，声明在当前全局环境中实例化。代码中声明的每个全局绑定都被实例化。</p>
      </emu-note>
      <p>被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _lexNames_ 为 _script_ 的 LexicallyDeclaredNames。
        1. 令 _varNames_ 为 _script_ 的 VarDeclaredNames。
        1. 对 _lexNames_ 的每个元素 _name_：
          1. 若 HasLexicalDeclaration(_env_, _name_) 为 *true*，抛出 *SyntaxError* 异常。
          1. 令 _hasRestrictedGlobal_ 为 ? HasRestrictedGlobalProperty(_env_, _name_)。
          1. 注：全局 `var` 和 `function` 绑定（除了由非严格直接 eval 引入的那些）是不可配置的，因此是受限的全局属性。
          1. 若 _hasRestrictedGlobal_ 为 *true*，抛出 *SyntaxError* 异常。
        1. 对 _varNames_ 的每个元素 _name_：
          1. 若 HasLexicalDeclaration(_env_, _name_) 为 *true*，抛出 *SyntaxError* 异常。
        1. 令 _varDeclarations_ 为 _script_ 的 VarScopedDeclarations。
        1. 令 _functionsToInitialize_ 为新的空列表。
        1. 令 _declaredFunctionNames_ 为新的空列表。
        1. 对 _varDeclarations_ 的每个元素 _d_，以反向列表顺序：
          1. 若 _d_ 既不是 |VariableDeclaration|、|ForBinding| 也不是 |BindingIdentifier|，则
            1. 断言：_d_ 是 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration| 或 |AsyncGeneratorDeclaration|。
            1. 注：若同一名称有多个函数声明，使用最后的声明。
            1. 令 _fn_ 为 _d_ 的 BoundNames 的唯一元素。
            1. 若 _declaredFunctionNames_ 不包含 _fn_，则
              1. 令 _fnDefinable_ 为 ? CanDeclareGlobalFunction(_env_, _fn_)。
              1. 若 _fnDefinable_ 为 *false*，抛出 *TypeError* 异常。
              1. 将 _fn_ 追加到 _declaredFunctionNames_。
              1. 将 _d_ 插入为 _functionsToInitialize_ 的第一个元素。
        1. 令 _declaredVarNames_ 为新的空列表。
        1. 对 _varDeclarations_ 的每个元素 _d_：
          1. 若 _d_ 是 |VariableDeclaration|、|ForBinding| 或 |BindingIdentifier|，则
            1. 对 _d_ 的 BoundNames 中每个字符串 _vn_：
              1. 若 _declaredFunctionNames_ 不包含 _vn_，则
                1. 令 _vnDefinable_ 为 ? CanDeclareGlobalVar(_env_, _vn_)。
                1. 若 _vnDefinable_ 为 *false*，抛出 *TypeError* 异常。
                1. 若 _declaredVarNames_ 不包含 _vn_，则
                  1. 将 _vn_ 追加到 _declaredVarNames_。
        1. 注：若全局对象是普通对象，此算法步骤之后不会发生异常终止。然而，若全局对象是 Proxy 异域对象，它可能表现出在某些后续步骤中导致异常终止的行为。
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point", normative-optional] 若宿主是 Web 浏览器或以其他方式支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>，则
          1. 令 _strict_ 为 ScriptIsStrict(_script_)。
          1. 若 _strict_ 为 *false*，则
            1. 令 _declaredFunctionOrVarNames_ 为 _declaredFunctionNames_ 和 _declaredVarNames_ 的列表连接。
            1. 对直接包含在任意 |Block|、|CaseClause| 或 |DefaultClause| _x_ 的 |StatementList| 中的每个 |FunctionDeclaration| _f_（使得 _script_ Contains _x_ 为 *true*）：
              1. 令 _F_ 为 _f_ 的 |BindingIdentifier| 的 StringValue。
              1. 若将 |FunctionDeclaration| _f_ 替换为以 _F_ 作为 |BindingIdentifier| 的 |VariableStatement| 不会为 _script_ 产生任何早期错误，则
                1. 若 HasLexicalDeclaration(_env_, _F_) 为 *false*，则
                  1. 令 _fnDefinable_ 为 ? CanDeclareGlobalVar(_env_, _F_)。
                  1. 若 _fnDefinable_ 为 *true*，则
                    1. 注：_F_ 的 var 绑定仅在它既不是 VarDeclaredName 也不是另一个 |FunctionDeclaration| 的名称时才在此实例化。
                    1. 若 _declaredFunctionOrVarNames_ 不包含 _F_，则
                      1. 执行 ? CreateGlobalVarBinding(_env_, _F_, *false*)。
                      1. 将 _F_ 追加到 _declaredFunctionOrVarNames_。
                    1. [id="step-globaldeclarationinstantiation-alt-funcdecl-eval"] 当 |FunctionDeclaration| _f_ 被求值时，执行以下步骤而不是 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 中提供的 |FunctionDeclaration| 求值算法：
                      1. 令 _gEnv_ 为正在运行的执行上下文的 VariableEnvironment。
                      1. 令 _bEnv_ 为正在运行的执行上下文的 LexicalEnvironment。
                      1. 令 _fObj_ 为 ! _bEnv_.GetBindingValue(_F_, *false*)。
                      1. 执行 ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*)。
                      1. 返回 ~unused~。
        1. 令 _lexDeclarations_ 为 _script_ 的 LexicallyScopedDeclarations。
        1. 令 _privateEnv_ 为 *null*。
        1. 对 _lexDeclarations_ 的每个元素 _d_：
          1. 注：词法声明的名称仅在此实例化但不初始化。
          1. 对 _d_ 的 BoundNames 的每个元素 _dn_：
            1. 若 IsConstantDeclaration(_d_) 为 *true*，则
              1. 执行 ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*)。
            1. 否则，
              1. 执行 ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*)。
        1. 对 _functionsToInitialize_ 的每个解析节点 _f_：
          1. 令 _fn_ 为 _f_ 的 BoundNames 的唯一元素。
          1. 令 _fo_ 为 InstantiateFunctionObject(_f_, _env_, _privateEnv_)。
          1. 执行 ? <emu-meta effects="user-code">CreateGlobalFunctionBinding</emu-meta>(_env_, _fn_, _fo_, *false*)。
        1. 对 _declaredVarNames_ 的每个字符串 _vn_：
          1. 执行 ? <emu-meta effects="user-code">CreateGlobalVarBinding</emu-meta>(_env_, _vn_, *false*)。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p><emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref> 中指定的早期错误防止了 function/var 声明与 let/const/class 声明之间的名称冲突，以及单个 |Script| 内声明的 let/const/class 绑定的重复声明。然而，跨越多个 |Script| 的此类冲突和重复声明在 GlobalDeclarationInstantiation 期间被检测为运行时错误。若检测到任何此类错误，不会为脚本实例化绑定。然而，若全局对象使用 Proxy 异域对象定义，则冲突声明的运行时测试可能不可靠，导致突然完成且某些全局声明未被实例化。若发生这种情况，|Script| 的代码不会被求值。</p>
        <p>与显式的 var 或 function 声明不同，直接在全局对象上创建的属性会产生可能被 let/const/class 声明遮蔽的全局绑定。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>模块 (Modules)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>模块语义 (Module Semantics)</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            若 |ModuleItemList| 的 LexicallyDeclaredNames 包含任何重复条目，则为语法错误。
          </li>
          <li>
            若 |ModuleItemList| 的 LexicallyDeclaredNames 中的任何元素也出现在 |ModuleItemList| 的 VarDeclaredNames 中，则为语法错误。
          </li>
          <li>
            若 |ModuleItemList| 的 ExportedNames 包含任何重复条目，则为语法错误。
          </li>
          <li>
            若 |ModuleItemList| 的 ExportedBindings 中的任何元素也不出现在 |ModuleItemList| 的 VarDeclaredNames 或 LexicallyDeclaredNames 中，则为语法错误。
          </li>
          <li>
            若 |ModuleItemList| Contains `super`，则为语法错误。
          </li>
          <li>
            若 |ModuleItemList| Contains |NewTarget|，则为语法错误。
          </li>
          <li>
            若 ContainsDuplicateLabels(|ModuleItemList|, « ») 为 *true*，则为语法错误。
          </li>
          <li>
            若 ContainsUndefinedBreakTarget(|ModuleItemList|, « ») 为 *true*，则为语法错误。
          </li>
          <li>
            若 ContainsUndefinedContinueTarget(|ModuleItemList|, « », « ») 为 *true*，则为语法错误。
          </li>
          <li>
            若 AllPrivateIdentifiersValid(|ModuleItemList|, « ») 为 *false*，则为语法错误。
          </li>
        </ul>
        <emu-note>
          <p>重复 ExportedNames 规则意味着在 |ModuleBody| 中有多个 `export default` |ExportDeclaration| 项是语法错误。与冲突或重复声明相关的额外错误条件在模块链接期间、|Module| 求值之前检查。如果检测到任何此类错误，|Module| 不会被求值。</p>
        </emu-note>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <ul>
          <li>若 IsStringWellFormedUnicode(SV of |StringLiteral|) 为 *false*，则为语法错误。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-importedlocalnames" type="abstract operation">
        <h1>
          静态语义：ImportedLocalNames (
            _importEntries_: ImportEntry Record 列表,
          ): 字符串列表
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>创建由 _importEntries_ 定义的所有本地名称绑定的列表。</dd>
        </dl>
        <emu-alg>
          1. 令 _localNames_ 为新的空列表。
          1. 对于 _importEntries_ 的每个 ImportEntry Record _i_：
            1. 将 _i_.[[LocalName]] 追加到 _localNames_。
          1. 返回 _localNames_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulerequest-record">
        <h1>ModuleRequest 记录 (ModuleRequest Records)</h1>

        <p><dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> 表示使用给定导入属性导入模块的请求。它由以下字段组成：</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest Record 字段">
          <table>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值类型
              </th>
              <th>
                含义
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                字符串
              </td>
              <td>
                模块说明符
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Record 列表
              </td>
              <td>
                导入属性
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="loadedmodulerequest-record" variants="LoadedModuleRequest Records">LoadedModuleRequest Record</dfn> 表示导入模块的请求以及生成的 Module Record。它由表 <emu-xref href="#table-modulerequest-fields"></emu-xref> 中定义的相同字段组成，另外添加了 [[Module]]：</p>
        <emu-table id="table-loadedmodulerequest-fields" caption="LoadedModuleRequest Record 字段">
          <table>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值类型
              </th>
              <th>
                含义
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                字符串
              </td>
              <td>
                模块说明符
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                ImportAttribute Record 列表
              </td>
              <td>
                导入属性
              </td>
            </tr>
            <tr>
              <td>
                [[Module]]
              </td>
              <td>
                Module Record
              </td>
              <td>
                对应此模块请求的已加载模块
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="importattribute-record" variants="ImportAttribute Records">ImportAttribute Record</dfn> 由以下字段组成：</p>
        <emu-table id="table-importattribute-fields" caption="ImportAttribute Record 字段">
          <table>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值类型
              </th>
              <th>
                含义
              </th>
            </tr>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                字符串
              </td>
              <td>
                属性键
              </td>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                字符串
              </td>
              <td>
                属性值
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ModuleRequestsEqual" type="abstract operation">
          <h1>
            ModuleRequestsEqual (
              _left_: ModuleRequest Record 或 LoadedModuleRequest Record,
              _right_: ModuleRequest Record 或 LoadedModuleRequest Record,
            ): Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. 若 _left_.[[Specifier]] 不是 _right_.[[Specifier]]，返回 *false*。
            1. 令 _leftAttrs_ 为 _left_.[[Attributes]]。
            1. 令 _rightAttrs_ 为 _right_.[[Attributes]]。
            1. 令 _leftAttrsCount_ 为 _leftAttrs_ 中元素的数量。
            1. 令 _rightAttrsCount_ 为 _rightAttrs_ 中元素的数量。
            1. 若 _leftAttrsCount_ ≠ _rightAttrsCount_，返回 *false*。
            1. 对于 _leftAttrs_ 的每个 ImportAttribute Record _l_：
              1. 若 _rightAttrs_ 不包含满足 _l_.[[Key]] 是 _r_.[[Key]] 且 _l_.[[Value]] 是 _r_.[[Value]] 的 ImportAttribute Record _r_，返回 *false*。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo">
        <h1>静态语义：ModuleRequests ( ): ModuleRequest Record 列表</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. 返回 |ModuleItem| 的 ModuleRequests。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. 令 _requests_ 为 |ModuleItemList| 的 ModuleRequests。
          1. 令 _additionalRequests_ 为 |ModuleItem| 的 ModuleRequests。
          1. 对于 _additionalRequests_ 的每个 ModuleRequest Record _mr_：
            1. 若 _requests_ 不包含满足 ModuleRequestsEqual(_mr_, _mr2_) 为 *true* 的 ModuleRequest Record _mr2_，则
              1. 将 _mr_ 追加到 _requests_。
          1. 返回 _requests_。
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. 令 _specifier_ 为 |FromClause| 的 SV。
          1. 返回唯一元素为 ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » } 的列表。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause `;`</emu-grammar>
        <emu-alg>
          1. 令 _specifier_ 为 |FromClause| 的 SV。
          1. 令 _attributes_ 为 WithClauseToAttributes of |WithClause|。
          1. 返回唯一元素为 ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ } 的列表。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. 令 _specifier_ 为 |ModuleSpecifier| 的 SV。
          1. 返回唯一元素为 ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » } 的列表。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause `;`</emu-grammar>
        <emu-alg>
          1. 令 _specifier_ 为 |ModuleSpecifier| 的 SV。
          1. 令 _attributes_ 为 WithClauseToAttributes of |WithClause|。
          1. 返回唯一元素为 ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ } 的列表。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. 令 _specifier_ 为 |FromClause| 的 SV。
          1. 返回唯一元素为 ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » } 的列表。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause WithClause `;`
        </emu-grammar>
        <emu-alg>
          1. 令 _specifier_ 为 |FromClause| 的 SV。
          1. 令 _attributes_ 为 WithClauseToAttributes of |WithClause|。
          1. 返回唯一元素为 ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ } 的列表。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>抽象模块记录 (Abstract Module Records)</h1>
        <p><dfn variants="Module Records">Module Record</dfn> 封装了关于单个模块导入和导出的结构信息。这些信息用于链接连接模块集合的导入和导出。Module Record 包含四个仅在求值模块时使用的字段。</p>
        <p>出于规范目的，Module Record 值是 Record 规范类型的值，可以看作存在于简单的面向对象层次结构中，其中 Module Record 是具有抽象和具体子类的抽象类。本规范定义了名为 Cyclic Module Record 的抽象子类及其名为 Source Text Module Record 的具体子类。其他规范和实现可以定义对应于它们所定义的替代模块定义工具的其他 Module Record 子类。</p>
        <p>Module Record 定义了 <emu-xref href="#table-module-record-fields"></emu-xref> 中列出的字段。所有 Module Definition 子类至少包含这些字段。Module Record 还定义了 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 中的抽象方法列表。所有 Module definition 子类必须提供这些抽象方法的具体实现。</p>
        <emu-table id="table-module-record-fields" caption="Module Record 字段" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值类型
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                Realm Record
              </td>
              <td>
                创建此模块的领域。
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                Module Environment Record 或 ~empty~
              </td>
              <td>
                包含此模块顶级绑定的 Environment Record。此字段在模块链接时设置。
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                Object 或 ~empty~
              </td>
              <td>
                Module Namespace Object（<emu-xref href="#sec-module-namespace-objects"></emu-xref>），如果已为此模块创建。
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                任意类型（默认值为 *undefined*）
              </td>
              <td>
                为需要将附加信息与模块关联的宿主环境保留的字段。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="Module Record 的抽象方法" oldids="table-37">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                LoadRequestedModules([_hostDefined_])
              </td>
              <td>
                <p>通过递归加载所有依赖项来准备模块以进行链接，并返回一个 promise。</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>返回从此模块直接或间接导出的所有名称的列表。</p>
                <p>在调用此方法之前，LoadRequestedModules 必须已成功完成。</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>返回此模块导出的名称的绑定。绑定由 <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn> 表示，形式为 { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ }。如果导出是没有任何模块中直接绑定的 Module Namespace Object，[[BindingName]] 将设置为 ~namespace~。如果名称无法解析则返回 *null*，如果找到多个绑定则返回 ~ambiguous~。</p>
                <p>每次使用特定 _exportName_、_resolveSet_ 对作为参数调用此操作时，必须返回相同结果。</p>
                <p>在调用此方法之前，LoadRequestedModules 必须已成功完成。</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>通过传递性地解析所有模块依赖项并创建 Module Environment Record 来准备模块以进行求值。</p>
                <p>在调用此方法之前，LoadRequestedModules 必须已成功完成。</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>返回此模块及其依赖项求值的 promise，在成功求值或已成功求值时解决，在求值错误或已求值失败时拒绝。如果 promise 被拒绝，期望宿主处理 promise 拒绝并重新抛出求值错误。</p>
                <p>在调用此方法之前，Link 必须已成功完成。</p>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-EvaluateModuleSync" type="abstract operation">
          <h1>
            EvaluateModuleSync (
              _module_: Module Record,
            ): 包含 ~unused~ 的正常完成或 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>同步求值 _module_，前提是调用者保证 _module_ 的求值将返回已定已 promise。</dd>
          </dl>

          <emu-alg>
            1. 断言：_module_ 不是 Cyclic Module Record。
            1. 令 _promise_ 为 _module_.Evaluate()。
            1. 断言：_promise_.[[PromiseState]] 为 ~fulfilled~ 或 ~rejected~。
            1. 若 _promise_.[[PromiseState]] 为 ~rejected~，则
              1. 若 _promise_.[[PromiseIsHandled]] 为 *false*，执行 HostPromiseRejectionTracker(_promise_, *"handle"*)。
              1. 设 _promise_.[[PromiseIsHandled]] 为 *true*。
              1. 返回 ThrowCompletion(_promise_.[[PromiseResult]])。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>循环模块记录 (Cyclic Module Records)</h1>
        <p><dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record（循环模块记录）</dfn> 用于表示一个模块与其它同属 Cyclic Module Record 类型子类的模块之间可以形成依赖环的信息。不是 Cyclic Module Record 类型子类的 Module Record 不得与 Source Text Module Record 形成依赖环。</p>
        <p>除 <emu-xref href="#table-module-record-fields"></emu-xref> 中定义的字段外，循环模块记录还具有 <emu-xref href="#table-cyclic-module-fields"></emu-xref> 中列出的附加字段。</p>
        <emu-table id="table-cyclic-module-fields" caption="循环模块记录的附加字段 (Additional Fields of Cyclic Module Records)">
          <table>
            <thead>
              <tr>
                <th>
                  字段名 (Field Name)
                </th>
                <th>
                  值类型 (Value Type)
                </th>
                <th>
                  含义 (Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, 或 ~evaluated~
              </td>
              <td>
                初始为 ~new~。在模块生命周期推进过程中按顺序转变为 ~unlinked~, ~linking~, ~linked~, ~evaluating~, 可能的 ~evaluating-async~, 最终 ~evaluated~。~evaluating-async~ 表示该模块已排队等待其异步依赖完成后执行，或其 [[HasTLA]] 为 *true* 且已开始执行，正在等待顶层完成。
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                throw completion 或 ~empty~
              </td>
              <td>
                表示求值期间发生的异常的 throw completion。若无异常或 [[Status]] 不是 ~evaluated~，则为 *undefined*。
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                整数或 ~empty~
              </td>
              <td>
                仅在 Link 与 Evaluate 过程中使用的辅助字段。若 [[Status]] 为 ~linking~ 或 ~evaluating~，此值为该模块的深度优先遍历索引或其所在强连通分量中“更早”模块的索引。
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                ModuleRequest Record 列表
              </td>
              <td>
                与该模块中的 import 相关联的 ModuleRequest Record 列表，按源码出现顺序排列。
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                LoadedModuleRequest Record 列表
              </td>
              <td>
                将此记录所代表模块使用的说明符字符串（及相对导入属性）映射到解析得到的 Module Record。该列表不包含两个不同记录 _r1_ 与 _r2_ 使得 ModuleRequestsEqual(_r1_, _r2_) 为 *true*。
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                Cyclic Module Record 或 ~empty~
              </td>
              <td>
                环的首个访问模块，即强连通分量（SCC）的深度优先根祖先。对不在环中的模块，该字段为其自身。Evaluate 完成后，模块的 [[DFSAncestorIndex]] 等于其 [[CycleRoot]] 的深度优先遍历索引。
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                该模块自身是否为异步（例如包含顶层 await 的 Source Text Module Record）。拥有异步依赖不意味着此字段为 *true*。解析后不得再改变。
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluationOrder]]
              </td>
              <td>
                ~unset~、整数或 ~done~
              </td>
              <td>
                初始为 ~unset~，同步模块保持 ~unset~。对自身异步或拥有异步依赖的模块，设为一个整数，用于决定 <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref> 排队执行的顺序。待执行完毕后设为 ~done~。
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                PromiseCapability Record 或 ~empty~
              </td>
              <td>
                若此模块是某个环的 [[CycleRoot]] 且对该环中某模块调用了 Evaluate()，此字段保存该整体求值的 PromiseCapability，用于完成 Evaluate() 返回的 Promise。除非对依赖发起顶层 Evaluate()，否则依赖的该字段为 ~empty~。
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                Cyclic Module Record 列表
              </td>
              <td>
                若此模块或其依赖具有 [[HasTLA]] *true* 且执行中，记录在顶层执行作业中依赖它的父导入者。在其完成之前这些父模块不会开始执行。
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                整数或 ~empty~
              </td>
              <td>
                若该模块有异步依赖，此值跟踪剩余尚未执行完成的异步依赖模块数量。计数降至 0 且无执行错误时，该模块执行。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>除 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 中的方法外，循环模块记录还具有 <emu-xref href="#table-cyclic-module-methods"></emu-xref> 中列出的附加抽象方法。</p>
        <emu-table id="table-cyclic-module-methods" caption="循环模块记录的附加抽象方法 (Additional Abstract Methods of Cyclic Module Records)">
          <table>
            <thead>
              <tr>
                <th>
                  方法 (Method)
                </th>
                <th>
                  目的 (Purpose)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                初始化模块的 Environment Record（包括解析全部导入绑定）并创建模块的执行上下文。
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule([_promiseCapability_])
              </td>
              <td>
                在其执行上下文内求值模块代码。若模块 [[HasTLA]] 为 *true*，则传入 PromiseCapability Record，方法应 resolve 或 reject 该能力；此时不得抛出异常，需通过 reject 处理。
              </td>
            </tr>
          </table>
        </emu-table>

        <p><dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record（图加载状态记录）</dfn> 是包含模块图加载流程信息的记录，用于在 HostLoadImportedModule 调用后继续加载。每个记录包含 <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref> 中的字段：</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="图加载状态记录字段 (GraphLoadingState Record Fields)">
          <table>
            <thead>
              <tr>
                <th>
                  字段名 (Field Name)
                </th>
                <th>
                  值类型 (Value Type)
                </th>
                <th>
                  含义 (Meaning)
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                PromiseCapability Record
              </td>
              <td>
                加载流程完成时要 resolve 的 promise。
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                Boolean
              </td>
              <td>
                若加载流程尚未成功或失败完成则为 *true*。
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                非负整数
              </td>
              <td>
                跟踪未完成 HostLoadImportedModule 调用的数量。
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                Cyclic Module Record 列表
              </td>
              <td>
                已在本次加载过程中加载的循环模块集合，用于避免循环依赖无限循环。
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                任意（默认 ~empty~）
              </td>
              <td>
                自宿主传入、供 LoadRequestedModules 到 HostLoadImportedModule 传递的宿主定义数据。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-cyclic-module-record-module-record-methods">
          <h1>模块记录抽象方法的具体实现 (Implementation of Module Record Abstract Methods)</h1>

          <p>以下为循环模块记录对 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 中相应模块记录抽象方法的具体实现。</p>

          <emu-clause id="sec-LoadRequestedModules" type="concrete method">
            <h1>
              LoadRequestedModules (
                optional _hostDefined_: anything,
              ): Promise
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>填充 _module_ 依赖图中所有 Module Record 的 [[LoadedModules]]（主要工作由辅助函数 InnerModuleLoading 完成）。可选参数 _hostDefined_ 将传递给 HostLoadImportedModule 钩子。</dd>
            </dl>

            <emu-alg>
              1. 若 _hostDefined_ 未传入，令 _hostDefined_ 为 ~empty~。
              1. 令 _pc_ 为 ! NewPromiseCapability(%Promise%)。
              1. 令 _state_ 为 GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }。
              1. 执行 InnerModuleLoading(_state_, _module_)。
              1. 返回 _pc_.[[Promise]]。
            </emu-alg>

            <emu-note>
              参数 _hostDefined_ 可传递获取导入模块所需的额外信息。例如 HTML 用它为 <code>&lt;link rel="preload" as="..."&gt;</code> 设置正确的 fetch destination。<code>import()</code> 表达式不会设置该参数。
            </emu-note>

            <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
              <h1>
                InnerModuleLoading (
                  _state_: GraphLoadingState Record,
                  _module_: Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>被 LoadRequestedModules 使用，递归执行 _module_ 依赖图的实际加载过程。</dd>
              </dl>

              <emu-alg>
                1. 断言：_state_.[[IsLoading]] 为 *true*。
                1. 若 _module_ 是 Cyclic Module Record，_module_.[[Status]] 为 ~new~ 且 _state_.[[Visited]] 不含 _module_，则
                  1. 将 _module_ 追加至 _state_.[[Visited]]。
                  1. 令 _requestedModulesCount_ 为 _module_.[[RequestedModules]] 的元素数。
                  1. 设 _state_.[[PendingModulesCount]] = _state_.[[PendingModulesCount]] + _requestedModulesCount_。
                  1. 对 _module_.[[RequestedModules]] 每个 ModuleRequest Record _request_：
                    1. 若 AllImportAttributesSupported(_request_.[[Attributes]]) 为 *false*，则
                      1. 令 _error_ 为 ThrowCompletion(新建的 *SyntaxError* 对象)。
                      1. 执行 ContinueModuleLoading(_state_, _error_)。
                    1. 否则若 _module_.[[LoadedModules]] 含 LoadedModuleRequest Record _record_ 使 ModuleRequestsEqual(_record_, _request_) 为 *true*，则
                      1. 执行 InnerModuleLoading(_state_, _record_.[[Module]])。
                    1. 否则，
                      1. 执行 HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_)。
                      1. 注：HostLoadImportedModule 将调用 FinishLoadingImportedModule，经由 ContinueModuleLoading 重新进入图加载流程。
                    1. 若 _state_.[[IsLoading]] 为 *false*，返回 ~unused~。
                1. 断言：_state_.[[PendingModulesCount]] ≥ 1。
                1. 设 _state_.[[PendingModulesCount]] = _state_.[[PendingModulesCount]] - 1。
                1. 若 _state_.[[PendingModulesCount]] = 0，则
                  1. 设 _state_.[[IsLoading]] = *false*。
                  1. 对 _state_.[[Visited]] 中每个 Cyclic Module Record _loaded_：
                    1. 若 _loaded_.[[Status]] 为 ~new~，设其为 ~unlinked~。
                  1. 执行 ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »)。
                1. 返回 ~unused~。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
              <h1>
                ContinueModuleLoading (
                  _state_: GraphLoadingState Record,
                  _moduleCompletion_: 正常完成（含 Module Record）或 throw completion,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>在 HostLoadImportedModule 返回后重新进入加载流程。</dd>
              </dl>

              <emu-alg>
                1. 若 _state_.[[IsLoading]] 为 *false*，返回 ~unused~。
                1. 若 _moduleCompletion_ 为正常完成，则
                  1. 执行 InnerModuleLoading(_state_, _moduleCompletion_.[[Value]])。
                1. 否则，
                  1. 设 _state_.[[IsLoading]] = *false*。
                  1. 执行 ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »)。
                1. 返回 ~unused~。
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
            <h1>Link ( ): 正常完成（含 ~unused~）或 throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>成功时将 [[Status]] 从 ~unlinked~ 过渡到 ~linked~。失败时抛出异常且保持 ~unlinked~。（主要工作由辅助函数 InnerModuleLinking 完成。）</dd>
            </dl>

            <emu-alg>
              1. 断言：_module_.[[Status]] 属于 ~unlinked~, ~linked~, ~evaluating-async~, ~evaluated~ 之一。
              1. 令 _stack_ 为新空列表。
              1. 令 _result_ 为 Completion(InnerModuleLinking(_module_, _stack_, 0))。
              1. 若 _result_ 为突然完成，则
                1. 对 _stack_ 中每个 Cyclic Module Record _m_：
                  1. 断言：_m_.[[Status]] 为 ~linking~。
                  1. 设 _m_.[[Status]] = ~unlinked~。
                1. 断言：_module_.[[Status]] 为 ~unlinked~。
                1. 返回 ? _result_。
              1. 断言：_module_.[[Status]] 属于 ~linked~, ~evaluating-async~, ~evaluated~。
              1. 断言：_stack_ 为空。
              1. 返回 ~unused~。
            </emu-alg>

            <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
              <h1>
                InnerModuleLinking (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record 列表,
                  _index_: 非负整数,
                ): 正常完成（含非负整数）或 throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Link 使用它执行 _module_ 的实际链接，并递归链接其依赖图的其它模块。参数 _stack_ 与 _index_ 以及模块的 [[DFSAncestorIndex]] 用于跟踪深度优先遍历（DFS），借此发现强连通分量（SCC），确保同一 SCC 内模块一起转为 ~linked~。</dd>
              </dl>

              <emu-alg>
                1. 若 _module_ 不是 Cyclic Module Record，则
                  1. 执行 ? _module_.Link()。
                  1. 返回 _index_。
                1. 若 _module_.[[Status]] 属于 ~linking~, ~linked~, ~evaluating-async~, ~evaluated~，则
                  1. 返回 _index_。
                1. 断言：_module_.[[Status]] 为 ~unlinked~。
                1. 设 _module_.[[Status]] = ~linking~。
                1. 令 _moduleIndex_ = _index_。
                1. 设 _module_.[[DFSAncestorIndex]] = _index_。
                1. 设 _index_ = _index_ + 1。
                1. 将 _module_ 追加到 _stack_。
                1. 对 _module_.[[RequestedModules]] 每个 ModuleRequest Record _request_：
                  1. 令 _requiredModule_ = GetImportedModule(_module_, _request_)。
                  1. 设 _index_ = ? InnerModuleLinking(_requiredModule_, _stack_, _index_)。
                  1. 若 _requiredModule_ 是 Cyclic Module Record，则
                    1. 断言：其 [[Status]] 属于 ~linking~, ~linked~, ~evaluating-async~, ~evaluated~。
                    1. 断言：_requiredModule_.[[Status]] 为 ~linking~ 当且仅当 _stack_ 含有它。
                    1. 若为 ~linking~，则
                      1. 设 _module_.[[DFSAncestorIndex]] = min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]])。
                1. 执行 ? _module_.InitializeEnvironment()。
                1. 断言：_module_ 在 _stack_ 中仅出现一次。
                1. 断言：_module_.[[DFSAncestorIndex]] ≤ _moduleIndex_。
                1. 若 _module_.[[DFSAncestorIndex]] = _moduleIndex_，则
                  1. 令 _done_ = *false*。
                  1. 当 _done_ 为 *false* 循环：
                    1. 令 _requiredModule_ 为 _stack_ 最末元素。
                    1. 移除该末元素。
                    1. 断言：_requiredModule_ 为 Cyclic Module Record。
                    1. 设 _requiredModule_.[[Status]] = ~linked~。
                    1. 若 _requiredModule_ 与 _module_ 相同，设 _done_ = *true*。
                1. 返回 _index_。
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduleevaluation" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>Evaluate 将 [[Status]] 从 ~linked~ 过渡为 ~evaluating-async~ 或 ~evaluated~。在给定强连通分量中第一次对任一模块调用时创建并返回 Promise，直至模块求值完成。该 Promise 存入该分量 [[CycleRoot]] 的 [[TopLevelCapability]]。随后对分量中任何模块的调用返回同一 Promise。（主要工作由 InnerModuleEvaluation 完成。）</dd>
            </dl>

            <emu-alg>
              1. 断言：本次 Evaluate 调用未与同代理内另一 Evaluate 并发。
              1. 断言：_module_.[[Status]] 属于 ~linked~, ~evaluating-async~, ~evaluated~。
              1. 若 [[Status]] 为 ~evaluating-async~ 或 ~evaluated~，令 _module_ = _module_.[[CycleRoot]]。
              1. 若 _module_.[[TopLevelCapability]] 非 ~empty~，返回其 [[Promise]]。
              1. 令 _stack_ 为新空列表。
              1. 令 _capability_ = ! NewPromiseCapability(%Promise%)。
              1. 设 _module_.[[TopLevelCapability]] = _capability_。
              1. 令 _result_ = Completion(InnerModuleEvaluation(_module_, _stack_, 0))。
              1. 若 _result_ 为突然完成，则
                1. 对 _stack_ 中每个 Cyclic Module Record _m_：
                  1. 断言：_m_.[[Status]] 为 ~evaluating~。
                  1. 断言：_m_.[[AsyncEvaluationOrder]] 为 ~unset~。
                  1. 设 _m_.[[Status]] = ~evaluated~。
                  1. 设 _m_.[[EvaluationError]] = _result_。
                1. 断言：_module_.[[Status]] 为 ~evaluated~。
                1. 断言：_module_.[[EvaluationError]] 与 _result_ 为同一 Completion Record。
                1. 执行 ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »)。
              1. 否则，
                1. 断言：_module_.[[Status]] 为 ~evaluating-async~ 或 ~evaluated~。
                1. 断言：_module_.[[EvaluationError]] 为 ~empty~。
                1. 若 _module_.[[Status]] 为 ~evaluated~，则
                  1. 注：表示同步完成求值。
                  1. 断言：_module_.[[AsyncEvaluationOrder]] 为 ~unset~。
                  1. 执行 ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »)。
                1. 断言：_stack_ 为空。
              1. 返回 _capability_.[[Promise]]。
            </emu-alg>

            <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
              <h1>
                InnerModuleEvaluation (
                  _module_: Module Record,
                  _stack_: Cyclic Module Record 列表,
                  _index_: 非负整数,
                ): 正常完成（含非负整数）或 throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>Evaluate 使用它执行 _module_ 的实际求值，并递归应用于依赖图的其它模块。_stack_ / _index_ 与 [[DFSAncestorIndex]] 用法与 InnerModuleLinking 相同。</dd>
              </dl>

              <emu-alg>
                1. 若 _module_ 非 Cyclic Module Record，则
                  1. 执行 ? EvaluateModuleSync(_module_)。
                  1. 返回 _index_。
                1. 若 _module_.[[Status]] 为 ~evaluating-async~ 或 ~evaluated~，则
                  1. 若 [[EvaluationError]] 为 ~empty~，返回 _index_。
                  1. 否则返回 ? _module_.[[EvaluationError]]。
                1. 若 _module_.[[Status]] 为 ~evaluating~，返回 _index_。
                1. 断言：_module_.[[Status]] 为 ~linked~。
                1. 设 _module_.[[Status]] = ~evaluating~。
                1. 令 _moduleIndex_ = _index_。
                1. 设 _module_.[[DFSAncestorIndex]] = _index_。
                1. 设 _module_.[[PendingAsyncDependencies]] = 0。
                1. 设 _index_ = _index_ + 1。
                1. 将 _module_ 追加至 _stack_。
                1. 对 _module_.[[RequestedModules]] 每个 ModuleRequest Record _request_：
                  1. 令 _requiredModule_ = GetImportedModule(_module_, _request_)。
                  1. 设 _index_ = ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_)。
                  1. 若 _requiredModule_ 为 Cyclic Module Record，则
                    1. 断言：其 [[Status]] 属于 ~evaluating~, ~evaluating-async~, ~evaluated~。
                    1. 断言：当且仅当 _stack_ 含其时状态为 ~evaluating~。
                    1. 若为 ~evaluating~，设 _module_.[[DFSAncestorIndex]] = min(两者索引)。
                    1. 否则，
                      1. 设 _requiredModule_ = _requiredModule_.[[CycleRoot]]。
                      1. 断言：其 [[Status]] 为 ~evaluating-async~ 或 ~evaluated~。
                      1. 若其 [[EvaluationError]] 非 ~empty~，返回 ? 该错误。
                    1. 若 _requiredModule_.[[AsyncEvaluationOrder]] 为整数，则
                      1. 设 _module_.[[PendingAsyncDependencies]] += 1。
                      1. 将 _module_ 追加至 _requiredModule_.[[AsyncParentModules]]。
                1. 若 _module_.[[PendingAsyncDependencies]] > 0 或 [[HasTLA]] 为 *true*，则
                  1. 断言：_module_.[[AsyncEvaluationOrder]] 为 ~unset~。
                  1. 设 _module_.[[AsyncEvaluationOrder]] = IncrementModuleAsyncEvaluationCount()。
                  1. 若 _module_.[[PendingAsyncDependencies]] = 0，执行 ExecuteAsyncModule(_module_)。
                1. 否则，
                  1. 执行 ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>。
                1. 断言：_module_ 在 _stack_ 中仅出现一次。
                1. 断言：_module_.[[DFSAncestorIndex]] ≤ _moduleIndex_。
                1. 若 _module_.[[DFSAncestorIndex]] = _moduleIndex_，则
                  1. 令 _done_ = *false*。
                  1. 当 _done_ 为 *false*：
                    1. 令 _requiredModule_ 为 _stack_ 最末元素并移除。
                    1. 断言：其为 Cyclic Module Record。
                    1. 断言：其 [[AsyncEvaluationOrder]] 为整数或 ~unset~。
                    1. 若为 ~unset~，设其 [[Status]] = ~evaluated~；否则设为 ~evaluating-async~。
                    1. 若与 _module_ 相同，设 _done_ = *true*。
                    1. 设 _requiredModule_.[[CycleRoot]] = _module_。
                1. 返回 _index_。
              </emu-alg>
              <emu-note>
                <p>模块在 InnerModuleEvaluation 遍历时为 ~evaluating~；若执行完成则为 ~evaluated~，若执行期间自身 [[HasTLA]] 为 *true* 或有异步依赖则为 ~evaluating-async~。</p>
              </emu-note>
              <emu-note>
                <p>依赖某异步环的模块在该环不处于 ~evaluating~ 时，通过 [[CycleRoot]] 依赖环根的执行，确保环作为单个强连通分量对待。</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-execute-async-module" type="abstract operation">
              <h1>
                ExecuteAsyncModule (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>

              <emu-alg>
                1. 断言：_module_.[[Status]] 为 ~evaluating~ 或 ~evaluating-async~。
                1. 断言：_module_.[[HasTLA]] 为 *true*。
                1. 令 _capability_ = ! NewPromiseCapability(%Promise%)。
                1. 令 _fulfilledClosure_ 为捕获 _module_ 的无参抽象闭包，调用时：
                  1. 执行 AsyncModuleExecutionFulfilled(_module_)。
                  1. 返回 NormalCompletion(*undefined*)。
                1. 令 _onFulfilled_ = CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »)。
                1. 令 _rejectedClosure_ 为捕获 _module_ 的抽象闭包（参数 _error_）：
                  1. 执行 AsyncModuleExecutionRejected(_module_, _error_)。
                  1. 返回 NormalCompletion(*undefined*)。
                1. 令 _onRejected_ = CreateBuiltinFunction(_rejectedClosure_, 0, *""*, « »)。
                1. 执行 PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_)。
                1. 执行 ! <emu-meta effects="user-code">_module_.ExecuteModule</emu-meta>(_capability_)。
                1. 返回 ~unused~。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-gather-available-ancestors" type="abstract operation">
              <h1>
                GatherAvailableAncestors (
                  _module_: Cyclic Module Record,
                  _execList_: Cyclic Module Record 列表,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. 对 _module_.[[AsyncParentModules]] 中每个 Cyclic Module Record _m_：
                  1. 若 _execList_ 不含 _m_ 且 _m_.[[CycleRoot]].[[EvaluationError]] 为 ~empty~，则
                    1. 断言：_m_.[[Status]] 为 ~evaluating-async~。
                    1. 断言：_m_.[[EvaluationError]] 为 ~empty~。
                    1. 断言：_m_.[[AsyncEvaluationOrder]] 为整数。
                    1. 断言：_m_.[[PendingAsyncDependencies]] > 0。
                    1. 设 _m_.[[PendingAsyncDependencies]] = _m_.[[PendingAsyncDependencies]] - 1。
                    1. 若其为 0，则
                      1. 将 _m_ 追加至 _execList_。
                      1. 若 _m_.[[HasTLA]] 为 *false*，执行 GatherAvailableAncestors(_m_, _execList_)。
                1. 返回 ~unused~。
              </emu-alg>
              <emu-note>
                <p>当根 _module_ 的异步执行 fulfilled 时，此函数确定可同步继续执行的模块集合，填入 _execList_。</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-fulfilled" type="abstract operation">
              <h1>
                AsyncModuleExecutionFulfilled (
                  _module_: Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. 若 _module_.[[Status]] 为 ~evaluated~，则
                  1. 断言：_module_.[[EvaluationError]] 非 ~empty~。
                  1. 返回 ~unused~。
                1. 断言：_module_.[[Status]] 为 ~evaluating-async~。
                1. 断言：_module_.[[AsyncEvaluationOrder]] 为整数。
                1. 断言：_module_.[[EvaluationError]] 为 ~empty~。
                1. 设 _module_.[[AsyncEvaluationOrder]] = ~done~。
                1. 设 _module_.[[Status]] = ~evaluated~。
                1. 若 _module_.[[TopLevelCapability]] 非 ~empty~，则
                  1. 断言：_module_.[[CycleRoot]] 与 _module_ 为同一记录。
                  1. 执行 ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »)。
                1. 令 _execList_ 为新空列表。
                1. 执行 GatherAvailableAncestors(_module_, _execList_)。
                1. 断言：_execList_ 各元素之 [[AsyncEvaluationOrder]] 为整数、[[PendingAsyncDependencies]] 为 0、[[EvaluationError]] 为 ~empty~。
                1. 令 _sortedExecList_ 为按 [[AsyncEvaluationOrder]] 升序排序的 _execList_ 拷贝。
                1. 对 _sortedExecList_ 每个 Cyclic Module Record _m_：
                  1. 若 _m_.[[Status]] 为 ~evaluated~，断言其 [[EvaluationError]] 非 ~empty~。
                  1. 否则若 _m_.[[HasTLA]] 为 *true*，执行 ExecuteAsyncModule(_m_)。
                  1. 否则，
                    1. 令 _result_ = <emu-meta effects="user-code">_m_.ExecuteModule()</emu-meta>。
                    1. 若 _result_ 为突然完成，执行 AsyncModuleExecutionRejected(_m_, _result_.[[Value]])。
                    1. 否则，
                      1. 设 _m_.[[AsyncEvaluationOrder]] = ~done~。
                      1. 设 _m_.[[Status]] = ~evaluated~。
                      1. 若 _m_.[[TopLevelCapability]] 非 ~empty~：
                        1. 断言：_m_.[[CycleRoot]] 与 _m_ 相同。
                        1. 执行 ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »)。
                1. 返回 ~unused~。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-rejected" type="abstract operation">
              <h1>
                AsyncModuleExecutionRejected (
                  _module_: Cyclic Module Record,
                  _error_: ECMAScript 语言值,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. 若 _module_.[[Status]] 为 ~evaluated~，则
                  1. 断言：_module_.[[EvaluationError]] 非 ~empty~。
                  1. 返回 ~unused~。
                1. 断言：_module_.[[Status]] 为 ~evaluating-async~。
                1. 断言：_module_.[[AsyncEvaluationOrder]] 为整数。
                1. 断言：_module_.[[EvaluationError]] 为 ~empty~。
                1. 设 _module_.[[EvaluationError]] = ThrowCompletion(_error_)。
                1. 设 _module_.[[Status]] = ~evaluated~。
                1. 设 _module_.[[AsyncEvaluationOrder]] = ~done~。
                1. 注：出于与 AsyncModuleExecutionFulfilled 对称，在出现错误时也设为 ~done~；当 [[EvaluationError]] 非 ~empty~ 时，其 [[AsyncEvaluationOrder]] 不再使用。
                1. 对 _module_.[[AsyncParentModules]] 中每个 Cyclic Module Record _m_：
                  1. 执行 AsyncModuleExecutionRejected(_m_, _error_)。
                1. 若 _module_.[[TopLevelCapability]] 非 ~empty~，则
                  1. 断言：_module_.[[CycleRoot]] 与 _module_ 相同。
                  1. 执行 ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ »)。
                1. 返回 ~unused~。
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-example-cyclic-module-record-graphs">
          <h1>循环模块记录图示例 (Example Cyclic Module Record Graphs)</h1>

          <p>本非规范性章节展示若干常见模块图的链接与求值示例，重点说明错误如何出现。</p>

          <p>先看一个简单模块图：</p>

          <emu-figure id="figure-module-graph-simple" caption="简单模块图 (A simple module graph)">
            <img alt="模块 A 依赖模块 B，模块 B 依赖模块 C 的模块图" width="60" height="198" src="https://tc39.es/ecma262/img/module-graph-simple.svg">
          </emu-figure>

          <p>假设无错误：宿主首先调用 _A_.LoadRequestedModules()（递归加载 _B_ 与 _C_ 的依赖），然后将 _A_、_B_、_C_ 的 [[Status]] 设为 ~unlinked~。接着调用 _A_.Link()，三者转为 ~linked~。稍后宿主在需要触发副作用时调用 _A_.Evaluate()，按顺序先求值 _C_ 再 _B_，最终三者 [[Status]] 为 ~evaluated~，Promise resolve 为 *undefined*。</p>

          <p>若在成功的 _A_.LoadRequestedModules() 之后出现链接错误：例如 InnerModuleLinking 处理 _C_ 成功但随后 _B_ 失败（导入不存在的内容），则 _A_.Link() 失败，_A_ 与 _B_ 保持 ~unlinked~，_C_ 为 ~linked~。</p>

          <p>若在成功 Link() 后出现求值错误：例如 _C_ 求值成功但 _B_ 中代码抛出异常，则 _A_.Evaluate() 返回被拒绝的 Promise；异常记录在 _A_ 与 _B_ 的 [[EvaluationError]]，二者变为 ~evaluated~。_C_ 也为 ~evaluated~ 但无错误。记录异常保证后续再次 Evaluate() 遇到相同错误。</p>

          <p>接着看一个无法解析模块的情形：</p>

          <emu-figure id="figure-module-graph-missing" caption="含缺失模块的模块图 (A module graph with an unresolvable module)">
            <img alt="模块 A 依赖一个缺失模块 ??? 的模块图" width="60" height="121" src="https://tc39.es/ecma262/img/module-graph-missing.svg">
          </emu-figure>

          <p>此时 _A_ 依赖的模块不存在（HostLoadImportedModule 最终以异常完成 FinishLoadingImportedModule）。可能原因包括资源不存在或解析返回错误。宿主可选择暴露失败原因。该异常导致加载失败，_A_.[[Status]] 保持 ~new~。</p>

          <p>加载、链接与求值错误的差异：</p>
          <ul>
            <li>求值只应执行一次（可能有副作用），需记住是否已求值及其结果（包含异常）。</li>
            <li>链接无副作用，可失败后重试。</li>
            <li>加载与宿主交互紧密，宿主可能允许在临时网络错误后重试。</li>
          </ul>

          <p>现在看一个包含环的模块图：</p>

          <emu-figure id="figure-module-graph-cycle" caption="循环模块图 (A cyclic module graph)">
            <img alt="模块 A 依赖 B 和 C，且 B 依赖 A 的模块图" width="181" height="121" src="https://tc39.es/ecma262/img/module-graph-cycle.svg">
          </emu-figure>

          <p>以 _A_ 为入口，LoadRequestedModules 触发对 _B_ 与 _C_ 的加载；因循环再次访问 _A_ 时不再重复。成功后所有模块状态同时从 ~new~ 转为 ~unlinked~。</p>

          <p>随后 Link 通过 DFS 对环进行 InnerModuleLinking，遇回返时不重复，最终在回溯根时同时把 SCC 中的 _A_ 与 _B_ 设为 ~linked~（_C_ 已先行）。求值阶段的成功路径类同。</p>

          <p>若 _A_ 存在链接错误（如从 _C_ 导入不存在的绑定），第二次回到 _A_ 时提前返回，但最终在 InitializeEnvironment（调用 _C_.ResolveExport 后）抛出 *SyntaxError*。异常向上使当前栈中仍 ~linking~ 的 _A_ 与 _B_ 重置为 ~unlinked~，_C_ 保持 ~linked~。</p>

          <p>若 _A_ 存在求值错误（源码抛异常），则求值阶段对应逻辑使 _A_ 与仍 ~evaluating~ 的 _B_ 记录错误并转为 ~evaluated~，_C_ 成功为 ~evaluated~ 且无错误。包含顶层 await 的路径通过 [[AsyncParentModules]] 传播。</p>

          <p>最后看一个所有模块异步完成的循环图：</p>
          <emu-figure id="figure-module-graph-cycle-async" caption="异步循环模块图 (An asynchronous cyclic module graph)">
            <img alt="模块 A 依赖 B 与 C，B 依赖 D，C 依赖 D 与 E，D 依赖 A 的模块图" width="241" height="211" src="https://tc39.es/ecma262/img/module-graph-cycle-async.svg">
          </emu-figure>
          <p>加载与链接后全部为 ~linked~。</p>

          <p>调用 _A_.Evaluate()：_A_、_B_、_D_ 设为 ~evaluating~；_D_ 无待依赖触发 ExecuteAsyncModule(_D_)；回溯时 _B_ 记录等待；继续处理 _C_ 及其 _D_（无操作）与 _E_（执行异步）。最终整个环出栈，转为 ~evaluating-async~，其字段如 <emu-xref href="#table-module-graph-cycle-async-fields-1"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-1" caption="初次 Evaluate() 后的模块字段 (Module fields after the initial Evaluate() call)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">字段 / 模块</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
                <td>3</td>
                <td>0</td>
                <td>2</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>2 (_B_, _C_)</td>
                <td>1 (_D_)</td>
                <td>2 (_D_, _E_)</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>假设 _E_ 先完成，调用 AsyncModuleExecutionFulfilled：_E_ 为 ~evaluated~，_C_.[[PendingAsyncDependencies]] 减至 1；字段见 <emu-xref href="#table-module-graph-cycle-async-fields-2"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-2" caption="模块 _E_ 完成后的字段 (Module fields after module _E_ finishes executing)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_C_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_D_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>接着 _D_ 完成：_D_ 设为 ~evaluated~，其可激活祖先为 _B_（顺序 1）与 _C_（顺序 3），因此先处理 _B_：其 Pending 变为 0，执行 ExecuteAsyncModule(_B_)；随后 _C_ 也开始执行；字段见 <emu-xref href="#table-module-graph-cycle-async-fields-3"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-3" caption="模块 _D_ 完成后的字段 (Module fields after module _D_ finishes executing)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th><td>0</td><td>0</td><td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th><td>~evaluating-async~</td><td>~evaluating-async~</td><td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th><td>1</td><td>3</td><td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th><td>« _A_ »</td><td>« _A_ »</td><td>« _B_, _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th><td>0</td><td>0</td><td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>然后 _C_ 完成：设为 ~evaluated~，_A_.Pending 减为 1；见 <emu-xref href="#table-module-graph-cycle-async-fields-4"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-4" caption="模块 _C_ 完成后的字段 (Module fields after module _C_ finishes executing)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr><th>[[DFSAncestorIndex]]</th><td>0</td><td>0</td></tr>
              <tr><th>[[Status]]</th><td>~evaluating-async~</td><td>~evaluated~</td></tr>
              <tr><th>[[AsyncEvaluationOrder]]</th><td>4</td><td>~done~</td></tr>
              <tr><th>[[AsyncParentModules]]</th><td>« »</td><td>« _A_ »</td></tr>
              <tr><th>[[PendingAsyncDependencies]]</th><td>1 (_B_)</td><td>0</td></tr>
            </table>
          </emu-table>

          <p>随后 _B_ 完成：设为 ~evaluated~，_A_.Pending 减为 0，执行 ExecuteAsyncModule(_A_)；见 <emu-xref href="#table-module-graph-cycle-async-fields-5"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-5" caption="模块 _B_ 完成后的字段 (Module fields after module _B_ finishes executing)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr><th>[[DFSAncestorIndex]]</th><td>0</td><td>0</td></tr>
              <tr><th>[[Status]]</th><td>~evaluating-async~</td><td>~evaluated~</td></tr>
              <tr><th>[[AsyncEvaluationOrder]]</th><td>4</td><td>~done~</td></tr>
              <tr><th>[[AsyncParentModules]]</th><td>« »</td><td>« _A_ »</td></tr>
              <tr><th>[[PendingAsyncDependencies]]</th><td>0</td><td>0</td></tr>
            </table>
          </emu-table>

          <p>最终 _A_ 完成：_A_ 设为 ~evaluated~，其 [[TopLevelCapability]] 的 Promise resolve，图处理结束；见 <emu-xref href="#table-module-graph-cycle-async-fields-6"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-6" caption="模块 _A_ 完成后的字段 (Module fields after module _A_ finishes executing)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr><th>[[DFSAncestorIndex]]</th><td>0</td></tr>
              <tr><th>[[Status]]</th><td>~evaluated~</td></tr>
              <tr><th>[[AsyncEvaluationOrder]]</th><td>~done~</td></tr>
              <tr><th>[[AsyncParentModules]]</th><td>« »</td></tr>
              <tr><th>[[PendingAsyncDependencies]]</th><td>0</td></tr>
            </table>
          </emu-table>

          <p>若失败：假设 _C_ 先执行出错，在 AsyncModuleExecutionRejected 中 _C_ 设为 ~evaluated~ 且记录错误，并沿 AsyncParentModules 传播；见 <emu-xref href="#table-module-graph-cycle-async-fields-7"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-7" caption="模块 _C_ 错误后的字段 (Module fields after module _C_ finishes with an error)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr><th>[[DFSAncestorIndex]]</th><td>0</td><td>0</td></tr>
              <tr><th>[[Status]]</th><td>~evaluated~</td><td>~evaluated~</td></tr>
              <tr><th>[[AsyncEvaluationOrder]]</th><td>~done~</td><td>~done~</td></tr>
              <tr><th>[[AsyncParentModules]]</th><td>« »</td><td>« _A_ »</td></tr>
              <tr><th>[[PendingAsyncDependencies]]</th><td>1 (_B_)</td><td>0</td></tr>
              <tr><th>[[EvaluationError]]</th><td>~empty~</td><td>_C_ 的求值错误</td></tr>
            </table>
          </emu-table>

          <p>_A_ 也被拒绝并记录相同错误；见 <emu-xref href="#table-module-graph-cycle-async-fields-8"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-8" caption="模块 _A_ 被拒绝后的字段 (Module fields after module _A_ is rejected)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr><th>[[DFSAncestorIndex]]</th><td>0</td></tr>
              <tr><th>[[Status]]</th><td>~evaluated~</td></tr>
              <tr><th>[[AsyncEvaluationOrder]]</th><td>~done~</td></tr>
              <tr><th>[[AsyncParentModules]]</th><td>« »</td></tr>
              <tr><th>[[PendingAsyncDependencies]]</th><td>0</td></tr>
              <tr><th>[[EvaluationError]]</th><td>_C_ 的 Evaluation Error</td></tr>
            </table>
          </emu-table>

          <p>若随后 _B_ 正常完成，AsyncModuleExecutionFulfilled 运行但因 _A_（环根）已有错误，不再继续执行；未来导入 _B_ 的模块通过 _B_.[[CycleRoot]].[[EvaluationError]] 看到同一错误；见 <emu-xref href="#table-module-graph-cycle-async-fields-9"></emu-xref>。</p>

          <emu-table id="table-module-graph-cycle-async-fields-9" caption="错误图中 _B_ 完成后的字段 (Module fields after module _B_ finishes executing in an erroring graph)">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell"><span class="column">字段</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span></th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr><th>[[DFSAncestorIndex]]</th><td>0</td><td>0</td></tr>
              <tr><th>[[Status]]</th><td>~evaluated~</td><td>~evaluated~</td></tr>
              <tr><th>[[AsyncEvaluationOrder]]</th><td>4</td><td>1</td></tr>
              <tr><th>[[AsyncParentModules]]</th><td>« »</td><td>« _A_ »</td></tr>
              <tr><th>[[PendingAsyncDependencies]]</th><td>0</td><td>0</td></tr>
              <tr><th>[[EvaluationError]]</th><td>_C_ 的 Evaluation Error</td><td>~empty~</td></tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>源码文本模块记录 (Source Text Module Records)</h1>

        <p><dfn id="sourctextmodule-record" variants="Source Text Module Records">Source Text Module Record（源码文本模块记录）</dfn> 表示由 ECMAScript 源文本（<emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>，以 |Module| 为目标符号）解析出的模块信息。其字段包含模块导入与导出的摘要，具体方法利用这些摘要进行链接与求值。</p>

        <p>该记录可与其它 Module Record 子类共存于模块图，并可与其它 Cyclic Module Record 子类构成环。</p>

        <p>除 <emu-xref href="#table-cyclic-module-fields"></emu-xref> 字段外，还拥有 <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref> 中列出的附加字段，均在 ParseModule 中初始化。</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="源码文本模块记录附加字段 (Additional Fields of Source Text Module Records)" oldids="table-38">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值类型
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                Parse Node
              </td>
              <td>
                以 |Module| 为目标符号解析该模块源文本的结果。
              </td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                ECMAScript 代码执行上下文或 ~empty~
              </td>
              <td>
                与模块关联的执行上下文；在环境初始化前为 ~empty~。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                Object 或 ~empty~
              </td>
              <td>
                通过 `import.meta` 暴露的对象；首次访问前为 ~empty~。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                ImportEntry Record 列表
              </td>
              <td>
                源码导入语句解析出的 ImportEntry 列表。
              </td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                ExportEntry Record 列表
              </td>
              <td>
                对应模块内部声明的导出。
              </td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                ExportEntry Record 列表
              </td>
              <td>
                对应重导出的导入或 `export * as namespace` 的导出。
              </td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                ExportEntry Record 列表
              </td>
              <td>
                对应 `export *`（不含 `export * as namespace`）的导出。
              </td>
            </tr>
          </table>
        </emu-table>
        <p><dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record（导入项记录）</dfn> 汇总单个声明式导入的信息，其字段见 <emu-xref href="#table-importentry-record-fields"></emu-xref>：</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry 记录字段 (ImportEntry Record Fields)" oldids="table-39">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值类型
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record
              </td>
              <td>
                表示 |ImportDeclaration| 的 |ModuleSpecifier| 与导入属性。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String 或 ~namespace-object~
              </td>
              <td>
                目标模块中导出的绑定名称。~namespace-object~ 表示请求模块命名空间对象。
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String
              </td>
              <td>
                在本模块中访问该导入值的局部名字。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> 展示不同导入语法与 ImportEntry 字段的映射：</p>
          <emu-table id="table-import-forms-mapping-to-importentry-records" caption="导入语法到 ImportEntry 映射 (Import Forms Mappings to ImportEntry Records)" informative oldids="table-40">
            <table>
              <thead>
                <tr>
                  <th>
                    导入语句形式
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~namespace-object~
                </td>
                <td>
                  *"ns"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  不创建 ImportEntry Record
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p><dfn id="exportentry-record" variants="ExportEntry Records">ExportEntry Record（导出项记录）</dfn> 汇总单个声明式导出信息，字段见 <emu-xref href="#table-exportentry-records"></emu-xref>：</p>
        <emu-table id="table-exportentry-records" caption="ExportEntry 记录字段 (ExportEntry Record Fields)" oldids="table-41">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值类型
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                String 或 *null*
              </td>
              <td>
                对外导出的名称。
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                ModuleRequest Record 或 *null*
              </td>
              <td>
                表示 |ExportDeclaration| 的 |ModuleSpecifier| 与导入属性；无则为 *null*。
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String、*null*、~all~ 或 ~all-but-default~
              </td>
              <td>
                从 [[ModuleRequest]] 指定模块导出的绑定名；`export * as ns` 用 ~all~，`export *` 用 ~all-but-default~。无则 *null*。
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String 或 *null*
              </td>
              <td>
                在本模块内部访问该导出值的名字；若非本地可访问则为 *null*。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-export-forms-mapping-to-exportentry-records"></emu-xref> 展示导出语法与 ExportEntry 字段映射：</p>
          <emu-table id="table-export-forms-mapping-to-exportentry-records" caption="导出语法到 ExportEntry 映射 (Export Forms Mappings to ExportEntry Records)" informative oldids="table-42">
            <table>
              <thead>
                <tr>
                  <th>
                    导出语句形式
                  </th>
                  <th>
                    [[ExportName]]
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f() {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"f"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function () {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"*default*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"*default*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all-but-default~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * as ns from "mod";`
                </td>
                <td>
                  *"ns"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all~
                </td>
                <td>
                  *null*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>以下定义 Source Text Module Record 所需的具体方法与相关抽象操作。</p>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript 源文本,
              _realm_: Realm Record,
              _hostDefined_: 任意,
            ): Source Text Module Record 或非空 *SyntaxError* 对象列表
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>将 _sourceText_ 以 |Module| 解析并创建 Source Text Module Record。</dd>
          </dl>
          <emu-alg>
            1. 令 _body_ = ParseText(_sourceText_, |Module|)。
            1. 若 _body_ 为错误列表，返回之。
            1. 令 _requestedModules_ = ModuleRequests(_body_)。
            1. 令 _importEntries_ = ImportEntries(_body_)。
            1. 令 _importedBoundNames_ = ImportedLocalNames(_importEntries_)。
            1. 令 _indirectExportEntries_、_localExportEntries_、_starExportEntries_ 各为新空列表。
            1. 令 _exportEntries_ = ExportEntries(_body_)。
            1. 对 _exportEntries_ 每个 ExportEntry Record _ee_：
              1. 若 _ee_.[[ModuleRequest]] 为 *null*，则
                1. 若 _importedBoundNames_ 不含 _ee_.[[LocalName]]，追加 _ee_ 至 _localExportEntries_。
                1. 否则，
                  1. 令 _ie_ 为 _importEntries_ 中 [[LocalName]] 等于该名的元素。
                  1. 若 _ie_.[[ImportName]] 为 ~namespace-object~，
                    1. 注：重导出模块命名空间对象。
                    1. 追加 _ee_ 至 _localExportEntries_。
                  1. 否则：
                    1. 注：重导出单一名称。
                    1. 追加 ExportEntry { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } 至 _indirectExportEntries_。
              1. 否则若 _ee_.[[ImportName]] 为 ~all-but-default~：
                1. 断言：_ee_.[[ExportName]] 为 *null*。
                1. 追加 _ee_ 至 _starExportEntries_。
              1. 否则追加 _ee_ 至 _indirectExportEntries_。
            1. 令 _async_ = _body_ Contains `await`。
            1. 返回 Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSAncestorIndex]]: ~empty~ }。
          </emu-alg>
          <emu-note>
            <p>实现可提前解析并检查早期错误，但错误报告需延迟到实际调用 ParseModule 时。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-module-record-methods">
          <h1>模块记录抽象方法实现 (Implementation of Module Record Abstract Methods)</h1>

          <p>以下为 Source Text Module Record 对 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 中模块记录抽象方法的具体实现。</p>

          <emu-clause id="sec-getexportednames" type="concrete method">
            <h1>
              GetExportedNames (
                optional _exportStarSet_: Source Text Module Record 列表,
              ): String 列表
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>
            <emu-alg>
              1. 断言：_module_.[[Status]] 非 ~new~。
              1. 若 _exportStarSet_ 未传入，设为新空列表。
              1. 若 _exportStarSet_ 含 _module_：
                1. 断言：达到 `export *` 循环起点。
                1. 返回新空列表。
              1. 追加 _module_ 至 _exportStarSet_。
              1. 令 _exportedNames_ 为新空列表。
              1. 对 _module_.[[LocalExportEntries]] 每个 _e_：
                1. 断言：存在直接绑定。
                1. 断言：_e_.[[ExportName]] 非 *null*。
                1. 追加该名称。
              1. 对 _module_.[[IndirectExportEntries]] 每个 _e_：
                1. 断言：导入特定绑定。
                1. 追加 _e_.[[ExportName]]。
              1. 对 _module_.[[StarExportEntries]] 每个 _e_：
                1. 断言：_e_.[[ModuleRequest]] 非 *null*。
                1. 令 _requestedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]])。
                1. 令 _starNames_ = _requestedModule_.GetExportedNames(_exportStarSet_)。
                1. 对 _starNames_ 每个 _n_：
                  1. 若 _n_ 非 *"default"* 且 _exportedNames_ 不含 _n_，则追加。
              1. 返回 _exportedNames_。
            </emu-alg>
            <emu-note>
              <p>GetExportedNames 不过滤或抛出模糊的星号再导出绑定。</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: String,
                optional _resolveSet_: 记录列表（字段 [[Module]] Module Record，[[ExportName]] String),
              ): ResolvedBinding Record、*null* 或 ~ambiguous~
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>

              <dt>description</dt>
              <dd>
                <p>尝试解析导出名称到定义的模块与局部绑定名。若是命名空间导出且无本地绑定，则 [[BindingName]] 为 ~namespace~。_resolveSet_ 用于检测循环路径；若对同一 (_module_, _exportName_) 再次出现则返回 *null*。找到单一定义返回 ResolvedBinding；无定义或循环返回 *null*；多重模糊返回 ~ambiguous~。</p>
              </dd>
            </dl>

            <emu-alg>
              1. 断言：_module_.[[Status]] 非 ~new~。
              1. 若 _resolveSet_ 未传入，设为新空列表。
              1. 若 _resolveSet_ 中存在记录与 (_module_, _exportName_) 相同：
                1. 断言：循环导出请求。
                1. 返回 *null*。
              1. 追加 { [[Module]]: _module_, [[ExportName]]: _exportName_ } 至 _resolveSet_。
              1. 遍历 [[LocalExportEntries]]：
                1. 若匹配 _exportName_，返回 { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }。
              1. 遍历 [[IndirectExportEntries]]：
                1. 若匹配：
                  1. 断言有 [[ModuleRequest]]。
                  1. 令 _importedModule_ = GetImportedModule(_module_, _e_.[[ModuleRequest]])。
                  1. 若 _e_.[[ImportName]] 为 ~all~：
                    1. 返回 { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }。
                  1. 否则返回 _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_)。
              1. 若 _exportName_ 为 *"default"*：
                1. 返回 *null*。（默认导出不会由 `export * from` 提供）
              1. 令 _starResolution_ = *null*。
              1. 遍历 [[StarExportEntries]]：
                1. 令 _importedModule_ = GetImportedModule(... )。
                1. 令 _resolution_ = _importedModule_.ResolveExport(_exportName_, _resolveSet_)。
                1. 若 ~ambiguous~ 返回 ~ambiguous~。
                1. 若非 *null*：
                  1. 若 _starResolution_ 为 *null*，设之。
                  1. 否则若模块不同或 BindingName 不兼容（含命名空间冲突）返回 ~ambiguous~。
              1. 返回 _starResolution_。
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-cyclic-module-record-methods">
          <h1>循环模块记录抽象方法的实现 (Implementation of Cyclic Module Record Abstract Methods)</h1>

          <p>以下为 Source Text Module Record 对 <emu-xref href="#table-cyclic-module-methods"></emu-xref> 中循环模块记录抽象方法的实现。</p>

          <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
            <h1>InitializeEnvironment ( ): 正常完成（含 ~unused~）或 throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 对 _module_.[[IndirectExportEntries]] 每个 _e_：
                1. 断言 _e_.[[ExportName]] 非 *null*。
                1. 令 _resolution_ = _module_.ResolveExport(_e_.[[ExportName]])。
                1. 若为 *null* 或 ~ambiguous~ 抛 *SyntaxError*。
              1. 断言所有命名导出可解析。
              1. 令 _realm_ = _module_.[[Realm]]。
              1. 断言非 *undefined*。
              1. 令 _env_ = NewModuleEnvironment(_realm_.[[GlobalEnv]])。
              1. 设 _module_.[[Environment]] = _env_。
              1. 对 _module_.[[ImportEntries]] 每个 _in_：
                1. 令 _importedModule_ = GetImportedModule(... )。
                1. 若 _in_.[[ImportName]] 为 ~namespace-object~：
                  1. 令 _namespace_ = GetModuleNamespace(_importedModule_)。
                  1. ! CreateImmutableBinding + InitializeBinding。
                1. 否则：
                  1. 令 _resolution_ = _importedModule_.ResolveExport(_in_.[[ImportName]])。
                  1. 若 *null* 或 ~ambiguous~ 抛 *SyntaxError*。
                  1. 若 _resolution_.[[BindingName]] 为 ~namespace~：
                    1. 获取命名空间并绑定。
                  1. 否则 CreateImportBinding。
              1. 创建执行上下文 _moduleContext_ 并关联环境。
              1. 推入执行上下文栈并获取 _code_。
              1. 处理 VarScopedDeclarations：为每个唯一变量创建并初始化 *undefined*。
              1. 处理 LexicallyScopedDeclarations：创建（可变或不可变）绑定；若是函数类声明，实例化函数对象并初始化绑定。
              1. 弹出执行上下文。
              1. 返回 ~unused~。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
            <h1>
              ExecuteModule (
                optional _capability_: PromiseCapability Record,
              ): 正常完成（含 ~unused~）或 throw completion
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 创建新执行上下文 _moduleContext_ 并关联 _module_.[[Environment]]。
              1. 暂停当前执行上下文。
              1. 若 _module_.[[HasTLA]] 为 *false*：
                1. 断言 _capability_ 未提供。
                1. 推入 _moduleContext_。
                1. 令 _result_ = Completion(Evaluation of _module_.[[ECMAScriptCode]])。
                1. 弹出并恢复上层上下文。
                1. 若 _result_ 为突然完成，返回 ? _result_。
              1. 否则：
                1. 断言 _capability_ 存在。
                1. 执行 AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_)。
              1. 返回 ~unused~。
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-synthetic-module-records">
        <h1>合成模块记录 (Synthetic Module Records)</h1>

        <p><dfn variants="Synthetic Module Records">Synthetic Module Record（合成模块记录）</dfn> 表示由规范定义的模块，其导出名称在创建时静态确定，但值可通过 SetSyntheticModuleExport 动态更新；无导入或依赖。</p>

        <emu-note>可用于定义多种模块类型，如 JSON 模块或 CSS 模块。</emu-note>

        <p>除 <emu-xref href="#table-module-record-fields"></emu-xref> 字段外，还具有 <emu-xref href="#table-synthetic-module-record-fields"></emu-xref> 中附加字段。</p>

        <emu-table id="table-synthetic-module-record-fields" caption="合成模块记录附加字段 (Additional Fields of Synthetic Module Records)">
          <table>
            <thead>
              <tr>
                <th>字段名</th>
                <th>值类型</th>
                <th>含义</th>
              </tr>
            </thead>
            <tr>
              <td>[[ExportNames]]</td>
              <td>字符串列表</td>
              <td>模块的导出名称；无重复。</td>
            </tr>
            <tr>
              <td>[[EvaluationSteps]]</td>
              <td>抽象闭包</td>
              <td>求值期间的初始化逻辑，以模块自身为唯一参数；不得修改 [[ExportNames]]；可返回突然完成。</td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-create-default-export-synthetic-module" type="abstract operation">
          <h1>
            CreateDefaultExportSyntheticModule (
              _defaultExport_: ECMAScript 语言值,
            ): Synthetic Module Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>创建一个默认导出为 _defaultExport_ 的合成模块记录。</dd>
          </dl>
          <emu-alg>
            1. 令 _realm_ 为当前 Realm Record。
            1. 令 _setDefaultExport_ 为捕获 _defaultExport_ 的抽象闭包(_module_)：
              1. 执行 SetSyntheticModuleExport(_module_, *"default"*, _defaultExport_)。
              1. 返回 NormalCompletion(~unused~)。
            1. 返回 { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[HostDefined]]: *undefined*, [[ExportNames]]: « *"default"* », [[EvaluationSteps]]: _setDefaultExport_ } 的 Synthetic Module Record。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parse-json-module" type="abstract operation">
          <h1>
            ParseJSONModule (
              _source_: String,
            ): 正常完成（含 Synthetic Module Record）或 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. 令 _json_ = ? ParseJSON(_source_)。
            1. 返回 CreateDefaultExportSyntheticModule(_json_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-setsyntheticmoduleexport" type="abstract operation">
          <h1>
            SetSyntheticModuleExport (
              _module_: Synthetic Module Record,
              _exportName_: String,
              _exportValue_: ECMAScript 语言值,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>设置或更新合成模块已存在导出的值。</dd>
          </dl>

          <emu-alg>
            1. 断言：_module_.[[ExportNames]] 含 _exportName_。
            1. 令 _envRec_ = _module_.[[Environment]]。
            1. 断言：_envRec_ 非 ~empty~。
            1. 执行 _envRec_.SetMutableBinding(_exportName_, _exportValue_, *true*)。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-smr-module-record-methods">
          <h1>模块记录抽象方法实现 (Implementation of Module Record Abstract Methods)</h1>

          <p>以下为合成模块记录对 <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> 抽象方法的实现。</p>

          <emu-clause id="sec-smr-LoadRequestedModules" type="concrete method">
            <h1>LoadRequestedModules ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 返回 ! PromiseResolve(%Promise%, *undefined*)。
            </emu-alg>

            <emu-note>
              合成模块记录无依赖。
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-smr-getexportednames" type="concrete method">
            <h1>GetExportedNames ( ): 字符串列表</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 返回 _module_.[[ExportNames]]。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: String,
              ): ResolvedBinding Record 或 *null*
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 若不含 _exportName_，返回 *null*。
              1. 返回 { [[Module]]: _module_, [[BindingName]]: _exportName_ }。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Link" type="concrete method">
            <h1>Link ( ): 正常完成（含 ~unused~）</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 令 _realm_ = _module_.[[Realm]]。
              1. 令 _env_ = NewModuleEnvironment(_realm_.[[GlobalEnv]])。
              1. 设 _module_.[[Environment]] = _env_。
              1. 对 _module_.[[ExportNames]] 每个 _exportName_：
                1. ! CreateMutableBinding + InitializeBinding(_exportName_, *undefined*)。
              1. 返回 NormalCompletion(~unused~)。
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Evaluate" type="concrete method">
            <h1>Evaluate ( ): Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. 创建执行上下文 _moduleContext_ 并关联环境。
              1. 暂停当前执行上下文并推入 _moduleContext_。
              1. 令 _steps_ = _module_.[[EvaluationSteps]]。
              1. 令 _result_ = Completion(_steps_(_module_))。
              1. 弹出 _moduleContext_ 并恢复。
              1. 令 _pc_ = ! NewPromiseCapability(%Promise%)。
              1. IfAbruptRejectPromise(_result_, _pc_)。
              1. 执行 ! Call(_pc_.[[Resolve]], *undefined*, « *undefined* »)。
              1. 返回 _pc_.[[Promise]]。
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetImportedModule" type="abstract operation">
        <h1>
          GetImportedModule (
            _referrer_: Cyclic Module Record,
            _request_: ModuleRequest Record,
          ): Module Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. [declared="r"] 令 _records_ 为 _referrer_.[[LoadedModules]] 中满足 ModuleRequestsEqual(_r_, _request_) 为 *true* 的 LoadedModuleRequest Record 列表。
          1. 断言：_records_ 恰有一个元素。
          1. 令 _record_ 为其唯一元素。
          1. 返回 _record_.[[Module]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation" oldids="sec-hostresolveimportedmodule,sec-hostimportmoduledynamically">
        <h1>
          HostLoadImportedModule (
            _referrer_: Script Record、Cyclic Module Record 或 Realm Record,
            _moduleRequest_: ModuleRequest Record,
            _hostDefined_: 任意,
            _payload_: GraphLoadingState Record 或 PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>在浏览器中，用户点击：</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>执行 `import()` 时可能没有活动脚本或模块（执行上下文栈顶 ScriptOrModule 为 *null*），因此 _referrer_ 可能是 Realm Record。</p>
        </emu-note>

        <p>HostLoadImportedModule 的实现需满足：</p>
        <ul>
          <li>
            必须（同步或异步）执行 FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_)，其中 _result_ 为正常完成（含 Module Record）或 throw completion。
          </li>
          <li>
            <p>若多次以相同 _referrer_ 且 ModuleRequestsEqual 为 *true* 的 _moduleRequest_ 调用，且第一次以正常完成 _result_ 调用 FinishLoadingImportedModule，则后续必须以同一 _result_ 调用。</p>
          </li>
          <li>
            <p>若 _moduleRequest_.[[Attributes]] 存在键 *"type"*、值 *"json"* 的条目，则调用 FinishLoadingImportedModule 时 _result_ 必须为 ParseJSONModule 返回的 Completion 或 throw completion。</p>
          </li>
          <li>
            必须将 _payload_ 视为不透明值原样传递给 FinishLoadingImportedModule。
          </li>
        </ul>

        <p>实际过程由宿主定义，通常包括执行所需 I/O 以加载 Module Record。不同 (_referrer_, 说明符, 属性) 组合可映射到同一模块实例，说明符标准化过程由宿主定义（如解析相对与简写路径）。</p>

        <emu-note>
          <p>上述要求宿主在 `type: "json"` 时支持 JSON 模块（且正常完成），但不禁止在缺省类型下支持 JSON。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" oldids="sec-finishdynamicimport">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: 一个 Script Record、Cyclic Module Record 或 Realm Record,
            _moduleRequest_: 一个 ModuleRequest Record,
            _payload_: 一个 GraphLoadingState Record 或 PromiseCapability Record,
            _result_: 正常完成（包含一个 Module Record）或 throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. 如果 _result_ 是正常完成，则
            1. 如果 _referrer_.[[LoadedModules]] 包含某个 LoadedModuleRequest Record _record_ 且 ModuleRequestsEqual(_record_, _moduleRequest_) 为 *true*，则
              1. 断言：_record_.[[Module]] 与 _result_.[[Value]] 是同一个 Module Record。
            1. 否则，
              1. 将 LoadedModuleRequest Record { [[Specifier]]: _moduleRequest_.[[Specifier]], [[Attributes]]: _moduleRequest_.[[Attributes]], [[Module]]: _result_.[[Value]] } 追加到 _referrer_.[[LoadedModules]]。
          1. 如果 _payload_ 是 GraphLoadingState Record，则
            1. 执行 ContinueModuleLoading(_payload_, _result_)。
          1. 否则，
            1. 执行 ContinueDynamicImport(_payload_, _result_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-AllImportAttributesSupported" type="abstract operation">
        <h1>
          AllImportAttributesSupported (
            _attributes_: ImportAttribute Records 的列表,
          ): Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. 令 _supported_ 为 HostGetSupportedImportAttributes()。
          1. 对 _attributes_ 的每个 ImportAttribute Record _attribute_：
            1. 如果 _supported_ 不包含 _attribute_.[[Key]]，返回 *false*。
          1. 返回 *true*。
        </emu-alg>

        <emu-clause id="sec-hostgetsupportedimportattributes" type="host-defined abstract operation">
          <h1>HostGetSupportedImportAttributes ( ): 字符串列表</h1>
          <dl class="header">
            <dt>description</dt>
            <dd>允许宿主环境指明其支持的 import 属性。只有具有受支持键的属性才会提供给宿主。</dd>
          </dl>

          <p>HostGetSupportedImportAttributes 的实现必须符合以下要求：</p>

          <ul>
            <li>必须返回一个字符串列表，每个字符串表示一个受支持的属性。</li>

            <li>每次调用都必须返回同一个包含相同内容且顺序相同的列表。</li>
          </ul>

          <p>默认实现返回一个新的空列表。</p>

          <emu-note>要求宿主声明支持的导入属性，而不是将全部属性传给宿主再筛选，旨在确保不同宿主对不支持属性的处理一致。</emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-getmodulenamespace" type="abstract operation">
        <h1>
          GetModuleNamespace (
            _module_: Module Record 具体子类的一个实例,
          ): Module Namespace Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>获取表示 _module_ 导出的 Module Namespace Object，第一次请求时惰性创建并存入 _module_.[[Namespace]] 以供后续复用。</dd>
        </dl>

        <emu-alg>
          1. 断言：若 _module_ 是 Cyclic Module Record，则 _module_.[[Status]] 不为 ~new~ 或 ~unlinked~。
          1. 令 _namespace_ 为 _module_.[[Namespace]]。
          1. 如果 _namespace_ 为 ~empty~，则
            1. 令 _exportedNames_ 为 _module_.GetExportedNames()。
            1. 令 _unambiguousNames_ 为新的空列表。
            1. 对 _exportedNames_ 的每个元素 _name_：
              1. 令 _resolution_ 为 _module_.ResolveExport(_name_)。
              1. 如果 _resolution_ 是 ResolvedBinding Record，将 _name_ 追加到 _unambiguousNames_。
            1. 设 _namespace_ 为 ModuleNamespaceCreate(_module_, _unambiguousNames_)。
          1. 返回 _namespace_。
        </emu-alg>
        <emu-note>
          <p>GetModuleNamespace 不会抛出异常。不可解析的名称此时直接排除；除非它们全是未被显式请求的歧义星号导出，否则稍后会导致真实的链接错误。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 返回 *undefined*。
        </emu-alg>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <emu-alg>
          1. 令 _result_ 为 Completion(Evaluation of |ModuleItemList|)。
          1. 如果 _result_ 是正常完成且 _result_.[[Value]] 为 ~empty~，则
            1. 返回 *undefined*。
          1. 返回 ? _result_。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. 令 _sl_ 为 ? Evaluation of |ModuleItemList|。
          1. 令 _s_ 为 Completion(Evaluation of |ModuleItem|)。
          1. 返回 ? UpdateEmpty(_s_, _sl_)。
        </emu-alg>
        <emu-note>
          <p>|ModuleItemList| 的值是其中最后一个产生值的条目的值。</p>
        </emu-note>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. 返回 ~empty~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>导入 (Imports)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause WithClause? `;`
          `import` ModuleSpecifier WithClause? `;`

        ImportClause :
          ImportedDefaultBinding
          NameSpaceImport
          NamedImports
          ImportedDefaultBinding `,` NameSpaceImport
          ImportedDefaultBinding `,` NamedImports

        ImportedDefaultBinding :
          ImportedBinding

        NameSpaceImport :
          `*` `as` ImportedBinding

        NamedImports :
          `{` `}`
          `{` ImportsList `}`
          `{` ImportsList `,` `}`

        FromClause :
          `from` ModuleSpecifier

        ImportsList :
          ImportSpecifier
          ImportsList `,` ImportSpecifier

        ImportSpecifier :
          ImportedBinding
          ModuleExportName `as` ImportedBinding

        ModuleSpecifier :
          StringLiteral

        ImportedBinding :
          BindingIdentifier[~Yield, +Await]

        WithClause :
          `with` `{` `}`
          `with` `{` WithEntries `,`? `}`

        WithEntries :
          AttributeKey `:` StringLiteral
          AttributeKey `:` StringLiteral `,` WithEntries

        AttributeKey :
          IdentifierName
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <ul>
          <li>
            若 |ImportDeclaration| 的 BoundNames 含有任意重复条目，则为语法错误。
          </li>
        </ul>

        <emu-grammar>WithClause : `with` `{` WithEntries `,`? `}`</emu-grammar>
        <ul>
          <li>
            若 |WithClause| 的 WithClauseToAttributes 具有两个不同条目 _a_ 与 _b_ 且 _a_.[[Key]] 为 _b_.[[Key]]，则为语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="sdo">
        <h1>静态语义：ImportEntries ( ): ImportEntry Record 列表</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. 令 _entries1_ 为 |ModuleItemList| 的 ImportEntries。
          1. 令 _entries2_ 为 |ModuleItem| 的 ImportEntries。
          1. 返回 _entries1_ 与 _entries2_ 的列表连接。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ExportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 令 _module_ 为 |ImportDeclaration| 的 ModuleRequests 的唯一元素。
          1. 返回 |ImportClause| 的 ImportEntriesForModule，参数 _module_。
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo">
        <h1>
          静态语义：ImportEntriesForModule (
            _module_: ModuleRequest Record,
          ): ImportEntry Record 列表
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. 令 _entries1_ 为 |ImportedDefaultBinding| 的 ImportEntriesForModule，参数 _module_。
          1. 令 _entries2_ 为 |NameSpaceImport| 的 ImportEntriesForModule，参数 _module_。
          1. 返回 _entries1_ 与 _entries2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. 令 _entries1_ 为 |ImportedDefaultBinding| 的 ImportEntriesForModule，参数 _module_。
          1. 令 _entries2_ 为 |NamedImports| 的 ImportEntriesForModule，参数 _module_。
          1. 返回 _entries1_ 与 _entries2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
        <emu-alg>
          1. 令 _localName_ 为 |ImportedBinding| 的 BoundNames 的唯一元素。
          1. 令 _defaultEntry_ 为 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *"default"*, [[LocalName]]: _localName_ }。
          1. 返回 « _defaultEntry_ »。
        </emu-alg>
        <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. 令 _localName_ 为 |ImportedBinding| 的 StringValue。
          1. 令 _entry_ 为 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ }。
          1. 返回 « _entry_ »。
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. 令 _specs1_ 为 |ImportsList| 的 ImportEntriesForModule，参数 _module_。
          1. 令 _specs2_ 为 |ImportSpecifier| 的 ImportEntriesForModule，参数 _module_。
          1. 返回 _specs1_ 与 _specs2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
        <emu-alg>
          1. 令 _localName_ 为 |ImportedBinding| 的 BoundNames 的唯一元素。
          1. 令 _entry_ 为 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }。
          1. 返回 « _entry_ »。
        </emu-alg>
        <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. 令 _importName_ 为 |ModuleExportName| 的 StringValue。
          1. 令 _localName_ 为 |ImportedBinding| 的 StringValue。
          1. 令 _entry_ 为 ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }。
          1. 返回 « _entry_ »。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-withclausetoattributes" type="sdo">
        <h1>静态语义：WithClauseToAttributes ( ): ImportAttribute Record 列表</h1>
        <dl class="header">
        </dl>

        <emu-grammar>
          WithClause : `with` `{` `}`
        </emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>

        <emu-grammar>
          WithClause : `with` `{` WithEntries `,`? `}`
        </emu-grammar>
        <emu-alg>
          1. 令 _attributes_ 为 |WithEntries| 的 WithClauseToAttributes。
          1. 按其 [[Key]] 字段的字典序（视各字段值为 UTF-16 代码单元序列）对 _attributes_ 排序。注：该排序的可观察性仅体现在宿主被禁止基于枚举顺序改变行为。
          1. 返回 _attributes_。
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral</emu-grammar>
        <emu-alg>
          1. 令 _key_ 为 |AttributeKey| 的 PropName。
          1. 令 _entry_ 为 ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| 的 SV }。
          1. 返回 « _entry_ »。
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral `,` WithEntries</emu-grammar>
        <emu-alg>
          1. 令 _key_ 为 |AttributeKey| 的 PropName。
          1. 令 _entry_ 为 ImportAttribute Record { [[Key]]: _key_, [[Value]]: |StringLiteral| 的 SV }。
          1. 令 _rest_ 为 |WithEntries| 的 WithClauseToAttributes。
          1. 返回 « _entry_ » 与 _rest_ 的列表连接。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>导出 (Exports)</h1>
      <h2>语法 (Syntax)</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          `*` `as` ModuleExportName
          NamedExports

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>静态语义：早期错误 (Static Semantics: Early Errors)</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            若 |NamedExports| 的 ReferencedBindings 包含任意 |StringLiteral|，则为语法错误。
          </li>
          <li>
            对于 |NamedExports| 的 ReferencedBindings 中每个 |IdentifierName| _n_：若 _n_ 的 StringValue 是 |ReservedWord|，或其值是 *"implements"*、*"interface"*、*"let"*、*"package"*、*"private"*、*"protected"*、*"public"*、*"static"* 之一，则为语法错误。
          </li>
        </ul>
        <emu-note>
          <p>上述规则意味着 |NamedExports| 的每个 ReferencedBindings 被视作一个 |IdentifierReference|。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportedbindings" oldids="sec-module-semantics-static-semantics-exportedbindings,sec-exports-static-semantics-exportedbindings" type="sdo">
        <h1>静态语义：ExportedBindings ( ): 字符串列表</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedBindings 是一个 |Module| 的 ExportedNames 显式映射到的本地绑定名称集合。</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. 令 _names1_ 为 |ModuleItemList| 的 ExportedBindings。
          1. 令 _names2_ 为 |ModuleItem| 的 ExportedBindings。
          1. 返回 _names1_ 与 _names2_ 的列表连接。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. 返回 |NamedExports| 的 ExportedBindings。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. 返回 |VariableStatement| 的 BoundNames。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. 返回 |Declaration| 的 BoundNames。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 返回此 |ExportDeclaration| 的 BoundNames。
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. 令 _names1_ 为 |ExportsList| 的 ExportedBindings。
          1. 令 _names2_ 为 |ExportSpecifier| 的 ExportedBindings。
          1. 返回 _names1_ 与 _names2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. 返回仅含 |ModuleExportName| 的 StringValue 的列表。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 返回仅含第一个 |ModuleExportName| 的 StringValue 的列表。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" oldids="sec-module-semantics-static-semantics-exportednames,sec-exports-static-semantics-exportednames" type="sdo">
        <h1>静态语义：ExportedNames ( ): 字符串列表</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames 是 |Module| 显式映射到其本地绑定的对外可见名称集合。</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. 令 _names1_ 为 |ModuleItemList| 的 ExportedNames。
          1. 令 _names2_ 为 |ModuleItem| 的 ExportedNames。
          1. 返回 _names1_ 与 _names2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. 返回 |ExportDeclaration| 的 ExportedNames。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 返回 |ExportFromClause| 的 ExportedNames。
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 返回仅含 |ModuleExportName| 的 StringValue 的列表。
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. 返回 |NamedExports| 的 ExportedNames。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. 返回 |VariableStatement| 的 BoundNames。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. 返回 |Declaration| 的 BoundNames。
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. 返回 « *"default"* »。
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. 令 _names1_ 为 |ExportsList| 的 ExportedNames。
          1. 令 _names2_ 为 |ExportSpecifier| 的 ExportedNames。
          1. 返回 _names1_ 与 _names2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. 返回仅含 |ModuleExportName| 的 StringValue 的列表。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 返回仅含第二个 |ModuleExportName| 的 StringValue 的列表。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" oldids="sec-module-semantics-static-semantics-exportentries,sec-exports-static-semantics-exportentries" type="sdo">
        <h1>静态语义：ExportEntries ( ): ExportEntry Record 列表</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. 令 _entries1_ 为 |ModuleItemList| 的 ExportEntries。
          1. 令 _entries2_ 为 |ModuleItem| 的 ExportEntries。
          1. 返回 _entries1_ 与 _entries2_ 的列表连接。
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. 令 _module_ 为 |ExportDeclaration| 的 ModuleRequests 的唯一元素。
          1. 返回 |ExportFromClause| 的 ExportEntriesForModule，参数 _module_。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. 返回 |NamedExports| 的 ExportEntriesForModule，参数 *null*。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. 令 _entries_ 为新的空列表。
          1. 令 _names_ 为 |VariableStatement| 的 BoundNames。
          1. 对 _names_ 中每个 _name_：
            1. 将 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } 追加至 _entries_。
          1. 返回 _entries_。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. 令 _entries_ 为新的空列表。
          1. 令 _names_ 为 |Declaration| 的 BoundNames。
          1. 对 _names_ 中每个 _name_：
            1. 将 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } 追加至 _entries_。
          1. 返回 _entries_。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. 令 _names_ 为 |HoistableDeclaration| 的 BoundNames。
          1. 令 _localName_ 为 _names_ 的唯一元素。
          1. 返回唯一元素为新 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } 的列表。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. 令 _names_ 为 |ClassDeclaration| 的 BoundNames。
          1. 令 _localName_ 为 _names_ 的唯一元素。
          1. 返回唯一元素为新 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* } 的列表。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. 令 _entry_ 为 ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* }。
          1. 返回 « _entry_ »。
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* 在本规范中用作匿名默认导出值的合成名称。详见 <emu-xref href="#note-star-default-star">该注释</emu-xref>。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentriesformodule" type="sdo">
        <h1>
          静态语义：ExportEntriesForModule (
            _module_: ModuleRequest Record 或 *null*,
          ): ExportEntry Record 列表
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. 令 _entry_ 为 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* }。
          1. 返回 « _entry_ »。
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 令 _exportName_ 为 |ModuleExportName| 的 StringValue。
          1. 令 _entry_ 为 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ }。
          1. 返回 « _entry_ »。
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. 令 _specs1_ 为 |ExportsList| 的 ExportEntriesForModule，参数 _module_。
          1. 令 _specs2_ 为 |ExportSpecifier| 的 ExportEntriesForModule，参数 _module_。
          1. 返回 _specs1_ 与 _specs2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. 令 _sourceName_ 为 |ModuleExportName| 的 StringValue。
          1. 若 _module_ 为 *null*，则
            1. 令 _localName_ 为 _sourceName_。
            1. 令 _importName_ 为 *null*。
          1. 否则，
            1. 令 _localName_ 为 *null*。
            1. 令 _importName_ 为 _sourceName_。
          1. 返回仅含新 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ } 的列表。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 令 _sourceName_ 为第一个 |ModuleExportName| 的 StringValue。
          1. 令 _exportName_ 为第二个 |ModuleExportName| 的 StringValue。
          1. 若 _module_ 为 *null*，则
            1. 令 _localName_ 为 _sourceName_。
            1. 令 _importName_ 为 *null*。
          1. 否则，
            1. 令 _localName_ 为 *null*。
            1. 令 _importName_ 为 _sourceName_。
          1. 返回仅含新 ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ } 的列表。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-referencedbindings" type="sdo">
        <h1>静态语义：ReferencedBindings ( ): 解析节点列表</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. 返回新的空列表。
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. 令 _names1_ 为 |ExportsList| 的 ReferencedBindings。
          1. 令 _names2_ 为 |ExportSpecifier| 的 ReferencedBindings。
          1. 返回 _names1_ 与 _names2_ 的列表连接。
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. 返回第一个 |ModuleExportName| 的 ReferencedBindings。
        </emu-alg>
        <emu-grammar>ModuleExportName : IdentifierName</emu-grammar>
        <emu-alg>
          1. 返回仅含该 |IdentifierName| 的列表。
        </emu-alg>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <emu-alg>
          1. 返回仅含该 |StringLiteral| 的列表。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo">
        <h1>运行时语义：求值 (Runtime Semantics: Evaluation)</h1>
        <emu-grammar>
          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
        </emu-grammar>
        <emu-alg>
          1. 返回 ~empty~。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. 返回 ? 对 |VariableStatement| 的 Evaluation。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. 返回 ? 对 |Declaration| 的 Evaluation。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. 返回 ? 对 |HoistableDeclaration| 的 Evaluation。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. 令 _value_ 为 ? 对 |ClassDeclaration| 的 BindingClassDeclarationEvaluation。
          1. 令 _className_ 为 |ClassDeclaration| 的 BoundNames 的唯一元素。
          1. 若 _className_ 为 *"\*default\*"*，则
            1. 令 _env_ 为正在运行的执行上下文的 LexicalEnvironment。
            1. 执行 ? InitializeBoundName(*"\*default\*"*, _value_, _env_)。
          1. 返回 ~empty~。
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. 若 IsAnonymousFunctionDefinition(|AssignmentExpression|) 为 *true*，则
            1. 令 _value_ 为 ? NamedEvaluation(|AssignmentExpression|, *"default"*)。
          1. 否则，
            1. 令 _rhs_ 为 ? Evaluation(|AssignmentExpression|)。
            1. 令 _value_ 为 ? GetValue(_rhs_)。
          1. 令 _env_ 为正在运行的执行上下文的 LexicalEnvironment。
          1. 执行 ? InitializeBoundName(*"\*default\*"*, _value_, _env_)。
          1. 返回 ~empty~。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-error-handling-and-language-extensions">
  <h1>错误处理与语言扩展 (Error Handling and Language Extensions)</h1>
  <p>实现必须在相关 ECMAScript 语言结构被求值时报告大多数错误。<dfn id="early-error" variants="early errors">early error（早期错误）</dfn> 是指可在包含该错误的 |Script| 的任意结构被求值之前就能检测并报告的错误。存在早期错误会阻止该结构的求值。实现必须在 ParseScript 解析 |Script| 时，将其中的早期错误作为解析的一部分报告。|Module| 中的早期错误在该 |Module| 将被求值的时刻报告，并且该 |Module| 永远不会被初始化。<b>eval</b> 代码中的早期错误在调用 `eval` 时报告，并阻止 <b>eval</b> 代码的求值。所有不是早期错误的错误都是运行时错误。</p>
  <p>实现必须将本规范各 “Static Semantics: Early Errors” 子小节中列出的条件的任何出现作为早期错误报告。</p>
  <p>实现不得将其他类型的错误视为早期错误，即使编译器可以证明某个结构在任何情况下都无法无错执行。此类情形下实现可以发出早期警告，但不应在相关结构真正执行之前报告该错误。</p>
  <p>实现应按规范报告所有错误，但以下情况除外：</p>
  <ul>
    <li>
      除 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 的限制外，宿主或实现可以扩展 |Script| 语法、|Module| 语法，以及正则表达式模式或标志语法。为允许这一点，所有允许抛出 *SyntaxError* 的操作（例如调用 `eval`、使用正则字面量，或使用 Function 或 RegExp 构造器）在遇到宿主定义的脚本语法或正则模式/标志语法扩展时，允许表现为宿主定义行为而不是抛出 *SyntaxError*。
    </li>
    <li>
      除 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 的限制外，宿主或实现可以提供规范未描述的额外类型、值、对象、属性和函数。这可能导致某些结构（如在全局作用域查找变量）表现为宿主定义行为，而不是抛出（例如 *ReferenceError*）错误。
    </li>
  </ul>

  <emu-clause id="sec-forbidden-extensions">
    <h1>禁止的扩展 (Forbidden Extensions)</h1>
    <p>实现不得以下述方式扩展本规范：</p>
    <ul>
      <li>
        严格模式代码中用语法构造器定义的 ECMAScript 函数对象不得被创建为拥有名为 *"caller"* 或 *"arguments"* 的自身属性。对于使用 |ArrowFunction|、|MethodDefinition|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|ClassDeclaration|、|ClassExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression| 或 |AsyncArrowFunction| 定义的函数对象，无论其定义是否位于严格模式代码中，也不得创建此类自身属性。内建函数、使用 Function 构造器创建的严格函数、使用 Generator 构造器创建的生成器函数、使用 AsyncFunction 构造器创建的异步函数以及通过 `bind` 方法创建的函数亦不得具有这些自身属性。
      </li>
      <li>
        若实现为任意函数对象扩展了名为 *"caller"* 的自身属性，则通过 [[Get]] 或 [[GetOwnProperty]] 观察到的该属性的值不得是严格函数对象。若它是访问器属性，其 [[Get]] 属性值的函数在被调用时绝不能返回严格函数。
      </li>
      <li>
        映射或非映射的 arguments 对象都不得以名为 *"caller"* 的自身属性被创建。
      </li>
      <li>
        在 ECMA-402 中指定的内建方法（如名为 `toLocaleString` 的那些）之行为，除 ECMA-402 规定外，不得被扩展。
      </li>
      <li>
        <emu-xref href="#sec-patterns"></emu-xref> 与 <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> 中的 RegExp 模式语法不得被扩展，以致在存在 <sub>[UnicodeMode]</sub> 语法参数时将任一 A-Z 或 a-z 源字符识别为 |IdentityEscape[+UnicodeMode]|。
      </li>
      <li>
        语法文法不得以任何方式扩展，使得记号 `:` 可以紧随由 |BindingIdentifier| 非终结符匹配的源码文本之后。
      </li>
      <li>
        处理严格模式代码时，实现不得放宽 <emu-xref href="#sec-numeric-literals-early-errors"></emu-xref> 的早期错误规则。
      </li>
      <li>
        |TemplateEscapeSequence| 不得被扩展以包含 <emu-xref href="#sec-literals-string-literals"></emu-xref> 中定义的 |LegacyOctalEscapeSequence| 或 |NonOctalDecimalEscapeSequence|。
      </li>
      <li>
        处理严格模式代码时，不得支持 <emu-xref href="#sec-labelled-function-declarations"></emu-xref>、<emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>、<emu-xref href="#sec-functiondeclarations-in-ifstatement-statement-clauses"></emu-xref> 与 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 中定义的扩展。
      </li>
      <li>
        以 |Module| 为目标符号进行解析时，不得支持 <emu-xref href="#sec-html-like-comments"></emu-xref> 中定义的词法文法扩展。
      </li>
      <!-- 未来可能添加新的参数或支持 ArgumentList。 -->
      <li>
        |ImportCall| 不得被扩展。
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-standard-built-in-objects">
  <h1>ECMAScript 标准内建对象 (ECMAScript Standard Built-in Objects)</h1>
  <p>当任意 ECMAScript |Script| 或 |Module| 开始执行时，有若干内建对象可用。其中，全局对象是正在执行程序的全局环境的一部分。其他对象作为全局对象的初始属性或作为已可访问内建对象的属性间接访问。</p>
  <p>除非另有说明，可作为函数调用的内建对象是具有 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 所述特性的内建函数对象。除非另有说明，内建对象的 [[Extensible]] 内部槽初始值为 *true*。每个内建函数对象都有 [[Realm]] 内部槽，其值为创建该对象时所属领域的 Realm Record。</p>
  <p>许多内建对象是函数：它们可带参数调用。其中一些还是构造器：它们旨在与 `new` 运算符一起使用。对于每个内建函数，本规范描述该函数所需的参数及函数对象的属性。对于每个内建构造器，本规范还描述该构造器原型对象的属性以及由调用该构造器的 `new` 表达式返回的特定对象实例的属性。</p>
  <p>除非在特定函数的描述中另有说明，如果给内建函数或构造器的实参少于其规范要求的数量，则该函数或构造器的行为与补足缺失的参数（每个缺失参数为 *undefined*）完全一致。此类缺失参数被视为 “not present”，规范算法可据此识别。在特定函数的描述中，“*this* value” 与 “NewTarget” 术语具有 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 中给出的含义。</p>
  <p>除非在特定函数的描述中另有说明，如果调用所描述的内建函数或构造器时提供的参数多于其允许的数量，多余的参数会被求值但随后被函数忽略。但是，实现可针对这些参数定义实现特定行为，只要该行为不只是因为存在额外参数而抛出 *TypeError* 异常。</p>
  <emu-note>
    <p>为向内建函数集合添加额外能力的实现，鼓励通过添加新函数而非为现有函数增加新参数来实现。</p>
  </emu-note>
  <p>除非另有说明，每个内建函数与每个内建构造器的 [[Prototype]] 内部槽值为 Function 原型对象，即表达式 `Function.prototype`（<emu-xref href="#sec-properties-of-the-function-prototype-object"></emu-xref>）的初始值。</p>
  <p>除非另有说明，每个内建原型对象（除 Object 原型对象本身外）的 [[Prototype]] 内部槽值为 Object 原型对象，即表达式 `Object.prototype`（<emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>）的初始值。</p>
  <p>若本规范通过算法步骤定义了某内建构造器的行为，则该行为同时适用于 [[Call]] 与 [[Construct]]。若该算法需要区分两种情形，它通过检测 NewTarget 是否为 *undefined*（表示 [[Call]] 调用）来实现。</p>
  <p>未标识为构造器的内建函数对象除非另有说明，否则不实现 [[Construct]] 内部方法。</p>
  <p>未作为构造器的内建函数对象除非另有说明，否则没有 *"prototype"* 属性。</p>
  <p>本规范中定义的每个内建函数（包括构造器）均通过调用 CreateBuiltinFunction 抽象操作（<emu-xref href="#sec-createbuiltinfunction"></emu-xref>）创建。参数 _length_ 与 _name_ 的值作为 *"length"* 与 *"name"* 属性的初始值（如下文所述）。_prefix_ 参数的值同样如下文所述。</p>
  <p>每个内建函数对象（包括构造器）都有 *"length"* 属性，其值为非负整数 Number。除非另有说明，该值为函数描述小节标题中列出的必需参数数量。可选参数与剩余参数不计入参数数目。</p>
  <emu-note>
    <p>例如，Array 原型对象 *"map"* 属性初始值的函数对象，其标题 «Array.prototype.map (callback [ , thisArg])» 展示两个命名参数 callback 与 thisArg（后者可选）；因此该函数对象的 *"length"* 属性值是 *1*<sub>𝔽</sub>。</p>
  </emu-note>
  <p>除非另有说明，内建函数对象的 *"length"* 属性具有属性特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
  <p>每个内建函数对象（包括构造器）都有 *"name"* 属性，其值为 String。除非另有说明，该值为本规范赋予该函数的名称。标识为匿名函数的使用空字符串作为 *"name"* 属性值。若函数作为对象的属性指定，其名称值为用于访问该函数的属性名字符串。作为内建属性的 getter 或 setter 访问器函数指定的函数，在调用 CreateBuiltinFunction 时分别将 *"get"* 或 *"set"* 传给 _prefix_ 参数。</p>
  <p>对属性键为 Symbol 值的每个内建函数，其 *"name"* 属性值在规范中被明确指定。若该值以 *"get "* 或 *"set "* 前缀开头且函数是某内建属性的 get 或 set 访问器，则去掉前缀的值传给 _name_ 参数，而 *"get"* 或 *"set"*（分别）传给 _prefix_ 参数。</p>
  <p>除非另有说明，内建函数对象的 *"name"* 属性具有属性特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> 至 <emu-xref href="#sec-reflection"></emu-xref> 各小节以及附录 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> 中描述的所有其他数据属性，除非另有说明，具有属性特性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
  <p><emu-xref href="#sec-global-object"></emu-xref> 至 <emu-xref href="#sec-reflection"></emu-xref> 各小节以及附录 <emu-xref href="#sec-additional-built-in-properties"></emu-xref> 中描述的所有访问器属性，除非另有说明，具有属性特性 { [[Enumerable]]: *false*, [[Configurable]]: *true* }。若仅描述了 get 访问器函数，则 set 访问器函数为默认值 *undefined*。若仅描述了 set 访问器函数，则 get 访问器为默认值 *undefined*。</p>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>全局对象 (The Global Object)</h1>
  <p><dfn variants="global objects">global object（全局对象）</dfn>：</p>
  <ul>
    <li>在进入任意执行上下文之前创建。</li>
    <li>没有 [[Construct]] 内部方法；不能被 `new` 作为构造器使用。</li>
    <li>没有 [[Call]] 内部方法；不能作为函数调用。</li>
    <li>具有宿主定义值的 [[Prototype]] 内部槽。</li>
    <li>除规范定义的属性外，可以有宿主定义属性。这可以包括值为全局对象自身的属性。</li>
  </ul>

  <emu-clause id="sec-value-properties-of-the-global-object">
    <h1>全局对象的值属性 (Value Properties of the Global Object)</h1>

    <emu-clause id="sec-globalthis">
      <h1>globalThis</h1>
      <p>Realm Record _realm_ 中全局对象 *"globalThis"* 属性的初始值为 _realm_.[[GlobalEnv]].[[GlobalThisValue]]。</p>
      <p>该属性具有特性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-infinity">
      <h1>Infinity</h1>
      <p>`Infinity` 的值为 *+∞*<sub>𝔽</sub>（见 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>）。该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-nan">
      <h1>NaN</h1>
      <p>`NaN` 的值为 *NaN*（见 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>）。该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
    </emu-clause>

    <emu-clause id="sec-undefined">
      <h1>undefined</h1>
      <p>`undefined` 的值为 *undefined*（见 <emu-xref href="#sec-ecmascript-language-types-undefined-type"></emu-xref>）。该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>全局对象的函数属性 (Function Properties of the Global Object)</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <p>此函数是 <dfn>%eval%</dfn> 本源对象。</p>
      <p>调用时执行以下步骤：</p>
      <emu-alg>
        1. 返回 ? PerformEval(_x_, *false*, *false*)。
      </emu-alg>

      <emu-clause id="sec-performeval" type="abstract operation" oldids="sec-performeval-rules-outside-functions,sec-performeval-rules-outside-methods,sec-performeval-rules-outside-constructors">
        <h1>
          PerformEval (
            _x_: 一个 ECMAScript 语言值,
            _strictCaller_: Boolean,
            _direct_: Boolean,
          ): 正常完成（含 ECMAScript 语言值）或 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：若 _direct_ 为 *false*，则 _strictCaller_ 也为 *false*。
          1. 若 _x_ 不是 String，返回 _x_。
          1. 令 _evalRealm_ 为当前 Realm Record。
          1. 注：直接 eval 情况下，_evalRealm_ 同时是调用 `eval` 的调用者与 `eval` 函数自身的 realm。
          1. 执行 ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_)。
          1. 令 _inFunction_ 为 *false*。
          1. 令 _inMethod_ 为 *false*。
          1. 令 _inDerivedConstructor_ 为 *false*。
          1. 令 _inClassFieldInitializer_ 为 *false*。
          1. 若 _direct_ 为 *true*，则
            1. 令 _thisEnvRec_ = GetThisEnvironment()。
            1. 若 _thisEnvRec_ 是 Function Environment Record，则
              1. 令 _F_ = _thisEnvRec_.[[FunctionObject]]。
              1. 设 _inFunction_ 为 *true*。
              1. 设 _inMethod_ 为 _thisEnvRec_.HasSuperBinding()。
              1. 若 _F_.[[ConstructorKind]] 为 ~derived~，设 _inDerivedConstructor_ 为 *true*。
              1. 令 _classFieldInitializerName_ 为 _F_.[[ClassFieldInitializerName]]。
              1. 若 _classFieldInitializerName_ 非 ~empty~，设 _inClassFieldInitializer_ 为 *true*。
          1. 按实现定义顺序执行以下子步骤，可交织解析与错误检测：
            1. 令 _script_ 为 ParseText(_x_, |Script|)。
            1. 若 _script_ 为错误列表，抛出 *SyntaxError*。
            1. 若 _script_ Contains |ScriptBody| 为 *false*，返回 *undefined*。
            1. 令 _body_ 为 _script_ 的 |ScriptBody|。
            1. 若 _inFunction_ 为 *false* 且 _body_ Contains |NewTarget|，抛出 *SyntaxError*。
            1. 若 _inMethod_ 为 *false* 且 _body_ Contains |SuperProperty|，抛出 *SyntaxError*。
            1. 若 _inDerivedConstructor_ 为 *false* 且 _body_ Contains |SuperCall|，抛出 *SyntaxError*。
            1. 若 _inClassFieldInitializer_ 为 *true* 且 ContainsArguments(_body_) 为 *true*，抛出 *SyntaxError*。
          1. 若 _strictCaller_ 为 *true*，令 _strictEval_ 为 *true*。
          1. 否则，令 _strictEval_ 为 ScriptIsStrict(_script_)。
          1. 令 _runningContext_ 为正在运行的执行上下文。
          1. 注：若 _direct_ 为 *true*，_runningContext_ 是执行直接 eval 的上下文；否则为 `eval` 调用的执行上下文。
          1. 若 _direct_ 为 *true*，则
            1. 令 _lexEnv_ = NewDeclarativeEnvironment(_runningContext_.LexicalEnvironment)。
            1. 令 _varEnv_ = _runningContext_.VariableEnvironment。
            1. 令 _privateEnv_ = _runningContext_.PrivateEnvironment。
          1. 否则，
            1. 令 _lexEnv_ = NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]])。
            1. 令 _varEnv_ = _evalRealm_.[[GlobalEnv]]。
            1. 令 _privateEnv_ = *null*。
          1. 若 _strictEval_ 为 *true*，设 _varEnv_ = _lexEnv_。
          1. 若 _runningContext_ 尚未被暂停，则暂停之。
          1. 令 _evalContext_ 为新的 ECMAScript 代码执行上下文。
          1. 设其 Function 为 *null*。
          1. 设其 Realm 为 _evalRealm_。
          1. 设其 ScriptOrModule 为 _runningContext_.ScriptOrModule。
          1. 设其 VariableEnvironment 为 _varEnv_。
          1. 设其 LexicalEnvironment 为 _lexEnv_。
          1. 设其 PrivateEnvironment 为 _privateEnv_。
          1. 压入 _evalContext_；其成为正在运行的执行上下文。
          1. 令 _result_ = Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_))。
          1. 若 _result_ 为正常完成，则
            1. 设 _result_ = Completion(Evaluation of _body_)。
          1. 若 _result_ 为正常完成且 _result_.[[Value]] 为 ~empty~，则
            1. 设 _result_ = NormalCompletion(*undefined*)。
          1. 暂停 _evalContext_ 并将其移出执行上下文栈。
          1. 恢复当前栈顶上下文。
          1. 返回 ? _result_。
        </emu-alg>
        <emu-note>
          <p>若调用者代码或 eval 代码为严格模式代码，eval 代码不得在调用上下文的变量环境中实例化变量或函数绑定；此时这些绑定在新建的 VariableEnvironment 中实例化，仅对 eval 代码可见。由 `let`、`const`、`class` 声明引入的绑定总是在新 LexicalEnvironment 中实例化。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostensurecancompilestrings" type="host-defined abstract operation">
        <h1>
          HostEnsureCanCompileStrings (
            _calleeRealm_: Realm Record,
            _parameterStrings_: 字符串列表,
            _bodyString_: 字符串,
            _direct_: Boolean,
          ): 正常完成（含 ~unused~）或 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>允许宿主环境阻止某些可让开发者将字符串解释并求值为 ECMAScript 代码的 ECMAScript 函数。</dd>
        </dl>
        <p>
          _parameterStrings_ 表示使用函数构造器时会被连接以构造参数列表的字符串。_bodyString_ 表示函数体或传递给 `eval` 的字符串。
          _direct_ 表示是否为直接 eval。
        </p>
        <p>默认实现返回 NormalCompletion(~unused~)。</p>
      </emu-clause>

      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-evaldeclarationinstantiation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: |ScriptBody| 解析节点,
            _varEnv_: Environment Record,
            _lexEnv_: Declarative Environment Record,
            _privateEnv_: PrivateEnvironment Record 或 *null*,
            _strict_: Boolean,
          ): 正常完成（含 ~unused~）或 throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _varNames_ 为 _body_ 的 VarDeclaredNames。
          1. 令 _varDeclarations_ 为 _body_ 的 VarScopedDeclarations。
          1. 若 _strict_ 为 *false*，则
            1. 若 _varEnv_ 是 Global Environment Record，则
              1. 对 _varNames_ 每个 _name_：
                1. 若 HasLexicalDeclaration(_varEnv_, _name_) 为 *true*，抛 *SyntaxError*。
                1. 注：`eval` 不会创建会被全局词法声明遮蔽的全局 var 声明。
            1. 令 _thisEnv_ = _lexEnv_。
            1. 断言：以下循环会终止。
            1. 重复，条件：_thisEnv_ 且 _thisEnv_ 与 _varEnv_ 不同：
              1. 若 _thisEnv_ 不是 Object Environment Record，则
                1. 注：with 语句环境不含词法声明，因此不需检查 var/let 提升冲突。
                1. 对 _varNames_ 每个 _name_：
                  1. 若 ! _thisEnv_.HasBinding(_name_) 为 *true*，则
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding", normative-optional] 若宿主为浏览器或支持 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref>：
                      1. 若 _thisEnv_ 不是 |Catch| 子句的 Environment Record，抛 *SyntaxError*。
                    1. 否则，抛 *SyntaxError*。
                  1. 注：直接 eval 不会将 var 声明提升越过同名词法声明。
              1. 设 _thisEnv_ 为 _thisEnv_.[[OuterEnv]]。
          1. 令 _privateIdentifiers_ 为新空列表。
          1. 令 _pointer_ = _privateEnv_。
          1. 重复，条件：_pointer_ 非 *null*：
            1. 对 _pointer_.[[Names]] 每个 Private Name _binding_：
              1. 若 _privateIdentifiers_ 不含 _binding_.[[Description]]，追加之。
            1. 设 _pointer_ = _pointer_.[[OuterPrivateEnvironment]]。
          1. 若 AllPrivateIdentifiersValid(_body_, _privateIdentifiers_) 为 *false*，抛 *SyntaxError*。
          1. 令 _functionsToInitialize_ 为新空列表。
          1. 令 _declaredFunctionNames_ 为新空列表。
          1. 逆序遍历 _varDeclarations_ 中每个 _d_：
            1. 若 _d_ 不是 |VariableDeclaration|、|ForBinding| 或 |BindingIdentifier|，则
              1. 断言：_d_ 为 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration| 或 |AsyncGeneratorDeclaration|。
              1. 注：若同名多次函数声明，最后一个生效。
              1. 令 _fn_ 为其 BoundNames 唯一元素。
              1. 若 _declaredFunctionNames_ 不含 _fn_，则
                1. 若 _varEnv_ 是 Global Environment Record，则
                  1. 令 _fnDefinable_ = ? CanDeclareGlobalFunction(_varEnv_, _fn_)。
                  1. 若 _fnDefinable_ 为 *false*，抛 *TypeError*。
                1. 追加 _fn_ 至 _declaredFunctionNames_。
                1. 将 _d_ 插入 _functionsToInitialize_ 首位。
          1. 令 _declaredVarNames_ 为新空列表。
          1. 遍历 _varDeclarations_ 中每个 _d_：
            1. 若 _d_ 是 |VariableDeclaration|、|ForBinding| 或 |BindingIdentifier|，则
              1. 对其 BoundNames 每个字符串 _vn_：
                1. 若 _declaredFunctionNames_ 不含 _vn_，则
                  1. 若 _varEnv_ 是 Global Environment Record，则
                    1. 令 _vnDefinable_ = ? CanDeclareGlobalVar(_varEnv_, _vn_)。
                    1. 若 _vnDefinable_ 为 *false*，抛 *TypeError*。
                  1. 若 _declaredVarNames_ 不含 _vn_，则追加之。
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point", normative-optional] 若 _strict_ 为 *false* 且宿主为浏览器或支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>，则
            1. 令 _declaredFunctionOrVarNames_ 为 _declaredFunctionNames_ 与 _declaredVarNames_ 的连接。
            1. 对每个直接包含于任何 |Block|、|CaseClause| 或 |DefaultClause| 的 |StatementList| 中、且使 _body_ Contains 该子节点为 *true* 的 |FunctionDeclaration| _f_：
              1. 令 _F_ 为其 |BindingIdentifier| 的 StringValue。
              1. 若将 _f_ 替换为以 _F_ 为 |BindingIdentifier| 的 |VariableStatement| 不会为 _body_ 产生早期错误，则
                1. 令 _bindingExists_ 为 *false*。
                1. 设 _thisEnv_ = _lexEnv_。
                1. 断言：以下循环终止。
                1. 重复，条件：_thisEnv_ ≠ _varEnv_：
                  1. 若 _thisEnv_ 不是 Object Environment Record，则
                    1. 若 ! _thisEnv_.HasBinding(_F_) 为 *true*，则
                      1. [id="step-evaldeclarationinstantiation-web-compat-bindingexists", normative-optional] 若宿主为浏览器或支持 <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref>：
                        1. 若 _thisEnv_ 不是 |Catch| 子句的 Environment Record，设 _bindingExists_ 为 *true*。
                      1. 否则设 _bindingExists_ 为 *true*。
                  1. 设 _thisEnv_ = _thisEnv_.[[OuterEnv]]。
                1. 若 _bindingExists_ 为 *false* 且 _varEnv_ 是 Global Environment Record，则
                  1. 若 HasLexicalDeclaration(_varEnv_, _F_) 为 *false*，则
                    1. 令 _fnDefinable_ = ? CanDeclareGlobalVar(_varEnv_, _F_)。
                  1. 否则设 _fnDefinable_ 为 *false*。
                1. 否则，
                  1. 设 _fnDefinable_ 为 *true*。
                1. 若 _bindingExists_ 为 *false* 且 _fnDefinable_ 为 *true*，则
                  1. 若 _declaredFunctionOrVarNames_ 不含 _F_，则
                    1. 若 _varEnv_ 是 Global Environment Record，则
                      1. 执行 ? CreateGlobalVarBinding(_varEnv_, _F_, *true*)。
                    1. 否则，
                      1. 设 _bindingExists_ = ! _varEnv_.HasBinding(_F_)。
                      1. 若 _bindingExists_ 为 *false*，则
                        1. 执行 ! _varEnv_.CreateMutableBinding(_F_, *true*)。
                        1. 执行 ! _varEnv_.InitializeBinding(_F_, *undefined*)。
                    1. 追加 _F_ 至 _declaredFunctionOrVarNames_。
                  1. [id="step-evaldeclarationinstantiation-alt-funcdecl-eval"] 当 |FunctionDeclaration| _f_ 被求值时，执行以下步骤替代 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 中的求值算法：
                    1. 令 _gEnv_ 为正在运行执行上下文的 VariableEnvironment。
                    1. 令 _bEnv_ 为正在运行执行上下文的 LexicalEnvironment。
                    1. 令 _fObj_ 为 ! _bEnv_.GetBindingValue(_F_, *false*)。
                    1. 执行 ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*)。
                    1. 返回 ~unused~。
          1. [id="step-evaldeclarationinstantiation-post-validation"] 注：除非 _varEnv_ 为 Global Environment Record 且全局对象为 Proxy 异域对象，此后不再出现异常终止。
          1. 令 _lexDeclarations_ 为 _body_ 的 LexicallyScopedDeclarations。
          1. 对 _lexDeclarations_ 每个 _d_：
            1. 注：词法声明名此处仅实例化，未初始化。
            1. 对 _d_ 的 BoundNames 每个 _dn_：
              1. 若 IsConstantDeclaration(_d_) 为 *true*，执行 ? _lexEnv_.CreateImmutableBinding(_dn_, *true*)。
              1. 否则执行 ? _lexEnv_.CreateMutableBinding(_dn_, *false*)。
          1. 对 _functionsToInitialize_ 每个解析节点 _f_：
            1. 令 _fn_ 为其 BoundNames 唯一元素。
            1. 令 _fo_ 为 InstantiateFunctionObject(_f_, _lexEnv_, _privateEnv_)。
            1. 若 _varEnv_ 是 Global Environment Record，则
              1. 执行 ? CreateGlobalFunctionBinding(_varEnv_, _fn_, _fo_, *true*)。
            1. 否则，
              1. 令 _bindingExists_ = ! _varEnv_.HasBinding(_fn_)。
              1. 若 *false*：
                1. 注：因前置验证，不会异常。
                1. 执行 ! _varEnv_.CreateMutableBinding(_fn_, *true*)。
                1. 执行 ! _varEnv_.InitializeBinding(_fn_, _fo_)。
              1. 否则执行 ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*)。
          1. 对 _declaredVarNames_ 每个字符串 _vn_：
            1. 若 _varEnv_ 是 Global Environment Record，则
              1. 执行 ? CreateGlobalVarBinding(_varEnv_, _vn_, *true*)。
            1. 否则，
              1. 令 _bindingExists_ = ! _varEnv_.HasBinding(_vn_)。
              1. 若 *false*：
                1. 注：因前置验证不异常。
                1. 执行 ! _varEnv_.CreateMutableBinding(_vn_, *true*)。
                1. 执行 ! _varEnv_.InitializeBinding(_vn_, *undefined*)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-isfinite-number">
      <h1>isFinite ( _number_ )</h1>
      <p>此函数是 <dfn>%isFinite%</dfn> 本源对象。</p>
      <p>调用时执行：</p>
      <emu-alg>
        1. 令 _num_ = ? ToNumber(_number_)。
        1. 若 _num_ 不是有限值，返回 *false*。
        1. 否则返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isnan-number">
      <h1>isNaN ( _number_ )</h1>
      <p>此函数是 <dfn>%isNaN%</dfn> 本源对象。</p>
      <p>调用时执行：</p>
      <emu-alg>
        1. 令 _num_ = ? ToNumber(_number_)。
        1. 若 _num_ 为 *NaN*，返回 *true*。
        1. 否则返回 *false*。
      </emu-alg>
      <emu-note>
        <p>在 ECMAScript 中检测值 `X` 是否为 *NaN* 的可靠方式是 `X !== X`；仅当且仅当 `X` 为 *NaN* 时结果为 *true*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parsefloat-string">
      <h1>parseFloat ( _string_ )</h1>
      <p>该函数根据对参数 _string_ 内容按十进制字面量的解释产生一个 Number 值。</p>
      <p>它是 <dfn>%parseFloat%</dfn> 本源对象。</p>
      <p>调用时执行：</p>
      <emu-alg>
        1. 令 _inputString_ = ? ToString(_string_)。
        1. 令 _trimmedString_ = ! TrimString(_inputString_, ~start~)。
        1. 令 _trimmed_ = StringToCodePoints(_trimmedString_)。
        1. 令 _trimmedPrefix_ 为 _trimmed_ 的最长前缀，满足 |StrDecimalLiteral| 语法，可能等于 _trimmed_ 本身。若不存在，返回 *NaN*。
        1. 令 _parsedNumber_ = ParseText(_trimmedPrefix_, |StrDecimalLiteral|)。
        1. 断言：_parsedNumber_ 为解析节点。
        1. 返回 _parsedNumber_ 的 StringNumericValue。
      </emu-alg>
      <emu-note>
        <p>该函数可能仅将 _string_ 的前导部分解释为 Number；忽略无法视为十进制字面量部分的代码单元，且不会指示有代码单元被忽略。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parseint-string-radix">
      <h1>parseInt ( _string_, _radix_ )</h1>
      <p>该函数依据指定 _radix_ 对 _string_ 内容的解释产生一个整数 Number。忽略 _string_ 前导空白。若 _radix_ 强制为 0（如其为 *undefined*），除非数字表示以 *"0x"* 或 *"0X"* 开头，否则假设为 10；若以其开头则假设为 16。若 _radix_ 为 16，数字表示可选以 *"0x"* 或 *"0X"* 开头。</p>
      <p>它是 <dfn>%parseInt%</dfn> 本源对象。</p>
      <p>调用时执行：</p>
      <emu-alg>
        1. 令 _inputString_ = ? ToString(_string_)。
        1. 令 _S_ = ! TrimString(_inputString_, ~start~)。
        1. 令 _sign_ = 1。
        1. 若 _S_ 非空且首代码单元为 0x002D，设 _sign_ = -1。
        1. 若 _S_ 非空且首代码单元为 0x002B 或 0x002D，设 _S_ 为去掉首单元的子串。
        1. 令 _R_ = ℝ(? ToInt32(_radix_))。
        1. 令 _stripPrefix_ = *true*。
        1. 若 _R_ ≠ 0，则
          1. 若 _R_ &lt; 2 或 _R_ > 36，返回 *NaN*。
          1. 若 _R_ ≠ 16，设 _stripPrefix_ = *false*。
        1. 否则设 _R_ = 10。
        1. 若 _stripPrefix_ 为 *true*，则
          1. 若 _S_ 长度 ≥ 2 且前两代码单元为 *"0x"* 或 *"0X"*，则
            1. 设 _S_ 为从索引 2 起子串。
            1. 设 _R_ = 16。
        1. 若 _S_ 含有非基数 _R_ 数字的代码单元，令 _end_ 为首此类代码单元索引；否则 _end_ 为 _S_ 长度。
        1. 令 _Z_ = _S_ 从 0 到 _end_ 的子串。
        1. 若 _Z_ 为空，返回 *NaN*。
        1. 令 _mathInt_ 为以基数-_R_ 表示 _Z_ 的整数值，使用字母 A-Z / a-z 表示 10 到 35。（但若 _R_ = 10 且 _Z_ 含超过 20 个有效数字，实现可将第 21 位及之后替换为 0；若 _R_ 不在 {2,4,8,10,16,32}，_mathInt_ 可为实现近似值。）
        1. 若 _mathInt_ = 0，则
          1. 若 _sign_ = -1，返回 *-0*<sub>𝔽</sub>。
          1. 返回 *+0*<sub>𝔽</sub>。
        1. 返回 𝔽(_sign_ × _mathInt_)。
      </emu-alg>
      <emu-note>
        <p>该函数可能仅将 _string_ 的前导部分解释为整数；忽略无法视为整数表示的代码单元，且不会给出被忽略的提示。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-uri-handling-functions" oldids="sec-uri-syntax-and-semantics">
      <h1>URI 处理函数 (URI Handling Functions)</h1>
      <p>统一资源标识符（URI）是识别资源（如网页或文件）及其访问传输协议（如 HTTP、FTP）的字符串。ECMAScript 语言本身除提供按本节描述进行 URI 编解码的函数外，不提供使用 URI 的支持。`encodeURI` 与 `decodeURI` 针对完整 URI；它们假设保留字符具特殊含义（如作为分隔符），故不编码它们。`encodeURIComponent` 与 `decodeURIComponent` 针对 URI 的各个组成部分；它们假设保留字符代表文本，需编码以在该组成部分成为完整 URI 的一部分时避免特殊含义。</p>
      <emu-note>
        <p>保留字符集合基于 RFC 2396，未反映较新的 RFC 3986 所引入的变化。</p>
      </emu-note>
      <emu-note>
        <p>许多 ECMAScript 实现提供额外操作网页的函数与方法；这些超出本标准范围。</p>
      </emu-note>

      <emu-clause id="sec-decodeuri-encodeduri">
        <h1>decodeURI ( _encodedURI_ )</h1>
        <p>此函数计算一个新 URI，将每个可能由 `encodeURI` 引入的转义序列与 UTF-8 编码替换为其表示码点的 UTF-16 编码。`encodeURI` 不会引入的转义序列不会被替换。</p>
        <p>它是 <dfn>%decodeURI%</dfn> 本源对象。</p>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _uriString_ = ? ToString(_encodedURI_)。
          1. 令 _preserveEscapeSet_ = *";/?:@&=+$,#"*。
          1. 返回 ? Decode(_uriString_, _preserveEscapeSet_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodeuricomponent-encodeduricomponent">
        <h1>decodeURIComponent ( _encodedURIComponent_ )</h1>
        <p>此函数计算新 URI，将每个可能由 `encodeURIComponent` 引入的转义序列与 UTF-8 编码替换为相应码点的 UTF-16 编码。</p>
        <p>它是 <dfn>%decodeURIComponent%</dfn> 本源对象。</p>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _componentString_ = ? ToString(_encodedURIComponent_)。
          1. 令 _preserveEscapeSet_ 为空字符串。
          1. 返回 ? Decode(_componentString_, _preserveEscapeSet_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuri-uri">
        <h1>encodeURI ( _uri_ )</h1>
        <p>此函数对一个 UTF-16 编码（<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）的 URI 进行处理，将特定码点的每个实例替换为表示该码点 UTF-8 编码的一至四个转义序列。</p>
        <p>它是 <dfn>%encodeURI%</dfn> 本源对象。</p>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _uriString_ = ? ToString(_uri_)。
          1. 令 _extraUnescaped_ = *";/?:@&=+$,#"*。
          1. 返回 ? Encode(_uriString_, _extraUnescaped_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuricomponent-uricomponent">
        <h1>encodeURIComponent ( _uriComponent_ )</h1>
        <p>此函数对一个 UTF-16 编码（<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）的 URI 组成部分处理，将特定码点的每个实例替换为表示该码点 UTF-8 编码的一至四个转义序列。</p>
        <p>它是 <dfn>%encodeURIComponent%</dfn> 本源对象。</p>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _componentString_ = ? ToString(_uriComponent_)。
          1. 令 _extraUnescaped_ 为空字符串。
          1. 返回 ? Encode(_componentString_, _extraUnescaped_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encode" type="abstract operation">
        <h1>
          Encode (
            _string_: 字符串,
            _extraUnescaped_: 字符串,
          ): 正常完成（含字符串）或 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>执行 URI 编码与转义，将 _string_ 视为 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 所述的 UTF-16 编码码点序列。若字符在 RFC 2396 标记为未保留或出现在 _extraUnescaped_ 中，则不转义。</dd>
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 长度。
          1. 令 _R_ 为空字符串。
          1. 令 _alwaysUnescaped_ 为 ASCII 单词字符与 *"-.!~\*'()"* 的串联。
          1. 令 _unescapedSet_ = _alwaysUnescaped_ 与 _extraUnescaped_ 的串联。
          1. 令 _k_ = 0。
          1. 重复，条件：_k_ &lt; _len_：
            1. 令 _C_ 为 _string_ 索引 _k_ 的代码单元。
            1. 若 _unescapedSet_ 包含 _C_，则
              1. _k_ ← _k_ + 1。
              1. _R_ ← _R_ 与 _C_ 串联。
            1. 否则，
              1. 令 _cp_ = CodePointAt(_string_, _k_)。
              1. 若 _cp_.[[IsUnpairedSurrogate]] 为 *true*，抛 *URIError*。
              1. _k_ ← _k_ + _cp_.[[CodeUnitCount]]。
              1. 令 _Octets_ 为将 _cp_.[[CodePoint]] 进行 UTF-8 转换得到的八位组列表。
              1. 对 _Octets_ 每个 _octet_：
                1. 令 _hex_ 为 _octet_ 的大写十六进制字符串。
                1. _R_ ← _R_ 与 *"%"* 及 StringPad(_hex_, 2, *"0"*, ~start~) 串联。
          1. 返回 _R_。
        </emu-alg>
        <emu-note>
          <p>因百分号编码表示单个八位组，一个码点可能由多个连续转义序列（其 UTF-8 各字节）表示。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-decode" type="abstract operation">
        <h1>
          Decode (
            _string_: 字符串,
            _preserveEscapeSet_: 字符串,
          ): 正常完成（含字符串）或 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>执行 URI 反转义与解码，保留对应 _preserveEscapeSet_ 中基本拉丁字符的转义序列。</dd>
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 长度。
          1. 令 _R_ 为空字符串。
          1. 令 _k_ = 0。
          1. 重复，条件：_k_ &lt; _len_：
            1. 令 _C_ 为 _string_ 索引 _k_ 的代码单元。
            1. 令 _S_ = _C_。
            1. 若 _C_ 为 0x0025，则
              1. 若 _k_ + 3 > _len_，抛 *URIError*。
              1. 令 _escape_ 为从 _k_ 到 _k_ + 3 的子串。
              1. 令 _B_ = ParseHexOctet(_string_, _k_ + 1)。
              1. 若 _B_ 非整数，抛 *URIError*。
              1. _k_ ← _k_ + 2。
              1. 令 _n_ 为 _B_ 中前导 1 比特数。
              1. 若 _n_ = 0，则
                1. 令 _asciiChar_ 为数值 _B_ 的代码单元。
                1. 若 _preserveEscapeSet_ 包含 _asciiChar_，设 _S_ = _escape_；否则 _S_ = _asciiChar_。
              1. 否则，
                1. 若 _n_ = 1 或 _n_ > 4，抛 *URIError*。
                1. 令 _Octets_ = « _B_ »。
                1. 令 _j_ = 1。
                1. 重复，条件：_j_ &lt; _n_：
                  1. _k_ ← _k_ + 1。
                  1. 若 _k_ + 3 > _len_，抛 *URIError*。
                  1. 若索引 _k_ 代码单元不是 0x0025，抛 *URIError*。
                  1. 令 _continuationByte_ = ParseHexOctet(_string_, _k_ + 1)。
                  1. 若其非整数，抛 *URIError*。
                  1. 追加 _continuationByte_ 至 _Octets_。
                  1. _k_ ← _k_ + 2。
                  1. _j_ ← _j_ + 1。
                1. 断言：_Octets_ 长度为 _n_。
                1. 若 _Octets_ 不含有效 UTF-8 编码，抛 *URIError*。
                1. 令 _V_ 为对 _Octets_ 应用 UTF-8 转换得到的码点。
                1. 设 _S_ = UTF16EncodeCodePoint(_V_)。
            1. _R_ ← _R_ 与 _S_ 串联。
            1. _k_ ← _k_ + 1。
          1. 返回 _R_。
        </emu-alg>
        <emu-note>
          <p>RFC 3629 禁止解码无效 UTF-8 序列。例如，无效序列 0xC0 0x80 不得解码为 0x0000。Decode 算法的实现遇到此类无效序列必须抛 *URIError*。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-parsehexoctet" type="abstract operation">
        <h1>
          ParseHexOctet (
            _string_: 字符串,
            _position_: 非负整数,
          ): 非负整数或非空 *SyntaxError* 对象列表
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>解析 _string_ 中 _position_ 位置的两个十六进制字符序列为无符号 8 位整数。</dd>
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 长度。
          1. 断言：_position_ + 2 ≤ _len_。
          1. 令 _hexDigits_ 为从 _position_ 到 _position_ + 2 的子串。
          1. 令 _parseResult_ = ParseText(_hexDigits_, |HexDigits[~Sep]|)。
          1. 若 _parseResult_ 不是解析节点，返回 _parseResult_。
          1. 令 _n_ 为 _parseResult_ 的 MV。
          1. 断言：_n_ 在 [0,255] 范围。
          1. 返回 _n_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>全局对象的构造器属性 (Constructor Properties of the Global Object)</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-aggregate-error">
      <h1>AggregateError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-aggregate-error-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-array">
      <h1>Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-array-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-arraybuffer">
      <h1>ArrayBuffer ( . . . )</h1>
      <p>见 <emu-xref href="#sec-arraybuffer-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint">
      <h1>BigInt ( . . . )</h1>
      <p>见 <emu-xref href="#sec-bigint-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint64array">
      <h1>BigInt64Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-biguint64array">
      <h1>BigUint64Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-boolean">
      <h1>Boolean ( . . . )</h1>
      <p>见 <emu-xref href="#sec-boolean-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-dataview">
      <h1>DataView ( . . . )</h1>
      <p>见 <emu-xref href="#sec-dataview-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-date">
      <h1>Date ( . . . )</h1>
      <p>见 <emu-xref href="#sec-date-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-error">
      <h1>Error ( . . . )</h1>
      <p>见 <emu-xref href="#sec-error-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-evalerror">
      <h1>EvalError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-finalization-registry" oldids="sec-constructor-properties-of-the-global-object-finnalization-registry">
      <h1>FinalizationRegistry ( . . . )</h1>
      <p>见 <emu-xref href="#sec-finalization-registry-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-float16array">
      <h1>Float16Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-float32array">
      <h1>Float32Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-float64array">
      <h1>Float64Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-function">
      <h1>Function ( . . . )</h1>
      <p>见 <emu-xref href="#sec-function-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-int8array">
      <h1>Int8Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-int16array">
      <h1>Int16Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-int32array">
      <h1>Int32Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-iterator">
      <h1>Iterator ( . . . )</h1>
      <p>见 <emu-xref href="#sec-iterator-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-map">
      <h1>Map ( . . . )</h1>
      <p>见 <emu-xref href="#sec-map-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-number">
      <h1>Number ( . . . )</h1>
      <p>见 <emu-xref href="#sec-number-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-object">
      <h1>Object ( . . . )</h1>
      <p>见 <emu-xref href="#sec-object-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-promise">
      <h1>Promise ( . . . )</h1>
      <p>见 <emu-xref href="#sec-promise-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-proxy">
      <h1>Proxy ( . . . )</h1>
      <p>见 <emu-xref href="#sec-proxy-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-rangeerror">
      <h1>RangeError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-referenceerror">
      <h1>ReferenceError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-regexp">
      <h1>RegExp ( . . . )</h1>
      <p>见 <emu-xref href="#sec-regexp-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-set">
      <h1>Set ( . . . )</h1>
      <p>见 <emu-xref href="#sec-set-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-sharedarraybuffer">
      <h1>SharedArrayBuffer ( . . . )</h1>
      <p>见 <emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-string">
      <h1>String ( . . . )</h1>
      <p>见 <emu-xref href="#sec-string-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-symbol">
      <h1>Symbol ( . . . )</h1>
      <p>见 <emu-xref href="#sec-symbol-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-syntaxerror">
      <h1>SyntaxError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-typeerror">
      <h1>TypeError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-uint8array">
      <h1>Uint8Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-uint8clampedarray">
      <h1>Uint8ClampedArray ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-uint16array">
      <h1>Uint16Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-uint32array">
      <h1>Uint32Array ( . . . )</h1>
      <p>见 <emu-xref href="#sec-typedarray-constructors"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-urierror">
      <h1>URIError ( . . . )</h1>
      <p>见 <emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakmap">
      <h1>WeakMap ( . . . )</h1>
      <p>见 <emu-xref href="#sec-weakmap-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakref">
      <h1>WeakRef ( . . . )</h1>
      <p>见 <emu-xref href="#sec-weak-ref-constructor"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakset">
      <h1>WeakSet ( . . . )</h1>
      <p>见 <emu-xref href="#sec-weakset-objects"></emu-xref>。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-other-properties-of-the-global-object">
    <h1>全局对象的其他属性 (Other Properties of the Global Object)</h1>

    <emu-clause id="sec-atomics">
      <h1>Atomics</h1>
      <p>见 <emu-xref href="#sec-atomics-object"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-json">
      <h1>JSON</h1>
      <p>见 <emu-xref href="#sec-json-object"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-math">
      <h1>Math</h1>
      <p>见 <emu-xref href="#sec-math-object"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-reflect">
      <h1>Reflect</h1>
      <p>见 <emu-xref href="#sec-reflect-object"></emu-xref>。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>基础对象 (Fundamental Objects)</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object 对象 (Object Objects)</h1>

    <emu-clause id="sec-object-constructor">
      <h1>Object 构造函数 (The Object Constructor)</h1>
      <p>Object 构造函数：</p>
      <ul>
        <li>是 <dfn>%Object%</dfn>。</li>
        <li>是全局对象 *"Object"* 属性的初始值。</li>
        <li>作为构造函数调用时创建一个新的普通对象。</li>
        <li>作为函数而非构造函数调用时执行一次类型转换。</li>
        <li>可用作类定义的 `extends` 子句的取值。</li>
      </ul>

      <emu-clause id="sec-object-value">
        <h1>Object ( [ _value_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 既不是 *undefined* 也不是活动函数对象，则
            1. 返回 ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*)。
          1. 如果 _value_ 是 *undefined* 或 *null*，返回 OrdinaryObjectCreate(%Object.prototype%)。
          1. 返回 ! ToObject(_value_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Object 构造函数的属性 (Properties of the Object Constructor)</h1>
      <p>Object 构造函数：</p>
      <ul>
        <li>拥有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>有 *"length"* 属性，其值为 *1*<sub>𝔽</sub>。</li>
        <li>具有以下附加属性：</li>
      </ul>

      <emu-clause id="sec-object.assign">
        <h1>Object.assign ( _target_, ..._sources_ )</h1>
        <p>该函数将一个或多个源对象自身的可枚举自有属性的值拷贝到 _target_ 对象。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _to_ 为 ? ToObject(_target_)。
          1. 如果只传入一个参数，返回 _to_。
          1. 对 _sources_ 中每个元素 _nextSource_，执行
            1. 如果 _nextSource_ 既不是 *undefined* 也不是 *null*，则
              1. 令 _from_ 为 ! ToObject(_nextSource_)。
              1. 令 _keys_ 为 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]()</emu-meta>。
              1. 对 _keys_ 中每个元素 _nextKey_，执行
                1. 令 _desc_ 为 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_)。
                1. 如果 _desc_ 不为 *undefined* 且 _desc_.[[Enumerable]] 为 *true*，则
                  1. 令 _propValue_ 为 ? Get(_from_, _nextKey_)。
                  1. 执行 ? Set(_to_, _nextKey_, _propValue_, *true*)。
          1. 返回 _to_。
        </emu-alg>
        <p>此函数的 *"length"* 属性值为 *2*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-object.create">
        <h1>Object.create ( _O_, _Properties_ )</h1>
        <p>该函数创建一个具有指定原型的新对象。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object 且 _O_ 不是 *null*，抛出 *TypeError* 异常。
          1. 令 _obj_ 为 OrdinaryObjectCreate(_O_)。
          1. 如果 _Properties_ 不是 *undefined*，则
            1. 返回 ? ObjectDefineProperties(_obj_, _Properties_)。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.defineproperties">
        <h1>Object.defineProperties ( _O_, _Properties_ )</h1>
        <p>该函数为对象添加自有属性和/或更新已有自有属性的特性。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，抛出 *TypeError* 异常。
          1. 返回 ? ObjectDefineProperties(_O_, _Properties_)。
        </emu-alg>

        <emu-clause id="sec-objectdefineproperties" type="abstract operation">
          <h1>
            ObjectDefineProperties (
              _O_: an Object,
              _Properties_: an ECMAScript language value,
            ): 一个包含 Object 的正常完成或一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _props_ 为 ? ToObject(_Properties_)。
            1. 令 _keys_ 为 ? <emu-meta effects="user-code">_props_.[[OwnPropertyKeys]]()</emu-meta>。
            1. 令 _descriptors_ 为一个新的空列表。
            1. 对 _keys_ 中每个元素 _nextKey_，执行
              1. 令 _propDesc_ 为 ? <emu-meta effects="user-code">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_)。
              1. 如果 _propDesc_ 不为 *undefined* 且 _propDesc_.[[Enumerable]] 为 *true*，则
                1. 令 _descObj_ 为 ? Get(_props_, _nextKey_)。
                1. 令 _desc_ 为 ? ToPropertyDescriptor(_descObj_)。
                1. 将记录 { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } 追加到 _descriptors_。
            1. 对 _descriptors_ 中每个元素 _property_，执行
              1. 执行 ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]])。
            1. 返回 _O_。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.defineproperty">
        <h1>Object.defineProperty ( _O_, _P_, _Attributes_ )</h1>
        <p>该函数为对象添加一个自有属性和/或更新已有自有属性的特性。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，抛出 *TypeError* 异常。
          1. 令 _key_ 为 ? ToPropertyKey(_P_)。
          1. 令 _desc_ 为 ? ToPropertyDescriptor(_Attributes_)。
          1. 执行 ? DefinePropertyOrThrow(_O_, _key_, _desc_)。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.entries">
        <h1>Object.entries ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 令 _entryList_ 为 ? EnumerableOwnProperties(_obj_, ~key+value~)。
          1. 返回 CreateArrayFromList(_entryList_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.freeze">
        <h1>Object.freeze ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，返回 _O_。
          1. 令 _status_ 为 ? SetIntegrityLevel(_O_, ~frozen~)。
          1. 如果 _status_ 为 *false*，抛出 *TypeError* 异常。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.fromentries" oldids="sec-create-data-property-on-object-functions">
        <h1>Object.fromEntries ( _iterable_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_iterable_)。
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 断言：_obj_ 是一个可扩展且无自有属性的普通对象。
          1. 令 _closure_ 为一个新的抽象闭包，参数 (_key_, _value_)，捕获 _obj_，调用时执行：
            1. 令 _propertyKey_ 为 ? ToPropertyKey(_key_)。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_)。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _adder_ 为 CreateBuiltinFunction(_closure_, 2, *""*, « »)。
          1. 返回 ? AddEntriesFromIterable(_obj_, _iterable_, _adder_)。
        </emu-alg>
        <emu-note>
          为 _adder_ 创建的函数不会被 ECMAScript 代码直接获取。
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptor">
        <h1>Object.getOwnPropertyDescriptor ( _O_, _P_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 令 _key_ 为 ? ToPropertyKey(_P_)。
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_)。
          1. 返回 FromPropertyDescriptor(_desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptors">
        <h1>Object.getOwnPropertyDescriptors ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 令 _ownKeys_ 为 ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta>。
          1. 令 _descriptors_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 对 _ownKeys_ 中每个元素 _key_，执行
            1. 令 _desc_ 为 ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_)。
            1. 令 _descriptor_ 为 FromPropertyDescriptor(_desc_)。
            1. 如果 _descriptor_ 不为 *undefined*，执行 ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_)。
          1. 返回 _descriptors_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertynames">
        <h1>Object.getOwnPropertyNames ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertysymbols">
        <h1>Object.getOwnPropertySymbols ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~))。
        </emu-alg>

        <emu-clause id="sec-getownpropertykeys" type="abstract operation">
          <h1>
            GetOwnPropertyKeys (
              _O_: an ECMAScript language value,
              _type_: ~string~ or ~symbol~,
            ): 一个包含属性键列表的正常完成或一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _obj_ 为 ? ToObject(_O_)。
            1. 令 _keys_ 为 ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta>。
            1. 令 _nameList_ 为一个新的空列表。
            1. 对 _keys_ 中每个元素 _nextKey_，执行
              1. 如果 _nextKey_ 是 Symbol 且 _type_ 为 ~symbol~，或 _nextKey_ 是 String 且 _type_ 为 ~string~，则
                1. 将 _nextKey_ 追加到 _nameList_。
            1. 返回 _nameList_。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getprototypeof">
        <h1>Object.getPrototypeOf ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 返回 ? <emu-meta effects="user-code">_obj_.[[GetPrototypeOf]]()</emu-meta>。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.groupby">
        <h1>Object.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ 应为一个接受两个参数的函数。`groupBy` 按升序对 _items_ 的每个元素调用一次 _callback_ 并构造一个新对象。_callback_ 返回的每个值被强制为属性键。对每个这样的属性键，结果对象都有一个该键的属性，其值是一个数组，包含所有使得 _callback_ 返回值强制为该键的元素。</p>
          <p>_callback_ 以两个参数被调用：元素的值以及元素的索引。</p>
          <p>`groupBy` 的返回值是一个不继承自 %Object.prototype% 的对象。</p>
        </emu-note>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _groups_ 为 ? GroupBy(_items_, _callback_, ~property~)。
          1. 令 _obj_ 为 OrdinaryObjectCreate(*null*)。
          1. 对 _groups_ 中每个记录 { [[Key]], [[Elements]] } _g_，执行
            1. 令 _elements_ 为 CreateArrayFromList(_g_.[[Elements]])。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_)。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.hasown">
        <h1>Object.hasOwn ( _O_, _P_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 令 _key_ 为 ? ToPropertyKey(_P_)。
          1. 返回 ? HasOwnProperty(_obj_, _key_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.is">
        <h1>Object.is ( _value1_, _value2_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 SameValue(_value1_, _value2_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isextensible">
        <h1>Object.isExtensible ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，返回 *false*。
          1. 返回 ? IsExtensible(_O_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isfrozen">
        <h1>Object.isFrozen ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，返回 *true*。
          1. 返回 ? TestIntegrityLevel(_O_, ~frozen~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.issealed">
        <h1>Object.isSealed ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，返回 *true*。
          1. 返回 ? TestIntegrityLevel(_O_, ~sealed~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.keys">
        <h1>Object.keys ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 令 _keyList_ 为 ? EnumerableOwnProperties(_obj_, ~key~)。
          1. 返回 CreateArrayFromList(_keyList_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.preventextensions">
        <h1>Object.preventExtensions ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，返回 _O_。
          1. 令 _status_ 为 ? <emu-meta effects="user-code">_O_.[[PreventExtensions]]()</emu-meta>。
          1. 如果 _status_ 为 *false*，抛出 *TypeError* 异常。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype">
        <h1>Object.prototype</h1>
        <p>`Object.prototype` 的初始值是 Object 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-object.seal">
        <h1>Object.seal ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _O_ 不是 Object，返回 _O_。
          1. 令 _status_ 为 ? SetIntegrityLevel(_O_, ~sealed~)。
          1. 如果 _status_ 为 *false*，抛出 *TypeError* 异常。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.setprototypeof">
        <h1>Object.setPrototypeOf ( _O_, _proto_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 如果 _proto_ 不是 Object 且 _proto_ 不是 *null*，抛出 *TypeError* 异常。
          1. 如果 _O_ 不是 Object，返回 _O_。
          1. 令 _status_ 为 ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_)。
          1. 如果 _status_ 为 *false*，抛出 *TypeError* 异常。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.values">
        <h1>Object.values ( _O_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _obj_ 为 ? ToObject(_O_)。
          1. 令 _valueList_ 为 ? EnumerableOwnProperties(_obj_, ~value~)。
          1. 返回 CreateArrayFromList(_valueList_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-prototype-object" oldids="sec-additional-properties-of-the-object.prototype-object">
      <h1>Object 原型对象的属性 (Properties of the Object Prototype Object)</h1>
      <p><dfn>Object 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Object.prototype%</dfn>。</li>
        <li>具有 [[Extensible]] 内部槽，其值为 *true*。</li>
        <li>具有普通对象定义的内部方法，但 [[SetPrototypeOf]] 方法按 <emu-xref href="#sec-immutable-prototype-exotic-objects-setprototypeof-v"></emu-xref> 中定义。（因此它是不可变原型奇异对象。）</li>
        <li>具有 [[Prototype]] 内部槽，其值为 *null*。</li>
      </ul>

      <emu-clause id="sec-object.prototype.constructor">
        <h1>Object.prototype.constructor</h1>
        <p>`Object.prototype.constructor` 的初始值是 %Object%。</p>
      </emu-clause>

      <emu-clause id="sec-object.prototype.hasownproperty">
        <h1>Object.prototype.hasOwnProperty ( _V_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. [id="step-hasownproperty-topropertykey"] 令 _P_ 为 ? ToPropertyKey(_V_)。
          1. [id="step-hasownproperty-toobject"] 令 _O_ 为 ? ToObject(*this* value)。
          1. 返回 ? HasOwnProperty(_O_, _P_)。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> 与 <emu-xref href="#step-hasownproperty-toobject"></emu-xref> 的顺序确保：即使 *this* 值为 *undefined* 或 *null*，以前版本规范中应由步骤 <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> 抛出的异常仍会抛出。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.isprototypeof">
        <h1>Object.prototype.isPrototypeOf ( _V_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. [id="step-isprototypeof-check-object"] 如果 _V_ 不是 Object，返回 *false*。
          1. [id="step-isprototypeof-toobject"] 令 _O_ 为 ? ToObject(*this* value)。
          1. 重复，
            1. 设 _V_ 为 ? <emu-meta effects="user-code">_V_.[[GetPrototypeOf]]()</emu-meta>。
            1. 如果 _V_ 是 *null*，返回 *false*。
            1. 如果 SameValue(_O_, _V_) 为 *true*，返回 *true*。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-isprototypeof-check-object"></emu-xref> 与 <emu-xref href="#step-isprototypeof-toobject"></emu-xref> 的顺序保持旧版规范在 _V_ 非对象且 *this* 值为 *undefined* 或 *null* 时的行为。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.propertyisenumerable">
        <h1>Object.prototype.propertyIsEnumerable ( _V_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. [id="step-propertyisenumerable-topropertykey"] 令 _P_ 为 ? ToPropertyKey(_V_)。
          1. [id="step-propertyisenumerable-toobject"] 令 _O_ 为 ? ToObject(*this* value)。
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 如果 _desc_ 是 *undefined*，返回 *false*。
          1. 返回 _desc_.[[Enumerable]]。
        </emu-alg>
        <emu-note>
          <p>此方法不考虑原型链上的对象。</p>
        </emu-note>
        <emu-note>
          <p>步骤 <emu-xref href="#step-propertyisenumerable-topropertykey"></emu-xref> 与 <emu-xref href="#step-propertyisenumerable-toobject"></emu-xref> 的顺序确保：即使 *this* 值为 *undefined* 或 *null*，以前版本规范中应由步骤 <emu-xref href="#step-propertyisenumerable-topropertykey"></emu-xref> 抛出的异常仍会抛出。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tolocalestring">
        <h1>Object.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 返回 ? Invoke(_O_, *"toString"*)。
        </emu-alg>
        <p>此方法的可选参数未使用，其存在旨在与 ECMA-402 `toLocaleString` 方法所使用的参数模式一致。不包含 ECMA-402 支持的实现不得将这些参数位置用于其他目的。</p>
        <emu-note>
          <p>该方法为没有本地化敏感 `toString` 行为的对象提供通用 `toLocaleString` 实现。`Array`、`Number`、`Date` 和 %TypedArray% 提供它们自己的本地化敏感 `toLocaleString` 方法。</p>
        </emu-note>
        <emu-note>
          <p>ECMA-402 有意不为此默认实现提供替代方案。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tostring">
        <h1>Object.prototype.toString ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 *this* 值为 *undefined*，返回 *"[object Undefined]"*。
          1. 如果 *this* 值为 *null*，返回 *"[object Null]"*。
          1. 令 _O_ 为 ! ToObject(*this* value)。
          1. 令 _isArray_ 为 ? IsArray(_O_)。
          1. 如果 _isArray_ 为 *true*，令 _builtinTag_ 为 *"Array"*。
          1. 否则如果 _O_ 有 [[ParameterMap]] 内部槽，令 _builtinTag_ 为 *"Arguments"*。
          1. 否则如果 _O_ 具有 [[Call]] 内部方法，令 _builtinTag_ 为 *"Function"*。
          1. 否则如果 _O_ 有 [[ErrorData]] 内部槽，令 _builtinTag_ 为 *"Error"*。
          1. 否则如果 _O_ 有 [[BooleanData]] 内部槽，令 _builtinTag_ 为 *"Boolean"*。
          1. 否则如果 _O_ 有 [[NumberData]] 内部槽，令 _builtinTag_ 为 *"Number"*。
          1. 否则如果 _O_ 有 [[StringData]] 内部槽，令 _builtinTag_ 为 *"String"*。
          1. 否则如果 _O_ 有 [[DateValue]] 内部槽，令 _builtinTag_ 为 *"Date"*。
          1. 否则如果 _O_ 有 [[RegExpMatcher]] 内部槽，令 _builtinTag_ 为 *"RegExp"*。
          1. 否则，令 _builtinTag_ 为 *"Object"*。
          1. 令 _tag_ 为 ? Get(_O_, %Symbol.toStringTag%)。
          1. 如果 _tag_ 不是 String，设 _tag_ 为 _builtinTag_。
          1. 返回 *"[object "*、_tag_、*"]"* 的字符串拼接。
        </emu-alg>
        <emu-note>
          <p>历史上，该方法有时用于访问先前版本规范中作为各种内建对象名义类型标签的 [[Class]] 内部槽的 String 值。上述 `toString` 定义保持使用 `toString` 测试特定内建对象类型的遗留代码兼容性。它并不为其他内建或程序自定义对象类型提供可靠的类型测试机制。此外，程序可使用 %Symbol.toStringTag% 的方式破坏此类遗留类型测试的可靠性。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.valueof">
        <h1>Object.prototype.valueOf ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? ToObject(*this* value)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype.__proto__" legacy normative-optional>
        <h1>Object.prototype.__proto__</h1>
        <p>`Object.prototype.__proto__` 是一个访问器属性，其特性 { [[Enumerable]]: *false*, [[Configurable]]: *true* }。其 [[Get]] 与 [[Set]] 属性定义如下：</p>

        <emu-clause id="sec-get-object.prototype.__proto__">
          <h1>get Object.prototype.__proto__</h1>
          <p>[[Get]] 特性的值是一个不需要参数的内建函数。被调用时执行：</p>
          <emu-alg>
            1. 令 _O_ 为 ? ToObject(*this* value)。
            1. 返回 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-object.prototype.__proto__">
          <h1>set Object.prototype.__proto__</h1>
          <p>[[Set]] 特性的值是一个接受参数 _proto_ 的内建函数。被调用时执行：</p>
          <emu-alg>
            1. 令 _O_ 为 *this* 值。
            1. 执行 ? RequireObjectCoercible(_O_)。
            1. 如果 _proto_ 不是 Object 且 _proto_ 不是 *null*，返回 *undefined*。
            1. 如果 _O_ 不是 Object，返回 *undefined*。
            1. 令 _status_ 为 ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_)。
            1. 如果 _status_ 为 *false*，抛出 *TypeError* 异常。
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.prototype-legacy-accessor-methods" legacy normative-optional>
        <h1>遗留 Object.prototype 访问器方法 (Legacy Object.prototype Accessor Methods)</h1>

        <emu-clause id="sec-object.prototype.__defineGetter__">
          <h1>Object.prototype.__defineGetter__ ( _P_, _getter_ )</h1>
          <p>该方法被调用时执行以下步骤：</p>
          <emu-alg>
            1. 令 _O_ 为 ? ToObject(*this* value)。
            1. 如果 IsCallable(_getter_) 为 *false*，抛出 *TypeError* 异常。
            1. 令 _desc_ 为 PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
            1. 令 _key_ 为 ? ToPropertyKey(_P_)。
            1. 执行 ? DefinePropertyOrThrow(_O_, _key_, _desc_)。
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__defineSetter__">
          <h1>Object.prototype.__defineSetter__ ( _P_, _setter_ )</h1>
          <p>该方法被调用时执行以下步骤：</p>
          <emu-alg>
            1. 令 _O_ 为 ? ToObject(*this* value)。
            1. 如果 IsCallable(_setter_) 为 *false*，抛出 *TypeError* 异常。
            1. 令 _desc_ 为 PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
            1. 令 _key_ 为 ? ToPropertyKey(_P_)。
            1. 执行 ? DefinePropertyOrThrow(_O_, _key_, _desc_)。
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupGetter__">
          <h1>Object.prototype.__lookupGetter__ ( _P_ )</h1>
          <p>该方法被调用时执行以下步骤：</p>
          <emu-alg>
            1. 令 _O_ 为 ? ToObject(*this* value)。
            1. 令 _key_ 为 ? ToPropertyKey(_P_)。
            1. 重复，
              1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)。
              1. 如果 _desc_ 不为 *undefined*，则
                1. 如果 IsAccessorDescriptor(_desc_) 为 *true*，返回 _desc_.[[Get]]。
                1. 返回 *undefined*。
              1. 设 _O_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>。
              1. 如果 _O_ 为 *null*，返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupSetter__">
          <h1>Object.prototype.__lookupSetter__ ( _P_ )</h1>
          <p>该方法被调用时执行以下步骤：</p>
          <emu-alg>
            1. 令 _O_ 为 ? ToObject(*this* value)。
            1. 令 _key_ 为 ? ToPropertyKey(_P_)。
            1. 重复，
              1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)。
              1. 如果 _desc_ 不为 *undefined*，则
                1. 如果 IsAccessorDescriptor(_desc_) 为 *true*，返回 _desc_.[[Set]]。
                1. 返回 *undefined*。
              1. 设 _O_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>。
              1. 如果 _O_ 为 *null*，返回 *undefined*。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-object-instances">
      <h1>Object 实例的属性 (Properties of Object Instances)</h1>
      <p>Object 实例除继承自 Object 原型对象的属性外没有特殊属性。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function 对象 (Function Objects)</h1>

    <emu-clause id="sec-function-constructor">
      <h1>Function 构造函数 (The Function Constructor)</h1>
      <p>Function 构造函数：</p>
      <ul>
        <li>是 <dfn>%Function%</dfn>。</li>
        <li>是全局对象 *"Function"* 属性的初始值。</li>
        <li>作为函数而非构造函数调用时创建并初始化一个新的函数对象。因此函数调用 `Function(…)` 等价于使用相同参数的对象创建表达式 `new Function(…)`。</li>
        <li>可用作类定义 `extends` 子句取值。打算继承规定 Function 行为的子类构造函数必须包含对 Function 构造函数的 `super` 调用，以创建并初始化一个具有内建函数行为所需内部槽的子类实例。所有 ECMAScript 语法形式定义的函数对象都是 Function 的实例。除内建 GeneratorFunction、AsyncFunction、AsyncGeneratorFunction 子类外，没有语法方式可创建 Function 子类实例。</li>
      </ul>

      <emu-clause id="sec-function-p1-p2-pn-body">
        <h1>Function ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最后一个参数（若存在）指定函数体（可执行代码）；之前的任何参数指定形式参数。</p>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _C_ 为活动函数对象。
          1. 如果 _bodyArg_ 未传入，设 _bodyArg_ 为空字符串。
          1. 返回 ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_)。
        </emu-alg>
        <emu-note>
          <p>为每个欲指定的形式参数提供一个实参是允许但非必须的。例如，下列三个表达式产生相同结果：</p>
          <pre><code class="javascript">
            new Function("a", "b", "c", "return a+b+c")
            new Function("a, b, c", "return a+b+c")
            new Function("a,b", "c", "return a+b+c")
          </code></pre>
        </emu-note>

        <emu-clause id="sec-createdynamicfunction" type="abstract operation" oldids="table-dynamic-function-sourcetext-prefixes">
          <h1>
            CreateDynamicFunction (
              _constructor_: a constructor,
              _newTarget_: a constructor or *undefined*,
              _kind_: ~normal~, ~generator~, ~async~, or ~async-generator~,
              _parameterArgs_: a List of ECMAScript language values,
              _bodyArg_: an ECMAScript language value,
            ): 一个包含 ECMAScript 函数对象的正常完成或一个 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_constructor_ 是正在执行该操作的构造函数。_newTarget_ 是最初由 `new` 应用于的构造函数。_parameterArgs_ 与 _bodyArg_ 反映传递给 _constructor_ 的参数值。</dd>
          </dl>
          <emu-alg>
            1. 如果 _newTarget_ 是 *undefined*，设 _newTarget_ 为 _constructor_。
            1. 如果 _kind_ 是 ~normal~，则
              1. 令 _prefix_ 为 *"function"*。
              1. 令 _exprSym_ 为语法符号 |FunctionExpression|。
              1. 令 _bodySym_ 为语法符号 |FunctionBody[~Yield, ~Await]|。
              1. 令 _parameterSym_ 为语法符号 |FormalParameters[~Yield, ~Await]|。
              1. 令 _fallbackProto_ 为 *"%Function.prototype%"*。
            1. 否则如果 _kind_ 是 ~generator~，则
              1. 令 _prefix_ 为 *"function\*"*。
              1. 令 _exprSym_ 为 |GeneratorExpression|。
              1. 令 _bodySym_ 为 |GeneratorBody|。
              1. 令 _parameterSym_ 为 |FormalParameters[+Yield, ~Await]|。
              1. 令 _fallbackProto_ 为 *"%GeneratorFunction.prototype%"*。
            1. 否则如果 _kind_ 是 ~async~，则
              1. 令 _prefix_ 为 *"async function"*。
              1. 令 _exprSym_ 为 |AsyncFunctionExpression|。
              1. 令 _bodySym_ 为 |AsyncFunctionBody|。
              1. 令 _parameterSym_ 为 |FormalParameters[~Yield, +Await]|。
              1. 令 _fallbackProto_ 为 *"%AsyncFunction.prototype%"*。
            1. 否则，
              1. 断言：_kind_ 为 ~async-generator~。
              1. 令 _prefix_ 为 *"async function\*"*。
              1. 令 _exprSym_ 为 |AsyncGeneratorExpression|。
              1. 令 _bodySym_ 为 |AsyncGeneratorBody|。
              1. 令 _parameterSym_ 为 |FormalParameters[+Yield, +Await]|。
              1. 令 _fallbackProto_ 为 *"%AsyncGeneratorFunction.prototype%"*。
            1. 令 _argCount_ 为 _parameterArgs_ 元素个数。
            1. 令 _parameterStrings_ 为一个新的空列表。
            1. 对 _parameterArgs_ 中每个元素 _arg_，执行
              1. 追加 ? ToString(_arg_) 到 _parameterStrings_。
            1. 令 _bodyString_ 为 ? ToString(_bodyArg_)。
            1. 令 _currentRealm_ 为当前 Realm Record。
            1. 执行 ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*)。
            1. 令 _P_ 为空字符串。
            1. 如果 _argCount_ > 0，则
              1. 设 _P_ 为 _parameterStrings_[0]。
              1. 令 _k_ 为 1。
              1. 当 _k_ &lt; _argCount_，重复
                1. 令 _nextArgString_ 为 _parameterStrings_[_k_]。
                1. 设 _P_ 为 _P_、*","* 与 _nextArgString_ 的串联。
                1. 设 _k_ 为 _k_ + 1。
            1. 令 _bodyParseString_ 为 0x000A、_bodyString_、0x000A 的串联。
            1. 令 _sourceString_ 为 _prefix_、*" anonymous("*、_P_、0x000A、*") {"*、_bodyParseString_、*"}"* 的串联。
            1. 令 _sourceText_ 为 StringToCodePoints(_sourceString_)。
            1. 令 _parameters_ 为 ParseText(_P_, _parameterSym_)。
            1. 如果 _parameters_ 是错误列表，抛出 *SyntaxError* 异常。
            1. 令 _body_ 为 ParseText(_bodyParseString_, _bodySym_)。
            1. 如果 _body_ 是错误列表，抛出 *SyntaxError* 异常。
            1. 注：参数和主体分开解析以保证各自单独有效。例如，`new Function("/*", "*/ ) {")` 不会求值为函数。
            1. 注：如果到达此步骤，_sourceText_ 必定具有 _exprSym_ 的语法（但反向不成立）。接下来两步的目的在于强制任何直接适用于 _exprSym_ 的早期错误规则。
            1. 令 _expr_ 为 ParseText(_sourceText_, _exprSym_)。
            1. 如果 _expr_ 是错误列表，抛出 *SyntaxError* 异常。
            1. 令 _proto_ 为 ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_)。
            1. 令 _env_ 为 _currentRealm_.[[GlobalEnv]]。
            1. 令 _privateEnv_ 为 *null*。
            1. 令 _F_ 为 OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_)。
            1. 执行 SetFunctionName(_F_, *"anonymous"*)。
            1. 如果 _kind_ 是 ~generator~，则
              1. 令 _prototype_ 为 OrdinaryObjectCreate(%GeneratorPrototype%)。
              1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
            1. 否则如果 _kind_ 是 ~async-generator~，则
              1. 令 _prototype_ 为 OrdinaryObjectCreate(%AsyncGeneratorPrototype%)。
              1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
            1. 否则如果 _kind_ 是 ~normal~，则
              1. 执行 MakeConstructor(_F_)。
            1. 注：_kind_ 为 ~async~ 的函数是不可构造的，不具有 [[Construct]] 内部方法或 *"prototype"* 属性。
            1. 返回 _F_。
          </emu-alg>
          <emu-note>
            <p>CreateDynamicFunction 会在它创建的、_kind_ 不是 ~async~ 的任何函数上定义 *"prototype"* 属性，以便该函数可被用作构造函数。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Function 构造函数的属性 (Properties of the Function Constructor)</h1>
      <p>Function 构造函数：</p>
      <ul>
        <li>其自身是一个内建函数对象。</li>
        <li>拥有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li oldids="sec-function.length">有 *"length"* 属性，其值为 *1*<sub>𝔽</sub>。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-function.prototype">
        <h1>Function.prototype</h1>
        <p>`Function.prototype` 的值是 Function 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Function 原型对象的属性 (Properties of the Function Prototype Object)</h1>
      <p><dfn>Function 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Function.prototype%</dfn>。</li>
        <li>其自身是一个内建函数对象。</li>
        <li>接受任意参数并在调用时返回 *undefined*。</li>
        <li>没有 [[Construct]] 内部方法；不能被 `new` 用作构造器。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>没有 *"prototype"* 属性。</li>
        <li>有 *"length"* 属性，其值为 *+0*<sub>𝔽</sub>。</li>
        <li>有 *"name"* 属性，其值为空字符串。</li>
      </ul>
      <emu-note>
        <p>将 Function 原型对象指定为函数对象以确保与 ECMAScript 2015 之前代码的兼容性。</p>
      </emu-note>

      <emu-clause id="sec-function.prototype.apply">
        <h1>Function.prototype.apply ( _thisArg_, _argArray_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _func_ 为 *this* 值。
          1. 如果 IsCallable(_func_) 为 *false*，抛出 *TypeError* 异常。
          1. 如果 _argArray_ 是 *undefined* 或 *null*，则
            1. 执行 PrepareForTailCall()。
            1. 返回 ? Call(_func_, _thisArg_)。
          1. 令 _argList_ 为 ? CreateListFromArrayLike(_argArray_)。
          1. 执行 PrepareForTailCall()。
          1. [id="step-function-proto-apply-call"] 返回 ? Call(_func_, _thisArg_, _argList_)。
        </emu-alg>
        <emu-note>
          <p>_thisArg_ 值未经修改地作为 *this* 值传递。这与第 3 版不同，后者将 *undefined* 或 *null* 的 _thisArg_ 替换为全局对象并对其他值应用 ToObject，然后传递该结果作为 *this*。尽管 _thisArg_ 未被修改传递，非严格函数在进入时仍会执行这些转换。</p>
        </emu-note>
        <emu-note>
          <p>如果 _func_ 是箭头函数或绑定函数奇异对象，那么在步骤 <emu-xref href="#step-function-proto-apply-call"></emu-xref> 的 [[Call]] 中会忽略 _thisArg_。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.bind">
        <h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _Target_ 为 *this* 值。
          1. 如果 IsCallable(_Target_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _F_ 为 ? BoundFunctionCreate(_Target_, _thisArg_, _args_)。
          1. 令 _L_ 为 0。
          1. 令 _targetHasLength_ 为 ? HasOwnProperty(_Target_, *"length"*)。
          1. 如果 _targetHasLength_ 为 *true*，则
            1. 令 _targetLen_ 为 ? Get(_Target_, *"length"*)。
            1. 如果 _targetLen_ 是 Number，则
              1. 如果 _targetLen_ 是 *+∞*<sub>𝔽</sub>，则
                1. 设 _L_ 为 +∞。
              1. 否则如果 _targetLen_ 是 *-∞*<sub>𝔽</sub>，则
                1. 设 _L_ 为 0。
              1. 否则，
                1. 令 _targetLenAsInt_ 为 ! ToIntegerOrInfinity(_targetLen_)。
                1. 断言：_targetLenAsInt_ 为有限值。
                1. 令 _argCount_ 为 _args_ 中元素数量。
                1. 设 _L_ 为 max(_targetLenAsInt_ - _argCount_, 0)。
          1. 执行 SetFunctionLength(_F_, _L_)。
          1. 令 _targetName_ 为 ? Get(_Target_, *"name"*)。
          1. 如果 _targetName_ 不是 String，设 _targetName_ 为空字符串。
          1. 执行 SetFunctionName(_F_, _targetName_, *"bound"*)。
          1. 返回 _F_。
        </emu-alg>
        <emu-note>
          <p>使用 `Function.prototype.bind` 创建的函数对象是奇异对象。它们也没有 *"prototype"* 属性。</p>
        </emu-note>
        <emu-note>
          <p>如果 _Target_ 是箭头函数或绑定函数奇异对象，则后续对 _F_ 的调用不会使用该方法传入的 _thisArg_。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.call">
        <h1>Function.prototype.call ( _thisArg_, ..._args_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _func_ 为 *this* 值。
          1. 如果 IsCallable(_func_) 为 *false*，抛出 *TypeError* 异常。
          1. 执行 PrepareForTailCall()。
          1. [id="step-function-proto-call-call"] 返回 ? Call(_func_, _thisArg_, _args_)。
        </emu-alg>
        <emu-note>
          <p>_thisArg_ 值未经修改地作为 *this* 值传递。这与第 3 版不同（见前述说明）。</p>
        </emu-note>
        <emu-note>
          <p>如果 _func_ 是箭头函数或绑定函数奇异对象，则在步骤 <emu-xref href="#step-function-proto-call-call"></emu-xref> 的 [[Call]] 中会忽略 _thisArg_。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.constructor">
        <h1>Function.prototype.constructor</h1>
        <p>`Function.prototype.constructor` 的初始值是 %Function%。</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype.tostring">
        <h1>Function.prototype.toString ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _func_ 为 *this* 值。
          1. 如果 _func_ 是 Object，且 _func_ 有 [[SourceText]] 内部槽，_func_.[[SourceText]] 是 Unicode 码点序列，且 HostHasSourceTextAvailable(_func_) 为 *true*，则
            1. 返回 CodePointsToString(_func_.[[SourceText]])。
          1. 如果 _func_ 是一个 <emu-xref href="#sec-built-in-function-objects">内建函数对象</emu-xref>，返回实现定义的 _func_ 的字符串源码表示。该表示必须具有 |NativeFunction| 的语法。此外，如果 _func_ 有 [[InitialName]] 内部槽且其为 String，则返回字符串中可被 |NativeFunctionAccessor?| |PropertyName| 匹配的部分必须为 _func_.[[InitialName]]。
          1. 如果 _func_ 是 Object 且 IsCallable(_func_) 为 *true*，返回实现定义的、具有 |NativeFunction| 语法的 _func_ 字符串源码表示。
          1. 抛出 *TypeError* 异常。
        </emu-alg>

        <emu-grammar type="definition">
          NativeFunction :
            `function` NativeFunctionAccessor? PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`

          NativeFunctionAccessor :
            `get`
            `set`
        </emu-grammar>
      </emu-clause>

      <emu-clause oldids="sec-function.prototype-@@hasinstance" id="sec-function.prototype-%symbol.hasinstance%">
        <h1>Function.prototype [ %Symbol.hasInstance% ] ( _V_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _F_ 为 *this* 值。
          1. 返回 ? OrdinaryHasInstance(_F_, _V_)。
        </emu-alg>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>这是大多数函数继承的 `%Symbol.hasInstance%` 默认实现。`%Symbol.hasInstance%` 被 `instanceof` 运算符调用以确定一个值是否是特定构造函数的实例。如下表达式</p>
          <pre><code class="javascript">
            v instanceof F
          </code></pre>
          <p>求值等价于</p>
          <pre><code class="javascript">
            F[%Symbol.hasInstance%](v)
          </code></pre>
          <p>构造函数可通过在函数上暴露不同的 `%Symbol.hasInstance%` 方法来控制哪些对象被 `instanceof` 识别为其实例。</p>
        </emu-note>
        <p>该属性不可写且不可配置，以防篡改从而可全局暴露绑定函数的目标函数。</p>
        <p>此方法的 *"name"* 属性值为 *"[Symbol.hasInstance]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-instances">
      <h1>Function 实例 (Function Instances)</h1>
      <p>每个 Function 实例都是一个 ECMAScript 函数对象，并具有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。用 `Function.prototype.bind` 方法 (<emu-xref href="#sec-function.prototype.bind"></emu-xref>) 创建的函数对象具有 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 中列出的内部槽。</p>
      <p>Function 实例具有以下属性：</p>

      <emu-clause id="sec-function-instances-length">
        <h1>length</h1>
        <p>*"length"* 属性的值是一个整数 Number，表示该函数期望的典型参数数量。但语言允许以其他参数数量调用该函数。函数在以不同于其 *"length"* 属性所指数量的参数被调用时的行为取决于函数本身。该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-name">
        <h1>name</h1>
        <p>*"name"* 属性的值是一个对函数具有描述性的 String。该名称无语义意义，通常是 ECMAScript 源文本中在定义点引用该函数的变量或属性名。该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        <p>未被本规范赋予上下文名称的匿名函数对象使用空字符串作为 *"name"* 属性的值。</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-prototype">
        <h1>prototype</h1>
        <p>可作为构造函数使用的 Function 实例具有 *"prototype"* 属性。每当此类 Function 实例被创建，会同时创建另一个普通对象作为函数 *"prototype"* 属性的初始值。除非另有说明，*"prototype"* 属性的值用于初始化该函数作为构造器被调用时新创建对象的 [[Prototype]] 内部槽。</p>
        <p>该属性具有特性 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>使用 `Function.prototype.bind` 创建的函数对象，或对一个 |MethodDefinition|（且不是 |GeneratorMethod| 或 |AsyncGeneratorMethod|）或一个 |ArrowFunction| 求值得到的函数对象不具有 *"prototype"* 属性。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-hosthassourcetextavailable" type="host-defined abstract operation">
      <h1>
        HostHasSourceTextAvailable (
          _func_: a function object,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>允许宿主环境阻止为 _func_ 提供源文本。</dd>
      </dl>
      <p>HostHasSourceTextAvailable 的实现必须符合以下要求：</p>
      <ul>
        <li>对其参数必须是确定性的。每次以特定 _func_ 调用时必须返回相同结果。</li>
      </ul>
      <p>HostHasSourceTextAvailable 的默认实现是返回 *true*。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean 对象 (Boolean Objects)</h1>

    <emu-clause id="sec-boolean-constructor">
      <h1>Boolean 构造函数 (The Boolean Constructor)</h1>
      <p>Boolean 构造函数：</p>
      <ul>
        <li>是 <dfn>%Boolean%</dfn>。</li>
        <li>是全局对象 *"Boolean"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Boolean 对象。</li>
        <li>作为函数调用而非构造函数调用时执行类型转换。</li>
        <li>可用作类定义 `extends` 子句的取值。打算继承指定 Boolean 行为的子类构造函数必须包含对 Boolean 构造函数的 `super` 调用，以创建并初始化具有 [[BooleanData]] 内部槽的子类实例。</li>
      </ul>

      <emu-clause id="sec-boolean-constructor-boolean-value">
        <h1>Boolean ( _value_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _b_ 为 ToBoolean(_value_)。
          1. 如果 NewTarget 是 *undefined*，返回 _b_。
          1. 令 _O_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Boolean.prototype%"*, « [[BooleanData]] »)。
          1. 设 _O_.[[BooleanData]] 为 _b_。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Boolean 构造函数的属性 (Properties of the Boolean Constructor)</h1>
      <p>Boolean 构造函数：</p>
      <ul>
        <li>有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-boolean.prototype">
        <h1>Boolean.prototype</h1>
        <p>`Boolean.prototype` 的初始值是 Boolean 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Boolean 原型对象的属性 (Properties of the Boolean Prototype Object)</h1>
      <p><dfn>Boolean 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Boolean.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>其自身是一个 Boolean 对象；拥有 [[BooleanData]] 内部槽，值为 *false*。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>

      <emu-clause id="sec-boolean.prototype.constructor">
        <h1>Boolean.prototype.constructor</h1>
        <p>`Boolean.prototype.constructor` 的初始值是 %Boolean%。</p>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.tostring">
        <h1>Boolean.prototype.toString ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _b_ 为 ? ThisBooleanValue(*this* value)。
          1. 如果 _b_ 为 *true*，返回 *"true"*；否则返回 *"false"*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.valueof">
        <h1>Boolean.prototype.valueOf ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? ThisBooleanValue(*this* value)。
        </emu-alg>

        <emu-clause id="sec-thisbooleanvalue" type="abstract operation" oldids="thisbooleanvalue">
          <h1>
            ThisBooleanValue (
              _value_: an ECMAScript language value,
            ): 一个包含 Boolean 的正常完成或一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _value_ 是 Boolean，返回 _value_。
            1. 如果 _value_ 是 Object 且 _value_ 有 [[BooleanData]] 内部槽，则
              1. 令 _b_ 为 _value_.[[BooleanData]]。
              1. 断言：_b_ 是 Boolean。
              1. 返回 _b_。
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-boolean-instances">
      <h1>Boolean 实例的属性 (Properties of Boolean Instances)</h1>
      <p>Boolean 实例是继承自 Boolean 原型对象的普通对象。Boolean 实例有 [[BooleanData]] 内部槽。[[BooleanData]] 内部槽是该 Boolean 对象所表示的布尔值。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol 对象 (Symbol Objects)</h1>

    <emu-clause id="sec-symbol-constructor">
      <h1>Symbol 构造函数 (The Symbol Constructor)</h1>
      <p>Symbol 构造函数：</p>
      <ul>
        <li>是 <dfn>%Symbol%</dfn>。</li>
        <li>是全局对象 *"Symbol"* 属性的初始值。</li>
        <li>作为函数调用时返回一个新的 Symbol 值。</li>
        <li>不打算与 `new` 运算符一起使用。</li>
        <li>不打算被继承（子类化）。</li>
        <li>可作为类定义 `extends` 子句的取值，但对它进行 `super` 调用会导致异常。</li>
      </ul>

      <emu-clause id="sec-symbol-description">
        <h1>Symbol ( [ _description_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 不为 *undefined*，抛出 *TypeError* 异常。
          1. 如果 _description_ 是 *undefined*，令 _descString_ 为 *undefined*。
          1. 否则，令 _descString_ 为 ? ToString(_description_)。
          1. 返回一个新的 Symbol，其 [[Description]] 为 _descString_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Symbol 构造函数的属性 (Properties of the Symbol Constructor)</h1>
      <p>Symbol 构造函数：</p>
      <ul>
        <li>有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-symbol.asynciterator">
        <h1>Symbol.asyncIterator</h1>
        <p>`Symbol.asyncIterator` 的初始值是著名符号 %Symbol.asyncIterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.for">
        <h1>Symbol.for ( _key_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _stringKey_ 为 ? ToString(_key_)。
          1. 对 GlobalSymbolRegistry 列表中每个元素 _e_，执行
            1. 如果 _e_.[[Key]] 是 _stringKey_，返回 _e_.[[Symbol]]。
          1. 断言：GlobalSymbolRegistry 列表当前不包含 _stringKey_ 的条目。
          1. 令 _newSymbol_ 为一个新 Symbol，其 [[Description]] 为 _stringKey_。
          1. 将记录 { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } 追加到 GlobalSymbolRegistry 列表。
          1. 返回 _newSymbol_。
        </emu-alg>
        <p><dfn>GlobalSymbolRegistry List</dfn> 是一个可追加的全局可用列表，所有 realm 共享。在任何 ECMAScript 代码执行前，它初始化为一个新的空列表。GlobalSymbolRegistry List 的元素是 <emu-xref href="#table-globalsymbolregistry-record-fields"></emu-xref> 中结构的记录。</p>
        <emu-table id="table-globalsymbolregistry-record-fields" caption="GlobalSymbolRegistry 记录字段 (GlobalSymbolRegistry Record Fields)" oldids="table-44">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Usage
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                a String
              </td>
              <td>
                用于全局标识一个 Symbol 的字符串键。
              </td>
            </tr>
            <tr>
              <td>
                [[Symbol]]
              </td>
              <td>
                a Symbol
              </td>
              <td>
                可从任意 realm 检索的 symbol。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-symbol.hasinstance">
        <h1>Symbol.hasInstance</h1>
        <p>`Symbol.hasInstance` 的初始值是著名符号 %Symbol.hasInstance% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.isconcatspreadable">
        <h1>Symbol.isConcatSpreadable</h1>
        <p>`Symbol.isConcatSpreadable` 的初始值是著名符号 %Symbol.isConcatSpreadable% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.iterator">
        <h1>Symbol.iterator</h1>
        <p>`Symbol.iterator` 的初始值是著名符号 %Symbol.iterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.keyfor">
        <h1>Symbol.keyFor ( _sym_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _sym_ 不是 Symbol，抛出 *TypeError* 异常。
          1. 返回 KeyForSymbol(_sym_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.match">
        <h1>Symbol.match</h1>
        <p>`Symbol.match` 的初始值是著名符号 %Symbol.match% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.matchall">
        <h1>Symbol.matchAll</h1>
        <p>`Symbol.matchAll` 的初始值是著名符号 %Symbol.matchAll% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype">
        <h1>Symbol.prototype</h1>
        <p>`Symbol.prototype` 的初始值是 Symbol 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.replace">
        <h1>Symbol.replace</h1>
        <p>`Symbol.replace` 的初始值是著名符号 %Symbol.replace% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.search">
        <h1>Symbol.search</h1>
        <p>`Symbol.search` 的初始值是著名符号 %Symbol.search% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.species">
        <h1>Symbol.species</h1>
        <p>`Symbol.species` 的初始值是著名符号 %Symbol.species% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.split">
        <h1>Symbol.split</h1>
        <p>`Symbol.split` 的初始值是著名符号 %Symbol.split% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.toprimitive">
        <h1>Symbol.toPrimitive</h1>
        <p>`Symbol.toPrimitive` 的初始值是著名符号 %Symbol.toPrimitive% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.tostringtag">
        <h1>Symbol.toStringTag</h1>
        <p>`Symbol.toStringTag` 的初始值是著名符号 %Symbol.toStringTag% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.unscopables">
        <h1>Symbol.unscopables</h1>
        <p>`Symbol.unscopables` 的初始值是著名符号 %Symbol.unscopables% (<emu-xref href="#table-well-known-symbols"></emu-xref>)。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Symbol 原型对象的属性 (Properties of the Symbol Prototype Object)</h1>
      <p><dfn>Symbol 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Symbol.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是 Symbol 实例且没有 [[SymbolData]] 内部槽。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>

      <emu-clause id="sec-symbol.prototype.constructor">
        <h1>Symbol.prototype.constructor</h1>
        <p>`Symbol.prototype.constructor` 的初始值是 %Symbol%。</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.description">
        <h1>get Symbol.prototype.description</h1>
        <p>`Symbol.prototype.description` 是一个访问器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _s_ 为 *this* 值。
          1. 令 _sym_ 为 ? ThisSymbolValue(_s_)。
          1. 返回 _sym_.[[Description]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.tostring">
        <h1>Symbol.prototype.toString ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _sym_ 为 ? ThisSymbolValue(*this* value)。
          1. 返回 SymbolDescriptiveString(_sym_)。
        </emu-alg>

        <emu-clause id="sec-symboldescriptivestring" type="abstract operation">
          <h1>
            SymbolDescriptiveString (
              _sym_: a Symbol,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _desc_ 为 _sym_.[[Description]]。
            1. 如果 _desc_ 为 *undefined*，设 _desc_ 为空字符串。
            1. 断言：_desc_ 是 String。
            1. 返回 *"Symbol("*、_desc_、*")"* 的串联。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.valueof">
        <h1>Symbol.prototype.valueOf ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? ThisSymbolValue(*this* value)。
        </emu-alg>

        <emu-clause id="sec-thissymbolvalue" type="abstract operation" oldids="thissymbolvalue">
          <h1>
            ThisSymbolValue (
              _value_: an ECMAScript language value,
            ): 一个包含 Symbol 的正常完成或一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _value_ 是 Symbol，返回 _value_。
            1. 如果 _value_ 是 Object 且 _value_ 有 [[SymbolData]] 内部槽，则
              1. 令 _s_ 为 _value_.[[SymbolData]]。
              1. 断言：_s_ 是 Symbol。
              1. 返回 _s_。
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@toprimitive" id="sec-symbol.prototype-%symbol.toprimitive%">
        <h1>Symbol.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>该方法被 ECMAScript 语言运算符调用，用于将一个 Symbol 对象转换为原始值。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? ThisSymbolValue(*this* value)。
        </emu-alg>
        <emu-note>
          <p>参数被忽略。</p>
        </emu-note>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        <p>此方法的 *"name"* 属性值为 *"[Symbol.toPrimitive]"*。</p>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@tostringtag" id="sec-symbol.prototype-%symbol.tostringtag%">
        <h1>Symbol.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是 String 值 *"Symbol"*。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-symbol-instances">
      <h1>Symbol 实例的属性 (Properties of Symbol Instances)</h1>
      <p>Symbol 实例是继承自 Symbol 原型对象的普通对象，并具有 [[SymbolData]] 内部槽。[[SymbolData]] 内部槽是该 Symbol 对象所表示的 Symbol 值。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-symbols">
      <h1>Symbol 的抽象操作 (Abstract Operations for Symbols)</h1>

      <emu-clause id="sec-keyforsymbol" type="abstract operation">
        <h1>
          KeyForSymbol (
            _sym_: a Symbol,
          ): a String or *undefined*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>如果 _sym_ 在 GlobalSymbolRegistry 列表中，则返回用于注册 _sym_ 的 String。</dd>
        </dl>
        <emu-alg>
          1. 对 GlobalSymbolRegistry 列表中每个元素 _e_，执行
            1. 如果 SameValue(_e_.[[Symbol]], _sym_) 为 *true*，返回 _e_.[[Key]]。
          1. 断言：GlobalSymbolRegistry 列表当前不包含 _sym_ 的条目。
          1. 返回 *undefined*。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error 对象 (Error Objects)</h1>
    <p>Error 对象的实例在运行时错误发生时作为异常被抛出。Error 对象也可作为用户自定义异常类的基类。</p>
    <p>当 ECMAScript 实现检测到运行时错误时，它会抛出 <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> 中定义的 _NativeError_ 对象之一的新实例，或 <emu-xref href="#sec-aggregate-error-objects"></emu-xref> 中定义的 AggregateError 对象的新实例。</p>

    <emu-clause id="sec-error-constructor">
      <h1>Error 构造函数 (The Error Constructor)</h1>
      <p>Error 构造函数：</p>
      <ul>
        <li>是 <dfn>%Error%</dfn>。</li>
        <li>是全局对象 *"Error"* 属性的初始值。</li>
        <li>作为函数而非构造函数调用时创建并初始化一个新的 Error 对象。因此函数调用 `Error(…)` 等价于使用相同参数的对象创建表达式 `new Error(…)`。</li>
        <li>可用作类定义 `extends` 子句的取值。打算继承指定 Error 行为的子类构造函数必须包含对 Error 构造函数的 `super` 调用，以创建并初始化具有 [[ErrorData]] 内部槽的子类实例。</li>
      </ul>

      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ [ , _options_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，令 _newTarget_ 为活动函数对象；否则令 _newTarget_ 为 NewTarget。
          1. 令 _O_ 为 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Error.prototype%"*, « [[ErrorData]] »)。
          1. 如果 _message_ 不是 *undefined*，则
            1. 令 _msg_ 为 ? ToString(_message_)。
            1. 执行 CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_)。
          1. 执行 ? InstallErrorCause(_O_, _options_)。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Error 构造函数的属性 (Properties of the Error Constructor)</h1>
      <p>Error 构造函数：</p>
      <ul>
        <li>有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-error.iserror">
        <h1>Error.isError ( _arg_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _arg_ 不是 Object，返回 *false*。
          1. 如果 _arg_ 不具有 [[ErrorData]] 内部槽，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-error.prototype">
        <h1>Error.prototype</h1>
        <p>`Error.prototype` 的初始值是 Error 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-prototype-object">
      <h1>Error 原型对象的属性 (Properties of the Error Prototype Object)</h1>
      <p><dfn>Error 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Error.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是 Error 实例且没有 [[ErrorData]] 内部槽。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>

      <emu-clause id="sec-error.prototype.constructor">
        <h1>Error.prototype.constructor</h1>
        <p>`Error.prototype.constructor` 的初始值是 %Error%。</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.message">
        <h1>Error.prototype.message</h1>
        <p>`Error.prototype.message` 的初始值是空字符串。</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.name">
        <h1>Error.prototype.name</h1>
        <p>`Error.prototype.name` 的初始值是 *"Error"*。</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.tostring">
        <h1>Error.prototype.toString ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是 Object，抛出 *TypeError* 异常。
          1. 令 _name_ 为 ? Get(_O_, *"name"*)。
          1. 如果 _name_ 是 *undefined*，设 _name_ 为 *"Error"*；否则设 _name_ 为 ? ToString(_name_)。
          1. 令 _msg_ 为 ? Get(_O_, *"message"*)。
          1. 如果 _msg_ 是 *undefined*，设 _msg_ 为空字符串；否则设 _msg_ 为 ? ToString(_msg_)。
          1. 如果 _name_ 是空字符串，返回 _msg_。
          1. 如果 _msg_ 是空字符串，返回 _name_。
          1. 返回 _name_、0x003A (COLON)、0x0020 (SPACE) 与 _msg_ 的字符串拼接。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Error 实例的属性 (Properties of Error Instances)</h1>
      <p>Error 实例是继承自 Error 原型对象的普通对象，并具有值为 *undefined* 的 [[ErrorData]] 内部槽。[[ErrorData]] 的唯一规定用途是让 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 与 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 用于识别 Error、AggregateError 与 _NativeError_ 实例。</p>
    </emu-clause>

    <emu-clause id="sec-native-error-types-used-in-this-standard">
      <h1>本标准使用的原生错误类型 (Native Error Types Used in This Standard)</h1>
      <p>检测到运行时错误时，会抛出以下 _NativeError_ 对象之一或 AggregateError 对象的新实例。所有 _NativeError_ 对象共享相同结构，如 <emu-xref href="#sec-nativeerror-object-structure"></emu-xref> 所述。</p>

      <emu-clause id="sec-native-error-types-used-in-this-standard-evalerror">
        <h1>EvalError</h1>
        <p>EvalError 构造函数是 <dfn>%EvalError%</dfn>。</p>
        <p>该异常当前未在本规范中使用。此对象保留用于与先前版本规范的兼容性。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-rangeerror">
        <h1>RangeError</h1>
        <p>RangeError 构造函数是 <dfn>%RangeError%</dfn>。</p>
        <p>表示一个值不在允许值集合或范围之内。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-referenceerror">
        <h1>ReferenceError</h1>
        <p>ReferenceError 构造函数是 <dfn>%ReferenceError%</dfn>。</p>
        <p>表示检测到无效引用。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-syntaxerror">
        <h1>SyntaxError</h1>
        <p>SyntaxError 构造函数是 <dfn>%SyntaxError%</dfn>。</p>
        <p>表示发生了一个解析错误。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-typeerror">
        <h1>TypeError</h1>
        <p>TypeError 构造函数是 <dfn>%TypeError%</dfn>。</p>
        <p>TypeError 用于指示一次操作失败，且其他 _NativeError_ 对象都不适合作为失败原因的指示。</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-urierror">
        <h1>URIError</h1>
        <p>URIError 构造函数是 <dfn>%URIError%</dfn>。</p>
        <p>表示一个全局 URI 处理函数被以与其定义不兼容的方式使用。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ 对象结构 (_NativeError_ Object Structure)</h1>
      <p>这些对象各自具有下面描述的结构，唯一区别在于使用的构造函数名称及其原型对象的 *"name"* 属性。</p>
      <p>对于每个错误对象，定义中对 _NativeError_ 的引用应替换为 <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> 中适当的错误对象名称。</p>

      <emu-clause id="sec-nativeerror-constructors">
        <h1>_NativeError_ 构造函数 (The _NativeError_ Constructors)</h1>
        <p>每个 _NativeError_ 构造函数：</p>
        <ul>
          <li>作为函数而非构造函数调用时创建并初始化一个新的 _NativeError_ 对象。以函数形式调用等价于以相同参数作为构造函数调用。因此函数调用 <code><var>NativeError</var>(&hellip;)</code> 等价于对象创建表达式 <code>new <var>NativeError</var>(&hellip;)</code>。</li>
          <li>可用作类定义 `extends` 子句的取值。子类构造函数若打算继承指定 _NativeError_ 行为，必须包含对 _NativeError_ 构造函数的 `super` 调用，以创建并初始化具有 [[ErrorData]] 内部槽的子类实例。</li>
        </ul>

        <emu-clause id="sec-nativeerror">
          <h1>_NativeError_ ( _message_ [ , _options_ ] )</h1>
          <p>每个 _NativeError_ 函数被调用时执行以下步骤：</p>
          <emu-alg>
            1. 如果 NewTarget 是 *undefined*，令 _newTarget_ 为活动函数对象；否则令 _newTarget_ 为 NewTarget。
            1. [id="step-nativeerror-ordinarycreatefromconstructor"] 令 _O_ 为 ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>.prototype%"</code>, « [[ErrorData]] »)。
            1. 如果 _message_ 不是 *undefined*，则
              1. 令 _msg_ 为 ? ToString(_message_)。
              1. 执行 CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_)。
            1. 执行 ? InstallErrorCause(_O_, _options_)。
            1. 返回 _O_。
          </emu-alg>
          <p>在步骤 <emu-xref href="#step-nativeerror-ordinarycreatefromconstructor"></emu-xref> 中传递的字符串的实际值根据具体构造函数分别是 *"%EvalError.prototype%"*、*"%RangeError.prototype%"*、*"%ReferenceError.prototype%"*、*"%SyntaxError.prototype%"*、*"%TypeError.prototype%"* 或 *"%URIError.prototype%"*。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>_NativeError_ 构造函数的属性 (Properties of the _NativeError_ Constructors)</h1>
        <p>每个 _NativeError_ 构造函数：</p>
        <ul>
          <li>有 [[Prototype]] 内部槽，其值为 %Error%。</li>
          <li>有 *"name"* 属性，其值为 String 值 <emu-val>"<var>NativeError</var>"</emu-val>。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype">
          <h1>_NativeError_.prototype</h1>
          <p><code><var>NativeError</var>.prototype</code> 的初始值是一个 _NativeError_ 原型对象 (<emu-xref href="#sec-properties-of-the-nativeerror-prototype-objects"></emu-xref>)。每个 _NativeError_ 构造函数有各自不同的原型对象。</p>
          <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-prototype-objects">
        <h1>_NativeError_ 原型对象的属性 (Properties of the _NativeError_ Prototype Objects)</h1>
        <p>每个 <dfn>_NativeError_ 原型对象</dfn>：</p>
        <ul>
          <li>是一个普通对象。</li>
          <li>不是 Error 实例且没有 [[ErrorData]] 内部槽。</li>
          <li>具有 [[Prototype]] 内部槽，其值为 %Error.prototype%。</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype.constructor">
          <h1>_NativeError_.prototype.constructor</h1>
          <p>给定 _NativeError_ 构造函数的原型的 *"constructor"* 属性初始值是构造函数自身。</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.message">
          <h1>_NativeError_.prototype.message</h1>
          <p>给定 _NativeError_ 构造函数的原型的 *"message"* 属性初始值是空字符串。</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.name">
          <h1>_NativeError_.prototype.name</h1>
          <p>给定 _NativeError_ 构造函数的原型的 *"name"* 属性初始值是构造函数名称（替换 _NativeError_ 的名称）的 String 值。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>_NativeError_ 实例的属性 (Properties of _NativeError_ Instances)</h1>
        <p>_NativeError_ 实例是继承自其 _NativeError_ 原型对象的普通对象，并具有值为 *undefined* 的 [[ErrorData]] 内部槽。[[ErrorData]] 的唯一规定用途是由 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 和 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 用于识别 Error、AggregateError 或 _NativeError_ 实例。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError 对象 (AggregateError Objects)</h1>

      <emu-clause id="sec-aggregate-error-constructor">
        <h1>AggregateError 构造函数 (The AggregateError Constructor)</h1>
        <p>AggregateError 构造函数：</p>
        <ul>
          <li>是 <dfn>%AggregateError%</dfn>。</li>
          <li>是全局对象 *"AggregateError"* 属性的初始值。</li>
          <li>作为函数而非构造函数调用时创建并初始化一个新的 AggregateError 对象。因此函数调用 `AggregateError(…)` 等价于使用相同参数的对象创建表达式 `new AggregateError(…)`。</li>
          <li>可用作类定义 `extends` 子句的取值。打算继承指定 AggregateError 行为的子类构造函数必须包含对 AggregateError 构造函数的 `super` 调用，以创建并初始化具有 [[ErrorData]] 内部槽的子类实例。</li>
        </ul>

        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>该函数被调用时执行以下步骤：</p>
          <emu-alg>
            1. 如果 NewTarget 是 *undefined*，令 _newTarget_ 为活动函数对象；否则令 _newTarget_ 为 NewTarget。
            1. 令 _O_ 为 ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, « [[ErrorData]] »)。
            1. 如果 _message_ 不为 *undefined*，则
              1. 令 _msg_ 为 ? ToString(_message_)。
              1. 执行 CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_)。
            1. 执行 ? InstallErrorCause(_O_, _options_)。
            1. 令 _errorsList_ 为 ? IteratorToList(? GetIterator(_errors_, ~sync~))。
            1. 执行 ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) })。
            1. 返回 _O_。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructors">
        <h1>AggregateError 构造函数的属性 (Properties of the AggregateError Constructor)</h1>
        <p>AggregateError 构造函数：</p>
        <ul>
          <li>具有 [[Prototype]] 内部槽，其值为 %Error%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype">
          <h1>AggregateError.prototype</h1>
          <p>`AggregateError.prototype` 的初始值是 %AggregateError.prototype%。</p>
          <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-prototype-objects">
        <h1>AggregateError 原型对象的属性 (Properties of the AggregateError Prototype Object)</h1>
        <p><dfn>AggregateError 原型对象</dfn>：</p>
        <ul>
          <li>是 <dfn>%AggregateError.prototype%</dfn>。</li>
          <li>是一个普通对象。</li>
          <li>不是 Error 实例或 AggregateError 实例且没有 [[ErrorData]] 内部槽。</li>
          <li>具有 [[Prototype]] 内部槽，其值为 %Error.prototype%。</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype.constructor">
          <h1>AggregateError.prototype.constructor</h1>
          <p>`AggregateError.prototype.constructor` 的初始值是 %AggregateError%。</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.message">
          <h1>AggregateError.prototype.message</h1>
          <p>`AggregateError.prototype.message` 的初始值是空字符串。</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.name">
          <h1>AggregateError.prototype.name</h1>
          <p>`AggregateError.prototype.name` 的初始值是 *"AggregateError"*。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-aggregate-error-instances">
        <h1>AggregateError 实例的属性 (Properties of AggregateError Instances)</h1>
        <p>AggregateError 实例是继承自其 AggregateError 原型对象的普通对象，并具有值为 *undefined* 的 [[ErrorData]] 内部槽。[[ErrorData]] 的唯一规定用途是由 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 和 `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) 用于识别 Error、AggregateError 或 _NativeError_ 实例。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-error-objects">
      <h1>Error 对象的抽象操作 (Abstract Operations for Error Objects)</h1>

      <emu-clause id="sec-installerrorcause" type="abstract operation">
        <h1>
          InstallErrorCause (
            _O_: an Object,
            _options_: an ECMAScript language value,
          ): 一个包含 ~unused~ 的正常完成或一个 throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>当 _options_ 上存在 *"cause"* 属性时用于在 _O_ 上创建 *"cause"* 属性。</dd>
        </dl>
        <emu-alg>
          1. 如果 _options_ 是 Object 且 ? HasProperty(_options_, *"cause"*) 为 *true*，则
            1. 令 _cause_ 为 ? Get(_options_, *"cause"*)。
            1. 执行 CreateNonEnumerableDataPropertyOrThrow(_O_, *"cause"*, _cause_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>数字与日期 (Numbers and Dates)</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number 对象 (Number Objects)</h1>

    <emu-clause id="sec-number-constructor">
      <h1>Number 构造函数 (The Number Constructor)</h1>
      <p>Number 构造函数：</p>
      <ul>
        <li>是 <dfn>%Number%</dfn>。</li>
        <li>是全局对象 *"Number"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Number 对象。</li>
        <li>作为函数而非构造函数调用时执行一次类型转换。</li>
        <li>可用作类定义的 `extends` 子句取值。想要继承指定 Number 行为的子类构造函数必须包含对 Number 构造函数的 `super` 调用，以创建并初始化带有 [[NumberData]] 内部槽的子类实例。</li>
      </ul>

      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果提供了 _value_，则
            1. 令 _prim_ 为 ? ToNumeric(_value_)。
            1. 如果 _prim_ 是 BigInt，令 _n_ 为 𝔽(ℝ(_prim_))。
            1. 否则，令 _n_ 为 _prim_。
          1. 否则，
            1. 令 _n_ 为 *+0*<sub>𝔽</sub>。
          1. 如果 NewTarget 是 *undefined*，返回 _n_。
          1. 令 _O_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »)。
          1. 设 _O_.[[NumberData]] 为 _n_。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Number 构造函数的属性 (Properties of the Number Constructor)</h1>
      <p>Number 构造函数：</p>
      <ul>
        <li>有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-number.epsilon">
        <h1>Number.EPSILON</h1>
        <p>`Number.EPSILON` 的值是 Number 值 1 与大于 1 的最小可表示 Number 值之间差值的数量级，对应约 2.2204460492503130808472633361816 × 10<sup>-16</sup>。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.isfinite">
        <h1>Number.isFinite ( _number_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _number_ 不是 Number，返回 *false*。
          1. 如果 _number_ 不是有限值，返回 *false*。
          1. 否则，返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isinteger">
        <h1>Number.isInteger ( _number_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _number_ 是一个整数的 Number，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isnan">
        <h1>Number.isNaN ( _number_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _number_ 不是 Number，返回 *false*。
          1. 如果 _number_ 是 *NaN*，返回 *true*。
          1. 否则，返回 *false*。
        </emu-alg>
        <emu-note>
          <p>该函数不同于全局 isNaN 函数 (<emu-xref href="#sec-isnan-number"></emu-xref>)，因为它在判断是否为 *NaN* 前不会将其参数转换为 Number。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.issafeinteger">
        <h1>Number.isSafeInteger ( _number_ )</h1>
        <emu-note>
          <p>整数 _n_ 是“<dfn id="safe-integer">安全整数 (safe integer)</dfn>”当且仅当 _n_ 的 Number 值不与任何其他整数的 Number 值相同。</p>
        </emu-note>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 _number_ 是一个整数的 Number，则
            1. 如果 abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.max_safe_integer">
        <h1>Number.MAX_SAFE_INTEGER</h1>
        <emu-note>
          <p>由于 IEEE 754-2019 精度限制导致的舍入行为，所有大于 `Number.MAX_SAFE_INTEGER` 的整数的 Number 值至少与另一个整数共享。此类大幅度整数因此不是 <emu-xref href="#safe-integer">安全</emu-xref> 的，不能保证精确表示为 Number 值，甚至不能保证彼此可区分。例如，`9007199254740992` 与 `9007199254740993` 都求值为 Number 值 *9007199254740992*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>`Number.MAX_SAFE_INTEGER` 的值是 *9007199254740991*<sub>𝔽</sub> (𝔽(2<sup>53</sup> - 1))。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.max_value">
        <h1>Number.MAX_VALUE</h1>
        <p>`Number.MAX_VALUE` 的值是 Number 类型的最大正有限值，约为 <emu-eqn>1.7976931348623157 × 10<sup>308</sup></emu-eqn>。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.min_safe_integer">
        <h1>Number.MIN_SAFE_INTEGER</h1>
        <emu-note>
          <p>由于 IEEE 754-2019 精度限制导致的舍入行为，所有小于 `Number.MIN_SAFE_INTEGER` 的整数的 Number 值至少与另一个整数共享。此类大幅度整数因此不是 <emu-xref href="#safe-integer">安全</emu-xref> 的，不能保证精确表示为 Number 值，甚至不能保证彼此可区分。例如，`-9007199254740992` 与 `-9007199254740993` 都求值为 Number 值 *-9007199254740992*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>`Number.MIN_SAFE_INTEGER` 的值是 *-9007199254740991*<sub>𝔽</sub> (𝔽(-(2<sup>53</sup> - 1)))。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.min_value">
        <h1>Number.MIN_VALUE</h1>
        <p>`Number.MIN_VALUE` 的值是 Number 类型最小的正值，约为 <emu-eqn>5 × 10<sup>-324</sup></emu-eqn>。</p>
        <p>在 IEEE 754-2019 双精度二进制表示中，最小可能值是一个非规范化数。如果实现不支持非规范化值，则 `Number.MIN_VALUE` 的值必须是该实现实际可表示的最小非零正值。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.nan">
        <h1>Number.NaN</h1>
        <p>`Number.NaN` 的值是 *NaN*。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.negative_infinity">
        <h1>Number.NEGATIVE_INFINITY</h1>
        <p>`Number.NEGATIVE_INFINITY` 的值是 *-∞*<sub>𝔽</sub>。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.parsefloat">
        <h1>Number.parseFloat ( _string_ )</h1>
        <p>*"parseFloat"* 属性的初始值是 %parseFloat%。</p>
      </emu-clause>

      <emu-clause id="sec-number.parseint">
        <h1>Number.parseInt ( _string_, _radix_ )</h1>
        <p>*"parseInt"* 属性的初始值是 %parseInt%。</p>
      </emu-clause>

      <emu-clause id="sec-number.positive_infinity">
        <h1>Number.POSITIVE_INFINITY</h1>
        <p>`Number.POSITIVE_INFINITY` 的值是 *+∞*<sub>𝔽</sub>。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype">
        <h1>Number.prototype</h1>
        <p>`Number.prototype` 的初始值是 Number 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Number 原型对象的属性 (Properties of the Number Prototype Object)</h1>
      <p><dfn>Number 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Number.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>其自身是一个 Number 对象；具有值为 *+0*<sub>𝔽</sub> 的 [[NumberData]] 内部槽。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>
      <p>除非明确另行说明，下面定义的 Number 原型对象的方法不是通用的；传递给它们的 *this* 值必须是一个 Number 值，或一个带有已初始化为 Number 值的 [[NumberData]] 内部槽的对象。</p>
      <p>在某个方法的规范中，“this Number 值”指调用抽象操作 ThisNumberValue 并以该方法调用的 *this* 值作为实参所返回的结果。</p>

      <emu-clause id="sec-number.prototype.constructor">
        <h1>Number.prototype.constructor</h1>
        <p>`Number.prototype.constructor` 的初始值是 %Number%。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toexponential">
        <h1>Number.prototype.toExponential ( _fractionDigits_ )</h1>
        <p>该方法返回一个 String，内容为此 Number 值按十进制指数表示法表示，尾数小数点前一位，且小数点后有 _fractionDigits_ 位。如果 _fractionDigits_ 为 *undefined*，则包含区分该 Number 所需的尽可能多的尾数字符（类似 ToString，只是此处始终用指数表示法）。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _x_ 为 ? ThisNumberValue(*this* value)。
          1. 令 _f_ 为 ? ToIntegerOrInfinity(_fractionDigits_)。
          1. 断言：若 _fractionDigits_ 为 *undefined*，则 _f_ 为 0。
          1. 如果 _x_ 不是有限值，返回 Number::toString(_x_, 10)。
          1. 如果 _f_ &lt; 0 或 _f_ > 100，抛出 *RangeError* 异常。
          1. 设 _x_ 为 ℝ(_x_)。
          1. 令 _s_ 为空字符串。
          1. 若 _x_ &lt; 0，则
            1. 设 _s_ 为 *"-"*。
            1. 设 _x_ 为 -_x_。
          1. 若 _x_ = 0，则
            1. 令 _m_ 为包含 _f_ + 1 个代码单元 0x0030 (DIGIT ZERO) 的 String。
            1. 令 _e_ 为 0。
          1. 否则，
            1. 若 _fractionDigits_ 不为 *undefined*，则
              1. 令 _e_ 与 _n_ 为整数，满足 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup> 且 _n_ × 10<sup>_e_ - _f_</sup> - _x_ 尽可能接近 0。若存在两个满足条件的 (_e_, _n_)，选择使 _n_ × 10<sup>_e_ - _f_</sup> 较大的那一组。
            1. 否则，
              1. [id="step-number-proto-toexponential-intermediate-values"] 令 _e_、_n_、_ff_ 为整数，满足 _ff_ ≥ 0，10<sup>_ff_</sup> ≤ _n_ &lt; 10<sup>_ff_ + 1</sup>，𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) 为 𝔽(_x_)，且 _ff_ 尽可能小。注意：_n_ 的十进制表示有 _ff_ + 1 位，_n_ 不可被 10 整除，并且 _n_ 的最低有效位不一定唯一确定。
              1. 设 _f_ 为 _ff_。
            1. 令 _m_ 为 _n_ 十进制表示的数字（按顺序，无前导零）组成的 String。
          1. 若 _f_ ≠ 0，则
            1. 令 _a_ 为 _m_ 的第一个代码单元。
            1. 令 _b_ 为 _m_ 的其余 _f_ 个代码单元。
            1. 设 _m_ 为 _a_、*"."*、_b_ 的串联。
          1. 若 _e_ = 0，则
            1. 令 _c_ 为 *"+"*。
            1. 令 _d_ 为 *"0"*。
          1. 否则，
            1. 若 _e_ > 0，则
              1. 令 _c_ 为 *"+"*。
            1. 否则，
              1. 断言：_e_ &lt; 0。
              1. 令 _c_ 为 *"-"*。
              1. 设 _e_ 为 -_e_。
            1. 令 _d_ 为 _e_ 十进制表示数字（按顺序，无前导零）组成的 String。
          1. 设 _m_ 为 _m_、*"e"*、_c_、_d_ 的串联。
          1. 返回 _s_ 与 _m_ 的串联。
        </emu-alg>
        <emu-note>
          <p>对于提供比上述规则更高精度转换的实现，建议使用下列替代版本的步骤 <emu-xref href="#step-number-proto-toexponential-intermediate-values"></emu-xref> 作为指导：</p>
          <emu-alg replaces-step="step-number-proto-toexponential-intermediate-values">
            1. 令 _e_、_n_、_f_ 为整数，满足 _f_ ≥ 0，10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup>，𝔽(_n_ × 10<sup>_e_ - _f_</sup>) 为 𝔽(_x_)，且 _f_ 尽可能小。若 _n_ 存在多个可能值，选择使 𝔽(_n_ × 10<sup>_e_ - _f_</sup>) 与 𝔽(_x_) 最接近的 _n_；若有两个这样的 _n_，选择偶数的那个。
          </emu-alg>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tofixed">
        <h1>Number.prototype.toFixed ( _fractionDigits_ )</h1>
        <emu-note>
          <p>该方法返回一个 String，内容为此 Number 值按十进制定点表示法表示，在小数点后有 _fractionDigits_ 位。如果 _fractionDigits_ 为 *undefined*，则假定为 0。</p>
        </emu-note>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _x_ 为 ? ThisNumberValue(*this* value)。
          1. 令 _f_ 为 ? ToIntegerOrInfinity(_fractionDigits_)。
          1. 断言：若 _fractionDigits_ 为 *undefined*，则 _f_ 为 0。
          1. 如果 _f_ 不是有限值，抛出 *RangeError* 异常。
          1. 如果 _f_ &lt; 0 或 _f_ > 100，抛出 *RangeError* 异常。
          1. 如果 _x_ 不是有限值，返回 Number::toString(_x_, 10)。
          1. 设 _x_ 为 ℝ(_x_)。
          1. 令 _s_ 为空字符串。
          1. 若 _x_ &lt; 0，则
            1. 设 _s_ 为 *"-"*。
            1. 设 _x_ 为 -_x_。
          1. 若 _x_ ≥ 10<sup>21</sup>，则
            1. 令 _m_ 为 ! ToString(𝔽(_x_))。
          1. 否则，
            1. 令 _n_ 为整数，使得 _n_ / 10<sup>_f_</sup> - _x_ 尽可能接近 0。若有两个这样的 _n_，取较大的。
            1. 若 _n_ = 0，令 _m_ 为 *"0"*；否则令 _m_ 为 _n_ 十进制表示数字（按顺序，无前导零）组成的 String。
            1. 若 _f_ ≠ 0，则
              1. 令 _k_ 为 _m_ 的长度。
              1. 若 _k_ ≤ _f_，则
                1. 令 _z_ 为包含 _f_ + 1 - _k_ 个代码单元 0x0030 (DIGIT ZERO) 的 String。
                1. 设 _m_ 为 _z_ 与 _m_ 的串联。
                1. 设 _k_ 为 _f_ + 1。
              1. 令 _a_ 为 _m_ 的前 _k_ - _f_ 个代码单元。
              1. 令 _b_ 为 _m_ 其余 _f_ 个代码单元。
              1. 设 _m_ 为 _a_、*"."*、_b_ 的串联。
          1. 返回 _s_ 与 _m_ 的串联。
        </emu-alg>
        <emu-note>
          <p>`toFixed` 的输出在某些值上可能比 `toString` 更精确，因为 `toString` 只打印区分该数字与相邻 Number 值所需的有效数字。例如：</p>
          <p>
            `(1000000000000000128).toString()` 返回 *"1000000000000000100"*，而<br>
            `(1000000000000000128).toFixed(0)` 返回 *"1000000000000000128"*。
          </p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tolocalestring">
        <h1>Number.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范实现此方法。若实现不包含 ECMA-402 API，则使用下列规范：</p>
        <p>此方法生成一个 String，表示此 Number 值，按宿主环境当前语言环境的约定格式化。该方法是实现定义的；允许（但不鼓励）它返回与 `toString` 相同的结果。</p>
        <p>此方法可选参数的意义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得将这些参数位置用于其他目的。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toprecision">
        <h1>Number.prototype.toPrecision ( _precision_ )</h1>
        <p>该方法返回一个 String，内容为此 Number 值：要么使用十进制指数表示法（尾数小数点前 1 位，后面有 <emu-eqn>_precision_ - 1</emu-eqn> 位），要么使用十进制定点表示法（共 _precision_ 个有效数字）。如果 _precision_ 为 *undefined*，则调用 ToString。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _x_ 为 ? ThisNumberValue(*this* value)。
          1. 如果 _precision_ 为 *undefined*，返回 ! ToString(_x_)。
          1. 令 _p_ 为 ? ToIntegerOrInfinity(_precision_)。
          1. 如果 _x_ 不是有限值，返回 Number::toString(_x_, 10)。
          1. 如果 _p_ &lt; 1 或 _p_ > 100，抛出 *RangeError* 异常。
          1. 设 _x_ 为 ℝ(_x_)。
          1. 令 _s_ 为空字符串。
          1. 若 _x_ &lt; 0，则
            1. 设 _s_ 为代码单元 0x002D (HYPHEN-MINUS)。
            1. 设 _x_ 为 -_x_。
          1. 若 _x_ = 0，则
            1. 令 _m_ 为包含 _p_ 个代码单元 0x0030 (DIGIT ZERO) 的 String。
            1. 令 _e_ 为 0。
          1. 否则，
            1. 令 _e_ 与 _n_ 为整数，满足 10<sup>_p_ - 1</sup> ≤ _n_ &lt; 10<sup>_p_</sup> 且 _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ 尽可能接近 0。若存在两个满足条件的 (_e_, _n_)，选择使 _n_ × 10<sup>_e_ - _p_ + 1</sup> 较大的那一组。
            1. 令 _m_ 为 _n_ 十进制表示数字（按顺序，无前导零）组成的 String。
            1. 若 _e_ &lt; -6 或 _e_ ≥ _p_，则
              1. 断言：_e_ ≠ 0。
              1. 若 _p_ ≠ 1，则
                1. 令 _a_ 为 _m_ 的第一个代码单元。
                1. 令 _b_ 为 _m_ 的其余 _p_ - 1 个代码单元。
                1. 设 _m_ 为 _a_、*"."*、_b_ 的串联。
              1. 若 _e_ > 0，则
                1. 令 _c_ 为代码单元 0x002B (PLUS SIGN)。
              1. 否则，
                1. 断言：_e_ &lt; 0。
                1. 令 _c_ 为代码单元 0x002D (HYPHEN-MINUS)。
                1. 设 _e_ 为 -_e_。
              1. 令 _d_ 为 _e_ 十进制表示数字（按顺序，无前导零）组成的 String。
              1. 返回 _s_、_m_、代码单元 0x0065 (LATIN SMALL LETTER E)、_c_、_d_ 的串联。
          1. 若 _e_ = _p_ - 1，返回 _s_ 与 _m_ 的串联。
          1. 若 _e_ ≥ 0，则
            1. 设 _m_ 为：_m_ 的前 _e_ + 1 个代码单元、代码单元 0x002E (FULL STOP)、以及剩余 _p_ - (_e_ + 1) 个代码单元的串联。
          1. 否则，
            1. 设 _m_ 为：代码单元 0x0030 (DIGIT ZERO)、代码单元 0x002E (FULL STOP)、-(_e_ + 1) 个代码单元 0x0030 (DIGIT ZERO)、以及字符串 _m_ 的串联。
          1. 返回 _s_ 与 _m_ 的串联。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tostring">
        <h1>Number.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>可选的 _radix_ 应是区间 *2*<sub>𝔽</sub> 到 *36*<sub>𝔽</sub>（含）内的整数 Number。若 _radix_ 为 *undefined* 则其值取 *10*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _x_ 为 ? ThisNumberValue(*this* value)。
          1. 若 _radix_ 为 *undefined*，令 _radixMV_ 为 10。
          1. 否则，令 _radixMV_ 为 ? ToIntegerOrInfinity(_radix_)。
          1. 若 _radixMV_ 不在 2 到 36 的区间内（含端点），抛出 *RangeError* 异常。
          1. 返回 Number::toString(_x_, _radixMV_)。
        </emu-alg>
        <p>该方法不是通用的；如果其 *this* 值不是一个 Number 或 Number 对象则抛出 *TypeError*。因此它不能被转移到其他类型对象上作为方法使用。</p>
        <p>该方法的 *"length"* 属性值为 *1*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.valueof">
        <h1>Number.prototype.valueOf ( )</h1>
        <emu-alg>
          1. 返回 ? ThisNumberValue(*this* value)。
        </emu-alg>

        <emu-clause id="sec-thisnumbervalue" type="abstract operation" oldids="thisnumbervalue">
          <h1>
            ThisNumberValue (
              _value_: an ECMAScript language value,
            ): 一个包含 Number 的正常完成或一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _value_ 是 Number，返回 _value_。
            1. 如果 _value_ 是 Object 且 _value_ 有 [[NumberData]] 内部槽，则
              1. 令 _n_ 为 _value_.[[NumberData]]。
              1. 断言：_n_ 是 Number。
              1. 返回 _n_。
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-number-instances">
      <h1>Number 实例的属性 (Properties of Number Instances)</h1>
      <p>Number 实例是继承自 Number 原型对象的普通对象。Number 实例还具有 [[NumberData]] 内部槽。[[NumberData]] 内部槽是该 Number 对象所表示的 Number 值。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt 对象 (BigInt Objects)</h1>

    <emu-clause id="sec-bigint-constructor">
      <h1>BigInt 构造函数 (The BigInt Constructor)</h1>
      <p>BigInt 构造函数：</p>
      <ul>
        <li>是 <dfn>%BigInt%</dfn>。</li>
        <li>是全局对象 *"BigInt"* 属性的初始值。</li>
        <li>作为函数而非构造函数调用时执行类型转换。</li>
        <li>不打算与 `new` 运算符一起使用，也不打算被子类化。它可用作类定义 `extends` 子句的取值，但对 BigInt 构造函数的 `super` 调用将导致异常。</li>
      </ul>

      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 不为 *undefined*，抛出 *TypeError* 异常。
          1. 令 _prim_ 为 ? ToPrimitive(_value_, ~number~)。
          1. 如果 _prim_ 是 Number，返回 ? NumberToBigInt(_prim_)。
          1. 否则，返回 ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>。
        </emu-alg>

        <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            NumberToBigInt (
              _number_: a Number,
            ): 要么是包含一个 BigInt 的正常完成，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _number_ 不是整数的 Number，抛出 *RangeError* 异常。
            1. 返回 ℤ(ℝ(_number_))。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>BigInt 构造函数的属性 (Properties of the BigInt Constructor)</h1>
      <p>BigInt 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-bigint.asintn">
        <h1>BigInt.asIntN ( _bits_, _bigint_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 将 _bits_ 设为 ? ToIndex(_bits_)。
          1. 将 _bigint_ 设为 ? ToBigInt(_bigint_)。
          1. 令 _mod_ 为 ℝ(_bigint_) 对 2<sup>_bits_</sup> 取模的结果。
          1. 如果 _mod_ ≥ 2<sup>_bits_ - 1</sup>，返回 ℤ(_mod_ - 2<sup>_bits_</sup>)；否则返回 ℤ(_mod_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.asuintn">
        <h1>BigInt.asUintN ( _bits_, _bigint_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 将 _bits_ 设为 ? ToIndex(_bits_)。
          1. 将 _bigint_ 设为 ? ToBigInt(_bigint_)。
          1. 返回 ℤ(ℝ(_bigint_) modulo 2<sup>_bits_</sup>)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype">
        <h1>BigInt.prototype</h1>
        <p>`BigInt.prototype` 的初始值是 BigInt 原型对象。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>BigInt 原型对象的属性 (Properties of the BigInt Prototype Object)</h1>
      <p><dfn>BigInt 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%BigInt.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是 BigInt 对象；它没有 [[BigIntData]] 内部槽。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>
      <p>在一个方法的规范中，短语 “this BigInt value” 指调用抽象操作 ThisBigIntValue 并以该方法调用的 *this* 值为实参所返回的结果。</p>

      <emu-clause id="sec-bigint.prototype.constructor">
        <h1>BigInt.prototype.constructor</h1>
        <p>`BigInt.prototype.constructor` 的初始值是 %BigInt%。</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tolocalestring">
        <h1>BigInt.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范实现此方法。如果实现不包含 ECMA-402 API，则使用以下规范：</p>
        <p>该方法生成一个表示此 BigInt 值的 String，按照宿主环境当前区域设置的惯例格式化。此方法是实现定义的；允许（但不鼓励）其返回与 `toString` 相同的结果。</p>
        <p>此方法可选参数的意义由 ECMA-402 规范定义；不包含 ECMA-402 支持的实现不得将这些参数位置用于其他用途。</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tostring">
        <h1>BigInt.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>可选的 _radix_ 应为区间 *2*<sub>𝔽</sub> 到 *36*<sub>𝔽</sub>（含）内的整数 Number。如果 _radix_ 为 *undefined*，则使用 *10*<sub>𝔽</sub> 作为基数。</p>
        </emu-note>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _x_ 为 ? ThisBigIntValue(*this* value)。
          1. 如果 _radix_ 为 *undefined*，令 _radixMV_ 为 10。
          1. 否则，令 _radixMV_ 为 ? ToIntegerOrInfinity(_radix_)。
          1. 如果 _radixMV_ 不在 2 到 36 的闭区间内，抛出 *RangeError* 异常。
          1. 返回 BigInt::toString(_x_, _radixMV_)。
        </emu-alg>
        <p>该方法不是通用的；如果其 *this* 值不是 BigInt 或 BigInt 对象则抛出 *TypeError* 异常。因此它不能被转移到其他类型对象上用作方法。</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.valueof">
        <h1>BigInt.prototype.valueOf ( )</h1>
        <emu-alg>
          1. 返回 ? ThisBigIntValue(*this* value)。
        </emu-alg>

        <emu-clause id="sec-thisbigintvalue" type="abstract operation" oldids="thisbigintvalue">
          <h1>
            ThisBigIntValue (
              _value_: an ECMAScript language value,
            ): 要么是包含一个 BigInt 的正常完成，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _value_ 是 BigInt，返回 _value_。
            1. 如果 _value_ 是 Object 且 _value_ 有 [[BigIntData]] 内部槽，则
              1. 断言：_value_.[[BigIntData]] 是 BigInt。
              1. 返回 _value_.[[BigIntData]]。
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-bigint.prototype-@@tostringtag" id="sec-bigint.prototype-%symbol.tostringtag%">
        <h1>BigInt.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"BigInt"*。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-bigint-instances">
      <h1>BigInt 实例的属性 (Properties of BigInt Instances)</h1>
      <p>BigInt 实例是继承自 BigInt 原型对象的普通对象。BigInt 实例还具有 [[BigIntData]] 内部槽。[[BigIntData]] 内部槽是该 BigInt 对象所表示的 BigInt 值。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-math-object">
    <h1>Math 对象 (The Math Object)</h1>
    <p>Math 对象：</p>
    <ul>
      <li>是 <dfn>%Math%</dfn>。</li>
      <li>是全局对象 *"Math"* 属性的初始值。</li>
      <li>是一个普通对象。</li>
      <li>有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      <li>不是函数对象。</li>
      <li>没有 [[Construct]] 内部方法；不能与 `new` 一起作为构造函数使用。</li>
      <li>没有 [[Call]] 内部方法；不能作为函数调用。</li>
    </ul>
    <emu-note>
      <p>在本规范中，短语 “the Number value for _x_” 有在 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> 中定义的技术含义。</p>
    </emu-note>

    <emu-clause id="sec-value-properties-of-the-math-object">
      <h1>Math 对象的值属性 (Value Properties of the Math Object)</h1>

      <emu-clause id="sec-math.e">
        <h1>Math.E</h1>
        <p>自然对数的底 <i>e</i> 的 Number 值，约为 2.7182818284590452354。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-math.ln10">
        <h1>Math.LN10</h1>
        <p>10 的自然对数的 Number 值，约为 2.302585092994046。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-math.ln2">
        <h1>Math.LN2</h1>
        <p>2 的自然对数的 Number 值，约为 0.6931471805599453。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-math.log10e">
        <h1>Math.LOG10E</h1>
        <p><i>e</i> 的常用对数（以 10 为底）的 Number 值，约为 0.4342944819032518。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>`Math.LOG10E` 的值约等于 `Math.LN10` 值的倒数。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log2e">
        <h1>Math.LOG2E</h1>
        <p><i>e</i> 的以 2 为底的对数的 Number 值，约为 1.4426950408889634。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>`Math.LOG2E` 的值约等于 `Math.LN2` 值的倒数。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.pi">
        <h1>Math.PI</h1>
        <p>圆周率 π 的 Number 值，即圆的周长与直径之比，约为 3.1415926535897932。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-math.sqrt1_2">
        <h1>Math.SQRT1_2</h1>
        <p>1/2 的平方根的 Number 值，约为 0.7071067811865476。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>`Math.SQRT1_2` 的值约等于 `Math.SQRT2` 值的倒数。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt2">
        <h1>Math.SQRT2</h1>
        <p>2 的平方根的 Number 值，约为 1.4142135623730951。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-math-@@tostringtag" id="sec-math-%symbol.tostringtag%">
        <h1>Math [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Math"*。</p>
        <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Math 对象的函数属性 (Function Properties of the Math Object)</h1>
      <emu-note>
        <p>`acos`、`acosh`、`asin`、`asinh`、`atan`、`atanh`、`atan2`、`cbrt`、`cos`、`cosh`、`exp`、`expm1`、`hypot`、`log`、`log1p`、`log2`、`log10`、`pow`、`random`、`sin`、`sinh`、`tan` 与 `tanh` 这些函数的行为，在此未被精确规定，除要求在某些表示边界情况的参数值上给出特定结果。对于其它参数值，这些函数旨在计算熟知数学函数的近似值，但在近似算法的选择上允许一定自由。总体意图是：实现者应能在某硬件平台上为 ECMAScript 使用与该平台上 C 程序员可用的同一数学库。</p>
        <p>虽然算法选择留给实现，但（非标准要求地）推荐实现使用 Sun Microsystems 的可自由发布数学库 `fdlibm`（适用于 IEEE 754-2019 算术的近似算法）（<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>）。</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>返回 _x_ 的绝对值；结果与 _x_ 具有相同数值大小且符号为正。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*，返回 *NaN*。
          1. 如果 _n_ 是 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *-∞*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub>，返回 -_n_。
          1. 返回 _n_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acos">
        <h1>Math.acos ( _x_ )</h1>
        <p>返回 _x_ 的反余弦。结果用弧度表示，位于 *+0*<sub>𝔽</sub> 到 𝔽(π) 的闭区间。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*，或 _n_ > *1*<sub>𝔽</sub>，或 _n_ &lt; *-1*<sub>𝔽</sub>，返回 *NaN*。
          1. 如果 _n_ 是 *1*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的反余弦。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>返回 _x_ 的反双曲余弦。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN* 或 *+∞*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ 是 *1*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *1*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的反双曲余弦。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asin">
        <h1>Math.asin ( _x_ )</h1>
        <p>返回 _x_ 的反正弦。结果用弧度表示，位于 𝔽(-π / 2) 到 𝔽(π / 2) 的闭区间。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ > *1*<sub>𝔽</sub> 或 _n_ &lt; *-1*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的反正弦。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>返回 _x_ 的反双曲正弦。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的反双曲正弦。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan">
        <h1>Math.atan ( _x_ )</h1>
        <p>返回 _x_ 的反正切。结果用弧度表示，位于 𝔽(-π / 2) 到 𝔽(π / 2) 的闭区间。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ 是 *+∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 π / 2。
          1. 如果 _n_ 是 *-∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 -π / 2。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的反正切。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>返回 _x_ 的反双曲正切。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ > *1*<sub>𝔽</sub> 或 _n_ &lt; *-1*<sub>𝔽</sub>，返回 *NaN*。
          1. 如果 _n_ 是 *1*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *-1*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的反双曲正切。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan2">
        <h1>Math.atan2 ( _y_, _x_ )</h1>
        <p>返回参数 _y_ 与 _x_ 的商 <emu-eqn>_y_ / _x_</emu-eqn> 的反正切，_y_ 和 _x_ 的符号用于确定结果所在象限。注意按传统约定，两个参数的反正切函数中名为 _y_ 的参数在前，名为 _x_ 的参数在后。结果用弧度表示，位于 -π 到 +π 的闭区间。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _ny_ 为 ? ToNumber(_y_)。
          1. 令 _nx_ 为 ? ToNumber(_x_)。
          1. 如果 _ny_ 是 *NaN* 或 _nx_ 是 *NaN*，返回 *NaN*。
          1. 如果 _ny_ 是 *+∞*<sub>𝔽</sub>，则
            1. 如果 _nx_ 是 *+∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 π / 4。
            1. 如果 _nx_ 是 *-∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 3π / 4。
            1. 返回一个实现近似的 Number，表示 π / 2。
          1. 如果 _ny_ 是 *-∞*<sub>𝔽</sub>，则
            1. 如果 _nx_ 是 *+∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 -π / 4。
            1. 如果 _nx_ 是 *-∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 -3π / 4。
            1. 返回一个实现近似的 Number，表示 -π / 2。
          1. 如果 _ny_ 是 *+0*<sub>𝔽</sub>，则
            1. 如果 _nx_ > *+0*<sub>𝔽</sub> 或 _nx_ 是 *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
            1. 返回一个实现近似的 Number，表示 π。
          1. 如果 _ny_ 是 *-0*<sub>𝔽</sub>，则
            1. 如果 _nx_ > *+0*<sub>𝔽</sub> 或 _nx_ 是 *+0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回一个实现近似的 Number，表示 -π。
          1. 断言：_ny_ 是有限，且既不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>。
          1. 如果 _ny_ > *+0*<sub>𝔽</sub>，则
            1. 如果 _nx_ 是 *+∞*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
            1. 如果 _nx_ 是 *-∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 π。
            1. 如果 _nx_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 π / 2。
          1. 如果 _ny_ &lt; *-0*<sub>𝔽</sub>，则
            1. 如果 _nx_ 是 *+∞*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 如果 _nx_ 是 *-∞*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 -π。
            1. 如果 _nx_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回一个实现近似的 Number，表示 -π / 2。
          1. 断言：_nx_ 是有限，且既不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>。
          1. 令 _r_ 为 abs(ℝ(_ny_) / ℝ(_nx_)) 的反正切。
          1. 如果 _nx_ &lt; *-0*<sub>𝔽</sub>，则
            1. 如果 _ny_ > *+0*<sub>𝔽</sub>，设 _r_ = π - _r_。
            1. 否则，设 _r_ = -π + _r_。
          1. 否则，
            1. 如果 _ny_ &lt; *-0*<sub>𝔽</sub>，设 _r_ = -_r_。
          1. 返回一个实现近似的 Number，表示 _r_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>返回 _x_ 的立方根。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的立方根。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>返回不小于 _x_ 的最小（最接近 -∞）整数 Number 值。若 _x_ 已是整数 Number，则结果为 _x_。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub> 且 _n_ > *-1*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
          1. 如果 _n_ 是整数的 Number，返回 _n_。
          1. 返回不小于 _n_ 的最小（最接近 -∞）整数 Number。
        </emu-alg>
        <emu-note>
          <p>`Math.ceil(x)` 的值与 `-Math.floor(-x)` 的值相同。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.clz32">
        <h1>Math.clz32 ( _x_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToUint32(_x_)。
          1. 令 _p_ 为 _n_ 的无符号 32 位二进制表示的前导零位数。
          1. 返回 𝔽(_p_)。
        </emu-alg>
        <emu-note>
          <p>如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，本方法返回 *32*<sub>𝔽</sub>。如果 _n_ 的 32 位最高有效位是 1，本方法返回 *+0*<sub>𝔽</sub>。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cos">
        <h1>Math.cos ( _x_ )</h1>
        <p>返回 _x_ 的余弦。参数用弧度表示。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限，返回 *NaN*。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的余弦。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>返回 _x_ 的双曲余弦。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*，返回 *NaN*。
          1. 如果 _n_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的双曲余弦。
        </emu-alg>
        <emu-note>
          <p>`Math.cosh(x)` 的值等于 `(Math.exp(x) + Math.exp(-x)) / 2`。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>返回指数函数 _e_<sup>_x_</sup>（_e_ 为自然对数的底）。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN* 或 *+∞*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *-∞*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的指数函数值。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>返回指数函数 _e_<sup>_x_</sup> 减 1 的结果（_e_ 为自然对数的底）。即使 _x_ 接近 0 也应保持精确。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub>、* -0*<sub>𝔽</sub> 或 *+∞*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ 是 *-∞*<sub>𝔽</sub>，返回 *-1*<sub>𝔽</sub>。
          1. 令 _exp_ 为 ℝ(_n_) 的指数函数。
          1. 返回一个实现近似的 Number，表示 _exp_ - 1。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>返回不大于 _x_ 的最大（最接近 +∞）整数 Number 值。若 _x_ 已是整数 Number，则结果为 _x_。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ &lt; *1*<sub>𝔽</sub> 且 _n_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ 是整数的 Number，返回 _n_。
          1. 返回不大于 _n_ 的最大（最接近 +∞）整数 Number。
        </emu-alg>
        <emu-note>
          <p>`Math.floor(x)` 的值与 `-Math.ceil(-x)` 的值相同。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.fround">
        <h1>Math.fround ( _x_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*，返回 *NaN*。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub>、* -0*<sub>𝔽</sub>、*+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub> 之一，返回 _n_。
          1. 令 _n32_ 为将 _n_ 按 roundTiesToEven 模式转换为 IEEE 754-2019 binary32 格式的结果。
          1. 令 _n64_ 为将 _n32_ 转换为 IEEE 754-2019 binary64 格式的结果。
          1. 返回与 _n64_ 对应的 ECMAScript Number 值。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.f16round">
        <h1>Math.f16round ( _x_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*，返回 *NaN*。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub>、* -0*<sub>𝔽</sub>、*+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub> 之一，返回 _n_。
          1. 令 _n16_ 为将 _n_ 按 roundTiesToEven 模式转换为 IEEE 754-2019 binary16 格式的结果。
          1. 令 _n64_ 为将 _n16_ 转换为 IEEE 754-2019 binary64 格式的结果。
          1. 返回与 _n64_ 对应的 ECMAScript Number 值。
        </emu-alg>
        <emu-note>
          <p>此操作不同于先转换为 binary32 再转换为 binary16，因为可能出现双重舍入：例如 _k_ = *1.00048828125000022204*<sub>𝔽</sub>，Math.f16round(_k_) 为 *1.0009765625*<sub>𝔽</sub>，但 Math.f16round(Math.fround(_k_)) 为 *1*<sub>𝔽</sub>。</p>
          <p>并非所有平台都提供从 binary64 转换到 binary16 的原生支持。有多种库可提供此功能，包括 MIT 许可的 <a href="https://half.sourceforge.net/">half</a> 库。或者，可以先在 roundTiesToEven 下从 binary64 转换到 binary32，然后检查结果是否可能导致错误的双重舍入。可能导致的情况可以通过调整 binary32 尾数，使其等同于在 roundTiesToOdd 下的初始转换结果来显式处理。随后在 roundTiesToEven 下将调整后的值转换为 binary16 即可得到正确值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( ..._args_ )</h1>
        <p>给定零个或多个参数，返回各参数平方和的平方根。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _coerced_ 为一个新的空列表。
          1. 对 _args_ 中每个元素 _arg_，执行
            1. 令 _n_ 为 ? ToNumber(_arg_)。
            1. 追加 _n_ 到 _coerced_。
          1. 对 _coerced_ 中每个元素 _number_，执行
            1. 如果 _number_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>。
          1. 令 _onlyZero_ 为 *true*。
          1. 对 _coerced_ 中每个元素 _number_，执行
            1. 如果 _number_ 是 *NaN*，返回 *NaN*。
            1. 如果 _number_ 既不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>，设 _onlyZero_ 为 *false*。
          1. 如果 _onlyZero_ 为 *true*，返回 *+0*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 _coerced_ 各元素数学值平方和的平方根。
        </emu-alg>
        <p>此函数的 *"length"* 属性值为 *2*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>实现应注意避免在具有两个或更多参数时出现朴素实现易触发的溢出与下溢导致的精度丢失。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.imul">
        <h1>Math.imul ( _x_, _y_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _a_ 为 ℝ(? ToUint32(_x_))。
          1. 令 _b_ 为 ℝ(? ToUint32(_y_))。
          1. 令 _product_ 为 (_a_ × _b_) 对 2<sup>32</sup> 取模的结果。
          1. 如果 _product_ ≥ 2<sup>31</sup>，返回 𝔽(_product_ - 2<sup>32</sup>)；否则返回 𝔽(_product_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>返回 _x_ 的自然对数。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN* 或 *+∞*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ 是 *1*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的自然对数。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>返回 1 + _x_ 的自然对数；即使 _x_ 接近 0 也要求精确。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub>、* -0*<sub>𝔽</sub> 或 *+∞*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ 是 *-1*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-1*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 1 + ℝ(_n_) 的自然对数。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>返回 _x_ 的以 10 为底的对数。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN* 或 *+∞*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ 是 *1*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的以 10 为底的对数。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>返回 _x_ 的以 2 为底的对数。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN* 或 *+∞*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ 是 *1*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的以 2 为底的对数。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( ..._args_ )</h1>
        <p>给定零个或多个参数，对每个参数执行 ToNumber，并返回结果值中的最大值。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _coerced_ 为一个新的空列表。
          1. 对 _args_ 中每个元素 _arg_，执行
            1. 令 _n_ 为 ? ToNumber(_arg_)。
            1. 追加 _n_ 到 _coerced_。
          1. 令 _highest_ 为 *-∞*<sub>𝔽</sub>。
          1. 对 _coerced_ 中每个元素 _number_，执行
            1. 如果 _number_ 是 *NaN*，返回 *NaN*。
            1. 如果 _number_ 是 *+0*<sub>𝔽</sub> 且 _highest_ 是 *-0*<sub>𝔽</sub>，设 _highest_ 为 *+0*<sub>𝔽</sub>。
            1. 如果 _number_ > _highest_，设 _highest_ 为 _number_。
          1. 返回 _highest_。
        </emu-alg>
        <emu-note>
          <p>确定最大值的比较使用 IsLessThan 算法，但 *+0*<sub>𝔽</sub> 被认为大于 *-0*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>此函数的 *"length"* 属性值为 *2*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( ..._args_ )</h1>
        <p>给定零个或多个参数，对每个参数执行 ToNumber，并返回结果值中的最小值。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _coerced_ 为一个新的空列表。
          1. 对 _args_ 中每个元素 _arg_，执行
            1. 令 _n_ 为 ? ToNumber(_arg_)。
            1. 追加 _n_ 到 _coerced_。
          1. 令 _lowest_ 为 *+∞*<sub>𝔽</sub>。
          1. 对 _coerced_ 中每个元素 _number_，执行
            1. 如果 _number_ 是 *NaN*，返回 *NaN*。
            1. 如果 _number_ 是 *-0*<sub>𝔽</sub> 且 _lowest_ 是 *+0*<sub>𝔽</sub>，设 _lowest_ 为 *-0*<sub>𝔽</sub>。
            1. 如果 _number_ &lt; _lowest_，设 _lowest_ 为 _number_。
          1. 返回 _lowest_。
        </emu-alg>
        <emu-note>
          <p>确定最大值的比较使用 IsLessThan 算法，但 *+0*<sub>𝔽</sub> 被认为大于 *-0*<sub>𝔽</sub>。</p>
        </emu-note>
        <p>此函数的 *"length"* 属性值为 *2*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 将 _base_ 设为 ? ToNumber(_base_)。
          1. 将 _exponent_ 设为 ? ToNumber(_exponent_)。
          1. 返回 Number::exponentiate(_base_, _exponent_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.random">
        <h1>Math.random ( )</h1>
        <p>返回一个具有正号的 Number，值 ≥ *+0*<sub>𝔽</sub> 且 &lt; *1*<sub>𝔽</sub>，在该范围内以近似均匀分布随机或伪随机选择，使用实现定义的算法或策略。</p>
        <p>为不同 realm 创建的每个 `Math.random` 函数必须产生与其它 realm 不同的值序列。</p>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>返回最接近 _x_ 的整数 Number 值；若有两个整数同样接近 _x_，结果为更靠近 +∞ 的那个。若 _x_ 已是整数，则结果为 _x_。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是整数 Number，返回 _n_。
          1. 如果 _n_ &lt; *0.5*<sub>𝔽</sub> 且 _n_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub> 且 _n_ ≥ *-0.5*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
          1. 返回最接近 _n_ 的整数 Number；若存在平局，取更靠近 +∞ 的那个。
        </emu-alg>
        <emu-note>
          <p>`Math.round(3.5)` 返回 4，而 `Math.round(-3.5)` 返回 -3。</p>
        </emu-note>
        <emu-note>
          <p>`Math.round(x)` 的值不总是等于 `Math.floor(x + 0.5)`。当 `x` 是 *-0*<sub>𝔽</sub> 或 `x` &lt; *-0*<sub>𝔽</sub> 且 ≥ *-0.5*<sub>𝔽</sub> 时，`Math.round(x)` 返回 *-0*<sub>𝔽</sub>，但 `Math.floor(x + 0.5)` 返回 *+0*<sub>𝔽</sub>。计算 `x + 0.5` 时的内部舍入也可能使结果不同。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>返回 _x_ 的符号，指示 _x_ 是正、负或零。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *-1*<sub>𝔽</sub>。
          1. 返回 *1*<sub>𝔽</sub>。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sin">
        <h1>Math.sin ( _x_ )</h1>
        <p>返回 _x_ 的正弦。参数用弧度表示。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的正弦。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>返回 _x_ 的双曲正弦。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的双曲正弦。
        </emu-alg>
        <emu-note>
          <p>`Math.sinh(x)` 的值等于 `(Math.exp(x) - Math.exp(-x)) / 2`。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>返回 _x_ 的平方根。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub>、* -0*<sub>𝔽</sub> 或 *+∞*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回 𝔽(ℝ(_n_) 的平方根)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sumprecise">
        <h1>Math.sumPrecise ( _items_ )</h1>
        <p>给定一个由 Number 组成的可迭代对象，对其中每个值求和并返回和。如果任一值不是 Number 则抛出 *TypeError* 异常。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 执行 ? RequireObjectCoercible(_items_)。
          1. 令 _iteratorRecord_ 为 ? GetIterator(_items_, ~sync~)。
          1. 令 _state_ 为 ~minus-zero~。
          1. 令 _sum_ 为 0。
          1. 令 _count_ 为 0。
          1. 令 _next_ 为 ~not-started~。
          1. 当 _next_ 不为 ~done~ 时重复，
            1. 设 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 如果 _next_ 不为 ~done~，则
              1. 如果 _count_ ≥ 2<sup>53</sup> - 1，则
                1. 注：理论上不期望到达此步骤，仅用于允许实现依赖“合理大小”的输入而不违背规范。
                1. 令 _error_ 为 ThrowCompletion(一个新建的 *RangeError* 对象)。
                1. 返回 ? IteratorClose(_iteratorRecord_, _error_)。
              1. 如果 _next_ 不是 Number，则
                1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
                1. 返回 ? IteratorClose(_iteratorRecord_, _error_)。
              1. 令 _n_ 为 _next_。
              1. 如果 _state_ 不为 ~not-a-number~，则
                1. 如果 _n_ 是 *NaN*，则
                  1. 设 _state_ 为 ~not-a-number~。
                1. 否则如果 _n_ 是 *+∞*<sub>𝔽</sub>，则
                  1. 如果 _state_ 是 ~minus-infinity~，设 _state_ 为 ~not-a-number~。
                  1. 否则设 _state_ 为 ~plus-infinity~。
                1. 否则如果 _n_ 是 *-∞*<sub>𝔽</sub>，则
                  1. 如果 _state_ 是 ~plus-infinity~，设 _state_ 为 ~not-a-number~。
                  1. 否则设 _state_ 为 ~minus-infinity~。
                1. 否则如果 _n_ 不是 *-0*<sub>𝔽</sub> 且 _state_ 是 ~minus-zero~ 或 ~finite~，则
                  1. 设 _state_ 为 ~finite~。
                  1. 设 _sum_ 为 _sum_ + ℝ(_n_)。
              1. 设 _count_ 为 _count_ + 1。
          1. 如果 _state_ 是 ~not-a-number~，返回 *NaN*。
          1. 如果 _state_ 是 ~plus-infinity~，返回 *+∞*<sub>𝔽</sub>。
          1. 如果 _state_ 是 ~minus-infinity~，返回 *-∞*<sub>𝔽</sub>。
          1. 如果 _state_ 是 ~minus-zero~，返回 *-0*<sub>𝔽</sub>。
          1. 返回 𝔽(_sum_)。
        </emu-alg>
        <emu-note>
          <p>_sum_ 的值可通过多种算法在无需任意精度算术的情况下计算。其中之一是 Jonathan Richard Shewchuk 在《Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates》中给出的 “Grow-Expansion” 算法。一个更新的算法见 “<a href="https://arxiv.org/abs/1505.05571">Fast exact summation using small and large superaccumulators</a>”，其代码位于 <a href="https://gitlab.com/radfordneal/xsum">https://gitlab.com/radfordneal/xsum</a>。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.tan">
        <h1>Math.tan ( _x_ )</h1>
        <p>返回 _x_ 的正切。参数用弧度表示。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *NaN*。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的正切。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>返回 _x_ 的双曲正切。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 之一，返回 _n_。
          1. 如果 _n_ 是 *+∞*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
          1. 如果 _n_ 是 *-∞*<sub>𝔽</sub>，返回 *-1*<sub>𝔽</sub>。
          1. 返回一个实现近似的 Number，表示 ℝ(_n_) 的双曲正切。
        </emu-alg>
        <emu-note>
          <p>`Math.tanh(x)` 的值等于 `(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))`。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>返回数字 _x_ 的整数部分，去除任何小数部分。若 _x_ 已是整数，结果为 _x_。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _n_ 为 ? ToNumber(_x_)。
          1. 如果 _n_ 非有限或 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
          1. 如果 _n_ &lt; *1*<sub>𝔽</sub> 且 _n_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 如果 _n_ &lt; *-0*<sub>𝔽</sub> 且 _n_ > *-1*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
          1. 返回朝向 *+0*<sub>𝔽</sub> 方向最接近 _n_ 的整数 Number。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date 对象</h1>

    <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
      <h1>Date 对象概述及抽象操作定义</h1>
      <p>以下抽象操作作用于时间值（定义见 <emu-xref href="#sec-time-values-and-time-range"></emu-xref>）。注意，在所有情况下，如果这些函数的任何参数为 *NaN*，则结果为 *NaN*。</p>

      <emu-clause id="sec-time-values-and-time-range">
        <h1>时间值与时间范围</h1>
        <p>ECMAScript 的时间度量与 POSIX 的时间度量类似，特别是在使用前推的公历、以 1970 年 1 月 1 日 UTC 零点为 <dfn id="epoch">纪元</dfn>，以及每一天精确包含 86,400 秒（每秒为 1000 毫秒）的定义上。</p>
        <p>ECMAScript 的 <dfn variants="time values">时间值</dfn> 是一个 Number，要么是表示某一时刻的有限整数 Number（精确到毫秒），要么是 *NaN* 表示没有具体时刻。一个是 <emu-eqn>24 × 60 × 60 × 1000 = 86,400,000</emu-eqn> 的倍数（即对于某个整数 _d_，为 86,400,000 × _d_）的时间值，表示自纪元起经过 _d_ 个完整 UTC 日的 UTC 日起始时刻（负 _d_ 表示纪元之前）。其他有限时间值 _t_ 则以紧邻其之前最大倍数的时间值 _s_ 为基准，表示与 _s_ 同一天内，距离 _s_ 之后 (_t_ - _s_) 毫秒的时刻。</p>
        <p>时间值不考虑 UTC 闰秒——没有表示正闰秒内时刻的时间值，也有表示因负闰秒从 UTC 时间线移除的时刻的时间值。但时间值的定义仍然与 UTC 分段对齐，只有在闰秒边界处有不连续，非闰秒时为零差异。</p>
        <p>Number 能精确表示从 -9,007,199,254,740,992 到 9,007,199,254,740,992 的所有整数（见 <emu-xref href="#sec-number.min_safe_integer"></emu-xref> 和 <emu-xref href="#sec-number.max_safe_integer"></emu-xref>）。而时间值支持稍小的范围 -8,640,000,000,000,000 到 8,640,000,000,000,000 毫秒。这对应于自 1970 年 1 月 1 日 UTC 零点起精确的 -100,000,000 天到 100,000,000 天的时间值范围。</p>
        <p>1970 年 1 月 1 日 UTC 零点的精确时刻由时间值 *+0*<sub>𝔽</sub> 表示。</p>
        <emu-note>
          <p>在前推的公历中，闰年是能被 4 整除且（能被 400 整除或不能被 100 整除）的年份。</p>
          <p>前推的公历 400 年周期包含 97 个闰年，平均每年为 365.2425 天，即 31,556,952,000 毫秒。因此用毫秒精度 Number 可精确表示的最大范围约为距 1970 年前后 -285,426 到 285,426 年。按本节时间值的更小支持范围约为距 1970 年前后 -273,790 到 273,790 年。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-related-constants">
        <h1>时间相关常量</h1>
        <p>这些常量会被后续章节中的算法引用。</p>
        <emu-eqn id="eqn-HoursPerDay" aoid="HoursPerDay">HoursPerDay = 24</emu-eqn>
        <emu-eqn id="eqn-MinutesPerHour" aoid="MinutesPerHour">MinutesPerHour = 60</emu-eqn>
        <emu-eqn id="eqn-SecondsPerMinute" aoid="SecondsPerMinute">SecondsPerMinute = 60</emu-eqn>
        <emu-eqn id="eqn-msPerSecond" aoid="msPerSecond">msPerSecond = *1000*<sub>𝔽</sub></emu-eqn>
        <emu-eqn id="eqn-msPerMinute" aoid="msPerMinute">msPerMinute = *60000*<sub>𝔽</sub> = msPerSecond × 𝔽(SecondsPerMinute)</emu-eqn>
        <emu-eqn id="eqn-msPerHour" aoid="msPerHour">msPerHour = *3600000*<sub>𝔽</sub> = msPerMinute × 𝔽(MinutesPerHour)</emu-eqn>
        <emu-eqn id="eqn-msPerDay" aoid="msPerDay">msPerDay = *86400000*<sub>𝔽</sub> = msPerHour × 𝔽(HoursPerDay)</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-day" type="abstract operation" oldids="eqn-Day,sec-day-number-and-time-within-day">
        <h1>
          Day (
            _t_: 有限时间值,
          ): 整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在日期的日号。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(floor(ℝ(_t_ / msPerDay)))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timewithinday" type="abstract operation" oldids="eqn-TimeWithinDay">
        <h1>
          TimeWithinDay (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub>（含）至 msPerDay（不含）内的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在日期自零点起经过的毫秒数。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(ℝ(_t_) 模 ℝ(msPerDay))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daysinyear" type="abstract operation" oldids="eqn-DaysInYear,sec-year-number">
        <h1>
          DaysInYear (
            _y_: 整数 Number,
          ): *365*<sub>𝔽</sub> 或 *366*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回年份 _y_ 的天数。闰年为 366 天，其他年份为 365 天。</dd>
        </dl>
        <emu-alg>
          1. 令 _ry_ 为 ℝ(_y_)。
          1. 若 (_ry_ 模 400) = 0，返回 *366*<sub>𝔽</sub>。
          1. 若 (_ry_ 模 100) = 0，返回 *365*<sub>𝔽</sub>。
          1. 若 (_ry_ 模 4) = 0，返回 *366*<sub>𝔽</sub>。
          1. 返回 *365*<sub>𝔽</sub>。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dayfromyear" type="abstract operation" oldids="eqn-DaysFromYear">
        <h1>
          DayFromYear (
            _y_: 整数 Number,
          ): 整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回年份 _y_ 的首日的日号。</dd>
        </dl>
        <emu-alg>
          1. 令 _ry_ 为 ℝ(_y_)。
          1. [declared="numYears1,numYears4,numYears100,numYears400"] 注：下列步骤中，_numYears1_、_numYears4_、_numYears100_、_numYears400_ 表示自纪元至 _y_ 年首之间能被 1、4、100、400 整除的年份数。若 _y_ 在纪元之前则为负数。
          1. 令 _numYears1_ 为 (_ry_ - 1970)。
          1. 令 _numYears4_ 为 floor((_ry_ - 1969) / 4)。
          1. 令 _numYears100_ 为 floor((_ry_ - 1901) / 100)。
          1. 令 _numYears400_ 为 floor((_ry_ - 1601) / 400)。
          1. 返回 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timefromyear" type="abstract operation" oldids="eqn-TimeFromYear">
        <h1>
          TimeFromYear (
            _y_: 整数 Number,
          ): 时间值
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回年份 _y_ 的首日的时间值。</dd>
        </dl>
        <emu-alg>
          1. 返回 msPerDay × DayFromYear(_y_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yearfromtime" type="abstract operation" oldids="eqn-YearFromTime">
        <h1>
          YearFromTime (
            _t_: 有限时间值,
          ): 整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在年份。</dd>
        </dl>
        <emu-alg>
          1. [declared="y"] 返回满足 TimeFromYear(_y_) ≤ _t_ 的最大整数 Number _y_（最接近 +∞）。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daywithinyear" type="abstract operation" oldids="eqn-DayWithinYear">
        <h1>
          DayWithinYear (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *365*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 Day(_t_) - DayFromYear(YearFromTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-inleapyear" type="abstract operation" oldids="eqn-InLeapYear">
        <h1>
          InLeapYear (
            _t_: 有限时间值,
          ): *+0*<sub>𝔽</sub> 或 *1*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>若 _t_ 属于闰年则返回 *1*<sub>𝔽</sub>，否则返回 *+0*<sub>𝔽</sub>。</dd>
        </dl>
        <emu-alg>
          1. 若 DaysInYear(YearFromTime(_t_)) 为 *366*<sub>𝔽</sub>，则返回 *1*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-monthfromtime" type="abstract operation" oldids="eqn-MonthFromTime,sec-month-number">
        <h1>
          MonthFromTime (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *11*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在月份。*+0*<sub>𝔽</sub> 表示一月，*1*<sub>𝔽</sub> 表示二月，*2*<sub>𝔽</sub> 表示三月，*3*<sub>𝔽</sub> 表示四月，*4*<sub>𝔽</sub> 表示五月，*5*<sub>𝔽</sub> 表示六月，*6*<sub>𝔽</sub> 表示七月，*7*<sub>𝔽</sub> 表示八月，*8*<sub>𝔽</sub> 表示九月，*9*<sub>𝔽</sub> 表示十月，*10*<sub>𝔽</sub> 表示十一月，*11*<sub>𝔽</sub> 表示十二月。注意 <emu-eqn>MonthFromTime(*+0*<sub>𝔽</sub>) = *+0*<sub>𝔽</sub></emu-eqn>，对应 1970 年 1 月 1 日星期四。</dd>
        </dl>
        <emu-alg>
          1. 令 _inLeapYear_ 为 InLeapYear(_t_)。
          1. 令 _dayWithinYear_ 为 DayWithinYear(_t_)。
          1. 若 _dayWithinYear_ &lt; *31*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *59*<sub>𝔽</sub> + _inLeapYear_，返回 *1*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *90*<sub>𝔽</sub> + _inLeapYear_，返回 *2*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *120*<sub>𝔽</sub> + _inLeapYear_，返回 *3*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *151*<sub>𝔽</sub> + _inLeapYear_，返回 *4*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *181*<sub>𝔽</sub> + _inLeapYear_，返回 *5*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *212*<sub>𝔽</sub> + _inLeapYear_，返回 *6*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *243*<sub>𝔽</sub> + _inLeapYear_，返回 *7*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *273*<sub>𝔽</sub> + _inLeapYear_，返回 *8*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *304*<sub>𝔽</sub> + _inLeapYear_，返回 *9*<sub>𝔽</sub>。
          1. 若 _dayWithinYear_ &lt; *334*<sub>𝔽</sub> + _inLeapYear_，返回 *10*<sub>𝔽</sub>。
          1. 断言：_dayWithinYear_ &lt; *365*<sub>𝔽</sub> + _inLeapYear_。
          1. 返回 *11*<sub>𝔽</sub>。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-datefromtime" type="abstract operation" oldids="sec-date-number">
        <h1>
          DateFromTime (
            _t_: 有限时间值,
          ): 区间 *1*<sub>𝔽</sub> 至 *31*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在月份的日期。</dd>
        </dl>
        <emu-alg>
          1. 令 _inLeapYear_ 为 InLeapYear(_t_)。
          1. 令 _dayWithinYear_ 为 DayWithinYear(_t_)。
          1. 令 _month_ 为 MonthFromTime(_t_)。
          1. 若 _month_ 为 *+0*<sub>𝔽</sub>，返回 _dayWithinYear_ + *1*<sub>𝔽</sub>。
          1. 若 _month_ 为 *1*<sub>𝔽</sub>，返回 _dayWithinYear_ - *30*<sub>𝔽</sub>。
          1. 若 _month_ 为 *2*<sub>𝔽</sub>，返回 _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *3*<sub>𝔽</sub>，返回 _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *4*<sub>𝔽</sub>，返回 _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *5*<sub>𝔽</sub>，返回 _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *6*<sub>𝔽</sub>，返回 _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *7*<sub>𝔽</sub>，返回 _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *8*<sub>𝔽</sub>，返回 _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *9*<sub>𝔽</sub>，返回 _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_。
          1. 若 _month_ 为 *10*<sub>𝔽</sub>，返回 _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_。
          1. 断言：_month_ 为 *11*<sub>𝔽</sub>。
          1. 返回 _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weekday" type="abstract operation" oldids="sec-week-day">
        <h1>
          WeekDay (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *6*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在星期的星期几。*+0*<sub>𝔽</sub> 表示星期天，*1*<sub>𝔽</sub> 表示星期一，*2*<sub>𝔽</sub> 表示星期二，*3*<sub>𝔽</sub> 表示星期三，*4*<sub>𝔽</sub> 表示星期四，*5*<sub>𝔽</sub> 表示星期五，*6*<sub>𝔽</sub> 表示星期六。注意 <emu-eqn>WeekDay(*+0*<sub>𝔽</sub>) = *4*<sub>𝔽</sub></emu-eqn>，对应 1970 年 1 月 1 日星期四。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) 模 7)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hourfromtime" type="abstract operation" oldids="eqn-HourFromTime,sec-hours-minutes-second-and-milliseconds">
        <h1>
          HourFromTime (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *23*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在日期的小时。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(floor(ℝ(_t_ / msPerHour)) 模 HoursPerDay)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-minfromtime" type="abstract operation" oldids="eqn-MinFromTime">
        <h1>
          MinFromTime (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *59*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在小时的分钟。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(floor(ℝ(_t_ / msPerMinute)) 模 MinutesPerHour)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-secfromtime" type="abstract operation" oldids="eqn-SecFromTime">
        <h1>
          SecFromTime (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *59*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在分钟的秒数。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(floor(ℝ(_t_ / msPerSecond)) 模 SecondsPerMinute)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-msfromtime" type="abstract operation" oldids="eqn-msFromTime">
        <h1>
          msFromTime (
            _t_: 有限时间值,
          ): 区间 *+0*<sub>𝔽</sub> 至 *999*<sub>𝔽</sub>（含）的整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _t_ 所在秒的毫秒数。</dd>
        </dl>
        <emu-alg>
          1. 返回 𝔽(ℝ(_t_) 模 ℝ(msPerSecond))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getutcepochnanoseconds" type="abstract operation">
        <h1>
          GetUTCEpochNanoseconds (
            _year_: 整数,
            _month_: 区间 1 到 12 内的整数,
            _day_: 区间 1 到 31 内的整数,
            _hour_: 区间 0 到 23 内的整数,
            _minute_: 区间 0 到 59 内的整数,
            _second_: 区间 0 到 59 内的整数,
            _millisecond_: 区间 0 到 999 内的整数,
            _microsecond_: 区间 0 到 999 内的整数,
            _nanosecond_: 区间 0 到 999 内的整数,
          ): BigInt
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回值表示自纪元起的纳秒数，对应给定 ISO 8601 日历日期和 UTC 挂钟时间。</dd>
        </dl>
        <emu-alg>
          1. 令 _date_ 为 MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_))。
          1. 令 _time_ 为 MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_))。
          1. 令 _ms_ 为 MakeDate(_date_, _time_)。
          1. 断言：_ms_ 是整数 Number。
          1. 返回 ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifiers">
        <h1>时区标识符</h1>

        <p>
          ECMAScript 中的时区由 <dfn variants="time zone identifier">时区标识符</dfn> 表示，是完全由码元在 0x0000 到 0x007F 区间组成的字符串。
          ECMAScript 支持的时区可以是 <dfn variants="available named time zone">可用命名时区</dfn>，其由 AvailableNamedTimeZoneIdentifiers 返回的时区标识符记录的 [[Identifier]] 字段表示，或是 <dfn variants="offset time zone">偏移时区</dfn>，其由 IsTimeZoneOffsetString 返回 *true* 的字符串表示。
        </p>
        <p>
          <dfn variants="primary time zone identifiers">主时区标识符</dfn>是可用命名时区的首选标识符。
          <dfn variants="non-primary time zone identifiers">非主时区标识符</dfn>是可用命名时区的非主标识符。
          <dfn variants="available named time zone identifiers">可用命名时区标识符</dfn>是主时区标识符或非主时区标识符中的一种。
          每个可用命名时区标识符只关联一个可用命名时区。
          每个可用命名时区只关联一个主时区标识符和零个或多个非主时区标识符。
        </p>
        <p>
          ECMAScript 实现必须支持标识符为 *"UTC"* 的可用命名时区，并且该标识符必须是 UTC 时区的主时区标识符。
          此外，实现可以支持任意数量的其他可用命名时区。
        </p>
        <p>
          遵循 ECMA-402 国际化 API 规范描述的时区要求的实现称为 <dfn>具备时区感知</dfn>。
          具备时区感知的实现必须支持与 IANA 时区数据库的 Zone 和 Link 名称相对应的可用命名时区，并且仅支持这些名称。
          在具备时区感知的实现中，主时区标识符是 Zone 名称，非主时区标识符是 Link 名称（除非被 ECMA-402 规范中的 AvailableNamedTimeZoneIdentifiers 特别覆盖）。
          不支持完整 IANA 时区数据库的实现仍建议使用 IANA 时区数据库名称作为时区标识符。
        </p>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneepochnanoseconds" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneEpochNanoseconds (
            _timeZoneIdentifier_: 字符串,
            _year_: 整数,
            _month_: 区间 1 到 12 内的整数,
            _day_: 区间 1 到 31 内的整数,
            _hour_: 区间 0 到 23 内的整数,
            _minute_: 区间 0 到 59 内的整数,
            _second_: 区间 0 到 59 内的整数,
            _millisecond_: 区间 0 到 999 内的整数,
            _microsecond_: 区间 0 到 999 内的整数,
            _nanosecond_: 区间 0 到 999 内的整数,
          ): BigInt 列表
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>
            返回的列表中的每个值表示自纪元起的纳秒数，对应以 _timeZoneIdentifier_ 标识的命名时区中的 ISO 8601 日历日期和挂钟时间。
          </dd>
        </dl>
        <p>
          当输入表示由于负时区变更（如夏令时结束或时区规则调整导致偏移减少）而某本地时间出现多次时，返回的列表会有多个元素，并按数值升序排序。
          当输入表示由于正时区变更（如夏令时开始或时区规则调整导致偏移增加）而某本地时间被跳过时，返回的列表为空。
          否则返回的列表只有一个元素。
        </p>
        <p>未包含任何时区本地规则的 ECMAScript 实现的默认实现步骤如下：</p>
        <emu-alg>
          1. 断言：_timeZoneIdentifier_ 为 *"UTC"*。
          1. 令 _epochNanoseconds_ 为 GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_)。
          1. 返回 « _epochNanoseconds_ »。
        </emu-alg>
        <emu-note>
          <p>时区感知实现（也推荐所有实现）需使用 IANA 时区数据库 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> 的时区信息。</p>
          <p>2017 年 11 月 5 日 1:30 AM 在 America/New_York 出现两次，因此 GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 11, 5, 1, 30, 0, 0, 0, 0) 会返回一个长度为 2 的列表，第一项表示 05:30 UTC（对应美国东部夏令时 UTC-04:00），第二项表示 06:30 UTC（对应美国东部标准时 UTC-05:00）。</p>
          <p>2017 年 3 月 12 日 2:30 AM 在 America/New_York 不存在，因此 GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 3, 12, 2, 30, 0, 0, 0, 0) 会返回空列表。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneoffsetnanoseconds" oldids="sec-local-time-zone-adjustment" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneOffsetNanoseconds (
            _timeZoneIdentifier_: 字符串,
            _epochNanoseconds_: BigInt,
          ): 整数
        </h1>
        <dl class="header">
        </dl>
        <p>返回的整数表示由 _timeZoneIdentifier_ 标识的命名时区，在与 _epochNanoseconds_ 相对应的时刻相对纪元的 UTC 偏移（单位为纳秒）。</p>
        <p>未包含任何时区本地规则的 ECMAScript 实现的默认实现步骤如下：</p>
        <emu-alg>
          1. 断言：_timeZoneIdentifier_ 为 *"UTC"*。
          1. 返回 0。
        </emu-alg>
        <emu-note>
          <p>时区偏移值可能为正或负。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifier-record">
        <h1>时区标识符记录</h1>
        <p><dfn variants="Time Zone Identifier Records">时区标识符记录</dfn>是用于描述可用命名时区标识符及其对应主时区标识符的记录。</p>
        <p>时区标识符记录具有 <emu-xref href="#table-time-zone-identifier-record-fields"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-time-zone-identifier-record-fields" caption="时区标识符记录字段">
          <table>
            <thead>
              <tr>
                <th>字段名</th>
                <th>值</th>
                <th>含义</th>
              </tr>
            </thead>
            <tr>
              <td>[[Identifier]]</td>
              <td>字符串</td>
              <td>实现支持的可用命名时区标识符。</td>
            </tr>
            <tr>
              <td>[[PrimaryIdentifier]]</td>
              <td>字符串</td>
              <td>[[Identifier]] 解析到的主时区标识符。</td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>若 [[Identifier]] 是主时区标识符，则 [[Identifier]] 即 [[PrimaryIdentifier]]。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-availablenamedtimezoneidentifiers" type="implementation-defined abstract operation">
        <h1>AvailableNamedTimeZoneIdentifiers ( ): 时区标识符记录列表</h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>
            结果描述此实现中所有可用命名时区标识符，以及每个可用命名时区标识符对应的主时区标识符。列表按每个时区标识符记录的 [[Identifier]] 字段排序。
          </dd>
        </dl>
        <p>
          具备时区感知的实现（包括所有实现 ECMA-402 国际化 API 的实现）必须按 ECMA-402 规范实现 AvailableNamedTimeZoneIdentifiers 抽象操作。
          对于不具备时区感知的实现，AvailableNamedTimeZoneIdentifiers 的默认步骤如下：
        </p>
        <emu-alg>
          1. 如果实现未包含任何时区本地规则，
            1. 返回 « 时区标识符记录 { [[Identifier]]: *"UTC"*, [[PrimaryIdentifier]]: *"UTC"* } »。
          1. 令 _identifiers_ 为唯一可用命名时区标识符列表，按字典码元顺序排序。
          1. 令 _result_ 为新空列表。
          1. 对每个 _identifier_ 元素，
            1. 令 _primary_ 为 _identifier_。
            1. 如果 _identifier_ 是此实现的非主时区标识符且不是 *"UTC"*，
              1. 将 _primary_ 设为与 _identifier_ 关联的主时区标识符。
              1. 注：实现可能需迭代解析 _identifier_ 以获得主时区标识符。
            1. 令 _record_ 为时区标识符记录 { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }。
            1. 将 _record_ 添加到 _result_。
          1. 断言：_result_ 包含时区标识符记录 _r_，使得 _r_.[[Identifier]] 为 *"UTC"* 且 _r_.[[PrimaryIdentifier]] 为 *"UTC"*。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-systemtimezoneidentifier" oldids="sec-defaulttimezone" type="implementation-defined abstract operation">
        <h1>SystemTimeZoneIdentifier ( ): 字符串</h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>
            返回代表宿主环境当前时区的字符串，该字符串要么是 IsTimeZoneOffsetString 返回 *true* 的 UTC 偏移字符串，要么是主时区标识符。
          </dd>
        </dl>

        <emu-alg>
          1. 如果实现仅支持 UTC 时区，返回 *"UTC"*。
          1. 令 _systemTimeZoneString_ 为代表宿主环境当前时区的字符串（主时区标识符或偏移时区标识符）。
          1. 返回 _systemTimeZoneString_。
        </emu-alg>

        <emu-note>
          <p>
            为确保实现常见 Date 对象方法的功能，建议 SystemTimeZoneIdentifier 返回宿主环境时区设置对应的 IANA 时区名（如存在）。
            GetNamedTimeZoneEpochNanoseconds 和 GetNamedTimeZoneOffsetNanoseconds 必须反映该时区标准时间和夏令时的本地政治规则（如有）。
          </p>
          <p>例如，若宿主环境为设置为美国东部时间的浏览器，则 SystemTimeZoneIdentifier 返回 *"America/New_York"*。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-localtime" type="abstract operation">
        <h1>
          LocalTime (
            _t_: 有限时间值,
          ): 整数 Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>
            将 _t_ 从 UTC 转换为本地时间。
            应根据本地标准时间和夏令时的政治规则来确定结果，如本节所述。
          </dd>
        </dl>
        <emu-alg>
          1. 令 _systemTimeZoneIdentifier_ 为 SystemTimeZoneIdentifier()。
          1. 如果 IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) 为 *true*，
            1. 令 _offsetNs_ 为 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)。
          1. 否则，
            1. 令 _offsetNs_ 为 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>))。
          1. 令 _offsetMs_ 为 truncate(_offsetNs_ / 10<sup>6</sup>)。
          1. 返回 _t_ + 𝔽(_offsetMs_)。
        </emu-alg>
        <emu-note>
          <p>若实现无法获得本地时间 _t_ 的政治规则，则结果为 _t_，因为 SystemTimeZoneIdentifier 返回 *"UTC"* 且 GetNamedTimeZoneOffsetNanoseconds 返回 0。</p>
        </emu-note>
        <emu-note>
          <p>时区感知实现（也推荐所有实现）需使用 IANA 时区数据库 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> 的时区信息。</p>
        </emu-note>
        <emu-note>
          <p>在负时区变更（如夏令时结束或时区调整减小时）发生重复时间时，两个不同输入时间值 <emu-eqn>_t_<sub>UTC</sub></emu-eqn> 会被转换为同一本地时间 <emu-eqn>t<sub>local</sub></emu-eqn>。<emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> 不一定等于 <emu-eqn>_t_<sub>local</sub></emu-eqn>，同理 <emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> 也不一定等于 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" type="abstract operation">
        <h1>
          UTC (
            _t_: Number,
          ): 时间值
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>
            将 _t_ 从本地时间转换为 UTC 时间值。
            应根据本地标准时间和夏令时的政治规则来确定结果，如本节所述。
          </dd>
        </dl>
        <emu-alg>
          1. 若 _t_ 非有限，返回 *NaN*。
          1. 令 _systemTimeZoneIdentifier_ 为 SystemTimeZoneIdentifier()。
          1. 如果 IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) 为 *true*，
            1. 令 _offsetNs_ 为 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)。
          1. 否则，
            1. 令 _possibleInstants_ 为 GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0)。
            1. 注：下列步骤确保 _t_ 表示在负时区变更（如夏令时结束或时区调整减小时）中重复出现的本地时间或在正时区变更（如夏令时开始或时区调整增大时）中被跳过的本地时间时，_t_ 按变更前的时区偏移解读。
            1. 若 _possibleInstants_ 非空，
              1. 令 _disambiguatedInstant_ 为 _possibleInstants_[0]。
            1. 否则，
              1. 注：_t_ 表示在正时区变更时被跳过的本地时间（如夏令时开始或时区调整增大）。
              1. [declared="tBefore"] 令 _possibleInstantsBefore_ 为 GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0)，其中 _tBefore_ 为小于 _t_ 的最大整数 Number，且 _possibleInstantsBefore_ 非空（即 _tBefore_ 为变更前的最后本地时间）。
              1. 令 _disambiguatedInstant_ 为 _possibleInstantsBefore_ 的最后一项。
            1. 令 _offsetNs_ 为 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_)。
          1. 令 _offsetMs_ 为 truncate(_offsetNs_ / 10<sup>6</sup>)。
          1. 返回 _t_ - 𝔽(_offsetMs_)。
        </emu-alg>
        <p>
          输入 _t_ 名义上为时间值，但可为任意 Number。
          算法不得限制 _t_ 在时间值范围，使得无论本地 UTC 偏移如何，都可支持对应时间值范围边界的输入。
          例如，最大时间值为 8.64 × 10<sup>15</sup>，对应 *"+275760-09-13T00:00:00Z"*。
          若本地时区偏移在该时刻为 UTC+1 小时，则对应更大的输入 8.64 × 10<sup>15</sup> + 3.6 × 10<sup>6</sup>，即 *"+275760-09-13T01:00:00+01:00"*。
        </p>
        <p>若实现无法获得本地时间 _t_ 的政治规则，则结果为 _t_，因为 SystemTimeZoneIdentifier 返回 *"UTC"* 且 GetNamedTimeZoneOffsetNanoseconds 返回 0。</p>
        <emu-note>
          <p>时区感知实现（也推荐所有实现）需使用 IANA 时区数据库 <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a> 的时区信息。</p>
          <p>
            2017 年 11 月 5 日 1:30 AM 在 America/New_York 出现两次（回拨），但应按 UTC-04 而不是 UTC-05 解释。
            在 UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0)))) 中，_offsetMs_ 的值为 <emu-eqn>-4 × msPerHour</emu-eqn>。
          </p>
          <p>
            2017 年 3 月 12 日 2:30 AM 在 America/New_York 不存在，但应按 UTC-05（等价于 UTC-04 的 3:30 AM）解释。
            在 UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0)))) 中，_offsetMs_ 的值为 <emu-eqn>-5 × msPerHour</emu-eqn>。
          </p>
        </emu-note>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> 不一定等于 <emu-eqn>_t_<sub>UTC</sub></emu-eqn>，同理 <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> 也不一定等于 <emu-eqn>_t_<sub>local</sub></emu-eqn>。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-maketime" type="abstract operation">
        <h1>
          MakeTime (
            _hour_: Number,
            _min_: Number,
            _sec_: Number,
            _ms_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>计算毫秒数。</dd>
        </dl>
        <emu-alg>
          1. 若 _hour_、_min_、_sec_、_ms_ 任一非有限，返回 *NaN*。
          1. 令 _h_ 为 𝔽(! ToIntegerOrInfinity(_hour_))。
          1. 令 _m_ 为 𝔽(! ToIntegerOrInfinity(_min_))。
          1. 令 _s_ 为 𝔽(! ToIntegerOrInfinity(_sec_))。
          1. 令 _milli_ 为 𝔽(! ToIntegerOrInfinity(_ms_))。
          1. 返回 ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_。
        </emu-alg>
        <emu-note>
          <p>MakeTime 的算术为浮点运算，非结合律，须按正确顺序执行。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-makeday" type="abstract operation">
        <h1>
          MakeDay (
            _year_: Number,
            _month_: Number,
            _date_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>计算天数。</dd>
        </dl>
        <emu-alg>
          1. 若 _year_、_month_、_date_ 任一非有限，返回 *NaN*。
          1. 令 _y_ 为 𝔽(! ToIntegerOrInfinity(_year_))。
          1. 令 _m_ 为 𝔽(! ToIntegerOrInfinity(_month_))。
          1. 令 _dt_ 为 𝔽(! ToIntegerOrInfinity(_date_))。
          1. 令 _ym_ 为 _y_ + 𝔽(floor(ℝ(_m_) / 12))。
          1. 若 _ym_ 非有限，返回 *NaN*。
          1. 令 _mn_ 为 𝔽(ℝ(_m_) 模 12)。
          1. 找到 YearFromTime(_t_) 为 _ym_、MonthFromTime(_t_) 为 _mn_、DateFromTime(_t_) 为 *1*<sub>𝔽</sub> 的有限时间值 _t_；若不可行（如参数越界），返回 *NaN*。
          1. 返回 Day(_t_) + _dt_ - *1*<sub>𝔽</sub>。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makedate" type="abstract operation">
        <h1>
          MakeDate (
            _day_: Number,
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>计算毫秒数。</dd>
        </dl>
        <emu-alg>
          1. 若 _day_ 或 _time_ 非有限，返回 *NaN*。
          1. 令 _tv_ 为 _day_ × msPerDay + _time_。
          1. 若 _tv_ 非有限，返回 *NaN*。
          1. 返回 _tv_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makefullyear" type="abstract operation">
        <h1>
          MakeFullYear (
            _year_: Number,
          ): 整数 Number 或 *NaN*
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>返回 _year_ 的整数部分所对应的完整年份，若值在 0 到 99 区间，则按自 1900 年起计数。为与前推公历对齐，"完整年份"定义为自公元前 1 年起的完整年数（即自 0 年起的有符号年数）。</dd>
        </dl>
        <emu-alg>
          1. 若 _year_ 为 *NaN*，返回 *NaN*。
          1. 令 _truncated_ 为 ! ToIntegerOrInfinity(_year_)。
          1. 若 _truncated_ 在 0 到 99 区间，返回 *1900*<sub>𝔽</sub> + 𝔽(_truncated_)。
          1. 返回 𝔽(_truncated_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timeclip" type="abstract operation">
        <h1>
          TimeClip (
            _time_: Number,
          ): Number
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>计算毫秒数。</dd>
        </dl>
        <emu-alg>
          1. 若 _time_ 非有限，返回 *NaN*。
          1. 若 abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>，返回 *NaN*。
          1. 返回 𝔽(! ToIntegerOrInfinity(_time_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-time-string-format">
        <h1>日期时间字符串格式</h1>
        <p>ECMAScript 定义了一种基于 ISO 8601 日历日期扩展格式的日期时间字符串交换格式。格式如下：`YYYY-MM-DDTHH:mm:ss.sssZ`</p>
        <p>各元素说明如下：</p>
        <figure>
          <table class="lightweight-table">
            <tr>
              <td>
                `YYYY`
              </td>
              <td>
                公历年份，四位十进制数字，范围 0000 到 9999，或 <emu-xref href="#sec-expanded-years">扩展年份</emu-xref>，即 *"+"* 或 *"-"* 加六位数字。
              </td>
            </tr>
            <tr>
              <td>
                `-`
              </td>
              <td>
                *"-"*（连字符）在字符串中出现两次。
              </td>
            </tr>
            <tr>
              <td>
                `MM`
              </td>
              <td>
                月份，两位十进制数字，01（1月）到 12（12月）。
              </td>
            </tr>
            <tr>
              <td>
                `DD`
              </td>
              <td>
                日期，两位十进制数字，01 到 31。
              </td>
            </tr>
            <tr>
              <td>
                `T`
              </td>
              <td>
                *"T"* 字面出现，表示时间部分开始。
              </td>
            </tr>
            <tr>
              <td>
                `HH`
              </td>
              <td>
                自零点起经过的完整小时数，两位十进制数字，00 到 24。
              </td>
            </tr>
            <tr>
              <td>
                `:`
              </td>
              <td>
                *":"*（冒号）在字符串中出现两次。
              </td>
            </tr>
            <tr>
              <td>
                `mm`
              </td>
              <td>
                小时开始起经过的完整分钟数，两位十进制数字，00 到 59。
              </td>
            </tr>
            <tr>
              <td>
                `ss`
              </td>
              <td>
                分钟开始起经过的完整秒数，两位十进制数字，00 到 59。
              </td>
            </tr>
            <tr>
              <td>
                `.`
              </td>
              <td>
                *"."*（点）字面出现。
              </td>
            </tr>
            <tr>
              <td>
                `sss`
              </td>
              <td>
                秒开始起经过的完整毫秒数，三位十进制数字。
              </td>
            </tr>
            <tr>
              <td>
                `Z`
              </td>
              <td>
                UTC 偏移表示，*"Z"*（无偏移的 UTC），或 *"+"* 或 *"-"* 加时间表达式 `HH:mm`（用于表示本地时间领先或落后 UTC，属于 <emu-xref href="#sec-time-zone-offset-strings">时区偏移字符串格式</emu-xref> 的子集）。
              </td>
            </tr>
          </table>
        </figure>
        <p>该格式还包括仅日期形式：</p>
        <pre>
YYYY
YYYY-MM
YYYY-MM-DD
        </pre>
        <p>也包括“日期-时间”形式，即上述日期形式紧接以下时间形式之一并可选加偏移：</p>
        <pre>
THH:mm
THH:mm:ss
THH:mm:ss.sss
        </pre>
        <p>包含越界或不符合规范元素的字符串不是本格式的有效实例。</p>
        <emu-note>
          <p>由于每一天既有开始也有结束的零点，`00:00` 和 `24:00` 两种记法都可用于区分同一天的两个零点。比如 `1995-02-04T24:00` 与 `1995-02-05T00:00` 表示同一时刻。这种将后者解释为“日终”与 ISO 8601 一致，尽管该规范仅用于时间区间，不用于单一时刻。</p>
        </emu-note>
        <emu-note>
          <p>国际上不存在民用时区缩写（如 CET、EST 等）的标准，有时同一缩写可表示不同时区。因此，ISO 8601 及本格式均采用数字型偏移表示时区。</p>
        </emu-note>

        <emu-clause id="sec-expanded-years" oldids="sec-extended-years">
          <h1>扩展年份</h1>
          <p>覆盖约 273,790 年前后（自 1970 年 1 月 1 日起，见 <emu-xref href="#sec-time-values-and-time-range"></emu-xref>）的完整时间值范围需表示 0 年之前或 9999 年之后的年份。ISO 8601 允许年份扩展，但仅限信息交换双方协商采用。简化的 ECMAScript 格式规定扩展年份为 6 位数字，前缀为 + 或 -。年份 0 视为正数，必须加 + 前缀。-000000 形式无效。超出时间值范围的扩展年份字符串被 <emu-xref href="#sec-date.parse">`Date.parse`</emu-xref> 视为不可识别，返回 *NaN*，不会退回实现特定行为或启发式处理。</p>
          <emu-note>
            <p>扩展年份示例：</p>
            <figure>
              <table class="lightweight-table">
                <tr>
                  <td>-271821-04-20T00:00:00Z</td>
                  <td>公元前 271822 年</td>
                </tr>
                <tr>
                  <td>-000001-01-01T00:00:00Z</td>
                  <td>公元前 2 年</td>
                </tr>
                <tr>
                  <td>+000000-01-01T00:00:00Z</td>
                  <td>公元前 1 年</td>
                </tr>
                <tr>
                  <td>+000001-01-01T00:00:00Z</td>
                  <td>公元 1 年</td>
                </tr>
                <tr>
                  <td>+001970-01-01T00:00:00Z</td>
                  <td>公元 1970 年</td>
                </tr>
                <tr>
                  <td>+002009-12-15T00:00:00Z</td>
                  <td>公元 2009 年</td>
                </tr>
                <tr>
                  <td>+275760-09-13T00:00:00Z</td>
                  <td>公元 275760 年</td>
                </tr>
              </table>
            </figure>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-time-zone-offset-strings">
        <h1>时区偏移字符串格式</h1>

        <p>
          ECMAScript 定义了用于 UTC 偏移的字符串交换格式，源自 ISO 8601。
          格式描述如下语法。
        </p>

        <h2>语法</h2>
        <emu-grammar type="definition">
          UTCOffset :::
            ASCIISign Hour
            ASCIISign Hour HourSubcomponents[+Extended]
            ASCIISign Hour HourSubcomponents[~Extended]

          ASCIISign ::: one of
            `+` `-`

          Hour :::
            `0` DecimalDigit
            `1` DecimalDigit
            `20`
            `21`
            `22`
            `23`

          HourSubcomponents[Extended] :::
            TimeSeparator[?Extended] MinuteSecond
            TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction?

          TimeSeparator[Extended] :::
            [+Extended] `:`
            [~Extended] [empty]

          MinuteSecond :::
            `0` DecimalDigit
            `1` DecimalDigit
            `2` DecimalDigit
            `3` DecimalDigit
            `4` DecimalDigit
            `5` DecimalDigit

          TemporalDecimalFraction :::
            TemporalDecimalSeparator DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

          TemporalDecimalSeparator ::: one of
            `.` `,`
        </emu-grammar>

        <emu-clause id="sec-istimezoneoffsetstring" type="abstract operation">
          <h1>
            IsTimeZoneOffsetString (
              _offsetString_: 字符串,
            ): 布尔值
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>返回值表示 _offsetString_ 是否符合 |UTCOffset| 语法。</dd>
          </dl>
          <emu-alg>
            1. 令 _parseResult_ 为 ParseText(_offsetString_, |UTCOffset|)。
            1. 若 _parseResult_ 为错误列表，返回 *false*。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parsetimezoneoffsetstring" type="abstract operation">
          <h1>
            ParseTimeZoneOffsetString (
              _offsetString_: 字符串,
            ): 整数
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>返回值为与字符串 _offsetString_ 对应的 UTC 偏移（单位纳秒）。</dd>
          </dl>
          <emu-alg>
            1. 令 _parseResult_ 为 ParseText(_offsetString_, |UTCOffset|)。
            1. 断言：_parseResult_ 非错误列表。
            1. 断言：_parseResult_ 包含 |ASCIISign| 解析节点。
            1. 令 _parsedSign_ 为 _parseResult_ 内 |ASCIISign| 解析节点匹配的源文本。
            1. 若 _parsedSign_ 为 U+002D（连字符），
              1. 令 _sign_ 为 -1。
            1. 否则，
              1. 令 _sign_ 为 1。
            1. 注：下列 StringToNumber 应用不会丢精度，因为每个解析值均为短数字字符串。
            1. 断言：_parseResult_ 包含 |Hour| 解析节点。
            1. 令 _parsedHours_ 为 _parseResult_ 内 |Hour| 解析节点匹配的源文本。
            1. 令 _hours_ 为 ℝ(StringToNumber(CodePointsToString(_parsedHours_)))。
            1. 若 _parseResult_ 不含 |MinuteSecond| 解析节点，
              1. 令 _minutes_ 为 0。
            1. 否则，
              1. 令 _parsedMinutes_ 为 _parseResult_ 内第一个 |MinuteSecond| 解析节点匹配的源文本。
              1. 令 _minutes_ 为 ℝ(StringToNumber(CodePointsToString(_parsedMinutes_)))。
            1. 若 _parseResult_ 不含两个 |MinuteSecond| 解析节点，
              1. 令 _seconds_ 为 0。
            1. 否则，
              1. 令 _parsedSeconds_ 为 _parseResult_ 内第二个 |MinuteSecond| 解析节点匹配的源文本。
              1. 令 _seconds_ 为 ℝ(StringToNumber(CodePointsToString(_parsedSeconds_)))。
            1. 若 _parseResult_ 不含 |TemporalDecimalFraction| 解析节点，
              1. 令 _nanoseconds_ 为 0。
            1. 否则，
              1. 令 _parsedFraction_ 为 _parseResult_ 内 |TemporalDecimalFraction| 解析节点匹配的源文本。
              1. 令 _fraction_ 为 CodePointsToString(_parsedFraction_) 与 *"000000000"* 的字符串拼接。
              1. 令 _nanosecondsString_ 为 _fraction_ 的第 1 到第 10 位子串。
              1. 令 _nanoseconds_ 为 ℝ(StringToNumber(_nanosecondsString_))。
            1. 返回 _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-date-constructor" oldids="this-time-value,sec-thistimevalue,thistimevalue,this-Date-object">
      <h1>Date 构造函数</h1>
      <p>Date 构造函数：</p>
      <ul>
        <li>是 <dfn>%Date%</dfn>。</li>
        <li>是全局对象的 *"Date"* 属性的初始值。</li>
        <li>作为构造函数调用时，会创建并初始化一个新的 Date。</li>
        <li>作为函数而不是构造函数调用时，返回一个表示当前时间（UTC）的字符串。</li>
        <li>是一个行为根据参数数量和类型不同而不同的函数。</li>
        <li>可用作类定义的 `extends` 子句的值。打算继承指定 Date 行为的子类构造函数必须包含对 Date 构造函数的 `super` 调用，以创建并用 [[DateValue]] 内部槽初始化子类实例。</li>
      </ul>

      <emu-clause id="sec-date" oldids="sec-date-constructor-date,sec-date-value,sec-date-year-month-date-hours-minutes-seconds-ms">
        <h1>Date ( ..._values_ )</h1>
        <p>当调用此函数时，执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，
            1. 令 _now_ 为标识当前时间的时间值（UTC）。
            1. 返回 ToDateString(_now_)。
          1. 令 _numberOfArgs_ 为 _values_ 中元素的数量。
          1. 如果 _numberOfArgs_ = 0，
            1. 令 _dv_ 为标识当前时间的时间值（UTC）。
          1. 否则如果 _numberOfArgs_ = 1，
            1. 令 _value_ 为 _values_[0]。
            1. 如果 _value_ 是对象且有 [[DateValue]] 内部槽，
              1. 令 _tv_ 为 _value_.[[DateValue]]。
            1. 否则，
              1. 令 _v_ 为 ? ToPrimitive(_value_)。
              1. 如果 _v_ 是字符串，
                1. 断言：下一步不会出现突然完成，因为 _v_ 是字符串。
                1. 令 _tv_ 为按与 `parse` 方法完全相同的方式解析 _v_ 作为日期的结果（<emu-xref href="#sec-date.parse"></emu-xref>）。
              1. 否则，
                1. 令 _tv_ 为 ? ToNumber(_v_)。
            1. 令 _dv_ 为 TimeClip(_tv_)。
          1. 否则，
            1. 断言：_numberOfArgs_ ≥ 2。
            1. 令 _y_ 为 ? ToNumber(_values_[0])。
            1. 令 _m_ 为 ? ToNumber(_values_[1])。
            1. 如果 _numberOfArgs_ > 2，令 _dt_ 为 ? ToNumber(_values_[2])；否则令 _dt_ 为 *1*<sub>𝔽</sub>。
            1. 如果 _numberOfArgs_ > 3，令 _h_ 为 ? ToNumber(_values_[3])；否则令 _h_ 为 *+0*<sub>𝔽</sub>。
            1. 如果 _numberOfArgs_ > 4，令 _min_ 为 ? ToNumber(_values_[4])；否则令 _min_ 为 *+0*<sub>𝔽</sub>。
            1. 如果 _numberOfArgs_ > 5，令 _s_ 为 ? ToNumber(_values_[5])；否则令 _s_ 为 *+0*<sub>𝔽</sub>。
            1. 如果 _numberOfArgs_ > 6，令 _milli_ 为 ? ToNumber(_values_[6])；否则令 _milli_ 为 *+0*<sub>𝔽</sub>。
            1. 令 _yr_ 为 MakeFullYear(_y_)。
            1. 令 _finalDate_ 为 MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))。
            1. 令 _dv_ 为 TimeClip(UTC(_finalDate_))。
          1. 令 _O_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Date.prototype%"*, « [[DateValue]] »)。
          1. 设置 _O_.[[DateValue]] 为 _dv_。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Date 构造函数的属性</h1>
      <p>Date 构造函数：</p>
      <ul>
        <li>拥有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>拥有一个 *"length"* 属性，其值为 *7*<sub>𝔽</sub>。</li>
        <li>拥有以下属性：</li>
      </ul>

      <emu-clause id="sec-date.now">
        <h1>Date.now ( )</h1>
        <p>此函数返回调用时发生的 UTC 日期和时间的时间值。</p>
      </emu-clause>

      <emu-clause id="sec-date.parse">
        <h1>Date.parse ( _string_ )</h1>
        <p>此函数对其参数应用 ToString 操作符。如果 ToString 结果为突然完成，则立即返回完成记录。否则，此函数将结果字符串解释为日期和时间；它返回一个数字，即对应于该日期和时间的 UTC 时间值。字符串可能会被解释为本地时间、UTC 时间或其他时区的时间，具体取决于字符串内容。该函数首先尝试按照 Date Time String Format（<emu-xref href="#sec-date-time-string-format"></emu-xref>）中描述的格式解析字符串，包括扩展年份。如果字符串不符合该格式，则函数可以回退到任何实现相关的启发式或实现相关的日期格式。不可识别或包含越界格式元素值的字符串会导致此函数返回 *NaN*。</p>
        <p>如果字符串符合 <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>，则使用替代值填补缺失的格式元素。当缺少 `MM` 或 `DD` 元素时，使用 *"01"*；当缺少 `HH`、`mm` 或 `ss` 元素时，使用 *"00"*；当缺少 `sss` 元素时，使用 *"000"*。当缺少 UTC 偏移表示时，仅日期形式按 UTC 时间解释，日期时间形式按本地时间解释。</p>
        <p>如果 `x` 是在某个 ECMAScript 实现中的毫秒部分为零的 Date，则以下所有表达式在该实现中应产生相同的数值，只要所有引用的属性都为初始值：</p>
        <pre><code class="javascript">
          x.valueOf()
          Date.parse(x.toString())
          Date.parse(x.toUTCString())
          Date.parse(x.toISOString())
        </code></pre>
        <p>然而，以下表达式</p>
        <pre><code class="javascript">
          Date.parse(x.toLocaleString())
        </code></pre>
        <p>不要求与前三个表达式产生相同的数值，并且通常当此函数接收到任何不符合 Date Time String Format（<emu-xref href="#sec-date-time-string-format"></emu-xref>）且无法通过该实现的 `toString` 或 `toUTCString` 方法产生的字符串值时，其产生的数值是实现定义的。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype">
        <h1>Date.prototype</h1>
        <p>`Date.prototype` 的初始值为 Date 原型对象。</p>
        <p>该属性具有属性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-date.utc">
        <h1>Date.UTC ( _year_ [ , _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] ] )</h1>
        <p>调用此函数时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _y_ 为 ? ToNumber(_year_)。
          1. 如果 _month_ 存在，令 _m_ 为 ? ToNumber(_month_)；否则令 _m_ 为 *+0*<sub>𝔽</sub>。
          1. 如果 _date_ 存在，令 _dt_ 为 ? ToNumber(_date_)；否则令 _dt_ 为 *1*<sub>𝔽</sub>。
          1. 如果 _hours_ 存在，令 _h_ 为 ? ToNumber(_hours_)；否则令 _h_ 为 *+0*<sub>𝔽</sub>。
          1. 如果 _minutes_ 存在，令 _min_ 为 ? ToNumber(_minutes_)；否则令 _min_ 为 *+0*<sub>𝔽</sub>。
          1. 如果 _seconds_ 存在，令 _s_ 为 ? ToNumber(_seconds_)；否则令 _s_ 为 *+0*<sub>𝔽</sub>。
          1. 如果 _ms_ 存在，令 _milli_ 为 ? ToNumber(_ms_)；否则令 _milli_ 为 *+0*<sub>𝔽</sub>。
          1. 令 _yr_ 为 MakeFullYear(_y_)。
          1. 返回 TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)))。
        </emu-alg>
        <p>此函数的 *"length"* 属性为 *7*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>此函数与 Date 构造函数有两个区别：它返回一个数字类型的时间值，而不是创建一个 Date，并且它以 UTC 解释参数而不是本地时间。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-prototype-object">
      <h1>Date 原型对象的属性</h1>
      <p><dfn>Date 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Date.prototype%</dfn>。</li>
        <li>自身是一个普通对象。</li>
        <li>不是 Date 实例，也没有 [[DateValue]] 内部槽。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>
      <p>除非另有明确定义，下面定义的 Date 原型对象的方法不是泛型的，传递给它们的 *this* 值必须是具有并已初始化为时间值的 [[DateValue]] 内部槽的对象。</p>

      <emu-clause id="sec-date.prototype.constructor">
        <h1>Date.prototype.constructor</h1>
        <p>`Date.prototype.constructor` 的初始值为 %Date%。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getdate">
        <h1>Date.prototype.getDate ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 DateFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getday">
        <h1>Date.prototype.getDay ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 WeekDay(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getfullyear">
        <h1>Date.prototype.getFullYear ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 YearFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gethours">
        <h1>Date.prototype.getHours ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 HourFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmilliseconds">
        <h1>Date.prototype.getMilliseconds ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 msFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getminutes">
        <h1>Date.prototype.getMinutes ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 MinFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmonth">
        <h1>Date.prototype.getMonth ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 MonthFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getseconds">
        <h1>Date.prototype.getSeconds ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 SecFromTime(LocalTime(_t_))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettime">
        <h1>Date.prototype.getTime ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 返回 _dateObject_.[[DateValue]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettimezoneoffset">
        <h1>Date.prototype.getTimezoneOffset ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 (_t_ - LocalTime(_t_)) / msPerMinute。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcdate">
        <h1>Date.prototype.getUTCDate ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 DateFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcday">
        <h1>Date.prototype.getUTCDay ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 WeekDay(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcfullyear">
        <h1>Date.prototype.getUTCFullYear ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 YearFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutchours">
        <h1>Date.prototype.getUTCHours ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 HourFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmilliseconds">
        <h1>Date.prototype.getUTCMilliseconds ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 msFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcminutes">
        <h1>Date.prototype.getUTCMinutes ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 MinFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmonth">
        <h1>Date.prototype.getUTCMonth ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 MonthFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcseconds">
        <h1>Date.prototype.getUTCSeconds ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 SecFromTime(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setdate">
        <h1>Date.prototype.setDate ( _date_ )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _dt_ 为 ? ToNumber(_date_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 设置 _t_ 为 LocalTime(_t_)。
          1. 令 _newDate_ 为 MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_))。
          1. 令 _u_ 为 TimeClip(UTC(_newDate_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setfullyear">
        <h1>Date.prototype.setFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _y_ 为 ? ToNumber(_year_)。
          1. 如果 _t_ 为 *NaN*，设置 _t_ 为 *+0*<sub>𝔽</sub>；否则设置 _t_ 为 LocalTime(_t_)。
          1. 如果 _month_ 未传入，令 _m_ 为 MonthFromTime(_t_)；否则令 _m_ 为 ? ToNumber(_month_)。
          1. 如果 _date_ 未传入，令 _dt_ 为 DateFromTime(_t_)；否则令 _dt_ 为 ? ToNumber(_date_)。
          1. 令 _newDate_ 为 MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_))。
          1. 令 _u_ 为 TimeClip(UTC(_newDate_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *3*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _month_，该方法表现为 _month_ 取 `getMonth()` 的值。如果未传入 _date_，则表现为 _date_ 取 `getDate()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.sethours">
        <h1>Date.prototype.setHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _h_ 为 ? ToNumber(_hour_)。
          1. 如果传入 _min_，令 _m_ 为 ? ToNumber(_min_)。
          1. 如果传入 _sec_，令 _s_ 为 ? ToNumber(_sec_)。
          1. 如果传入 _ms_，令 _milli_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 设置 _t_ 为 LocalTime(_t_)。
          1. 如果 _min_ 未传入，令 _m_ 为 MinFromTime(_t_)。
          1. 如果 _sec_ 未传入，令 _s_ 为 SecFromTime(_t_)。
          1. 如果 _ms_ 未传入，令 _milli_ 为 msFromTime(_t_)。
          1. 令 _date_ 为 MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_))。
          1. 令 _u_ 为 TimeClip(UTC(_date_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *4*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _min_，该方法表现为 _min_ 取 `getMinutes()` 的值。如果未传入 _sec_，表现为 _sec_ 取 `getSeconds()` 的值。如果未传入 _ms_，表现为 _ms_ 取 `getMilliseconds()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmilliseconds">
        <h1>Date.prototype.setMilliseconds ( _ms_ )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 设置 _ms_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 设置 _t_ 为 LocalTime(_t_)。
          1. 令 _time_ 为 MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_)。
          1. 令 _u_ 为 TimeClip(UTC(MakeDate(Day(_t_), _time_)))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setminutes">
        <h1>Date.prototype.setMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _m_ 为 ? ToNumber(_min_)。
          1. 如果传入 _sec_，令 _s_ 为 ? ToNumber(_sec_)。
          1. 如果传入 _ms_，令 _milli_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 设置 _t_ 为 LocalTime(_t_)。
          1. 如果 _sec_ 未传入，令 _s_ 为 SecFromTime(_t_)。
          1. 如果 _ms_ 未传入，令 _milli_ 为 msFromTime(_t_)。
          1. 令 _date_ 为 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_))。
          1. 令 _u_ 为 TimeClip(UTC(_date_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *3*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _sec_，该方法表现为 _sec_ 取 `getSeconds()` 的值。如果未传入 _ms_，表现为 _ms_ 取 `getMilliseconds()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmonth">
        <h1>Date.prototype.setMonth ( _month_ [ , _date_ ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _m_ 为 ? ToNumber(_month_)。
          1. 如果传入 _date_，令 _dt_ 为 ? ToNumber(_date_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 设置 _t_ 为 LocalTime(_t_)。
          1. 如果 _date_ 未传入，令 _dt_ 为 DateFromTime(_t_)。
          1. 令 _newDate_ 为 MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_))。
          1. 令 _u_ 为 TimeClip(UTC(_newDate_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *2*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _date_，该方法表现为 _date_ 取 `getDate()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setseconds">
        <h1>Date.prototype.setSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _s_ 为 ? ToNumber(_sec_)。
          1. 如果传入 _ms_，令 _milli_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 设置 _t_ 为 LocalTime(_t_)。
          1. 如果 _ms_ 未传入，令 _milli_ 为 msFromTime(_t_)。
          1. 令 _date_ 为 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_))。
          1. 令 _u_ 为 TimeClip(UTC(_date_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _u_。
          1. 返回 _u_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *2*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _ms_，该方法表现为 _ms_ 取 `getMilliseconds()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.settime">
        <h1>Date.prototype.setTime ( _time_ )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 ? ToNumber(_time_)。
          1. 令 _v_ 为 TimeClip(_t_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcdate">
        <h1>Date.prototype.setUTCDate ( _date_ )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _dt_ 为 ? ToNumber(_date_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 令 _newDate_ 为 MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_))。
          1. 令 _v_ 为 TimeClip(_newDate_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcfullyear">
        <h1>Date.prototype.setUTCFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _t_ 为 *NaN*，设置 _t_ 为 *+0*<sub>𝔽</sub>。
          1. 令 _y_ 为 ? ToNumber(_year_)。
          1. 如果 _month_ 未传入，令 _m_ 为 MonthFromTime(_t_)；否则令 _m_ 为 ? ToNumber(_month_)。
          1. 如果 _date_ 未传入，令 _dt_ 为 DateFromTime(_t_)；否则令 _dt_ 为 ? ToNumber(_date_)。
          1. 令 _newDate_ 为 MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_))。
          1. 令 _v_ 为 TimeClip(_newDate_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *3*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _month_，该方法表现为 _month_ 取 `getUTCMonth()` 的值。如果未传入 _date_，则表现为 _date_ 取 `getUTCDate()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutchours">
        <h1>Date.prototype.setUTCHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _h_ 为 ? ToNumber(_hour_)。
          1. 如果传入 _min_，令 _m_ 为 ? ToNumber(_min_)。
          1. 如果传入 _sec_，令 _s_ 为 ? ToNumber(_sec_)。
          1. 如果传入 _ms_，令 _milli_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 如果 _min_ 未传入，令 _m_ 为 MinFromTime(_t_)。
          1. 如果 _sec_ 未传入，令 _s_ 为 SecFromTime(_t_)。
          1. 如果 _ms_ 未传入，令 _milli_ 为 msFromTime(_t_)。
          1. 令 _date_ 为 MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_))。
          1. 令 _v_ 为 TimeClip(_date_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *4*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _min_，该方法表现为 _min_ 取 `getUTCMinutes()` 的值。如果未传入 _sec_，表现为 _sec_ 取 `getUTCSeconds()` 的值。如果未传入 _ms_，表现为 _ms_ 取 `getUTCMilliseconds()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmilliseconds">
        <h1>Date.prototype.setUTCMilliseconds ( _ms_ )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 设置 _ms_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 令 _time_ 为 MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_)。
          1. 令 _v_ 为 TimeClip(MakeDate(Day(_t_), _time_))。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcminutes">
        <h1>Date.prototype.setUTCMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _m_ 为 ? ToNumber(_min_)。
          1. 如果传入 _sec_，令 _s_ 为 ? ToNumber(_sec_)。
          1. 如果传入 _ms_，令 _milli_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 如果 _sec_ 未传入，令 _s_ 为 SecFromTime(_t_)。
          1. 如果 _ms_ 未传入，令 _milli_ 为 msFromTime(_t_)。
          1. 令 _date_ 为 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_))。
          1. 令 _v_ 为 TimeClip(_date_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *3*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _sec_，该方法表现为 _sec_ 取 `getUTCSeconds()` 的值。如果未传入 _ms_，表现为 _ms_ 取 `getUTCMilliseconds()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmonth">
        <h1>Date.prototype.setUTCMonth ( _month_ [ , _date_ ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _m_ 为 ? ToNumber(_month_)。
          1. 如果传入 _date_，令 _dt_ 为 ? ToNumber(_date_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 如果 _date_ 未传入，令 _dt_ 为 DateFromTime(_t_)。
          1. 令 _newDate_ 为 MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_))。
          1. 令 _v_ 为 TimeClip(_newDate_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *2*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _date_，该方法表现为 _date_ 取 `getUTCDate()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcseconds">
        <h1>Date.prototype.setUTCSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _s_ 为 ? ToNumber(_sec_)。
          1. 如果传入 _ms_，令 _milli_ 为 ? ToNumber(_ms_)。
          1. 如果 _t_ 为 *NaN*，返回 *NaN*。
          1. 如果 _ms_ 未传入，令 _milli_ 为 msFromTime(_t_)。
          1. 令 _date_ 为 MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_))。
          1. 令 _v_ 为 TimeClip(_date_)。
          1. 设置 _dateObject_.[[DateValue]] 为 _v_。
          1. 返回 _v_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *2*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>如果未传入 _ms_，该方法表现为 _ms_ 取 `getUTCMilliseconds()` 的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.todatestring">
        <h1>Date.prototype.toDateString ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _tv_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _tv_ 为 *NaN*，返回 *"Invalid Date"*。
          1. 令 _t_ 为 LocalTime(_tv_)。
          1. 返回 DateString(_t_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toisostring">
        <h1>Date.prototype.toISOString ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _tv_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _tv_ 为 *NaN*，抛出 *RangeError* 异常。
          1. 断言：_tv_ 是整数类型的数字。
          1. 如果 _tv_ 对应的年份无法在 <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> 中表示，抛出 *RangeError* 异常。
          1. 返回 _tv_ 在 UTC 时间轴上的 <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> 字符串表示，包括所有格式元素和 UTC 偏移表示 *"Z"*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tojson">
        <h1>Date.prototype.toJSON ( _key_ )</h1>
        <p>此方法为 `JSON.stringify` (<emu-xref href="#sec-json.stringify"></emu-xref>) 提供 Date 的字符串表示。</p>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 ? ToObject(*this* 值)。
          1. 令 _tv_ 为 ? ToPrimitive(_O_, ~number~)。
          1. 如果 _tv_ 是数字且不是有限值，返回 *null*。
          1. 返回 ? Invoke(_O_, *"toISOString"*)。
        </emu-alg>
        <emu-note>
          <p>参数会被忽略。</p>
        </emu-note>
        <emu-note>
          <p>此方法有意设计为泛型；它不要求其 *this* 值为 Date。因此，它可以被转移到其他类型的对象上作为方法使用。但要求该对象有 `toISOString` 方法。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaledatestring">
        <h1>Date.prototype.toLocaleDateString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范：</p>
        <p>此方法返回一个字符串值。字符串内容由实现定义，但旨在以主机环境当前区域设置的习惯用法，以便捷、易读的方式表示当前时区中的 Date 的“日期”部分。</p>
        <p>此方法的可选参数含义在 ECMA-402 规范中定义；不支持 ECMA-402 的实现不得在这些参数位置使用其他含义。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocalestring">
        <h1>Date.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范：</p>
        <p>此方法返回一个字符串值。字符串内容由实现定义，但旨在以主机环境当前区域设置的习惯用法，以便捷、易读的方式表示当前时区中的 Date。</p>
        <p>此方法的可选参数含义在 ECMA-402 规范中定义；不支持 ECMA-402 的实现不得在这些参数位置使用其他含义。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaletimestring">
        <h1>Date.prototype.toLocaleTimeString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按照 ECMA-402 规范实现此方法。如果 ECMAScript 实现不包含 ECMA-402 API，则使用以下规范：</p>
        <p>此方法返回一个字符串值。字符串内容由实现定义，但旨在以主机环境当前区域设置的习惯用法，以便捷、易读的方式表示当前时区中的 Date 的“时间”部分。</p>
        <p>此方法的可选参数含义在 ECMA-402 规范中定义；不支持 ECMA-402 的实现不得在这些参数位置使用其他含义。</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _tv_ 为 _dateObject_.[[DateValue]]。
          1. 返回 ToDateString(_tv_)。
        </emu-alg>
        <emu-note>
          <p>对于任何 Date `d`，只要 `d.[[DateValue]]` 能被 1000 整除，则 `Date.parse(d.toString())` = `d.valueOf()`，详见 <emu-xref href="#sec-date.parse"></emu-xref>。</p>
        </emu-note>
        <emu-note>
          <p>此方法不是泛型的；如果 *this* 值不是 Date，则抛出 *TypeError* 异常。因此，不能将其作为方法转移到其他类型对象。</p>
        </emu-note>

        <emu-clause id="sec-timestring" type="abstract operation">
          <h1>
            TimeString (
              _tv_: 一个数字，但不是 *NaN*,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _hour_ 为 ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2)。
            1. 令 _minute_ 为 ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2)。
            1. 令 _second_ 为 ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2)。
            1. 返回 _hour_、*":"*、_minute_、*":"*、_second_、码元 0x0020（空格）、*"GMT"* 的字符串拼接结果。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-datestring" type="abstract operation">
          <h1>
            DateString (
              _tv_: 一个数字，但不是 *NaN*,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _weekday_ 为 <emu-xref href="#sec-todatestring-day-names"></emu-xref> 中 WeekDay(_tv_) 的 Name。
            1. 令 _month_ 为 <emu-xref href="#sec-todatestring-month-names"></emu-xref> 中 MonthFromTime(_tv_) 的 Name。
            1. 令 _day_ 为 ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2)。
            1. 令 _yv_ 为 YearFromTime(_tv_)。
            1. 如果 _yv_ 为 *+0*<sub>𝔽</sub> 或 _yv_ > *+0*<sub>𝔽</sub>，令 _yearSign_ 为空字符串；否则令 _yearSign_ 为 *"-"*。
            1. 令 _paddedYear_ 为 ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4)。
            1. 返回 _weekday_、码元 0x0020（空格）、_month_、码元 0x0020（空格）、_day_、码元 0x0020（空格）、_yearSign_、_paddedYear_ 的字符串拼接结果。
          </emu-alg>
          <emu-table id="sec-todatestring-day-names" caption="一周中各天的名称">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sun"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mon"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Tue"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Wed"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"Thu"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Fri"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sat"*
                </td>
              </tr>
            </table>
          </emu-table>
          <emu-table id="sec-todatestring-month-names" caption="一年中各月的名称">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jan"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Feb"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mar"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Apr"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"May"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jun"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jul"*
                </td>
              </tr>
              <tr>
                <td>
                  *7*<sub>𝔽</sub>
                </td>
                <td>
                  *"Aug"*
                </td>
              </tr>
              <tr>
                <td>
                  *8*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sep"*
                </td>
              </tr>
              <tr>
                <td>
                  *9*<sub>𝔽</sub>
                </td>
                <td>
                  *"Oct"*
                </td>
              </tr>
              <tr>
                <td>
                  *10*<sub>𝔽</sub>
                </td>
                <td>
                  *"Nov"*
                </td>
              </tr>
              <tr>
                <td>
                  *11*<sub>𝔽</sub>
                </td>
                <td>
                  *"Dec"*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>

        <emu-clause id="sec-timezoneestring" type="abstract operation">
          <h1>
            TimeZoneString (
              _tv_: 一个整数类型的数字,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _systemTimeZoneIdentifier_ 为 SystemTimeZoneIdentifier()。
            1. 如果 IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) 是 *true*，
              1. 令 _offsetNs_ 为 ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_)。
            1. 否则，
              1. 令 _offsetNs_ 为 GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>))。
            1. 令 _offset_ 为 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>))。
            1. 如果 _offset_ 为 *+0*<sub>𝔽</sub> 或 _offset_ > *+0*<sub>𝔽</sub>，
              1. 令 _offsetSign_ 为 *"+"*。
              1. 令 _absOffset_ 为 _offset_。
            1. 否则，
              1. 令 _offsetSign_ 为 *"-"*。
              1. 令 _absOffset_ 为 -_offset_。
            1. 令 _offsetMin_ 为 ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2)。
            1. 令 _offsetHour_ 为 ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2)。
            1. 令 _tzName_ 为实现定义的字符串，可以为空字符串，也可以是码元 0x0020（空格）、码元 0x0028（左括号）、实现定义的时区名称和码元 0x0029（右括号）拼接的字符串。
            1. 返回 _offsetSign_、_offsetHour_、_offsetMin_、_tzName_ 的字符串拼接结果。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-todatestring" type="abstract operation">
          <h1>
            ToDateString (
              _tv_: 一个整数类型的数字或 *NaN*,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _tv_ 为 *NaN*，返回 *"Invalid Date"*。
            1. 令 _t_ 为 LocalTime(_tv_)。
            1. 返回 DateString(_t_)、码元 0x0020（空格）、TimeString(_t_)、TimeZoneString(_tv_) 的字符串拼接结果。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-date.prototype.totimestring">
        <h1>Date.prototype.toTimeString ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _tv_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _tv_ 为 *NaN*，返回 *"Invalid Date"*。
          1. 令 _t_ 为 LocalTime(_tv_)。
          1. 返回 TimeString(_t_) 和 TimeZoneString(_tv_) 的字符串拼接结果。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toutcstring">
        <h1>Date.prototype.toUTCString ( )</h1>
        <p>此方法返回一个字符串值，表示与 *this* 值对应的时间点。字符串格式基于 RFC 7231 的 "HTTP-date"，并加以泛化以支持 ECMAScript Date 支持的完整时间范围。</p>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _tv_ 为 _dateObject_.[[DateValue]]。
          1. 如果 _tv_ 为 *NaN*，返回 *"Invalid Date"*。
          1. 令 _weekday_ 为 <emu-xref href="#sec-todatestring-day-names"></emu-xref> 中 WeekDay(_tv_) 的 Name。
          1. 令 _month_ 为 <emu-xref href="#sec-todatestring-month-names"></emu-xref> 中 MonthFromTime(_tv_) 的 Name。
          1. 令 _day_ 为 ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2)。
          1. 令 _yv_ 为 YearFromTime(_tv_)。
          1. 如果 _yv_ 为 *+0*<sub>𝔽</sub> 或 _yv_ > *+0*<sub>𝔽</sub>，令 _yearSign_ 为空字符串；否则令 _yearSign_ 为 *"-"*。
          1. 令 _paddedYear_ 为 ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4)。
          1. 返回 _weekday_、*","*、码元 0x0020（空格）、_day_、码元 0x0020（空格）、_month_、码元 0x0020（空格）、_yearSign_、_paddedYear_、码元 0x0020（空格）、TimeString(_tv_) 的字符串拼接结果。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.valueof">
        <h1>Date.prototype.valueOf ( )</h1>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 返回 _dateObject_.[[DateValue]]。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-date.prototype-@@toprimitive" id="sec-date.prototype-%symbol.toprimitive%">
        <h1>Date.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>此方法由 ECMAScript 语言运算符调用，用于将 Date 转换为原始值。_hint_ 的允许值为 *"default"*、*"number"* 和 *"string"*。Date 在所有内建 ECMAScript 对象中是独特的，因为它将 *"default"* 视为等同于 *"string"*，而其他内建对象则将 *"default"* 视为等同于 *"number"*。</p>
        <p>调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是对象，抛出 *TypeError* 异常。
          1. 如果 _hint_ 是 *"string"* 或 *"default"*，
            1. 令 _tryFirst_ 为 ~string~。
          1. 否则如果 _hint_ 是 *"number"*，
            1. 令 _tryFirst_ 为 ~number~。
          1. 否则，
            1. 抛出 *TypeError* 异常。
          1. 返回 ? OrdinaryToPrimitive(_O_, _tryFirst_)。
        </emu-alg>
        <p>此属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 属性。</p>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.toPrimitive]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-date-instances">
      <h1>Date 实例的属性</h1>
      <p>Date 实例是普通对象，继承自 Date 原型对象的属性。Date 实例还拥有 [[DateValue]] 内部槽。[[DateValue]] 内部槽是该 Date 所表示的时间值。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>文本处理</h1>

  <emu-clause id="sec-string-objects">
    <h1>String 对象</h1>

    <emu-clause id="sec-string-constructor">
      <h1>String 构造函数</h1>
      <p>String 构造函数：</p>
      <ul>
        <li>是 <dfn>%String%</dfn>。</li>
        <li>是全局对象 *"String"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 String 对象。</li>
        <li>作为函数而非构造函数调用时执行类型转换。</li>
        <li>可用作类定义中 `extends` 子句的值。打算继承指定 String 行为的子类构造函数必须包含对 String 构造函数的 `super` 调用，以使用 [[StringData]] 内部槽创建并初始化子类实例。</li>
      </ul>

      <emu-clause id="sec-string-constructor-string-value">
        <h1>String ( _value_ )</h1>
        <p>调用该函数时执行以下步骤：</p>
        <emu-alg>
          1. 如果未传入 _value_，则
            1. 令 _s_ 为空字符串。
          1. 否则，
            1. 如果 NewTarget 为 *undefined* 且 _value_ 是一个 Symbol，返回 SymbolDescriptiveString(_value_)。
            1. 令 _s_ 为 ? ToString(_value_)。
          1. 如果 NewTarget 为 *undefined*，返回 _s_。
          1. 返回 StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *"%String.prototype%"*))。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>String 构造函数的属性</h1>
      <p>String 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-string.fromcharcode">
        <h1>String.fromCharCode ( ..._codeUnits_ )</h1>
        <p>此函数可用任意数量的参数调用，这些参数组成剩余参数 _codeUnits_。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _result_ 为空字符串。
          1. 对于 _codeUnits_ 中的每个元素 _next_，执行
            1. 令 _nextCU_ 为数值为 ℝ(? ToUint16(_next_)) 的代码单元。
            1. 将 _result_ 设为 _result_ 与 _nextCU_ 的字符串拼接。
          1. 返回 _result_。
        </emu-alg>
        <p>该函数的 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-string.fromcodepoint">
        <h1>String.fromCodePoint ( ..._codePoints_ )</h1>
        <p>此函数可用任意数量的参数调用，这些参数组成剩余参数 _codePoints_。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _result_ 为空字符串。
          1. 对于 _codePoints_ 中的每个元素 _next_，执行
            1. 令 _nextCP_ 为 ? ToNumber(_next_)。
            1. 如果 _nextCP_ 不是整数数值，抛出 *RangeError* 异常。
            1. 如果 ℝ(_nextCP_) &lt; 0 或 ℝ(_nextCP_) > 0x10FFFF，抛出 *RangeError* 异常。
            1. 将 _result_ 设为 _result_ 与 UTF16EncodeCodePoint(ℝ(_nextCP_)) 的字符串拼接。
          1. 断言：若 _codePoints_ 为空，则 _result_ 为空字符串。
          1. 返回 _result_。
        </emu-alg>
        <p>该函数的 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype">
        <h1>String.prototype</h1>
        <p>`String.prototype` 的初始值是 String 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-string.raw">
        <h1>String.raw ( _template_, ..._substitutions_ )</h1>
        <p>此函数可用可变数量参数调用。第一个参数为 _template_，其余参数构成列表 _substitutions_。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _substitutionCount_ 为 _substitutions_ 中元素数量。
          1. 令 _cooked_ 为 ? ToObject(_template_)。
          1. 令 _literals_ 为 ? ToObject(? Get(_cooked_, *"raw"*))。
          1. 令 _literalCount_ 为 ? LengthOfArrayLike(_literals_)。
          1. 若 _literalCount_ ≤ 0，返回空字符串。
          1. 令 _R_ 为空字符串。
          1. 令 _nextIndex_ 为 0。
          1. 重复，
            1. 令 _nextLiteralVal_ 为 ? Get(_literals_, ! ToString(𝔽(_nextIndex_)))。
            1. 令 _nextLiteral_ 为 ? ToString(_nextLiteralVal_)。
            1. 将 _R_ 设为 _R_ 与 _nextLiteral_ 的字符串拼接。
            1. 若 _nextIndex_ + 1 = _literalCount_，返回 _R_。
            1. 若 _nextIndex_ &lt; _substitutionCount_，则
              1. 令 _nextSubVal_ 为 _substitutions_[_nextIndex_]。
              1. 令 _nextSub_ 为 ? ToString(_nextSubVal_)。
              1. 将 _R_ 设为 _R_ 与 _nextSub_ 的字符串拼接。
            1. 将 _nextIndex_ 设为 _nextIndex_ + 1。
        </emu-alg>
        <emu-note>
          <p>此函数旨在作为标记模板（<emu-xref href="#sec-tagged-templates"></emu-xref>）的标签函数使用。如此调用时，第一个参数将是格式正确的模板对象，剩余参数包含替换值。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>String 原型对象的属性</h1>
      <p><dfn>String 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%String.prototype%</dfn>。</li>
        <li>是一个 String 特异（exotic）对象，并具有为此类对象指定的内部方法。</li>
        <li>有一个 [[StringData]] 内部槽，其值为空字符串。</li>
        <li>有一个 *"length"* 属性，其初始值为 *+0*<sub>𝔽</sub>，属性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>
      <p>除非另有明确说明，下面定义的 String 原型对象的方法不是泛型的，传入的 *this* 值必须是一个 String 值或者具有已初始化为某个 String 值的 [[StringData]] 内部槽的对象。</p>

      <emu-clause id="sec-string.prototype.at">
        <h1>String.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _relativeIndex_ 为 ? ToIntegerOrInfinity(_index_)。
          1. 如果 _relativeIndex_ ≥ 0，则
            1. 令 _k_ 为 _relativeIndex_。
          1. 否则，
            1. 令 _k_ 为 _len_ + _relativeIndex_。
          1. 若 _k_ &lt; 0 或 _k_ ≥ _len_，返回 *undefined*。
          1. 返回 _S_ 中从 _k_ 到 _k_ + 1 的子串。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charat">
        <h1>String.prototype.charAt ( _pos_ )</h1>
        <emu-note>
          <p>该方法返回一个包含在将此对象转换为 String 后所得字符串中索引 _pos_ 处代码单元的单元素字符串。如果该索引处无元素，则结果为空字符串。结果是 String 值，而非 String 对象。</p>
          <p>如果 `pos` 是整数数值，则 `x.charAt(pos)` 的结果等价于 `x.substring(pos, pos + 1)` 的结果。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _position_ 为 ? ToIntegerOrInfinity(_pos_)。
          1. 令 _size_ 为 _S_ 的长度。
          1. 若 _position_ &lt; 0 或 _position_ ≥ _size_，返回空字符串。
          1. 返回 _S_ 中从 _position_ 到 _position_ + 1 的子串。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charcodeat">
        <h1>String.prototype.charCodeAt ( _pos_ )</h1>
        <emu-note>
          <p>该方法返回一个 Number（非负整数且小于 2<sup>16</sup>），表示在将此对象转换为 String 后得到的字符串中索引 _pos_ 处代码单元的数值。如果该索引处无元素，结果为 *NaN*。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _position_ 为 ? ToIntegerOrInfinity(_pos_)。
          1. 令 _size_ 为 _S_ 的长度。
          1. 若 _position_ &lt; 0 或 _position_ ≥ _size_，返回 *NaN*。
          1. 返回在字符串 _S_ 中索引 _position_ 处代码单元的数值对应的 Number 值。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.codepointat">
        <h1>String.prototype.codePointAt ( _pos_ )</h1>
        <emu-note>
          <p>该方法返回一个非负整数 Number（≤ *0x10FFFF*<sub>𝔽</sub>），表示在将此对象转换为 String 后得到的字符串中索引 _pos_ 处起始的 UTF-16 编码代码点（<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）的数值。如果该索引处没有元素，返回 *undefined*。如果在 _pos_ 处没有以有效 UTF-16 代理对开始，则结果为 _pos_ 处的代码单元。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _position_ 为 ? ToIntegerOrInfinity(_pos_)。
          1. 令 _size_ 为 _S_ 的长度。
          1. 若 _position_ &lt; 0 或 _position_ ≥ _size_，返回 *undefined*。
          1. 令 _cp_ 为 CodePointAt(_S_, _position_)。
          1. 返回 𝔽(_cp_.[[CodePoint]])。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.concat">
        <h1>String.prototype.concat ( ..._args_ )</h1>
        <emu-note>
          <p>调用此方法时，它返回一个由 *this* 值（转换为字符串）的代码单元后接每个参数（各自转换为字符串）的代码单元组成的字符串值。结果是一个 String 值，而非 String 对象。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _R_ 为 _S_。
          1. 对于 _args_ 中的每个元素 _next_，执行
            1. 令 _nextString_ 为 ? ToString(_next_)。
            1. 将 _R_ 设为 _R_ 与 _nextString_ 的字符串拼接。
          1. 返回 _R_。
        </emu-alg>
        <p>该方法的 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.constructor">
        <h1>String.prototype.constructor</h1>
        <p>`String.prototype.constructor` 的初始值是 %String%。</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype.endswith">
        <h1>String.prototype.endsWith ( _searchString_ [ , _endPosition_ ] )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _isRegExp_ 为 ? IsRegExp(_searchString_)。
          1. 若 _isRegExp_ 为 *true*，抛出 *TypeError* 异常。
          1. 令 _searchStr_ 为 ? ToString(_searchString_)。
          1. 令 _len_ 为 _S_ 的长度。
          1. 若 _endPosition_ 为 *undefined*，令 _pos_ 为 _len_；否则令 _pos_ 为 ? ToIntegerOrInfinity(_endPosition_)。
          1. 令 _end_ 为将 _pos_ 钳制在 0 和 _len_ 之间的结果。
          1. 令 _searchLength_ 为 _searchStr_ 的长度。
          1. 若 _searchLength_ = 0，返回 *true*。
          1. 令 _start_ 为 _end_ - _searchLength_。
          1. 若 _start_ &lt; 0，返回 *false*。
          1. 令 _substring_ 为 _S_ 中从 _start_ 到 _end_ 的子串。
          1. 若 _substring_ 是 _searchStr_，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>若 _searchString_（转为 String） 的代码单元序列与该对象（转为 String）在 _endPosition_ - length(this) 处开始的对应代码单元相同，则此方法返回 *true*；否则返回 *false*。</p>
        </emu-note>
        <emu-note>
          <p>当第一个参数是 RegExp 时抛出异常是为了允许未来版本定义允许此类参数值的扩展。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.includes">
        <h1>String.prototype.includes ( _searchString_ [ , _position_ ] )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _isRegExp_ 为 ? IsRegExp(_searchString_)。
          1. 若 _isRegExp_ 为 *true*，抛出 *TypeError* 异常。
          1. 令 _searchStr_ 为 ? ToString(_searchString_)。
          1. 令 _pos_ 为 ? ToIntegerOrInfinity(_position_)。
          1. 断言：如果 _position_ 为 *undefined*，则 _pos_ 为 0。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _start_ 为将 _pos_ 钳制在 0 和 _len_ 之间的结果。
          1. 令 _index_ 为 StringIndexOf(_S_, _searchStr_, _start_)。
          1. 若 _index_ 为 ~not-found~，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>如果 _searchString_ 作为 <emu-not-ref>substring</emu-not-ref> 出现在将该对象转换为 String 的结果中，并且其至少一个出现位置索引 ≥ _position_，则该函数返回 *true*；否则返回 *false*。若 _position_ 为 *undefined*，则视为 0，因此搜索全部字符串。</p>
        </emu-note>
        <emu-note>
          <p>当第一个参数是 RegExp 时抛出异常是为了允许未来版本定义允许此类参数值的扩展。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.indexof">
        <h1>String.prototype.indexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>如果 _searchString_ 作为 <emu-not-ref>substring</emu-not-ref> 出现在将该对象转换为 String 的结果中，并且至少一个出现位置索引 ≥ _position_，则返回最小的此类索引；否则返回 *-1*<sub>𝔽</sub>。若 _position_ 为 *undefined*，则视为 *+0*<sub>𝔽</sub>，以便搜索整个字符串。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _searchStr_ 为 ? ToString(_searchString_)。
          1. 令 _pos_ 为 ? ToIntegerOrInfinity(_position_)。
          1. 断言：如果 _position_ 为 *undefined*，则 _pos_ 为 0。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _start_ 为将 _pos_ 钳制在 0 和 _len_ 之间的结果。
          1. 令 _result_ 为 StringIndexOf(_S_, _searchStr_, _start_)。
          1. 若 _result_ 为 ~not-found~，返回 *-1*<sub>𝔽</sub>。
          1. 返回 𝔽(_result_)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.iswellformed">
        <h1>String.prototype.isWellFormed ( )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 返回 IsStringWellFormedUnicode(_S_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.lastindexof">
        <h1>String.prototype.lastIndexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>如果 _searchString_ 作为 <emu-not-ref>substring</emu-not-ref> 出现在将该对象转换为 String 的结果中，且出现位置索引 ≤ _position_，则返回最大的此类索引；否则返回 *-1*<sub>𝔽</sub>。若 _position_ 为 *undefined*，则视为该字符串长度，以便搜索整个字符串。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _searchStr_ 为 ? ToString(_searchString_)。
          1. 令 _numPos_ 为 ? ToNumber(_position_)。
          1. 断言：若 _position_ 为 *undefined*，则 _numPos_ 为 *NaN*。
          1. 若 _numPos_ 为 *NaN*，令 _pos_ 为 +∞；否则令 _pos_ 为 ! ToIntegerOrInfinity(_numPos_)。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _searchLen_ 为 _searchStr_ 的长度。
          1. 令 _start_ 为将 _pos_ 钳制在 0 和 _len_ - _searchLen_ 之间的结果。
          1. 令 _result_ 为 StringLastIndexOf(_S_, _searchStr_, _start_)。
          1. 若 _result_ 为 ~not-found~，返回 *-1*<sub>𝔽</sub>。
          1. 返回 𝔽(_result_)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象，因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.localecompare">
        <h1>String.prototype.localeCompare ( _that_ [ , _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 的规范实现此方法。若不包含，则使用下述规范：</p>
        <p>此方法返回一个非 *NaN* 的 Number，表示将 *this* 值（转换为字符串 _S_）与 _that_（转换为字符串 _thatValue_）进行实现定义的、对区域敏感的字符串比较的结果。该结果意图与宿主环境当前区域设置的字符串排序规则一致：当 _S_ 排在 _thatValue_ 之前时为负，排在之后时为正，其他情况为零（表示 _S_ 与 _thatValue_ 之间无相对次序）。</p>
        <p>在执行比较前，此方法进行以下准备步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _thatValue_ 为 ? ToString(_that_)。
        </emu-alg>
        <p>第二与第三可选参数的含义在 ECMA-402 规范中定义；不包含 ECMA-402 支持的实现不得为这些参数位置赋予其他含义。</p>
        <p>实际返回值是实现定义的，以允许编码附加信息；但是当该方法视作二元比较器使用时，必须定义所有字符串集合上的一个总排序。该方法还必须识别并遵循 Unicode 标准中的规范等价（canonical equivalence），包括在比较可区分但规范等价的字符串时返回 *+0*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>该方法本身不适合作为 `Array.prototype.sort` 的参数，因为后者需要一个二元函数。</p>
        </emu-note>
        <emu-note>
          <p>该方法可依赖宿主环境提供的语言或区域敏感比较功能，并意图依据宿主环境当前区域设置的习惯比较。然而，无论比较能力如何，该方法必须识别并遵循 Unicode 标准的规范等价——例如以下比较都必须返回 *+0*<sub>𝔽</sub>：</p>
          <pre><code class="javascript">
            // &#x212B; ANGSTROM SIGN vs.
            // A&#x030A; LATIN CAPITAL LETTER A + COMBINING RING ABOVE
            "\u212B".localeCompare("A\u030A")

            // &#x2126; OHM SIGN vs.
            // &#x03A9; GREEK CAPITAL LETTER OMEGA
            "\u2126".localeCompare("\u03A9")

            // &#x1E69; LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
            // s&#x0307;&#x0323; LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
            "\u1E69".localeCompare("s\u0307\u0323")

            // &#x1E0B;&#x0323; LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
            // &#x1E0D;&#x0307; LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
            "\u1E0B\u0323".localeCompare("\u1E0D\u0307")

            // &#x1100;&#x1161; HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
            // &#xAC00; HANGUL SYLLABLE GA
            "\u1100\u1161".localeCompare("\uAC00")
          </code></pre>
          <p>关于规范等价的定义与讨论，参见 Unicode 标准第 2、3 章，以及 <a href="https://unicode.org/reports/tr15/">Unicode Standard Annex #15, Unicode Normalization Forms</a> 和 <a href="https://unicode.org/notes/tn5/">Unicode Technical Note #5, Canonical Equivalence in Applications</a>。另参见 <a href="https://unicode.org/reports/tr10/">Unicode Technical Standard #10, Unicode Collation Algorithm</a>。</p>
          <p>建议该方法不应遵循 Unicode 标准第 3 章第 3.7 节中定义的兼容等价或兼容分解。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.match">
        <h1>String.prototype.match ( _regexp_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 若 _regexp_ 既不是 *undefined* 也不是 *null*，则
            1. 令 _matcher_ 为 ? GetMethod(_regexp_, %Symbol.match%)。
            1. 若 _matcher_ 不为 *undefined*，则
              1. 返回 ? Call(_matcher_, _regexp_, « _O_ »)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _rx_ 为 ? RegExpCreate(_regexp_, *undefined*)。
          1. 返回 ? Invoke(_rx_, %Symbol.match%, « _S_ »)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 值不要求为 String 对象。因此可转移到其他对象类型上作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.matchall">
        <h1>String.prototype.matchAll ( _regexp_ )</h1>
        <p>该方法对表示 *this* 值的字符串执行正则表达式匹配并返回一个产出匹配结果的迭代器。每个匹配结果是一个数组，其首元素为匹配的子串，后续元素为任意捕获组匹配的部分。若正则表达式从未匹配，则返回的迭代器不产出任何匹配结果。</p>
        <p>调用时执行以下步骤：</p>

        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 若 _regexp_ 既不是 *undefined* 也不是 *null*，则
            1. 令 _isRegExp_ 为 ? IsRegExp(_regexp_)。
            1. 若 _isRegExp_ 为 *true*，则
              1. 令 _flags_ 为 ? Get(_regexp_, *"flags"*)。
              1. 执行 ? RequireObjectCoercible(_flags_)。
              1. 若 ? ToString(_flags_) 不包含 *"g"*，抛出 *TypeError* 异常。
            1. 令 _matcher_ 为 ? GetMethod(_regexp_, %Symbol.matchAll%)。
            1. 若 _matcher_ 不为 *undefined*，则
              1. 返回 ? Call(_matcher_, _regexp_, « _O_ »)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _rx_ 为 ? RegExpCreate(_regexp_, *"g"*)。
          1. 返回 ? Invoke(_rx_, %Symbol.matchAll%, « _S_ »)。
        </emu-alg>
        <emu-note>该方法特意设计为泛型，不要求其 *this* 值为 String 对象。因此可转移到其他对象类型上使用。</emu-note>
        <emu-note>与 `String.prototype.split` 相似，`String.prototype.matchAll` 被设计为通常不修改其输入。</emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.normalize">
        <h1>String.prototype.normalize ( [ _form_ ] )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 若 _form_ 为 *undefined*，令 _f_ 为 *"NFC"*。
          1. 否则，令 _f_ 为 ? ToString(_form_)。
          1. 若 _f_ 不在 *"NFC"*、*"NFD"*、*"NFKC"*、*"NFKD"* 之一中，抛出 *RangeError* 异常。
          1. 令 _ns_ 为将 _S_ 归一化为由 _f_ 命名的标准化形式所得的字符串值（参见 <a href="https://www.unicode.org/versions/latest/ch03.pdf">最新 Unicode 标准 - 归一化形式</a>）。
          1. 返回 _ns_。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可以转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padend">
        <h1>String.prototype.padEnd ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 返回 ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padstart">
        <h1>String.prototype.padStart ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 返回 ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~)。
        </emu-alg>

        <emu-clause id="sec-stringpaddingbuiltinsimpl" type="abstract operation">
          <h1>
            StringPaddingBuiltinsImpl (
              _O_: 一个 ECMAScript 语言值,
              _maxLength_: 一个 ECMAScript 语言值,
              _fillString_: 一个 ECMAScript 语言值,
              _placement_: ~start~ 或 ~end~,
            ): 返回包含一个字符串的普通完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _S_ 为 ? ToString(_O_)。
            1. 令 _intMaxLength_ 为 ℝ(? ToLength(_maxLength_))。
            1. 令 _stringLength_ 为 _S_ 的长度。
            1. 若 _intMaxLength_ ≤ _stringLength_，返回 _S_。
            1. 若 _fillString_ 为 *undefined*，将 _fillString_ 设为仅包含代码单元 0x0020 (SPACE) 的字符串。
            1. 否则，将 _fillString_ 设为 ? ToString(_fillString_)。
            1. 返回 StringPad(_S_, _intMaxLength_, _fillString_, _placement_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-stringpad" type="abstract operation">
          <h1>
            StringPad (
              _S_: 一个字符串,
              _maxLength_: 非负整数,
              _fillString_: 一个字符串,
              _placement_: ~start~ 或 ~end~,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _stringLength_ 为 _S_ 的长度。
            1. 若 _maxLength_ ≤ _stringLength_，返回 _S_。
            1. 若 _fillString_ 为空字符串，返回 _S_。
            1. 令 _fillLen_ 为 _maxLength_ - _stringLength_。
            1. 令 _truncatedStringFiller_ 为由重复拼接 _fillString_ 直至截断到长度 _fillLen_ 得到的字符串。
            1. 若 _placement_ 为 ~start~，返回 _truncatedStringFiller_ 与 _S_ 的字符串拼接。
            1. 否则，返回 _S_ 与 _truncatedStringFiller_ 的字符串拼接。
          </emu-alg>
          <emu-note>
            <p>参数 _maxLength_ 会被钳制，使其不小于 _S_ 的长度。</p>
          </emu-note>
          <emu-note>
            <p>参数 _fillString_ 的默认值为 *" "*（仅包含代码单元 0x0020 SPACE 的字符串）。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-tozeropaddeddecimalstring" type="abstract operation">
          <h1>
            ToZeroPaddedDecimalString (
              _n_: 非负整数,
              _minLength_: 非负整数,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _S_ 为 _n_ 的十进制格式字符串表示。
            1. 返回 StringPad(_S_, _minLength_, *"0"*, ~start~)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.repeat">
        <h1>String.prototype.repeat ( _count_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _n_ 为 ? ToIntegerOrInfinity(_count_)。
          1. 若 _n_ &lt; 0 或 _n_ = +∞，抛出 *RangeError* 异常。
          1. 若 _n_ = 0，返回空字符串。
          1. 返回由 _n_ 个 _S_ 依次拼接而成的字符串值。
        </emu-alg>
        <emu-note>
          <p>此方法创建一个字符串值，其内容为 *this* 值（转换为字符串）重复 _count_ 次。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移至其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replace">
        <h1>String.prototype.replace ( _searchValue_, _replaceValue_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 若 _searchValue_ 既非 *undefined* 也非 *null*，则
            1. 令 _replacer_ 为 ? GetMethod(_searchValue_, %Symbol.replace%)。
            1. 若 _replacer_ 不为 *undefined*，则
              1. 返回 ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »)。
          1. 令 _string_ 为 ? ToString(_O_)。
          1. 令 _searchString_ 为 ? ToString(_searchValue_)。
          1. 令 _functionalReplace_ 为 IsCallable(_replaceValue_)。
          1. 若 _functionalReplace_ 为 *false*，则
            1. 将 _replaceValue_ 设为 ? ToString(_replaceValue_)。
          1. 令 _searchLength_ 为 _searchString_ 的长度。
          1. 令 _position_ 为 StringIndexOf(_string_, _searchString_, 0)。
          1. 若 _position_ 为 ~not-found~，返回 _string_。
          1. 令 _preceding_ 为 _string_ 中从 0 到 _position_ 的子串。
          1. 令 _following_ 为 _string_ 中从 _position_ + _searchLength_ 起的子串。
          1. 若 _functionalReplace_ 为 *true*，则
            1. 令 _replacement_ 为 ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »))。
          1. 否则，
            1. 断言：_replaceValue_ 为字符串。
            1. 令 _captures_ 为一个新的空列表。
            1. 令 _replacement_ 为 ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_)。
          1. 返回 _preceding_、_replacement_、_following_ 的字符串拼接。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型作为方法使用。</p>
        </emu-note>

        <emu-clause id="sec-getsubstitution" type="abstract operation" oldids="table-replacement-text-symbol-substitutions,table-45">
          <h1>
            GetSubstitution (
              _matched_: 字符串,
              _str_: 字符串,
              _position_: 非负整数,
              _captures_: 由字符串或 *undefined* 组成的列表,
              _namedCaptures_: 对象或 *undefined*,
              _replacementTemplate_: 字符串,
            ): 返回包含一个字符串的普通完成或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>在此抽象操作中，<em>十进制数字</em> 指代码单元范围 0x0030 (DIGIT ZERO) 至 0x0039 (DIGIT NINE) 内的任一代码单元。</dd>
          </dl>
          <emu-alg>
            1. 令 _stringLength_ 为 _str_ 的长度。
            1. 断言：_position_ ≤ _stringLength_。
            1. 令 _result_ 为空字符串。
            1. 令 _templateRemainder_ 为 _replacementTemplate_。
            1. 当 _templateRemainder_ 非空字符串时重复，
              1. [declared="ref,refReplacement"] 注：下列步骤提取 _ref_（_templateRemainder_ 的前缀）、确定 _refReplacement_（其替换），然后将替换附加到 _result_。
              1. 若 _templateRemainder_ 以 *"$$"* 开头，则
                1. 令 _ref_ 为 *"$$"*。
                1. 令 _refReplacement_ 为 *"$"*。
              1. 否则若以 *"$`"* 开头，则
                1. 令 _ref_ 为 *"$`"*。
                1. 令 _refReplacement_ 为 _str_ 中从 0 到 _position_ 的子串。
              1. 否则若以 *"$&amp;"* 开头，则
                1. 令 _ref_ 为 *"$&amp;"*。
                1. 令 _refReplacement_ 为 _matched_。
              1. 否则若以 *"$'"*（0x0024 (DOLLAR SIGN) 后接 0x0027 (APOSTROPHE)）开头，则
                1. 令 _ref_ 为 *"$'"*。
                1. 令 _matchLength_ 为 _matched_ 的长度。
                1. 令 _tailPos_ 为 _position_ + _matchLength_。
                1. 令 _refReplacement_ 为 _str_ 中从 min(_tailPos_, _stringLength_) 起的子串。
                1. 注：_tailPos_ 仅当此抽象操作由 %RegExp.prototype% 的本征 %Symbol.replace% 方法被一个 *"exec"* 属性非其本征 %RegExp.prototype.exec% 的对象调用时才可能超过 _stringLength_。
              1. 否则若以 *"$"* 后接 1 个或多个十进制数字开头，则
                1. 若以 *"$"* 后接至少 2 个十进制数字开头，令 _digitCount_ 为 2；否则令 _digitCount_ 为 1。
                1. 令 _digits_ 为 _templateRemainder_ 中从 1 到 1 + _digitCount_ 的子串。
                1. 令 _index_ 为 ℝ(StringToNumber(_digits_))。
                1. 断言：0 ≤ _index_ ≤ 99。
                1. 令 _captureLen_ 为 _captures_ 的元素数量。
                1. 若 _index_ > _captureLen_ 且 _digitCount_ = 2，则
                  1. 注：当两位数字替换模式指定的索引超过捕获组数量时，它被视为一位数字替换模式后随一个字面数字。
                  1. 将 _digitCount_ 设为 1。
                  1. 将 _digits_ 设为 _digits_ 中从 0 到 1 的子串。
                  1. 将 _index_ 设为 ℝ(StringToNumber(_digits_))。
                1. 令 _ref_ 为 _templateRemainder_ 中从 0 到 1 + _digitCount_ 的子串。
                1. 若 1 ≤ _index_ ≤ _captureLen_，则
                  1. 令 _capture_ 为 _captures_[_index_ - 1]。
                  1. 若 _capture_ 为 *undefined*，则
                    1. 令 _refReplacement_ 为空字符串。
                  1. 否则，
                    1. 令 _refReplacement_ 为 _capture_。
                1. 否则，
                  1. 令 _refReplacement_ 为 _ref_。
              1. 否则若以 *"$&lt;"* 开头，则
                1. 令 _gtPos_ 为 StringIndexOf(_templateRemainder_, *">"*, 0)。
                1. 若 _gtPos_ 为 ~not-found~ 或 _namedCaptures_ 为 *undefined*，则
                  1. 令 _ref_ 为 *"$&lt;"*。
                  1. 令 _refReplacement_ 为 _ref_。
                1. 否则，
                  1. 令 _ref_ 为 _templateRemainder_ 中从 0 到 _gtPos_ + 1 的子串。
                  1. 令 _groupName_ 为 _templateRemainder_ 中从 2 到 _gtPos_ 的子串。
                  1. 断言：_namedCaptures_ 是一个对象。
                  1. 令 _capture_ 为 ? Get(_namedCaptures_, _groupName_)。
                  1. 若 _capture_ 为 *undefined*，则
                    1. 令 _refReplacement_ 为空字符串。
                  1. 否则，
                    1. 令 _refReplacement_ 为 ? ToString(_capture_)。
              1. 否则，
                1. 令 _ref_ 为 _templateRemainder_ 中从 0 到 1 的子串。
                1. 令 _refReplacement_ 为 _ref_。
              1. 令 _refLength_ 为 _ref_ 的长度。
              1. 将 _templateRemainder_ 设为其从 _refLength_ 起的子串。
              1. 将 _result_ 设为 _result_ 与 _refReplacement_ 的字符串拼接。
            1. 返回 _result_。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replaceall">
        <h1>String.prototype.replaceAll ( _searchValue_, _replaceValue_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 若 _searchValue_ 既非 *undefined* 也非 *null*，则
            1. 令 _isRegExp_ 为 ? IsRegExp(_searchValue_)。
            1. 若 _isRegExp_ 为 *true*，则
              1. 令 _flags_ 为 ? Get(_searchValue_, *"flags"*)。
              1. 执行 ? RequireObjectCoercible(_flags_)。
              1. 若 ? ToString(_flags_) 不包含 *"g"*，抛出 *TypeError* 异常。
            1. 令 _replacer_ 为 ? GetMethod(_searchValue_, %Symbol.replace%)。
            1. 若 _replacer_ 不为 *undefined*，则
              1. 返回 ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »)。
          1. 令 _string_ 为 ? ToString(_O_)。
          1. 令 _searchString_ 为 ? ToString(_searchValue_)。
          1. 令 _functionalReplace_ 为 IsCallable(_replaceValue_)。
          1. 若 _functionalReplace_ 为 *false*，则
            1. 将 _replaceValue_ 设为 ? ToString(_replaceValue_)。
          1. 令 _searchLength_ 为 _searchString_ 长度。
          1. 令 _advanceBy_ 为 max(1, _searchLength_)。
          1. 令 _matchPositions_ 为新的空列表。
          1. 令 _position_ 为 StringIndexOf(_string_, _searchString_, 0)。
          1. 当 _position_ 非 ~not-found~ 时重复，
            1. 将 _position_ 附加到 _matchPositions_。
            1. 将 _position_ 设为 StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_)。
          1. 令 _endOfLastMatch_ 为 0。
          1. 令 _result_ 为空字符串。
          1. 对于 _matchPositions_ 中的每个元素 _p_，执行
            1. 令 _preserved_ 为 _string_ 中从 _endOfLastMatch_ 到 _p_ 的子串。
            1. 若 _functionalReplace_ 为 *true*，则
              1. 令 _replacement_ 为 ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »))。
            1. 否则，
              1. 断言：_replaceValue_ 为字符串。
              1. 令 _captures_ 为新的空列表。
              1. 令 _replacement_ 为 ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_)。
            1. 将 _result_ 设为 _result_、_preserved_、_replacement_ 的字符串拼接。
            1. 将 _endOfLastMatch_ 设为 _p_ + _searchLength_。
          1. 若 _endOfLastMatch_ &lt; _string_ 的长度，则
            1. 将 _result_ 设为 _result_ 与 _string_ 中从 _endOfLastMatch_ 起的子串的字符串拼接。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.search">
        <h1>String.prototype.search ( _regexp_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 若 _regexp_ 既非 *undefined* 也非 *null*，则
            1. 令 _searcher_ 为 ? GetMethod(_regexp_, %Symbol.search%)。
            1. 若 _searcher_ 不为 *undefined*，则
              1. 返回 ? Call(_searcher_, _regexp_, « _O_ »)。
          1. 令 _string_ 为 ? ToString(_O_)。
          1. 令 _rx_ 为 ? RegExpCreate(_regexp_, *undefined*)。
          1. 返回 ? Invoke(_rx_, %Symbol.search%, « _string_ »)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象。因此可转移到其他对象类型作为方法使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.slice">
        <h1>String.prototype.slice ( _start_, _end_ )</h1>
        <p>该方法返回将此对象转换为字符串后的 <emu-not-ref>substring</emu-not-ref>，起始于索引 _start_，结束于但不包括索引 _end_（若 _end_ 为 *undefined* 则到字符串末尾）。若 _start_ 为负，则视为 <emu-eqn>_sourceLength_ + _start_</emu-eqn>，其中 _sourceLength_ 为字符串长度。若 _end_ 为负，则视为 <emu-eqn>_sourceLength_ + _end_</emu-eqn>。结果是一个字符串值而非 String 对象。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _intStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _intStart_ = -∞，令 _from_ 为 0。
          1. 否则若 _intStart_ &lt; 0，令 _from_ 为 max(_len_ + _intStart_, 0)。
          1. 否则，令 _from_ 为 min(_intStart_, _len_)。
          1. 若 _end_ 为 *undefined*，令 _intEnd_ 为 _len_；否则令 _intEnd_ 为 ? ToIntegerOrInfinity(_end_)。
          1. 若 _intEnd_ = -∞，令 _to_ 为 0。
          1. 否则若 _intEnd_ &lt; 0，令 _to_ 为 max(_len_ + _intEnd_, 0)。
          1. 否则，令 _to_ 为 min(_intEnd_, _len_)。
          1. 若 _from_ ≥ _to_，返回空字符串。
          1. 返回 _S_ 中从 _from_ 到 _to_ 的子串。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.split">
        <h1>String.prototype.split ( _separator_, _limit_ )</h1>
        <p>该方法返回一个数组，其中存放了将此对象转换为字符串后的子串。子串通过自左向右查找 _separator_ 的出现确定；这些出现本身不包含在结果数组的任一字符串中，而是用来分割字符串值。_separator_ 的值可以是任意长度的字符串，也可以是一个对象（如具有 %Symbol.split% 方法的 RegExp）。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 若 _separator_ 既非 *undefined* 也非 *null*，则
            1. 令 _splitter_ 为 ? GetMethod(_separator_, %Symbol.split%)。
            1. 若 _splitter_ 不为 *undefined*，则
              1. 返回 ? Call(_splitter_, _separator_, « _O_, _limit_ »)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 若 _limit_ 为 *undefined*，令 _lim_ 为 2<sup>32</sup> - 1；否则令 _lim_ 为 ℝ(? ToUint32(_limit_))。
          1. 令 _R_ 为 ? ToString(_separator_)。
          1. 若 _lim_ = 0，则
            1. 返回 CreateArrayFromList(« »)。
          1. 若 _separator_ 为 *undefined*，则
            1. 返回 CreateArrayFromList(« _S_ »)。
          1. 令 _separatorLength_ 为 _R_ 的长度。
          1. 若 _separatorLength_ = 0，则
            1. 令 _strLen_ 为 _S_ 的长度。
            1. 令 _outLen_ 为将 _lim_ 钳制在 0 与 _strLen_ 之间的结果。
            1. 令 _head_ 为 _S_ 中从 0 到 _outLen_ 的子串。
            1. 令 _codeUnits_ 为 _head_ 代码单元序列组成的列表。
            1. 返回 CreateArrayFromList(_codeUnits_)。
          1. 若 _S_ 为空字符串，返回 CreateArrayFromList(« _S_ »)。
          1. 令 _substrings_ 为新的空列表。
          1. 令 _i_ 为 0。
          1. 令 _j_ 为 StringIndexOf(_S_, _R_, 0)。
          1. 当 _j_ 非 ~not-found~ 时重复，
            1. 令 _T_ 为 _S_ 中从 _i_ 到 _j_ 的子串。
            1. 将 _T_ 添加至 _substrings_。
            1. 若 _substrings_ 的元素个数为 _lim_，返回 CreateArrayFromList(_substrings_)。
            1. 将 _i_ 设为 _j_ + _separatorLength_。
            1. 将 _j_ 设为 StringIndexOf(_S_, _R_, _i_)。
          1. 令 _T_ 为 _S_ 中自 _i_ 起的子串。
          1. 将 _T_ 添加至 _substrings_。
          1. 返回 CreateArrayFromList(_substrings_)。
        </emu-alg>
        <emu-note>
          <p>_separator_ 的值可以为空字符串。在此情况下，_separator_ 不匹配输入字符串开始或末尾的空 <emu-not-ref>substring</emu-not-ref>，也不匹配前一个分隔符匹配末尾的空 <emu-not-ref>substring</emu-not-ref>。如果 _separator_ 为空字符串，则字符串被拆分为单个代码单元元素；结果数组长度等于字符串长度，每个 <emu-not-ref>substring</emu-not-ref> 含一个代码单元。</p>
          <p>如果 *this* 值（或其转换结果）为空字符串，则结果取决于 _separator_ 是否能匹配空字符串：若能，则结果数组为空；否则数组包含一个元素，即空字符串。</p>
          <p>若 _separator_ 为 *undefined*，结果数组只包含一个字符串，即 *this* 值（转换为 String）。若 _limit_ 非 *undefined*，输出数组会被截断为不超过 _limit_ 个元素。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.startswith">
        <h1>String.prototype.startsWith ( _searchString_ [ , _position_ ] )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _isRegExp_ 为 ? IsRegExp(_searchString_)。
          1. 若 _isRegExp_ 为 *true*，抛出 *TypeError* 异常。
          1. 令 _searchStr_ 为 ? ToString(_searchString_)。
          1. 令 _len_ 为 _S_ 的长度。
          1. 若 _position_ 为 *undefined*，令 _pos_ 为 0；否则令 _pos_ 为 ? ToIntegerOrInfinity(_position_)。
          1. 令 _start_ 为将 _pos_ 钳制在 0 与 _len_ 之间的结果。
          1. 令 _searchLength_ 为 _searchStr_ 的长度。
          1. 若 _searchLength_ = 0，返回 *true*。
          1. 令 _end_ 为 _start_ + _searchLength_。
          1. 若 _end_ > _len_，返回 *false*。
          1. 令 _substring_ 为 _S_ 中从 _start_ 到 _end_ 的子串。
          1. 若 _substring_ 是 _searchStr_，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>若 _searchString_（转换为 String）的代码单元序列与该对象（转换为 String）从索引 _position_ 开始的对应代码单元相同，则该方法返回 *true*；否则返回 *false*。</p>
        </emu-note>
        <emu-note>
          <p>当第一个参数是 RegExp 时抛出异常是为了允许未来版本扩展允许此类参数值。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.substring">
        <h1>String.prototype.substring ( _start_, _end_ )</h1>
        <p>该方法返回将此对象转换为字符串后，从索引 _start_ 开始到（但不包含）索引 _end_（或 _end_ 为 *undefined* 时到字符串末尾）的 <emu-not-ref>substring</emu-not-ref>。结果为字符串值，不是 String 对象。</p>
        <p>若任一参数为 *NaN* 或为负，则替换为 0；若任一参数严格大于字符串长度，则替换为字符串长度。</p>
        <p>若 _start_ 严格大于 _end_，则交换它们。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _intStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _end_ 为 *undefined*，令 _intEnd_ 为 _len_；否则令 _intEnd_ 为 ? ToIntegerOrInfinity(_end_)。
          1. 令 _finalStart_ 为将 _intStart_ 钳制在 0 与 _len_ 之间的结果。
          1. 令 _finalEnd_ 为将 _intEnd_ 钳制在 0 与 _len_ 之间的结果。
          1. 令 _from_ 为 min(_finalStart_, _finalEnd_)。
          1. 令 _to_ 为 max(_finalStart_, _finalEnd_)。
          1. 返回 _S_ 中从 _from_ 到 _to_ 的子串。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocalelowercase">
        <h1>String.prototype.toLocaleLowerCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范实现此方法。若不包含，则使用以下规范：</p>
        <p>此方法将一个字符串值视为 UTF-16 编码代码点序列，参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>。</p>
        <p>其行为与 `toLowerCase` 相同，但意在生成与宿主环境当前区域设置约定相符的对区域敏感结果。只有在少数（如土耳其语）与 Unicode 常规大小写映射冲突的语言情况下，结果才会不同。</p>
        <p>该方法可选参数的含义在 ECMA-402 中定义；未包含 ECMA-402 支持的实现不得对这些参数位置赋予其他含义。</p>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocaleuppercase">
        <h1>String.prototype.toLocaleUpperCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>包含 ECMA-402 国际化 API 的 ECMAScript 实现必须按 ECMA-402 规范实现此方法。若不包含，则使用以下规范：</p>
        <p>此方法将字符串值视为 UTF-16 编码代码点序列（参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。</p>
        <p>其行为与 `toUpperCase` 相同，但意在生成与宿主环境当前区域设置约定相符的对区域敏感结果。仅在少数如土耳其语的情形中，语言规则与常规 Unicode 大小写映射冲突时才会不同。</p>
        <p>该方法可选参数含义由 ECMA-402 规范定义；未包含 ECMA-402 支持的实现不得赋予其他含义。</p>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolowercase">
        <h1>String.prototype.toLowerCase ( )</h1>
        <p>此方法将字符串值视为 UTF-16 编码代码点序列（参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _sText_ 为 StringToCodePoints(_S_)。
          1. 令 _lowerText_ 为依据 Unicode 默认大小写转换算法对 _sText_ 执行 toLowercase 的结果。
          1. 令 _L_ 为 CodePointsToString(_lowerText_)。
          1. 返回 _L_。
        </emu-alg>
        <p>结果必须依据 Unicode 字符数据库中的与区域无关的大小写映射获得（明确包括 <a href="https://unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"><code>UnicodeData.txt</code></a> 文件以及伴随的 <a href="https://unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt"><code>SpecialCasing.txt</code></a> 中所有与区域无关的映射）。</p>
        <emu-note>
          <p>某些代码点的大小写映射会产生多个代码点。在此情况下结果字符串长度可能不同于源字符串。由于 `toUpperCase` 与 `toLowerCase` 均具有上下文相关行为，这两个方法并不对称；即 `s.toUpperCase().toLowerCase()` 不一定等于 `s.toLowerCase()`。</p>
        </emu-note>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tostring">
        <h1>String.prototype.toString ( )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? ThisStringValue(*this* value)。
        </emu-alg>
        <emu-note>
          <p>对于 String 对象，该方法恰好与 `valueOf` 方法返回相同的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.touppercase">
        <h1>String.prototype.toUpperCase ( )</h1>
        <p>此方法将字符串值视为 UTF-16 编码代码点序列（参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。</p>
        <p>其行为与 `String.prototype.toLowerCase` 相同，只是字符串使用 Unicode 默认大小写转换中的 toUppercase 算法映射。</p>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.towellformed">
        <h1>String.prototype.toWellFormed ( )</h1>
        <p>该方法返回此对象的字符串表示，其中所有不成对的前导或后导代理项被替换为 U+FFFD（REPLACEMENT CHARACTER）。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _strLen_ 为 _S_ 的长度。
          1. 令 _k_ 为 0。
          1. 令 _result_ 为空字符串。
          1. 当 _k_ &lt; _strLen_ 时重复，
            1. 令 _cp_ 为 CodePointAt(_S_, _k_)。
            1. 若 _cp_.[[IsUnpairedSurrogate]] 为 *true*，则
              1. 将 _result_ 设为 _result_ 与 0xFFFD (REPLACEMENT CHARACTER) 的字符串拼接。
            1. 否则，
              1. 将 _result_ 设为 _result_ 与 UTF16EncodeCodePoint(_cp_.[[CodePoint]]) 的字符串拼接。
            1. 将 _k_ 设为 _k_ + _cp_.[[CodeUnitCount]]。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trim">
        <h1>String.prototype.trim ( )</h1>
        <p>该方法将字符串值视为 UTF-16 编码代码点序列（参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? TrimString(_S_, ~start+end~)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>

        <emu-clause id="sec-trimstring" type="abstract operation">
          <h1>
            TrimString (
              _string_: 一个 ECMAScript 语言值,
              _where_: ~start~, ~end~, 或 ~start+end~,
            ): 返回包含一个字符串的普通完成或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>它将 _string_ 视为 UTF-16 编码代码点序列，参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>。</dd>
          </dl>
          <emu-alg>
            1. 执行 ? RequireObjectCoercible(_string_)。
            1. 令 _S_ 为 ? ToString(_string_)。
            1. 若 _where_ 为 ~start~，则
              1. 令 _T_ 为移除前导空白后的 _S_ 副本。
            1. 否则若 _where_ 为 ~end~，则
              1. 令 _T_ 为移除尾随空白后的 _S_ 副本。
            1. 否则，
              1. 断言：_where_ 为 ~start+end~。
              1. 令 _T_ 为移除前后空白后的 _S_ 副本。
            1. 返回 _T_。
          </emu-alg>
          <p>空白的定义为 |WhiteSpace| 与 |LineTerminator| 的并集。判断某 Unicode 代码点是否属于 Unicode 通用类别 “Space_Separator”(“Zs”) 时，代码单元序列按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 指定的 UTF-16 编码代码点序列解释。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimend">
        <h1>String.prototype.trimEnd ( )</h1>
        <p>该方法将字符串值视为 UTF-16 编码代码点序列（参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? TrimString(_S_, ~end~)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimstart">
        <h1>String.prototype.trimStart ( )</h1>
        <p>该方法将字符串值视为 UTF-16 编码代码点序列（参见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? TrimString(_S_, ~start~)。
        </emu-alg>
        <emu-note>
          <p>该方法特意设计为泛型；其 *this* 不要求为 String 对象，因此可转移到其他对象类型使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.valueof">
        <h1>String.prototype.valueOf ( )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? ThisStringValue(*this* value)。
        </emu-alg>

        <emu-clause id="sec-thisstringvalue" type="abstract operation" oldids="thisstringvalue">
          <h1>
            ThisStringValue (
              _value_: 一个 ECMAScript 语言值,
            ): 返回包含一个字符串的普通完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _value_ 是字符串，返回 _value_。
            1. 若 _value_ 是对象且具有 [[StringData]] 内部槽，则
              1. 令 _s_ 为 _value_.[[StringData]]。
              1. 断言：_s_ 为字符串。
              1. 返回 _s_。
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype-%symbol.iterator%" oldids="sec-string.prototype-@@iterator,sec-createstringiterator,sec-properties-of-string-iterator-instances,table-46,table-internal-slots-of-string-iterator-instances">
        <h1>String.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>该方法返回一个迭代器对象，该对象按字符串值的代码点进行迭代，并将每个代码点作为字符串值返回。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _s_ 为 ? ToString(_O_)。
          1. 令 _closure_ 为一个不带参数的新抽象闭包，捕获 _s_，调用时执行：
            1. 令 _len_ 为 _s_ 的长度。
            1. 令 _position_ 为 0。
            1. 当 _position_ &lt; _len_ 时重复，
              1. 令 _cp_ 为 CodePointAt(_s_, _position_)。
              1. 令 _nextIndex_ 为 _position_ + _cp_.[[CodeUnitCount]]。
              1. 令 _resultString_ 为 _s_ 中从 _position_ 到 _nextIndex_ 的子串。
              1. 将 _position_ 设为 _nextIndex_。
              1. 执行 ? GeneratorYield(CreateIteratorResultObject(_resultString_, *false*))。
            1. 返回 NormalCompletion(~unused~)。
          1. 返回 CreateIteratorFromClosure(_closure_, *"%StringIteratorPrototype%"*, %StringIteratorPrototype%)。
        </emu-alg>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.iterator]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-string-instances">
      <h1>String 实例的属性</h1>
      <p>String 实例是 String 特异对象，并具有为此类对象指定的内部方法。String 实例从 String 原型对象继承属性。String 实例还具有 [[StringData]] 内部槽。[[StringData]] 内部槽是该 String 对象表示的字符串值。</p>
      <p>String 实例有一个 *"length"* 属性，以及一组按整数索引命名的可枚举属性。</p>

      <emu-clause id="sec-properties-of-string-instances-length">
        <h1>length</h1>
        <p>该 String 对象表示的字符串值中的元素数量。</p>
        <p>一旦 String 对象初始化，该属性不再变化。其属性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-iterator-objects">
      <h1>String 迭代器对象</h1>
      <p><dfn variants="String Iterators,String Iterator object,String Iterator objects">String Iterator</dfn> 是表示某个特定 String 实例对象上的一次特定迭代的对象。String Iterator 对象没有命名构造函数；相反，它们由调用某些 String 实例对象的方法创建。</p>

      <emu-clause id="sec-%stringiteratorprototype%-object">
        <h1>%StringIteratorPrototype% 对象</h1>
        <p><dfn>%StringIteratorPrototype%</dfn> 对象：</p>
        <ul>
          <li>具有所有 String Iterator 对象继承的属性。</li>
          <li>是一个普通对象。</li>
          <li>有一个 [[Prototype]] 内部槽，其值为 %Iterator.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%stringiteratorprototype%.next">
          <h1>%StringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. 返回 ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%StringIteratorPrototype%"*)</emu-meta>。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%stringiteratorprototype%-@@tostringtag" id="sec-%stringiteratorprototype%-%symbol.tostringtag%">
          <h1>%StringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 属性的初始值为字符串值 *"String Iterator"*。</p>
          <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp（正则表达式）对象</h1>
    <p>RegExp 对象包含一个正则表达式以及其相关的标志（flags）。</p>
    <emu-note>
      <p>正则表达式的形式和功能参考 Perl 5 编程语言中的正则表达式机制。</p>
    </emu-note>

    <emu-clause id="sec-patterns">
      <h1>模式（Patterns）</h1>
      <p>RegExp 构造函数对输入的模式字符串应用以下语法。如果该语法无法将该字符串解释为 |Pattern| 的展开，则会产生错误。</p>
      <h2>语法（Syntax）</h2>
      <emu-grammar type="definition">
        Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `|` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [empty]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          `(?=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        Quantifier ::
          QuantifierPrefix
          QuantifierPrefix `?`

        QuantifierPrefix ::
          `*`
          `+`
          `?`
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          PatternCharacter
          `.`
          `\` AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
          CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
          `(` GroupSpecifier[?UnicodeMode]? Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        RegularExpressionModifiers ::
          [empty]
          RegularExpressionModifiers RegularExpressionModifier

        RegularExpressionModifier :: one of
          `i` `m` `s`

        SyntaxCharacter :: one of
          `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

        PatternCharacter ::
          SourceCharacter but not SyntaxCharacter

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          DecimalEscape
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          IdentityEscape[?UnicodeMode]

        ControlEscape :: one of
          `f` `n` `r` `t` `v`

        GroupSpecifier[UnicodeMode] ::
          `?` GroupName[?UnicodeMode]

        GroupName[UnicodeMode] ::
          `&lt;` RegExpIdentifierName[?UnicodeMode] `&gt;`

        RegExpIdentifierName[UnicodeMode] ::
          RegExpIdentifierStart[?UnicodeMode]
          RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]

        RegExpIdentifierStart[UnicodeMode] ::
          IdentifierStartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpIdentifierPart[UnicodeMode] ::
          IdentifierPartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpUnicodeEscapeSequence[UnicodeMode] ::
          [+UnicodeMode] `u` HexLeadSurrogate `\u` HexTrailSurrogate
          [+UnicodeMode] `u` HexLeadSurrogate
          [+UnicodeMode] `u` HexTrailSurrogate
          [+UnicodeMode] `u` HexNonSurrogate
          [~UnicodeMode] `u` Hex4Digits
          [+UnicodeMode] `u{` CodePoint `}`

        UnicodeLeadSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+D800 to U+DBFF

        UnicodeTrailSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
      </emu-grammar>
      <p>对于每个 `\\u` |HexTrailSurrogate|，若其关联的 `u` |HexLeadSurrogate| 的选择存在歧义，则应与最近的、否则将没有对应 `\\u` |HexTrailSurrogate| 的 `u` |HexLeadSurrogate| 关联。</p>
      <emu-grammar type="definition">
        HexLeadSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xD800 to 0xDBFF]

        HexTrailSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xDC00 to 0xDFFF]

        HexNonSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is not in the inclusive interval from 0xD800 to 0xDFFF]

        IdentityEscape[UnicodeMode] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacter but not UnicodeIDContinue

        DecimalEscape ::
          NonZeroDigit DecimalDigits[~Sep]? [lookahead &notin; DecimalDigit]

        CharacterClassEscape[UnicodeMode] ::
          `d`
          `D`
          `s`
          `S`
          `w`
          `W`
          [+UnicodeMode] `p{` UnicodePropertyValueExpression `}`
          [+UnicodeMode] `P{` UnicodePropertyValueExpression `}`

        UnicodePropertyValueExpression ::
          UnicodePropertyName `=` UnicodePropertyValue
          LoneUnicodePropertyNameOrValue

        UnicodePropertyName ::
          UnicodePropertyNameCharacters

        UnicodePropertyNameCharacters ::
          UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

        UnicodePropertyValue ::
          UnicodePropertyValueCharacters

        LoneUnicodePropertyNameOrValue ::
          UnicodePropertyValueCharacters

        UnicodePropertyValueCharacters ::
          UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

        UnicodePropertyValueCharacter ::
          UnicodePropertyNameCharacter
          DecimalDigit

        UnicodePropertyNameCharacter ::
          AsciiLetter
          `_`

        CharacterClass[UnicodeMode, UnicodeSetsMode] ::
          `[` [lookahead != `^`] ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`
          `[^` ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`

        ClassContents[UnicodeMode, UnicodeSetsMode] ::
          [empty]
          [~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
          [+UnicodeSetsMode] ClassSetExpression

        NonemptyClassRanges[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtom[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        NonemptyClassRangesNoDash[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        ClassAtom[UnicodeMode] ::
          `-`
          ClassAtomNoDash[?UnicodeMode]

        ClassAtomNoDash[UnicodeMode] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode]

        ClassEscape[UnicodeMode] ::
          `b`
          [+UnicodeMode] `-`
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]

        ClassSetExpression ::
          ClassUnion
          ClassIntersection
          ClassSubtraction

        ClassUnion ::
          ClassSetRange ClassUnion?
          ClassSetOperand ClassUnion?

        ClassIntersection ::
          ClassSetOperand `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand
          ClassIntersection `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand

        ClassSubtraction ::
          ClassSetOperand `--` ClassSetOperand
          ClassSubtraction `--` ClassSetOperand

        ClassSetRange ::
          ClassSetCharacter `-` ClassSetCharacter

        ClassSetOperand ::
          NestedClass
          ClassStringDisjunction
          ClassSetCharacter

        NestedClass ::
          `[` [lookahead != `^`] ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `[^` ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `\` CharacterClassEscape[+UnicodeMode]
      </emu-grammar>
      <emu-note>
        <p>此处前两行等价于 CharacterClass。</p>
      </emu-note>
      <emu-grammar type="definition">
        ClassStringDisjunction ::
          `\q{` ClassStringDisjunctionContents `}`

        ClassStringDisjunctionContents ::
          ClassString
          ClassString `|` ClassStringDisjunctionContents

        ClassString ::
          [empty]
          NonEmptyClassString

        NonEmptyClassString ::
          ClassSetCharacter NonEmptyClassString?

        ClassSetCharacter ::
          [lookahead &notin; ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
          `\` CharacterEscape[+UnicodeMode]
          `\` ClassSetReservedPunctuator
          `\b`

        ClassSetReservedDoublePunctuator :: one of
          `&amp;&amp;` `!!` `##`
          `$$` `%%` `**`
          `++` `,,` `..`
          `::` `;;` `&lt;&lt;`
          `==` `&gt;&gt;` `??`
          `@@` `^^` `&grave;&grave;`
          `~~`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetSyntaxCharacter :: one of
          `(` `)` `[` `]` `{` `}` `/` `-` `\` `|`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetReservedPunctuator :: one of
          `&amp;` `-` `!` `#` `%` `,`
          `:` `;` `&lt;` `=` `&gt;` `@`
          `&grave;` `~`
      </emu-grammar>
      <emu-note>
        <p>本节中的若干产生式在 <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> 中给出了替代定义。</p>
      </emu-note>

      <emu-clause id="sec-patterns-static-semantics-early-errors">
        <h1>静态语义：早期错误（Early Errors）</h1>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <ul>
          <li>
            若 CountLeftCapturingParensWithin(|Pattern|) ≥ 2<sup>32</sup> - 1，则为语法错误（Syntax Error）。
          </li>
          <li>
            若 |Pattern| 含有两个不同的 |GroupSpecifier| _x_ 和 _y_，使得 _x_ 的 CapturingGroupName 与 _y_ 的 CapturingGroupName 相同，且 MightBothParticipate(_x_, _y_) 为 *true*，则为语法错误。
          </li>
        </ul>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <ul>
          <li>
            若第一个 |DecimalDigits| 的 MV 严格大于第二个 |DecimalDigits| 的 MV，则为语法错误。
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            若 |RegularExpressionModifiers| 匹配的源文本包含同一代码点多次，则为语法错误。
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            若第一个 |RegularExpressionModifiers| 和第二个 |RegularExpressionModifiers| 匹配的源文本都为空，则为语法错误。
          </li>
          <li>
            若第一个 |RegularExpressionModifiers| 匹配的源文本包含同一代码点多次，则为语法错误。
          </li>
          <li>
            若第二个 |RegularExpressionModifiers| 匹配的源文本包含同一代码点多次，则为语法错误。
          </li>
          <li>
            若第一个 |RegularExpressionModifiers| 匹配的任何代码点也出现在第二个 |RegularExpressionModifiers| 匹配的源文本中，则为语法错误。
          </li>
        </ul>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <ul>
          <li>
            若 GroupSpecifiersThatMatch(|GroupName|) 为空，则为语法错误。
          </li>
        </ul>
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <ul>
          <li>
            若 |DecimalEscape| 的 CapturingGroupNumber 严格大于包含该 |AtomEscape| 的 |Pattern| 中 CountLeftCapturingParensWithin 的结果，则为语法错误。
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            若第一个 |ClassAtom| 的 IsCharacterClass 为 *true* 或第二个 |ClassAtom| 的 IsCharacterClass 为 *true*，则为语法错误。
          </li>
          <li>
            若两者 IsCharacterClass 均为 *false* 且第一个 |ClassAtom| 的 CharacterValue 严格大于第二个 |ClassAtom| 的 CharacterValue，则为语法错误。
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            若 |ClassAtomNoDash| 的 IsCharacterClass 为 *true* 或 |ClassAtom| 的 IsCharacterClass 为 *true*，则为语法错误。
          </li>
          <li>
            若二者 IsCharacterClass 均为 *false* 且 |ClassAtomNoDash| 的 CharacterValue 严格大于 |ClassAtom| 的 CharacterValue，则为语法错误。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            若 |RegExpUnicodeEscapeSequence| 的 CharacterValue 不是 |IdentifierStartChar| 词法语法产生式所匹配的某个代码点的数值，则为语法错误。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            若 |RegExpIdentifierStart| 的 RegExpIdentifierCodePoint 未被 |UnicodeIDStart| 词法语法产生式匹配，则为语法错误。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            若 |RegExpUnicodeEscapeSequence| 的 CharacterValue 不是 |IdentifierPartChar| 词法语法产生式所匹配的某个代码点的数值，则为语法错误。
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            若 |RegExpIdentifierPart| 的 RegExpIdentifierCodePoint 未被 |UnicodeIDContinue| 词法语法产生式匹配，则为语法错误。
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <ul>
          <li>
            若 |UnicodePropertyName| 匹配的源文本不是 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> “Property name and aliases” 列所列出的 Unicode 属性名或属性别名，则为语法错误。
          </li>
          <li>
            若 |UnicodePropertyValue| 匹配的源文本不是 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a> 中针对该 |UnicodePropertyName| 源文本所给 Unicode 属性（或其别名）的属性值或属性值别名，则为语法错误。
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <ul>
          <li>
            若 |LoneUnicodePropertyNameOrValue| 匹配的源文本既不是 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a> 中 General_Category (gc) 属性的属性值或其别名，也不是 <emu-xref href="#table-binary-unicode-properties"></emu-xref> “Property name and aliases” 列中列出的二进制属性或其别名，也不是 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> “Property name” 列中列出的字符串二进制属性，则为语法错误。
          </li>
          <li>
            若封闭的 |Pattern| 不具有 <sub>[UnicodeSetsMode]</sub> 参数，且 |LoneUnicodePropertyNameOrValue| 匹配的源文本是 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> “Property name” 列中列出的字符串二进制属性，则为语法错误。
          </li>
        </ul>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <ul>
          <li>
            若该 |UnicodePropertyValueExpression| 的 MayContainStrings 为 *true*，则为语法错误。
          </li>
        </ul>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            若该 |ClassContents| 的 MayContainStrings 为 *true*，则为语法错误。
          </li>
        </ul>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            若该 |ClassContents| 的 MayContainStrings 为 *true*，则为语法错误。
          </li>
        </ul>
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <ul>
          <li>
            若第一个 |ClassSetCharacter| 的 CharacterValue 严格大于第二个 |ClassSetCharacter| 的 CharacterValue，则为语法错误。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparenswithin" type="abstract operation">
        <h1>
          静态语义：CountLeftCapturingParensWithin (
            _node_: 一个解析节点,
          ): 非负整数
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>返回 _node_ 中左捕获括号（<dfn variants="left-capturing parentheses">左捕获括号</dfn>）的数量。左捕获括号是由产生式 <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 中的 `(` 终结符匹配的任意 `(` 模式字符。</dd>
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-alg>
          1. 断言：_node_ 是 <emu-xref href="#sec-patterns">RegExp 模式语法</emu-xref> 中某个产生式实例。
          1. 返回 _node_ 内包含的 <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 解析节点的数量。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparensbefore" type="abstract operation">
        <h1>
          静态语义：CountLeftCapturingParensBefore (
            _node_: 一个解析节点,
          ): 非负整数
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>返回封闭模式中出现在 _node_ 左侧的左捕获括号数量。</dd>
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-alg>
          1. 断言：_node_ 是 <emu-xref href="#sec-patterns">RegExp 模式语法</emu-xref> 中某个产生式实例。
          1. 令 _pattern_ 为包含 _node_ 的 |Pattern|。
          1. 返回 _pattern_ 中所有 <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> 解析节点里，出现在 _node_ 之前或包含 _node_ 的那些的数量。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mightbothparticipate" type="abstract operation">
        <h1>
          静态语义：MightBothParticipate (
            _x_: 一个解析节点,
            _y_: 一个解析节点,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_x_ 与 _y_ 具有相同的封闭 |Pattern|。
          1. 若封闭 |Pattern| 中存在一个 <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar> 解析节点，使得 _x_ 位于该 |Alternative| 内而 _y_ 位于其派生的 |Disjunction| 内，或 _x_ 位于派生的 |Disjunction| 而 _y_ 位于该 |Alternative| 内，则返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-capturing-group-number" type="sdo">
        <h1>静态语义：CapturingGroupNumber ( ): 正整数</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-grammar>DecimalEscape :: NonZeroDigit</emu-grammar>
        <emu-alg>
          1. 返回 |NonZeroDigit| 的 MV。
        </emu-alg>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits</emu-grammar>
        <emu-alg>
          1. 令 _n_ 为 |DecimalDigits| 中代码点数量。
          1. 返回 (|NonZeroDigit| 的 MV × 10<sup>_n_</sup> 加上 |DecimalDigits| 的 MV)。
        </emu-alg>
        <p>“|NonZeroDigit| 的 MV” 与 “|DecimalDigits| 的 MV” 的定义见 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>。</p>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-is-character-class" type="sdo">
        <h1>静态语义：IsCharacterClass ( ): 布尔值</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-patterns-static-semantics-is-character-class-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-grammar>
          ClassAtom ::
            `-`

          ClassAtomNoDash ::
            SourceCharacter but not one of `\` or `]` or `-`

          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>ClassEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-character-value" type="sdo">
        <h1>静态语义：CharacterValue ( ): 非负整数</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-patterns-static-semantics-character-value-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-grammar>
          ClassAtom :: `-`
        </emu-grammar>
        <emu-alg>
          1. 返回 U+002D（连字号 HYPHEN-MINUS）的数值。
        </emu-alg>
        <emu-grammar>
          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`
        </emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |SourceCharacter| 匹配的代码点。
          1. 返回 _ch_ 的数值。
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `b`
        </emu-grammar>
        <emu-alg>
          1. 返回 U+0008（BACKSPACE）的数值。
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `-`
        </emu-grammar>
        <emu-alg>
          1. 返回 U+002D（连字号 HYPHEN-MINUS）的数值。
        </emu-alg>
        <emu-grammar>CharacterEscape :: ControlEscape</emu-grammar>
        <emu-alg>
          1. 按 <emu-xref href="#table-controlescape-code-point-values"></emu-xref> 返回对应数值。
        </emu-alg>
        <emu-table id="table-controlescape-code-point-values" caption="ControlEscape 代码点数值" oldids="table-47">
          <table>
            <thead>
              <tr>
                <th>
                  ControlEscape
                </th>
                <th>
                  数值
                </th>
                <th>
                  代码点
                </th>
                <th>
                  Unicode 名称
                </th>
                <th>
                  符号
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `t`
              </td>
              <td>
                9
              </td>
              <td>
                `U+0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `n`
              </td>
              <td>
                10
              </td>
              <td>
                `U+000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `v`
              </td>
              <td>
                11
              </td>
              <td>
                `U+000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `f`
              </td>
              <td>
                12
              </td>
              <td>
                `U+000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `r`
              </td>
              <td>
                13
              </td>
              <td>
                `U+000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-grammar>CharacterEscape :: `c` AsciiLetter</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |AsciiLetter| 匹配的代码点。
          1. 令 _i_ 为 _ch_ 的数值。
          1. 返回 _i_ 除以 32 的余数。
        </emu-alg>
        <emu-grammar>CharacterEscape :: `0` [lookahead &notin; DecimalDigit]</emu-grammar>
        <emu-alg>
          1. 返回 U+0000（NULL）的数值。
        </emu-alg>
        <emu-note>
          <p>`\\0` 表示 &lt;NUL> 字符，且后面不能跟十进制数字。</p>
        </emu-note>
        <emu-grammar>CharacterEscape :: HexEscapeSequence</emu-grammar>
        <emu-alg>
          1. 返回 |HexEscapeSequence| 的 MV。
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` HexLeadSurrogate `\u` HexTrailSurrogate</emu-grammar>
        <emu-alg>
          1. 令 _lead_ 为 |HexLeadSurrogate| 的 CharacterValue。
          1. 令 _trail_ 为 |HexTrailSurrogate| 的 CharacterValue。
          1. 令 _cp_ 为 UTF16SurrogatePairToCodePoint(_lead_, _trail_)。
          1. 返回 _cp_ 的数值。
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. 返回 |Hex4Digits| 的 MV。
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. 返回 |CodePoint| 的 MV。
        </emu-alg>
        <emu-grammar>
          HexLeadSurrogate :: Hex4Digits

          HexTrailSurrogate :: Hex4Digits

          HexNonSurrogate :: Hex4Digits
        </emu-grammar>
        <emu-alg>
          1. 返回 |Hex4Digits| 的 MV。
        </emu-alg>
        <emu-grammar>CharacterEscape :: IdentityEscape</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |IdentityEscape| 匹配的代码点。
          1. 返回 _ch_ 的数值。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: SourceCharacter but not ClassSetSyntaxCharacter</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |SourceCharacter| 匹配的代码点。
          1. 返回 _ch_ 的数值。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\` ClassSetReservedPunctuator</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |ClassSetReservedPunctuator| 匹配的代码点。
          1. 返回 _ch_ 的数值。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. 返回 U+0008（BACKSPACE）的数值。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-maycontainstrings" type="sdo">
        <h1>静态语义：MayContainStrings ( ): 布尔值</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          CharacterClassEscape ::
            `d`
            `D`
            `s`
            `S`
            `w`
            `W`
            `P{` UnicodePropertyValueExpression `}`

          UnicodePropertyValueExpression ::
            UnicodePropertyName `=` UnicodePropertyValue

          NestedClass ::
            `[^` ClassContents `]`

          ClassContents ::
            [empty]
            NonemptyClassRanges

          ClassSetOperand ::
            ClassSetCharacter
        </emu-grammar>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. 若 |LoneUnicodePropertyNameOrValue| 匹配的源文本是 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> “Property name” 列中列出的字符串二进制属性，则返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. 若 |ClassUnion| 存在，返回该 |ClassUnion| 的 MayContainStrings。
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. 若该 |ClassSetOperand| 的 MayContainStrings 为 *true*，返回 *true*。
          1. 若 |ClassUnion| 存在，返回该 |ClassUnion| 的 MayContainStrings。
          1. 返回 *false*。
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 若第一个 |ClassSetOperand| 的 MayContainStrings 为 *false*，返回 *false*。
          1. 若第二个 |ClassSetOperand| 的 MayContainStrings 为 *false*，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 若该 |ClassIntersection| 的 MayContainStrings 为 *false*，返回 *false*。
          1. 若该 |ClassSetOperand| 的 MayContainStrings 为 *false*，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 返回第一个 |ClassSetOperand| 的 MayContainStrings。
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 返回该 |ClassSubtraction| 的 MayContainStrings。
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. 若该 |ClassString| 的 MayContainStrings 为 *true*，返回 *true*。
          1. 返回该 |ClassStringDisjunctionContents| 的 MayContainStrings。
        </emu-alg>
        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. 返回 *true*。
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. 返回该 |NonEmptyClassString| 的 MayContainStrings。
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. 若 |NonEmptyClassString| 存在，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-groupspecifiersthatmatch" type="abstract operation">
        <h1>
          静态语义：GroupSpecifiersThatMatch (
            _thisGroupName_: 一个 |GroupName| 解析节点,
          ): |GroupSpecifier| 解析节点的列表
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _name_ 为 _thisGroupName_ 的 CapturingGroupName。
          1. 令 _pattern_ 为包含 _thisGroupName_ 的 |Pattern|。
          1. 令 _result_ 为新的空列表。
          1. 对 _pattern_ 中的每个 |GroupSpecifier| _gs_，执行
            1. 若 _gs_ 的 CapturingGroupName 为 _name_，则
              1. 将 _gs_ 追加至 _result_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-capturinggroupname" oldids="sec-regexp-identifier-names-static-semantics-stringvalue" type="sdo">
        <h1>静态语义：CapturingGroupName ( ): 字符串</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          GroupName :: `&lt;` RegExpIdentifierName `&gt;`
        </emu-grammar>
        <emu-alg>
          1. 令 _idTextUnescaped_ 为 |RegExpIdentifierName| 的 RegExpIdentifierCodePoints。
          1. 返回 CodePointsToString(_idTextUnescaped_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoints" type="sdo">
        <h1>静态语义：RegExpIdentifierCodePoints ( ): 代码点列表</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierStart</emu-grammar>
        <emu-alg>
          1. 令 _cp_ 为 |RegExpIdentifierStart| 的 RegExpIdentifierCodePoint。
          1. 返回 « _cp_ »。
        </emu-alg>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierName RegExpIdentifierPart</emu-grammar>
        <emu-alg>
          1. 令 _cps_ 为派生的 |RegExpIdentifierName| 的 RegExpIdentifierCodePoints。
          1. 令 _cp_ 为 |RegExpIdentifierPart| 的 RegExpIdentifierCodePoint。
          1. 返回 _cps_ 与 « _cp_ » 的列表拼接。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoint" type="sdo">
        <h1>静态语义：RegExpIdentifierCodePoint ( ): 代码点</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. 返回 |IdentifierStartChar| 匹配的代码点。
        </emu-alg>
        <emu-grammar>RegExpIdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. 返回 |IdentifierPartChar| 匹配的代码点。
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence

          RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence
        </emu-grammar>
        <emu-alg>
          1. 返回其数值为 |RegExpUnicodeEscapeSequence| 的 CharacterValue 的代码点。
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

          RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
        </emu-grammar>
        <emu-alg>
          1. 令 _lead_ 为数值等于 |UnicodeLeadSurrogate| 匹配代码点数值的代码单元。
          1. 令 _trail_ 为数值等于 |UnicodeTrailSurrogate| 匹配代码点数值的代码单元。
          1. 返回 UTF16SurrogatePairToCodePoint(_lead_, _trail_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-pattern-semantics">
      <h1>模式语义（Pattern Semantics）</h1>
      <p>正则表达式模式通过下述过程被转换为一个抽象闭包（Abstract Closure）。实现被鼓励使用比下述更高效的算法，只要结果一致。该抽象闭包用作 RegExp 对象 [[RegExpMatcher]] 内部槽的值。</p>
      <p>一个 |Pattern| 在其关联标志不包含 `u` 且不包含 `v` 时是一个 BMP 模式；否则是一个 Unicode 模式。BMP 模式针对被解释为由一系列 16 位值组成的字符串进行匹配，这些 16 位值是在基本多文种平面范围内的 Unicode 代码点。Unicode 模式针对被解释为由 UTF-16 编码的 Unicode 代码点组成的字符串进行匹配。在描述 BMP 模式行为的语境中，“character（字符）”指单个 16 位 Unicode BMP 代码点；在描述 Unicode 模式行为的语境中，“character” 指一个 UTF-16 编码的代码点（<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）。在任一语境下，“character value（字符值）”指对应未编码代码点的数值。</p>
      <p>|Pattern| 的语法与语义按如下方式定义：将 |Pattern| 的源文本视为 |SourceCharacter| 值的一个列表，其中每个 |SourceCharacter| 对应一个 Unicode 代码点。若一个 BMP 模式包含非 BMP 的 |SourceCharacter|，则整个模式使用 UTF-16 编码，该编码的各个代码单元作为该列表的元素。</p>
      <emu-note>
        <p>例如，考虑一个在源文本中表示为单个非 BMP 字符 U+1D11E（MUSICAL SYMBOL G CLEF）的模式。作为 Unicode 模式解释时，它将是一个只含该代码点 U+1D11E 的单元素（字符）列表。然而，作为 BMP 模式解释时，它首先被 UTF-16 编码，产生一个包含代码单元 0xD834 和 0xDD1E 的双元素列表。</p>
        <p>模式以 ECMAScript 字符串值的形式传给 RegExp 构造函数，其中非 BMP 字符以 UTF-16 编码。例如，单字符 MUSICAL SYMBOL G CLEF 的模式，作为一个字符串值，是长度为 2 的字符串，其元素是代码单元 0xD834 与 0xDD1E。因此，将其作为由两个模式字符组成的 BMP 模式处理无需进一步转换；然而，要把它作为 Unicode 模式处理，必须使用 UTF16SurrogatePairToCodePoint 生成仅含一个模式字符（代码点 U+1D11E）的列表。</p>
        <p>实现也许实际上不会执行这些到 UTF-16 之间的转换，但本规范语义要求匹配结果等效于执行了这些转换。</p>
      </emu-note>

      <emu-clause id="sec-pattern-notation" oldids="sec-notation">
        <h1>记号（Notation）</h1>
        <p>下述描述使用以下内部数据结构：</p>
        <ul>
          <li>
            <dfn>CharSetElement</dfn> 是下列两种实体之一：
            <ul>
              <li>
                若 _rer_.[[UnicodeSets]] 为 *false*，则 CharSetElement 是前述“模式语义”意义里的一个字符。
              </li>
              <li>
                若 _rer_.[[UnicodeSets]] 为 *true*，则 CharSetElement 是一个序列，其元素为前述“模式语义”意义里的字符。包含空序列、单字符序列以及多字符序列。为方便起见，处理此类 CharSetElement 时，单个字符与单字符序列可互换视之。
              </li>
            </ul>
          </li>
          <li>
            <dfn id="pattern-charset" variants="CharSets">CharSet</dfn> 是 CharSetElement 的数学集合。
          </li>
          <li>
            <dfn id="pattern-capturerange" variants="CaptureRanges">CaptureRange</dfn> 是一个记录 { [[StartIndex]], [[EndIndex]] }，表示一次捕获中包含的字符范围；[[StartIndex]] 是表示范围在 _Input_ 中起始索引（含）的整数，[[EndIndex]] 是表示范围在 _Input_ 中结束索引（不含）的整数。任意 CaptureRange 必须满足 [[StartIndex]] ≤ [[EndIndex]] 的不变量。
          </li>
          <li>
            <dfn id="pattern-matchstate" variants="MatchStates" oldids="pattern-matchresult">MatchState</dfn> 是记录 { [[Input]], [[EndIndex]], [[Captures]] }，其中 [[Input]] 是表示被匹配字符串的字符列表，[[EndIndex]] 是一个整数，[[Captures]] 是一个值列表，对应模式中每个左捕获括号。MatchState 用于在正则表达式匹配算法中表示部分匹配状态。[[EndIndex]] 是当前模式已匹配的最后一个输入字符索引加 1；[[Captures]] 保存捕获括号的结果。[[Captures]] 的第 _n_ 个元素要么是表示第 _n_ 个捕获括号所捕获字符范围的 CaptureRange，要么在该捕获括号尚未到达时为 *undefined*。由于回溯，匹配过程中任意时刻可能存在多个 MatchState。
          </li>
          <li>
            <dfn id="pattern-matchercontinuation" variants="MatcherContinuations">MatcherContinuation</dfn> 是一个抽象闭包，接收一个 MatchState 参数，返回一个 MatchState 或 ~failure~。该闭包尝试从其 MatchState 参数给出的中间状态起，将剩余（由闭包捕获的值指定）的模式部分与 _Input_ 匹配。若匹配成功，返回达到的最终 MatchState；失败则返回 ~failure~。
          </li>
          <li>
            <dfn id="pattern-matcher" variants="Matchers">Matcher</dfn> 是一个抽象闭包，接收两个参数——一个 MatchState 和一个 MatcherContinuation——返回一个 MatchState 或 ~failure~。Matcher 尝试从其 MatchState 参数给出的中间状态起，将模式的一个中间子模式（由闭包捕获值指定）与该 MatchState 的 [[Input]] 匹配。MatcherContinuation 参数应为匹配剩余模式的闭包。匹配子模式得到新的 MatchState 后，Matcher 调用 MatcherContinuation 测试剩余模式是否也能匹配。若可以，返回该 MatcherContinuation 返回的 MatchState；否则 Matcher 可以在其选择点尝试不同选择，不断调用 MatcherContinuation，直到成功或所有可能性耗尽。
          </li>
        </ul>

        <emu-clause id="sec-regexp-records">
          <h1>RegExp 记录（RegExp Records）</h1>
          <p><dfn variants="RegExp Records">RegExp 记录</dfn> 是一个记录值，用于存储编译（并可能在匹配）过程中需要的 RegExp 信息。</p>
          <p>其具有以下字段：</p>
          <emu-table id="table-regexp-record-fields" caption="RegExp 记录字段">
            <table>
              <thead>
                <tr>
                  <th>字段名</th>
                  <th>值</th>
                  <th>含义</th>
                </tr>
              </thead>
              <tr>
                <td>[[IgnoreCase]]</td>
                <td>一个布尔值</td>
                <td>指示 *"i"* 是否出现在该 RegExp 的标志中</td>
              </tr>
              <tr>
                <td>[[Multiline]]</td>
                <td>一个布尔值</td>
                <td>指示 *"m"* 是否出现在标志中</td>
              </tr>
              <tr>
                <td>[[DotAll]]</td>
                <td>一个布尔值</td>
                <td>指示 *"s"* 是否出现在标志中</td>
              </tr>
              <tr>
                <td>[[Unicode]]</td>
                <td>一个布尔值</td>
                <td>指示 *"u"* 是否出现在标志中</td>
              </tr>
              <tr>
                <td>[[UnicodeSets]]</td>
                <td>一个布尔值</td>
                <td>指示 *"v"* 是否出现在标志中</td>
              </tr>
              <tr>
                <td>[[CapturingGroupsCount]]</td>
                <td>非负整数</td>
                <td>该 RegExp 模式中的左捕获括号数量</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilepattern" type="sdo" oldids="sec-pattern">
        <h1>
          运行时语义：CompilePattern (
            _rer_: 一个 RegExp 记录,
          ): 一个抽象闭包，接收一个字符列表与一个非负整数，返回 MatchState 或 ~failure~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Disjunction| 的 CompileSubpattern，参数为 _rer_ 与 ~forward~。
          1. 返回一个新的抽象闭包，具参数 (_Input_, _index_)，捕获 _rer_ 与 _m_，被调用时执行：
            1. 断言：_Input_ 是字符列表。
            1. 断言：0 ≤ _index_ ≤ _Input_ 元素数量。
            1. 令 _c_ 为新的 MatcherContinuation，参数 (_y_)，捕获无，其执行：
              1. 断言：_y_ 是 MatchState。
              1. 返回 _y_。
            1. 令 _cap_ 为一个长度为 _rer_.[[CapturingGroupsCount]] 的列表，索引 1.._rer_.[[CapturingGroupsCount]]，初值皆为 *undefined*。
            1. 令 _x_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }。
            1. 返回 _m_(_x_, _c_)。
        </emu-alg>
        <emu-note>
          <p>一个 Pattern 编译成抽象闭包值。随后 RegExpBuiltinExec 可将此过程应用于字符列表与其中的偏移量，以判断该模式是否在该偏移精确匹配，并在匹配时确定捕获括号的值。<emu-xref href="#sec-pattern-semantics"></emu-xref> 中的算法设计为：编译模式可能抛出 *SyntaxError*；另一方面，一旦成功编译，将所得抽象闭包应用于字符列表查找匹配时不会抛异常（除非出现诸如内存不足的实现定义异常）。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-compilesubpattern" type="sdo" oldids="sec-disjunction,sec-alternative,sec-term">
        <h1>
          运行时语义：CompileSubpattern (
            _rer_: 一个 RegExp 记录,
            _direction_: ~forward~ 或 ~backward~,
          ): 一个 Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-compilesubpattern-annexb"></emu-xref> 中有补充。</p>
        </emu-note>

        <!-- Disjunction -->
        <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar>
        <emu-alg>
          1. 令 _m1_ 为 |Alternative| 的 CompileSubpattern，参数 _rer_ 与 _direction_。
          1. 令 _m2_ 为 |Disjunction| 的 CompileSubpattern，参数 _rer_ 与 _direction_。
          1. 返回 MatchTwoAlternatives(_m1_, _m2_)。
        </emu-alg>
        <emu-note>
          <p>`|` 运算符分隔两个候选。模式先尝试匹配左侧 |Alternative|（后接正则表达式余部）；若失败，再尝试右侧 |Disjunction|（后接余部）。若左 |Alternative|、右 |Disjunction| 及余部均有选择点，则在转向左 |Alternative| 的下一个选择之前，会先穷尽余部的所有选择；在穷尽左 |Alternative| 的所有选择后，才改试右 |Disjunction|。被 `|` 跳过的部分中的捕获括号产生 *undefined* 而不是字符串。例如：</p>
          <pre><code class="javascript">/a|ab/.exec("abc")</code></pre>
          <p>返回 *"a"* 而非 *"ab"*。并且，</p>
          <pre><code class="javascript">/((a)|(ab))((c)|(bc))/.exec("abc")</code></pre>
          <p>返回数组</p>
          <pre><code class="javascript">["abc", "a", "a", undefined, "bc", undefined, "bc"]</code></pre>
          <p>而非</p>
          <pre><code class="javascript">["abc", "ab", undefined, "ab", "c", "c", undefined]</code></pre>
          <p>两候选的尝试顺序与 _direction_ 的值无关。</p>
        </emu-note>

        <!-- Alternative -->
        <emu-grammar>Alternative :: [empty]</emu-grammar>
        <emu-alg>
          1. 返回 EmptyMatcher()。
        </emu-alg>
        <emu-grammar>Alternative :: Alternative Term</emu-grammar>
        <emu-alg>
          1. 令 _m1_ 为 |Alternative| 的 CompileSubpattern，参数 _rer_ 与 _direction_。
          1. 令 _m2_ 为 |Term| 的 CompileSubpattern，参数 _rer_ 与 _direction_。
          1. 返回 MatchSequence(_m1_, _m2_, _direction_)。
        </emu-alg>
        <emu-note>
          <p>相邻的 |Term| 会尝试同时匹配 _Input_ 的相邻片段。当 _direction_ 为 ~forward~ 时，若左 |Alternative|、右 |Term| 和余部存在选择点，则在进入右 |Term| 的下一个选择前会先穷尽余部所有选择，在进入左 |Alternative| 的下一个选择前会先穷尽右 |Term| 的所有选择；当 _direction_ 为 ~backward~ 时，|Alternative| 与 |Term| 的求值顺序反转。</p>
        </emu-note>

        <!-- Term -->
        <emu-grammar>Term :: Assertion</emu-grammar>
        <emu-alg>
          1. 返回 |Assertion| 的 CompileAssertion，参数 _rer_。
        </emu-alg>
        <emu-note>
          <p>结果 Matcher 与 _direction_ 无关。</p>
        </emu-note>
        <emu-grammar>Term :: Atom</emu-grammar>
        <emu-alg>
          1. 返回 |Atom| 的 CompileAtom，参数 _rer_ 与 _direction_。
        </emu-alg>
        <emu-grammar>Term :: Atom Quantifier</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Atom| 的 CompileAtom，参数 _rer_ 与 _direction_。
          1. 令 _q_ 为 |Quantifier| 的 CompileQuantifier。
          1. 断言：_q_.[[Min]] ≤ _q_.[[Max]]。
          1. 令 _parenIndex_ 为 CountLeftCapturingParensBefore(|Term|)。
          1. 令 _parenCount_ 为 CountLeftCapturingParensWithin(|Atom|)。
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m_、_q_、_parenIndex_、_parenCount_，其执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 返回 RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_)。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-repeatmatcher-abstract-operation" type="abstract operation">
          <h1>
            RepeatMatcher (
              _m_: 一个 Matcher,
              _min_: 非负整数,
              _max_: 非负整数或 +&infin;,
              _greedy_: 布尔值,
              _x_: MatchState,
              _c_: MatcherContinuation,
              _parenIndex_: 非负整数,
              _parenCount_: 非负整数,
            ): MatchState 或 ~failure~
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _max_ = 0，返回 _c_(_x_)。
            1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获 _m_、_min_、_max_、_greedy_、_x_、_c_、_parenIndex_、_parenCount_，其执行：
              1. 断言：_y_ 是 MatchState。
              1. [id="step-repeatmatcher-done"] 若 _min_ = 0 且 _y_.[[EndIndex]] = _x_.[[EndIndex]]，返回 ~failure~。
              1. 若 _min_ = 0，令 _min2_ 为 0；否则令 _min2_ 为 _min_ - 1。
              1. 若 _max_ = +∞，令 _max2_ 为 +∞；否则令 _max2_ 为 _max_ - 1。
              1. 返回 RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_)。
            1. 令 _cap_ 为 _x_.[[Captures]] 的拷贝。
            1. [id="step-repeatmatcher-clear-captures"] 对区间 _parenIndex_ + 1 至 _parenIndex_ + _parenCount_（含）内每个整数 _k_，设 _cap_[_k_] 为 *undefined*。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _e_ 为 _x_.[[EndIndex]]。
            1. 令 _xr_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ }。
            1. 若 _min_ ≠ 0，返回 _m_(_xr_, _d_)。
            1. 若 _greedy_ 为 *false*，则
              1. 令 _z_ 为 _c_(_x_)。
              1. 若 _z_ 不为 ~failure~，返回 _z_。
              1. 返回 _m_(_xr_, _d_)。
            1. 令 _z_ 为 _m_(_xr_, _d_)。
            1. 若 _z_ 不为 ~failure~，返回 _z_。
            1. 返回 _c_(_x_)。
          </emu-alg>
          <emu-note>
            <p>|Atom| 后随 |Quantifier| 会按 |Quantifier| 指定的次数重复。|Quantifier| 可为非贪婪，此时 |Atom| 尽可能少重复仍满足余部匹配；或为贪婪，此时尽可能多重复仍满足余部匹配。重复的是 |Atom| 模式本身，而非其已匹配的输入字符序列，因此不同重复可匹配不同子串。</p>
          </emu-note>
          <emu-note>
            <p>若 |Atom| 与余部均有选择点，|Atom| 首先按尽可能多（或在非贪婪时尽可能少）重复。会在进入 |Atom| 最后一次重复的下一选择前穷尽余部选择；在进入倒数第二次重复的下一选择前穷尽最后一次重复的所有选择；此时可能出现允许更多或更少重复的情况，再次（按多或少的策略）穷尽后再进入倒数第二次重复的下一选择，依此类推。</p>
            <p>比较：</p>
            <pre><code class="javascript">/a[a-z]{2,4}/.exec("abcdefghi")</code></pre>
            <p>返回 *"abcde"* 与</p>
            <pre><code class="javascript">/a[a-z]{2,4}?/.exec("abcdefghi")</code></pre>
            <p>返回 *"abc"*。</p>
            <p>再考虑：</p>
            <pre><code class="javascript">/(aa|aabaac|ba|b|c)*/.exec("aabaac")</code></pre>
            <p>依据上述选择点顺序返回数组</p>
            <pre><code class="javascript">["aaba", "ba"]</code></pre>
            <p>而不是：</p>
            <pre><code class="javascript">
              ["aabaac", "aabaac"]
              ["aabaac", "c"]
            </code></pre>
            <p>上述选择点次序可用来编写计算两个一元表示数的最大公约数的正则。以下示例计算 10 与 15 的 gcd：</p>
            <pre><code class="javascript">"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")</code></pre>
            <p>返回一元表示的 gcd *"aaaaa"*。</p>
          </emu-note>
          <emu-note>
            <p>RepeatMatcher 的步骤 <emu-xref href="#step-repeatmatcher-clear-captures"></emu-xref> 在每次重复 |Atom| 时清除其捕获。其行为可见于：</p>
            <pre><code class="javascript">/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</code></pre>
            <p>返回数组</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", undefined, "c"]</code></pre>
            <p>而非</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</code></pre>
            <p>因为最外层 `*` 的每次迭代都会清除量词作用域内 |Atom| 的捕获（此例中为第 2、3、4、5 号捕获）。</p>
          </emu-note>
          <emu-note>
            <p>RepeatMatcher 的步骤 <emu-xref href="#step-repeatmatcher-done"></emu-xref> 指出：一旦最小重复次数满足，任何再匹配空字符序列的 |Atom| 展开将不再考虑，防止在如下模式中无限循环：</p>
            <pre><code class="javascript">/(a*)*/.exec("b")</code></pre>
            <p>或稍复杂的：</p>
            <pre><code class="javascript">/(a*)b\1+/.exec("baaaac")</code></pre>
            <p>其返回数组</p>
            <pre><code class="javascript">["b", ""]</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-emptymatcher" type="abstract operation">
          <h1>EmptyMatcher ( ): 一个 Matcher</h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回新的 Matcher，参数 (_x_, _c_)，捕获无，执行：
              1. 断言：_x_ 是 MatchState。
              1. 断言：_c_ 是 MatcherContinuation。
              1. 返回 _c_(_x_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchtwoalternatives" type="abstract operation">
          <h1>
            MatchTwoAlternatives (
              _m1_: 一个 Matcher,
              _m2_: 一个 Matcher,
            ): 一个 Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m1_ 与 _m2_，执行：
              1. 断言：_x_ 是 MatchState。
              1. 断言：_c_ 是 MatcherContinuation。
              1. 令 _r_ 为 _m1_(_x_, _c_)。
              1. 若 _r_ 不为 ~failure~，返回 _r_。
              1. 返回 _m2_(_x_, _c_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchsequence" type="abstract operation">
          <h1>
            MatchSequence (
              _m1_: 一个 Matcher,
              _m2_: 一个 Matcher,
              _direction_: ~forward~ 或 ~backward~,
            ): 一个 Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _direction_ 为 ~forward~，则
              1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m1_、_m2_，执行：
                1. 断言：_x_ 是 MatchState。
                1. 断言：_c_ 是 MatcherContinuation。
                1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获 _c_、_m2_，执行：
                  1. 断言：_y_ 是 MatchState。
                  1. 返回 _m2_(_y_, _c_)。
                1. 返回 _m1_(_x_, _d_)。
            1. 否则，
              1. 断言：_direction_ 为 ~backward~。
              1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m1_、_m2_，执行：
                1. 断言：_x_ 是 MatchState。
                1. 断言：_c_ 是 MatcherContinuation。
                1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获 _c_、_m1_，执行：
                  1. 断言：_y_ 是 MatchState。
                  1. 返回 _m1_(_y_, _c_)。
                1. 返回 _m2_(_x_, _d_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileassertion" type="sdo" oldids="sec-assertion">
        <h1>
          运行时语义：CompileAssertion (
            _rer_: 一个 RegExp 记录,
          ): 一个 Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-compileassertion-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-grammar>Assertion :: `^`</emu-grammar>
        <emu-alg>
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _rer_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _e_ 为 _x_.[[EndIndex]]。
            1. 若 _e_ = 0，或 (_rer_.[[Multiline]] 为 *true* 且字符 _Input_[_e_ - 1] 被 |LineTerminator| 匹配)，则
              1. 返回 _c_(_x_)。
            1. 返回 ~failure~。
        </emu-alg>
        <emu-note>
          <p>即使使用 `y` 标志，`^` 也只匹配 _Input_ 的开始，或（若 _rer_.[[Multiline]] 为 *true*）行首。</p>
        </emu-note>
        <emu-grammar>Assertion :: `$`</emu-grammar>
        <emu-alg>
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _rer_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _e_ 为 _x_.[[EndIndex]]。
            1. 令 _InputLength_ 为 _Input_ 元素数量。
            1. 若 _e_ = _InputLength_，或 (_rer_.[[Multiline]] 为 *true* 且字符 _Input_[_e_] 被 |LineTerminator| 匹配)，
              1. 返回 _c_(_x_)。
            1. 返回 ~failure~。
        </emu-alg>
        <emu-grammar>Assertion :: `\b`</emu-grammar>
        <emu-alg>
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _rer_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _e_ 为 _x_.[[EndIndex]]。
            1. 令 _a_ 为 IsWordChar(_rer_, _Input_, _e_ - 1)。
            1. 令 _b_ 为 IsWordChar(_rer_, _Input_, _e_)。
            1. 若 (_a_ 为 *true* 且 _b_ 为 *false*) 或 (_a_ 为 *false* 且 _b_ 为 *true*)，返回 _c_(_x_)。
            1. 返回 ~failure~。
        </emu-alg>
        <emu-grammar>Assertion :: `\B`</emu-grammar>
        <emu-alg>
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _rer_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _e_ 为 _x_.[[EndIndex]]。
            1. 令 _a_ 为 IsWordChar(_rer_, _Input_, _e_ - 1)。
            1. 令 _b_ 为 IsWordChar(_rer_, _Input_, _e_)。
            1. 若 (_a_ 为 *true* 且 _b_ 为 *true*) 或 (_a_ 为 *false* 且 _b_ 为 *false*)，返回 _c_(_x_)。
            1. 返回 ~failure~。
        </emu-alg>
        <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Disjunction| 的 CompileSubpattern，参数 _rer_ 与 ~forward~。
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获无，执行：
              1. 断言：_y_ 是 MatchState。
              1. 返回 _y_。
            1. 令 _r_ 为 _m_(_x_, _d_)。
            1. 若 _r_ 为 ~failure~，返回 ~failure~。
            1. 断言：_r_ 是 MatchState。
            1. 令 _cap_ 为 _r_.[[Captures]]。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _xe_ 为 _x_.[[EndIndex]]。
            1. 令 _z_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }。
            1. 返回 _c_(_z_)。
        </emu-alg>
        <emu-note>
          <p>`(?=` |Disjunction| `)` 是零宽正向先行断言。其成功要求 |Disjunction| 在当前位置匹配，但当前位置在匹配余部前不前进。若 |Disjunction| 在当前位置可多种方式匹配，仅尝试第一种。与其他正则运算不同，不会对 `(?=` 形式进行回溯（此异常行为源自 Perl）。仅当 |Disjunction| 含捕获括号且余部含对其的反向引用时此行为才重要。</p>
          <p>例如：</p>
          <pre><code class="javascript">/(?=(a+))/.exec("baaabac")</code></pre>
          <p>在首个 `b` 之后的空字符串处匹配，返回：</p>
          <pre><code class="javascript">["", "aaa"]</code></pre>
          <p>为说明缺少回溯，考虑：</p>
          <pre><code class="javascript">/(?=(a+))a*b\1/.exec("baaabac")</code></pre>
          <p>该表达式返回</p>
          <pre><code class="javascript">["aba", "a"]</code></pre>
          <p>而非：</p>
          <pre><code class="javascript">["aaaba", "a"]</code></pre>
        </emu-note>
        <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Disjunction| 的 CompileSubpattern，参数 _rer_ 与 ~forward~。
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获无，执行：
              1. 断言：_y_ 是 MatchState。
              1. 返回 _y_。
            1. 令 _r_ 为 _m_(_x_, _d_)。
            1. 若 _r_ 不为 ~failure~，返回 ~failure~。
            1. 返回 _c_(_x_)。
        </emu-alg>
        <emu-note>
          <p>`(?!` |Disjunction| `)` 是零宽负向先行断言。其成功要求 |Disjunction| 在当前位置匹配失败。当前位置在匹配余部前不前进。|Disjunction| 可含捕获括号，但对它们的反向引用仅在 |Disjunction| 内有意义；模式其它位置引用这些捕获总是返回 *undefined*，因为负向先行必须失败整个模式才成功。例如：</p>
          <pre><code class="javascript">/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</code></pre>
          <p>寻找一个 `a`，其后不紧跟着若干（正数 n）个 `a`、一个 `b`、再 n 个 `a`（由第一个 `\\2` 指定）以及一个 `c`。第二个 `\\2` 在负向先行外，匹配 *undefined* 因而总成功。整体返回数组：</p>
          <pre><code class="javascript">["baaabaac", "ba", undefined, "abaac"]</code></pre>
        </emu-note>
        <emu-grammar>Assertion :: `(?&lt;=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Disjunction| 的 CompileSubpattern，参数 _rer_ 与 ~backward~。
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获无，执行：
              1. 断言：_y_ 是 MatchState。
              1. 返回 _y_。
            1. 令 _r_ 为 _m_(_x_, _d_)。
            1. 若 _r_ 为 ~failure~，返回 ~failure~。
            1. 断言：_r_ 是 MatchState。
            1. 令 _cap_ 为 _r_.[[Captures]]。
            1. 令 _Input_ 为 _x_.[[Input]]。
            1. 令 _xe_ 为 _x_.[[EndIndex]]。
            1. 令 _z_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }。
            1. 返回 _c_(_z_)。
        </emu-alg>
        <emu-grammar>Assertion :: `(?&lt;!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Disjunction| 的 CompileSubpattern，参数 _rer_ 与 ~backward~。
          1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _m_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获无，执行：
              1. 断言：_y_ 是 MatchState。
              1. 返回 _y_。
            1. 令 _r_ 为 _m_(_x_, _d_)。
            1. 若 _r_ 不为 ~failure~，返回 ~failure~。
            1. 返回 _c_(_x_)。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-iswordchar-abstract-operation" type="abstract operation">
          <h1>
            IsWordChar (
              _rer_: 一个 RegExp 记录,
              _Input_: 字符列表,
              _e_: 整数,
            ): 布尔值
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _InputLength_ 为 _Input_ 元素数量。
            1. 若 _e_ = -1 或 _e_ = _InputLength_，返回 *false*。
            1. 令 _c_ 为字符 _Input_[_e_]。
            1. 若 WordCharacters(_rer_) 包含 _c_，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilequantifier" type="sdo" oldids="sec-quantifier">
        <h1>运行时语义：CompileQuantifier ( ): 一个记录，字段 [[Min]]（非负整数）、[[Max]]（非负整数或 +&infin;）、[[Greedy]]（布尔值）</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Quantifier :: QuantifierPrefix</emu-grammar>
        <emu-alg>
          1. 令 _qp_ 为 |QuantifierPrefix| 的 CompileQuantifierPrefix。
          1. 返回记录 { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* }。
        </emu-alg>
        <emu-grammar>Quantifier :: QuantifierPrefix `?`</emu-grammar>
        <emu-alg>
          1. 令 _qp_ 为 |QuantifierPrefix| 的 CompileQuantifierPrefix。
          1. 返回记录 { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compilequantifierprefix" type="sdo">
        <h1>运行时语义：CompileQuantifierPrefix ( ): 记录，字段 [[Min]]（非负整数）与 [[Max]]（非负整数或 +&infin;）</h1>
        <dl class="header">
        </dl>
        <emu-grammar>QuantifierPrefix :: `*`</emu-grammar>
        <emu-alg>
          1. 返回记录 { [[Min]]: 0, [[Max]]: +∞ }。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `+`</emu-grammar>
        <emu-alg>
          1. 返回记录 { [[Min]]: 1, [[Max]]: +∞ }。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `?`</emu-grammar>
        <emu-alg>
          1. 返回记录 { [[Min]]: 0, [[Max]]: 1 }。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. 令 _i_ 为 |DecimalDigits| 的 MV（参见 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>）。
          1. 返回记录 { [[Min]]: _i_, [[Max]]: _i_ }。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,}`</emu-grammar>
        <emu-alg>
          1. 令 _i_ 为 |DecimalDigits| 的 MV。
          1. 返回记录 { [[Min]]: _i_, [[Max]]: +∞ }。
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. 令 _i_ 为第一组 |DecimalDigits| 的 MV。
          1. 令 _j_ 为第二组 |DecimalDigits| 的 MV。
          1. 返回记录 { [[Min]]: _i_, [[Max]]: _j_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compileatom" type="sdo" oldids="sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape">
        <h1>
          运行时语义：CompileAtom (
            _rer_: 一个 RegExp 记录,
            _direction_: ~forward~ 或 ~backward~,
          ): 一个 Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-compileatom-annexb"></emu-xref> 中有补充。</p>
        </emu-note>

        <!-- Atom -->
        <emu-grammar>Atom :: PatternCharacter</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |PatternCharacter| 匹配的字符。
          1. 令 _A_ 为包含字符 _ch_ 的单元素 CharSet。
          1. 返回 CharacterSetMatcher(_rer_, _A_, *false*, _direction_)。
        </emu-alg>
        <emu-grammar>Atom :: `.`</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 AllCharacters(_rer_)。
          1. 若 _rer_.[[DotAll]] 不为 *true*，则
            1. 从 _A_ 中移除所有对应 |LineTerminator| 产生式右侧代码点的字符。
          1. 返回 CharacterSetMatcher(_rer_, _A_, *false*, _direction_)。
        </emu-alg>
        <emu-grammar>Atom :: CharacterClass</emu-grammar>
        <emu-alg>
          1. 令 _cc_ 为 |CharacterClass| 的 CompileCharacterClass，参数 _rer_。
          1. 令 _cs_ 为 _cc_.[[CharSet]]。
          1. 若 _rer_.[[UnicodeSets]] 为 *false*，或 _cs_ 的每个 CharSetElement 都是单字符（包括 _cs_ 为空），返回 CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_)。
          1. 断言：_cc_.[[Invert]] 为 *false*。
          1. 令 _lm_ 为空的 Matcher 列表。
          1. 对 _cs_ 中每个包含超过 1 个字符的 CharSetElement _s_（按长度降序）：
            1. 令 _cs2_ 为仅含 _s_ 最后代码点的单元素 CharSet。
            1. 令 _m2_ 为 CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_)。
            1. 对 _s_ 中每个代码点 _c1_（从倒数第二个向前迭代）：
              1. 令 _cs1_ 为仅含 _c1_ 的单元素 CharSet。
              1. 令 _m1_ 为 CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_)。
              1. 设 _m2_ 为 MatchSequence(_m1_, _m2_, _direction_)。
            1. 将 _m2_ 追加入 _lm_。
          1. 令 _singles_ 为包含 _cs_ 中所有单字符 CharSetElement 的 CharSet。
          1. 将 CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) 追加入 _lm_。
          1. 若 _cs_ 含空字符序列，将 EmptyMatcher() 追加入 _lm_。
          1. 令 _m2_ 为 _lm_ 中最后一个 Matcher。
          1. 对 _lm_ 中每个 Matcher _m1_（自倒数第二个向前）：
            1. 设 _m2_ 为 MatchTwoAlternatives(_m1_, _m2_)。
          1. 返回 _m2_。
        </emu-alg>
        <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _m_ 为 |Disjunction| 的 CompileSubpattern，参数 _rer_ 与 _direction_。
          1. 令 _parenIndex_ 为 CountLeftCapturingParensBefore(|Atom|)。
          1. 返回新 Matcher，参数 (_x_, _c_)，捕获 _direction_、_m_、_parenIndex_，执行：
            1. 断言：_x_ 是 MatchState。
            1. 断言：_c_ 是 MatcherContinuation。
            1. 令 _d_ 为新的 MatcherContinuation，参数 (_y_)，捕获 _x_、_c_、_direction_、_parenIndex_，执行：
              1. 断言：_y_ 是 MatchState。
              1. 令 _cap_ 为 _y_.[[Captures]] 的拷贝。
              1. 令 _Input_ 为 _x_.[[Input]]。
              1. 令 _xe_ 为 _x_.[[EndIndex]]。
              1. 令 _ye_ 为 _y_.[[EndIndex]]。
              1. 若 _direction_ 为 ~forward~，则
                1. 断言：_xe_ ≤ _ye_。
                1. 令 _r_ 为 CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }。
              1. 否则，
                1. 断言：_direction_ 为 ~backward~。
                1. 断言：_ye_ ≤ _xe_。
                1. 令 _r_ 为 CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }。
              1. 设 _cap_[_parenIndex_ + 1] = _r_。
              1. 令 _z_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }。
              1. 返回 _c_(_z_)。
            1. 返回 _m_(_x_, _d_)。
        </emu-alg>
        <emu-note>
          <p>`(` |Disjunction| `)` 形式的括号既分组 |Disjunction| 的组件，又保存匹配结果。该结果可用于反向引用（`\\` 加非零十进制数）、替换字符串引用，或作为正则匹配抽象闭包返回数组的一部分。若要禁止捕获行为，使用 `(?:` |Disjunction| `)`。</p>
        </emu-note>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _addModifiers_ 为 |RegularExpressionModifiers| 匹配的源文本。
          1. 令 _removeModifiers_ 为空字符串。
          1. 令 _modifiedRer_ 为 UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), _removeModifiers_)。
          1. 返回 |Disjunction| 的 CompileSubpattern，参数 _modifiedRer_ 与 _direction_。
        </emu-alg>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. 令 _addModifiers_ 为第一个 |RegularExpressionModifiers| 匹配的源文本。
          1. 令 _removeModifiers_ 为第二个 |RegularExpressionModifiers| 匹配的源文本。
          1. 令 _modifiedRer_ 为 UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), CodePointsToString(_removeModifiers_))。
          1. 返回 |Disjunction| 的 CompileSubpattern，参数 _modifiedRer_ 与 _direction_。
        </emu-alg>

        <!-- AtomEscape -->
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <emu-alg>
          1. 令 _n_ 为 |DecimalEscape| 的 CapturingGroupNumber。
          1. 断言：_n_ ≤ _rer_.[[CapturingGroupsCount]]。
          1. 返回 BackreferenceMatcher(_rer_, « _n_ », _direction_)。
        </emu-alg>
        <emu-note>
          <p>`\\` 后随非零十进制数字 _n_ 的转义序列匹配第 _n_ 组捕获括号的结果（<emu-xref href="#sec-pattern-notation"></emu-xref>）。若模式捕获括号少于 _n_ 则错误。若第 _n_ 组存在但为 *undefined*（未捕获任何内容），该反向引用总是成功。</p>
        </emu-note>
        <emu-grammar>AtomEscape :: CharacterEscape</emu-grammar>
        <emu-alg>
          1. 令 _cv_ 为 |CharacterEscape| 的 CharacterValue。
          1. 令 _ch_ 为字符值为 _cv_ 的字符。
          1. 令 _A_ 为包含 _ch_ 的单元素 CharSet。
            1. 返回 CharacterSetMatcher(_rer_, _A_, *false*, _direction_)。
        </emu-alg>
        <emu-grammar>AtomEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. 令 _cs_ 为 |CharacterClassEscape| 的 CompileToCharSet，参数 _rer_。
          1. 若 _rer_.[[UnicodeSets]] 为 *false*，或 _cs_ 的每个 CharSetElement 都是单字符（含空），返回 CharacterSetMatcher(_rer_, _cs_, *false*, _direction_)。
          1. 令 _lm_ 为空 Matcher 列表。
          1. 对 _cs_ 中每个含多于 1 字符的 CharSetElement _s_（按长度降序）：
            1. 令 _cs2_ 为仅含 _s_ 最后代码点的单元素 CharSet。
            1. 令 _m2_ 为 CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_)。
            1. 对 _s_ 中每个代码点 _c1_（自倒数第二个向前）：
              1. 令 _cs1_ 为仅含 _c1_ 的 CharSet。
              1. 令 _m1_ 为 CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_)。
              1. 设 _m2_ 为 MatchSequence(_m1_, _m2_, _direction_)。
            1. 将 _m2_ 追加入 _lm_。
          1. 令 _singles_ 为包含 _cs_ 中所有单字符元素的 CharSet。
          1. 将 CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) 追加入 _lm_。
          1. 若 _cs_ 含空序列，将 EmptyMatcher() 追加入 _lm_。
          1. 令 _m2_ 为 _lm_ 最末 Matcher。
          1. 对 _lm_ 中每个 _m1_（自倒数第二向前）：
            1. 设 _m2_ 为 MatchTwoAlternatives(_m1_, _m2_)。
          1. 返回 _m2_。
        </emu-alg>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <emu-alg>
          1. 令 _matchingGroupSpecifiers_ 为 GroupSpecifiersThatMatch(|GroupName|)。
          1. 令 _parenIndices_ 为新空列表。
          1. 对 _matchingGroupSpecifiers_ 中每个 |GroupSpecifier| _groupSpecifier_：
            1. 令 _parenIndex_ 为 CountLeftCapturingParensBefore(_groupSpecifier_)。
            1. 将 _parenIndex_ 追加入 _parenIndices_。
          1. 返回 BackreferenceMatcher(_rer_, _parenIndices_, _direction_)。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-charactersetmatcher-abstract-operation" type="abstract operation">
          <h1>
            CharacterSetMatcher (
              _rer_: 一个 RegExp 记录,
              _A_: 一个 CharSet,
              _invert_: 布尔值,
              _direction_: ~forward~ 或 ~backward~,
            ): 一个 Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _rer_.[[UnicodeSets]] 为 *true*，则
              1. 断言：_invert_ 为 *false*。
              1. 断言：_A_ 的每个 CharSetElement 皆为单字符。
            1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _rer_、_A_、_invert_、_direction_，执行：
              1. 断言：_x_ 是 MatchState。
              1. 断言：_c_ 是 MatcherContinuation。
              1. 令 _Input_ 为 _x_.[[Input]]。
              1. 令 _e_ 为 _x_.[[EndIndex]]。
              1. 若 _direction_ 为 ~forward~，令 _f_ = _e_ + 1。
              1. 否则令 _f_ = _e_ - 1。
              1. 令 _InputLength_ 为 _Input_ 元素数量。
              1. 若 _f_ &lt; 0 或 _f_ > _InputLength_，返回 ~failure~。
              1. 令 _index_ = min(_e_, _f_)。
              1. 令 _ch_ 为字符 _Input_[_index_]。
              1. 令 _cc_ = Canonicalize(_rer_, _ch_)。
              1. 若存在 _A_ 中某 CharSetElement 含恰一字符 _a_ 且 Canonicalize(_rer_, _a_) = _cc_，令 _found_ = *true*；否则 _found_ = *false*。
              1. 若 _invert_ = *false* 且 _found_ = *false*，返回 ~failure~。
              1. 若 _invert_ = *true* 且 _found_ = *true*，返回 ~failure~。
              1. 令 _cap_ 为 _x_.[[Captures]]。
              1. 令 _y_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }。
              1. 返回 _c_(_y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-backreference-matcher" type="abstract operation">
          <h1>
            BackreferenceMatcher (
              _rer_: 一个 RegExp 记录,
              _ns_: 正整数列表,
              _direction_: ~forward~ 或 ~backward~,
            ): 一个 Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回新的 Matcher，参数 (_x_, _c_)，捕获 _rer_、_ns_、_direction_，执行：
              1. 断言：_x_ 是 MatchState。
              1. 断言：_c_ 是 MatcherContinuation。
              1. 令 _Input_ 为 _x_.[[Input]]。
              1. 令 _cap_ 为 _x_.[[Captures]]。
              1. 令 _r_ 为 *undefined*。
              1. 对 _ns_ 中每个整数 _n_：
                1. 若 _cap_[_n_] 不为 *undefined*，则
                  1. 断言：_r_ 为 *undefined*。
                  1. 设 _r_ = _cap_[_n_]。
              1. 若 _r_ 为 *undefined*，返回 _c_(_x_)。
              1. 令 _e_ 为 _x_.[[EndIndex]]。
              1. 令 _rs_ 为 _r_.[[StartIndex]]。
              1. 令 _re_ 为 _r_.[[EndIndex]]。
              1. 令 _len_ = _re_ - _rs_。
              1. 若 _direction_ 为 ~forward~，令 _f_ = _e_ + _len_；否则 _f_ = _e_ - _len_。
              1. 令 _InputLength_ 为 _Input_ 元素数量。
              1. 若 _f_ &lt; 0 或 _f_ > _InputLength_，返回 ~failure~。
              1. 令 _g_ = min(_e_, _f_)。
              1. 若存在区间 [0, _len_) 内整数 _i_ 使 Canonicalize(_rer_, _Input_[_rs_ + _i_]) ≠ Canonicalize(_rer_, _Input_[_g_ + _i_])，返回 ~failure~。
              1. 令 _y_ 为 MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }。
              1. 返回 _c_(_y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-canonicalize-ch" type="abstract operation">
          <h1>
            Canonicalize (
              _rer_: 一个 RegExp 记录,
              _ch_: 一个字符,
            ): 一个字符
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 HasEitherUnicodeFlag(_rer_) 为 *true* 且 _rer_.[[IgnoreCase]] 为 *true*，则
              1. 若 Unicode 字符数据库文件 <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> 为 _ch_ 提供简单或常用大小写折叠映射，则返回应用该映射后的 _ch_。
              1. 返回 _ch_。
            1. 若 _rer_.[[IgnoreCase]] 为 *false*，返回 _ch_。
            1. 断言：_ch_ 是 UTF-16 代码单元。
            1. 令 _cp_ 为数值等于 _ch_ 数值的代码点。
            1. 令 _u_ 为根据 Unicode 默认大小写转换算法 toUppercase(« _cp_ ») 的结果。
            1. 令 _uStr_ 为 CodePointsToString(_u_)。
            1. 若 _uStr_ 长度 ≠ 1，返回 _ch_。
            1. 令 _cu_ 为 _uStr_ 的单个代码单元。
            1. 若 _ch_ 数值 ≥ 128 且 _cu_ 数值 &lt; 128，返回 _ch_。
            1. 返回 _cu_。
          </emu-alg>
          <emu-note>
            <p>在 HasEitherUnicodeFlag(_rer_) 为 *true* 的不区分大小写匹配中，比较前所有字符按 Unicode 标准提供的 simple case folding 隐式折叠。该映射始终映射到单个代码点，不会将 `ß` 映射到 `ss`/`SS`。但可将非 Basic Latin 代码点映射到该块内，如 `ſ` 折叠到 `s`，`K` 折叠到 `k`。包含这些代码点的字符串可被 `/[a-z]/ui` 匹配。</p>
            <p>在 HasEitherUnicodeFlag(_rer_) 为 *false* 的不区分大小写匹配中，使用的是 toUppercase 而非 toCasefold，有细微差别。例如 `Ω` 被 toUppercase 映射为自身，但 toCasefold 映射为 `ω`，与 `Ω` 一起；因此 *"\u2126"* 被 `/[ω]/ui` 与 `/[\u03A9]/ui` 匹配，却不被 `/[ω]/i` 或 `/[\u03A9]/i` 匹配。且无 Basic Latin 外代码点映射进该块，所以 *"\u017F ſ"* 与 *"\u212A K"* 不被 `/[a-z]/i` 匹配。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-updatemodifiers" type="abstract operation">
          <h1>
            UpdateModifiers (
              _rer_: 一个 RegExp 记录,
              _add_: 字符串,
              _remove_: 字符串,
            ): 一个 RegExp 记录
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 断言：_add_ 与 _remove_ 不含共同元素。
            1. 令 _ignoreCase_ = _rer_.[[IgnoreCase]]。
            1. 令 _multiline_ = _rer_.[[Multiline]]。
            1. 令 _dotAll_ = _rer_.[[DotAll]]。
            1. 令 _unicode_ = _rer_.[[Unicode]]。
            1. 令 _unicodeSets_ = _rer_.[[UnicodeSets]]。
            1. 令 _capturingGroupsCount_ = _rer_.[[CapturingGroupsCount]]。
            1. 若 _remove_ 含 *"i"*，设 _ignoreCase_ = *false*；否则若 _add_ 含 *"i"*，设其为 *true*。
            1. 若 _remove_ 含 *"m"*，设 _multiline_ = *false*；否则若 _add_ 含 *"m"*，设其为 *true*。
            1. 若 _remove_ 含 *"s"*，设 _dotAll_ = *false*；否则若 _add_ 含 *"s"*，设其为 *true*。
            1. 返回 RegExp 记录 { [[IgnoreCase]]: _ignoreCase_, [[Multiline]]: _multiline_, [[DotAll]]: _dotAll_, [[Unicode]]: _unicode_, [[UnicodeSets]]: _unicodeSets_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilecharacterclass" type="sdo" oldids="sec-characterclass">
        <h1>
          运行时语义：CompileCharacterClass (
            _rer_: 一个 RegExp 记录,
          ): 记录，字段 [[CharSet]]（CharSet）与 [[Invert]]（布尔值）
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>CharacterClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 返回记录 { [[CharSet]]: _A_, [[Invert]]: *false* }。
        </emu-alg>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 若 _rer_.[[UnicodeSets]] 为 *true*，则
            1. 返回记录 { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* }。
          1. 返回记录 { [[CharSet]]: _A_, [[Invert]]: *true* }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compiletocharset" type="sdo" oldids="sec-classranges,sec-nonemptyclassranges,sec-nonemptyclassrangesnodash,sec-classatom,sec-classatomnodash,sec-classescape,sec-characterclassescape">
        <h1>
          运行时语义：CompileToCharSet (
            _rer_: 一个 RegExp 记录,
          ): 一个 CharSet
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-compiletocharset-annexb"></emu-xref> 中有补充。</p>
        </emu-note>

        <!-- ClassContents -->
        <emu-grammar>ClassContents :: [empty]</emu-grammar>
        <emu-alg>
          1. 返回空 CharSet。
        </emu-alg>

        <!-- NonemptyClassRanges -->
        <emu-grammar>NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为 |NonemptyClassRangesNoDash| 的 CompileToCharSet，参数 _rer_。
          1. 返回 _A_ 与 _B_ 的并集。
        </emu-alg>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为第一个 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为第二个 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _C_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 令 _D_ 为 CharacterRange(_A_, _B_)。
          1. 返回 _D_ 与 _C_ 的并集。
        </emu-alg>

        <!-- NonemptyClassRangesNoDash -->
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassAtomNoDash| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为 |NonemptyClassRangesNoDash| 的 CompileToCharSet，参数 _rer_。
          1. 返回 _A_ 与 _B_ 的并集。
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassAtomNoDash| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _C_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 令 _D_ 为 CharacterRange(_A_, _B_)。
          1. 返回 _D_ 与 _C_ 的并集。
        </emu-alg>
        <emu-note>
          <p>|ClassContents| 可展开为单个 |ClassAtom|，以及/或由连字符分隔的两个 |ClassAtom| 范围。后者包含两端之间所有字符（含端点）；若任一 |ClassAtom| 不表示单字符（如 \w）或首字符值大于第二个字符值则错误。</p>
        </emu-note>
        <emu-note>
          <p>即便模式忽略大小写，范围两端大小写仍影响范围所含字符。例如 `/[E-F]/i` 只匹配 `E`、`F`、`e`、`f`，而 `/[E-f]/i` 匹配 Basic Latin 中所有大小写字母以及符号 `[`, `\\`, `]`, `^`, `_`, <code>`</code>。</p>
        </emu-note>
        <emu-note>
          <p>`-` 可字面或作范围界定符。位于 |ClassContents| 首/末、范围起止、或紧随范围后时按字面处理。</p>
        </emu-note>

        <!-- ClassAtom -->
        <emu-grammar>ClassAtom :: `-`</emu-grammar>
        <emu-alg>
          1. 返回含单字符 `-` U+002D 的 CharSet。
        </emu-alg>

        <!-- ClassAtomNoDash -->
        <emu-grammar>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</emu-grammar>
        <emu-alg>
          1. 返回含 |SourceCharacter| 匹配字符的 CharSet。
        </emu-alg>

        <!-- ClassEscape -->
        <emu-grammar>
          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. 令 _cv_ 为此 |ClassEscape| 的 CharacterValue。
          1. 令 _c_ 为字符值为 _cv_ 的字符。
          1. 返回含单字符 _c_ 的 CharSet。
        </emu-alg>
        <emu-note>
          <p>|ClassAtom| 可使用除 `\\b`、`\\B`、反向引用外的其他正则转义。在 |CharacterClass| 内，`\\b` 表示退格，`\\B` 与反向引用报错；在 |ClassAtom| 内使用反向引用导致错误。</p>
        </emu-note>

        <!-- CharacterClassEscape -->
        <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>
        <emu-alg>
          1. 返回含字符 `0`..`9` 的十元素 CharSet。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `D`</emu-grammar>
        <emu-alg>
          1. 令 _S_ 为 <emu-grammar>CharacterClassEscape :: `d`</emu-grammar> 返回的 CharSet。
          1. 返回 CharacterComplement(_rer_, _S_)。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>
        <emu-alg>
          1. 返回含 |WhiteSpace| 或 |LineTerminator| 产生式右侧代码点对应字符的 CharSet。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `S`</emu-grammar>
        <emu-alg>
          1. 令 _S_ 为 <emu-grammar>CharacterClassEscape :: `s`</emu-grammar> 返回的 CharSet。
          1. 返回 CharacterComplement(_rer_, _S_)。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>
        <emu-alg>
          1. 返回 MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_))。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `W`</emu-grammar>
        <emu-alg>
          1. 令 _S_ 为 <emu-grammar>CharacterClassEscape :: `w`</emu-grammar> 返回的 CharSet。
          1. 返回 CharacterComplement(_rer_, _S_)。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `p{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. 返回 |UnicodePropertyValueExpression| 的 CompileToCharSet，参数 _rer_。
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. 令 _S_ 为 |UnicodePropertyValueExpression| 的 CompileToCharSet，参数 _rer_。
          1. 断言：_S_ 仅含单代码点。
          1. 返回 CharacterComplement(_rer_, _S_)。
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <emu-alg>
          1. 令 _ps_ 为 |UnicodePropertyName| 匹配的源文本。
          1. 令 _p_ 为 UnicodeMatchProperty(_rer_, _ps_)。
          1. 断言：_p_ 是 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> “Property name and aliases” 列列出的属性名或别名。
          1. 令 _vs_ 为 |UnicodePropertyValue| 匹配的源文本。
          1. 令 _v_ 为 UnicodeMatchPropertyValue(_p_, _vs_)。
          1. 令 _A_ 为含所有在字符数据库定义中具属性 _p_ 且值 _v_ 的 Unicode 代码点的 CharSet。
          1. 返回 MaybeSimpleCaseFolding(_rer_, _A_)。
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. 令 _s_ 为 |LoneUnicodePropertyNameOrValue| 匹配的源文本。
          1. 若 UnicodeMatchPropertyValue(`General_Category`, _s_) 为 General_Category 属性的属性值或别名（见 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>），则
            1. 返回含字符数据库中属性 “General_Category” = _s_ 的所有 Unicode 代码点的 CharSet。
          1. 令 _p_ 为 UnicodeMatchProperty(_rer_, _s_)。
          1. 断言：_p_ 是 <emu-xref href="#table-binary-unicode-properties"></emu-xref> “Property name and aliases” 列列出的二进制属性或别名，或 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> “Property name” 列列出的字符串二进制属性。
          1. 令 _A_ 为含所有字符数据库定义中属性 _p_ = “True” 的 CharSetElement 的 CharSet。
          1. 返回 MaybeSimpleCaseFolding(_rer_, _A_)。
        </emu-alg>

        <!-- ClassUnion -->
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassSetRange| 的 CompileToCharSet，参数 _rer_。
          1. 若 |ClassUnion| 存在，则
            1. 令 _B_ 为 |ClassUnion| 的 CompileToCharSet，参数 _rer_。
            1. 返回 _A_ ∪ _B_。
          1. 返回 _A_。
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 若 |ClassUnion| 存在，则
            1. 令 _B_ 为 |ClassUnion| 的 CompileToCharSet，参数 _rer_。
            1. 返回 _A_ ∪ _B_。
          1. 返回 _A_。
        </emu-alg>

        <!-- ClassIntersection -->
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为第一个 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为第二个 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 返回 _A_ ∩ _B_。
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassIntersection| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 返回 _A_ ∩ _B_。
        </emu-alg>

        <!-- ClassSubtraction -->
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为第一个 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为第二个 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 返回含 _A_ 中不在 _B_ 中的元素的 CharSet。
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassSubtraction| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为 |ClassSetOperand| 的 CompileToCharSet，参数 _rer_。
          1. 返回含 _A_ 中不在 _B_ 中元素的 CharSet。
        </emu-alg>

        <!-- ClassSetRange -->
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为第一个 |ClassSetCharacter| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为第二个 |ClassSetCharacter| 的 CompileToCharSet，参数 _rer_。
          1. 返回 MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_))。
        </emu-alg>
        <emu-note>
          <p>结果通常由多段范围组成。当 UnicodeSets 与 IgnoreCase 同为 *true* 时，MaybeSimpleCaseFolding(_rer_, [Ā-č]) 仅包含该范围中奇数序号代码点。</p>
        </emu-note>

        <!-- ClassSetOperand -->
        <emu-grammar>ClassSetOperand :: ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassSetCharacter| 的 CompileToCharSet，参数 _rer_。
          1. 返回 MaybeSimpleCaseFolding(_rer_, _A_)。
        </emu-alg>
        <emu-grammar>ClassSetOperand :: ClassStringDisjunction</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassStringDisjunction| 的 CompileToCharSet，参数 _rer_。
          1. 返回 MaybeSimpleCaseFolding(_rer_, _A_)。
        </emu-alg>
        <emu-grammar>ClassSetOperand :: NestedClass</emu-grammar>
        <emu-alg>
          1. 返回 |NestedClass| 的 CompileToCharSet，参数 _rer_。
        </emu-alg>

        <!-- NestedClass -->
        <emu-grammar>NestedClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. 返回 |ClassContents| 的 CompileToCharSet，参数 _rer_。
        </emu-alg>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 返回 CharacterComplement(_rer_, _A_)。
        </emu-alg>
        <emu-grammar>NestedClass :: `\` CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. 返回 |CharacterClassEscape| 的 CompileToCharSet，参数 _rer_。
        </emu-alg>

        <!-- ClassStringDisjunction -->
        <emu-grammar>ClassStringDisjunction :: `\q{` ClassStringDisjunctionContents `}`</emu-grammar>
        <emu-alg>
          1. 返回 |ClassStringDisjunctionContents| 的 CompileToCharSet，参数 _rer_。
        </emu-alg>

        <!-- ClassStringDisjunctionContents -->
        <emu-grammar>ClassStringDisjunctionContents :: ClassString</emu-grammar>
        <emu-alg>
          1. 令 _s_ 为 |ClassString| 的 CompileClassSetString，参数 _rer_。
          1. 返回含唯一字符串 _s_ 的 CharSet。
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. 令 _s_ 为 |ClassString| 的 CompileClassSetString，参数 _rer_。
          1. 令 _A_ 为含字符串 _s_ 的 CharSet。
          1. 令 _B_ 为 |ClassStringDisjunctionContents| 的 CompileToCharSet，参数 _rer_。
          1. 返回 _A_ 与 _B_ 的并集。
        </emu-alg>

        <!-- ClassSetCharacter -->
        <emu-grammar>
          ClassSetCharacter ::
            SourceCharacter but not ClassSetSyntaxCharacter
            `\` CharacterEscape
            `\` ClassSetReservedPunctuator
        </emu-grammar>
        <emu-alg>
          1. 令 _cv_ 为此 |ClassSetCharacter| 的 CharacterValue。
          1. 令 _c_ 为字符值为 _cv_ 的字符。
          1. 返回含单字符 _c_ 的 CharSet。
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. 返回含单字符 U+0008 (BACKSPACE) 的 CharSet。
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-characterrange-abstract-operation" type="abstract operation">
          <h1>
            CharacterRange (
              _A_: 一个 CharSet,
              _B_: 一个 CharSet,
            ): 一个 CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 断言：_A_ 与 _B_ 各含恰一字符。
            1. 令 _a_ 为 _A_ 中该字符。
            1. 令 _b_ 为 _B_ 中该字符。
            1. 令 _i_ 为 _a_ 的字符值。
            1. 令 _j_ 为 _b_ 的字符值。
            1. 断言：_i_ ≤ _j_。
            1. 返回含所有字符值位于 [_i_, _j_] 间（含）的字符集合的 CharSet。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-haseitherunicodeflag-abstract-operation" type="abstract operation">
          <h1>
            HasEitherUnicodeFlag (
              _rer_: 一个 RegExp 记录,
            ): 布尔值
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _rer_.[[Unicode]] 为 *true* 或 _rer_.[[UnicodeSets]] 为 *true*，
              1. 返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-wordcharacters" type="abstract operation" oldids="sec-runtime-semantics-wordcharacters-abstract-operation">
          <h1>
            WordCharacters (
              _rer_: 一个 RegExp 记录,
            ): 一个 CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>返回一个包含被视为 `\\b`、`\\B`、`\\w`、`\\W` 之“单词字符”的 CharSet。</dd>
          </dl>
          <emu-alg>
            1. 令 _basicWordChars_ 为含所有 ASCII 单词字符的 CharSet。
            1. 令 _extraWordChars_ 为 CharSet，包含所有不在 _basicWordChars_ 中但 Canonicalize(_rer_, _c_) 在其中的字符 _c_。
            1. 断言：除非 HasEitherUnicodeFlag(_rer_) 为 *true* 且 _rer_.[[IgnoreCase]] 为 *true*，否则 _extraWordChars_ 为空。
            1. 返回 _basicWordChars_ 与 _extraWordChars_ 的并集。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allcharacters" type="abstract operation">
          <h1>
            AllCharacters (
              _rer_: 一个 RegExp 记录,
            ): 一个 CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>依据正则标志返回“全部字符”集合。</dd>
          </dl>
          <emu-alg>
            1. 若 _rer_.[[UnicodeSets]] 为 *true* 且 _rer_.[[IgnoreCase]] 为 *true*，则
              1. [declared="c"] 返回含所有 Unicode 代码点 _c_ 且其 <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> 映射为空（scf(_c_) = _c_）的 CharSet。
            1. 否则若 HasEitherUnicodeFlag(_rer_) 为 *true*，
              1. 返回含所有代码点值的 CharSet。
            1. 否则，
              1. 返回含所有代码单元值的 CharSet。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-maybesimplecasefolding" type="abstract operation">
          <h1>
            MaybeSimpleCaseFolding (
              _rer_: 一个 RegExp 记录,
              _A_: 一个 CharSet,
            ): 一个 CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>若 _rer_.[[UnicodeSets]] 为 *false* 或 _rer_.[[IgnoreCase]] 为 *false*，返回 _A_。否则使用 Unicode 字符数据库文件 <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a>（<emu-eqn id="eqn-scf" aoid="scf">scf(_cp_)</emu-eqn>）定义，对 _A_ 中每个 CharSetElement 进行逐字符映射到规范形式并返回结果。</dd>
          </dl>
          <emu-alg>
            1. 若 _rer_.[[UnicodeSets]] 为 *false* 或 _rer_.[[IgnoreCase]] 为 *false*，返回 _A_。
            1. 令 _B_ 为新空 CharSet。
            1. 对 _A_ 的每个 CharSetElement _s_：
              1. 令 _t_ 为空字符序列。
              1. 对 _s_ 中每个单代码点 _cp_：
                1. 追加 scf(_cp_) 至 _t_。
              1. 将 _t_ 加入 _B_。
            1. 返回 _B_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-charactercomplement" type="abstract operation">
          <h1>
            CharacterComplement (
              _rer_: 一个 RegExp 记录,
              _S_: 一个 CharSet,
            ): 一个 CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _A_ 为 AllCharacters(_rer_)。
            1. 返回含 _A_ 中不在 _S_ 中的 CharSetElement 的 CharSet。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchproperty-p" type="abstract operation">
          <h1>
            UnicodeMatchProperty (
              _rer_: 一个 RegExp 记录,
              _p_: ECMAScript 源文本,
            ): 一个 Unicode 属性名
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _rer_.[[UnicodeSets]] 为 *true* 且 _p_ 是 <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> “Property name” 列列出的 Unicode <emu-not-ref>property name</emu-not-ref>，则
              1. 返回 Unicode 代码点列表 _p_。
            1. 断言：_p_ 为 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> 或 <emu-xref href="#table-binary-unicode-properties"></emu-xref> “Property name and aliases” 列列出的属性名或别名。
            1. 令 _c_ 为该行 “Canonical property name” 列给出的 _p_ 的规范属性名。
            1. 返回 Unicode 代码点列表 _c_。
          </emu-alg>
          <p>实现必须支持 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>、<emu-xref href="#table-binary-unicode-properties"></emu-xref>、<emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref> 中列出的属性名与别名；不得支持其他名称或别名。</p>
          <emu-note>
            <p>例如，`Script_Extensions` 与 `scx` 有效，但 `script_extensions` 或 `Scx` 无效。</p>
          </emu-note>
          <emu-note>
            <p>列出属性集合为 <a href="https://unicode.org/reports/tr18/#RL1.2">UTS18 RL1.2</a> 要求的超集。</p>
          </emu-note>
          <emu-note>
            <p>表中条目拼写（含大小写）与 Unicode 字符数据库 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt"><code>PropertyAliases.txt</code></a> 保持一致，并遵守其稳定性保证。</p>
          </emu-note>
          <emu-import href="table-nonbinary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties-of-strings.html"></emu-import>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchpropertyvalue-p-v" type="abstract operation">
          <h1>
            UnicodeMatchPropertyValue (
              _p_: ECMAScript 源文本,
              _v_: ECMAScript 源文本,
            ): 一个 Unicode 属性值
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 断言：_p_ 为 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> “Canonical property name” 列列出的规范非别名属性名。
            1. 断言：_v_ 是文件 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a> 中属性 _p_ 的属性值或别名。
            1. 令 _value_ 为该行 “Canonical property value” 列中 _v_ 的规范属性值。
            1. 返回 Unicode 代码点列表 _value_。
          </emu-alg>
          <p>实现必须支持 <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a> 中针对 <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> 所列属性的属性值与别名；不得支持其他属性值或别名。</p>
          <emu-note>
            <p>例如，`Xpeo` 与 `Old_Persian` 是有效的 `Script_Extensions` 值，而 `xpeo` 与 `Old Persian` 无效。</p>
          </emu-note>
          <emu-note>
            <p>该算法不同于 <a href="https://unicode.org/reports/tr44/#Matching_Symbolic">UAX44 中符号值匹配规则</a>：不会忽略大小写、空白、U+002D、U+005F，也不支持 `Is` 前缀。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileclasssetstring" type="sdo">
        <h1>
          运行时语义：CompileClassSetString (
            _rer_: 一个 RegExp 记录,
          ): 一个字符序列
        </h1>
        <dl class="header">
        </dl>

        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. 返回空字符序列。
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. 返回 |NonEmptyClassString| 的 CompileClassSetString，参数 _rer_。
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. 令 _cs_ 为 |ClassSetCharacter| 的 CompileToCharSet，参数 _rer_。
          1. 令 _s1_ 为 _cs_ 的单个 CharSetElement 所对应的字符序列。
          1. 若 |NonEmptyClassString| 存在，则
            1. 令 _s2_ 为 |NonEmptyClassString| 的 CompileClassSetString，参数 _rer_。
            1. 返回 _s1_ 与 _s2_ 的连接。
          1. 返回 _s1_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-creation" oldids="sec-abstract-operations-for-the-regexp-constructor">
      <h1>用于创建 RegExp 的抽象操作（Abstract Operations for RegExp Creation）</h1>

      <emu-clause id="sec-regexpcreate" type="abstract operation">
        <h1>
          RegExpCreate (
            _P_: 一个 ECMAScript 语言值,
            _F_: 一个字符串或 *undefined*,
          ): 包含一个对象的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _obj_ 为 ! RegExpAlloc(%RegExp%)。
          1. 返回 ? RegExpInitialize(_obj_, _P_, _F_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpalloc" type="abstract operation">
        <h1>
          RegExpAlloc (
            _newTarget_: 一个构造函数,
          ): 包含一个对象的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _obj_ 为 ? OrdinaryCreateFromConstructor(_newTarget_, *"%RegExp.prototype%"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »)。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"lastIndex"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpinitialize" type="abstract operation">
        <h1>
          RegExpInitialize (
            _obj_: 一个对象,
            _pattern_: 一个 ECMAScript 语言值,
            _flags_: 一个 ECMAScript 语言值,
          ): 包含一个对象的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _pattern_ 是 *undefined*，令 _P_ 为空字符串。
          1. 否则，令 _P_ 为 ? ToString(_pattern_)。
          1. 如果 _flags_ 是 *undefined*，令 _F_ 为空字符串。
          1. 否则，令 _F_ 为 ? ToString(_flags_)。
          1. 如果 _F_ 包含 *"d"*、*"g"*、*"i"*、*"m"*、*"s"*、*"u"*、*"v"*、*"y"* 之外的任一代码单元，或 _F_ 中任一代码单元出现多于一次，抛出 *SyntaxError* 异常。
          1. 如果 _F_ 包含 *"i"*，令 _i_ 为 *true*；否则令 _i_ 为 *false*。
          1. 如果 _F_ 包含 *"m"*，令 _m_ 为 *true*；否则令 _m_ 为 *false*。
          1. 如果 _F_ 包含 *"s"*，令 _s_ 为 *true*；否则令 _s_ 为 *false*。
          1. 如果 _F_ 包含 *"u"*，令 _u_ 为 *true*；否则令 _u_ 为 *false*。
          1. 如果 _F_ 包含 *"v"*，令 _v_ 为 *true*；否则令 _v_ 为 *false*。
          1. 如果 _u_ 为 *true* 或 _v_ 为 *true*，则
            1. 令 _patternText_ 为 StringToCodePoints(_P_)。
          1. 否则，
            1. 令 _patternText_ 为将 _P_ 的每个 16 位元素按 Unicode BMP 代码点解释的结果。不会对这些元素应用 UTF-16 解码。
          1. 令 _parseResult_ 为 ParsePattern(_patternText_, _u_, _v_)。
          1. 如果 _parseResult_ 是一个非空 *SyntaxError* 对象列表，抛出 *SyntaxError* 异常。
          1. 断言：_parseResult_ 是一个 |Pattern| 解析节点。
          1. 设 _obj_.[[OriginalSource]] 为 _P_。
          1. 设 _obj_.[[OriginalFlags]] 为 _F_。
          1. 令 _capturingGroupsCount_ 为 CountLeftCapturingParensWithin(_parseResult_)。
          1. 令 _rer_ 为 RegExp 记录 { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }。
          1. 设 _obj_.[[RegExpRecord]] 为 _rer_。
          1. 设 _obj_.[[RegExpMatcher]] 为 CompilePattern of _parseResult_ with argument _rer_。
          1. 执行 ? <emu-meta suppress-effects="user-code">Set(_obj_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-parsepattern" type="abstract operation">
        <h1>
          静态语义：ParsePattern (
            _patternText_: 一个 Unicode 代码点序列,
            _u_: 一个布尔值,
            _v_: 一个布尔值,
          ): 一个解析节点或非空 *SyntaxError* 对象列表
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>本节在 <emu-xref href="#sec-parsepattern-annexb"></emu-xref> 中有补充。</p>
        </emu-note>
        <emu-alg>
          1. 如果 _v_ 为 *true* 且 _u_ 为 *true*，则
            1. 令 _parseResult_ 为包含一个或多个 *SyntaxError* 对象的列表。
          1. 否则如果 _v_ 为 *true*，则
            1. 令 _parseResult_ 为 ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|)。
          1. 否则如果 _u_ 为 *true*，则
            1. 令 _parseResult_ 为 ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|)。
          1. 否则，
            1. 令 _parseResult_ 为 ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|)。
          1. 返回 _parseResult_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-constructor">
      <h1>RegExp 构造函数（The RegExp Constructor）</h1>
      <p>RegExp 构造函数：</p>
      <ul>
        <li>是 <dfn>%RegExp%</dfn>。</li>
        <li>是全局对象 *"RegExp"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 RegExp 对象。</li>
        <li>作为函数（而非构造函数）调用时，返回一个新的 RegExp 对象，或在唯一参数本身是 RegExp 对象时返回该参数。</li>
        <li>可用作类定义 `extends` 子句的值。打算继承指定 RegExp 行为的子类构造函数必须包含对 RegExp 构造函数的 `super` 调用，以创建并初始化带有所需内部槽的子类实例。</li>
      </ul>

      <emu-clause id="sec-regexp-pattern-flags">
        <h1>RegExp ( _pattern_, _flags_ )</h1>
        <p>调用该函数时执行以下步骤：</p>
        <emu-alg>
          1. 令 _patternIsRegExp_ 为 ? IsRegExp(_pattern_)。
          1. 如果 NewTarget 为 *undefined*，则
            1. 令 _newTarget_ 为活动函数对象。
            1. 如果 _patternIsRegExp_ 为 *true* 且 _flags_ 为 *undefined*，则
              1. 令 _patternConstructor_ 为 ? Get(_pattern_, *"constructor"*)。
              1. 如果 SameValue(_newTarget_, _patternConstructor_) 为 *true*，返回 _pattern_。
          1. 否则，
            1. 令 _newTarget_ 为 NewTarget。
          1. 如果 _pattern_ 是一个对象且具有 [[RegExpMatcher]] 内部槽，则
            1. 令 _P_ 为 _pattern_.[[OriginalSource]]。
            1. 如果 _flags_ 是 *undefined*，令 _F_ 为 _pattern_.[[OriginalFlags]]。
            1. 否则，令 _F_ 为 _flags_。
          1. 否则如果 _patternIsRegExp_ 为 *true*，则
            1. 令 _P_ 为 ? Get(_pattern_, *"source"*)。
            1. 如果 _flags_ 是 *undefined*，则
              1. 令 _F_ 为 ? Get(_pattern_, *"flags"*)。
            1. 否则，
              1. 令 _F_ 为 _flags_。
          1. 否则，
            1. 令 _P_ 为 _pattern_。
            1. 令 _F_ 为 _flags_。
          1. 令 _O_ 为 ? RegExpAlloc(_newTarget_)。
          1. 返回 ? RegExpInitialize(_O_, _P_, _F_)。
        </emu-alg>
        <emu-note>
          <p>如果以 |StringLiteral| 形式传入 pattern，则在本函数处理该字符串之前会执行通常的转义序列替换。如果 pattern 必须包含一个转义序列才能被本函数识别，则 |StringLiteral| 中的任何 U+005C（反斜杠）代码点必须再被转义，以避免在形成 |StringLiteral| 内容时被移除。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>RegExp 构造函数的属性（Properties of the RegExp Constructor）</h1>
      <p>RegExp 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-regexp.escape">
        <h1>RegExp.escape ( _S_ )</h1>
        <p>该函数返回 _S_ 的一个拷贝，其中在正则表达式 |Pattern| 中可能具有特殊意义的字符已被等效转义序列替换。</p>
        <p>调用时执行以下步骤：</p>

        <emu-alg>
          1. 如果 _S_ 不是字符串，抛出 *TypeError* 异常。
          1. 令 _escaped_ 为空字符串。
          1. 令 _cpList_ 为 StringToCodePoints(_S_)。
          1. 对 _cpList_ 中的每个代码点 _cp_，执行
            1. 如果 _escaped_ 为空字符串且 _cp_ 被 |DecimalDigit| 或 |AsciiLetter| 匹配，则
              1. 注：转义前导数字确保输出对应的模式文本可在 `\0` 字符转义或 |DecimalEscape|（如 `\1`）之后使用并仍匹配 _S_，而不是被解释为前一转义序列的延伸。转义前导 ASCII 字母在 `\c` 后的情境中亦如此。
              1. 令 _numericValue_ 为 _cp_ 的数值。
              1. 令 _hex_ 为 Number::toString(𝔽(_numericValue_), 16)。
              1. 断言：_hex_ 的长度为 2。
              1. 设 _escaped_ 为 代码单元 0x005C (REVERSE SOLIDUS)、*"x"* 与 _hex_ 的字符串拼接。
            1. 否则，
              1. 设 _escaped_ 为 _escaped_ 与 EncodeForRegExpEscape(_cp_) 的字符串拼接。
          1. 返回 _escaped_。
        </emu-alg>

        <emu-note>
          <p>尽管名字相似，EscapeRegExpPattern 与 `RegExp.escape` 所做的事情并不相同。前者转义一个模式以便作为字符串表示，而此函数转义一个字符串以便在模式内部表示。</p>
        </emu-note>

        <emu-clause id="sec-encodeforregexpescape" type="abstract operation">
          <h1>
            EncodeForRegExpEscape (
              _cp_: 一个代码点,
            ): 一个字符串
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>返回一个用于匹配 _cp_ 的 |Pattern| 的字符串。如果 _cp_ 是空白或 ASCII 标点，则返回值是一个转义序列；否则返回值是 _cp_ 自身的字符串表示。</dd>
          </dl>

          <emu-alg>
            1. 如果 _cp_ 被 |SyntaxCharacter| 匹配或 _cp_ 是 U+002F (SOLIDUS)，则
              1. 返回 0x005C (REVERSE SOLIDUS) 与 UTF16EncodeCodePoint(_cp_) 的字符串拼接。
            1. 否则如果 _cp_ 是 <emu-xref href="#table-controlescape-code-point-values"></emu-xref> “Code Point” 列所列出的代码点，则
              1. 返回 0x005C (REVERSE SOLIDUS) 与该行 “ControlEscape” 列中字符串的拼接。
            1. 令 _otherPunctuators_ 为 *",-=&lt;>#&amp;!%:;@~'`"* 与代码单元 0x0022 (QUOTATION MARK) 的字符串拼接。
            1. 令 _toEscape_ 为 StringToCodePoints(_otherPunctuators_)。
            1. 如果 _toEscape_ 包含 _cp_，或 _cp_ 被 |WhiteSpace| 或 |LineTerminator| 匹配，或 _cp_ 数值与前导代理或尾随代理相同，则
              1. 令 _cpNum_ 为 _cp_ 的数值。
              1. 如果 _cpNum_ ≤ 0xFF，则
                1. 令 _hex_ 为 Number::toString(𝔽(_cpNum_), 16)。
                1. 返回 代码单元 0x005C (REVERSE SOLIDUS)、*"x"* 与 StringPad(_hex_, 2, *"0"*, ~start~) 的字符串拼接。
              1. 令 _escaped_ 为空字符串。
              1. 令 _codeUnits_ 为 UTF16EncodeCodePoint(_cp_)。
              1. 对 _codeUnits_ 中的每个代码单元 _cu_，执行
                1. 设 _escaped_ 为 _escaped_ 与 UnicodeEscape(_cu_) 的字符串拼接。
              1. 返回 _escaped_。
            1. 返回 UTF16EncodeCodePoint(_cp_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype">
        <h1>RegExp.prototype</h1>
        <p>`RegExp.prototype` 的初始值是 RegExp 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-regexp-@@species" id="sec-get-regexp-%symbol.species%">
        <h1>get RegExp [ %Symbol.species% ]</h1>
        <p>`RegExp[%Symbol.species%]` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>此函数的 *"name"* 属性值为 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>RegExp 原型方法通常使用其 *this* 值的构造函数来创建派生对象。然而，子类构造函数可通过重新定义其 %Symbol.species% 属性来覆盖该默认行为。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>RegExp 原型对象的属性（Properties of the RegExp Prototype Object）</h1>
      <p><dfn>RegExp 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%RegExp.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是 RegExp 实例，且没有 [[RegExpMatcher]] 内部槽或 RegExp 实例对象的其他内部槽。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>
      <emu-note>
        <p>RegExp 原型对象自身没有 *"valueOf"* 属性；但它从 Object 原型对象继承 *"valueOf"* 属性。</p>
      </emu-note>

      <emu-clause id="sec-regexp.prototype.constructor">
        <h1>RegExp.prototype.constructor</h1>
        <p>`RegExp.prototype.constructor` 的初始值是 %RegExp%。</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.exec">
        <h1>RegExp.prototype.exec ( _string_ )</h1>
        <p>该方法在 _string_ 中搜索一次正则表达式模式的出现，并返回包含匹配结果的数组；若 _string_ 未匹配则返回 *null*。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_R_, [[RegExpMatcher]])。
          1. 令 _S_ 为 ? ToString(_string_)。
          1. 返回 ? RegExpBuiltinExec(_R_, _S_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.dotAll">
        <h1>get RegExp.prototype.dotAll</h1>
        <p>`RegExp.prototype.dotAll` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0073 (LATIN SMALL LETTER S)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.flags">
        <h1>get RegExp.prototype.flags</h1>
        <p>`RegExp.prototype.flags` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 如果 _R_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _codeUnits_ 为新的空列表。
          1. 令 _hasIndices_ 为 ToBoolean(? Get(_R_, *"hasIndices"*))。
          1. 如果 _hasIndices_ 为 *true*，将代码单元 0x0064 (LATIN SMALL LETTER D) 追加到 _codeUnits_。
          1. 令 _global_ 为 ToBoolean(? Get(_R_, *"global"*))。
          1. 如果 _global_ 为 *true*，将代码单元 0x0067 (LATIN SMALL LETTER G) 追加到 _codeUnits_。
          1. 令 _ignoreCase_ 为 ToBoolean(? Get(_R_, *"ignoreCase"*))。
          1. 如果 _ignoreCase_ 为 *true*，将代码单元 0x0069 (LATIN SMALL LETTER I) 追加到 _codeUnits_。
          1. 令 _multiline_ 为 ToBoolean(? Get(_R_, *"multiline"*))。
          1. 如果 _multiline_ 为 *true*，将代码单元 0x006D (LATIN SMALL LETTER M) 追加到 _codeUnits_。
          1. 令 _dotAll_ 为 ToBoolean(? Get(_R_, *"dotAll"*))。
          1. 如果 _dotAll_ 为 *true*，将代码单元 0x0073 (LATIN SMALL LETTER S) 追加到 _codeUnits_。
          1. 令 _unicode_ 为 ToBoolean(? Get(_R_, *"unicode"*))。
          1. 如果 _unicode_ 为 *true*，将代码单元 0x0075 (LATIN SMALL LETTER U) 追加到 _codeUnits_。
          1. 令 _unicodeSets_ 为 ToBoolean(? Get(_R_, *"unicodeSets"*))。
          1. 如果 _unicodeSets_ 为 *true*，将代码单元 0x0076 (LATIN SMALL LETTER V) 追加到 _codeUnits_。
          1. 令 _sticky_ 为 ToBoolean(? Get(_R_, *"sticky"*))。
          1. 如果 _sticky_ 为 *true*，将代码单元 0x0079 (LATIN SMALL LETTER Y) 追加到 _codeUnits_。
          1. 返回代码单元为 _codeUnits_ 列表元素的字符串值。若 _codeUnits_ 为空，则返回空字符串。
        </emu-alg>

        <emu-clause id="sec-regexphasflag" type="abstract operation">
          <h1>
            RegExpHasFlag (
              _R_: 一个 ECMAScript 语言值,
              _codeUnit_: 一个代码单元,
            ): 包含布尔值或 *undefined* 的正常完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _R_ 不是对象，抛出 *TypeError* 异常。
            1. 如果 _R_ 没有 [[OriginalFlags]] 内部槽，则
              1. 如果 SameValue(_R_, %RegExp.prototype%) 为 *true*，返回 *undefined*。
              1. 否则，抛出 *TypeError* 异常。
            1. 令 _flags_ 为 _R_.[[OriginalFlags]]。
            1. 如果 _flags_ 包含 _codeUnit_，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.global">
        <h1>get RegExp.prototype.global</h1>
        <p>`RegExp.prototype.global` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0067 (LATIN SMALL LETTER G)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.hasIndices">
        <h1>get RegExp.prototype.hasIndices</h1>
        <p>`RegExp.prototype.hasIndices` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0064 (LATIN SMALL LETTER D)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.ignorecase">
        <h1>get RegExp.prototype.ignoreCase</h1>
        <p>`RegExp.prototype.ignoreCase` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0069 (LATIN SMALL LETTER I)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@match" id="sec-regexp.prototype-%symbol.match%">
        <h1>RegExp.prototype [ %Symbol.match% ] ( _string_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _rx_ 为 *this* 值。
          1. 如果 _rx_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _S_ 为 ? ToString(_string_)。
          1. 令 _flags_ 为 ? ToString(? Get(_rx_, *"flags"*))。
          1. 如果 _flags_ 不包含 *"g"*，则
            1. 返回 ? RegExpExec(_rx_, _S_)。
          1. 否则，
            1. 如果 _flags_ 包含 *"u"* 或 _flags_ 包含 *"v"*，令 _fullUnicode_ 为 *true*；否则令 _fullUnicode_ 为 *false*。
            1. 执行 ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)。
            1. 令 _A_ 为 ! ArrayCreate(0)。
            1. 令 _n_ 为 0。
            1. 重复，
              1. 令 _result_ 为 ? RegExpExec(_rx_, _S_)。
              1. 如果 _result_ 为 *null*，则
                1. 如果 _n_ = 0，返回 *null*。
                1. 返回 _A_。
              1. 否则，
                1. 令 _matchStr_ 为 ? ToString(? Get(_result_, *"0"*))。
                1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_)。
                1. 如果 _matchStr_ 为空字符串，则
                  1. 令 _thisIndex_ 为 ℝ(? ToLength(? Get(_rx_, *"lastIndex"*)))。
                  1. 令 _nextIndex_ 为 AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_)。
                  1. 执行 ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*)。
                1. 设 _n_ 为 _n_ + 1。
        </emu-alg>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.match]"*。</p>
        <emu-note>
          <p>%Symbol.match% 属性被 IsRegExp 抽象操作用于识别具有基本正则行为的对象。缺失 %Symbol.match% 属性或其值布尔化结果不为 *true* 表示该对象不打算作为正则表达式对象使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-regexp-prototype-matchall" id="sec-regexp-prototype-%symbol.matchall%">
        <h1>RegExp.prototype [ %Symbol.matchAll% ] ( _string_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 如果 _R_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _S_ 为 ? ToString(_string_)。
          1. 令 _C_ 为 ? SpeciesConstructor(_R_, %RegExp%)。
          1. 令 _flags_ 为 ? ToString(? Get(_R_, *"flags"*))。
          1. 令 _matcher_ 为 ? Construct(_C_, « _R_, _flags_ »)。
          1. 令 _lastIndex_ 为 ? ToLength(? Get(_R_, *"lastIndex"*))。
          1. 执行 ? Set(_matcher_, *"lastIndex"*, _lastIndex_, *true*)。
          1. 如果 _flags_ 包含 *"g"*，令 _global_ 为 *true*。
          1. 否则，令 _global_ 为 *false*。
          1. 如果 _flags_ 包含 *"u"* 或 _flags_ 包含 *"v"*，令 _fullUnicode_ 为 *true*。
          1. 否则，令 _fullUnicode_ 为 *false*。
          1. 返回 CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_)。
        </emu-alg>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.matchAll]"*。</p>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.multiline">
        <h1>get RegExp.prototype.multiline</h1>
        <p>`RegExp.prototype.multiline` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x006D (LATIN SMALL LETTER M)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@replace" id="sec-regexp.prototype-%symbol.replace%">
        <h1>RegExp.prototype [ %Symbol.replace% ] ( _string_, _replaceValue_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _rx_ 为 *this* 值。
          1. 如果 _rx_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _S_ 为 ? ToString(_string_)。
          1. 令 _lengthS_ 为 _S_ 的长度。
          1. 令 _functionalReplace_ 为 IsCallable(_replaceValue_)。
          1. 如果 _functionalReplace_ 为 *false*，则
            1. 将 _replaceValue_ 设为 ? ToString(_replaceValue_)。
          1. 令 _flags_ 为 ? ToString(? Get(_rx_, *"flags"*))。
          1. 如果 _flags_ 包含 *"g"*，令 _global_ 为 *true*；否则令 _global_ 为 *false*。
          1. 如果 _global_ 为 *true*，则
            1. 执行 ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)。
          1. 令 _results_ 为新的空列表。
          1. 令 _done_ 为 *false*。
          1. 当 _done_ 为 *false* 时重复，
            1. 令 _result_ 为 ? RegExpExec(_rx_, _S_)。
            1. 如果 _result_ 为 *null*，则
              1. 设 _done_ 为 *true*。
            1. 否则，
              1. 将 _result_ 追加到 _results_。
              1. 如果 _global_ 为 *false*，则
                1. 设 _done_ 为 *true*。
              1. 否则，
                1. 令 _matchStr_ 为 ? ToString(? Get(_result_, *"0"*))。
                1. 如果 _matchStr_ 为空字符串，则
                  1. 令 _thisIndex_ 为 ℝ(? ToLength(? Get(_rx_, *"lastIndex"*)))。
                  1. 如果 _flags_ 包含 *"u"* 或 _flags_ 包含 *"v"*，令 _fullUnicode_ 为 *true*；否则令 _fullUnicode_ 为 *false*。
                  1. 令 _nextIndex_ 为 AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_)。
                  1. 执行 ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*)。
          1. 令 _accumulatedResult_ 为空字符串。
          1. 令 _nextSourcePosition_ 为 0。
          1. 对 _results_ 中的每个元素 _result_，执行
            1. 令 _resultLength_ 为 ? LengthOfArrayLike(_result_)。
            1. 令 _nCaptures_ 为 max(_resultLength_ - 1, 0)。
            1. 令 _matched_ 为 ? ToString(? Get(_result_, *"0"*))。
            1. 令 _matchLength_ 为 _matched_ 的长度。
            1. 令 _position_ 为 ? ToIntegerOrInfinity(? Get(_result_, *"index"*))。
            1. 将 _position_ 钳制到 0 与 _lengthS_ 之间。
            1. 令 _captures_ 为新的空列表。
            1. 令 _n_ 为 1。
            1. 当 _n_ ≤ _nCaptures_ 时重复，
              1. 令 _capN_ 为 ? Get(_result_, ! ToString(𝔽(_n_)))。
              1. 如果 _capN_ 不为 *undefined*，则
                1. 设 _capN_ 为 ? ToString(_capN_)。
              1. 将 _capN_ 追加到 _captures_。
              1. 注：当 _n_ = 1 时，上一步将首元素放入 _captures_（索引 0）。更一般地，第 _n_ 个捕获位于 _captures_[_n_ - 1]。
              1. 设 _n_ 为 _n_ + 1。
            1. 令 _namedCaptures_ 为 ? Get(_result_, *"groups"*)。
            1. 如果 _functionalReplace_ 为 *true*，则
              1. 令 _replacerArgs_ 为 « _matched_ » 与 _captures_ 以及 « 𝔽(_position_), _S_ » 的列表拼接。
              1. 如果 _namedCaptures_ 不为 *undefined*，则
                1. 将 _namedCaptures_ 追加到 _replacerArgs_。
              1. 令 _replacementValue_ 为 ? Call(_replaceValue_, *undefined*, _replacerArgs_)。
              1. 令 _replacementString_ 为 ? ToString(_replacementValue_)。
            1. 否则，
              1. 如果 _namedCaptures_ 不为 *undefined*，则
                1. 设 _namedCaptures_ 为 ? ToObject(_namedCaptures_)。
              1. 令 _replacementString_ 为 ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_)。
            1. 如果 _position_ ≥ _nextSourcePosition_，则
              1. 注：_position_ 通常不应后移；若后移，说明存在行为不良的 RegExp 子类或通过访问触发副作用更改 _rx_ 的 global 标志或其他特性。在此类情况下，对应替换被忽略。
              1. 设 _accumulatedResult_ 为 _accumulatedResult_、_S_ 的子串（从 _nextSourcePosition_ 到 _position_）、_replacementString_ 的串联。
              1. 设 _nextSourcePosition_ 为 _position_ + _matchLength_。
          1. 如果 _nextSourcePosition_ ≥ _lengthS_，返回 _accumulatedResult_。
          1. 返回 _accumulatedResult_ 与 _S_ 自 _nextSourcePosition_ 起子串的拼接。
        </emu-alg>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.replace]"*。</p>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@search" id="sec-regexp.prototype-%symbol.search%">
        <h1>RegExp.prototype [ %Symbol.search% ] ( _string_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _rx_ 为 *this* 值。
          1. 如果 _rx_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _S_ 为 ? ToString(_string_)。
          1. 令 _previousLastIndex_ 为 ? Get(_rx_, *"lastIndex"*)。
          1. 如果 _previousLastIndex_ 不是 *+0*<sub>𝔽</sub>，则
            1. 执行 ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)。
          1. 令 _result_ 为 ? RegExpExec(_rx_, _S_)。
          1. 令 _currentLastIndex_ 为 ? Get(_rx_, *"lastIndex"*)。
          1. 如果 SameValue(_currentLastIndex_, _previousLastIndex_) 为 *false*，则
            1. 执行 ? Set(_rx_, *"lastIndex"*, _previousLastIndex_, *true*)。
          1. 如果 _result_ 为 *null*，返回 *-1*<sub>𝔽</sub>。
          1. 返回 ? Get(_result_, *"index"*)。
        </emu-alg>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.search]"*。</p>
        <emu-note>
          <p>执行搜索时忽略该 RegExp 对象的 *"lastIndex"* 与 *"global"* 属性。*"lastIndex"* 属性保持不变。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.source">
        <h1>get RegExp.prototype.source</h1>
        <p>`RegExp.prototype.source` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 如果 _R_ 不是对象，抛出 *TypeError* 异常。
          1. 如果 _R_ 没有 [[OriginalSource]] 内部槽，则
            1. 如果 SameValue(_R_, %RegExp.prototype%) 为 *true*，返回 *"(?:)"*。
            1. 否则，抛出 *TypeError* 异常。
          1. 断言：_R_ 具有 [[OriginalFlags]] 内部槽。
          1. 令 _src_ 为 _R_.[[OriginalSource]]。
          1. 令 _flags_ 为 _R_.[[OriginalFlags]]。
          1. 返回 EscapeRegExpPattern(_src_, _flags_)。
        </emu-alg>

        <emu-clause id="sec-escaperegexppattern" type="abstract operation">
          <h1>
            EscapeRegExpPattern (
              _P_: 一个字符串,
              _F_: 一个字符串,
            ): 一个字符串
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _F_ 包含 *"v"*，则
              1. 令 _patternSymbol_ 为 |Pattern[+UnicodeMode, +UnicodeSetsMode]|。
            1. 否则如果 _F_ 包含 *"u"*，则
              1. 令 _patternSymbol_ 为 |Pattern[+UnicodeMode, ~UnicodeSetsMode]|。
            1. 否则，
              1. 令 _patternSymbol_ 为 |Pattern[~UnicodeMode, ~UnicodeSetsMode]|。
            1. 令 _S_ 为一种 _patternSymbol_ 形式的字符串，该字符串等价于将 _P_ 按 UTF-16 编码的 Unicode 代码点解释（<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>）后对特定代码点按下述规则转义得到的结果。_S_ 可能与 _P_ 相同或不同；但对 _S_ 作为 _patternSymbol_ 求值得到的抽象闭包必须与构造对象 [[RegExpMatcher]] 内部槽给出的抽象闭包行为一致。对同一 _P_ 与 _F_ 的多次调用必须产生相同结果。
            1. 模式中出现的 `/` 或任何 |LineTerminator| 必须在 _S_ 中按需转义，以确保 *"/"*、_S_、*"/"* 与 _F_ 的字符串拼接（在适当词法上下文中）可被解析为与所构造正则表达式行为一致的 |RegularExpressionLiteral|。例如，如果 _P_ 是 *"/"*，则 _S_ 可以是 *"\\/"* 或 *"\\u002F"* 等，但不能是 *"/"*，因为 `///` 后随 _F_ 会被解析为 |SingleLineComment| 而非 |RegularExpressionLiteral|。如果 _P_ 是空字符串，本规范可通过让 _S_ 为 *"(?:)"* 来满足。
            1. 返回 _S_。
          </emu-alg>

          <emu-note>
            <p>尽管名字相似，`RegExp.escape` 与 EscapeRegExpPattern 所做事情不同。前者转义一个字符串以用于模式内部，后者转义一个模式以作为字符串表示。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@split" id="sec-regexp.prototype-%symbol.split%">
        <h1>RegExp.prototype [ %Symbol.split% ] ( _string_, _limit_ )</h1>
        <emu-note>
          <p>该方法返回一个数组，数组中存放将 _string_ 转为字符串结果的各子串。子串通过自左向右搜索 *this* 值正则表达式的匹配来确定；这些出现不属于返回数组中任何字符串，而是用来分割字符串值。</p>
          <p>*this* 值可以是一个空正则或一个可匹配空字符串的正则。在此情况下，正则不会匹配输入字符串开头或末尾的空 <emu-not-ref>substring</emu-not-ref>，也不会匹配前一次分隔符匹配末尾的空 <emu-not-ref>substring</emu-not-ref>。（例如，如果正则匹配空字符串，则字符串被拆分为单个代码单元；结果数组长度等于字符串长度，每个 <emu-not-ref>substring</emu-not-ref> 包含一个代码单元。）在给定索引处只考虑第一次匹配，即便回溯可能在该索引产生非空 <emu-not-ref>substring</emu-not-ref>。 （例如，`/a*?/[Symbol.split]("ab")` 结果为 `["a", "b"]`，而 `/a*/[Symbol.split]("ab")` 结果为 `["","b"]`。）</p>
          <p>如果 _string_ 是（或转换为）空字符串，结果取决于正则是否能匹配空字符串。若能，结果数组无元素；否则结果数组含一个元素，即空字符串。</p>
          <p>如果正则包含捕获括号，则每次匹配 _separator_ 时捕获括号的结果（包括 *undefined*）会被拼接进输出数组。例如：</p>
          <pre><code class="javascript">/&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split]("A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;")</code></pre>
          <p>计算结果为数组</p>
          <pre><code class="javascript">["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]</code></pre>
          <p>如果 _limit_ 不为 *undefined*，则输出数组截断为不超过 _limit_ 个元素。</p>
        </emu-note>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _rx_ 为 *this* 值。
          1. 如果 _rx_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _S_ 为 ? ToString(_string_)。
          1. 令 _C_ 为 ? SpeciesConstructor(_rx_, %RegExp%)。
          1. 令 _flags_ 为 ? ToString(? Get(_rx_, *"flags"*))。
          1. 如果 _flags_ 包含 *"u"* 或 _flags_ 包含 *"v"*，令 _unicodeMatching_ 为 *true*。
          1. 否则，令 _unicodeMatching_ 为 *false*。
          1. 如果 _flags_ 包含 *"y"*，令 _newFlags_ 为 _flags_。
          1. 否则，令 _newFlags_ 为 _flags_ 与 *"y"* 的串联。
          1. 令 _splitter_ 为 ? Construct(_C_, « _rx_, _newFlags_ »)。
          1. 令 _A_ 为 ! ArrayCreate(0)。
          1. 令 _lengthA_ 为 0。
          1. 如果 _limit_ 是 *undefined*，令 _lim_ 为 2<sup>32</sup> - 1；否则令 _lim_ 为 ℝ(? ToUint32(_limit_))。
          1. 如果 _lim_ = 0，返回 _A_。
          1. 如果 _S_ 是空字符串，则
            1. 令 _z_ 为 ? RegExpExec(_splitter_, _S_)。
            1. 如果 _z_ 不为 *null*，返回 _A_。
            1. 执行 ! CreateDataPropertyOrThrow(_A_, *"0"*, _S_)。
            1. 返回 _A_。
          1. 令 _size_ 为 _S_ 的长度。
          1. 令 _p_ 为 0。
          1. 令 _q_ 为 _p_。
          1. 当 _q_ &lt; _size_ 时重复，
            1. 执行 ? Set(_splitter_, *"lastIndex"*, 𝔽(_q_), *true*)。
            1. 令 _z_ 为 ? RegExpExec(_splitter_, _S_)。
            1. 如果 _z_ 为 *null*，则
              1. 设 _q_ 为 AdvanceStringIndex(_S_, _q_, _unicodeMatching_)。
            1. 否则，
              1. 令 _e_ 为 ℝ(? ToLength(? Get(_splitter_, *"lastIndex"*)))。
              1. 设 _e_ 为 min(_e_, _size_)。
              1. 如果 _e_ = _p_，则
                1. 设 _q_ 为 AdvanceStringIndex(_S_, _q_, _unicodeMatching_)。
              1. 否则，
                1. 令 _T_ 为 _S_ 从 _p_ 到 _q_ 的子串。
                1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_)。
                1. 设 _lengthA_ 为 _lengthA_ + 1。
                1. 如果 _lengthA_ = _lim_，返回 _A_。
                1. 设 _p_ 为 _e_。
                1. 令 _numberOfCaptures_ 为 ? LengthOfArrayLike(_z_)。
                1. 设 _numberOfCaptures_ 为 max(_numberOfCaptures_ - 1, 0)。
                1. 令 _i_ 为 1。
                1. 当 _i_ ≤ _numberOfCaptures_ 时重复，
                  1. 令 _nextCapture_ 为 ? Get(_z_, ! ToString(𝔽(_i_)))。
                  1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_)。
                  1. 设 _i_ 为 _i_ + 1。
                  1. 设 _lengthA_ 为 _lengthA_ + 1。
                  1. 如果 _lengthA_ = _lim_，返回 _A_。
                1. 设 _q_ 为 _p_。
          1. 令 _T_ 为 _S_ 从 _p_ 到 _size_ 的子串。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_)。
          1. 返回 _A_。
        </emu-alg>
        <p>该方法的 *"name"* 属性值为 *"[Symbol.split]"*。</p>
        <emu-note>
          <p>该方法忽略此 RegExp 对象的 *"global"* 与 *"sticky"* 属性的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.sticky">
        <h1>get RegExp.prototype.sticky</h1>
        <p>`RegExp.prototype.sticky` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0079 (LATIN SMALL LETTER Y)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.test">
        <h1>RegExp.prototype.test ( _S_ )</h1>
        <p>调用该方法时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 如果 _R_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _string_ 为 ? ToString(_S_)。
          1. 令 _match_ 为 ? RegExpExec(_R_, _string_)。
          1. 如果 _match_ 不为 *null*，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.tostring">
        <h1>RegExp.prototype.toString ( )</h1>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 如果 _R_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _pattern_ 为 ? ToString(? Get(_R_, *"source"*))。
          1. 令 _flags_ 为 ? ToString(? Get(_R_, *"flags"*))。
          1. 令 _result_ 为 *"/"*、_pattern_、*"/"*、_flags_ 的字符串拼接。
          1. 返回 _result_。
        </emu-alg>
        <emu-note>
          <p>返回的字符串形式为 |RegularExpressionLiteral|，其求值得到的另一个 RegExp 对象与此对象行为相同。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicode">
        <h1>get RegExp.prototype.unicode</h1>
        <p>`RegExp.prototype.unicode` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0075 (LATIN SMALL LETTER U)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicodesets">
        <h1>get RegExp.prototype.unicodeSets</h1>
        <p>`RegExp.prototype.unicodeSets` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _R_ 为 *this* 值。
          1. 令 _cu_ 为代码单元 0x0076 (LATIN SMALL LETTER V)。
          1. 返回 ? RegExpHasFlag(_R_, _cu_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-matching">
      <h1>用于 RegExp 匹配的抽象操作（Abstract Operations for RegExp Matching）</h1>

      <emu-clause id="sec-regexpexec" type="abstract operation">
        <h1>
          RegExpExec (
            _R_: 一个对象,
            _S_: 一个字符串,
          ): 包含对象或 *null* 的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _exec_ 为 ? Get(_R_, *"exec"*)。
          1. 如果 IsCallable(_exec_) 为 *true*，则
            1. 令 _result_ 为 ? Call(_exec_, _R_, « _S_ »)。
            1. 如果 _result_ 不是对象且不为 *null*，抛出 *TypeError* 异常。
            1. 返回 _result_。
          1. 执行 ? RequireInternalSlot(_R_, [[RegExpMatcher]])。
          1. 返回 ? RegExpBuiltinExec(_R_, _S_)。
        </emu-alg>
        <emu-note>
          <p>如果未找到可调用的 *"exec"* 属性，本算法会回退到使用内置的 RegExp 匹配算法。这为旧版本编写的代码提供兼容行为——在那些版本中，大多数使用正则的内置算法不会对 *"exec"* 进行动态属性查找。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-regexpbuiltinexec" type="abstract operation">
        <h1>
          RegExpBuiltinExec (
            _R_: 一个已初始化的 RegExp 实例,
            _S_: 一个字符串,
          ): 包含数组特异对象或 *null* 的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _length_ 为 _S_ 的长度。
          1. 令 _lastIndex_ 为 ℝ(? ToLength(! Get(_R_, *"lastIndex"*)))。
          1. 令 _flags_ 为 _R_.[[OriginalFlags]]。
          1. 如果 _flags_ 包含 *"g"*，令 _global_ 为 *true*；否则令 _global_ 为 *false*。
          1. 如果 _flags_ 包含 *"y"*，令 _sticky_ 为 *true*；否则令 _sticky_ 为 *false*。
          1. 如果 _flags_ 包含 *"d"*，令 _hasIndices_ 为 *true*；否则令 _hasIndices_ 为 *false*。
          1. 如果 _global_ 为 *false* 且 _sticky_ 为 *false*，设 _lastIndex_ 为 0。
          1. 令 _matcher_ 为 _R_.[[RegExpMatcher]]。
          1. 如果 _flags_ 包含 *"u"* 或 _flags_ 包含 *"v"*，令 _fullUnicode_ 为 *true*；否则令 _fullUnicode_ 为 *false*。
          1. 令 _matchSucceeded_ 为 *false*。
          1. 如果 _fullUnicode_ 为 *true*，令 _input_ 为 StringToCodePoints(_S_)；否则令 _input_ 为一个列表，其元素为 _S_ 的代码单元。
          1. 注：_input_ 的每个元素都被视为一个字符。
          1. 当 _matchSucceeded_ 为 *false* 时重复，
            1. 如果 _lastIndex_ > _length_，则
              1. 如果 _global_ 为 *true* 或 _sticky_ 为 *true*，则
                1. 执行 ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>。
              1. 返回 *null*。
            1. 令 _inputIndex_ 为对应 _S_ 第 _lastIndex_ 个元素的字符在 _input_ 中的索引。
            1. 令 _r_ 为 _matcher_(_input_, _inputIndex_)。
            1. 如果 _r_ 为 ~failure~，则
              1. 如果 _sticky_ 为 *true*，则
                1. 执行 ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>。
                1. 返回 *null*。
              1. 设 _lastIndex_ 为 AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_)。
            1. 否则，
              1. 断言：_r_ 是 MatchState。
              1. 设 _matchSucceeded_ 为 *true*。
          1. 令 _e_ 为 _r_.[[EndIndex]]。
          1. 如果 _fullUnicode_ 为 *true*，设 _e_ 为 GetStringIndex(_S_, _e_)。
          1. 如果 _global_ 为 *true* 或 _sticky_ 为 *true*，则
            1. 执行 ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, 𝔽(_e_), *true*)</emu-meta>。
          1. 令 _n_ 为 _r_.[[Captures]] 中的元素数量。
          1. 断言：_n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]]。
          1. 断言：_n_ &lt; 2<sup>32</sup> - 1。
          1. 令 _A_ 为 ! ArrayCreate(_n_ + 1)。
          1. 断言：_A_ 的 *"length"* 属性的数学值为 _n_ + 1。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, *"index"*, 𝔽(_lastIndex_))。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, *"input"*, _S_)。
          1. 令 _match_ 为 Match 记录 { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }。
          1. 令 _indices_ 为新的空列表。
          1. 令 _groupNames_ 为新的空列表。
          1. 将 _match_ 追加到 _indices_。
          1. 令 _matchedSubstr_ 为 GetMatchString(_S_, _match_)。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, *"0"*, _matchedSubstr_)。
          1. 如果 _R_ 包含任意 |GroupName|，则
            1. 令 _groups_ 为 OrdinaryObjectCreate(*null*)。
            1. 令 _hasGroups_ 为 *true*。
          1. 否则，
            1. 令 _groups_ 为 *undefined*。
            1. 令 _hasGroups_ 为 *false*。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_)。
          1. 令 _matchedGroupNames_ 为新的空列表。
          1. 对每个整数 _i_（1 ≤ _i_ ≤ _n_，升序），执行
            1. 令 _captureI_ 为 _r_.[[Captures]] 的第 _i_ 个元素。
            1. 如果 _captureI_ 为 *undefined*，则
              1. 令 _capturedValue_ 为 *undefined*。
              1. 将 *undefined* 追加到 _indices_。
            1. 否则，
              1. 令 _captureStart_ 为 _captureI_.[[StartIndex]]。
              1. 令 _captureEnd_ 为 _captureI_.[[EndIndex]]。
              1. 如果 _fullUnicode_ 为 *true*，则
                1. 设 _captureStart_ 为 GetStringIndex(_S_, _captureStart_)。
                1. 设 _captureEnd_ 为 GetStringIndex(_S_, _captureEnd_)。
              1. 令 _capture_ 为 Match 记录 { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }。
              1. 令 _capturedValue_ 为 GetMatchString(_S_, _capture_)。
              1. 将 _capture_ 追加到 _indices_。
            1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_)。
            1. 如果 _R_ 的第 _i_ 个捕获是用 |GroupName| 定义的，则
              1. 令 _s_ 为该 |GroupName| 的 CapturingGroupName。
              1. 如果 _matchedGroupNames_ 包含 _s_，则
                1. 断言：_capturedValue_ 为 *undefined*。
                1. 将 *undefined* 追加到 _groupNames_。
              1. 否则，
                1. 如果 _capturedValue_ 不为 *undefined*，将 _s_ 追加到 _matchedGroupNames_。
                1. 注：若多个组名为 _s_，_groups_ 此时可能已有 _s_ 属性；但由于 _groups_ 是所有属性皆可写的数据属性的普通对象，CreateDataPropertyOrThrow 调用仍保证成功。
                1. 执行 ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_)。
                1. 将 _s_ 追加到 _groupNames_。
            1. 否则，
              1. 将 *undefined* 追加到 _groupNames_。
          1. 如果 _hasIndices_ 为 *true*，则
            1. 令 _indicesArray_ 为 MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_)。
            1. 执行 ! CreateDataPropertyOrThrow(_A_, *"indices"*, _indicesArray_)。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-advancestringindex" type="abstract operation">
        <h1>
          AdvanceStringIndex (
            _S_: 一个字符串,
            _index_: 一个非负整数,
            _unicode_: 一个布尔值,
          ): 一个整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_index_ ≤ 2<sup>53</sup> - 1。
          1. 如果 _unicode_ 为 *false*，返回 _index_ + 1。
          1. 令 _length_ 为 _S_ 的长度。
          1. 如果 _index_ + 1 ≥ _length_，返回 _index_ + 1。
          1. 令 _cp_ 为 CodePointAt(_S_, _index_)。
          1. 返回 _index_ + _cp_.[[CodeUnitCount]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getstringindex" type="abstract operation">
        <h1>
          GetStringIndex (
            _S_: 一个字符串,
            _codePointIndex_: 一个非负整数,
          ): 一个非负整数
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 将 _S_ 解释为 UTF-16 编码代码点序列，返回与代码点索引 _codePointIndex_ 对应的代码单元索引（若存在）。否则返回 _S_ 的长度。</dd>
        </dl>
        <emu-alg>
          1. 如果 _S_ 是空字符串，返回 0。
          1. 令 _len_ 为 _S_ 的长度。
          1. 令 _codeUnitCount_ 为 0。
          1. 令 _codePointCount_ 为 0。
          1. 当 _codeUnitCount_ &lt; _len_ 时重复，
            1. 如果 _codePointCount_ = _codePointIndex_，返回 _codeUnitCount_。
            1. 令 _cp_ 为 CodePointAt(_S_, _codeUnitCount_)。
            1. 设 _codeUnitCount_ 为 _codeUnitCount_ + _cp_.[[CodeUnitCount]]。
            1. 设 _codePointCount_ 为 _codePointCount_ + 1。
          1. 返回 _len_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-match-records">
        <h1>匹配记录（Match Records）</h1>
        <p><dfn variants="Match Records">Match 记录</dfn> 是用于封装正则匹配或捕获起止索引的记录值。</p>
        <p>Match 记录具有 <emu-xref href="#table-match-record"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-match-record" caption="Match 记录字段">
          <table>
            <thead>
              <tr>
                <th>字段名</th>
                <th>值</th>
                <th>含义</th>
              </tr>
            </thead>
            <tr>
              <td>[[StartIndex]]</td>
              <td>一个非负整数</td>
              <td>从字符串起始处开始（含）匹配开始的代码单元数量。</td>
            </tr>
            <tr>
              <td>[[EndIndex]]</td>
              <td>一个 ≥ [[StartIndex]] 的整数</td>
              <td>从字符串起始处开始匹配结束（不含）位置的代码单元数量。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getmatchstring" type="abstract operation">
        <h1>
          GetMatchString (
            _S_: 一个字符串,
            _match_: 一个 Match 记录,
          ): 一个字符串
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ _S_ 的长度。
          1. 返回 _S_ 中从 _match_.[[StartIndex]] 到 _match_.[[EndIndex]] 的子串。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmatchindexpair" type="abstract operation">
        <h1>
          GetMatchIndexPair (
            _S_: 一个字符串,
            _match_: 一个 Match 记录,
          ): 一个数组
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ _S_ 的长度。
          1. 返回 CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) »)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makematchindicesindexpairarray" type="abstract operation">
        <h1>
          MakeMatchIndicesIndexPairArray (
            _S_: 一个字符串,
            _indices_: 一个由 Match 记录或 *undefined* 组成的列表,
            _groupNames_: 一个由字符串或 *undefined* 组成的列表,
            _hasGroups_: 一个布尔值,
          ): 一个数组
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _n_ 为 _indices_ 的元素数量。
          1. 断言：_n_ &lt; 2<sup>32</sup> - 1。
          1. 断言：_groupNames_ 有 _n_ - 1 个元素。
          1. 注：_groupNames_ 列表的元素与 _indices_ 列表自 _indices_[1] 起对齐。
          1. 令 _A_ 为 ! ArrayCreate(_n_)。
          1. 如果 _hasGroups_ 为 *true*，则
            1. 令 _groups_ 为 OrdinaryObjectCreate(*null*)。
          1. 否则，
            1. 令 _groups_ 为 *undefined*。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_)。
          1. 对每个整数 _i_（0 ≤ _i_ &lt; _n_，升序），执行
            1. 令 _matchIndices_ 为 _indices_[_i_]。
            1. 如果 _matchIndices_ 不为 *undefined*，则
              1. 令 _matchIndexPair_ 为 GetMatchIndexPair(_S_, _matchIndices_)。
            1. 否则，
              1. 令 _matchIndexPair_ 为 *undefined*。
            1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_)。
            1. 如果 _i_ > 0，则
              1. 令 _s_ 为 _groupNames_[_i_ - 1]。
              1. 如果 _s_ 不为 *undefined*，则
                1. 断言：_groups_ 不为 *undefined*。
                1. 注：若多个组名为 _s_，_groups_ 此时可能已有 _s_ 属性；但由于 _groups_ 是所有属性皆可写的数据属性的普通对象，CreateDataPropertyOrThrow 调用仍保证成功。
                1. 执行 ! CreateDataPropertyOrThrow(_groups_, _s_, _matchIndexPair_)。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-regexp-instances">
      <h1>RegExp 实例的属性（Properties of RegExp Instances）</h1>
      <p>RegExp 实例是普通对象，从 RegExp 原型对象继承属性。RegExp 实例具有内部槽 [[OriginalSource]]、[[OriginalFlags]]、[[RegExpRecord]] 与 [[RegExpMatcher]]。[[RegExpMatcher]] 内部槽的值是该 RegExp 对象 |Pattern| 的抽象闭包表示。</p>
      <emu-note>
        <p>在 ECMAScript 2015 之前，RegExp 实例被指定为拥有自身数据属性 *"source"*、*"global"*、*"ignoreCase"* 与 *"multiline"*。这些属性现在被指定为 `RegExp.prototype` 的存取器属性。</p>
      </emu-note>
      <p>RegExp 实例还具有以下属性：</p>

      <emu-clause id="sec-lastindex">
        <h1>lastIndex</h1>
        <p>*"lastIndex"* 属性的值指定下一次匹配开始的字符串索引。使用时将其强制转换为整数 Number（参见 <emu-xref href="#sec-regexpbuiltinexec"></emu-xref>）。此属性具有 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-string-iterator-objects">
      <h1>RegExp 字符串迭代器对象</h1>
      <p><dfn variants="RegExp String Iterators,RegExp String Iterator object,RegExp String Iterator objects">RegExp String Iterator</dfn> 是一个对象，表示针对某个特定 String 实例对象、以某个特定 RegExp 实例对象进行匹配时的特定迭代过程。RegExp String Iterator 对象没有命名构造函数；相反，它们通过调用某些 RegExp 实例对象的方法创建。</p>

      <emu-clause id="sec-createregexpstringiterator" type="abstract operation">
        <h1>
          CreateRegExpStringIterator (
            _R_: 一个对象,
            _S_: 一个字符串,
            _global_: 一个布尔值,
            _fullUnicode_: 一个布尔值,
          ): 一个对象
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _iterator_ 为 OrdinaryObjectCreate(%RegExpStringIteratorPrototype%, « [[IteratingRegExp]], [[IteratedString]], [[Global]], [[Unicode]], [[Done]] »)。
          1. 设 _iterator_.[[IteratingRegExp]] 为 _R_。
          1. 设 _iterator_.[[IteratedString]] 为 _S_。
          1. 设 _iterator_.[[Global]] 为 _global_。
          1. 设 _iterator_.[[Unicode]] 为 _fullUnicode_。
          1. 设 _iterator_.[[Done]] 为 *false*。
          1. 返回 _iterator_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%regexpstringiteratorprototype%-object">
        <h1>%RegExpStringIteratorPrototype% 对象</h1>
        <p><dfn>%RegExpStringIteratorPrototype%</dfn> 对象：</p>
        <ul>
          <li>具有所有 RegExp String Iterator 对象继承的属性。</li>
          <li>是一个普通对象。</li>
          <li>有一个 [[Prototype]] 内部槽，其值为 %Iterator.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%regexpstringiteratorprototype%.next">
          <h1>%RegExpStringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. 令 _O_ 为 *this* 值。
            1. 若 _O_ 不是对象，抛出 *TypeError* 异常。
            1. 若 _O_ 不具有 RegExp String Iterator 对象实例的全部内部槽（见 <emu-xref href="#sec-properties-of-regexp-string-iterator-instances"></emu-xref>），抛出 *TypeError* 异常。
            1. 若 _O_.[[Done]] 为 *true*，则
              1. 返回 CreateIteratorResultObject(*undefined*, *true*)。
            1. 令 _R_ 为 _O_.[[IteratingRegExp]]。
            1. 令 _S_ 为 _O_.[[IteratedString]]。
            1. 令 _global_ 为 _O_.[[Global]]。
            1. 令 _fullUnicode_ 为 _O_.[[Unicode]]。
            1. 令 _match_ 为 ? RegExpExec(_R_, _S_)。
            1. 若 _match_ 为 *null*，则
              1. 设 _O_.[[Done]] 为 *true*。
              1. 返回 CreateIteratorResultObject(*undefined*, *true*)。
            1. 若 _global_ 为 *false*，则
              1. 设 _O_.[[Done]] 为 *true*。
              1. 返回 CreateIteratorResultObject(_match_, *false*)。
            1. 令 _matchStr_ 为 ? ToString(? Get(_match_, *"0"*))。
            1. 若 _matchStr_ 为空字符串，则
              1. 令 _thisIndex_ 为 ℝ(? ToLength(? Get(_R_, *"lastIndex"*)))。
              1. 令 _nextIndex_ 为 AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_)。
              1. 执行 ? Set(_R_, *"lastIndex"*, 𝔽(_nextIndex_), *true*)。
            1. 返回 CreateIteratorResultObject(_match_, *false*)。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%regexpstringiteratorprototype%-@@tostringtag" id="sec-%regexpstringiteratorprototype%-%symbol.tostringtag%">
          <h1>%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 属性的初始值为字符串 *"RegExp String Iterator"*。</p>
          <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-regexp-string-iterator-instances">
        <h1>RegExp String Iterator 实例的属性</h1>
        <p>RegExp String Iterator 实例是普通对象，从内建对象 %RegExpStringIteratorPrototype% 继承属性。RegExp String Iterator 实例最初以 <emu-xref href="#table-regexp-string-iterator-instance-slots"></emu-xref> 中列出的内部槽创建。</p>
        <emu-table id="table-regexp-string-iterator-instance-slots" caption="RegExp String Iterator 实例的内部槽">
          <table>
            <tr>
              <th>内部槽</th>
              <th>类型</th>
              <th>描述</th>
            </tr>
            <tr>
              <td>[[IteratingRegExp]]</td>
              <td>an Object</td>
              <td>用于迭代的正则表达式。IsRegExp([[IteratingRegExp]]) 初始为 *true*。</td>
            </tr>
            <tr>
              <td>[[IteratedString]]</td>
              <td>a String</td>
              <td>当前被迭代的字符串值。</td>
            </tr>
            <tr>
              <td>[[Global]]</td>
              <td>a Boolean</td>
              <td>指示 [[IteratingRegExp]] 是否为全局模式。</td>
            </tr>
            <tr>
              <td>[[Unicode]]</td>
              <td>a Boolean</td>
              <td>指示 [[IteratingRegExp]] 是否处于 Unicode 模式。</td>
            </tr>
            <tr>
              <td>[[Done]]</td>
              <td>a Boolean</td>
              <td>指示迭代是否完成。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>索引集合（Indexed Collections）</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array 对象</h1>
    <p>Array 是一种对某类属性名进行特殊处理的异质（exotic）对象。该特殊处理的定义见 <emu-xref href="#sec-array-exotic-objects"></emu-xref>。</p>

    <emu-clause id="sec-array-constructor">
      <h1>Array 构造函数</h1>
      <p>Array 构造函数：</p>
      <ul>
        <li>是 <dfn>%Array%</dfn>。</li>
        <li>是全局对象 *"Array"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Array。</li>
        <li>作为函数（而非构造函数）调用时同样创建并初始化一个新的 Array。因此函数调用 `Array(…)` 等价于使用相同参数的对象创建表达式 `new Array(…)`。</li>
        <li>其行为随参数数量与类型不同而不同。</li>
        <li>可用作类定义 `extends` 子句的值。打算继承数组异质行为的子类构造函数必须包含对 Array 构造函数的 `super` 调用，以初始化作为数组异质对象的子类实例。但大多数 `Array.prototype` 方法是泛型的，不依赖其 *this* 为数组异质对象。</li>
      </ul>

      <emu-clause id="sec-array" oldids="sec-array-constructor-array,sec-array-len,sec-array-items">
        <h1>Array ( ..._values_ )</h1>
        <p>此函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 NewTarget 为 *undefined*，令 _newTarget_ 为活动函数对象；否则令 _newTarget_ 为 NewTarget。
          1. 令 _proto_ 为 ? GetPrototypeFromConstructor(_newTarget_, *"%Array.prototype%"*)。
          1. 令 _numberOfArgs_ 为 _values_ 中元素的数量。
          1. 若 _numberOfArgs_ = 0，则
            1. 返回 ! ArrayCreate(0, _proto_)。
          1. 否则若 _numberOfArgs_ = 1，则
            1. 令 _len_ 为 _values_[0]。
            1. 令 _array_ 为 ! ArrayCreate(0, _proto_)。
            1. 若 _len_ 不是 Number，则
              1. 执行 ! CreateDataPropertyOrThrow(_array_, *"0"*, _len_)。
              1. 令 _intLen_ 为 *1*<sub>𝔽</sub>。
            1. 否则，
              1. 令 _intLen_ 为 ! ToUint32(_len_)。
              1. 若 SameValueZero(_intLen_, _len_) 为 *false*，抛出 *RangeError* 异常。
            1. 执行 ! Set(_array_, *"length"*, _intLen_, *true*)。
            1. 返回 _array_。
          1. 否则，
            1. 断言：_numberOfArgs_ ≥ 2。
            1. 令 _array_ 为 ? ArrayCreate(_numberOfArgs_, _proto_)。
            1. 令 _k_ 为 0。
            1. 当 _k_ &lt; _numberOfArgs_ 时重复，
              1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
              1. 令 _itemK_ 为 _values_[_k_]。
              1. 执行 ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_)。
              1. 令 _k_ = _k_ + 1。
            1. 断言：_array_ 的 *"length"* 属性数学值为 _numberOfArgs_。
            1. 返回 _array_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Array 构造函数的属性</h1>
      <p>Array 构造函数：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有 *"length"* 属性，其值为 *1*<sub>𝔽</sub>。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-array.from">
        <h1>Array.from ( _items_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>此方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 若 _mapper_ 为 *undefined*，则
            1. 令 _mapping_ 为 *false*。
          1. 否则，
            1. 若 IsCallable(_mapper_) 为 *false*，抛出 *TypeError* 异常。
            1. 令 _mapping_ 为 *true*。
          1. 令 _usingIterator_ 为 ? GetMethod(_items_, %Symbol.iterator%)。
          1. 若 _usingIterator_ 不为 *undefined*，则
            1. 若 IsConstructor(_C_) 为 *true*，则
              1. 令 _A_ 为 ? Construct(_C_)。
            1. 否则，
              1. 令 _A_ 为 ! ArrayCreate(0)。
            1. 令 _iteratorRecord_ 为 ? GetIteratorFromMethod(_items_, _usingIterator_)。
            1. 令 _k_ 为 0。
            1. 重复，
              1. 若 _k_ ≥ 2<sup>53</sup> - 1，则
                1. 令 _error_ 为 ThrowCompletion(新建的 *TypeError* 对象)。
                1. 返回 ? IteratorClose(_iteratorRecord_, _error_)。
              1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
              1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
              1. 若 _next_ 为 ~done~，则
                1. 执行 ? Set(_A_, *"length"*, 𝔽(_k_), *true*)。
                1. 返回 _A_。
              1. 若 _mapping_ 为 *true*，则
                1. 令 _mappedValue_ 为 Completion(Call(_mapper_, _thisArg_, « _next_, 𝔽(_k_) »))。
                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_)。
              1. 否则，
                1. 令 _mappedValue_ 为 _next_。
              1. 令 _defineStatus_ 为 Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_))。
              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_)。
              1. 令 _k_ = _k_ + 1。
          1. 注：_items_ 不可迭代，假定为类数组对象。
          1. 令 _arrayLike_ 为 ! ToObject(_items_)。
          1. 令 _len_ 为 ? LengthOfArrayLike(_arrayLike_)。
          1. 若 IsConstructor(_C_) 为 *true*，则
            1. 令 _A_ 为 ? Construct(_C_, « 𝔽(_len_) »)。
          1. 否则，
            1. 令 _A_ 为 ? ArrayCreate(_len_)。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 时重复，
            1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
            1. 令 _kValue_ 为 ? Get(_arrayLike_, _Pk_)。
            1. 若 _mapping_ 为 *true*，则
              1. 令 _mappedValue_ 为 ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »)。
            1. 否则，
              1. 令 _mappedValue_ 为 _kValue_。
            1. 执行 ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)。
            1. 令 _k_ = _k_ + 1。
          1. 执行 ? Set(_A_, *"length"*, 𝔽(_len_), *true*)。
          1. 返回 _A_。
        </emu-alg>
        <emu-note>
          <p>此方法是刻意设计的通用工厂方法；其 *this* 不必为 Array 构造函数，因此可被其他可用单个数值参数调用的构造函数继承或转移使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.isarray">
        <h1>Array.isArray ( _arg_ )</h1>
        <p>此函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 ? IsArray(_arg_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.of">
        <h1>Array.of ( ..._items_ )</h1>
        <p>此方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _len_ 为 _items_ 中元素数量。
          1. 令 _lenNumber_ 为 𝔽(_len_)。
          1. 令 _C_ 为 *this* 值。
          1. 若 IsConstructor(_C_) 为 *true*，则
            1. 令 _A_ 为 ? Construct(_C_, « _lenNumber_ »)。
          1. 否则，
            1. 令 _A_ 为 ? ArrayCreate(_len_)。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 时重复，
            1. 令 _kValue_ 为 _items_[_k_]。
            1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
            1. 执行 ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_)。
            1. 令 _k_ = _k_ + 1。
          1. 执行 ? Set(_A_, *"length"*, _lenNumber_, *true*)。
          1. 返回 _A_。
        </emu-alg>
        <emu-note>
          <p>此方法是刻意设计的通用工厂方法；其 *this* 不必为 Array 构造函数，因此可被其它构造函数继承或转移使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype">
        <h1>Array.prototype</h1>
        <p>`Array.prototype` 的值是 Array 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-array-@@species" id="sec-get-array-%symbol.species%">
        <h1>get Array [ %Symbol.species% ]</h1>
        <p>`Array[%Symbol.species%]` 是一个存取器属性，其 set 访问器为 *undefined*。其 get 访问器被调用时执行：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数 *"name"* 属性值为 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>Array 原型方法通常使用其 *this* 的构造函数来创建派生对象；子类可通过重定义 %Symbol.species% 覆盖该默认行为。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-prototype-object">
      <h1>Array 原型对象的属性</h1>
      <p><dfn>Array 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Array.prototype%</dfn>。</li>
        <li>是一个 Array 异质对象，具有该类对象规定的内部方法。</li>
        <li>有 *"length"* 属性，其初始值为 *+0*<sub>𝔽</sub>，属性特性为 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      </ul>
      <emu-note>
        <p>指定为数组异质对象以保持与 ECMAScript 2015 之前代码的兼容性。</p>
      </emu-note>

      <emu-clause id="sec-array.prototype.at">
        <h1>Array.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. 令 _O_ 为 ? ToObject(*this* value)。
          1. 令 _len_ 为 ? LengthOfArrayLike(_O_)。
          1. 令 _relativeIndex_ 为 ? ToIntegerOrInfinity(_index_)。
          1. 若 _relativeIndex_ ≥ 0，则
            1. 令 _k_ = _relativeIndex_。
          1. 否则，
            1. 令 _k_ = _len_ + _relativeIndex_。
          1. 若 _k_ &lt; 0 或 _k_ ≥ _len_，返回 *undefined*。
          1. 返回 ? Get(_O_, ! ToString(𝔽(_k_)))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.concat">
        <h1>Array.prototype.concat ( ..._items_ )</h1>
        <p>返回一个数组，包含对象自身元素后接各参数的数组元素。</p>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 ? ToObject(*this* value)。
          1. 令 _A_ 为 ? ArraySpeciesCreate(_O_, 0)。
          1. 令 _n_ = 0。
          1. 将 _O_ 前置到 _items_。
          1. 对 _items_ 中每个元素 _E_：
            1. 令 _spreadable_ 为 ? IsConcatSpreadable(_E_)。
            1. 若 _spreadable_ 为 *true*，
              1. 令 _len_ 为 ? LengthOfArrayLike(_E_)。
              1. 若 _n_ + _len_ > 2<sup>53</sup> - 1，抛出 *TypeError*。
              1. 令 _k_ = 0。
              1. 当 _k_ &lt; _len_：
                1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
                1. 令 _exists_ 为 ? HasProperty(_E_, _Pk_)。
                1. 若 _exists_ 为 *true*，
                  1. 令 _subElement_ 为 ? Get(_E_, _Pk_)。
                  1. 执行 ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_)。
                1. 令 _n_ = _n_ + 1。
                1. 令 _k_ = _k_ + 1。
            1. 否则，
              1. 注：_E_ 作为单个元素添加。
              1. 若 _n_ ≥ 2<sup>53</sup> - 1，抛出 *TypeError*。
              1. 执行 ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_)。
              1. 令 _n_ = _n_ + 1。
          1. [id="step-array-proto-concat-set-length"] 执行 ? Set(_A_, *"length"*, 𝔽(_n_), *true*)。
          1. 返回 _A_。
        </emu-alg>
        <p>此方法 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>显式设置 *"length"*（参见 <emu-xref href="#step-array-proto-concat-set-length"></emu-xref>）以确保尾部存在空洞或 _A_ 不是内置数组时长度正确。</p>
        </emu-note>
        <emu-note>
          <p>本方法为泛型；*this* 不要求是 Array，可转移给其他对象使用。</p>
        </emu-note>

        <emu-clause id="sec-isconcatspreadable" type="abstract operation">
          <h1>
            IsConcatSpreadable (
              _O_: an ECMAScript language value,
            ): 包含布尔值的正常完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 _O_ 不是对象，返回 *false*。
            1. 令 _spreadable_ 为 ? Get(_O_, %Symbol.isConcatSpreadable%)。
            1. 若 _spreadable_ 不为 *undefined*，返回 ToBoolean(_spreadable_)。
            1. 返回 ? IsArray(_O_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.constructor">
        <h1>Array.prototype.constructor</h1>
        <p>`Array.prototype.constructor` 的初始值为 %Array%。</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.copywithin">
        <h1>Array.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <emu-note>
          <p>_end_ 可选；缺省使用 *this* 的长度。</p>
        </emu-note>
        <emu-note>
          <p>负的 _target_ / _start_ / _end_ 分别视为 <emu-eqn>_length_ + 参数</emu-eqn>。</p>
        </emu-note>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 ? ToObject(*this* value)。
          1. 令 _len_ 为 ? LengthOfArrayLike(_O_)。
          1. 令 _relativeTarget_ 为 ? ToIntegerOrInfinity(_target_)。
          1. 若 _relativeTarget_ = -∞，令 _to_ = 0。
          1. 否则若 _relativeTarget_ &lt; 0，令 _to_ = max(_len_ + _relativeTarget_, 0)。
          1. 否则令 _to_ = min(_relativeTarget_, _len_)。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _from_ = 0。
          1. 否则若 _relativeStart_ &lt; 0，令 _from_ = max(_len_ + _relativeStart_, 0)。
          1. 否则令 _from_ = min(_relativeStart_, _len_)。
          1. 若 _end_ 为 *undefined*，令 _relativeEnd_ = _len_；否则令 _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，令 _final_ = 0。
          1. 否则若 _relativeEnd_ &lt; 0，令 _final_ = max(_len_ + _relativeEnd_, 0)。
          1. 否则令 _final_ = min(_relativeEnd_, _len_)。
          1. 令 _count_ = min(_final_ - _from_, _len_ - _to_)。
          1. 若 _from_ &lt; _to_ 且 _to_ &lt; _from_ + _count_，则
            1. 令 _direction_ = -1。
            1. 令 _from_ = _from_ + _count_ - 1。
            1. 令 _to_ = _to_ + _count_ - 1。
          1. 否则令 _direction_ = 1。
          1. 当 _count_ > 0：
            1. 令 _fromKey_ = ! ToString(𝔽(_from_))。
            1. 令 _toKey_ = ! ToString(𝔽(_to_))。
            1. 令 _fromPresent_ = ? HasProperty(_O_, _fromKey_)。
            1. 若 _fromPresent_ 为 *true*，
              1. 令 _fromValue_ = ? Get(_O_, _fromKey_)。
              1. 执行 ? Set(_O_, _toKey_, _fromValue_, *true*)。
            1. 否则
              1. 执行 ? DeletePropertyOrThrow(_O_, _toKey_)。
            1. _from_ += _direction_。
            1. _to_ += _direction_。
            1. _count_ -= 1。
          1. 返回 _O_。
        </emu-alg>
        <emu-note>
          <p>方法为泛型，可转移到其它对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.entries">
        <h1>Array.prototype.entries ( )</h1>
        <p>调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 ? ToObject(*this* value)。
          1. 返回 CreateArrayIterator(_O_, ~key+value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.every">
        <h1>Array.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>依次（升序）对存在的元素调用 _callback_，若遇到返回 *false* 的元素立即返回 *false*；否则返回 *true*。空数组结果为 *true*。</p>
        </emu-note>
        <p>执行步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 ? ToObject(*this* value)。
          1. 令 _len_ 为 ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError*。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. 令 _kValue_ = ? Get(_O_, _Pk_)。
              1. 令 _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
              1. 若 _testResult_ 为 *false*，返回 *false*。
            1. _k_ = _k_ + 1。
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>泛型方法，可转移使用。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.fill">
        <h1>Array.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <emu-note>
          <p>_start_ 缺省 *+0*<sub>𝔽</sub>；_end_ 缺省为长度；负值按长度偏移。</p>
        </emu-note>
        <p>执行步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，_k_ = 0；否则若 < 0，_k_ = max(_len_ + _relativeStart_, 0)；否则 _k_ = min(_relativeStart_, _len_)。
          1. 若 _end_ 为 *undefined*，_relativeEnd_ = _len_；否则 _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，_final_ = 0；否则若 < 0，_final_ = max(_len_ + _relativeEnd_, 0)；否则 _final_ = min(_relativeEnd_, _len_)。
          1. 当 _k_ &lt; _final_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. ? Set(_O_, _Pk_, _value_, *true*)。
            1. _k_++。
          1. 返回 _O_。
        </emu-alg>
        <emu-note>
          <p>泛型方法。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.filter">
        <h1>Array.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>对现有元素调用 _callback_，收集返回 *true* 的值构成新数组。</p>
        </emu-note>
        <p>执行步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false* 抛 *TypeError*。
          1. _A_ = ? ArraySpeciesCreate(_O_, 0)。
          1. _k_ = 0；_to_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _selected_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
              1. 若 _selected_：
                1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_)。
                1. _to_++。
            1. _k_++。
          1. 返回 _A_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.find">
        <h1>Array.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>升序查找首个使 _predicate_ 结果为真值的元素，找不到返回 *undefined*。</p>
        </emu-note>
        <p>执行步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Value]]。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findindex">
        <h1>Array.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>升序查找首个满足谓词的索引，未找到返回 -1。</p>
        </emu-note>
        <p>执行：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Index]]。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlast">
        <h1>Array.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>降序查找首个满足谓词的元素，未找到返回 *undefined*。</p>
        </emu-note>
        <p>执行：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Value]]。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlastindex">
        <h1>Array.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>降序查找首个满足谓词的索引，未找到返回 -1。</p>
        </emu-note>
        <p>执行：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _findRec_ = ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Index]]。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>

        <emu-clause id="sec-findviapredicate" type="abstract operation">
          <h1>
            FindViaPredicate (
              _O_: an Object,
              _len_: a non-negative integer,
              _direction_: ~ascending~ or ~descending~,
              _predicate_: an ECMAScript language value,
              _thisArg_: an ECMAScript language value,
            ): 返回含 [[Index]] 与 [[Value]] 字段的记录或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              <p>遍历 _O_ 的索引（升序或降序）调用 _predicate_，返回首个真值对应的索引与值；若无则索引 *-1*<sub>𝔽</sub>，值 *undefined*。</p>
              <p>_predicate_ 接收 (元素值, 索引, 被遍历对象)。</p>
              <p>_thisArg_ 作为 *this* 使用。</p>
              <p>不直接修改 _O_；_predicate_ 可修改。</p>
              <p>遍历范围在开始前确定；新增元素不访问；修改元素按访问时值；删除后再访问的仍按原序列访问（TypedArray 特例除外按语义）。</p>
            </dd>
          </dl>
          <emu-alg>
            1. 若 IsCallable(_predicate_) 为 *false* 抛 *TypeError*。
            1. 若 _direction_ 为 ~ascending~，
              1. 令 _indices_ 为 [0, …, _len_-1] 升序列表。
            1. 否则，
              1. 令 _indices_ 为 [0, …, _len_-1] 降序列表。
            1. 对 _indices_ 中每个整数 _k_：
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. 注：若 _O_ 是 TypedArray，调用 Get 为正常完成。
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _testResult_ = ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
              1. 若 ToBoolean(_testResult_) 为 *true*，返回 { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ }。
            1. 返回 { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* }。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flat">
        <h1>Array.prototype.flat ( [ _depth_ ] )</h1>
        <p>调用时执行：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _sourceLen_ = ? LengthOfArrayLike(_O_)。
          1. _depthNum_ = 1。
          1. 若 _depth_ 非 *undefined*：
            1. _depthNum_ = ? ToIntegerOrInfinity(_depth_)。
            1. 若 _depthNum_ &lt; 0，设为 0。
          1. _A_ = ? ArraySpeciesCreate(_O_, 0)。
          1. ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_)。
          1. 返回 _A_。
        </emu-alg>

        <emu-clause id="sec-flattenintoarray" type="abstract operation">
          <h1>
            FlattenIntoArray (
            _target_: an Object,
            _source_: an Object,
            _sourceLen_: a non-negative integer,
            _start_: a non-negative integer,
            _depth_: a non-negative integer or +∞,
            optional _mapperFunction_: a function object,
            optional _thisArg_: an ECMAScript language value,
            ): either a normal completion containing a non-negative integer or a throw completion
          </h1>
          <emu-alg>
            1. 断言：若提供 _mapperFunction_，则 IsCallable(_mapperFunction_) 为 *true*，_thisArg_ 存在且 _depth_ = 1。
            1. _targetIndex_ = _start_。
            1. _sourceIndex_ = *+0*<sub>𝔽</sub>。
            1. 当 ℝ(_sourceIndex_) &lt; _sourceLen_：
              1. _P_ = ! ToString(_sourceIndex_)。
              1. _exists_ = ? HasProperty(_source_, _P_)。
              1. 若 _exists_：
                1. _element_ = ? Get(_source_, _P_)。
                1. 若有 _mapperFunction_：_element_ = ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »)。
                1. _shouldFlatten_ = *false*。
                1. 若 _depth_ > 0：_shouldFlatten_ = ? IsArray(_element_)。
                1. 若 _shouldFlatten_：
                  1. 若 _depth_ = +∞，_newDepth_ = +∞；否则 _newDepth_ = _depth_ - 1。
                  1. _elementLen_ = ? LengthOfArrayLike(_element_)。
                  1. _targetIndex_ = ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_)。
                1. 否则：
                  1. 若 _targetIndex_ ≥ 2<sup>53</sup> - 1 抛 *TypeError*。
                  1. ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_)。
                  1. _targetIndex_++。
              1. _sourceIndex_ += *1*<sub>𝔽</sub>。
            1. 返回 _targetIndex_。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flatmap">
        <h1>Array.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>执行步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _sourceLen_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_mapperFunction_) 为 *false* 抛 *TypeError*。
          1. _A_ = ? ArraySpeciesCreate(_O_, 0)。
          1. ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_)。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.foreach">
        <h1>Array.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>对存在元素升序调用 _callback_，不返回聚合值，缺失元素略过。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false* 抛 *TypeError*。
          1. _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_++。
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.includes">
        <h1>Array.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>使用 SameValueZero 比较，找到即返回 *true*，未找到 *false*；不跳过空洞（空洞按 *undefined*）。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 _len_ = 0 返回 *false*。
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_)。
          1. 断言：若 _fromIndex_ 为 *undefined*，_n_ = 0。
          1. 若 _n_ = +∞ 返回 *false*；若 _n_ = -∞ 令 _n_ = 0。
          1. 若 _n_ ≥ 0：_k_ = _n_；否则 _k_ = _len_ + _n_，若 _k_ &lt; 0 则 _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _elementK_ = ? Get(_O_, ! ToString(𝔽(_k_)))。
            1. 若 SameValueZero(_searchElement_, _elementK_) 为 *true* 返回 *true*。
            1. _k_++。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
        <emu-note>
          <p>区别于 `indexOf`：使用 SameValueZero 并且不跳过空洞。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.indexof">
        <h1>Array.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>使用 IsStrictlyEqual 升序查找首个匹配索引，未找到返回 *-1*<sub>𝔽</sub>（跳过空洞）。</p>
        <emu-note>
          <p>_fromIndex_ 缺省 *+0*<sub>𝔽</sub>；可为负表示从末尾偏移。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 _len_ = 0 返回 *-1*<sub>𝔽</sub>。
          1. _n_ = ? ToIntegerOrInfinity(_fromIndex_)。
          1. 断言：_fromIndex_ 为 *undefined* 时 _n_ = 0。
          1. 若 _n_ = +∞ 返回 *-1*<sub>𝔽</sub>；若 _n_ = -∞ 置 0。
          1. 若 _n_ ≥ 0：_k_ = _n_；否则 _k_ = _len_ + _n_，若 _k_ &lt; 0 则 0。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _elementK_ = ? Get(_O_, _Pk_)。
              1. 若 IsStrictlyEqual(_searchElement_, _elementK_) 为 *true* 返回 𝔽(_k_)。
            1. _k_++。
          1. 返回 *-1*<sub>𝔽</sub>。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.join">
        <h1>Array.prototype.join ( _separator_ )</h1>
        <p>将元素转换为字符串并用分隔符拼接；缺省分隔符为逗号。</p>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 _separator_ 为 *undefined*，_sep_ = *","*；否则 _sep_ = ? ToString(_separator_)。
          1. _R_ = 空字符串；_k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. 若 _k_ > 0，_R_ = _R_ + _sep_。
            1. _element_ = ? Get(_O_, ! ToString(𝔽(_k_)))。
            1. 若 _element_ 既非 *undefined* 亦非 *null*：
              1. _S_ = ? ToString(_element_)。
              1. _R_ = _R_ + _S_。
            1. _k_++。
          1. 返回 _R_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.keys">
        <h1>Array.prototype.keys ( )</h1>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. 返回 CreateArrayIterator(_O_, ~key~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.lastindexof">
        <h1>Array.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>自右向左使用 IsStrictlyEqual 查找，返回最大匹配索引，否则 -1。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 _len_ = 0 返回 *-1*<sub>𝔽</sub>。
          1. 若提供 _fromIndex_，_n_ = ? ToIntegerOrInfinity(_fromIndex_)；否则 _n_ = _len_ - 1。
          1. 若 _n_ = -∞ 返回 *-1*<sub>𝔽</sub>。
          1. 若 _n_ ≥ 0：_k_ = min(_n_, _len_ - 1)；否则 _k_ = _len_ + _n_。
          1. 当 _k_ ≥ 0：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _elementK_ = ? Get(_O_, _Pk_)。
              1. 若 IsStrictlyEqual(_searchElement_, _elementK_) 为 *true* 返回 𝔽(_k_)。
            1. _k_--。
          1. 返回 *-1*<sub>𝔽</sub>。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.map">
        <h1>Array.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>升序对存在元素调用 _callback_，生成新数组。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false* 抛 *TypeError*。
          1. _A_ = ? ArraySpeciesCreate(_O_, _len_)。
          1. _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _mappedValue_ = ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
              1. ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)。
            1. _k_++。
          1. 返回 _A_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.pop">
        <h1>Array.prototype.pop ( )</h1>
        <emu-note>
          <p>移除并返回最后一个元素。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 _len_ = 0：
            1. ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*)。
            1. 返回 *undefined*。
          1. 否则：
            1. 令 _newLen_ = 𝔽(_len_ - 1)。
            1. _index_ = ! ToString(_newLen_)。
            1. _element_ = ? Get(_O_, _index_)。
            1. ? DeletePropertyOrThrow(_O_, _index_)。
            1. ? Set(_O_, *"length"*, _newLen_, *true*)。
            1. 返回 _element_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.push">
        <h1>Array.prototype.push ( ..._items_ )</h1>
        <emu-note>
          <p>将参数按顺序追加到末尾，返回新长度。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. _argCount_ = _items_ 长度。
          1. 若 _len_ + _argCount_ > 2<sup>53</sup> - 1 抛 *TypeError*。
          1. 对每个 _E_ 属于 _items_：
            1. ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*)。
            1. _len_++。
          1. ? Set(_O_, *"length"*, 𝔽(_len_), *true*)。
          1. 返回 𝔽(_len_)。
        </emu-alg>
        <p>此方法 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduce">
        <h1>Array.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>从左到右归约；若未提供 _initialValue_，使用首个存在元素作为累加器起始；空数组且无初始值抛 *TypeError*。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. _len_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false* 抛 *TypeError*。
          1. 若 _len_ = 0 且无 _initialValue_ 抛 *TypeError*。
          1. _k_ = 0；_accumulator_ = *undefined*。
          1. 若提供 _initialValue_：_accumulator_ = _initialValue_。
          1. 否则：
            1. _kPresent_ = *false*。
            1. 当 !_kPresent_ 且 _k_ &lt; _len_：
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
              1. 若 _kPresent_：_accumulator_ = ? Get(_O_, _Pk_)。
              1. _k_++。
            1. 若 !_kPresent_ 抛 *TypeError*。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_++。
          1. 返回 _accumulator_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduceright">
        <h1>Array.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>从右向左归约，规则同 `reduce` 但方向相反。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false* 抛 *TypeError*。
          1. 若 _len_ = 0 且无 _initialValue_ 抛 *TypeError*。
          1. _k_ = _len_ - 1；_accumulator_ = *undefined*。
          1. 若有初始值：_accumulator_ = _initialValue_。
          1. 否则：
            1. _kPresent_ = *false*。
            1. 当 !_kPresent_ 且 _k_ ≥ 0：
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
              1. 若 _kPresent_：_accumulator_ = ? Get(_O_, _Pk_)。
              1. _k_--。
            1. 若 !_kPresent_ 抛 *TypeError*。
          1. 当 _k_ ≥ 0：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_：
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. _k_--。
          1. 返回 _accumulator_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reverse">
        <h1>Array.prototype.reverse ( )</h1>
        <emu-note>
          <p>就地反转顺序并返回该对象。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. _middle_ = floor(_len_/2)，_lower_ = 0。
          1. 当 _lower_ ≠ _middle_：
            1. _upper_ = _len_ - _lower_ - 1。
            1. _upperP_ = ! ToString(𝔽(_upper_))，_lowerP_ = ! ToString(𝔽(_lower_))。
            1. _lowerExists_ = ? HasProperty(_O_, _lowerP_)；若真：_lowerValue_ = ? Get(_O_, _lowerP_)。
            1. _upperExists_ = ? HasProperty(_O_, _upperP_)；若真：_upperValue_ = ? Get(_O_, _upperP_)。
            1. 若二者皆真：交换；仅上真：下设上并删上；仅下真：删下并设上；皆假：无操作。
            1. _lower_++。
          1. 返回 _O_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.shift">
        <h1>Array.prototype.shift ( )</h1>
        <p>移除首元素并返回。</p>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. 若 _len_ = 0：? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*)；返回 *undefined*。
          1. _first_ = ? Get(_O_, *"0"*)。
          1. _k_ = 1。
          1. 当 _k_ &lt; _len_：
            1. _from_ = ! ToString(𝔽(_k_))，_to_ = ! ToString(𝔽(_k_-1))。
            1. _fromPresent_ = ? HasProperty(_O_, _from_)。
            1. 若真：_fromValue_ = ? Get(_O_, _from_)；? Set(_O_, _to_, _fromValue_, *true*)；否则 Delete _to_。
            1. _k_++。
          1. ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_-1)))。
          1. ? Set(_O_, *"length"*, 𝔽(_len_-1), *true*)。
          1. 返回 _first_。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.slice">
        <h1>Array.prototype.slice ( _start_, _end_ )</h1>
        <p>返回从 _start_（含）到 _end_（不含）之间的浅拷贝；负值按长度偏移。</p>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. 若 = -∞，_k_ = 0；否则若 <0，_k_ = max(_len_+_relativeStart_,0)；否则 _k_ = min(_relativeStart_, _len_)。
          1. _relativeEnd_ = (_end_ 是 *undefined* ? _len_ : ? ToIntegerOrInfinity(_end_))。
          1. 若 _relativeEnd_ = -∞，_final_ = 0；若 <0，_final_ = max(_len_+_relativeEnd_,0)；否则 _final_ = min(_relativeEnd_, _len_)。
          1. _count_ = max(_final_ - _k_, 0)。
          1. _A_ = ? ArraySpeciesCreate(_O_, _count_)。
          1. _n_ = 0。
          1. 当 _k_ &lt; _final_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若真：_kValue_ = ? Get(_O_, _Pk_)；? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_)。
            1. _k_++；_n_++。
          1. [id="step-array-proto-slice-set-length"] ? Set(_A_, *"length"*, 𝔽(_n_), *true*)。
          1. 返回 _A_。
        </emu-alg>
        <emu-note>
          <p>显式设置长度确保非内置数组时正确。</p>
        </emu-note>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.some">
        <h1>Array.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>升序测试是否存在使 _callback_ 为真值的元素；空数组返回 *false*。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. 若 IsCallable(_callback_) 为 *false* 抛 *TypeError*。
          1. _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _kPresent_ = ? HasProperty(_O_, _Pk_)。
            1. 若真：
              1. _kValue_ = ? Get(_O_, _Pk_)。
              1. _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
              1. 若 _testResult_ 为 *true* 返回 *true*。
            1. _k_++。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.sort" oldids="sec-sortcompare">
        <h1>Array.prototype.sort ( _comparator_ )</h1>
        <p>对数组元素排序；若提供 _comparator_，必须可调用并按返回值符号决定顺序。</p>
        <p>步骤：</p>
        <emu-alg>
          1. [id="step-array-sort-comparefn"] 若 _comparator_ 非 *undefined* 且不可调用，抛 *TypeError*。
          1. _obj_ = ? ToObject(*this* value)。
          1. [id="step-array-sort-len"] _len_ = ? LengthOfArrayLike(_obj_)。
          1. _SortCompare_ = 抽象闭包(_x_, _y_)：? CompareArrayElements(_x_, _y_, _comparator_)。
          1. [id="step-array-sortindexedproperties"] _sortedList_ = ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~)。
          1. _itemCount_ = _sortedList_ 长度。
          1. _j_ = 0。
          1. 当 _j_ &lt; _itemCount_：
            1. ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*)。
            1. _j_++。
          1. 注：跳过空洞后删除剩余索引以保留空洞数量。
          1. 当 _j_ &lt; _len_：
            1. ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_)))。
            1. _j_++。
          1. 返回 _obj_。
        </emu-alg>
        <emu-note>
          <p>*undefined* 排序到末尾，其后是不存在的属性。</p>
        </emu-note>
        <emu-note>
          <p>ToString 期间的方法调用可能使比较器不一致。</p>
        </emu-note>
        <emu-note>
          <p>泛型。</p>
        </emu-note>

        <emu-clause id="sec-sortindexedproperties" type="abstract operation">
          <h1>
            SortIndexedProperties (
            _obj_: an Object,
            _len_: a non-negative integer,
            _SortCompare_: an Abstract Closure with two parameters,
            _holes_: ~skip-holes~ or ~read-through-holes~,
            ): either a normal completion containing a List of ECMAScript language values or a throw completion
          </h1>
          <emu-alg>
            1. _items_ = 空列表；_k_ = 0。
            1. 当 _k_ &lt; _len_：
              1. _Pk_ = ! ToString(𝔽(_k_))。
              1. 若 _holes_ = ~skip-holes~：_kRead_ = ? HasProperty(_obj_, _Pk_)；否则 _kRead_ = *true*。
              1. 若 _kRead_：_kValue_ = ? Get(_obj_, _Pk_)；追加 _kValue_。
              1. _k_++。
            1. [id="step-array-sort"] 以实现定义次序使用 <emu-meta effects="user-code">_SortCompare_</emu-meta> 排序 _items_；若出现 abrupt 完成即停止并返回。
            1. 返回 _items_。
          </emu-alg>
          <p><dfn id="sort-order">排序顺序</dfn>是上述算法步骤 <emu-xref href="#step-array-sort"></emu-xref> 完成后 _items_ 的排列顺序。如果对于 _items_ 的元素，_SortCompare_ 不是一个一致的比较器，则排序顺序是实现自定的。当由 <emu-xref href="#sec-array.prototype.sort">Array.prototype.sort</emu-xref> 或 <emu-xref href="#sec-array.prototype.tosorted">Array.prototype.toSorted</emu-xref> 调用 SortIndexedProperties 时，如果 _comparator_ 为 *undefined*，并且对传给 _SortCompare_ 的任何特定值进行的所有 ToString 应用不会产生相同结果，则排序顺序同样是实现自定的。</p>
          <p>除非指定排序顺序是实现自定的，否则它必须满足以下全部条件：</p>
          <ul>
            <li>
              存在某个对小于 _itemCount_ 的非负整数的数学排列 π，使得对每个小于 _itemCount_ 的非负整数 _j_，元素 <emu-eqn>old[_j_]</emu-eqn> 与 <emu-eqn>new[π(_j_)]</emu-eqn> 完全相同。
            </li>
            <li>
              然后对所有非负整数 _j_ 和 _k_（各自小于 _itemCount_），如果 <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) &lt; 0</emu-eqn>，则 <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>。
            </li>
            <li>
              并且对于所有满足 _j_ &lt; _k_ &lt; _itemCount_ 的非负整数 _j_ 与 _k_，如果 <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) = 0</emu-eqn>，则 <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>；即排序是稳定的。
            </li>
          </ul>
          <p>这里记号 <emu-eqn>old[_j_]</emu-eqn> 用于指代执行步骤 <emu-xref href="#step-array-sort"></emu-xref> 之前的 <emu-eqn>_items_[_j_]</emu-eqn>，记号 <emu-eqn>new[_j_]</emu-eqn> 用于指代执行步骤 <emu-xref href="#step-array-sort"></emu-xref> 之后的 <emu-eqn>_items_[_j_]</emu-eqn>。</p>
          <p>若一个抽象闭包或函数 _comparator_ 对一组值 _S_ 满足下述所有要求，则称其为该集合的一个<dfn id="consistent-comparator">一致的比较器</dfn>。对集合 _S_ 中（可能相同）的所有值 _a_、_b_、_c_，记号 <emu-eqn>_a_ &lt;<sub>C</sub> _b_</emu-eqn> 表示 <emu-eqn>ℝ(_comparator_(_a_, _b_)) &lt; 0</emu-eqn>；<emu-eqn>_a_ =<sub>C</sub> _b_</emu-eqn> 表示 <emu-eqn>ℝ(_comparator_(_a_, _b_)) = 0</emu-eqn>；<emu-eqn>_a_ ><sub>C</sub> _b_</emu-eqn> 表示 <emu-eqn>ℝ(_comparator_(_a_, _b_)) > 0</emu-eqn>。</p>
          <ul>
            <li>
              调用 _comparator_(_a_, _b_) 时，对于特定的值对 _a_ 与 _b_ 总是返回相同的值 _v_。此外，_v_ 是一个 Number，且 _v_ 不是 *NaN*。注意这意味着对于给定的 _a_ 与 _b_，_a_ &lt;<sub>C</sub> _b_、_a_ =<sub>C</sub> _b_、_a_ ><sub>C</sub> _b_ 三者中恰有一个为真。
            </li>
            <li>
              调用 _comparator_(_a_, _b_) 不会修改 _obj_ 或 _obj_ 原型链上的任何对象。
            </li>
            <li>
              _a_ =<sub>C</sub> _a_（自反性）
            </li>
            <li>
              若 _a_ =<sub>C</sub> _b_，则 _b_ =<sub>C</sub> _a_（对称性）
            </li>
            <li>
              若 _a_ =<sub>C</sub> _b_ 且 _b_ =<sub>C</sub> _c_，则 _a_ =<sub>C</sub> _c_（=<sub>C</sub> 的传递性）
            </li>
            <li>
              若 _a_ &lt;<sub>C</sub> _b_ 且 _b_ &lt;<sub>C</sub> _c_，则 _a_ &lt;<sub>C</sub> _c_（&lt;<sub>C</sub> 的传递性）
            </li>
            <li>
              若 _a_ ><sub>C</sub> _b_ 且 _b_ ><sub>C</sub> _c_，则 _a_ ><sub>C</sub> _c_（><sub>C</sub> 的传递性）
            </li>
          </ul>
          <emu-note>
            <p>上述条件是充分且必要的，以确保 _comparator_ 将集合 _S_ 划分为等价类，并且这些等价类是全序的。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-comparearrayelements" type="abstract operation">
          <h1>
            CompareArrayElements (
              _x_: an ECMAScript language value,
              _y_: an ECMAScript language value,
              _comparator_: a function object or *undefined*,
            ): either a normal completion containing a Number or an abrupt completion
          </h1>
          <emu-alg>
            1. 若 _x_ 与 _y_ 均 *undefined* 返回 *+0*<sub>𝔽</sub>。
            1. 若 _x_ 为 *undefined* 返回 *1*<sub>𝔽</sub>。
            1. 若 _y_ 为 *undefined* 返回 *-1*<sub>𝔽</sub>。
            1. 若 _comparator_ 非 *undefined*：
              1. _v_ = ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »))。
              1. 若 _v_ 为 *NaN* 返回 *+0*<sub>𝔽</sub>。
              1. 返回 _v_。
            1. [id="step-sortcompare-tostring-x"] _xString_ = ? ToString(_x_)。
            1. [id="step-sortcompare-tostring-y"] _yString_ = ? ToString(_y_)。
            1. _xSmaller_ = ! IsLessThan(_xString_, _yString_, *true*)。
            1. 若 _xSmaller_ 为 *true* 返回 *-1*<sub>𝔽</sub>。
            1. _ySmaller_ = ! IsLessThan(_yString_, _xString_, *true*)。
            1. 若 _ySmaller_ 为 *true* 返回 *1*<sub>𝔽</sub>。
            1. 返回 *+0*<sub>𝔽</sub>。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.splice">
        <h1>Array.prototype.splice ( _start_, _deleteCount_, ..._items_ )</h1>
        <emu-note>
          <p>从 _start_ 删除 _deleteCount_ 个元素并以 _items_ 插入，返回被删除元素数组。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)；_len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. 若 = -∞，_actualStart_ = 0；否则若 <0，_actualStart_ = max(_len_+_relativeStart_,0)；否则 = min(_relativeStart_, _len_)。
          1. _itemCount_ = _items_ 长度。
          1. 若 _start_ 不存在：_actualDeleteCount_ = 0。
          1. 否则若 _deleteCount_ 不存在：_actualDeleteCount_ = _len_ - _actualStart_。
          1. 否则 _dc_ = ? ToIntegerOrInfinity(_deleteCount_)；_actualDeleteCount_ = clamp(_dc_, 0, _len_ - _actualStart_)。
          1. 若 _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup>-1 抛 *TypeError*。
          1. _A_ = ? ArraySpeciesCreate(_O_, _actualDeleteCount_)。
          1. _k_ = 0。当 _k_ &lt; _actualDeleteCount_：
            1. _from_ = ! ToString(𝔽(_actualStart_ + _k_))。
            1. 若 ? HasProperty(_O_, _from_)：
              1. _fromValue_ = ? Get(_O_, _from_)。
              1. ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_)。
            1. _k_++。
          1. [id="step-array-proto-splice-set-length"] ? Set(_A_, *"length"*, 𝔽(_actualDeleteCount_), *true*)。
          1. 若 _itemCount_ &lt; _actualDeleteCount_：
            1. _k_ = _actualStart_。
            1. 当 _k_ &lt; (_len_ - _actualDeleteCount_)：
              1. _from_ = ! ToString(𝔽(_k_ + _actualDeleteCount_))。
              1. _to_ = ! ToString(𝔽(_k_ + _itemCount_))。
              1. 若 ? HasProperty(_O_, _from_)：_fromValue_ = ? Get(_O_, _from_)；? Set(_O_, _to_, _fromValue_, *true*)；否则 Delete _to_。
              1. _k_++。
            1. _k_ = _len_。
            1. 当 _k_ > (_len_ - _actualDeleteCount_ + _itemCount_)：
              1. ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_-1)))。
              1. _k_--。
          1. 否则若 _itemCount_ > _actualDeleteCount_：
            1. _k_ = (_len_ - _actualDeleteCount_)。
            1. 当 _k_ > _actualStart_：
              1. _from_ = ! ToString(𝔽(_k_ + _actualDeleteCount_ -1))。
              1. _to_ = ! ToString(𝔽(_k_ + _itemCount_ -1))。
              1. 若 ? HasProperty(_O_, _from_)：_fromValue_ = ? Get(_O_, _from_)；? Set(_O_, _to_, _fromValue_, *true*)；否则 Delete _to_。
              1. _k_--。
          1. _k_ = _actualStart_。
          1. 对每个 _E_ ∈ _items_：? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*)；_k_++。
          1. [id="step-array-proto-splice-set-length-2"] ? Set(_O_, *"length"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*)。
          1. 返回 _A_。
        </emu-alg>
        <emu-note>
          <p>显式设置长度确保非内置数组仍正确。</p>
        </emu-note>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tolocalestring">
        <h1>Array.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>支持 ECMA-402 的实现按其规范实现；否则使用此处规范。两个可选参数的意义由 ECMA-402 定义，未实现该 API 时不得另作他用。</p>
        <emu-note>
          <p>ECMA-402 第一版未替换此方法的规范。</p>
        </emu-note>
        <p>步骤：</p>
        <emu-alg>
          1. _array_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_array_)。
          1. _separator_ = 实现定义的、符合当前区域设置的列表分隔符（如 *", "*）。
          1. _R_ = ""；_k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. 若 _k_ > 0：_R_ = _R_ + _separator_。
            1. _element_ = ? Get(_array_, ! ToString(𝔽(_k_)))。
            1. 若 _element_ 非 *undefined* 且非 *null*：
              1. _S_ = ? ToString(? Invoke(_element_, *"toLocaleString"*))。
              1. _R_ = _R_ + _S_。
            1. _k_++。
          1. 返回 _R_。
        </emu-alg>
        <emu-note>
          <p>与 `toString` 类似，但使用区域化的元素表示与分隔符。</p>
        </emu-note>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.toreversed">
        <h1>Array.prototype.toReversed ( )</h1>
        <p>返回一个新数组，其元素为原数组的反向拷贝。</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. _A_ = ? ArrayCreate(_len_)。
          1. _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _from_ = ! ToString(𝔽(_len_ - _k_ - 1))。
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. _fromValue_ = ? Get(_O_, _from_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_)。
            1. _k_++。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tosorted">
        <h1>Array.prototype.toSorted ( _comparator_ )</h1>
        <p>返回排序后的新数组（不修改原数组）。</p>
        <emu-alg>
          1. 若 _comparator_ 非 *undefined* 且不可调用，抛 *TypeError*。
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. _A_ = ? ArrayCreate(_len_)。
          1. _SortCompare_ = 抽象闭包(_x_, _y_)：? CompareArrayElements(_x_, _y_, _comparator_)。
          1. _sortedList_ = ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~)。
          1. _j_ = 0。
          1. 当 _j_ &lt; _len_：
            1. ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_])。
            1. _j_++。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tospliced">
        <h1>Array.prototype.toSpliced ( _start_, _skipCount_, ..._items_ )</h1>
        <p>返回应用类 splice 操作后的新数组（不修改原数组）。</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)，_len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeStart_ = ? ToIntegerOrInfinity(_start_)。
          1. 若 = -∞，_actualStart_ = 0；否则若 <0，_actualStart_ = max(_len_+_relativeStart_,0)；否则 _actualStart_ = min(_relativeStart_, _len_)。
          1. _insertCount_ = _items_ 长度。
          1. 若 _start_ 不存在：_actualSkipCount_ = 0；否则若 _skipCount_ 不存在：_actualSkipCount_ = _len_ - _actualStart_；否则 _sc_ = ? ToIntegerOrInfinity(_skipCount_)；_actualSkipCount_ = clamp(_sc_, 0, _len_-_actualStart_)。
          1. _newLen_ = _len_ + _insertCount_ - _actualSkipCount_。
          1. 若 _newLen_ > 2<sup>53</sup>-1 抛 *TypeError*。
          1. _A_ = ? ArrayCreate(_newLen_)。
          1. _i_ = 0；_r_ = _actualStart_ + _actualSkipCount_。
          1. 当 _i_ &lt; _actualStart_：
            1. _Pi_ = ! ToString(𝔽(_i_))。
            1. _iValue_ = ? Get(_O_, _Pi_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_)。
            1. _i_++。
          1. 对 _items_ 中每个 _E_：
            1. _Pi_ = ! ToString(𝔽(_i_))。
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_)。
            1. _i_++。
          1. 当 _i_ &lt; _newLen_：
            1. _Pi_ = ! ToString(𝔽(_i_))。
            1. _from_ = ! ToString(𝔽(_r_))。
            1. _fromValue_ = ? Get(_O_, _from_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_)。
            1. _i_++；_r_++。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tostring">
        <h1>Array.prototype.toString ( )</h1>
        <p>调用时执行：</p>
        <emu-alg>
          1. _array_ = ? ToObject(*this* value)。
          1. _func_ = ? Get(_array_, *"join"*)。
          1. 若 IsCallable(_func_) 为 *false*，_func_ = %Object.prototype.toString%。
          1. 返回 ? Call(_func_, _array_)。
        </emu-alg>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.unshift">
        <h1>Array.prototype.unshift ( ..._items_ )</h1>
        <p>将参数插入开头并保持顺序，返回新长度。</p>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)；_len_ = ? LengthOfArrayLike(_O_)。
          1. _argCount_ = _items_ 长度。
          1. 若 _argCount_ > 0：
            1. 若 _len_ + _argCount_ > 2<sup>53</sup>-1 抛 *TypeError*。
            1. _k_ = _len_。
            1. 当 _k_ > 0：
              1. _from_ = ! ToString(𝔽(_k_-1))；_to_ = ! ToString(𝔽(_k_ + _argCount_ -1))。
              1. _fromPresent_ = ? HasProperty(_O_, _from_)。
              1. 若真：_fromValue_ = ? Get(_O_, _from_)；? Set(_O_, _to_, _fromValue_, *true*)；否则 Delete _to_。
              1. _k_--。
            1. _j_ = *+0*<sub>𝔽</sub>。
            1. 对每个 _E_ ∈ _items_：? Set(_O_, ! ToString(_j_), _E_, *true*)；_j_ += *1*<sub>𝔽</sub>。
          1. ? Set(_O_, *"length"*, 𝔽(_len_ + _argCount_), *true*)。
          1. 返回 𝔽(_len_ + _argCount_)。
        </emu-alg>
        <p>此方法 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
        <emu-note>
          <p>泛型。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.values">
        <h1>Array.prototype.values ( )</h1>
        <p>步骤：</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)。
          1. 返回 CreateArrayIterator(_O_, ~value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.with">
        <h1>Array.prototype.with ( _index_, _value_ )</h1>
        <p>返回替换给定索引后的新数组（不修改原数组）。</p>
        <emu-alg>
          1. _O_ = ? ToObject(*this* value)；_len_ = ? LengthOfArrayLike(_O_)。
          1. _relativeIndex_ = ? ToIntegerOrInfinity(_index_)。
          1. 若 _relativeIndex_ ≥ 0：_actualIndex_ = _relativeIndex_；否则 _actualIndex_ = _len_ + _relativeIndex_。
          1. 若 _actualIndex_ ≥ _len_ 或 _actualIndex_ &lt; 0 抛 *RangeError*。
          1. _A_ = ? ArrayCreate(_len_)。
          1. _k_ = 0。
          1. 当 _k_ &lt; _len_：
            1. _Pk_ = ! ToString(𝔽(_k_))。
            1. 若 _k_ = _actualIndex_：_fromValue_ = _value_；否则 _fromValue_ = ? Get(_O_, _Pk_)。
            1. ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_)。
            1. _k_++。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@iterator" id="sec-array.prototype-%symbol.iterator%">
        <h1>Array.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 初始值为 %Array.prototype.values%，定义见 <emu-xref href="#sec-array.prototype.values"></emu-xref>。</p>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@unscopables" id="sec-array.prototype-%symbol.unscopables%">
        <h1>Array.prototype [ %Symbol.unscopables% ]</h1>
        <p>%Symbol.unscopables% 数据属性初始值按以下步骤创建：</p>
        <emu-alg>
          1. _unscopableList_ = OrdinaryObjectCreate(*null*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"at"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findLast"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"findLastIndex"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toReversed"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toSorted"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"toSpliced"*, *true*)。
          1. ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*)。
          1. 返回 _unscopableList_。
        </emu-alg>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        <emu-note>
          <p>这些名称在 ES2015 前不是标准 Array.prototype 自有属性；在 `with` 语句中应忽略以避免遮蔽外层绑定。</p>
          <p>*"with"* 未列入是因为其已为 <emu-xref href="#sec-keywords-and-reserved-words">保留字</emu-xref>。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-array-instances">
      <h1>Array 实例的属性</h1>
      <p>Array 实例是数组异质对象，具有对应内部方法，并继承自 Array 原型。</p>
      <p>Array 实例具有 *"length"* 属性及一组可枚举的数组索引属性。</p>

      <emu-clause id="sec-properties-of-array-instances-length">
        <h1>length</h1>
        <p>*"length"* 是数据属性，其值始终大于任一可配置自有数组索引属性名的数值。</p>
        <p>初始属性特性：{ [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>减小 *"length"* 会删除旧长度与新长度之间的索引元素（不可配置者除外）。若尝试设置长度为小于等于某不可配置索引名的值，则实际长度会被设置为该索引名+1。参见 <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-iterator-objects">
      <h1>Array 迭代器对象</h1>
      <p><dfn variants="Array Iterators,Array Iterator object,Array Iterator objects">Array Iterator</dfn> 表示针对某个特定 Array 实例的一次特定迭代。无命名构造函数；通过调用某些 Array 实例方法创建。</p>

      <emu-clause id="sec-createarrayiterator" type="abstract operation">
        <h1>
          CreateArrayIterator (
            _array_: an Object,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): an Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>为返回迭代器的 Array 方法创建迭代器对象。</dd>
        </dl>
        <emu-alg>
          1. _iterator_ = OrdinaryObjectCreate(%ArrayIteratorPrototype%, « [[IteratedArrayLike]], [[ArrayLikeNextIndex]], [[ArrayLikeIterationKind]] »)。
          1. 设 _iterator_.[[IteratedArrayLike]] = _array_。
          1. 设 _iterator_.[[ArrayLikeNextIndex]] = 0。
          1. 设 _iterator_.[[ArrayLikeIterationKind]] = _kind_。
          1. 返回 _iterator_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%arrayiteratorprototype%-object">
        <h1>%ArrayIteratorPrototype% 对象</h1>
        <p><dfn>%ArrayIteratorPrototype%</dfn> 对象：</p>
        <ul>
          <li>提供所有 Array Iterator 继承的属性。</li>
          <li>是普通对象。</li>
          <li>其 [[Prototype]] 为 %Iterator.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%arrayiteratorprototype%.next">
          <h1>%ArrayIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. _O_ = *this*。
            1. 若 _O_ 非对象抛 *TypeError*。
            1. 若 _O_ 不具备数组迭代器实例全部内部槽抛 *TypeError*。
            1. _array_ = _O_.[[IteratedArrayLike]]。
            1. 若 _array_ 为 *undefined* 返回 CreateIteratorResultObject(*undefined*, *true*)。
            1. _index_ = _O_.[[ArrayLikeNextIndex]]。
            1. _kind_ = _O_.[[ArrayLikeIterationKind]]。
            1. 若 _array_ 具有 [[TypedArrayName]]：
              1. _taRecord_ = MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~)。
              1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true* 抛 *TypeError*。
              1. _len_ = TypedArrayLength(_taRecord_)。
            1. 否则 _len_ = ? LengthOfArrayLike(_array_)。
            1. 若 _index_ ≥ _len_：
              1. 设 _O_.[[IteratedArrayLike]] = *undefined*。
              1. 返回 CreateIteratorResultObject(*undefined*, *true*)。
            1. 设 _O_.[[ArrayLikeNextIndex]] = _index_ + 1。
            1. _indexNumber_ = 𝔽(_index_)。
            1. 若 _kind_ = ~key~：_result_ = _indexNumber_。
            1. 否则：
              1. _elementKey_ = ! ToString(_indexNumber_)。
              1. _elementValue_ = ? Get(_array_, _elementKey_)。
              1. 若 _kind_ = ~value~：_result_ = _elementValue_；否则（断言 ~key+value~）_result_ = CreateArrayFromList(« _indexNumber_, _elementValue_ »)。
            1. 返回 CreateIteratorResultObject(_result_, *false*)。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%arrayiteratorprototype%-@@tostringtag" id="sec-%arrayiteratorprototype%-%symbol.tostringtag%">
          <h1>%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 初始值为 *"Array Iterator"*。</p>
          <p>属性特性：{ [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-array-iterator-instances">
        <h1>Array 迭代器实例的属性</h1>
        <p>Array 迭代器实例继承自内在对象 %ArrayIteratorPrototype%，并具有下表内部槽。</p>
        <emu-table id="table-internal-slots-of-array-iterator-instances" caption="Array 迭代器实例的内部槽" oldids="table-48">
          <table>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>[[IteratedArrayLike]]</td>
              <td>an Object or *undefined*</td>
              <td>被迭代的类数组对象。</td>
            </tr>
            <tr>
              <td>[[ArrayLikeNextIndex]]</td>
              <td>a non-negative integer</td>
              <td>下一个要访问的元素索引。</td>
            </tr>
            <tr>
              <td>[[ArrayLikeIterationKind]]</td>
              <td>~key+value~, ~key~, or ~value~</td>
              <td>迭代时返回的形式。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray 对象</h1>
    <p>_TypedArray_ 提供其底层二进制数据缓冲区的类数组视图（<emu-xref href="#sec-arraybuffer-objects"></emu-xref>）。<dfn variants="TypedArray element types">TypedArray 元素类型</dfn> 是所有 _TypedArray_ 实例元素所具有的底层二进制标量数据类型。针对每种受支持的元素类型，在 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中列出了一个不同的 _TypedArray_ 构造函数。<emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中的每个构造函数都有其对应且相互不同的原型对象。</p>
    <emu-table id="table-the-typedarray-constructors" caption="TypedArray 构造函数" oldids="table-49">
      <table>
        <thead>
          <tr>
            <th>构造函数名称与内在对象</th>
            <th>元素类型</th>
            <th>元素大小</th>
            <th>转换操作</th>
            <th>描述</th>
          </tr>
        </thead>
        <tr>
          <td>
            Int8Array<br>
            <dfn>%Int8Array%</dfn>
          </td>
          <td>~int8~</td>
          <td>1</td>
          <td>ToInt8</td>
          <td>8 位二进制补码有符号整数</td>
        </tr>
        <tr>
          <td>
            Uint8Array<br>
            <dfn>%Uint8Array%</dfn>
          </td>
          <td>~uint8~</td>
          <td>1</td>
          <td>ToUint8</td>
          <td>8 位无符号整数</td>
        </tr>
        <tr>
          <td>
            Uint8ClampedArray<br>
            <dfn>%Uint8ClampedArray%</dfn>
          </td>
          <td>~uint8clamped~</td>
          <td>1</td>
          <td>ToUint8Clamp</td>
          <td>8 位无符号整数（限制转换）</td>
        </tr>
        <tr>
          <td>
            Int16Array<br>
            <dfn>%Int16Array%</dfn>
          </td>
          <td>~int16~</td>
          <td>2</td>
          <td>ToInt16</td>
          <td>16 位二进制补码有符号整数</td>
        </tr>
        <tr>
          <td>
            Uint16Array<br>
            <dfn>%Uint16Array%</dfn>
          </td>
          <td>~uint16~</td>
          <td>2</td>
          <td>ToUint16</td>
          <td>16 位无符号整数</td>
        </tr>
        <tr>
          <td>
            Int32Array<br>
            <dfn>%Int32Array%</dfn>
          </td>
          <td>~int32~</td>
          <td>4</td>
          <td>ToInt32</td>
          <td>32 位二进制补码有符号整数</td>
        </tr>
        <tr>
          <td>
            Uint32Array<br>
            <dfn>%Uint32Array%</dfn>
          </td>
          <td>~uint32~</td>
          <td>4</td>
          <td>ToUint32</td>
          <td>32 位无符号整数</td>
        </tr>
        <tr>
          <td>
            BigInt64Array<br>
            <dfn>%BigInt64Array%</dfn>
          </td>
          <td>~bigint64~</td>
          <td>8</td>
          <td>ToBigInt64</td>
          <td>64 位二进制补码有符号整数</td>
        </tr>
        <tr>
          <td>
            BigUint64Array<br>
            <dfn>%BigUint64Array%</dfn>
          </td>
          <td>~biguint64~</td>
          <td>8</td>
          <td>ToBigUint64</td>
          <td>64 位无符号整数</td>
        </tr>
        <tr>
          <td>
            Float16Array<br>
            <dfn>%Float16Array%</dfn>
          </td>
          <td>~float16~</td>
          <td>2</td>
          <td></td>
          <td>16 位 IEEE 浮点数</td>
        </tr>
        <tr>
          <td>
            Float32Array<br>
            <dfn>%Float32Array%</dfn>
          </td>
          <td>~float32~</td>
          <td>4</td>
          <td></td>
          <td>32 位 IEEE 浮点数</td>
        </tr>
        <tr>
          <td>
            Float64Array<br>
            <dfn>%Float64Array%</dfn>
          </td>
          <td>~float64~</td>
          <td>8</td>
          <td></td>
          <td>64 位 IEEE 浮点数</td>
        </tr>
      </table>
    </emu-table>
    <p>在下列定义中，对 _TypedArray_ 的引用应替换为上表中的适当构造函数名称。</p>

    <emu-clause id="sec-%typedarray%-intrinsic-object">
      <h1>%TypedArray% 内在对象</h1>
      <p><dfn>%TypedArray%</dfn> 内在对象：</p>
      <ul>
        <li>是所有 _TypedArray_ 构造函数对象继承自的构造函数对象。</li>
        <li>与其对应的原型对象一起，提供所有 _TypedArray_ 构造函数及其实例所继承的共有属性。</li>
        <li>没有全局名称，也不作为全局对象的属性出现。</li>
        <li>作为各种 _TypedArray_ 构造函数的抽象超类。</li>
        <li>作为抽象类构造函数被调用时会抛出错误。_TypedArray_ 构造函数不会对其执行 `super` 调用。</li>
      </ul>

      <emu-clause id="sec-%typedarray%">
        <h1>%TypedArray% ( )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 抛出 *TypeError* 异常。
        </emu-alg>
        <p>此函数的 *"length"* 属性为 *+0*<sub>𝔽</sub>。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarray%-intrinsic-object">
      <h1>%TypedArray% 内在对象的属性</h1>
      <p>%TypedArray% 内在对象：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>有 *"name"* 属性，其值为 *"TypedArray"*。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-%typedarray%.from">
        <h1>%TypedArray%.from ( _source_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 若 IsConstructor(_C_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _mapper_ 为 *undefined*，则
            1. 令 _mapping_ 为 *false*。
          1. 否则，
            1. 若 IsCallable(_mapper_) 为 *false*，抛出 *TypeError* 异常。
            1. 令 _mapping_ 为 *true*。
          1. 令 _usingIterator_ 为 ? GetMethod(_source_, %Symbol.iterator%)。
          1. 若 _usingIterator_ 不为 *undefined*，则
            1. 令 _values_ 为 ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_))。
            1. 令 _len_ 为 _values_ 中元素的数量。
            1. 令 _targetObj_ 为 ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »)。
            1. 令 _k_ 为 0。
            1. 当 _k_ &lt; _len_ 重复，
              1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
              1. 令 _kValue_ 为 _values_ 的第一个元素。
              1. 移除 _values_ 的第一个元素。
              1. 若 _mapping_ 为 *true*，则
                1. 令 _mappedValue_ 为 ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »)。
              1. 否则，
                1. 令 _mappedValue_ 为 _kValue_。
              1. 执行 ? Set(_targetObj_, _Pk_, _mappedValue_, *true*)。
              1. 令 _k_ 为 _k_ + 1。
            1. 断言：_values_ 现在为空列表。
            1. 返回 _targetObj_。
          1. 注：_source_ 不是可迭代对象，因此假定其已为类数组对象。
          1. 令 _arrayLike_ 为 ! ToObject(_source_)。
          1. 令 _len_ 为 ? LengthOfArrayLike(_arrayLike_)。
          1. 令 _targetObj_ 为 ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »)。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
            1. 令 _kValue_ 为 ? Get(_arrayLike_, _Pk_)。
            1. 若 _mapping_ 为 *true*，则
              1. 令 _mappedValue_ 为 ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »)。
            1. 否则，
              1. 令 _mappedValue_ 为 _kValue_。
            1. 执行 ? Set(_targetObj_, _Pk_, _mappedValue_, *true*)。
            1. 令 _k_ 为 _k_ + 1。
          1. 返回 _targetObj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.of">
        <h1>%TypedArray%.of ( ..._items_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _len_ 为 _items_ 中元素的数量。
          1. 令 _C_ 为 *this* 值。
          1. 若 IsConstructor(_C_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _newObj_ 为 ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »)。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _kValue_ 为 _items_[_k_]。
            1. 令 _Pk_ 为 ! ToString(𝔽(_k_))。
            1. 执行 ? Set(_newObj_, _Pk_, _kValue_, *true*)。
            1. 令 _k_ 为 _k_ + 1。
          1. 返回 _newObj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype">
        <h1>%TypedArray%.prototype</h1>
        <p>%TypedArray%`.prototype` 的初始值是 %TypedArray% 原型对象。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%-@@species" id="sec-get-%typedarray%-%symbol.species%">
        <h1>get %TypedArray% [ %Symbol.species% ]</h1>
        <p>%TypedArray%`[%Symbol.species%]` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数 *"name"* 属性的值为 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>%TypedArray.prototype% 的方法通常使用其 *this* 值的构造函数创建派生对象。然而，子类构造函数可以通过重定义其 %Symbol.species% 属性来覆盖该默认行为。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
      <h1>%TypedArray% 原型对象的属性</h1>
      <p><dfn>%TypedArray% 原型对象</dfn>：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是 <dfn>%TypedArray.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[ViewedArrayBuffer]] 或其他特定于 _TypedArray_ 实例对象的内部槽。</li>
      </ul>

      <emu-clause id="sec-%typedarray%.prototype.at">
        <h1>%TypedArray%.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _relativeIndex_ 为 ? ToIntegerOrInfinity(_index_)。
          1. 若 _relativeIndex_ ≥ 0，则
            1. 令 _k_ = _relativeIndex_。
          1. 否则，
            1. 令 _k_ = _len_ + _relativeIndex_。
          1. 若 _k_ &lt; 0 或 _k_ ≥ _len_，返回 *undefined*。
          1. 返回 ! Get(_O_, ! ToString(𝔽(_k_)))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.buffer">
        <h1>get %TypedArray%.prototype.buffer</h1>
        <p>%TypedArray%`.prototype.buffer` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _buffer_ 为 _O_.[[ViewedArrayBuffer]]。
          1. 返回 _buffer_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
        <h1>get %TypedArray%.prototype.byteLength</h1>
        <p>%TypedArray%`.prototype.byteLength` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 令 _size_ 为 TypedArrayByteLength(_taRecord_)。
          1. 返回 𝔽(_size_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
        <h1>get %TypedArray%.prototype.byteOffset</h1>
        <p>%TypedArray%`.prototype.byteOffset` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，返回 *+0*<sub>𝔽</sub>。
          1. 令 _offset_ 为 _O_.[[ByteOffset]]。
          1. 返回 𝔽(_offset_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.constructor">
        <h1>%TypedArray%.prototype.constructor</h1>
        <p>%TypedArray%`.prototype.constructor` 的初始值为 %TypedArray%。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.copywithin">
        <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>此方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.copywithin"></emu-xref> 中定义的 `Array.prototype.copyWithin` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _relativeTarget_ 为 ? ToIntegerOrInfinity(_target_)。
          1. 若 _relativeTarget_ = -∞，令 _targetIndex_ = 0。
          1. 否则若 _relativeTarget_ &lt; 0，令 _targetIndex_ = max(_len_ + _relativeTarget_, 0)。
          1. 否则令 _targetIndex_ = min(_relativeTarget_, _len_)。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _startIndex_ = 0。
          1. 否则若 _relativeStart_ &lt; 0，令 _startIndex_ = max(_len_ + _relativeStart_, 0)。
          1. 否则令 _startIndex_ = min(_relativeStart_, _len_)。
          1. 若 _end_ 为 *undefined*，令 _relativeEnd_ = _len_；否则令 _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，令 _endIndex_ = 0。
          1. 否则若 _relativeEnd_ &lt; 0，令 _endIndex_ = max(_len_ + _relativeEnd_, 0)。
          1. 否则令 _endIndex_ = min(_relativeEnd_, _len_)。
          1. 令 _count_ 为 min(_endIndex_ - _startIndex_, _len_ - _targetIndex_)。
          1. 若 _count_ > 0，则
            1. 注：复制必须以保持源数据位级编码的方式进行。
            1. 令 _buffer_ 为 _O_.[[ViewedArrayBuffer]]。
            1. 设 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
            1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 设 _len_ 为 TypedArrayLength(_taRecord_)。
            1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
            1. 令 _byteOffset_ 为 _O_.[[ByteOffset]]。
            1. 令 _bufferByteLimit_ 为 (_len_ × _elementSize_) + _byteOffset_。
            1. 令 _toByteIndex_ 为 (_targetIndex_ × _elementSize_) + _byteOffset_。
            1. 令 _fromByteIndex_ 为 (_startIndex_ × _elementSize_) + _byteOffset_。
            1. 令 _countBytes_ 为 _count_ × _elementSize_。
            1. 若 _fromByteIndex_ &lt; _toByteIndex_ 且 _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_，则
              1. 令 _direction_ = -1。
              1. 设 _fromByteIndex_ = _fromByteIndex_ + _countBytes_ - 1。
              1. 设 _toByteIndex_ = _toByteIndex_ + _countBytes_ - 1。
            1. 否则，
              1. 令 _direction_ = 1。
            1. 当 _countBytes_ > 0 重复，
              1. 若 _fromByteIndex_ &lt; _bufferByteLimit_ 且 _toByteIndex_ &lt; _bufferByteLimit_，则
                1. 令 _value_ 为 GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~)。
                1. 执行 SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~)。
                1. 设 _fromByteIndex_ = _fromByteIndex_ + _direction_。
                1. 设 _toByteIndex_ = _toByteIndex_ + _direction_。
                1. 设 _countBytes_ = _countBytes_ - 1。
              1. 否则，
                1. 设 _countBytes_ = 0。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.entries">
        <h1>%TypedArray%.prototype.entries ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 返回 CreateArrayIterator(_O_, ~key+value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.every">
        <h1>%TypedArray%.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.every"></emu-xref> 中的 `Array.prototype.every` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 令 _testResult_ 为 ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
            1. 若 _testResult_ 为 *false*，返回 *false*。
            1. 设 _k_ = _k_ + 1。
          1. 返回 *true*。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.fill"></emu-xref> 中的 `Array.prototype.fill` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _O_.[[ContentType]] 为 ~bigint~，设 _value_ 为 ? ToBigInt(_value_)。
          1. 否则，设 _value_ 为 ? ToNumber(_value_)。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _startIndex_ = 0。
          1. 否则若 _relativeStart_ &lt; 0，令 _startIndex_ = max(_len_ + _relativeStart_, 0)。
          1. 否则令 _startIndex_ = min(_relativeStart_, _len_)。
          1. 若 _end_ 为 *undefined*，令 _relativeEnd_ = _len_；否则令 _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，令 _endIndex_ = 0。
          1. 否则若 _relativeEnd_ &lt; 0，令 _endIndex_ = max(_len_ + _relativeEnd_, 0)。
          1. 否则令 _endIndex_ = min(_relativeEnd_, _len_)。
          1. 设 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 设 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 设 _endIndex_ = min(_endIndex_, _len_)。
          1. 令 _k_ = _startIndex_。
          1. 当 _k_ &lt; _endIndex_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 执行 ! Set(_O_, _Pk_, _value_, *true*)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.filter">
        <h1>%TypedArray%.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.filter"></emu-xref> 中的 `Array.prototype.filter` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _kept_ 为一个新的空列表。
          1. 令 _captured_ 为 0。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 令 _selected_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
            1. 若 _selected_ 为 *true*，则
              1. 将 _kValue_ 追加到 _kept_。
              1. 设 _captured_ = _captured_ + 1。
            1. 设 _k_ = _k_ + 1。
          1. 令 _A_ 为 ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »)。
          1. 令 _n_ = 0。
          1. 对 _kept_ 中每个元素 _e_：
            1. 执行 ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*)。
            1. 设 _n_ = _n_ + 1。
          1. 返回 _A_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.find">
        <h1>%TypedArray%.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.find"></emu-xref> 中的 `Array.prototype.find` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _findRec_ 为 ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Value]]。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findindex">
        <h1>%TypedArray%.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.findindex"></emu-xref> 中的 `Array.prototype.findIndex` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _findRec_ 为 ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Index]]。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlast">
        <h1>%TypedArray%.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.findlast"></emu-xref> 中的 `Array.prototype.findLast` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _findRec_ 为 ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Value]]。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlastindex">
        <h1>%TypedArray%.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref> 中的 `Array.prototype.findLastIndex` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _findRec_ 为 ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_)。
          1. 返回 _findRec_.[[Index]]。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.foreach">
        <h1>%TypedArray%.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.foreach"></emu-xref> 中的 `Array.prototype.forEach` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 执行 ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 *undefined*。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.includes">
        <h1>%TypedArray%.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.includes"></emu-xref> 中的 `Array.prototype.includes` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _len_ = 0，返回 *false*。
          1. 令 _n_ 为 ? ToIntegerOrInfinity(_fromIndex_)。
          1. 断言：若 _fromIndex_ 为 *undefined*，则 _n_ 为 0。
          1. 若 _n_ = +∞，返回 *false*。
          1. 否则若 _n_ = -∞，设 _n_ = 0。
          1. 若 _n_ ≥ 0，则
            1. 令 _k_ = _n_。
          1. 否则，
            1. 令 _k_ = _len_ + _n_。
            1. 若 _k_ &lt; 0，设 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _elementK_ 为 ! Get(_O_, ! ToString(𝔽(_k_)))。
            1. 若 SameValueZero(_searchElement_, _elementK_) 为 *true*，返回 *true*。
            1. 设 _k_ = _k_ + 1。
          1. 返回 *false*。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.indexof">
        <h1>%TypedArray%.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.indexof"></emu-xref> 中的 `Array.prototype.indexOf` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _len_ = 0，返回 *-1*<sub>𝔽</sub>。
          1. 令 _n_ 为 ? ToIntegerOrInfinity(_fromIndex_)。
          1. 断言：若 _fromIndex_ 为 *undefined*，则 _n_ 为 0。
          1. 若 _n_ = +∞，返回 *-1*<sub>𝔽</sub>。
          1. 否则若 _n_ = -∞，设 _n_ = 0。
          1. 若 _n_ ≥ 0，则
            1. 令 _k_ = _n_。
          1. 否则，
            1. 令 _k_ = _len_ + _n_。
            1. 若 _k_ &lt; 0，设 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kPresent_ = ! HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_ 为 *true*，则
              1. 令 _elementK_ = ! Get(_O_, _Pk_)。
              1. 若 IsStrictlyEqual(_searchElement_, _elementK_) 为 *true*，返回 𝔽(_k_)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 *-1*<sub>𝔽</sub>。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.join">
        <h1>%TypedArray%.prototype.join ( _separator_ )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.join"></emu-xref> 中的 `Array.prototype.join` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _separator_ 为 *undefined*，令 _sep_ = *","*。
          1. 否则，令 _sep_ = ? ToString(_separator_)。
          1. 令 _R_ 为空字符串。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 若 _k_ > 0，设 _R_ 为 _R_ 与 _sep_ 的字符串拼接。
            1. 令 _element_ 为 ! Get(_O_, ! ToString(𝔽(_k_)))。
            1. 若 _element_ 不为 *undefined*，则
              1. 令 _S_ 为 ! ToString(_element_)。
              1. 设 _R_ 为 _R_ 与 _S_ 的字符串拼接。
            1. 设 _k_ = _k_ + 1。
          1. 返回 _R_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.keys">
        <h1>%TypedArray%.prototype.keys ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 返回 CreateArrayIterator(_O_, ~key~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.lastindexof">
        <h1>%TypedArray%.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref> 中的 `Array.prototype.lastIndexOf` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _len_ = 0，返回 *-1*<sub>𝔽</sub>。
          1. 若提供 _fromIndex_，令 _n_ 为 ? ToIntegerOrInfinity(_fromIndex_)；否则令 _n_ = _len_ - 1。
          1. 若 _n_ = -∞，返回 *-1*<sub>𝔽</sub>。
          1. 若 _n_ ≥ 0，则
            1. 令 _k_ = min(_n_, _len_ - 1)。
          1. 否则，
            1. 令 _k_ = _len_ + _n_。
          1. 当 _k_ ≥ 0 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kPresent_ = ! HasProperty(_O_, _Pk_)。
            1. 若 _kPresent_ 为 *true*，则
              1. 令 _elementK_ = ! Get(_O_, _Pk_)。
              1. 若 IsStrictlyEqual(_searchElement_, _elementK_) 为 *true*，返回 𝔽(_k_)。
            1. 设 _k_ = _k_ - 1。
          1. 返回 *-1*<sub>𝔽</sub>。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.length">
        <h1>get %TypedArray%.prototype.length</h1>
        <p>%TypedArray%`.prototype.length` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 与 [[ArrayLength]] 内部槽。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，返回 *+0*<sub>𝔽</sub>。
          1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
          1. 返回 𝔽(_length_)。
        </emu-alg>
        <p>该函数不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.map">
        <h1>%TypedArray%.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.map"></emu-xref> 中的 `Array.prototype.map` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _A_ 为 ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »)。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 令 _mappedValue_ = ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)。
            1. 执行 ? Set(_A_, _Pk_, _mappedValue_, *true*)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 _A_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduce">
        <h1>%TypedArray%.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.reduce"></emu-xref> 中的 `Array.prototype.reduce` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _len_ = 0 且 _initialValue_ 不存在，抛出 *TypeError* 异常。
          1. 令 _k_ = 0。
          1. 令 _accumulator_ = *undefined*。
          1. 若存在 _initialValue_，则
            1. 设 _accumulator_ = _initialValue_。
          1. 否则，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 设 _accumulator_ = ! Get(_O_, _Pk_)。
            1. 设 _k_ = _k_ + 1。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 设 _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 _accumulator_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduceright">
        <h1>%TypedArray%.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.reduceright"></emu-xref> 中的 `Array.prototype.reduceRight` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _len_ = 0 且 _initialValue_ 不存在，抛出 *TypeError* 异常。
          1. 令 _k_ = _len_ - 1。
          1. 令 _accumulator_ = *undefined*。
          1. 若存在 _initialValue_，则
            1. 设 _accumulator_ = _initialValue_。
          1. 否则，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 设 _accumulator_ = ! Get(_O_, _Pk_)。
            1. 设 _k_ = _k_ - 1。
          1. 当 _k_ ≥ 0 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 设 _accumulator_ = ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »)。
            1. 设 _k_ = _k_ - 1。
          1. 返回 _accumulator_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reverse">
        <h1>%TypedArray%.prototype.reverse ( )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.reverse"></emu-xref> 中的 `Array.prototype.reverse` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _middle_ = floor(_len_ / 2)。
          1. 令 _lower_ = 0。
          1. 当 _lower_ ≠ _middle_ 重复，
            1. 令 _upper_ = _len_ - _lower_ - 1。
            1. 令 _upperP_ = ! ToString(𝔽(_upper_))。
            1. 令 _lowerP_ = ! ToString(𝔽(_lower_))。
            1. 令 _lowerValue_ = ! Get(_O_, _lowerP_)。
            1. 令 _upperValue_ = ! Get(_O_, _upperP_)。
            1. 执行 ! Set(_O_, _lowerP_, _upperValue_, *true*)。
            1. 执行 ! Set(_O_, _upperP_, _lowerValue_, *true*)。
            1. 设 _lower_ = _lower_ + 1。
          1. 返回 _O_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.set" oldids="sec-%typedarray%.prototype.set-overloaded-offset">
        <h1>%TypedArray%.prototype.set ( _source_ [ , _offset_ ] )</h1>
        <p>该方法在此 _TypedArray_ 中设置多个值，从 _source_ 读取这些值。具体细节依据 _source_ 的类型不同而不同。可选的 _offset_ 指定开始写入的首个元素索引。如省略则视为 0。</p>
        <p>其被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _target_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_target_, [[TypedArrayName]])。
          1. 断言：_target_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _targetOffset_ 为 ? ToIntegerOrInfinity(_offset_)。
          1. 若 _targetOffset_ &lt; 0，抛出 *RangeError* 异常。
          1. 若 _source_ 是具有 [[TypedArrayName]] 内部槽的对象，则
            1. 执行 ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_)。
          1. 否则，
            1. 执行 ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_)。
          1. 返回 *undefined*。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>

        <emu-clause id="sec-settypedarrayfromarraylike" type="abstract operation" oldids="sec-%typedarray%.prototype.set-array-offset">
          <h1>
            SetTypedArrayFromArrayLike (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: an ECMAScript language value, but not a TypedArray,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>从 _source_ 读取值并自 _targetOffset_ 开始在 _target_ 中设置多个值。</dd>
          </dl>
          <emu-alg>
            1. 令 _targetRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~)。
            1. 若 IsTypedArrayOutOfBounds(_targetRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 令 _targetLength_ 为 TypedArrayLength(_targetRecord_)。
            1. 令 _src_ 为 ? ToObject(_source_)。
            1. 令 _srcLength_ 为 ? LengthOfArrayLike(_src_)。
            1. 若 _targetOffset_ = +∞，抛出 *RangeError* 异常。
            1. 若 _srcLength_ + _targetOffset_ > _targetLength_，抛出 *RangeError* 异常。
            1. 令 _k_ = 0。
            1. 当 _k_ &lt; _srcLength_ 重复，
              1. 令 _Pk_ = ! ToString(𝔽(_k_))。
              1. 令 _value_ = ? Get(_src_, _Pk_)。
              1. 令 _targetIndex_ = 𝔽(_targetOffset_ + _k_)。
              1. 执行 ? TypedArraySetElement(_target_, _targetIndex_, _value_)。
              1. 设 _k_ = _k_ + 1。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>
            SetTypedArrayFromTypedArray (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: a TypedArray,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>从 _source_ 读取值并自 _targetOffset_ 开始在 _target_ 中设置多个值。</dd>
          </dl>
          <emu-alg>
            1. 令 _targetBuffer_ 为 _target_.[[ViewedArrayBuffer]]。
            1. 令 _targetRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~)。
            1. 若 IsTypedArrayOutOfBounds(_targetRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 令 _targetLength_ 为 TypedArrayLength(_targetRecord_)。
            1. 令 _srcBuffer_ 为 _source_.[[ViewedArrayBuffer]]。
            1. 令 _srcRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~)。
            1. 若 IsTypedArrayOutOfBounds(_srcRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 令 _srcLength_ 为 TypedArrayLength(_srcRecord_)。
            1. 令 _targetType_ 为 TypedArrayElementType(_target_)。
            1. 令 _targetElementSize_ 为 TypedArrayElementSize(_target_)。
            1. 令 _targetByteOffset_ 为 _target_.[[ByteOffset]]。
            1. 令 _srcType_ 为 TypedArrayElementType(_source_)。
            1. 令 _srcElementSize_ 为 TypedArrayElementSize(_source_)。
            1. 令 _srcByteOffset_ 为 _source_.[[ByteOffset]]。
            1. 若 _targetOffset_ = +∞，抛出 *RangeError* 异常。
            1. 若 _srcLength_ + _targetOffset_ > _targetLength_，抛出 *RangeError* 异常。
            1. 若 _target_.[[ContentType]] 不等于 _source_.[[ContentType]]，抛出 *TypeError* 异常。
            1. 若 IsSharedArrayBuffer(_srcBuffer_) 为 *true*、IsSharedArrayBuffer(_targetBuffer_) 为 *true* 且 _srcBuffer_.[[ArrayBufferData]] 为 _targetBuffer_.[[ArrayBufferData]]，令 _sameSharedArrayBuffer_ = *true*；否则令 _sameSharedArrayBuffer_ = *false*。
            1. 若 SameValue(_srcBuffer_, _targetBuffer_) 为 *true* 或 _sameSharedArrayBuffer_ 为 *true*，则
              1. 令 _srcByteLength_ 为 TypedArrayByteLength(_srcRecord_)。
              1. 设 _srcBuffer_ 为 ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_)。
              1. 令 _srcByteIndex_ = 0。
            1. 否则，
              1. 令 _srcByteIndex_ = _srcByteOffset_。
            1. 令 _targetByteIndex_ = (_targetOffset_ × _targetElementSize_) + _targetByteOffset_。
            1. 令 _limit_ = _targetByteIndex_ + (_targetElementSize_ × _srcLength_)。
            1. 若 _srcType_ 是 _targetType_，则
              1. 注：复制必须保持源数据的位级编码。
              1. 当 _targetByteIndex_ &lt; _limit_ 重复，
                1. 令 _value_ 为 GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~)。
                1. 执行 SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~)。
                1. 设 _srcByteIndex_ = _srcByteIndex_ + 1。
                1. 设 _targetByteIndex_ = _targetByteIndex_ + 1。
            1. 否则，
              1. 当 _targetByteIndex_ &lt; _limit_ 重复，
                1. 令 _value_ 为 GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~)。
                1. 执行 SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~)。
                1. 设 _srcByteIndex_ = _srcByteIndex_ + _srcElementSize_。
                1. 设 _targetByteIndex_ = _targetByteIndex_ + _targetElementSize_。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.slice">
        <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.slice"></emu-xref> 中的 `Array.prototype.slice` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _srcArrayLength_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _startIndex_ = 0。
          1. 否则若 _relativeStart_ &lt; 0，令 _startIndex_ = max(_srcArrayLength_ + _relativeStart_, 0)。
          1. 否则令 _startIndex_ = min(_relativeStart_, _srcArrayLength_)。
          1. 若 _end_ 为 *undefined*，令 _relativeEnd_ = _srcArrayLength_；否则令 _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，令 _endIndex_ = 0。
          1. 否则若 _relativeEnd_ &lt; 0，令 _endIndex_ = max(_srcArrayLength_ + _relativeEnd_, 0)。
          1. 否则令 _endIndex_ = min(_relativeEnd_, _srcArrayLength_)。
          1. 令 _countBytes_ = max(_endIndex_ - _startIndex_, 0)。
          1. 令 _A_ 为 ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »)。
          1. 若 _countBytes_ > 0，则
            1. 设 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
            1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 设 _endIndex_ = min(_endIndex_, TypedArrayLength(_taRecord_))。
            1. 设 _countBytes_ = max(_endIndex_ - _startIndex_, 0)。
            1. 令 _srcType_ = TypedArrayElementType(_O_)。
            1. 令 _targetType_ = TypedArrayElementType(_A_)。
            1. 若 _srcType_ 是 _targetType_，则
              1. 注：传输必须保持源数据的位级编码。
              1. 令 _srcBuffer_ = _O_.[[ViewedArrayBuffer]]。
              1. 令 _targetBuffer_ = _A_.[[ViewedArrayBuffer]]。
              1. 令 _elementSize_ = TypedArrayElementSize(_O_)。
              1. 令 _srcByteOffset_ = _O_.[[ByteOffset]]。
              1. 令 _srcByteIndex_ = (_startIndex_ × _elementSize_) + _srcByteOffset_。
              1. 令 _targetByteIndex_ = _A_.[[ByteOffset]]。
              1. 令 _endByteIndex_ = _targetByteIndex_ + (_countBytes_ × _elementSize_)。
              1. 当 _targetByteIndex_ &lt; _endByteIndex_ 重复，
                1. 令 _value_ 为 GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~)。
                1. 执行 SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~)。
                1. 设 _srcByteIndex_ = _srcByteIndex_ + 1。
                1. 设 _targetByteIndex_ = _targetByteIndex_ + 1。
            1. 否则，
              1. 令 _n_ = 0。
              1. 令 _k_ = _startIndex_。
              1. 当 _k_ &lt; _endIndex_ 重复，
                1. 令 _Pk_ = ! ToString(𝔽(_k_))。
                1. 令 _kValue_ = ! Get(_O_, _Pk_)。
                1. 执行 ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*)。
                1. 设 _k_ = _k_ + 1。
                1. 设 _n_ = _n_ + 1。
          1. 返回 _A_。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.some">
        <h1>%TypedArray%.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法参数的解释与用法与 <emu-xref href="#sec-array.prototype.some"></emu-xref> 中的 `Array.prototype.some` 相同。</p>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _kValue_ = ! Get(_O_, _Pk_)。
            1. 令 _testResult_ = ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »))。
            1. 若 _testResult_ 为 *true*，返回 *true*。
            1. 设 _k_ = _k_ + 1。
          1. 返回 *false*。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.sort" oldids="sec-typedarraysortcompare">
        <h1>%TypedArray%.prototype.sort ( _comparator_ )</h1>
        <p>这是一个不同的方法；除下面描述的情况外，其实现与 <emu-xref href="#sec-array.prototype.sort"></emu-xref> 中 `Array.prototype.sort` 的要求相同。该方法的实现可以利用 *this* 值是长度固定且其整数索引属性非稀疏的对象这一知识进行优化。</p>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
        <p>其被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 _comparator_ 不为 *undefined* 且 IsCallable(_comparator_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _obj_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_obj_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 注：以下闭包执行数值比较而非 <emu-xref href="#sec-array.prototype.sort"></emu-xref> 中使用的字符串比较。
          1. 令 _SortCompare_ 为具有参数 (_x_, _y_) 并捕获 _comparator_ 的新抽象闭包，调用时执行：
            1. 返回 ? CompareTypedArrayElements(_x_, _y_, _comparator_)。
          1. 令 _sortedList_ 为 ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~)。
          1. 令 _j_ = 0。
          1. 当 _j_ &lt; _len_ 重复，
            1. 执行 ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*)。
            1. 设 _j_ = _j_ + 1。
          1. 返回 _obj_。
        </emu-alg>
        <emu-note>
          <p>因为 *NaN* 总是比较大于任何其他值（见 CompareTypedArrayElements），当未提供 _comparator_ 时，*NaN* 属性值总是排在结果末尾。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.subarray">
        <h1>%TypedArray%.prototype.subarray ( _start_, _end_ )</h1>
        <p>该方法返回一个新的 _TypedArray_，其元素类型与该 _TypedArray_ 相同，其 ArrayBuffer 为该 _TypedArray_ 的 ArrayBuffer，引用从 _start_（含）到 _end_（不含）区间的元素。若 _start_ 或 _end_ 为负值，则表示自数组末尾起的索引。</p>
        <p>其被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _buffer_ 为 _O_.[[ViewedArrayBuffer]]。
          1. 令 _srcRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 若 IsTypedArrayOutOfBounds(_srcRecord_) 为 *true*，则
            1. 令 _srcLength_ = 0。
          1. 否则，
            1. 令 _srcLength_ = TypedArrayLength(_srcRecord_)。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _startIndex_ = 0。
          1. 否则若 _relativeStart_ &lt; 0，令 _startIndex_ = max(_srcLength_ + _relativeStart_, 0)。
          1. 否则令 _startIndex_ = min(_relativeStart_, _srcLength_)。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 令 _srcByteOffset_ 为 _O_.[[ByteOffset]]。
          1. 令 _beginByteOffset_ = _srcByteOffset_ + (_startIndex_ × _elementSize_)。
          1. 若 _O_.[[ArrayLength]] 为 ~auto~ 且 _end_ 为 *undefined*，则
            1. 令 _argumentsList_ 为 « _buffer_, 𝔽(_beginByteOffset_) »。
          1. 否则，
            1. 若 _end_ 为 *undefined*，令 _relativeEnd_ = _srcLength_；否则令 _relativeEnd_ = ? ToIntegerOrInfinity(_end_)。
            1. 若 _relativeEnd_ = -∞，令 _endIndex_ = 0。
            1. 否则若 _relativeEnd_ &lt; 0，令 _endIndex_ = max(_srcLength_ + _relativeEnd_, 0)。
            1. 否则令 _endIndex_ = min(_relativeEnd_, _srcLength_)。
            1. 令 _newLength_ = max(_endIndex_ - _startIndex_, 0)。
            1. 令 _argumentsList_ = « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) »。
          1. 返回 ? TypedArraySpeciesCreate(_O_, _argumentsList_)。
        </emu-alg>
        <p>该方法不是泛型。*this* 值必须为具有 [[TypedArrayName]] 内部槽的对象。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tolocalestring">
        <h1>%TypedArray%.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>这是一个不同的方法，实现与 <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref> 中 `Array.prototype.toLocaleString` 的算法相同，只是用 TypedArrayLength 取代对 *"length"* 的 [[Get]]。在底层缓冲区不可调整大小且整数索引属性非稀疏时，实现可以利用 *this* 值长度固定的知识进行优化。然而，该优化不得引入任何可观测的指定行为变化。</p>
        <p>该方法不是泛型。在求值算法前，使用 *this* 值与 ~seq-cst~ 作为参数调用 ValidateTypedArray。若其结果为异常完成，则抛出该异常而不再执行算法。</p>
        <emu-note>
          <p>若 ECMAScript 实现包含 ECMA-402 国际化 API，则该方法基于 ECMA-402 规范中 `Array.prototype.toLocaleString` 的算法。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.toreversed">
        <h1>%TypedArray%.prototype.toReversed ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _A_ 为 ? TypedArrayCreateSameType(_O_, _len_)。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _from_ = ! ToString(𝔽(_len_ - _k_ - 1))。
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 令 _fromValue_ = ! Get(_O_, _from_)。
            1. 执行 ! Set(_A_, _Pk_, _fromValue_, *true*)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tosorted">
        <h1>%TypedArray%.prototype.toSorted ( _comparator_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 _comparator_ 不为 *undefined* 且 IsCallable(_comparator_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _A_ 为 ? TypedArrayCreateSameType(_O_, _len_)。
          1. 注：以下闭包执行数值比较，而非 <emu-xref href="#sec-array.prototype.tosorted"></emu-xref> 中使用的字符串比较。
          1. 令 _SortCompare_ 为具有参数 (_x_, _y_) 并捕获 _comparator_ 的新抽象闭包，调用时执行：
            1. 返回 ? CompareTypedArrayElements(_x_, _y_, _comparator_)。
          1. 令 _sortedList_ 为 ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~)。
          1. 令 _j_ = 0。
          1. 当 _j_ &lt; _len_ 重复，
            1. 执行 ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*)。
            1. 设 _j_ = _j_ + 1。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tostring">
        <h1>%TypedArray%.prototype.toString ( )</h1>
        <p>*"toString"* 属性的初始值为 %Array.prototype.toString%，定义见 <emu-xref href="#sec-array.prototype.tostring"></emu-xref>。</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.values">
        <h1>%TypedArray%.prototype.values ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 返回 CreateArrayIterator(_O_, ~value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.with">
        <h1>%TypedArray%.prototype.with ( _index_, _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_O_, ~seq-cst~)。
          1. 令 _len_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _relativeIndex_ 为 ? ToIntegerOrInfinity(_index_)。
          1. 若 _relativeIndex_ ≥ 0，令 _actualIndex_ = _relativeIndex_。
          1. 否则，令 _actualIndex_ = _len_ + _relativeIndex_。
          1. 若 _O_.[[ContentType]] 为 ~bigint~，令 _numericValue_ = ? ToBigInt(_value_)。
          1. 否则，令 _numericValue_ = ? ToNumber(_value_)。
          1. 若 IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) 为 *false*，抛出 *RangeError* 异常。
          1. 令 _A_ 为 ? TypedArrayCreateSameType(_O_, _len_)。
          1. 令 _k_ = 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _Pk_ = ! ToString(𝔽(_k_))。
            1. 若 _k_ = _actualIndex_，令 _fromValue_ = _numericValue_；否则令 _fromValue_ = ! Get(_O_, _Pk_)。
            1. 执行 ! Set(_A_, _Pk_, _fromValue_, *true*)。
            1. 设 _k_ = _k_ + 1。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%typedarray%.prototype-@@iterator" id="sec-%typedarray%.prototype-%symbol.iterator%">
        <h1>%TypedArray%.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 属性的初始值为 %TypedArray.prototype.values%，定义见 <emu-xref href="#sec-%typedarray%.prototype.values"></emu-xref>。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%.prototype-@@tostringtag" id="sec-get-%typedarray%.prototype-%symbol.tostringtag%">
        <h1>get %TypedArray%.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%TypedArray%`.prototype[%Symbol.toStringTag%]` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 若 _O_ 不是对象，返回 *undefined*。
          1. 若 _O_ 不具有 [[TypedArrayName]] 内部槽，返回 *undefined*。
          1. 令 _name_ = _O_.[[TypedArrayName]]。
          1. 断言：_name_ 是一个字符串。
          1. 返回 _name_。
        </emu-alg>
        <p>该属性特性为 { [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        <p>该函数 *"name"* 属性的初始值为 *"get [Symbol.toStringTag]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-typedarray-objects">
      <h1>TypedArray 对象的抽象操作</h1>

      <emu-clause id="sec-typedarraycreatefromconstructor" oldids="typedarray-create" type="abstract operation">
        <h1>
          TypedArrayCreateFromConstructor (
            _constructor_: a constructor,
            _argumentList_: a List of ECMAScript language values,
          ): 返回一个 TypedArray 的正常完成或抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于通过构造函数创建一个新的 TypedArray。</dd>
        </dl>
        <emu-alg>
          1. 令 _newTypedArray_ 为 ? Construct(_constructor_, _argumentList_)。
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_newTypedArray_, ~seq-cst~)。
          1. 断言：_newTypedArray_ 具有 <emu-xref href="#sec-properties-of-typedarray-instances" title></emu-xref> 中提及的所有内部槽。
          1. 若 _argumentList_ 中元素数量为 1 且 _argumentList_[0] 是 Number，则
            1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
            1. 若 _length_ &lt; ℝ(_argumentList_[0])，抛出 *TypeError* 异常。
          1. 返回 _newTypedArray_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-create-same-type" type="abstract operation">
        <h1>
          TypedArrayCreateSameType (
            _exemplar_: a TypedArray,
            _length_: a non-negative integer,
          ): 返回一个 TypedArray 的正常完成或抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于使用从 _exemplar_ 派生的构造函数及一个 _length_ 创建新的 TypedArray。不同于可通过 %Symbol.species% 构造自定义子类的 TypedArraySpeciesCreate，本操作始终使用内置的 TypedArray 构造函数之一。</dd>
        </dl>
        <emu-alg>
          1. 令 _constructor_ 为与 _exemplar_.[[TypedArrayName]] 的构造函数名称关联的内在对象，见 <emu-xref href="#table-the-typedarray-constructors"></emu-xref>。
          1. 令 _result_ 为 ? <emu-meta suppress-effects="user-code">TypedArrayCreateFromConstructor(_constructor_, « 𝔽(_length_) »)</emu-meta>。
          1. 断言：_result_ 具有 [[TypedArrayName]] 与 [[ContentType]] 内部槽。
          1. 断言：_result_.[[ContentType]] 为 _exemplar_.[[ContentType]]。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-species-create" type="abstract operation">
        <h1>
          TypedArraySpeciesCreate (
            _exemplar_: a TypedArray,
            _argumentList_: a List of ECMAScript language values,
          ): 返回一个 TypedArray 的正常完成或抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于通过从 _exemplar_ 派生的构造函数创建新的 TypedArray。不同于可通过 %Symbol.species% 创建非 Array 对象的 ArraySpeciesCreate，该操作强制构造函数必须创建一个实际的 TypedArray。</dd>
        </dl>
        <emu-alg>
          1. 令 _defaultConstructor_ 为与 _exemplar_.[[TypedArrayName]] 的构造函数名称关联的内在对象，见 <emu-xref href="#table-the-typedarray-constructors"></emu-xref>。
          1. 令 _constructor_ 为 ? SpeciesConstructor(_exemplar_, _defaultConstructor_)。
          1. 令 _result_ 为 ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_)。
          1. 若 _result_.[[ContentType]] 不为 _exemplar_.[[ContentType]]，抛出 *TypeError* 异常。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validatetypedarray" type="abstract operation">
        <h1>
          ValidateTypedArray (
            _O_: an ECMAScript language value,
            _order_: ~seq-cst~ or ~unordered~,
          ): 返回一个带缓冲见证记录的 TypedArray 的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_O_, [[TypedArrayName]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, _order_)。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 返回 _taRecord_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementsize" type="abstract operation">
        <h1>
          TypedArrayElementSize (
            _O_: a TypedArray,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回在 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中为 _O_.[[TypedArrayName]] 指定的元素大小值。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementtype" type="abstract operation">
        <h1>
          TypedArrayElementType (
            _O_: a TypedArray,
          ): a TypedArray element type
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回在 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中为 _O_.[[TypedArrayName]] 指定的元素类型值。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-comparetypedarrayelements" type="abstract operation">
        <h1>
          CompareTypedArrayElements (
            _x_: a Number or a BigInt,
            _y_: a Number or a BigInt,
            _comparator_: a function object or *undefined*,
          ): 返回一个 Number 的正常完成或一个突然完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_x_ 与 _y_ 同为 Number，或 _x_ 与 _y_ 同为 BigInt。
          1. 若 _comparator_ 不为 *undefined*，则
            1. 令 _v_ 为 ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »))。
            1. 若 _v_ 为 *NaN*，返回 *+0*<sub>𝔽</sub>。
            1. 返回 _v_。
          1. 若 _x_ 和 _y_ 均为 *NaN*，返回 *+0*<sub>𝔽</sub>。
          1. 若 _x_ 为 *NaN*，返回 *1*<sub>𝔽</sub>。
          1. 若 _y_ 为 *NaN*，返回 *-1*<sub>𝔽</sub>。
          1. 若 _x_ &lt; _y_，返回 *-1*<sub>𝔽</sub>。
          1. 若 _x_ > _y_，返回 *1*<sub>𝔽</sub>。
          1. 若 _x_ 为 *-0*<sub>𝔽</sub> 且 _y_ 为 *+0*<sub>𝔽</sub>，返回 *-1*<sub>𝔽</sub>。
          1. 若 _x_ 为 *+0*<sub>𝔽</sub> 且 _y_ 为 *-0*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
          1. 返回 *+0*<sub>𝔽</sub>。
        </emu-alg>
        <emu-note>
          该操作执行数值比较，而非 <emu-xref href="#sec-comparearrayelements"></emu-xref> 中使用的字符串比较。
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-constructors">
      <h1>_TypedArray_ 构造函数</h1>
      <p>每个 _TypedArray_ 构造函数：</p>
      <ul>
        <li>是具有下文所述结构的内在对象，区别仅在于在 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中用作构造函数名的名称不同于 _TypedArray_。</li>
        <li>是其行为根据参数数量与类型而不同的函数。一次 _TypedArray_ 调用的实际行为取决于传入的参数数量与种类。</li>
        <li>不应作为函数被调用，若以此方式调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。意在继承所规定 _TypedArray_ 行为的子类构造函数必须包含对 _TypedArray_ 构造函数的 `super` 调用，以使用支持 %TypedArray%`.prototype` 内置方法所需的内部状态创建并初始化子类实例。</li>
      </ul>

      <emu-clause id="sec-typedarray" oldids="sec-typedarray-length,sec-typedarray-object">
        <h1>_TypedArray_ ( ..._args_ )</h1>
        <p>每个 _TypedArray_ 构造函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 NewTarget 为 *undefined*，抛出 *TypeError* 异常。
          1. 令 _constructorName_ 为此 <var>TypedArray</var> 构造函数在 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中指定的构造函数名称的字符串值。
          1. 令 _proto_ 为 <code>"%<var>TypedArray</var>.prototype%"</code>。
          1. 令 _numberOfArgs_ 为 _args_ 中元素的数量。
          1. 若 _numberOfArgs_ = 0，则
            1. 返回 ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0)。
          1. 否则，
            1. 令 _firstArgument_ = _args_[0]。
            1. 若 _firstArgument_ 是对象，则
              1. 令 _O_ 为 ? AllocateTypedArray(_constructorName_, NewTarget, _proto_)。
              1. 若 _firstArgument_ 具有 [[TypedArrayName]] 内部槽，则
                1. 执行 ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_)。
              1. 否则若 _firstArgument_ 具有 [[ArrayBufferData]] 内部槽，则
                1. 若 _numberOfArgs_ > 1，令 _byteOffset_ = _args_[1]；否则 _byteOffset_ = *undefined*。
                1. 若 _numberOfArgs_ > 2，令 _length_ = _args_[2]；否则 _length_ = *undefined*。
                1. 执行 ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_)。
              1. 否则，
                1. 断言：_firstArgument_ 是对象且不具有 [[TypedArrayName]] 或 [[ArrayBufferData]]。
                1. 令 _usingIterator_ = ? GetMethod(_firstArgument_, %Symbol.iterator%)。
                1. 若 _usingIterator_ 不为 *undefined*，则
                  1. 令 _values_ = ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_))。
                  1. 执行 ? InitializeTypedArrayFromList(_O_, _values_)。
                1. 否则，
                  1. 注：_firstArgument_ 不是可迭代对象，因此假定其已为类数组对象。
                  1. 执行 ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_)。
              1. 返回 _O_。
            1. 否则，
              1. 断言：_firstArgument_ 不是对象。
              1. 令 _elementLength_ = ? ToIndex(_firstArgument_)。
              1. 返回 ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_)。
        </emu-alg>

        <emu-clause id="sec-allocatetypedarray" type="abstract operation">
          <h1>
            AllocateTypedArray (
              _constructorName_: a String which is the name of a TypedArray constructor in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>,
              _newTarget_: a constructor,
              _defaultProto_: a String,
              optional _length_: a non-negative integer,
            ): 返回一个 TypedArray 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>用于验证并创建某个 TypedArray 构造函数的实例。若传入 _length_，则还会分配一个该长度的 ArrayBuffer 并与新实例关联。AllocateTypedArray 提供 _TypedArray_ 使用的通用语义。</dd>
          </dl>
          <emu-alg>
            1. 令 _proto_ 为 ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_)。
            1. 令 _obj_ 为 TypedArrayCreate(_proto_)。
            1. 断言：_obj_.[[ViewedArrayBuffer]] 为 *undefined*。
            1. 设 _obj_.[[TypedArrayName]] = _constructorName_。
            1. 若 _constructorName_ 为 *"BigInt64Array"* 或 *"BigUint64Array"*，设 _obj_.[[ContentType]] = ~bigint~。
            1. 否则，设 _obj_.[[ContentType]] = ~number~。
            1. 若 _length_ 不存在，则
              1. 设 _obj_.[[ByteLength]] = 0。
              1. 设 _obj_.[[ByteOffset]] = 0。
              1. 设 _obj_.[[ArrayLength]] = 0。
            1. 否则，
              1. 执行 ? AllocateTypedArrayBuffer(_obj_, _length_)。
            1. 返回 _obj_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray">
          <h1>
            InitializeTypedArrayFromTypedArray (
              _O_: a TypedArray,
              _srcArray_: a TypedArray,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _srcData_ = _srcArray_.[[ViewedArrayBuffer]]。
            1. 令 _elementType_ = TypedArrayElementType(_O_)。
            1. 令 _elementSize_ = TypedArrayElementSize(_O_)。
            1. 令 _srcType_ = TypedArrayElementType(_srcArray_)。
            1. 令 _srcElementSize_ = TypedArrayElementSize(_srcArray_)。
            1. 令 _srcByteOffset_ = _srcArray_.[[ByteOffset]]。
            1. 令 _srcRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~)。
            1. 若 IsTypedArrayOutOfBounds(_srcRecord_) 为 *true*，抛出 *TypeError* 异常。
            1. 令 _elementLength_ = TypedArrayLength(_srcRecord_)。
            1. 令 _byteLength_ = _elementSize_ × _elementLength_。
            1. 若 _elementType_ 是 _srcType_，则
              1. 令 _data_ = ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_)。
            1. 否则，
              1. 令 _data_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>。
              1. 若 _srcArray_.[[ContentType]] 不等于 _O_.[[ContentType]]，抛出 *TypeError* 异常。
              1. 令 _srcByteIndex_ = _srcByteOffset_。
              1. 令 _targetByteIndex_ = 0。
              1. 令 _count_ = _elementLength_。
              1. 当 _count_ > 0 重复，
                1. 令 _value_ = GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~)。
                1. 执行 SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~)。
                1. 设 _srcByteIndex_ = _srcByteIndex_ + _srcElementSize_。
                1. 设 _targetByteIndex_ = _targetByteIndex_ + _elementSize_。
                1. 设 _count_ = _count_ - 1。
            1. 设 _O_.[[ViewedArrayBuffer]] = _data_。
            1. 设 _O_.[[ByteLength]] = _byteLength_。
            1. 设 _O_.[[ByteOffset]] = 0。
            1. 设 _O_.[[ArrayLength]] = _elementLength_。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length">
          <h1>
            InitializeTypedArrayFromArrayBuffer (
              _O_: a TypedArray,
              _buffer_: an ArrayBuffer or a SharedArrayBuffer,
              _byteOffset_: an ECMAScript language value,
              _length_: an ECMAScript language value,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _elementSize_ = TypedArrayElementSize(_O_)。
            1. 令 _offset_ = ? ToIndex(_byteOffset_)。
            1. 若 _offset_ 模 _elementSize_ ≠ 0，抛出 *RangeError* 异常。
            1. 令 _bufferIsFixedLength_ = IsFixedLengthArrayBuffer(_buffer_)。
            1. 若 _length_ 不为 *undefined*，则
              1. 令 _newLength_ = ? ToIndex(_length_)。
            1. 若 IsDetachedBuffer(_buffer_) 为 *true*，抛出 *TypeError* 异常。
            1. 令 _bufferByteLength_ = ArrayBufferByteLength(_buffer_, ~seq-cst~)。
            1. 若 _length_ 为 *undefined* 且 _bufferIsFixedLength_ 为 *false*，则
              1. 若 _offset_ > _bufferByteLength_，抛出 *RangeError* 异常。
              1. 设 _O_.[[ByteLength]] = ~auto~。
              1. 设 _O_.[[ArrayLength]] = ~auto~。
            1. 否则，
              1. 若 _length_ 为 *undefined*，则
                1. 若 _bufferByteLength_ 模 _elementSize_ ≠ 0，抛出 *RangeError* 异常。
                1. 令 _newByteLength_ = _bufferByteLength_ - _offset_。
                1. 若 _newByteLength_ &lt; 0，抛出 *RangeError* 异常。
              1. 否则，
                1. 令 _newByteLength_ = _newLength_ × _elementSize_。
                1. 若 _offset_ + _newByteLength_ > _bufferByteLength_，抛出 *RangeError* 异常。
              1. 设 _O_.[[ByteLength]] = _newByteLength_。
              1. 设 _O_.[[ArrayLength]] = _newByteLength_ / _elementSize_。
            1. 设 _O_.[[ViewedArrayBuffer]] = _buffer_。
            1. 设 _O_.[[ByteOffset]] = _offset_。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromlist" type="abstract operation">
          <h1>
            InitializeTypedArrayFromList (
              _O_: a TypedArray,
              _values_: a List of ECMAScript language values,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _len_ 为 _values_ 中的元素数量。
            1. 执行 ? AllocateTypedArrayBuffer(_O_, _len_)。
            1. 令 _k_ = 0。
            1. 当 _k_ &lt; _len_ 重复，
              1. 令 _Pk_ = ! ToString(𝔽(_k_))。
              1. 令 _kValue_ 为 _values_ 的第一个元素。
              1. 移除 _values_ 的第一个元素。
              1. 执行 ? Set(_O_, _Pk_, _kValue_, *true*)。
              1. 设 _k_ = _k_ + 1。
            1. 断言：_values_ 现在为空列表。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraylike" type="abstract operation">
          <h1>
            InitializeTypedArrayFromArrayLike (
              _O_: a TypedArray,
              _arrayLike_: an Object, but not a TypedArray or an ArrayBuffer,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _len_ 为 ? LengthOfArrayLike(_arrayLike_)。
            1. 执行 ? AllocateTypedArrayBuffer(_O_, _len_)。
            1. 令 _k_ = 0。
            1. 当 _k_ &lt; _len_ 重复，
              1. 令 _Pk_ = ! ToString(𝔽(_k_))。
              1. 令 _kValue_ = ? Get(_arrayLike_, _Pk_)。
              1. 执行 ? Set(_O_, _Pk_, _kValue_, *true*)。
              1. 设 _k_ = _k_ + 1。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allocatetypedarraybuffer" type="abstract operation">
          <h1>
            AllocateTypedArrayBuffer (
              _O_: a TypedArray,
              _length_: a non-negative integer,
            ): 返回 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>为 _O_ 分配并关联一个 ArrayBuffer。</dd>
          </dl>
          <emu-alg>
            1. 断言：_O_.[[ViewedArrayBuffer]] 为 *undefined*。
            1. 令 _elementSize_ = TypedArrayElementSize(_O_)。
            1. 令 _byteLength_ = _elementSize_ × _length_。
            1. 令 _data_ = ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>。
            1. 设 _O_.[[ViewedArrayBuffer]] = _data_。
            1. 设 _O_.[[ByteLength]] = _byteLength_。
            1. 设 _O_.[[ByteOffset]] = 0。
            1. 设 _O_.[[ArrayLength]] = _length_。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>_TypedArray_ 构造函数的属性</h1>
      <p>每个 _TypedArray_ 构造函数：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %TypedArray%。</li>
        <li>具有 *"length"* 属性，其值为 *3*<sub>𝔽</sub>。</li>
        <li>具有 *"name"* 属性，其值为在 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中为其指定的构造函数名称的字符串值。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-typedarray.bytes_per_element">
        <h1>_TypedArray_.BYTES_PER_ELEMENT</h1>
        <p>_TypedArray_`.BYTES_PER_ELEMENT` 的值是 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中为 _TypedArray_ 指定的元素大小值。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype">
        <h1>_TypedArray_.prototype</h1>
        <p>_TypedArray_`.prototype` 的初始值是对应的 _TypedArray_ 原型内在对象（<emu-xref href="#sec-properties-of-typedarray-prototype-objects"></emu-xref>）。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-prototype-objects">
      <h1>_TypedArray_ 原型对象的属性</h1>
      <p>每个 _TypedArray_ 原型对象：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %TypedArray.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[ViewedArrayBuffer]] 或其他特定于 _TypedArray_ 实例对象的内部槽。</li>
      </ul>

      <emu-clause id="sec-typedarray.prototype.bytes_per_element">
        <h1>_TypedArray_.prototype.BYTES_PER_ELEMENT</h1>
        <p>_TypedArray_`.prototype.BYTES_PER_ELEMENT` 的值是 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中为 _TypedArray_ 指定的元素大小值。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype.constructor">
        <h1>_TypedArray_.prototype.constructor</h1>
        <p>给定 _TypedArray_ 构造函数的原型的 *"constructor"* 属性初始值为该构造函数本身。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-instances">
      <h1>_TypedArray_ 实例的属性</h1>
      <p>_TypedArray_ 实例是 TypedArrays。每个 _TypedArray_ 实例从对应的 _TypedArray_ 原型对象继承属性。每个 _TypedArray_ 实例具有以下内部槽：[[ViewedArrayBuffer]]、[[TypedArrayName]]、[[ContentType]]、[[ByteLength]]、[[ByteOffset]] 和 [[ArrayLength]]。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>键控集合（Keyed Collections）</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map 对象</h1>
    <p>Map 是键/值对的集合，其中键和值都可以是任意 ECMAScript 语言值。一个特定的键值在该 Map 的集合中只能出现一次。不同的键值通过 SameValueZero 比较算法的语义加以区分。</p>
    <p>Map 必须使用哈希表或其他在平均情况下能提供次线性访问时间的机制实现。本规范中使用的数据结构仅用于描述 Map 所需的可观察语义，而不是一个可行的实现模型。</p>

    <emu-clause id="sec-map-constructor">
      <h1>Map 构造函数</h1>
      <p>Map 构造函数：</p>
      <ul>
        <li>是 <dfn>%Map%</dfn>。</li>
        <li>是全局对象 *"Map"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Map。</li>
        <li>不应作为普通函数调用；若以此方式调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。希望继承指定 Map 行为的子类构造函数必须包含对 Map 构造函数的 `super` 调用，以创建并初始化具有支持 `Map.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <emu-clause id="sec-map-iterable">
        <h1>Map ( [ _iterable_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 令 _map_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Map.prototype%"*, « [[MapData]] »)。
          1. 将 _map_.[[MapData]] 设为一个新的空 List。
          1. 如果 _iterable_ 是 *undefined* 或 *null*，返回 _map_。
          1. 令 _adder_ 为 ? Get(_map_, *"set"*)。
          1. 如果 IsCallable(_adder_) 为 *false*，抛出 *TypeError* 异常。
          1. 返回 ? AddEntriesFromIterable(_map_, _iterable_, _adder_)。
        </emu-alg>
        <emu-note>
          <p>如果参数 _iterable_ 存在，期望它是一个实现了 %Symbol.iterator% 方法的对象，该迭代器返回的每个值是一个长度为 2 的类数组对象，其第一个元素用作 Map 的键，第二个元素是与该键关联的值。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-add-entries-from-iterable" type="abstract operation">
        <h1>
          AddEntriesFromIterable (
            _target_: an Object,
            _iterable_: an ECMAScript language value, but not *undefined* or *null*,
            _adder_: a function object,
          ): 要么是包含一个 ECMAScript 语言值的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_adder_ 将以 _target_ 作为接收者被调用。</dd>
        </dl>
        <emu-alg>
          1. 令 _iteratorRecord_ 为 ? GetIterator(_iterable_, ~sync~)。
          1. 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 如果 _next_ 是 ~done~，返回 _target_。
            1. 如果 _next_ 不是一个 Object，则
              1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
              1. 返回 ? IteratorClose(_iteratorRecord_, _error_)。
            1. 令 _k_ 为 Completion(Get(_next_, *"0"* ))。
            1. IfAbruptCloseIterator(_k_, _iteratorRecord_)。
            1. 令 _v_ 为 Completion(Get(_next_, *"1"* ))。
            1. IfAbruptCloseIterator(_v_, _iteratorRecord_)。
            1. 令 _status_ 为 Completion(Call(_adder_, _target_, « _k_, _v_ »))。
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_)。
        </emu-alg>
        <emu-note>
          <p>参数 _iterable_ 期望是一个实现 %Symbol.iterator% 方法的对象，其迭代器产出的每个值是一个二元的类数组对象，第一个元素为 Map 键，第二个元素为与键关联的值。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Map 构造函数的属性</h1>
      <p>Map 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-map.groupby">
        <h1>Map.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ 应该是接受两个参数的函数。`groupBy` 按升序对 _items_ 中的每个元素调用 _callback_，并构造一个新的 Map。_callback_ 返回的每个值作为 Map 的一个键。对每个这样的键，结果 Map 有一个条目，其键是该键，其值是包含所有使得 _callback_ 返回该键的元素的数组。</p>
          <p>_callback_ 以两个参数被调用：元素的值以及该元素的索引。</p>
          <p>`groupBy` 的返回值是一个 Map。</p>
        </emu-note>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _groups_ 为 ? GroupBy(_items_, _callback_, ~collection~)。
          1. 令 _map_ 为 ! Construct(%Map%)。
          1. 对 _groups_ 中每个 Record { [[Key]], [[Elements]] } _g_：
            1. 令 _elements_ 为 CreateArrayFromList(_g_.[[Elements]])。
            1. 令 _entry_ 为记录 { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }。
            1. 将 _entry_ 追加到 _map_.[[MapData]]。
          1. 返回 _map_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype">
        <h1>Map.prototype</h1>
        <p>`Map.prototype` 的初始值是 Map 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-map-@@species" id="sec-get-map-%symbol.species%">
        <h1>get Map [ %Symbol.species% ]</h1>
        <p>`Map[%Symbol.species%]` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数 *"name"* 属性的值为 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>创建派生集合对象的方法应调用 %Symbol.species% 来确定用于创建派生对象的构造函数。子类构造函数可以重写 %Symbol.species% 以改变默认的构造函数选择。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-prototype-object">
      <h1>Map 原型对象的属性</h1>
      <p><dfn>Map 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Map.prototype%</dfn>。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[MapData]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-map.prototype.clear">
        <h1>Map.prototype.clear ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 对 _M_.[[MapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 将 _p_.[[Key]] 设为 ~empty~。
            1. 将 _p_.[[Value]] 设为 ~empty~。
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>保留现有的 [[MapData]] List，是因为可能存在已经在该 List 中迭代到一半的 Map 迭代器对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.constructor">
        <h1>Map.prototype.constructor</h1>
        <p>`Map.prototype.constructor` 的初始值是 %Map%。</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype.delete">
        <h1>Map.prototype.delete ( _key_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 将 _key_ 设为 CanonicalizeKeyedCollectionKey(_key_)。
          1. 对 _M_.[[MapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，则
              1. 将 _p_.[[Key]] 设为 ~empty~。
              1. 将 _p_.[[Value]] 设为 ~empty~。
              1. 返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>值 ~empty~ 用作规范设备以指示一个条目已被删除。实际实现可采取其它操作，如在内部数据结构中物理移除此条目。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.entries">
        <h1>Map.prototype.entries ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 返回 ? CreateMapIterator(_M_, ~key+value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.foreach">
        <h1>Map.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 如果 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _entries_ 为 _M_.[[MapData]]。
          1. 令 _numEntries_ 为 _entries_ 中元素的数量。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _numEntries_ 重复，
            1. 令 _e_ 为 _entries_[_index_]。
            1. 将 _index_ 设为 _index_ + 1。
            1. 如果 _e_.[[Key]] 不是 ~empty~，则
              1. 执行 ? Call(_callback_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »)。
              1. 注：在执行 _callback_ 期间 _entries_ 中元素数量可能增加。
              1. 将 _numEntries_ 设为 _entries_ 中元素的数量。
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>_callback_ 应为接受三个参数的函数。`forEach` 按键插入顺序对 Map 中每个键/值对调用一次 _callback_。仅对 Map 中实际存在的键调用；已删除的键不会调用。</p>
          <p>如果提供 _thisArg_，它将在每次调用 _callback_ 时用作 *this* 值；否则使用 *undefined*。</p>
          <p>_callback_ 以三个参数调用：条目的值、条目的键以及被遍历的 Map。</p>
          <p>`forEach` 不直接修改其被调用的对象，但该对象可在 _callback_ 内被修改。Map 的 [[MapData]] 中的每个条目只访问一次。调用开始后新增的键会被访问。一个键如果在访问后被删除然后在调用结束前又被重新加入会被再次访问。调用开始后删除且尚未访问的键不会被访问，除非它在调用结束前再次添加。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.get">
        <h1>Map.prototype.get ( _key_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 将 _key_ 设为 CanonicalizeKeyedCollectionKey(_key_)。
          1. 对 _M_.[[MapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，返回 _p_.[[Value]]。
          1. 返回 *undefined*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.has">
        <h1>Map.prototype.has ( _key_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 将 _key_ 设为 CanonicalizeKeyedCollectionKey(_key_)。
          1. 对 _M_.[[MapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.keys">
        <h1>Map.prototype.keys ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 返回 ? CreateMapIterator(_M_, ~key~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.set">
        <h1>Map.prototype.set ( _key_, _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 将 _key_ 设为 CanonicalizeKeyedCollectionKey(_key_)。
          1. 对 _M_.[[MapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，则
              1. 将 _p_.[[Value]] 设为 _value_。
              1. 返回 _M_。
          1. 令 _p_ 为记录 { [[Key]]: _key_, [[Value]]: _value_ }。
          1. 将 _p_ 追加到 _M_.[[MapData]]。
          1. 返回 _M_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-map.prototype.size">
        <h1>get Map.prototype.size</h1>
        <p>`Map.prototype.size` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[MapData]])。
          1. 令 _count_ 为 0。
          1. 对 _M_.[[MapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~，将 _count_ 设为 _count_ + 1。
          1. 返回 𝔽(_count_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.values">
        <h1>Map.prototype.values ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 返回 ? CreateMapIterator(_M_, ~value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@iterator" id="sec-map.prototype-%symbol.iterator%">
        <h1>Map.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 属性的初始值是 %Map.prototype.entries%，定义见 <emu-xref href="#sec-map.prototype.entries"></emu-xref>。</p>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@tostringtag" id="sec-map.prototype-%symbol.tostringtag%">
        <h1>Map.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Map"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-map-instances">
      <h1>Map 实例的属性</h1>
      <p>Map 实例是普通对象，从 Map 原型对象继承属性。Map 实例还具有 [[MapData]] 内部槽。</p>
    </emu-clause>

    <emu-clause id="sec-map-iterator-objects">
      <h1>Map 迭代器对象</h1>
      <p><dfn variants="Map Iterators,Map Iterator object,Map Iterator objects">Map Iterator</dfn> 是一个表示对某个特定 Map 实例对象的特定迭代的对象。没有命名的 Map 迭代器构造函数。相反，通过调用某些 Map 实例对象的方法创建 Map 迭代器对象。</p>

      <emu-clause id="sec-createmapiterator" type="abstract operation" oldids="sec-properties-of-map-iterator-instances,table-50,table-internal-slots-of-map-iterator-instances">
        <h1>
          CreateMapIterator (
            _map_: an ECMAScript language value,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): 一个包含 Generator 的正常完成或抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于为返回此类迭代器的 Map 方法创建迭代器对象。</dd>
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_map_, [[MapData]])。
          1. 令 _closure_ 为一个无参数的新抽象闭包，捕获 _map_ 和 _kind_ 并在调用时执行：
            1. 令 _entries_ 为 _map_.[[MapData]]。
            1. 令 _index_ 为 0。
            1. 令 _numEntries_ 为 _entries_ 中元素的数量。
            1. 当 _index_ &lt; _numEntries_ 重复，
              1. 令 _e_ 为 _entries_[_index_]。
              1. 将 _index_ 设为 _index_ + 1。
              1. 如果 _e_.[[Key]] 不是 ~empty~，则
                1. 如果 _kind_ 是 ~key~，则
                  1. 令 _result_ 为 _e_.[[Key]]。
                1. 否则如果 _kind_ 是 ~value~，则
                  1. 令 _result_ 为 _e_.[[Value]]。
                1. 否则，
                  1. 断言：_kind_ 是 ~key+value~。
                  1. 令 _result_ 为 CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »)。
                1. 执行 ? GeneratorYield(CreateIteratorResultObject(_result_, *false*))。
                1. 注：在 GeneratorYield 暂停本抽象操作执行期间，_entries_ 中的元素数量可能增加。
                1. 将 _numEntries_ 设为 _entries_ 中元素的数量。
            1. 返回 NormalCompletion(~unused~)。
          1. 返回 CreateIteratorFromClosure(_closure_, *"%MapIteratorPrototype%"*, %MapIteratorPrototype%)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%mapiteratorprototype%-object">
        <h1>%MapIteratorPrototype% 对象</h1>
        <p><dfn>%MapIteratorPrototype%</dfn> 对象：</p>
        <ul>
          <li>具有所有 Map 迭代器对象继承的属性。</li>
          <li>是一个普通对象。</li>
          <li>有一个 [[Prototype]] 内部槽，其值为 %Iterator.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%mapiteratorprototype%.next">
          <h1>%MapIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. 返回 ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%MapIteratorPrototype%"*)</emu-meta>。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%mapiteratorprototype%-@@tostringtag" id="sec-%mapiteratorprototype%-%symbol.tostringtag%">
          <h1>%MapIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Map Iterator"*。</p>
          <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set 对象</h1>
    <p>Set 对象是 ECMAScript 语言值的集合。一个特定的值在 Set 的集合中只能出现一次。不同的值通过 SameValueZero 比较算法的语义区分。</p>
    <p>Set 对象必须使用哈希表或其他平均情况下提供次线性访问时间的机制实现。本规范使用的数据结构仅用于描述 Set 对象所需的可观察语义，不是可行的实现模型。</p>

    <emu-clause id="sec-abstract-operations-for-set-objects">
      <h1>Set 对象的抽象操作</h1>

      <emu-clause id="sec-set-records">
        <h1>Set 记录</h1>
        <p><dfn variants="Set Records">Set Record</dfn> 是用于封装 Set 或类似对象接口的 Record 值。</p>
        <p>Set 记录具有 <emu-xref href="#table-set-record-fields"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-set-record-fields" caption="Set 记录字段">
          <table>
            <tr>
              <th>字段名</th>
              <th>取值</th>
              <th>含义</th>
            </tr>
            <tr>
              <td>[[SetObject]]</td>
              <td>an Object</td>
              <td>该 Set 或类似对象。</td>
            </tr>
            <tr>
              <td>[[Size]]</td>
              <td>a non-negative integer or +∞</td>
              <td>对象报告的大小。</td>
            </tr>
            <tr>
              <td>[[Has]]</td>
              <td>a function object</td>
              <td>对象的 `has` 方法。</td>
            </tr>
            <tr>
              <td>[[Keys]]</td>
              <td>a function object</td>
              <td>对象的 `keys` 方法。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getsetrecord" type="abstract operation">
        <h1>
          GetSetRecord (
            _obj_: an ECMAScript language value,
          ): 一个包含 Set Record 的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _obj_ 不是一个 Object，抛出 *TypeError* 异常。
          1. 令 _rawSize_ 为 ? Get(_obj_, *"size"*)。
          1. 令 _numSize_ 为 ? ToNumber(_rawSize_)。
          1. 注：如果 _rawSize_ 是 *undefined*，则 _numSize_ 将为 *NaN*。
          1. 如果 _numSize_ 是 *NaN*，抛出 *TypeError* 异常。
          1. 令 _intSize_ 为 ! ToIntegerOrInfinity(_numSize_)。
          1. 如果 _intSize_ &lt; 0，抛出 *RangeError* 异常。
          1. 令 _has_ 为 ? Get(_obj_, *"has"*)。
          1. 如果 IsCallable(_has_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _keys_ 为 ? Get(_obj_, *"keys"*)。
          1. 如果 IsCallable(_keys_) 为 *false*，抛出 *TypeError* 异常。
          1. 返回一个新的 Set Record { [[SetObject]]: _obj_, [[Size]]: _intSize_, [[Has]]: _has_, [[Keys]]: _keys_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatahas" type="abstract operation">
        <h1>
          SetDataHas (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 SetDataIndex(_setData_, _value_) 是 ~not-found~，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdataindex" type="abstract operation">
        <h1>
          SetDataIndex (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): 一个非负整数或 ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 将 _value_ 设为 CanonicalizeKeyedCollectionKey(_value_)。
          1. 令 _size_ 为 _setData_ 中的元素数量。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _size_ 重复，
            1. 令 _e_ 为 _setData_[_index_]。
            1. 如果 _e_ 不是 ~empty~ 且 _e_ 是 _value_，则
              1. 返回 _index_。
            1. 将 _index_ 设为 _index_ + 1。
          1. 返回 ~not-found~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatasize" type="abstract operation">
        <h1>
          SetDataSize (
            _setData_: a List of either ECMAScript language values or ~empty~,
          ): 一个非负整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _count_ 为 0。
          1. 对 _setData_ 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~，将 _count_ 设为 _count_ + 1。
          1. 返回 _count_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-set-constructor">
      <h1>Set 构造函数</h1>
      <p>Set 构造函数：</p>
      <ul>
        <li>是 <dfn>%Set%</dfn>。</li>
        <li>是全局对象 *"Set"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Set 对象。</li>
        <li>不应作为普通函数调用；若以此方式调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。希望继承指定 Set 行为的子类构造函数必须包含对 Set 构造函数的 `super` 调用，以创建并初始化具有支持 `Set.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <emu-clause id="sec-set-iterable">
        <h1>Set ( [ _iterable_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 令 _set_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Set.prototype%"*, « [[SetData]] »)。
          1. 将 _set_.[[SetData]] 设为一个新的空 List。
          1. 如果 _iterable_ 是 *undefined* 或 *null*，返回 _set_。
          1. 令 _adder_ 为 ? Get(_set_, *"add"*)。
          1. 如果 IsCallable(_adder_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _iteratorRecord_ 为 ? GetIterator(_iterable_, ~sync~)。
          1. 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 如果 _next_ 是 ~done~，返回 _set_。
            1. 令 _status_ 为 Completion(Call(_adder_, _set_, « _next_ »))。
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Set 构造函数的属性</h1>
      <p>Set 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-set.prototype">
        <h1>Set.prototype</h1>
        <p>`Set.prototype` 的初始值是 Set 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-set-@@species" id="sec-get-set-%symbol.species%">
        <h1>get Set [ %Symbol.species% ]</h1>
        <p>`Set[%Symbol.species%]` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数 *"name"* 属性的值为 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>创建派生集合对象的方法应调用 %Symbol.species% 来确定用于创建派生对象的构造函数。子类构造函数可重写 %Symbol.species% 来改变默认的构造函数选择。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-prototype-object">
      <h1>Set 原型对象的属性</h1>
      <p><dfn>Set 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Set.prototype%</dfn>。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[SetData]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-set.prototype.add">
        <h1>Set.prototype.add ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[SetData]])。
          1. 将 _value_ 设为 CanonicalizeKeyedCollectionKey(_value_)。
          1. 对 _S_.[[SetData]] 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~ 且 SameValue(_e_, _value_) 为 *true*，则
              1. 返回 _S_。
          1. 将 _value_ 追加到 _S_.[[SetData]]。
          1. 返回 _S_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.clear">
        <h1>Set.prototype.clear ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[SetData]])。
          1. 对 _S_.[[SetData]] 中每个元素 _e_：
            1. 用值为 ~empty~ 的元素替换 _S_.[[SetData]] 中值为 _e_ 的元素。
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>保留现有 [[SetData]] List，因为可能存在已经在该 List 中迭代到一半的 Set 迭代器对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.constructor">
        <h1>Set.prototype.constructor</h1>
        <p>`Set.prototype.constructor` 的初始值是 %Set%。</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype.delete">
        <h1>Set.prototype.delete ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[SetData]])。
          1. 将 _value_ 设为 CanonicalizeKeyedCollectionKey(_value_)。
          1. 对 _S_.[[SetData]] 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~ 且 SameValue(_e_, _value_) 为 *true*，则
              1. 用值为 ~empty~ 的元素替换 _S_.[[SetData]] 中值为 _e_ 的元素。
              1. 返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>值 ~empty~ 用作规范设备指示条目已删除。实际实现可以物理删除该条目等。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.difference">
        <h1>Set.prototype.difference ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 令 _resultSetData_ 为 _O_.[[SetData]] 的一个拷贝。
          1. 如果 SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]]，则
            1. 令 _thisSize_ 为 _O_.[[SetData]] 中元素的数量。
            1. 令 _index_ 为 0。
            1. 当 _index_ &lt; _thisSize_ 重复，
              1. 令 _e_ 为 _resultSetData_[_index_]。
              1. 如果 _e_ 不是 ~empty~，则
                1. 令 _inOther_ 为 ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
                1. 如果 _inOther_ 为 *true*，则
                  1. 将 _resultSetData_[_index_] 设为 ~empty~。
              1. 将 _index_ 设为 _index_ + 1。
          1. 否则，
            1. 令 _keysIter_ 为 ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
            1. 令 _next_ 为 ~not-started~。
            1. 当 _next_ 不是 ~done~ 重复，
              1. 将 _next_ 设为 ? IteratorStepValue(_keysIter_)。
              1. 如果 _next_ 不是 ~done~，则
                1. 将 _next_ 设为 CanonicalizeKeyedCollectionKey(_next_)。
                1. 令 _valueIndex_ 为 SetDataIndex(_resultSetData_, _next_)。
                1. 如果 _valueIndex_ 不是 ~not-found~，则
                  1. 将 _resultSetData_[_valueIndex_] 设为 ~empty~。
          1. 令 _result_ 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. 将 _result_.[[SetData]] 设为 _resultSetData_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.entries">
        <h1>Set.prototype.entries ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateSetIterator(_S_, ~key+value~)。
        </emu-alg>
        <emu-note>
          <p>在迭代语义上，Set 类似于每个条目键和值相同的 Map。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.foreach">
        <h1>Set.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[SetData]])。
          1. 如果 IsCallable(_callback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _entries_ 为 _S_.[[SetData]]。
          1. 令 _numEntries_ 为 _entries_ 中元素的数量。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _numEntries_ 重复，
            1. 令 _e_ 为 _entries_[_index_]。
            1. 将 _index_ 设为 _index_ + 1。
            1. 如果 _e_ 不是 ~empty~，则
              1. 执行 ? Call(_callback_, _thisArg_, « _e_, _e_, _S_ »)。
              1. 注：执行 _callback_ 期间 _entries_ 中元素数量可能增加。
              1. 将 _numEntries_ 设为 _entries_ 中元素的数量。
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>_callback_ 应为接受三个参数的函数。`forEach` 按值插入顺序对 Set 对象中每个值调用一次 _callback_。仅对实际存在的值调用；对已删除的值不会调用。</p>
          <p>如果提供 _thisArg_，它作为每次调用 _callback_ 的 *this* 值；否则使用 *undefined*。</p>
          <p>_callback_ 以三个参数调用：前两个参数是 Set 中的一个值（相同的值传两次），第三个参数是被遍历的 Set 对象。</p>
          <p>_callback_ 传递三个参数是为了与 Map 和 Array 的 `forEach` 回调函数保持一致；在 Set 中每个值同时被视为键和值。</p>
          <p>`forEach` 不直接修改其被调用的对象，但对象可在 _callback_ 中被修改。</p>
          <p>每个值通常只访问一次；但如果某值在被访问后被删除并在调用结束前重新加入，会被再次访问。调用开始后删除且尚未访问的值不会被访问，除非在调用结束前再次添加。调用开始后新增的值会被访问。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.has">
        <h1>Set.prototype.has ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[SetData]])。
          1. 将 _value_ 设为 CanonicalizeKeyedCollectionKey(_value_)。
          1. 对 _S_.[[SetData]] 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~ 且 SameValue(_e_, _value_) 为 *true*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.intersection">
        <h1>Set.prototype.intersection ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 令 _resultSetData_ 为一个新的空 List。
          1. 如果 SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]]，则
            1. 令 _thisSize_ 为 _O_.[[SetData]] 中元素的数量。
            1. 令 _index_ 为 0。
            1. 当 _index_ &lt; _thisSize_ 重复，
              1. 令 _e_ 为 _O_.[[SetData]][_index_]。
              1. 将 _index_ 设为 _index_ + 1。
              1. 如果 _e_ 不是 ~empty~，则
                1. 令 _inOther_ 为 ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
                1. 如果 _inOther_ 为 *true*，则
                  1. 注：早先对 _otherRec_.[[Has]] 的调用可能移除并重新添加 _O_.[[SetData]] 的元素，导致同一元素在本次迭代中被访问两次。
                  1. 如果 SetDataHas(_resultSetData_, _e_) 为 *false*，则
                    1. 将 _e_ 追加到 _resultSetData_。
                1. 注：执行 _otherRec_.[[Has]] 期间 _O_.[[SetData]] 中元素数量可能增加。
                1. 将 _thisSize_ 设为 _O_.[[SetData]] 中元素的数量。
          1. 否则，
            1. 令 _keysIter_ 为 ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
            1. 令 _next_ 为 ~not-started~。
            1. 当 _next_ 不是 ~done~ 重复，
              1. 将 _next_ 设为 ? IteratorStepValue(_keysIter_)。
              1. 如果 _next_ 不是 ~done~，则
                1. 将 _next_ 设为 CanonicalizeKeyedCollectionKey(_next_)。
                1. 令 _inThis_ 为 SetDataHas(_O_.[[SetData]], _next_)。
                1. 如果 _inThis_ 为 *true*，则
                  1. 注：因为 _other_ 是一个任意对象，其 *"keys"* 迭代器可能多次产生同一值。
                  1. 如果 SetDataHas(_resultSetData_, _next_) 为 *false*，则
                    1. 将 _next_ 追加到 _resultSetData_。
          1. 令 _result_ 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. 将 _result_.[[SetData]] 设为 _resultSetData_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.isdisjointfrom">
        <h1>Set.prototype.isDisjointFrom ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 如果 SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]]，则
            1. 令 _thisSize_ 为 _O_.[[SetData]] 中元素的数量。
            1. 令 _index_ 为 0。
            1. 当 _index_ &lt; _thisSize_ 重复，
              1. 令 _e_ 为 _O_.[[SetData]][_index_]。
              1. 将 _index_ 设为 _index_ + 1。
              1. 如果 _e_ 不是 ~empty~，则
                1. 令 _inOther_ 为 ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
                1. 如果 _inOther_ 为 *true*，返回 *false*。
                1. 注：执行 _otherRec_.[[Has]] 期间 _O_.[[SetData]] 中元素数量可能增加。
                1. 将 _thisSize_ 设为 _O_.[[SetData]] 中元素的数量。
          1. 否则，
            1. 令 _keysIter_ 为 ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
            1. 令 _next_ 为 ~not-started~。
            1. 当 _next_ 不是 ~done~ 重复，
              1. 将 _next_ 设为 ? IteratorStepValue(_keysIter_)。
              1. 如果 _next_ 不是 ~done~，则
                1. 如果 SetDataHas(_O_.[[SetData]], _next_) 为 *true*，则
                  1. 执行 ? IteratorClose(_keysIter_, NormalCompletion(~unused~))。
                  1. 返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issubsetof">
        <h1>Set.prototype.isSubsetOf ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 如果 SetDataSize(_O_.[[SetData]]) > _otherRec_.[[Size]]，返回 *false*。
          1. 令 _thisSize_ 为 _O_.[[SetData]] 中元素数量。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _thisSize_ 重复，
            1. 令 _e_ 为 _O_.[[SetData]][_index_]。
            1. 将 _index_ 设为 _index_ + 1。
            1. 如果 _e_ 不是 ~empty~，则
              1. 令 _inOther_ 为 ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »))。
              1. 如果 _inOther_ 为 *false*，返回 *false*。
              1. 注：执行 _otherRec_.[[Has]] 期间 _O_.[[SetData]] 中元素数量可能增加。
              1. 将 _thisSize_ 设为 _O_.[[SetData]] 中元素的数量。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issupersetof">
        <h1>Set.prototype.isSupersetOf ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 如果 SetDataSize(_O_.[[SetData]]) &lt; _otherRec_.[[Size]]，返回 *false*。
          1. 令 _keysIter_ 为 ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
          1. 令 _next_ 为 ~not-started~。
          1. 当 _next_ 不是 ~done~ 重复，
            1. 将 _next_ 设为 ? IteratorStepValue(_keysIter_)。
            1. 如果 _next_ 不是 ~done~，则
              1. 如果 SetDataHas(_O_.[[SetData]], _next_) 为 *false*，则
                1. 执行 ? IteratorClose(_keysIter_, NormalCompletion(~unused~))。
                1. 返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.keys">
        <h1>Set.prototype.keys ( )</h1>
        <p>*"keys"* 属性的初始值是 %Set.prototype.values%，定义见 <emu-xref href="#sec-set.prototype.values"></emu-xref>。</p>
        <emu-note>
          <p>在迭代语义上，Set 类似于每个条目键和值相同的 Map。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-set.prototype.size">
        <h1>get Set.prototype.size</h1>
        <p>`Set.prototype.size` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[SetData]])。
          1. 令 _size_ 为 SetDataSize(_S_.[[SetData]])。
          1. 返回 𝔽(_size_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.symmetricdifference">
        <h1>Set.prototype.symmetricDifference ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 令 _keysIter_ 为 ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
          1. 令 _resultSetData_ 为 _O_.[[SetData]] 的一个拷贝。
          1. 令 _next_ 为 ~not-started~。
          1. 当 _next_ 不是 ~done~ 重复，
            1. 将 _next_ 设为 ? IteratorStepValue(_keysIter_)。
            1. 如果 _next_ 不是 ~done~，则
              1. 将 _next_ 设为 CanonicalizeKeyedCollectionKey(_next_)。
              1. 令 _resultIndex_ 为 SetDataIndex(_resultSetData_, _next_)。
              1. 如果 _resultIndex_ 是 ~not-found~，令 _alreadyInResult_ 为 *false*；否则令其为 *true*。
              1. 如果 SetDataHas(_O_.[[SetData]], _next_) 为 *true*，则
                1. 如果 _alreadyInResult_ 为 *true*，将 _resultSetData_[_resultIndex_] 设为 ~empty~。
              1. 否则，
                1. 如果 _alreadyInResult_ 为 *false*，将 _next_ 追加到 _resultSetData_。
          1. 令 _result_ 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. 将 _result_.[[SetData]] 设为 _resultSetData_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.union">
        <h1>Set.prototype.union ( _other_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[SetData]])。
          1. 令 _otherRec_ 为 ? GetSetRecord(_other_)。
          1. 令 _keysIter_ 为 ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]])。
          1. 令 _resultSetData_ 为 _O_.[[SetData]] 的一个拷贝。
          1. 令 _next_ 为 ~not-started~。
          1. 当 _next_ 不是 ~done~ 重复，
            1. 将 _next_ 设为 ? IteratorStepValue(_keysIter_)。
            1. 如果 _next_ 不是 ~done~，则
              1. 将 _next_ 设为 CanonicalizeKeyedCollectionKey(_next_)。
              1. 如果 SetDataHas(_resultSetData_, _next_) 为 *false*，则
                1. 将 _next_ 追加到 _resultSetData_。
          1. 令 _result_ 为 OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »)。
          1. 将 _result_.[[SetData]] 设为 _resultSetData_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.values">
        <h1>Set.prototype.values ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateSetIterator(_S_, ~value~)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@iterator" id="sec-set.prototype-%symbol.iterator%">
        <h1>Set.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>%Symbol.iterator% 属性的初始值是 %Set.prototype.values%，定义见 <emu-xref href="#sec-set.prototype.values"></emu-xref>。</p>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@tostringtag" id="sec-set.prototype-%symbol.tostringtag%">
        <h1>Set.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Set"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-set-instances">
      <h1>Set 实例的属性</h1>
      <p>Set 实例是普通对象，从 Set 原型对象继承属性。Set 实例还具有 [[SetData]] 内部槽。</p>
    </emu-clause>

    <emu-clause id="sec-set-iterator-objects">
      <h1>Set 迭代器对象</h1>
      <p><dfn variants="Set Iterators,Set Iterator object,Set Iterator objects">Set Iterator</dfn> 是一个普通对象，结构如下，表示对某个特定 Set 实例对象的特定迭代。没有命名的 Set 迭代器构造函数。相反，通过调用某些 Set 实例对象的方法创建 Set 迭代器对象。</p>

      <emu-clause id="sec-createsetiterator" type="abstract operation" oldids="sec-properties-of-set-iterator-instances,table-51,table-internal-slots-of-set-iterator-instances">
        <h1>
          CreateSetIterator (
            _set_: an ECMAScript language value,
            _kind_: ~key+value~ or ~value~,
          ): 一个包含 Generator 的正常完成或抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于为返回此类迭代器的 Set 方法创建迭代器对象。</dd>
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_set_, [[SetData]])。
          1. 令 _closure_ 为一个无参数的新抽象闭包，捕获 _set_ 和 _kind_ 并在调用时执行：
            1. 令 _index_ 为 0。
            1. 令 _entries_ 为 _set_.[[SetData]]。
            1. 令 _numEntries_ 为 _entries_ 中元素的数量。
            1. 当 _index_ &lt; _numEntries_ 重复，
              1. 令 _e_ 为 _entries_[_index_]。
              1. 将 _index_ 设为 _index_ + 1。
              1. 如果 _e_ 不是 ~empty~，则
                1. 如果 _kind_ 是 ~key+value~，则
                  1. 令 _result_ 为 CreateArrayFromList(« _e_, _e_ »)。
                  1. 执行 ? GeneratorYield(CreateIteratorResultObject(_result_, *false*))。
                1. 否则，
                  1. 断言：_kind_ 是 ~value~。
                  1. 执行 ? GeneratorYield(CreateIteratorResultObject(_e_, *false*))。
                1. 注：在 GeneratorYield 暂停本抽象操作执行期间，_entries_ 中元素数量可能增加。
                1. 将 _numEntries_ 设为 _entries_ 中元素的数量。
            1. 返回 NormalCompletion(~unused~)。
          1. 返回 CreateIteratorFromClosure(_closure_, *"%SetIteratorPrototype%"*, %SetIteratorPrototype%)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%setiteratorprototype%-object">
        <h1>%SetIteratorPrototype% 对象</h1>
        <p><dfn>%SetIteratorPrototype%</dfn> 对象：</p>
        <ul>
          <li>具有所有 Set 迭代器对象继承的属性。</li>
          <li>是一个普通对象。</li>
          <li>有一个 [[Prototype]] 内部槽，其值为 %Iterator.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%setiteratorprototype%.next">
          <h1>%SetIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. 返回 ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%SetIteratorPrototype%"*)</emu-meta>。
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%setiteratorprototype%-@@tostringtag" id="sec-%setiteratorprototype%-%symbol.tostringtag%">
          <h1>%SetIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Set Iterator"*。</p>
          <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap 对象</h1>
    <p>WeakMap 是键/值对的集合，其中键是对象和/或符号，值可以是任意 ECMAScript 语言值。可以查询 WeakMap 是否包含具有特定键的键/值对，但没有枚举其持有键的机制。在特定条件下，非存活的值会作为 WeakMap 的键被移除，详见 <emu-xref href="#sec-weakref-execution"></emu-xref>。</p>
    <p>实现可以在 WeakMap 的键/值对变得不可访问与其被移除之间施加任意决定的延迟。若该延迟对 ECMAScript 程序可观察，将导致不确定性并影响程序执行。因此，实现不得提供任何不需要观察者出示被观察键就能观察 WeakMap 键的方式。</p>
    <p>WeakMap 必须使用哈希表或其他平均情况下提供次线性访问时间的机制实现。本规范使用的数据结构仅用于描述 WeakMap 所需的可观察语义，而非可行实现模型。</p>
    <emu-note>
      <p>WeakMap 和 WeakSet 旨在提供一种动态地将状态与对象或符号关联的机制，在没有 WeakMap 或 WeakSet 实例的情况下，如果对象或符号本来会变得不可访问并被实现的垃圾回收机制回收，这种机制不会“泄漏”内存资源。该特性可以通过使用按对象/符号反向映射 WeakMap 或 WeakSet 实例到键来实现。或者，每个 WeakMap 或 WeakSet 实例可以在内部存储其键和值数据，但这种方法需要 WeakMap 或 WeakSet 实现与垃圾回收器协同。以下参考文献描述的机制可能对 WeakMap 和 WeakSet 的实现有用：</p>
      <p>Barry Hayes. 1997. Ephemerons: a new finalization mechanism. 载于 <i>Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)</i>, A. Michael Berman (编). ACM, New York, NY, USA, 176-183, <a href="http://doi.acm.org/10.1145/263698.263733">http://doi.acm.org/10.1145/263698.263733</a>。</p>
      <p>Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, <a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak">http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak</a></p>
    </emu-note>

    <emu-clause id="sec-weakmap-constructor">
      <h1>WeakMap 构造函数</h1>
      <p>WeakMap 构造函数：</p>
      <ul>
        <li>是 <dfn>%WeakMap%</dfn>。</li>
        <li>是全局对象 *"WeakMap"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 WeakMap。</li>
        <li>不应作为普通函数调用；若以此方式调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。希望继承指定 WeakMap 行为的子类构造函数必须包含对 WeakMap 构造函数的 `super` 调用，以创建并初始化具有支持 `WeakMap.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <emu-clause id="sec-weakmap-iterable">
        <h1>WeakMap ( [ _iterable_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 令 _map_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakMap.prototype%"*, « [[WeakMapData]] »)。
          1. 将 _map_.[[WeakMapData]] 设为一个新的空 List。
          1. 如果 _iterable_ 是 *undefined* 或 *null*，返回 _map_。
          1. 令 _adder_ 为 ? Get(_map_, *"set"*)。
          1. 如果 IsCallable(_adder_) 为 *false*，抛出 *TypeError* 异常。
          1. 返回 ? AddEntriesFromIterable(_map_, _iterable_, _adder_)。
        </emu-alg>
        <emu-note>
          <p>如果参数 _iterable_ 存在，期望它是一个实现了 %Symbol.iterator% 方法的对象，迭代器返回的每个值是一个包含两个元素的类数组对象，第一个元素作为 WeakMap 键，第二个元素为与该键关联的值。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>WeakMap 构造函数的属性</h1>
      <p>WeakMap 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype">
        <h1>WeakMap.prototype</h1>
        <p>`WeakMap.prototype` 的初始值是 WeakMap 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-prototype-object">
      <h1>WeakMap 原型对象的属性</h1>
      <p><dfn>WeakMap 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%WeakMap.prototype%</dfn>。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[WeakMapData]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype.constructor">
        <h1>WeakMap.prototype.constructor</h1>
        <p>`WeakMap.prototype.constructor` 的初始值是 %WeakMap%。</p>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.delete">
        <h1>WeakMap.prototype.delete ( _key_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. 如果 CanBeHeldWeakly(_key_) 为 *false*，返回 *false*。
          1. 对 _M_.[[WeakMapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，则
              1. 将 _p_.[[Key]] 设为 ~empty~。
              1. 将 _p_.[[Value]] 设为 ~empty~。
              1. 返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>值 ~empty~ 用作规范设备指示条目已删除。实际实现可能物理移除该条目。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.get">
        <h1>WeakMap.prototype.get ( _key_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. 如果 CanBeHeldWeakly(_key_) 为 *false*，返回 *undefined*。
          1. 对 _M_.[[WeakMapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，返回 _p_.[[Value]]。
          1. 返回 *undefined*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.has">
        <h1>WeakMap.prototype.has ( _key_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. 如果 CanBeHeldWeakly(_key_) 为 *false*，返回 *false*。
          1. 对 _M_.[[WeakMapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.set">
        <h1>WeakMap.prototype.set ( _key_, _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _M_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_M_, [[WeakMapData]])。
          1. 如果 CanBeHeldWeakly(_key_) 为 *false*，抛出 *TypeError* 异常。
          1. 对 _M_.[[WeakMapData]] 中每个 Record { [[Key]], [[Value]] } _p_：
            1. 如果 _p_.[[Key]] 不是 ~empty~ 且 SameValue(_p_.[[Key]], _key_) 为 *true*，则
              1. 将 _p_.[[Value]] 设为 _value_。
              1. 返回 _M_。
          1. 令 _p_ 为记录 { [[Key]]: _key_, [[Value]]: _value_ }。
          1. 将 _p_ 追加到 _M_.[[WeakMapData]]。
          1. 返回 _M_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakmap.prototype-@@tostringtag" id="sec-weakmap.prototype-%symbol.tostringtag%">
        <h1>WeakMap.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"WeakMap"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakmap-instances">
      <h1>WeakMap 实例的属性</h1>
      <p>WeakMap 实例是普通对象，从 WeakMap 原型对象继承属性。WeakMap 实例还具有 [[WeakMapData]] 内部槽。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet 对象</h1>
    <p>WeakSet 是对象和/或符号的集合。一个特定对象或符号在 WeakSet 的集合中只能出现一次。可以查询 WeakSet 是否包含一个特定值，但没有枚举其持有值的机制。在特定条件下，非存活的值会作为 WeakSet 元素被移除，详见 <emu-xref href="#sec-weakref-execution"></emu-xref>。</p>
    <p>实现可以在 WeakSet 中的一个值变得不可访问与其被移除之间施加任意决定的延迟。若该延迟对 ECMAScript 程序可观察，将导致不确定性并影响程序执行。因此，实现不得提供不需要观察者出示被观察值就能判断 WeakSet 是否包含该值的方式。</p>
    <p>WeakSet 必须使用哈希表或其他平均情况下提供次线性访问时间的机制实现。本规范使用的数据结构仅用于描述 WeakSet 所需的可观察语义，并非可行实现模型。</p>
    <emu-note>
      <p>参见 <emu-xref href="#sec-weakmap-objects"></emu-xref> 中的注。</p>
    </emu-note>

    <emu-clause id="sec-weakset-constructor">
      <h1>WeakSet 构造函数</h1>
      <p>WeakSet 构造函数：</p>
      <ul>
        <li>是 <dfn>%WeakSet%</dfn>。</li>
        <li>是全局对象 *"WeakSet"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 WeakSet。</li>
        <li>不应作为普通函数调用；若以此方式调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。希望继承指定 WeakSet 行为的子类构造函数必须包含对 WeakSet 构造函数的 `super` 调用，以创建并初始化具有支持 `WeakSet.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <emu-clause id="sec-weakset-iterable">
        <h1>WeakSet ( [ _iterable_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 令 _set_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakSet.prototype%"*, « [[WeakSetData]] »)。
          1. 将 _set_.[[WeakSetData]] 设为一个新的空 List。
          1. 如果 _iterable_ 是 *undefined* 或 *null*，返回 _set_。
          1. 令 _adder_ 为 ? Get(_set_, *"add"*)。
          1. 如果 IsCallable(_adder_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _iteratorRecord_ 为 ? GetIterator(_iterable_, ~sync~)。
          1. 重复，
            1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
            1. 如果 _next_ 是 ~done~，返回 _set_。
            1. 令 _status_ 为 Completion(Call(_adder_, _set_, « _next_ »))。
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>WeakSet 构造函数的属性</h1>
      <p>WeakSet 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-weakset.prototype">
        <h1>WeakSet.prototype</h1>
        <p>`WeakSet.prototype` 的初始值是 WeakSet 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-prototype-object">
      <h1>WeakSet 原型对象的属性</h1>
      <p><dfn>WeakSet 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%WeakSet.prototype%</dfn>。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[WeakSetData]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-weakset.prototype.add">
        <h1>WeakSet.prototype.add ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[WeakSetData]])。
          1. 如果 CanBeHeldWeakly(_value_) 为 *false*，抛出 *TypeError* 异常。
          1. 对 _S_.[[WeakSetData]] 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~ 且 SameValue(_e_, _value_) 为 *true*，则
              1. 返回 _S_。
          1. 将 _value_ 追加到 _S_.[[WeakSetData]]。
          1. 返回 _S_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.constructor">
        <h1>WeakSet.prototype.constructor</h1>
        <p>`WeakSet.prototype.constructor` 的初始值是 %WeakSet%。</p>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.delete">
        <h1>WeakSet.prototype.delete ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[WeakSetData]])。
          1. 如果 CanBeHeldWeakly(_value_) 为 *false*，返回 *false*。
          1. 对 _S_.[[WeakSetData]] 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~ 且 SameValue(_e_, _value_) 为 *true*，则
              1. 用值为 ~empty~ 的元素替换 _S_.[[WeakSetData]] 中值为 _e_ 的元素。
              1. 返回 *true*。
          1. 返回 *false*。
        </emu-alg>
        <emu-note>
          <p>值 ~empty~ 用作规范设备指示条目已删除。实际实现可能物理移除该条目。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.has">
        <h1>WeakSet.prototype.has ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_S_, [[WeakSetData]])。
          1. 如果 CanBeHeldWeakly(_value_) 为 *false*，返回 *false*。
          1. 对 _S_.[[WeakSetData]] 中每个元素 _e_：
            1. 如果 _e_ 不是 ~empty~ 且 SameValue(_e_, _value_) 为 *true*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakset.prototype-@@tostringtag" id="sec-weakset.prototype-%symbol.tostringtag%">
        <h1>WeakSet.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"WeakSet"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakset-instances">
      <h1>WeakSet 实例的属性</h1>
      <p>WeakSet 实例是普通对象，从 WeakSet 原型对象继承属性。WeakSet 实例还具有 [[WeakSetData]] 内部槽。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-keyed-collections">
    <h1>键控集合的抽象操作</h1>

    <emu-clause id="sec-canonicalizekeyedcollectionkey" type="abstract operation">
      <h1>
        CanonicalizeKeyedCollectionKey (
          _key_: an ECMAScript language value,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _key_ 是 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 返回 _key_。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>结构化数据（Structured Data）</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer 对象</h1>

    <emu-clause id="sec-arraybuffer-notation">
      <h1>记号（Notation）</h1>
      <p>本小节、<emu-xref href="#sec-atomics-object"></emu-xref> 以及 <emu-xref href="#sec-memory-model"></emu-xref> 中的下述描述使用 “读-改-写 修改函数（read-modify-write modification function）” 内部数据结构。</p>
      <p><dfn variants="read-modify-write modification functions">读-改-写 修改函数</dfn> 是一种数学函数，以抽象闭包形式表示，接受两个字节值的 List 作为参数并返回一个字节值的 List。这些抽象闭包满足以下全部性质：</p>
      <ul>
        <li>它们以原子方式执行其全部算法步骤。</li>
        <li>其各个算法步骤不可被观察。</li>
      </ul>
      <emu-note>
        <p>为帮助验证读-改-写 修改函数的算法步骤构成一个纯粹的数学函数，建议遵循以下编辑约定：</p>
        <ul>
          <li>除其参数与捕获的值外，不直接或经由被调用的抽象操作与抽象闭包传递性访问任何语言或规范值。</li>
          <li>不直接或传递性调用返回 Completion Record 的抽象操作与抽象闭包。</li>
          <li>不返回 Completion Record。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-fixed-length-and-resizable-arraybuffer-objects">
      <h1>固定长度与可调整大小（Resizable）的 ArrayBuffer 对象</h1>
      <p><dfn>固定长度 ArrayBuffer（fixed-length ArrayBuffer）</dfn> 是创建后其字节长度不可改变的 ArrayBuffer。</p>
      <p><dfn>可调整大小 ArrayBuffer（resizable ArrayBuffer）</dfn> 是创建后其字节长度可通过调用 <emu-xref href="#sec-arraybuffer.prototype.resize" title></emu-xref> 改变的 ArrayBuffer。</p>
      <p>创建何种 ArrayBuffer 对象取决于传递给 <emu-xref href="#sec-arraybuffer-length" title></emu-xref> 的参数。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-arraybuffer-objects">
      <h1>ArrayBuffer 对象的抽象操作</h1>

      <emu-clause id="sec-allocatearraybuffer" type="abstract operation">
        <h1>
          AllocateArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): 要么是包含一个 ArrayBuffer 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于创建一个 ArrayBuffer。</dd>
        </dl>
        <emu-alg>
          1. 令 _slots_ 为 « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] »。
          1. 如果存在 _maxByteLength_ 且其不为 ~empty~，令 _allocatingResizableBuffer_ 为 *true*；否则令其为 *false*。
          1. 若 _allocatingResizableBuffer_ 为 *true*，则
            1. 若 _byteLength_ > _maxByteLength_，抛出 *RangeError* 异常。
            1. 将 [[ArrayBufferMaxByteLength]] 追加到 _slots_。
          1. 令 _obj_ 为 ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, _slots_)。
          1. 令 _block_ 为 ? CreateByteDataBlock(_byteLength_)。
          1. 设 _obj_.[[ArrayBufferData]] 为 _block_。
          1. 设 _obj_.[[ArrayBufferByteLength]] 为 _byteLength_。
          1. 若 _allocatingResizableBuffer_ 为 *true*，则
            1. 若无法创建一个由 _maxByteLength_ 个字节组成的 Data Block _block_，抛出 *RangeError* 异常。
            1. 注：可调整大小 ArrayBuffer 设计为可原地增长。实现可在例如无法预先保留虚拟内存时抛出。
            1. 设 _obj_.[[ArrayBufferMaxByteLength]] 为 _maxByteLength_。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybufferbytelength" type="abstract operation">
        <h1>
          ArrayBufferByteLength (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _order_: ~seq-cst~ or ~unordered~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsSharedArrayBuffer(_arrayBuffer_) 为 *true* 且 _arrayBuffer_ 具有内部槽 [[ArrayBufferByteLengthData]]，则
            1. 令 _bufferByteLengthBlock_ 为 _arrayBuffer_.[[ArrayBufferByteLengthData]]。
            1. 令 _rawLength_ 为 GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_)。
            1. 令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段的值。
            1. 返回 ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_))。
          1. 断言：IsDetachedBuffer(_arrayBuffer_) 为 *false*。
          1. 返回 _arrayBuffer_.[[ArrayBufferByteLength]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffercopyanddetach" type="abstract operation">
        <h1>
          ArrayBufferCopyAndDetach (
            _arrayBuffer_: an ECMAScript language value,
            _newLength_: an ECMAScript language value,
            _preserveResizability_: ~preserve-resizability~ or ~fixed-length~,
          ): 要么是包含一个 ArrayBuffer 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_arrayBuffer_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 _newLength_ 为 *undefined*，则
            1. 令 _newByteLength_ 为 _arrayBuffer_.[[ArrayBufferByteLength]]。
          1. 否则，
            1. 令 _newByteLength_ 为 ? ToIndex(_newLength_)。
          1. 若 IsDetachedBuffer(_arrayBuffer_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 _preserveResizability_ 为 ~preserve-resizability~ 且 IsFixedLengthArrayBuffer(_arrayBuffer_) 为 *false*，则
            1. 令 _newMaxByteLength_ 为 _arrayBuffer_.[[ArrayBufferMaxByteLength]]。
          1. 否则，
            1. 令 _newMaxByteLength_ 为 ~empty~。
          1. 若 _arrayBuffer_.[[ArrayBufferDetachKey]] 不为 *undefined*，抛出 *TypeError* 异常。
          1. 令 _newBuffer_ 为 ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta>。
          1. 令 _copyLength_ 为 min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]])。
          1. 令 _fromBlock_ 为 _arrayBuffer_.[[ArrayBufferData]]。
          1. 令 _toBlock_ 为 _newBuffer_.[[ArrayBufferData]]。
          1. 执行 CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_)。
          1. 注：新旧 Data Block 的创建与拷贝均不可观察。实现可用零拷贝移动或 `realloc`。
          1. 执行 ! DetachArrayBuffer(_arrayBuffer_)。
          1. 返回 _newBuffer_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdetachedbuffer" type="abstract operation">
        <h1>
          IsDetachedBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _arrayBuffer_.[[ArrayBufferData]] 为 *null*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-detacharraybuffer" type="abstract operation">
        <h1>
          DetachArrayBuffer (
            _arrayBuffer_: an ArrayBuffer,
            optional _key_: anything,
          ): 要么是包含 ~unused~ 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>skip global checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. 断言：IsSharedArrayBuffer(_arrayBuffer_) 为 *false*。
          1. 若 _key_ 不存在，设 _key_ 为 *undefined*。
          1. 若 _arrayBuffer_.[[ArrayBufferDetachKey]] 不为 _key_，抛出 *TypeError* 异常。
          1. 设 _arrayBuffer_.[[ArrayBufferData]] 为 *null*。
          1. 设 _arrayBuffer_.[[ArrayBufferByteLength]] 为 0。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-note>
          <p>分离一个 ArrayBuffer 实例会将其用作后备存储的 Data Block 与该实例解除关联，并将其字节长度设为 0。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-clonearraybuffer" type="abstract operation">
        <h1>
          CloneArrayBuffer (
            _srcBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _srcByteOffset_: a non-negative integer,
            _srcLength_: a non-negative integer,
          ): 要么是包含一个 ArrayBuffer 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>创建一个新的 ArrayBuffer，其数据为 _srcBuffer_ 从 _srcByteOffset_ 起 _srcLength_ 字节范围内数据的拷贝。</dd>
        </dl>
        <emu-alg>
          1. 断言：IsDetachedBuffer(_srcBuffer_) 为 *false*。
          1. 令 _targetBuffer_ 为 ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta>。
          1. 令 _srcBlock_ 为 _srcBuffer_.[[ArrayBufferData]]。
          1. 令 _targetBlock_ 为 _targetBuffer_.[[ArrayBufferData]]。
          1. 执行 CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_)。
          1. 返回 _targetBuffer_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
        <h1>
          GetArrayBufferMaxByteLengthOption (
            _options_: an ECMAScript language value,
          ): 要么是包含非负整数或 ~empty~ 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _options_ 不是 Object，返回 ~empty~。
          1. 令 _maxByteLength_ 为 ? Get(_options_, *"maxByteLength"*)。
          1. 若 _maxByteLength_ 为 *undefined*，返回 ~empty~。
          1. 返回 ? ToIndex(_maxByteLength_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation">
        <h1>
          HostResizeArrayBuffer (
            _buffer_: an ArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): 要么是包含 ~handled~ 或 ~unhandled~ 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>给予宿主机会对 _buffer_ 进行实现自定义的调整大小。若宿主选择不处理，可返回 ~unhandled~ 以使用默认行为。</dd>
        </dl>

        <p>HostResizeArrayBuffer 的实现必须符合以下要求：</p>
        <ul>
          <li>该抽象操作不会分离 _buffer_。</li>
          <li>若正常完成并返回 ~handled~，则 _buffer_.[[ArrayBufferByteLength]] 为 _newByteLength_。</li>
        </ul>

        <p>默认实现返回 NormalCompletion(~unhandled~)。</p>
      </emu-clause>

      <emu-clause id="sec-isfixedlengtharraybuffer" type="abstract operation">
        <h1>
          IsFixedLengthArrayBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _arrayBuffer_ 具有内部槽 [[ArrayBufferMaxByteLength]]，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunsignedelementtype" type="abstract operation">
        <h1>
          IsUnsignedElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>验证参数 _type_ 是否为无符号的 TypedArray 元素类型。</dd>
        </dl>
        <emu-alg>
          1. 若 _type_ 是 ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, 或 ~biguint64~ 之一，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunclampedintegerelementtype" type="abstract operation">
        <h1>
          IsUnclampedIntegerElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>验证参数 _type_ 是否为不包含 ~uint8clamped~ 的整数 TypedArray 元素类型。</dd>
        </dl>
        <emu-alg>
          1. 若 _type_ 是 ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, 或 ~uint32~ 之一，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isbigintelementtype" type="abstract operation">
        <h1>
          IsBigIntElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>验证参数 _type_ 是否为 BigInt TypedArray 元素类型。</dd>
        </dl>
        <emu-alg>
          1. 若 _type_ 为 ~biguint64~ 或 ~bigint64~，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isnotearconfiguration" type="abstract operation">
        <h1>
          IsNoTearConfiguration (
            _type_: a TypedArray element type,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsUnclampedIntegerElementType(_type_) 为 *true*，返回 *true*。
          1. 若 IsBigIntElementType(_type_) 为 *true* 且 _order_ 既不是 ~init~ 也不是 ~unordered~，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rawbytestonumeric" type="abstract operation" oldids="sec-rawbytestonumber">
        <h1>
          RawBytesToNumeric (
            _type_: a TypedArray element type,
            _rawBytes_: a List of byte values,
            _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 指定的元素大小值。
          1. 若 _isLittleEndian_ 为 *false*，反转 _rawBytes_ 的元素顺序。
          1. 若 _type_ 为 ~float16~，则
            1. 令 _value_ 为将 _rawBytes_ 字节元素拼接并按 IEEE 754-2019 binary16 小端位串编码解释的结果。
            1. 若 _value_ 是 NaN，返回 *NaN*。
            1. 返回与 _value_ 对应的 Number 值。
          1. 若 _type_ 为 ~float32~，则
            1. 同上以 binary32 方式处理。
          1. 若 _type_ 为 ~float64~，则
            1. 同上以 binary64 方式处理。
          1. 若 IsUnsignedElementType(_type_) 为 *true*，则
            1. 令 _intValue_ 为 _rawBytes_ 按小端无符号二进制数的位串编码解释的结果。
          1. 否则，
            1. 令 _intValue_ 为 _rawBytes_ 按小端二补数、位长 _elementSize_ × 8 的位串编码解释的结果。
          1. 若 IsBigIntElementType(_type_) 为 *true*，返回与 _intValue_ 对应的 BigInt。
          1. 否则，返回与 _intValue_ 对应的 Number。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getrawbytesfromsharedblock" type="abstract operation">
        <h1>
          GetRawBytesFromSharedBlock (
            _block_: a Shared Data Block,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 指定的元素大小值。
          1. 令 _execution_ 为外层 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
          1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
          1. 若 _isTypedArray_ 为 *true* 且 IsNoTearConfiguration(_type_, _order_) 为 *true*，令 _noTear_ 为 *true*；否则为 *false*。
          1. 令 _rawValue_ 为长度 _elementSize_、元素为非确定性选择字节值的 List。
          1. 注：在实现中，_rawValue_ 是底层硬件非原子或原子读取指令的结果；该非确定性是内存模型对弱一致硬件可观察行为的语义规定。
          1. 令 _readEvent_ 为 ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }。
          1. 将 _readEvent_ 追加到 _eventsRecord_.[[EventList]]。
          1. 将 Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } 追加到 _execution_.[[ChosenValues]]。
          1. 返回 _rawValue_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvaluefrombuffer" type="abstract operation">
        <h1>
          GetValueFromBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
            optional _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsDetachedBuffer(_arrayBuffer_) 为 *false*。
          1. 断言：_arrayBuffer_ 中自 _byteIndex_ 起有足够字节表示 _type_ 的一个值。
          1. 令 _block_ 为 _arrayBuffer_.[[ArrayBufferData]]。
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 的元素大小值。
          1. 若 IsSharedArrayBuffer(_arrayBuffer_) 为 *true*，则
            1. 断言：_block_ 为 Shared Data Block。
            1. 令 _rawValue_ 为 GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_)。
          1. 否则，
            1. 令 _rawValue_ 为 _block_ 中索引区间 [_byteIndex_, _byteIndex_ + _elementSize_) 的字节组成的 List。
          1. 断言：_rawValue_ 元素个数为 _elementSize_。
          1. 若 _isLittleEndian_ 不存在，设其为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段值。
          1. 返回 RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numerictorawbytes" type="abstract operation" oldids="sec-numbertorawbytes">
        <h1>
          NumericToRawBytes (
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isLittleEndian_: a Boolean,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _type_ 为 ~float16~，则
            1. 令 _rawBytes_ 为长度 2 的 List，为将 _value_ 以 roundTiesToEven 模式转换为 IEEE 754-2019 binary16 格式的结果字节（小端序）。若 _value_ 为 *NaN*，_rawBytes_ 可为实现选择的任一 binary16 NaN 编码；实现对每个可区分 *NaN* 必须始终选择同一编码。
          1. Else if _type_ 为 ~float32~，同理生成 4 字节（binary32）。
          1. Else if _type_ 为 ~float64~，同理生成 8 字节（binary64）。
          1. 否则，
            1. 令 _n_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 的元素大小值。
            1. 令 _conversionOperation_ 为同表中该元素类型的 Conversion Operation 列命名的抽象操作。
            1. 令 _intValue_ 为 ℝ(! _conversionOperation_(_value_))。
            1. 若 _intValue_ ≥ 0，则
              1. 令 _rawBytes_ 为按小端序排列的 _intValue_ 的 _n_ 字节二进制编码。
            1. 否则，
              1. 令 _rawBytes_ 为按小端序排列的 _intValue_ 的 _n_ 字节二进制二补数编码。
          1. 若 _isLittleEndian_ 为 *false*，反转 _rawBytes_ 的元素顺序。
          1. 返回 _rawBytes_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setvalueinbuffer" type="abstract operation">
        <h1>
          SetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
            optional _isLittleEndian_: a Boolean,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsDetachedBuffer(_arrayBuffer_) 为 *false*。
          1. 断言：_arrayBuffer_ 中自 _byteIndex_ 起有足够字节表示 _type_ 的一个值。
          1. 断言：若 IsBigIntElementType(_type_) 为 *true*，_value_ 为 BigInt；否则为 Number。
          1. 令 _block_ 为 _arrayBuffer_.[[ArrayBufferData]]。
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 的元素大小值。
          1. 若 _isLittleEndian_ 不存在，设其为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段值。
          1. 令 _rawBytes_ 为 NumericToRawBytes(_type_, _value_, _isLittleEndian_)。
          1. 若 IsSharedArrayBuffer(_arrayBuffer_) 为 *true*，则
            1. 令 _execution_ 为外层 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
            1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
            1. 若 _isTypedArray_ 为 *true* 且 IsNoTearConfiguration(_type_, _order_) 为 *true*，令 _noTear_ 为 *true*；否则为 *false*。
            1. 将 WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } 追加到 _eventsRecord_.[[EventList]]。
          1. 否则，
            1. 将 _rawBytes_ 的各字节存入 _block_，起始于 _block_[_byteIndex_]。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" type="abstract operation">
        <h1>
          GetModifySetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _op_: a read-modify-write modification function,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsDetachedBuffer(_arrayBuffer_) 为 *false*。
          1. 断言：_arrayBuffer_ 中自 _byteIndex_ 起有足够字节表示 _type_ 的一个值。
          1. 断言：若 IsBigIntElementType(_type_) 为 *true*，_value_ 为 BigInt；否则为 Number。
          1. 令 _block_ 为 _arrayBuffer_.[[ArrayBufferData]]。
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 的元素大小值。
          1. 令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段值。
          1. 令 _rawBytes_ 为 NumericToRawBytes(_type_, _value_, _isLittleEndian_)。
          1. 若 IsSharedArrayBuffer(_arrayBuffer_) 为 *true*，则
            1. 令 _execution_ 为外层 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
            1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
            1. 令 _rawBytesRead_ 为长度 _elementSize_、元素为非确定性选择字节值的 List。
            1. 注：在实现中，_rawBytesRead_ 来自底层硬件的 load-link、load-exclusive 或读-改-写指令操作数；非确定性用于描述弱一致硬件的可观察行为。
            1. 令 _rmwEvent_ 为 ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }。
            1. 将 _rmwEvent_ 追加到 _eventsRecord_.[[EventList]]。
            1. 将 Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } 追加到 _execution_.[[ChosenValues]]。
          1. 否则，
            1. 令 _rawBytesRead_ 为长度 _elementSize_ 的 List，其元素为自 _block_[_byteIndex_] 起的 _elementSize_ 个字节。
            1. 令 _rawBytesModified_ 为 _op_(_rawBytesRead_, _rawBytes_)。
            1. 将 _rawBytesModified_ 的字节存入 _block_，起始于 _block_[_byteIndex_]。
          1. 返回 RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arraybuffer-constructor">
      <h1>ArrayBuffer 构造函数</h1>
      <p>ArrayBuffer 构造函数：</p>
      <ul>
        <li>是 <dfn>%ArrayBuffer%</dfn>。</li>
        <li>是全局对象 *"ArrayBuffer"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 ArrayBuffer。</li>
        <li>不应作为函数调用；若如此调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。继承该指定行为的子类构造函数必须在内部包含对 ArrayBuffer 构造函数的 `super` 调用，以创建并初始化具有支持 `ArrayBuffer.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <emu-clause id="sec-arraybuffer-length">
        <h1>ArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 NewTarget 为 *undefined*，抛出 *TypeError* 异常。
          1. 令 _byteLength_ 为 ? ToIndex(_length_)。
          1. 令 _requestedMaxByteLength_ 为 ? GetArrayBufferMaxByteLengthOption(_options_)。
          1. 返回 ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>ArrayBuffer 构造函数的属性</h1>
      <p>ArrayBuffer 构造函数：</p>
      <ul>
        <li>有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-arraybuffer.isview">
        <h1>ArrayBuffer.isView ( _arg_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 _arg_ 不是 Object，返回 *false*。
          1. 若 _arg_ 具有内部槽 [[ViewedArrayBuffer]]，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype">
        <h1>ArrayBuffer.prototype</h1>
        <p>`ArrayBuffer.prototype` 的初始值是 ArrayBuffer 原型对象。</p>
        <p>该属性的特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-get-arraybuffer-@@species" id="sec-get-arraybuffer-%symbol.species%">
        <h1>get ArrayBuffer [ %Symbol.species% ]</h1>
        <p>`ArrayBuffer[%Symbol.species%]` 是一个存取器属性，其 set 访问器为 *undefined*。其 get 访问器被调用时执行：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数 *"name"* 属性的值为 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p><emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> 通常使用其 *this* 值的构造函数创建派生对象。然而，子类构造函数可通过重定义其 %Symbol.species% 属性来覆盖该方法（<emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref>）的默认行为。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>ArrayBuffer 原型对象的属性</h1>
      <p><dfn>ArrayBuffer 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%ArrayBuffer.prototype%</dfn>。</li>
        <li>有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是普通对象。</li>
        <li>没有 [[ArrayBufferData]] 或 [[ArrayBufferByteLength]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength</h1>
        <p>`ArrayBuffer.prototype.byteLength` 是一个存取器属性，其 set 访问器为 *undefined*。其 get 访问器被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsDetachedBuffer(_O_) 为 *true*，返回 *+0*<sub>𝔽</sub>。
          1. 令 _length_ 为 _O_.[[ArrayBufferByteLength]]。
          1. 返回 𝔽(_length_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.constructor">
        <h1>ArrayBuffer.prototype.constructor</h1>
        <p>`ArrayBuffer.prototype.constructor` 的初始值是 %ArrayBuffer%。</p>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.detached">
        <h1>get ArrayBuffer.prototype.detached</h1>
        <p>`ArrayBuffer.prototype.detached` 是一个存取器属性，其 set 访问器为 *undefined*。其 get 访问器被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 返回 IsDetachedBuffer(_O_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
        <h1>get ArrayBuffer.prototype.maxByteLength</h1>
        <p>`ArrayBuffer.prototype.maxByteLength` 是一个存取器属性，其 set 访问器为 *undefined*。其 get 访问器被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsDetachedBuffer(_O_) 为 *true*，返回 *+0*<sub>𝔽</sub>。
          1. 若 IsFixedLengthArrayBuffer(_O_) 为 *true*，则
            1. 令 _length_ 为 _O_.[[ArrayBufferByteLength]]。
          1. 否则，
            1. 令 _length_ 为 _O_.[[ArrayBufferMaxByteLength]]。
          1. 返回 𝔽(_length_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.resizable">
        <h1>get ArrayBuffer.prototype.resizable</h1>
        <p>`ArrayBuffer.prototype.resizable` 是一个存取器属性，其 set 访问器为 *undefined*。其 get 访问器被调用时执行：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsFixedLengthArrayBuffer(_O_) 为 *false*，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.resize">
        <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _newByteLength_ 为 ? ToIndex(_newLength_)。
          1. 若 IsDetachedBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]]，抛出 *RangeError* 异常。
          1. 令 _hostHandled_ 为 ? HostResizeArrayBuffer(_O_, _newByteLength_)。
          1. 若 _hostHandled_ 为 ~handled~，返回 *undefined*。
          1. 令 _oldBlock_ 为 _O_.[[ArrayBufferData]]。
          1. 令 _newBlock_ 为 ? CreateByteDataBlock(_newByteLength_)。
          1. 令 _copyLength_ 为 min(_newByteLength_, _O_.[[ArrayBufferByteLength]])。
          1. 执行 CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_)。
          1. 注：新 Data Block 的创建与旧 Data Block 的拷贝均不可观察。实现可原地增长或收缩。
          1. 设 _O_.[[ArrayBufferData]] 为 _newBlock_。
          1. 设 _O_.[[ArrayBufferByteLength]] 为 _newByteLength_。
          1. 返回 *undefined*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsDetachedBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _len_ 为 _O_.[[ArrayBufferByteLength]]。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _first_ 为 0。
          1. Else if _relativeStart_ &lt; 0，令 _first_ 为 max(_len_ + _relativeStart_, 0)。
          1. Else，令 _first_ 为 min(_relativeStart_, _len_)。
          1. 若 _end_ 为 *undefined*，令 _relativeEnd_ 为 _len_；否则令 _relativeEnd_ 为 ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，令 _final_ 为 0。
          1. Else if _relativeEnd_ &lt; 0，令 _final_ 为 max(_len_ + _relativeEnd_, 0)。
          1. Else，令 _final_ 为 min(_relativeEnd_, _len_)。
          1. 令 _newLen_ 为 max(_final_ - _first_, 0)。
          1. 令 _ctor_ 为 ? SpeciesConstructor(_O_, %ArrayBuffer%)。
          1. 令 _new_ 为 ? Construct(_ctor_, « 𝔽(_newLen_) »)。
          1. 执行 ? RequireInternalSlot(_new_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_new_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsDetachedBuffer(_new_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 SameValue(_new_, _O_) 为 *true*，抛出 *TypeError* 异常。
          1. 若 _new_.[[ArrayBufferByteLength]] &lt; _newLen_，抛出 *TypeError* 异常。
          1. 注：以上步骤的副作用可能已分离或调整 _O_ 大小。
          1. 若 IsDetachedBuffer(_O_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _fromBuf_ 为 _O_.[[ArrayBufferData]]。
          1. 令 _toBuf_ 为 _new_.[[ArrayBufferData]]。
          1. 令 _currentLen_ 为 _O_.[[ArrayBufferByteLength]]。
          1. 若 _first_ &lt; _currentLen_，则
            1. 令 _count_ 为 min(_newLen_, _currentLen_ - _first_)。
            1. 执行 CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_)。
          1. 返回 _new_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfer">
        <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 返回 ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfertofixedlength">
        <h1>ArrayBuffer.prototype.transferToFixedLength ( [ _newLength_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 返回 ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-arraybuffer.prototype-@@tostringtag" id="sec-arraybuffer.prototype-%symbol.tostringtag%">
        <h1>ArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值为字符串 *"ArrayBuffer"*。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-instances">
      <h1>ArrayBuffer 实例的属性</h1>
      <p>ArrayBuffer 实例从 ArrayBuffer 原型对象继承属性。每个实例都有 [[ArrayBufferData]]、[[ArrayBufferByteLength]] 与 [[ArrayBufferDetachKey]] 内部槽。可调整大小的实例还具有 [[ArrayBufferMaxByteLength]] 内部槽。</p>
      <p>[[ArrayBufferData]] 为 *null* 的 ArrayBuffer 实例被视为已分离，对其数据的访问或修改操作均会失败。</p>
      <p>[[ArrayBufferDetachKey]] 设为非 *undefined* 值的 ArrayBuffer 实例，在所有 DetachArrayBuffer 调用中必须传递相同的 “detach key” 作为参数，否则将产生 TypeError。该内部槽仅由某些嵌入环境设置，而非本规范算法。</p>
    </emu-clause>

    <emu-clause id="sec-resizable-arraybuffer-guidelines">
      <h1>可调整大小 ArrayBuffer 指南</h1>
      <emu-note>
        <p>以下是供 ECMAScript 程序员在使用可调整大小 ArrayBuffer 时的指南。</p>
        <p>建议在部署环境中（如果可能）对程序进行测试。不同硬件设备的可用物理内存差异很大；虚拟内存子系统也因硬件设备与操作系统不同而差异明显。一个在 64 位桌面浏览器中无内存不足错误的应用，可能在 32 位移动浏览器中耗尽内存。</p>
        <p>为可调整大小 ArrayBuffer 选择 *"maxByteLength"* 选项值时，建议选择应用所需的最小可能值。建议 *"maxByteLength"* 不超过 1,073,741,824（2<sup>30</sup> 字节或 1GiB）。</p>
        <p>请注意：成功构造一个指定最大值的可调整大小 ArrayBuffer 并不保证未来的扩展一定成功。</p>
      </emu-note>

      <emu-note>
        <p>以下是供实现可调整大小 ArrayBuffer 的 ECMAScript 实现者的指南。</p>
        <p>Resizable ArrayBuffer 可实现为在调整时复制、通过预留虚拟内存的原地增长、或针对构造函数 *"maxByteLength"* 选项不同取值的上述方案组合。</p>
        <p>若宿主是多租户（同时运行许多 ECMAScript 应用），例如 Web 浏览器，并选择通过预留虚拟内存实现原地增长，建议 32 位与 64 位实现对 *"maxByteLength"* ≥ 1GiB 到 1.5GiB 的值抛出异常。其目的是减少单一应用耗尽虚拟地址空间的可能性并降低互操作风险。</p>
        <p>若宿主无虚拟内存（例如无 MMU 的嵌入式设备），或宿主仅通过复制实现调整大小，则可接受 *"maxByteLength"* 选项的任意 <emu-not-ref>Number value for</emu-not-ref> 值。然而，建议当请求的大小永远无法分配时抛出 *RangeError*。例如请求大小大于设备可用的最大可用内存时。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer 对象</h1>

    <emu-clause id="sec-fixed-length-and-growable-sharedarraybuffer-objects">
      <h1>固定长度与可增长的 SharedArrayBuffer 对象</h1>
      <p><dfn>固定长度 SharedArrayBuffer</dfn> 是创建后其字节长度不可改变的 SharedArrayBuffer。</p>
      <p><dfn>可增长 SharedArrayBuffer</dfn> 是创建后其字节长度可通过调用 <emu-xref href="#sec-sharedarraybuffer.prototype.grow" title></emu-xref> 增加的 SharedArrayBuffer。</p>
      <p>创建哪种 SharedArrayBuffer 对象取决于传递给 <emu-xref href="#sec-sharedarraybuffer-length" title></emu-xref> 的参数。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects">
      <h1>SharedArrayBuffer 对象的抽象操作</h1>

      <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation">
        <h1>
          AllocateSharedArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): 要么是包含一个 SharedArrayBuffer 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于创建一个 SharedArrayBuffer。</dd>
        </dl>
        <emu-alg>
          1. 令 _slots_ 为 « [[ArrayBufferData]] »。
          1. 若存在 _maxByteLength_ 且其不为 ~empty~，令 _allocatingGrowableBuffer_ 为 *true*；否则令其为 *false*。
          1. 若 _allocatingGrowableBuffer_ 为 *true*，则
            1. 若 _byteLength_ > _maxByteLength_，抛出 *RangeError* 异常。
            1. 将 [[ArrayBufferByteLengthData]] 与 [[ArrayBufferMaxByteLength]] 追加到 _slots_。
          1. 否则，
            1. 将 [[ArrayBufferByteLength]] 追加到 _slots_。
          1. 令 _obj_ 为 ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, _slots_)。
          1. 若 _allocatingGrowableBuffer_ 为 *true*，令 _allocLength_ 为 _maxByteLength_；否则令 _allocLength_ 为 _byteLength_。
          1. 令 _block_ 为 ? CreateSharedByteDataBlock(_allocLength_)。
          1. 设 _obj_.[[ArrayBufferData]] 为 _block_。
          1. 若 _allocatingGrowableBuffer_ 为 *true*，则
            1. 断言：_byteLength_ ≤ _maxByteLength_。
            1. 令 _byteLengthBlock_ 为 ? CreateSharedByteDataBlock(8)。
            1. 执行 SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~)。
            1. 设 _obj_.[[ArrayBufferByteLengthData]] 为 _byteLengthBlock_。
            1. 设 _obj_.[[ArrayBufferMaxByteLength]] 为 _maxByteLength_。
          1. 否则，
            1. 设 _obj_.[[ArrayBufferByteLength]] 为 _byteLength_。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issharedarraybuffer" type="abstract operation">
        <h1>
          IsSharedArrayBuffer (
            _obj_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>测试一个对象是否是 ArrayBuffer、SharedArrayBuffer，或它们的子类型。</dd>
        </dl>
        <emu-alg>
          1. 令 _bufferData_ 为 _obj_.[[ArrayBufferData]]。
          1. 若 _bufferData_ 为 *null*，返回 *false*。
          1. 若 _bufferData_ 是 Data Block，返回 *false*。
          1. 断言：_bufferData_ 是 Shared Data Block。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation">
        <h1>
          HostGrowSharedArrayBuffer (
            _buffer_: a SharedArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): 要么是包含 ~handled~ 或 ~unhandled~ 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>给予宿主机会对 _buffer_ 进行实现自定义的增长。若宿主选择不处理增长，可返回 ~unhandled~ 以使用默认行为。</dd>
        </dl>
        <p>HostGrowSharedArrayBuffer 的实现必须符合以下要求：</p>
        <ul>
          <li>若该抽象操作未以 ~unhandled~ 正常完成，且 _newByteLength_ &lt; 当前 _buffer_ 的字节长度，或 _newByteLength_ > _buffer_.[[ArrayBufferMaxByteLength]]，抛出 *RangeError* 异常。</li>
          <li>令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段的值。若该抽象操作以 ~handled~ 正常完成，则一个 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件被加入外层 agent 的候选执行，其 [[Order]] 为 ~seq-cst~，[[Payload]] 为 NumericToRawBytes(~biguint64~, _newByteLength_, _isLittleEndian_)，[[Block]] 为 _buffer_.[[ArrayBufferByteLengthData]]，[[ByteIndex]] 为 0，[[ElementSize]] 为 8，从而并发竞争的 `SharedArrayBuffer.prototype.grow` 调用不会“丢失”（即静默不做任何事）。</li>
        </ul>

        <emu-note>
          <p>上面第二个要求有意未明确说明如何或何时读取 _buffer_ 的当前字节长度。由于字节长度必须通过底层硬件的原子读-改-写操作更新，使用 load-link/store-conditional 或 load-exclusive/store-exclusive 指令对的体系结构可能希望将该指令对在指令流中保持紧邻。因此，SharedArrayBuffer.prototype.grow 自身不会在调用 HostGrowSharedArrayBuffer 前对 _newByteLength_ 做边界检查，也不要求何时读取当前字节长度。</p>
          <p>这与 HostResizeArrayBuffer 形成对比，后者被保证 _newByteLength_ 值 ≥ 0 且 ≤ _buffer_.[[ArrayBufferMaxByteLength]]。</p>
        </emu-note>

        <p>HostGrowSharedArrayBuffer 的默认实现是返回 NormalCompletion(~unhandled~)。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer-constructor">
      <h1>SharedArrayBuffer 构造函数</h1>
      <p>SharedArrayBuffer 构造函数：</p>
      <ul>
        <li>是 <dfn>%SharedArrayBuffer%</dfn>。</li>
        <li>若全局对象存在该属性，则为其 *"SharedArrayBuffer"* 属性的初始值（见下文）。</li>
        <li>作为构造函数调用时创建并初始化一个新的 SharedArrayBuffer。</li>
        <li>不应作为函数调用；若如此调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。欲继承指定 SharedArrayBuffer 行为的子类构造函数必须包含对 SharedArrayBuffer 构造函数的 `super` 调用，以创建并初始化具有支持 `SharedArrayBuffer.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <p>当宿主不提供对 SharedArrayBuffers 的并发访问时，可以省略全局对象的 *"SharedArrayBuffer"* 属性。</p>

      <emu-note>
        <p>不同于 `ArrayBuffer`，`SharedArrayBuffer` 不会被分离，其内部 [[ArrayBufferData]] 槽永不为 *null*。</p>
      </emu-note>

      <emu-clause id="sec-sharedarraybuffer-length">
        <h1>SharedArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 NewTarget 为 *undefined*，抛出 *TypeError* 异常。
          1. 令 _byteLength_ 为 ? ToIndex(_length_)。
          1. 令 _requestedMaxByteLength_ 为 ? GetArrayBufferMaxByteLengthOption(_options_)。
          1. 返回 ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>SharedArrayBuffer 构造函数的属性</h1>
      <p>SharedArrayBuffer 构造函数：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-sharedarraybuffer.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>`SharedArrayBuffer.prototype` 的初始值是 SharedArrayBuffer 原型对象。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer-@@species" id="sec-sharedarraybuffer-%symbol.species%">
        <h1>get SharedArrayBuffer [ %Symbol.species% ]</h1>
        <p>`SharedArrayBuffer[%Symbol.species%]` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数 *"name"* 属性的值为 *"get [Symbol.species]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object">
      <h1>SharedArrayBuffer 原型对象的属性</h1>
      <p><dfn>SharedArrayBuffer 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%SharedArrayBuffer.prototype%</dfn>。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[ArrayBufferData]] 或 [[ArrayBufferByteLength]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>
        <p>`SharedArrayBuffer.prototype.byteLength` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _length_ 为 ArrayBufferByteLength(_O_, ~seq-cst~)。
          1. 返回 𝔽(_length_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>`SharedArrayBuffer.prototype.constructor` 的初始值是 %SharedArrayBuffer%。</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.grow">
        <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _newByteLength_ 为 ? ToIndex(_newLength_)。
          1. 令 _hostHandled_ 为 ? HostGrowSharedArrayBuffer(_O_, _newByteLength_)。
          1. 若 _hostHandled_ 为 ~handled~，返回 *undefined*。
          1. 令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段的值。
          1. 令 _byteLengthBlock_ 为 _O_.[[ArrayBufferByteLengthData]]。
          1. 令 _currentByteLengthRawBytes_ 为 GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~)。
          1. 令 _newByteLengthRawBytes_ 为 NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_)。
          1. 重复，
            1. 注：这是一个比较并交换循环，确保对同一缓冲区的并行竞争增长是全序的，不会丢失，也不会静默不执行。循环在能够无竞争地尝试增长时退出。
            1. 令 _currentByteLength_ 为 ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_))。
            1. 若 _newByteLength_ = _currentByteLength_，返回 *undefined*。
            1. 若 _newByteLength_ &lt; _currentByteLength_ 或 _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]]，抛出 *RangeError* 异常。
            1. 令 _byteLengthDelta_ 为 _newByteLength_ - _currentByteLength_。
            1. 若无法创建由 _byteLengthDelta_ 个字节组成的新 Shared Data Block 值，抛出 *RangeError* 异常。
            1. 注：此处未构造并使用新的 Shared Data Block。对可增长 SharedArrayBuffer 的可观察行为通过在构造时分配最大尺寸 Shared Data Block 指定，此步体现实现若内存不足必须抛出 *RangeError* 的要求。
            1. 令 _readByteLengthRawBytes_ 为 AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_)。
            1. 若 ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) 为 *true*，返回 *undefined*。
            1. 设 _currentByteLengthRawBytes_ 为 _readByteLengthRawBytes_。
        </emu-alg>
        <emu-note>
          <p>禁止比较交换更新长度的虚假失败。若新长度的边界检查通过且实现未耗尽内存，则总会向候选执行添加一个 ReadModifyWriteSharedMemory 事件（即成功的比较交换）。</p>
          <p>对 SharedArrayBuffer.prototype.grow 的并行调用是全序的。例如并发的 `sab.grow(10)` 与 `sab.grow(20)`，二者之一必定赢得竞争。`sab.grow(10)` 不会在 `sab.grow(20)` 先发生时收缩 `sab`；在那种情况下它将抛出 RangeError。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
        <h1>get SharedArrayBuffer.prototype.growable</h1>
        <p>`SharedArrayBuffer.prototype.growable` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 IsFixedLengthArrayBuffer(_O_) 为 *false*，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
        <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
        <p>`SharedArrayBuffer.prototype.maxByteLength` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 IsFixedLengthArrayBuffer(_O_) 为 *true*，则
            1. 令 _length_ 为 _O_.[[ArrayBufferByteLength]]。
          1. 否则，
            1. 令 _length_ 为 _O_.[[ArrayBufferMaxByteLength]]。
          1. 返回 𝔽(_length_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_O_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _len_ 为 ArrayBufferByteLength(_O_, ~seq-cst~)。
          1. 令 _relativeStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _relativeStart_ = -∞，令 _first_ 为 0。
          1. Else if _relativeStart_ &lt; 0，令 _first_ 为 max(_len_ + _relativeStart_, 0)。
          1. Else，令 _first_ 为 min(_relativeStart_, _len_)。
          1. 若 _end_ 为 *undefined*，令 _relativeEnd_ 为 _len_；否则令 _relativeEnd_ 为 ? ToIntegerOrInfinity(_end_)。
          1. 若 _relativeEnd_ = -∞，令 _final_ 为 0。
          1. Else if _relativeEnd_ &lt; 0，令 _final_ 为 max(_len_ + _relativeEnd_, 0)。
          1. Else，令 _final_ 为 min(_relativeEnd_, _len_)。
          1. 令 _newLen_ 为 max(_final_ - _first_, 0)。
          1. 令 _ctor_ 为 ? SpeciesConstructor(_O_, %SharedArrayBuffer%)。
          1. 令 _new_ 为 ? Construct(_ctor_, « 𝔽(_newLen_) »)。
          1. 执行 ? RequireInternalSlot(_new_, [[ArrayBufferData]])。
          1. 若 IsSharedArrayBuffer(_new_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _new_.[[ArrayBufferData]] 是 _O_.[[ArrayBufferData]]，抛出 *TypeError* 异常。
          1. 若 ArrayBufferByteLength(_new_, ~seq-cst~) &lt; _newLen_，抛出 *TypeError* 异常。
          1. 令 _fromBuf_ 为 _O_.[[ArrayBufferData]]。
          1. 令 _toBuf_ 为 _new_.[[ArrayBufferData]]。
          1. 执行 CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_)。
          1. 返回 _new_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer.prototype.toString,sec-sharedarraybuffer.prototype-@@tostringtag" id="sec-sharedarraybuffer.prototype-%symbol.tostringtag%">
        <h1>SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"SharedArrayBuffer"*。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-instances">
      <h1>SharedArrayBuffer 实例的属性</h1>
      <p>SharedArrayBuffer 实例从 SharedArrayBuffer 原型对象继承属性。每个 SharedArrayBuffer 实例都有一个 [[ArrayBufferData]] 内部槽。不可增长的 SharedArrayBuffer 实例各自具有一个 [[ArrayBufferByteLength]] 内部槽。可增长的 SharedArrayBuffer 实例各自具有一个 [[ArrayBufferByteLengthData]] 内部槽和一个 [[ArrayBufferMaxByteLength]] 内部槽。</p>

      <emu-note>
        <p>SharedArrayBuffer 实例与 ArrayBuffer 实例不同，永远不会被分离。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-growable-sharedarraybuffer-guidelines">
      <h1>可增长 SharedArrayBuffer 指南</h1>
      <emu-note>
        <p>以下是供使用可增长 SharedArrayBuffer 的 ECMAScript 程序员的指南。</p>
        <p>建议在部署环境中（若可行）对程序进行测试。不同硬件设备的可用物理内存差异巨大；虚拟内存子系统同样因硬件与操作系统不同而显著差异。一个在 64 位桌面浏览器中无内存耗尽错误的应用，可能在 32 位移动浏览器中耗尽内存。</p>
        <p>为可增长 SharedArrayBuffer 选择 *"maxByteLength"* 选项时，建议选择应用所需的最小可能值。建议 *"maxByteLength"* 不超过 1073741824（即 1GiB）。</p>
        <p>请注意：成功构造一个指定最大值的可增长 SharedArrayBuffer 并不保证后续的增长操作一定成功。</p>
        <p>对可增长 SharedArrayBuffer 的长度的所有读取并非都是同步的 ~seq-cst~ 读取。用于整数索引属性访问（如 `u8[idx]`）的边界检查中的长度读取不是同步的。一般而言，在缺乏显式同步的情况下，一个属性访问在边界内并不意味着同一 agent 中后续的另一个属性访问也在边界内。相比之下，通过 SharedArrayBuffer、%TypedArray%.prototype 和 DataView.prototype 上的 `length` 与 `byteLength` getter 对长度的显式读取是同步的。内置方法为检查 TypedArray 是否完全越界而执行的长度读取也是同步的。</p>
      </emu-note>

      <emu-note>
        <p>以下是实现可增长 SharedArrayBuffer 的 ECMAScript 实现者的指南。</p>
        <p>建议将可增长 SharedArrayBuffer 实现为通过预留虚拟内存的原地增长。</p>
        <p>由于增长操作可与对可增长 SharedArrayBuffer 的内存访问并行发生，内存模型的约束要求即便是无序访问也不得“撕裂”（其值的比特不会混杂）。实际上，这意味着可增长 SharedArrayBuffer 的底层数据块不能在不停顿世界的情况下通过复制来增长。我们不建议以停顿世界作为实现策略，因为它引入串行化点且速度慢。</p>
        <p>被增长的内存在创建时必须表现为已归零，包括对任何并行的竞争访问。这可通过按需零填充的虚拟内存页实现，或在手动清零内存时使用谨慎的同步。</p>
        <p>针对可增长 SharedArrayBuffer 的 TypedArray 视图的整数索引属性访问，旨在可与针对不可增长 SharedArrayBuffer 的 TypedArray 视图访问类似地优化，因为整数索引属性读取在底层缓冲区长度上不是同步操作（见上面的程序员指南）。例如，属性访问的边界检查仍可被提升出循环。</p>
        <p>在没有虚拟内存的宿主（例如无 MMU 的嵌入式设备）上通过复制实现可增长 SharedArrayBuffer 在实践中很困难。此类宿主上可增长 SharedArrayBuffer 的内存使用行为可能与具备虚拟内存的宿主显著不同。这些宿主应清晰地向用户传达内存使用期望。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView 对象</h1>

    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>DataView 对象的抽象操作</h1>

      <emu-clause id="sec-dataview-with-buffer-witness-records">
        <h1>具有缓冲区见证记录的 DataView</h1>
        <p><dfn variants="DataView With Buffer Witness Records">具有缓冲区见证记录的 DataView</dfn> 是一个 Record 值，用于封装一个 DataView 以及已查看缓冲区的缓存字节长度。当被查看缓冲区是可增长 SharedArrayBuffers 时，它用于帮助确保对字节长度数据块只有一次共享内存读取事件。</p>
        <p>具有缓冲区见证记录的 DataView 拥有 <emu-xref href="#table-dataview-with-buffer-witness-record-fields"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-dataview-with-buffer-witness-record-fields" caption="具有缓冲区见证记录的 DataView 字段">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a DataView
              </td>
              <td>
                其缓冲区字节长度被加载的 DataView 对象。
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                Record 创建时对象的 [[ViewedArrayBuffer]] 的字节长度。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-makedataviewwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeDataViewWithBufferWitnessRecord (
            _obj_: a DataView,
            _order_: ~seq-cst~ or ~unordered~,
          ): a DataView With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _buffer_ 为 _obj_.[[ViewedArrayBuffer]]。
          1. 若 IsDetachedBuffer(_buffer_) 为 *true*，则
            1. 令 _byteLength_ 为 ~detached~。
          1. 否则，
            1. 令 _byteLength_ 为 ArrayBufferByteLength(_buffer_, _order_)。
          1. 返回 DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewbytelength" type="abstract operation">
        <h1>
          GetViewByteLength (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsViewOutOfBounds(_viewRecord_) 为 *false*。
          1. 令 _view_ 为 _viewRecord_.[[Object]]。
          1. 若 _view_.[[ByteLength]] 不为 ~auto~，返回 _view_.[[ByteLength]]。
          1. 断言：IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) 为 *false*。
          1. 令 _byteOffset_ 为 _view_.[[ByteOffset]]。
          1. 令 _byteLength_ 为 _viewRecord_.[[CachedBufferByteLength]]。
          1. 断言：_byteLength_ 不为 ~detached~。
          1. 返回 _byteLength_ - _byteOffset_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isviewoutofbounds" type="abstract operation">
        <h1>
          IsViewOutOfBounds (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _view_ 为 _viewRecord_.[[Object]]。
          1. 令 _bufferByteLength_ 为 _viewRecord_.[[CachedBufferByteLength]]。
          1. 断言：IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) 为 *true* 当且仅当 _bufferByteLength_ 为 ~detached~。
          1. 若 _bufferByteLength_ 为 ~detached~，返回 *true*。
          1. 令 _byteOffsetStart_ 为 _view_.[[ByteOffset]]。
          1. 若 _view_.[[ByteLength]] 为 ~auto~，则
            1. 令 _byteOffsetEnd_ 为 _bufferByteLength_。
          1. 否则，
            1. 令 _byteOffsetEnd_ 为 _byteOffsetStart_ + _view_.[[ByteLength]]。
          1. 若 _byteOffsetStart_ > _bufferByteLength_ 或 _byteOffsetEnd_ > _bufferByteLength_，返回 *true*。
          1. 注：长度为 0 的 DataView 不被视为越界。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewvalue" type="abstract operation">
        <h1>
          GetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
          ): 要么是包含 Number 或 BigInt 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>供 DataView 实例上的函数使用以从其视图缓冲区读取值。</dd>
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_view_, [[DataView]])。
          1. 断言：_view_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _getIndex_ 为 ? ToIndex(_requestIndex_)。
          1. 设 _isLittleEndian_ 为 ToBoolean(_isLittleEndian_)。
          1. 令 _viewOffset_ 为 _view_.[[ByteOffset]]。
          1. 令 _viewRecord_ 为 MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~)。
          1. 注：当 _view_ 的后备缓冲区是可增长 SharedArrayBuffer 时，边界检查不是同步操作。
          1. 若 IsViewOutOfBounds(_viewRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _viewSize_ 为 GetViewByteLength(_viewRecord_)。
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 指定的元素大小值。
          1. 若 _getIndex_ + _elementSize_ > _viewSize_，抛出 *RangeError* 异常。
          1. 令 _bufferIndex_ 为 _getIndex_ + _viewOffset_。
          1. 返回 GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setviewvalue" type="abstract operation">
        <h1>
          SetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
            _value_: an ECMAScript language value,
          ): 要么是包含 *undefined* 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>供 DataView 实例上的函数使用以向其视图缓冲区存储值。</dd>
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_view_, [[DataView]])。
          1. 断言：_view_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _getIndex_ 为 ? ToIndex(_requestIndex_)。
          1. 若 IsBigIntElementType(_type_) 为 *true*，令 _numberValue_ 为 ? ToBigInt(_value_)。
          1. 否则，令 _numberValue_ 为 ? ToNumber(_value_)。
          1. 设 _isLittleEndian_ 为 ToBoolean(_isLittleEndian_)。
          1. 令 _viewOffset_ 为 _view_.[[ByteOffset]]。
          1. 令 _viewRecord_ 为 MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~)。
          1. 注：当 _view_ 的后备缓冲区是可增长 SharedArrayBuffer 时，边界检查不是同步操作。
          1. 若 IsViewOutOfBounds(_viewRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _viewSize_ 为 GetViewByteLength(_viewRecord_)。
          1. 令 _elementSize_ 为 <emu-xref href="#table-the-typedarray-constructors"></emu-xref> 中元素类型 _type_ 指定的元素大小值。
          1. 若 _getIndex_ + _elementSize_ > _viewSize_，抛出 *RangeError* 异常。
          1. 令 _bufferIndex_ 为 _getIndex_ + _viewOffset_。
          1. 执行 SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_)。
          1. 返回 *undefined*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-dataview-constructor">
      <h1>DataView 构造函数</h1>
      <p>DataView 构造函数：</p>
      <ul>
        <li>是 <dfn>%DataView%</dfn>。</li>
        <li>是全局对象 *"DataView"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 DataView。</li>
        <li>不应作为函数调用；若如此调用将抛出异常。</li>
        <li>可作为类定义 `extends` 子句的值。欲继承指定 DataView 行为的子类构造函数必须包含对 DataView 构造函数的 `super` 调用，以创建并初始化具有支持 `DataView.prototype` 内置方法所需内部状态的子类实例。</li>
      </ul>

      <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
        <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 NewTarget 为 *undefined*，抛出 *TypeError* 异常。
          1. 执行 ? RequireInternalSlot(_buffer_, [[ArrayBufferData]])。
          1. 令 _offset_ 为 ? ToIndex(_byteOffset_)。
          1. 若 IsDetachedBuffer(_buffer_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _bufferByteLength_ 为 ArrayBufferByteLength(_buffer_, ~seq-cst~)。
          1. 若 _offset_ > _bufferByteLength_，抛出 *RangeError* 异常。
          1. 令 _bufferIsFixedLength_ 为 IsFixedLengthArrayBuffer(_buffer_)。
          1. 若 _byteLength_ 为 *undefined*，则
            1. 若 _bufferIsFixedLength_ 为 *true*，则
              1. 令 _viewByteLength_ 为 _bufferByteLength_ - _offset_。
            1. 否则，
              1. 令 _viewByteLength_ 为 ~auto~。
          1. 否则，
            1. 令 _viewByteLength_ 为 ? ToIndex(_byteLength_)。
            1. 若 _offset_ + _viewByteLength_ > _bufferByteLength_，抛出 *RangeError* 异常。
          1. 令 _O_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »)。
          1. 若 IsDetachedBuffer(_buffer_) 为 *true*，抛出 *TypeError* 异常。
          1. 设 _bufferByteLength_ 为 ArrayBufferByteLength(_buffer_, ~seq-cst~)。
          1. 若 _offset_ > _bufferByteLength_，抛出 *RangeError* 异常。
          1. 若 _byteLength_ 不为 *undefined*，则
            1. 若 _offset_ + _viewByteLength_ > _bufferByteLength_，抛出 *RangeError* 异常。
          1. 设 _O_.[[ViewedArrayBuffer]] 为 _buffer_。
          1. 设 _O_.[[ByteLength]] 为 _viewByteLength_。
          1. 设 _O_.[[ByteOffset]] 为 _offset_。
          1. 返回 _O_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>DataView 构造函数的属性</h1>
      <p>DataView 构造函数：</p>
      <ul>
        <li>具有 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-dataview.prototype">
        <h1>DataView.prototype</h1>
        <p>`DataView.prototype` 的初始值是 DataView 原型对象。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-prototype-object">
      <h1>DataView 原型对象的属性</h1>
      <p><dfn>DataView 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%DataView.prototype%</dfn>。</li>
        <li>具有 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>没有 [[DataView]]、[[ViewedArrayBuffer]]、[[ByteLength]] 或 [[ByteOffset]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-get-dataview.prototype.buffer">
        <h1>get DataView.prototype.buffer</h1>
        <p>`DataView.prototype.buffer` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[DataView]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _buffer_ 为 _O_.[[ViewedArrayBuffer]]。
          1. 返回 _buffer_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.bytelength">
        <h1>get DataView.prototype.byteLength</h1>
        <p>`DataView.prototype.byteLength` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[DataView]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _viewRecord_ 为 MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 若 IsViewOutOfBounds(_viewRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _size_ 为 GetViewByteLength(_viewRecord_)。
          1. 返回 𝔽(_size_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.byteoffset">
        <h1>get DataView.prototype.byteOffset</h1>
        <p>`DataView.prototype.byteOffset` 是一个存取器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[DataView]])。
          1. 断言：_O_ 具有 [[ViewedArrayBuffer]] 内部槽。
          1. 令 _viewRecord_ 为 MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 若 IsViewOutOfBounds(_viewRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 令 _offset_ 为 _O_.[[ByteOffset]]。
          1. 返回 𝔽(_offset_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.constructor">
        <h1>DataView.prototype.constructor</h1>
        <p>`DataView.prototype.constructor` 的初始值是 %DataView%。</p>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbigint64">
        <h1>DataView.prototype.getBigInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbiguint64">
        <h1>DataView.prototype.getBigUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat16">
        <h1>DataView.prototype.getFloat16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat32">
        <h1>DataView.prototype.getFloat32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat64">
        <h1>DataView.prototype.getFloat64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint8">
        <h1>DataView.prototype.getInt8 ( _byteOffset_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, *true*, ~int8~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint16">
        <h1>DataView.prototype.getInt16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint32">
        <h1>DataView.prototype.getInt32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint8">
        <h1>DataView.prototype.getUint8 ( _byteOffset_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, *true*, ~uint8~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint16">
        <h1>DataView.prototype.getUint16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint32">
        <h1>DataView.prototype.getUint32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbigint64">
        <h1>DataView.prototype.setBigInt64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbiguint64">
        <h1>DataView.prototype.setBigUint64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat16">
        <h1>DataView.prototype.setFloat16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat32">
        <h1>DataView.prototype.setFloat32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat64">
        <h1>DataView.prototype.setFloat64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint8">
        <h1>DataView.prototype.setInt8 ( _byteOffset_, _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, *true*, ~int8~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint16">
        <h1>DataView.prototype.setInt16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint32">
        <h1>DataView.prototype.setInt32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint8">
        <h1>DataView.prototype.setUint8 ( _byteOffset_, _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, *true*, ~uint8~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint16">
        <h1>DataView.prototype.setUint16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint32">
        <h1>DataView.prototype.setUint32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _view_ 为 *this* 值。
          1. 若 _littleEndian_ 不存在，设 _littleEndian_ 为 *false*。
          1. 返回 ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~, _value_)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-dataview.prototype-@@tostringtag" id="sec-dataview.prototype-%symbol.tostringtag%">
        <h1>DataView.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"DataView"*。</p>
        <p>该属性特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-dataview-instances">
      <h1>DataView 实例的属性</h1>
      <p>DataView 实例是从 DataView 原型对象继承属性的普通对象。每个 DataView 实例具有 [[DataView]]、[[ViewedArrayBuffer]]、[[ByteLength]] 和 [[ByteOffset]] 内部槽。</p>
      <emu-note>
        <p>[[DataView]] 内部槽的值不在本规范中使用。该内部槽的简单存在用于在规范中识别由 DataView 构造函数创建的对象。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics-object">
    <h1>Atomics 对象</h1>
    <p>Atomics 对象：</p>
    <ul>
      <li>是 <dfn>%Atomics%</dfn>。</li>
      <li>是全局对象 *"Atomics"* 属性的初始值。</li>
      <li>是一个普通对象。</li>
      <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      <li>没有 [[Construct]] 内部方法；不能与 `new` 运算符一起作为构造函数使用。</li>
      <li>没有 [[Call]] 内部方法；不能作为函数调用。</li>
    </ul>
    <p>Atomics 对象提供在共享内存数组单元上不可分割（原子）操作的函数，以及让 agent 等待和派发原始事件（primitive events）的函数。正确使用 Atomics 函数，可以让通过共享内存通信的多 agent 程序即便在并行 CPU 上也按照可理解的顺序执行。共享内存通信的规则由下文定义的内存模型提供。</p>
    <emu-note>
      <p>关于在 ECMAScript 中编程与实现共享内存的说明性指南，请参见内存模型章节末尾的注释。</p>
    </emu-note>

    <emu-clause id="sec-waiter-record">
      <h1>Waiter Record</h1>
      <p><dfn variants="Waiter Records">Waiter Record</dfn> 是一个 Record 值，用于表示一次对 `Atomics.wait` 或 `Atomics.waitAsync` 的特定调用。</p>
      <p>Waiter Record 拥有 <emu-xref href="#table-waiterrecord"></emu-xref> 中列出的字段。</p>
      <emu-table id="table-waiterrecord" caption="Waiter Record 字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                取值
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[AgentSignifier]]
            </td>
            <td>
              一个 agent 标识符
            </td>
            <td>
              调用 `Atomics.wait` 或 `Atomics.waitAsync` 的 agent。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            </td>
            <td>
              一个 PromiseCapability Record 或 ~blocking~
            </td>
            <td>
              若表示一次对 `Atomics.waitAsync` 的调用，则为生成的 promise，否则为 ~blocking~。
            </td>
          </tr>
          <tr>
            <td>
              [[TimeoutTime]]
            </td>
            <td>
              一个非负扩展数学值
            </td>
            <td>
              可能触发超时的最早时间；使用时间值计算。
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            </td>
            <td>
              *"ok"* 或 *"timed-out"*
            </td>
            <td>
              调用的返回值。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-waiterlist-records" oldids="sec-waiterlist-objects">
      <h1>WaiterList Records</h1>
      <p><dfn variants="WaiterList Records">WaiterList Record</dfn> 用于解释通过 `Atomics.wait`、`Atomics.waitAsync` 与 `Atomics.notify` 进行的等待与通知。</p>
      <p>WaiterList Record 拥有 <emu-xref href="#table-waiterlistrecord"></emu-xref> 中列出的字段。</p>
      <emu-table id="table-waiterlistrecord" caption="WaiterList Record 字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                取值
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Waiters]]
            </td>
            <td>
              一个 Waiter Record 的 List
            </td>
            <td>
              等待与该 WaiterList 关联的位置的 `Atomics.wait` 或 `Atomics.waitAsync` 调用。
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            </td>
            <td>
              一个 Synchronize 事件或 ~empty~
            </td>
            <td>
              最近一次离开其临界区的事件；若从未进入过其临界区则为 ~empty~。
            </td>
          </tr>
        </table>
      </emu-table>
      <p>在一个 WaiterList 中可以有多个具有相同 agent 标识符的 Waiter Record。</p>
      <p>agent 集群拥有一个 WaiterList Record 的存储；该存储由 (_block_, _i_) 索引，其中 _block_ 是一个 Shared Data Block，_i_ 是 _block_ 内存中的字节偏移。WaiterList Record 与 agent 无关：在集群中任一 agent 中按 (_block_, _i_) 查找都会得到同一 WaiterList Record。</p>
      <p>每个 WaiterList Record 有一个 <dfn variants="critical sections">临界区（critical section）</dfn>，控制在求值期间对该 WaiterList Record 的独占访问。一次只能有一个 agent 进入该临界区。进入和离开临界区由抽象操作 EnterCriticalSection 与 LeaveCriticalSection 控制。对 WaiterList Record 的操作——添加和移除等待的 agent、遍历 agent 列表、挂起与通知列表中的 agent、设置与获取 Synchronize 事件——只能由已进入该临界区的 agent 执行。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-atomics">
      <h1>Atomics 的抽象操作</h1>

      <emu-clause id="sec-validateintegertypedarray" type="abstract operation" oldids="sec-validatesharedintegertypedarray">
        <h1>
          ValidateIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _waitable_: a Boolean,
          ): 要么是包含一个 TypedArray With Buffer Witness Record 的正常完成，要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _taRecord_ 为 ? ValidateTypedArray(_typedArray_, ~unordered~)。
          1. 注：当 _typedArray_ 的后备缓冲区是可增长 SharedArrayBuffer 时，边界检查不是同步操作。
          1. 若 _waitable_ 为 *true*，则
            1. 若 _typedArray_.[[TypedArrayName]] 既不是 *"Int32Array"* 也不是 *"BigInt64Array"*，抛出 *TypeError* 异常。
          1. 否则，
            1. 令 _type_ 为 TypedArrayElementType(_typedArray_)。
            1. 若 IsUnclampedIntegerElementType(_type_) 为 *false* 且 IsBigIntElementType(_type_) 为 *false*，抛出 *TypeError* 异常。
          1. 返回 _taRecord_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccess" type="abstract operation">
        <h1>
          ValidateAtomicAccess (
            _taRecord_: a TypedArray With Buffer Witness Record,
            _requestIndex_: an ECMAScript language value,
          ): 要么是包含一个整数的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
          1. 令 _accessIndex_ 为 ? ToIndex(_requestIndex_)。
          1. 断言：_accessIndex_ ≥ 0。
          1. 若 _accessIndex_ ≥ _length_，抛出 *RangeError* 异常。
          1. 令 _typedArray_ 为 _taRecord_.[[Object]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_typedArray_)。
          1. 令 _offset_ 为 _typedArray_.[[ByteOffset]]。
          1. 返回 (_accessIndex_ × _elementSize_) + _offset_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccessonintegertypedarray" type="abstract operation">
        <h1>
          ValidateAtomicAccessOnIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
          ): 要么是包含一个整数的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _taRecord_ 为 ? ValidateIntegerTypedArray(_typedArray_, *false*)。
          1. 返回 ? ValidateAtomicAccess(_taRecord_, _requestIndex_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-revalidateatomicaccess" type="abstract operation">
        <h1>
          RevalidateAtomicAccess (
            _typedArray_: a TypedArray,
            _byteIndexInBuffer_: an integer,
          ): 要么是包含 ~unused~ 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>该操作在 Atomics 方法中所有参数强制类型转换完成后对底层缓冲区中的索引重新验证，因为参数转换可能有任意副作用，会导致缓冲区变为越界。当 _typedArray_ 的后备缓冲区是 SharedArrayBuffer 时该操作不会抛出。</dd>
        </dl>
        <emu-alg>
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~)。
          1. 注：当 _typedArray_ 的后备缓冲区是可增长 SharedArrayBuffer 时，边界检查不是同步操作。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，抛出 *TypeError* 异常。
          1. 断言：_byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]]。
          1. 若 _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]]，抛出 *RangeError* 异常。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getwaiterlist" type="abstract operation">
        <h1>
          GetWaiterList (
            _block_: a Shared Data Block,
            _i_: a non-negative integer that is evenly divisible by 4,
          ): a WaiterList Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_i_ 与 _i_ + 3 均是 _block_ 内存中的有效字节偏移。
          1. 返回由 (_block_, _i_) 对引用的 WaiterList Record。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-entercriticalsection" type="abstract operation">
        <h1>
          EnterCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 不在任何 WaiterList Record 的临界区中。
          1. 等待直到没有 agent 在 _WL_ 的临界区中，然后进入 _WL_ 的临界区（期间不允许其他 agent 进入）。
          1. 若 _WL_.[[MostRecentLeaveEvent]] 不为 ~empty~，则
            1. 注：至少进入过一次临界区的 _WL_ 有由 LeaveCriticalSection 设置的 Synchronize 事件。
            1. 令 _execution_ 为外层 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
            1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
            1. 令 _enterEvent_ 为一个新的 Synchronize 事件。
            1. 将 _enterEvent_ 追加到 _eventsRecord_.[[EventList]]。
            1. 将 (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) 追加到 _eventsRecord_.[[AgentSynchronizesWith]]。
          1. 返回 ~unused~。
        </emu-alg>
        <p>当尝试进入临界区的 agent 必须等待另一个 agent 离开时，EnterCriticalSection 存在 <dfn>争用（contention）</dfn>。无争用时，EnterCriticalSection 调用的 FIFO 顺序是可观察的；有争用时，实现可选择任意顺序，但不能导致某个 agent 无限期等待。</p>
      </emu-clause>

      <emu-clause id="sec-leavecriticalsection" type="abstract operation">
        <h1>
          LeaveCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 正在 _WL_ 的临界区中。
          1. 令 _execution_ 为外层 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
          1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
          1. 令 _leaveEvent_ 为一个新的 Synchronize 事件。
          1. 将 _leaveEvent_ 追加到 _eventsRecord_.[[EventList]]。
          1. 设 _WL_.[[MostRecentLeaveEvent]] 为 _leaveEvent_。
          1. 离开 _WL_ 的临界区。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-addwaiter" type="abstract operation">
        <h1>
          AddWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 在 _WL_ 的临界区中。
          1. 断言：_WL_.[[Waiters]] 中不存在其 [[PromiseCapability]] 字段为 _waiterRecord_.[[PromiseCapability]] 且 [[AgentSignifier]] 字段为 _waiterRecord_.[[AgentSignifier]] 的 Waiter Record。
          1. 将 _waiterRecord_ 追加到 _WL_.[[Waiters]]。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiter" type="abstract operation">
        <h1>
          RemoveWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 在 _WL_ 的临界区中。
          1. 断言：_WL_.[[Waiters]] 包含 _waiterRecord_。
          1. 从 _WL_.[[Waiters]] 移除 _waiterRecord_。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiters" type="abstract operation">
        <h1>
          RemoveWaiters (
            _WL_: a WaiterList Record,
            _c_: a non-negative integer or +∞,
          ): a List of Waiter Records
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 在 _WL_ 的临界区中。
          1. 令 _len_ 为 _WL_.[[Waiters]] 中元素数量。
          1. 令 _n_ 为 min(_c_, _len_)。
          1. 令 _L_ 为一个 List，其元素为 _WL_.[[Waiters]] 的前 _n_ 个元素。
          1. 移除 _WL_.[[Waiters]] 的前 _n_ 个元素。
          1. 返回 _L_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-suspendthisagent" type="abstract operation" oldids="sec-suspend,sec-suspendagent">
        <h1>
          SuspendThisAgent (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 在 _WL_ 的临界区中。
          1. 断言：_WL_.[[Waiters]] 包含 _waiterRecord_。
          1. 令 _thisAgent_ 为 AgentSignifier()。
          1. 断言：_waiterRecord_.[[AgentSignifier]] 是 _thisAgent_。
          1. 断言：_waiterRecord_.[[PromiseCapability]] 是 ~blocking~。
          1. 断言：AgentCanSuspend() 为 *true*。
          1. 执行 LeaveCriticalSection(_WL_) 并挂起外层 agent 直到时间到达 _waiterRecord_.[[TimeoutTime]]，以一种方式组合操作：使得离开临界区后到挂起生效前到来的通知不会丢失。外层 agent 只能因超时或另一个 agent 使用参数 _WL_ 与 _thisAgent_ 调用 NotifyWaiter（即通过调用 `Atomics.notify`）而被唤醒。
          1. 执行 EnterCriticalSection(_WL_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-notifywaiter" type="abstract operation">
        <h1>
          NotifyWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：外层 agent 在 _WL_ 的临界区中。
          1. 若 _waiterRecord_.[[PromiseCapability]] 为 ~blocking~，则
            1. 唤醒其标识符为 _waiterRecord_.[[AgentSignifier]] 的 agent。
            1. 注：这会使该 agent 在 SuspendThisAgent 中恢复执行。
          1. 否则若 AgentSignifier() 是 _waiterRecord_.[[AgentSignifier]]，则
            1. 令 _promiseCapability_ 为 _waiterRecord_.[[PromiseCapability]]。
            1. 执行 ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] »)。
          1. 否则，
            1. 执行 EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]])。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-note>
          <p>一个 agent 不得以除传递给宿主之外的任何方式访问另一个 agent 的 promise capability。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueresolveinagentjob" type="abstract operation">
        <h1>
          EnqueueResolveInAgentJob (
            _agentSignifier_: an agent signifier,
            _promiseCapability_: a PromiseCapability Record,
            _resolution_: *"ok"* or *"timed-out"*,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _resolveJob_ 为一个无参数的新 Job 抽象闭包，捕获 _agentSignifier_、_promiseCapability_ 与 _resolution_，被调用时执行：
            1. 断言：AgentSignifier() 是 _agentSignifier_。
            1. 执行 ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »)。
            1. 返回 ~unused~。
          1. 令 _realmInTargetAgent_ 为 ! GetFunctionRealm(_promiseCapability_.[[Resolve]])。
          1. 断言：_agentSignifier_ 是 _realmInTargetAgent_.[[AgentSignifier]]。
          1. 执行 HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dowait" type="abstract operation">
        <h1>
          DoWait (
            _mode_: ~sync~ or ~async~,
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _timeout_: an ECMAScript language value,
          ): 要么是包含一个 Object、*"not-equal"*、*"timed-out"* 或 *"ok"* 的正常完成，要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _taRecord_ 为 ? ValidateIntegerTypedArray(_typedArray_, *true*)。
          1. 令 _buffer_ 为 _taRecord_.[[Object]].[[ViewedArrayBuffer]]。
          1. 若 IsSharedArrayBuffer(_buffer_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _i_ 为 ? ValidateAtomicAccess(_taRecord_, _index_)。
          1. 令 _arrayTypeName_ 为 _typedArray_.[[TypedArrayName]]。
          1. 若 _arrayTypeName_ 为 *"BigInt64Array"*，令 _v_ 为 ? ToBigInt64(_value_)。
          1. 否则，令 _v_ 为 ? ToInt32(_value_)。
          1. 令 _q_ 为 ? ToNumber(_timeout_)。
          1. 若 _q_ 为 *NaN* 或 *+∞*<sub>𝔽</sub>，令 _t_ 为 +∞；否则若 _q_ 为 *-∞*<sub>𝔽</sub>，令 _t_ 为 0；否则令 _t_ 为 max(ℝ(_q_), 0)。
          1. 若 _mode_ 为 ~sync~ 且 AgentCanSuspend() 为 *false*，抛出 *TypeError* 异常。
          1. 令 _block_ 为 _buffer_.[[ArrayBufferData]]。
          1. 令 _offset_ 为 _typedArray_.[[ByteOffset]]。
          1. 令 _byteIndexInBuffer_ 为 (_i_ × 4) + _offset_。
          1. 令 _WL_ 为 GetWaiterList(_block_, _byteIndexInBuffer_)。
          1. 若 _mode_ 为 ~sync~，则
            1. 令 _promiseCapability_ 为 ~blocking~。
            1. 令 _resultObject_ 为 *undefined*。
          1. 否则，
            1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
            1. 令 _resultObject_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 EnterCriticalSection(_WL_)。
          1. 令 _elementType_ 为 TypedArrayElementType(_typedArray_)。
          1. 令 _w_ 为 GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~)。
          1. 若 _v_ ≠ _w_，则
            1. 执行 LeaveCriticalSection(_WL_)。
            1. 若 _mode_ 为 ~sync~，返回 *"not-equal"*。
            1. 执行 ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*)。
            1. 执行 ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"not-equal"*)。
            1. 返回 _resultObject_。
          1. 若 _t_ = 0 且 _mode_ 为 ~async~，则
            1. 注：对同步的立即超时没有特殊处理；异步立即超时被特殊处理以快速失败并避免不必要的 Promise 作业。
            1. 执行 LeaveCriticalSection(_WL_)。
            1. 执行 ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*)。
            1. 执行 ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"timed-out"*)。
            1. 返回 _resultObject_。
          1. 令 _thisAgent_ 为 AgentSignifier()。
          1. 令 _now_ 为标识当前时间的时间值 (UTC)。
          1. 令 _additionalTimeout_ 为实现定义的非负数学值。
          1. 令 _timeoutTime_ 为 ℝ(_now_) + _t_ + _additionalTimeout_。
          1. 注：当 _t_ 为 +∞ 时，_timeoutTime_ 亦为 +∞。
          1. 令 _waiterRecord_ 为一个新 Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* }。
          1. 执行 AddWaiter(_WL_, _waiterRecord_)。
          1. 若 _mode_ 为 ~sync~，则
            1. 执行 SuspendThisAgent(_WL_, _waiterRecord_)。
          1. 否则若 _timeoutTime_ 是有限的，则
            1. 执行 EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_)。
          1. 执行 LeaveCriticalSection(_WL_)。
          1. 若 _mode_ 为 ~sync~，返回 _waiterRecord_.[[Result]]。
          1. 执行 ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *true*)。
          1. 执行 ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, _promiseCapability_.[[Promise]])。
          1. 返回 _resultObject_。
        </emu-alg>
        <emu-note>
          <p>_additionalTimeout_ 允许实现按需填充超时，例如用于降低能耗或粗化计时器分辨率以缓解计时攻击。该值在不同 DoWait 调用间可能不同。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueatomicswaitasynctimeoutjob" type="abstract operation">
        <h1>
          EnqueueAtomicsWaitAsyncTimeoutJob (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _timeoutJob_ 为一个无参数的新 Job 抽象闭包，捕获 _WL_ 与 _waiterRecord_，被调用时执行：
            1. 执行 EnterCriticalSection(_WL_)。
            1. 若 _WL_.[[Waiters]] 包含 _waiterRecord_，则
              1. 令 _timeOfJobExecution_ 为标识当前时间的时间值 (UTC)。
              1. 断言：ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]]（忽略时间值可能的非单调性）。
              1. 设 _waiterRecord_.[[Result]] 为 *"timed-out"*。
              1. 执行 RemoveWaiter(_WL_, _waiterRecord_)。
              1. 执行 NotifyWaiter(_WL_, _waiterRecord_)。
            1. 执行 LeaveCriticalSection(_WL_)。
            1. 返回 ~unused~。
          1. 令 _now_ 为标识当前时间的时间值 (UTC)。
          1. 令 _currentRealm_ 为当前 Realm Record。
          1. 执行 HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomiccompareexchangeinsharedblock" type="abstract operation">
        <h1>
          AtomicCompareExchangeInSharedBlock (
            _block_: a Shared Data Block,
            _byteIndexInBuffer_: an integer,
            _elementSize_: a non-negative integer,
            _expectedBytes_: a List of byte values,
            _replacementBytes_: a List of byte values,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _execution_ 为外层 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
          1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
          1. 令 _rawBytesRead_ 为长度 _elementSize_ 的 List，其元素为非确定性选择的字节值。
          1. 注：在实现中，_rawBytesRead_ 是底层硬件 load-link、load-exclusive 或读-改-写指令操作数的结果；该非确定性是内存模型对弱一致硬件可观察行为的语义描述。
          1. 注：期望值与读值的比较在读-改-写修改函数之外执行，以避免当期望值不等于读值时产生不必要的强同步。
          1. 若 ByteListEqual(_rawBytesRead_, _expectedBytes_) 为 *true*，则
            1. 令 _second_ 为一个具有参数 (_oldBytes_, _newBytes_) 的新读-改-写修改函数，不捕获任何内容，被调用时原子地执行：
              1. 返回 _newBytes_。
            1. 令 _event_ 为 ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }。
          1. 否则，
            1. 令 _event_ 为 ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }。
          1. 将 _event_ 追加到 _eventsRecord_.[[EventList]]。
          1. 将 Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } 追加到 _execution_.[[ChosenValues]]。
          1. 返回 _rawBytesRead_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation">
        <h1>
          AtomicReadModifyWrite (
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _op_: a read-modify-write modification function,
          ): 要么是包含 Number 或 BigInt 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_op_ 接受两个字节值 List 参数并返回一个字节值 List。该操作原子地加载一个值，将其与另一个值组合并存储组合结果。它返回被加载的值。</dd>
        </dl>
        <emu-alg>
          1. 令 _byteIndexInBuffer_ 为 ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_)。
          1. 若 _typedArray_.[[ContentType]] 为 ~bigint~，令 _v_ 为 ? ToBigInt(_value_)。
          1. 否则，令 _v_ 为 𝔽(? ToIntegerOrInfinity(_value_))。
          1. 执行 ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_)。
          1. 令 _buffer_ 为 _typedArray_.[[ViewedArrayBuffer]]。
          1. 令 _elementType_ 为 TypedArrayElementType(_typedArray_)。
          1. 返回 GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistbitwiseop" type="abstract operation">
        <h1>
          ByteListBitwiseOp (
            _op_: `&amp;`, `^`, or `|`,
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): a List of byte values
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>该操作对参数的所有字节值执行按位运算并返回一个字节值 List。</dd>
        </dl>
        <emu-alg>
          1. 断言：_xBytes_ 与 _yBytes_ 拥有相同数量的元素。
          1. 令 _result_ 为新空 List。
          1. 令 _i_ 为 0。
          1. 对 _xBytes_ 的每个元素 _xByte_，执行
            1. 令 _yByte_ 为 _yBytes_[_i_]。
            1. 若 _op_ 是 `&amp;`，则
              1. 令 _resultByte_ 为对 _xByte_ 与 _yByte_ 执行按位与的结果。
            1. 否则若 _op_ 是 `^`，则
              1. 令 _resultByte_ 为按位异或结果。
            1. 否则，
              1. 断言：_op_ 是 `|`。
              1. 令 _resultByte_ 为按位或结果。
            1. 设 _i_ 为 _i_ + 1。
            1. 将 _resultByte_ 追加到 _result_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistequal" type="abstract operation">
        <h1>
          ByteListEqual (
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _xBytes_ 与 _yBytes_ 的元素数量不同，返回 *false*。
          1. 令 _i_ 为 0。
          1. 对 _xBytes_ 的每个元素 _xByte_，执行
            1. 令 _yByte_ 为 _yBytes_[_i_]。
            1. 若 _xByte_ ≠ _yByte_，返回 *false*。
            1. 设 _i_ 为 _i_ + 1。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-atomics.add">
      <h1>Atomics.add ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _add_ 为一个具有参数 (_xBytes_, _yBytes_) 的新读-改-写修改函数，捕获 _typedArray_，被调用时原子地执行：
          1. 令 _type_ 为 TypedArrayElementType(_typedArray_)。
          1. 令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段的值。
          1. 令 _x_ 为 RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_)。
          1. 令 _y_ 为 RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_)。
          1. 若 _x_ 是 Number，则
            1. 令 _sum_ 为 Number::add(_x_, _y_)。
          1. 否则，
            1. 断言：_x_ 是 BigInt。
            1. 令 _sum_ 为 BigInt::add(_x_, _y_)。
          1. 令 _sumBytes_ 为 NumericToRawBytes(_type_, _sum_, _isLittleEndian_)。
          1. 断言：_sumBytes_、_xBytes_ 与 _yBytes_ 拥有相同数量的元素。
          1. 返回 _sumBytes_。
        1. 返回 ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.and">
      <h1>Atomics.and ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _and_ 为一个具有参数 (_xBytes_, _yBytes_) 的新读-改-写修改函数，不捕获任何内容，被调用时原子地执行：
          1. 返回 ByteListBitwiseOp(`&amp;`, _xBytes_, _yBytes_)。
        1. 返回 ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _byteIndexInBuffer_ 为 ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_)。
        1. 令 _buffer_ 为 _typedArray_.[[ViewedArrayBuffer]]。
        1. 令 _block_ 为 _buffer_.[[ArrayBufferData]]。
        1. 若 _typedArray_.[[ContentType]] 为 ~bigint~，则
          1. 令 _expected_ 为 ? ToBigInt(_expectedValue_)。
          1. 令 _replacement_ 为 ? ToBigInt(_replacementValue_)。
        1. 否则，
          1. 令 _expected_ 为 𝔽(? ToIntegerOrInfinity(_expectedValue_))。
          1. 令 _replacement_ 为 𝔽(? ToIntegerOrInfinity(_replacementValue_))。
        1. 执行 ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_)。
        1. 令 _elementType_ 为 TypedArrayElementType(_typedArray_)。
        1. 令 _elementSize_ 为 TypedArrayElementSize(_typedArray_)。
        1. 令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段的值。
        1. 令 _expectedBytes_ 为 NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_)。
        1. 令 _replacementBytes_ 为 NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_)。
        1. 若 IsSharedArrayBuffer(_buffer_) 为 *true*，则
          1. 令 _rawBytesRead_ 为 AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_)。
        1. 否则，
          1. 令 _rawBytesRead_ 为长度 _elementSize_ 的 List，其元素为自 _block_[_byteIndexInBuffer_] 起的 _elementSize_ 个字节。
          1. 若 ByteListEqual(_rawBytesRead_, _expectedBytes_) 为 *true*，则
            1. 将 _replacementBytes_ 的各字节写入 _block_，起始于 _block_[_byteIndexInBuffer_]。
        1. 返回 RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange">
      <h1>Atomics.exchange ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _second_ 为一个具有参数 (_oldBytes_, _newBytes_) 的新读-改-写修改函数，不捕获任何内容，被调用时原子地执行：
          1. 返回 _newBytes_。
        1. 返回 ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree ( _size_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _n_ 为 ? ToIntegerOrInfinity(_size_)。
        1. 令 _AR_ 为外层 agent 的 Agent Record。
        1. 若 _n_ = 1，返回 _AR_.[[IsLockFree1]]。
        1. 若 _n_ = 2，返回 _AR_.[[IsLockFree2]]。
        1. 若 _n_ = 4，返回 *true*。
        1. 若 _n_ = 8，返回 _AR_.[[IsLockFree8]]。
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>此函数是一个优化原语。直觉是：如果大小为 _n_ 字节的数据上的原子原语（`compareExchange`、`load`、`store`、`add`、`sub`、`and`、`or`、`xor` 或 `exchange`）的原子步骤会在不获取该数据之外的锁的情况下执行，则 `Atomics.isLockFree`(_n_) 返回 *true*。高性能算法将利用该函数决定是否在临界区使用锁或原子操作。若原子原语不是无锁的，算法自行提供锁常常更高效。</p>
        <p>`Atomics.isLockFree`(4) 总是返回 *true*，因为所有已知相关硬件都能支持。可假定此点通常简化程序。</p>
        <p>无论此函数返回何值，所有原子操作都保证原子性。例如，它们不会在操作中间出现可见操作（如“撕裂”）。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-atomics.load" oldids="sec-atomicload">
      <h1>Atomics.load ( _typedArray_, _index_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _byteIndexInBuffer_ 为 ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_)。
        1. 执行 ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_)。
        1. 令 _buffer_ 为 _typedArray_.[[ViewedArrayBuffer]]。
        1. 令 _elementType_ 为 TypedArrayElementType(_typedArray_)。
        1. 返回 GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.or">
      <h1>Atomics.or ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _or_ 为一个具有参数 (_xBytes_, _yBytes_) 的新读-改-写修改函数，不捕获任何内容，被调用时原子地执行：
          1. 返回 ByteListBitwiseOp(`|`, _xBytes_, _yBytes_)。
        1. 返回 ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _byteIndexInBuffer_ 为 ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_)。
        1. 若 _typedArray_.[[ContentType]] 为 ~bigint~，令 _v_ 为 ? ToBigInt(_value_)。
        1. 否则，令 _v_ 为 𝔽(? ToIntegerOrInfinity(_value_))。
        1. 执行 ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_)。
        1. 令 _buffer_ 为 _typedArray_.[[ViewedArrayBuffer]]。
        1. 令 _elementType_ 为 TypedArrayElementType(_typedArray_)。
        1. 执行 SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~)。
        1. 返回 _v_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.sub">
      <h1>Atomics.sub ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _subtract_ 为一个具有参数 (_xBytes_, _yBytes_) 的新读-改-写修改函数，捕获 _typedArray_，被调用时原子地执行：
          1. 令 _type_ 为 TypedArrayElementType(_typedArray_)。
          1. 令 _isLittleEndian_ 为外层 agent 的 Agent Record 的 [[LittleEndian]] 字段的值。
          1. 令 _x_ 为 RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_)。
          1. 令 _y_ 为 RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_)。
          1. 若 _x_ 是 Number，则
            1. 令 _difference_ 为 Number::subtract(_x_, _y_)。
          1. 否则，
            1. 断言：_x_ 是 BigInt。
            1. 令 _difference_ 为 BigInt::subtract(_x_, _y_)。
          1. 令 _differenceBytes_ 为 NumericToRawBytes(_type_, _difference_, _isLittleEndian_)。
          1. 断言：_differenceBytes_、_xBytes_ 与 _yBytes_ 拥有相同数量的元素。
          1. 返回 _differenceBytes_。
        1. 返回 ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>该函数将外层 agent 置于等待队列并挂起，直到被通知或等待超时，返回区分这些情形的字符串。</p>
      <p>调用时执行以下步骤：</p>
      <emu-alg>
        1. 返回 ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.waitasync">
      <h1>Atomics.waitAsync ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>该函数返回一个 Promise，当调用者 agent 被通知或超时到达时 resolve。</p>
      <p>调用时执行以下步骤：</p>
      <emu-alg>
        1. 返回 ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.notify">
      <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
      <p>该函数通知一些在等待队列中休眠的 agent。</p>
      <p>调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _taRecord_ 为 ? ValidateIntegerTypedArray(_typedArray_, *true*)。
        1. 令 _byteIndexInBuffer_ 为 ? ValidateAtomicAccess(_taRecord_, _index_)。
        1. 若 _count_ 为 *undefined*，则
          1. 令 _c_ 为 +∞。
        1. 否则，
          1. 令 _intCount_ 为 ? ToIntegerOrInfinity(_count_)。
          1. 令 _c_ 为 max(_intCount_, 0)。
        1. 令 _buffer_ 为 _typedArray_.[[ViewedArrayBuffer]]。
        1. 令 _block_ 为 _buffer_.[[ArrayBufferData]]。
        1. 若 IsSharedArrayBuffer(_buffer_) 为 *false*，返回 *+0*<sub>𝔽</sub>。
        1. 令 _WL_ 为 GetWaiterList(_block_, _byteIndexInBuffer_)。
        1. 执行 EnterCriticalSection(_WL_)。
        1. 令 _S_ 为 RemoveWaiters(_WL_, _c_)。
        1. 对 _S_ 的每个元素 _W_，执行
          1. 执行 NotifyWaiter(_WL_, _W_)。
        1. 执行 LeaveCriticalSection(_WL_)。
        1. 令 _n_ 为 _S_ 中元素数量。
        1. 返回 𝔽(_n_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.xor">
      <h1>Atomics.xor ( _typedArray_, _index_, _value_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _xor_ 为一个具有参数 (_xBytes_, _yBytes_) 的新读-改-写修改函数，不捕获任何内容，被调用时原子地执行：
          1. 返回 ByteListBitwiseOp(`^`, _xBytes_, _yBytes_)。
        1. 返回 ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_)。
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-atomics-@@tostringtag" id="sec-atomics-%symbol.tostringtag%">
      <h1>Atomics [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Atomics"*。</p>
      <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-json-object">
    <h1>JSON 对象</h1>
    <p>JSON 对象：</p>
    <ul>
      <li>是 <dfn>%JSON%</dfn>。</li>
      <li>是全局对象 *"JSON"* 属性的初始值。</li>
      <li>是一个普通对象。</li>
      <li>包含两个函数 `parse` 与 `stringify`，用于解析与构造 JSON 文本。</li>
      <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
      <li>没有 [[Construct]] 内部方法；不能与 `new` 运算符一起作为构造函数使用。</li>
      <li>没有 [[Call]] 内部方法；不能作为函数调用。</li>
    </ul>
    <p>JSON 数据交换格式在 ECMA-404 中定义。本规范使用的 JSON 交换格式完全与 ECMA-404 所描述一致。`JSON.parse` 与 `JSON.stringify` 的一致实现必须支持 ECMA-404 规范所描述的精确交换格式，不得删除或扩展该格式。</p>

    <emu-clause id="sec-json.parse">
      <h1>JSON.parse ( _text_ [ , _reviver_ ] )</h1>
      <p>该函数解析一个 JSON 文本（JSON 格式的字符串）并生成一个 ECMAScript 语言值。JSON 格式以类似 ECMAScript 字面量、数组初始值与对象初始值的语法表示字面量、数组与对象。解析后，JSON 对象被实现为 ECMAScript 对象；JSON 数组被实现为 ECMAScript Array 实例；JSON 字符串、数字、布尔与 null 分别实现为 ECMAScript 的 String、Number、Boolean 与 *null*。</p>
      <p>可选参数 _reviver_ 是一个带两个参数 _key_ 与 _value_ 的函数。它可以过滤并转换结果。解析产生的每个 _key_/_value_ 对都会调用它，其返回值将替代原始值。若返回收到的值，结构不变；若返回 *undefined* 则该属性从结果中删除。</p>
      <emu-alg>
        1. 令 _jsonString_ 为 ? ToString(_text_)。
        1. 令 _unfiltered_ 为 ? ParseJSON(_jsonString_)。
        1. 若 IsCallable(_reviver_) 为 *true*，则
          1. 令 _root_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 令 _rootName_ 为空字符串。
          1. 执行 ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_)。
          1. 返回 ? InternalizeJSONProperty(_root_, _rootName_, _reviver_)。
        1. 否则，
          1. 返回 _unfiltered_。
      </emu-alg>
      <p>该函数的 *"length"* 属性为 *2*<sub>𝔽</sub>。</p>

      <emu-clause id="sec-ParseJSON" type="abstract operation">
        <h1>
          ParseJSON (
            _text_: a String,
          ): 要么是包含一个 ECMAScript 语言值的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. [id="step-json-parse-validate"] 若 StringToCodePoints(_text_) 不是 ECMA-404 所规定的有效 JSON 文本，抛出 *SyntaxError* 异常。
          1. 令 _scriptString_ 为 *"("*、_text_ 与 *");"* 的字符串连接。
          1. [id="step-json-parse-parse"] 令 _script_ 为 ParseText(_scriptString_, |Script|)。
          1. 注：<emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref> 定义的早期错误规则对上述 ParseText 调用有特殊处理。
          1. 断言：_script_ 是一个 Parse Node。
          1. [id="step-json-parse-eval"] 令 _result_ 为 ! <emu-meta suppress-effects="user-code">Evaluation of _script_</emu-meta>。
          1. 注：<emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> 定义的 PropertyDefinitionEvaluation 语义对上述求值有特殊处理。
          1. [id="step-json-parse-assert-type"] 断言：_result_ 不是 String、Number、Boolean、由 |ArrayLiteral| 或 |ObjectLiteral| 定义的 Object、就是 *null*。
          1. 返回 _result_。
        </emu-alg>
        <p>一致实现的 `JSON.parse` 不允许扩展 JSON 语法。若实现希望支持修改或扩展的 JSON 交换格式，必须定义不同的解析函数。</p>
        <emu-note>
          <p>有效 JSON 文本是 ECMAScript |PrimaryExpression| 语法的子集。步骤 <emu-xref href="#step-json-parse-validate"></emu-xref> 验证 _jsonString_ 是否符合该子集，步骤 <emu-xref href="#step-json-parse-assert-type"></emu-xref> 断言求值返回一个适当类型的值。</p>
          <p>然而，由于 <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> 在 ParseJSON 期间行为不同，同一源文本作为 |PrimaryExpression| 求值与作为 JSON 求值可能产生不同结果。此外，对对象字面量中重复 *"__proto__"* 属性的 Early Error 在 ParseJSON 中不适用，这意味着尽管语法匹配，并非所有 ParseJSON 接受的文本都可作为 |PrimaryExpression| 有效。</p>
        </emu-note>
        <emu-note>
          <p>当对象中存在重复名称字符串时，词法上先出现的同键值将被覆盖。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-internalizejsonproperty" type="abstract operation">
        <h1>
          InternalizeJSONProperty (
            _holder_: an Object,
            _name_: a String,
            _reviver_: a function object,
          ): 要么是包含一个 ECMAScript 语言值的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>该算法故意不在 [[Delete]] 或 CreateDataProperty 返回 *false* 时抛出异常。</p>
        </emu-note>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _val_ 为 ? Get(_holder_, _name_)。
          1. 若 _val_ 是 Object，则
            1. 令 _isArray_ 为 ? IsArray(_val_)。
            1. 若 _isArray_ 为 *true*，则
              1. 令 _len_ 为 ? LengthOfArrayLike(_val_)。
              1. 令 _I_ 为 0。
              1. 当 _I_ &lt; _len_ 重复，
                1. 令 _prop_ 为 ! ToString(𝔽(_I_))。
                1. 令 _newElement_ 为 ? InternalizeJSONProperty(_val_, _prop_, _reviver_)。
                1. 若 _newElement_ 为 *undefined*，则
                  1. 执行 ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_prop_)。
                1. 否则，
                  1. 执行 ? CreateDataProperty(_val_, _prop_, _newElement_)。
                1. 设 _I_ 为 _I_ + 1。
            1. 否则，
              1. 令 _keys_ 为 ? EnumerableOwnProperties(_val_, ~key~)。
              1. 对 _keys_ 的每个 String _P_，执行
                1. 令 _newElement_ 为 ? InternalizeJSONProperty(_val_, _P_, _reviver_)。
                1. 若 _newElement_ 为 *undefined*，则
                  1. 执行 ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_P_)。
                1. 否则，
                  1. 执行 ? CreateDataProperty(_val_, _P_, _newElement_)。
          1. 返回 ? Call(_reviver_, _holder_, « _name_, _val_ »)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json.stringify">
      <h1>JSON.stringify ( _value_ [ , _replacer_ [ , _space_ ] ] )</h1>
      <p>该函数返回一个 UTF-16 编码的 JSON 格式字符串表示一个 ECMAScript 语言值，或 *undefined*。它可接受三个参数。参数 _value_ 是 ECMAScript 语言值，通常是对象或数组，也可以是 String、Boolean、Number 或 *null*。可选参数 _replacer_ 要么是函数，改变对象与数组的字符串化方式；要么是由 String 与 Number 组成的数组，充当包含列表，选择会被字符串化的对象属性。可选参数 _space_ 是 String 或 Number，用于在结果中注入空白以提升可读性。</p>
      <p>调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _stack_ 为新空 List。
        1. 令 _indent_ 为空字符串。
        1. 令 _PropertyList_ 为 *undefined*。
        1. 令 _ReplacerFunction_ 为 *undefined*。
        1. 若 _replacer_ 是 Object，则
          1. 若 IsCallable(_replacer_) 为 *true*，则
            1. 设 _ReplacerFunction_ 为 _replacer_。
          1. 否则，
            1. 令 _isArray_ 为 ? IsArray(_replacer_)。
            1. 若 _isArray_ 为 *true*，则
              1. 设 _PropertyList_ 为新空 List。
              1. 令 _len_ 为 ? LengthOfArrayLike(_replacer_)。
              1. 令 _k_ 为 0。
              1. 当 _k_ &lt; _len_ 重复，
                1. 令 _prop_ 为 ! ToString(𝔽(_k_))。
                1. 令 _v_ 为 ? Get(_replacer_, _prop_)。
                1. 令 _item_ 为 *undefined*。
                1. 若 _v_ 是 String，则
                  1. 设 _item_ 为 _v_。
                1. 否则若 _v_ 是 Number，则
                  1. 设 _item_ 为 ! ToString(_v_)。
                1. 否则若 _v_ 是 Object，则
                  1. 若 _v_ 具有 [[StringData]] 或 [[NumberData]] 内部槽，设 _item_ 为 ? ToString(_v_)。
                1. 若 _item_ 不为 *undefined* 且 _PropertyList_ 不包含 _item_，则
                  1. 将 _item_ 追加到 _PropertyList_。
                1. 设 _k_ 为 _k_ + 1。
        1. 若 _space_ 是 Object，则
          1. 若 _space_ 具有 [[NumberData]] 内部槽，则
            1. 设 _space_ 为 ? ToNumber(_space_)。
          1. 否则若 _space_ 具有 [[StringData]] 内部槽，则
            1. 设 _space_ 为 ? ToString(_space_)。
        1. 若 _space_ 是 Number，则
          1. 令 _spaceMV_ 为 ! ToIntegerOrInfinity(_space_)。
          1. 设 _spaceMV_ 为 min(10, _spaceMV_)。
          1. 若 _spaceMV_ &lt; 1，令 _gap_ 为空字符串；否则令 _gap_ 为包含 _spaceMV_ 个代码单元 0x0020 (SPACE) 的字符串。
        1. 否则若 _space_ 是 String，则
          1. 若 _space_ 长度 ≤ 10，令 _gap_ 为 _space_；否则令 _gap_ 为 _space_ 的前 10 个代码单元子串。
        1. 否则，
          1. 令 _gap_ 为空字符串。
        1. 令 _wrapper_ 为 OrdinaryObjectCreate(%Object.prototype%)。
        1. 执行 ! CreateDataPropertyOrThrow(_wrapper_, 空字符串, _value_)。
        1. 令 _state_ 为 JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }。
        1. 返回 ? SerializeJSONProperty(_state_, 空字符串, _wrapper_)。
      </emu-alg>
      <p>该函数的 *"length"* 属性为 *3*<sub>𝔽</sub>。</p>
      <emu-note>
        <p>JSON 结构允许任意深度嵌套，但必须非循环。若 _value_ 是或包含循环结构，则该函数必须抛出 *TypeError* 异常。如下是一个不可字符串化的值示例：</p>
        <pre><code class="javascript">
          a = [];
          a[0] = a;
          my_text = JSON.stringify(a); // 必须抛出 TypeError。
        </code></pre>
      </emu-note>
      <emu-note>
        <p>符号化的原始值呈现如下：</p>
        <ul>
          <li>*null* 在 JSON 文本中呈现为字符串值 *"null"*。</li>
          <li>*undefined* 不呈现。</li>
          <li>*true* 在 JSON 文本中呈现为字符串值 *"true"*。</li>
          <li>*false* 在 JSON 文本中呈现为字符串值 *"false"*。</li>
        </ul>
      </emu-note>
      <emu-note>
        <p>字符串值以 QUOTATION MARK (`"`) 代码单元包裹。代码单元 `"` 与 `\\` 以 `\\` 前缀转义。控制字符代码单元替换为 `\\u`HHHH 转义序列，或更短形式 `\\b`（BACKSPACE）、`\\f`（FORM FEED）、`\\n`（LINE FEED）、`\\r`（CARRIAGE RETURN）、`\\t`（CHARACTER TABULATION）。</p>
      </emu-note>
      <emu-note>
        <p>有限数字按调用 ToString(_number_) 的方式字符串化。*NaN* 与任意符号的 *Infinity* 表示为字符串值 *"null"*。</p>
      </emu-note>
      <emu-note>
        <p>没有 JSON 表示的值（如 *undefined* 与函数）不产生字符串，而产生 *undefined* 值。在数组中这些值表示为字符串值 *"null"*；在对象中不可表示的值会使该属性被排除。</p>
      </emu-note>
      <emu-note>
        <p>对象呈现为 U+007B (LEFT CURLY BRACKET) 后跟零个或多个属性，以 U+002C (COMMA) 分隔，以 U+007D (RIGHT CURLY BRACKET) 结束。属性由表示属性名的带引号字符串、一个 U+003A (COLON) 与字符串化的属性值组成。数组呈现为 U+005B (LEFT SQUARE BRACKET) 开头，零个或多个值以 U+002C (COMMA) 分隔，以 U+005D (RIGHT SQUARE BRACKET) 结束。</p>
      </emu-note>

      <emu-clause id="sec-json-serialization-record">
        <h1>JSON Serialization Record</h1>
        <p><dfn variants="JSON Serialization Records">JSON Serialization Record</dfn> 是一个 Record 值，用于实现向 JSON 格式的序列化。</p>
        <p>JSON Serialization Record 拥有 <emu-xref href="#table-json-serialization-record"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-json-serialization-record" caption="JSON Serialization Record 字段">
          <table>
            <thead>
              <tr>
                <th>字段名</th>
                <th>取值</th>
                <th>含义</th>
              </tr>
            </thead>
            <tr>
              <td>[[ReplacerFunction]]</td>
              <td>一个函数对象或 *undefined*</td>
              <td>可为对象属性提供替换值的函数（来自 JSON.stringify 的 _replacer_ 参数）。</td>
            </tr>
            <tr>
              <td>[[PropertyList]]</td>
              <td>一个 String 的 List 或 *undefined*</td>
              <td>序列化非数组对象时包含的属性名（来自 _replacer_ 参数）。</td>
            </tr>
            <tr>
              <td>[[Gap]]</td>
              <td>一个 String</td>
              <td>缩进单元（来自 _space_ 参数）。</td>
            </tr>
            <tr>
              <td>[[Stack]]</td>
              <td>一个对象的 List</td>
              <td>正在序列化的嵌套对象集合，用于检测循环结构。</td>
            </tr>
            <tr>
              <td>[[Indent]]</td>
              <td>一个 String</td>
              <td>当前缩进。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-serializejsonproperty" type="abstract operation">
        <h1>
          SerializeJSONProperty (
            _state_: a JSON Serialization Record,
            _key_: a String,
            _holder_: an Object,
          ): 要么是包含一个 String 或 *undefined* 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _value_ 为 ? Get(_holder_, _key_)。
          1. 若 _value_ 是 Object 或 _value_ 是 BigInt，则
            1. 令 _toJSON_ 为 ? GetV(_value_, *"toJSON"*)。
            1. 若 IsCallable(_toJSON_) 为 *true*，则
              1. 设 _value_ 为 ? Call(_toJSON_, _value_, « _key_ »)。
          1. 若 _state_.[[ReplacerFunction]] 不为 *undefined*，则
            1. 设 _value_ 为 ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »)。
          1. 若 _value_ 是 Object，则
            1. 若 _value_ 有 [[NumberData]] 内部槽，则
              1. 设 _value_ 为 ? ToNumber(_value_)。
            1. 否则若有 [[StringData]] 内部槽，则
              1. 设 _value_ 为 ? ToString(_value_)。
            1. 否则若有 [[BooleanData]] 内部槽，则
              1. 设 _value_ 为 _value_.[[BooleanData]]。
            1. 否则若有 [[BigIntData]] 内部槽，则
              1. 设 _value_ 为 _value_.[[BigIntData]]。
          1. 若 _value_ 为 *null*，返回 *"null"*。
          1. 若 _value_ 为 *true*，返回 *"true"*。
          1. 若 _value_ 为 *false*，返回 *"false"*。
          1. 若 _value_ 为 String，返回 QuoteJSONString(_value_)。
          1. 若 _value_ 为 Number，则
            1. 若 _value_ 有限，返回 ! ToString(_value_)。
            1. 返回 *"null"*。
          1. 若 _value_ 为 BigInt，抛出 *TypeError* 异常。
          1. 若 _value_ 是 Object 且 IsCallable(_value_) 为 *false*，则
            1. 令 _isArray_ 为 ? IsArray(_value_)。
            1. 若 _isArray_ 为 *true*，返回 ? SerializeJSONArray(_state_, _value_)。
            1. 返回 ? SerializeJSONObject(_state_, _value_)。
          1. 返回 *undefined*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-quotejsonstring" type="abstract operation">
        <h1>
          QuoteJSONString (
            _value_: a String,
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>将 _value_ 用 0x0022 (QUOTATION MARK) 代码单元包裹并对其中某些代码单元转义。该操作将 _value_ 视作 UTF-16 编码的代码点序列，详见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>。</dd>
        </dl>
        <emu-alg>
          1. 令 _product_ 为仅由代码单元 0x0022 (QUOTATION MARK) 组成的字符串值。
          1. 对 StringToCodePoints(_value_) 的每个代码点 _C_，执行
            1. 若 _C_ 列于 <emu-xref href="#table-json-single-character-escapes"></emu-xref> “Code Point” 列，则
              1. 设 _product_ 为 _product_ 与该行 “Escape Sequence” 列中转义序列的连接。
            1. 否则若 _C_ 数值小于 0x0020 (SPACE) 或与某前导代理或后导代理数值相同，则
              1. 令 _unit_ 为数值等于 _C_ 数值的代码单元。
              1. 设 _product_ 为 _product_ 与 UnicodeEscape(_unit_) 的连接。
            1. 否则，
              1. 设 _product_ 为 _product_ 与 UTF16EncodeCodePoint(_C_) 的连接。
          1. 设 _product_ 为 _product_ 与代码单元 0x0022 (QUOTATION MARK) 的连接。
          1. 返回 _product_。
        </emu-alg>
        <emu-table id="table-json-single-character-escapes" caption="JSON 单字符转义序列">
          <table>
            <thead>
              <tr>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode 字符名称
                </th>
                <th>
                  转义序列
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                U+0008
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                `\\b`
              </td>
            </tr>
            <tr>
              <td>
                U+0009
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                `\\t`
              </td>
            </tr>
            <tr>
              <td>
                U+000A
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                `\\n`
              </td>
            </tr>
            <tr>
              <td>
                U+000C
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                `\\f`
              </td>
            </tr>
            <tr>
              <td>
                U+000D
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                `\\r`
              </td>
            </tr>
            <tr>
              <td>
                U+0022
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `\\"`
              </td>
            </tr>
            <tr>
              <td>
                U+005C
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\\\`
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unicodeescape" type="abstract operation">
        <h1>
          UnicodeEscape (
            _C_: a code unit,
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>以 Unicode 转义序列表示 _C_。</dd>
        </dl>
        <emu-alg>
          1. 令 _n_ 为 _C_ 的数值。
          1. 断言：_n_ ≤ 0xFFFF。
          1. 令 _hex_ 为 _n_ 的字符串表示，按小写十六进制格式。
          1. 返回代码单元 0x005C (REVERSE SOLIDUS)、*"u"* 与 StringPad(_hex_, 4, *"0"*, ~start~) 的字符串连接。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonobject" type="abstract operation">
        <h1>
          SerializeJSONObject (
            _state_: a JSON Serialization Record,
            _value_: an Object,
          ): 要么是包含一个 String 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>序列化一个对象。</dd>
        </dl>
        <emu-alg>
          1. 若 _state_.[[Stack]] 包含 _value_，抛出 *TypeError* 异常（结构循环）。
          1. 将 _value_ 追加到 _state_.[[Stack]]。
          1. 令 _stepBack_ 为 _state_.[[Indent]]。
          1. 设 _state_.[[Indent]] 为 _state_.[[Indent]] 与 _state_.[[Gap]] 的连接。
          1. 若 _state_.[[PropertyList]] 不为 *undefined*，则
            1. 令 _K_ 为 _state_.[[PropertyList]]。
          1. 否则，
            1. 令 _K_ 为 ? EnumerableOwnProperties(_value_, ~key~)。
          1. 令 _partial_ 为新空 List。
          1. 对 _K_ 的每个元素 _P_，执行
            1. 令 _strP_ 为 ? SerializeJSONProperty(_state_, _P_, _value_)。
            1. 若 _strP_ 不为 *undefined*，则
              1. 令 _member_ 为 QuoteJSONString(_P_)。
              1. 设 _member_ 为 _member_ 与 *":"* 的连接。
              1. 若 _state_.[[Gap]] 非空字符串，则
                1. 设 _member_ 为 _member_ 与代码单元 0x0020 (SPACE) 的连接。
              1. 设 _member_ 为 _member_ 与 _strP_ 的连接。
              1. 将 _member_ 追加到 _partial_。
          1. 若 _partial_ 为空，则
            1. 令 _final_ 为 *"{}"*。
          1. 否则，
            1. 若 _state_.[[Gap]] 为空字符串，则
              1. 令 _properties_ 为以代码单元 0x002C (COMMA) 分隔连接 _partial_ 中所有元素字符串的结果（不在首尾插入逗号）。
              1. 令 _final_ 为 *"{"*、_properties_、*"}"* 的连接。
            1. 否则，
              1. 令 _separator_ 为代码单元 0x002C (COMMA)、代码单元 0x000A (LINE FEED) 与 _state_.[[Indent]] 的连接。
              1. 令 _properties_ 为以 _separator_ 分隔连接 _partial_ 所有元素字符串的结果（不在首尾插入分隔符）。
              1. 令 _final_ 为 *"{"*、代码单元 0x000A (LINE FEED)、_state_.[[Indent]]、_properties_、代码单元 0x000A (LINE FEED)、_stepBack_ 与 *"}"* 的连接。
          1. 移除 _state_.[[Stack]] 的最后一个元素。
          1. 设 _state_.[[Indent]] 为 _stepBack_。
          1. 返回 _final_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonarray" type="abstract operation">
        <h1>
          SerializeJSONArray (
            _state_: a JSON Serialization Record,
            _value_: an ECMAScript language value,
          ): 要么是包含一个 String 的正常完成要么是抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>序列化一个数组。</dd>
        </dl>
        <emu-alg>
          1. 若 _state_.[[Stack]] 包含 _value_，抛出 *TypeError* 异常（结构循环）。
          1. 将 _value_ 追加到 _state_.[[Stack]]。
          1. 令 _stepBack_ 为 _state_.[[Indent]]。
          1. 设 _state_.[[Indent]] 为 _state_.[[Indent]] 与 _state_.[[Gap]] 的连接。
          1. 令 _partial_ 为新空 List。
          1. 令 _len_ 为 ? LengthOfArrayLike(_value_)。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _len_ 重复，
            1. 令 _strP_ 为 ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_)。
            1. 若 _strP_ 为 *undefined*，则
              1. 将 *"null"* 追加到 _partial_。
            1. 否则，
              1. 将 _strP_ 追加到 _partial_。
            1. 设 _index_ 为 _index_ + 1。
          1. 若 _partial_ 为空，则
            1. 令 _final_ 为 *"[]"*。
          1. 否则，
            1. 若 _state_.[[Gap]] 为空字符串，则
              1. 令 _properties_ 为以代码单元 0x002C (COMMA) 分隔连接 _partial_ 所有元素字符串的结果（不在首尾插入逗号）。
              1. 令 _final_ 为 *"["*、_properties_、*"]"* 的连接。
            1. 否则，
              1. 令 _separator_ 为代码单元 0x002C (COMMA)、代码单元 0x000A (LINE FEED) 与 _state_.[[Indent]] 的连接。
              1. 令 _properties_ 为以 _separator_ 分隔连接 _partial_ 所有元素字符串的结果（不在首尾插入分隔符）。
              1. 令 _final_ 为 *"["*、代码单元 0x000A (LINE FEED)、_state_.[[Indent]]、_properties_、代码单元 0x000A (LINE FEED)、_stepBack_ 与 *"]"* 的连接。
          1. 移除 _state_.[[Stack]] 的最后一个元素。
          1. 设 _state_.[[Indent]] 为 _stepBack_。
          1. 返回 _final_。
        </emu-alg>
        <emu-note>
          <p>数组表示仅包含从 *+0*<sub>𝔽</sub>（含）到 `array.length`（不含）的元素。键不是数组索引的属性被排除。数组字符串化为左方括号、元素（以逗号分隔）与右方括号。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-json-@@tostringtag" id="sec-json-%symbol.tostringtag%">
      <h1>JSON [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% 属性的初始值是字符串 *"JSON"*。</p>
      <p>该属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>内存管理（Managing Memory）</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef 对象</h1>
    <p>WeakRef 是一种对象，用于引用一个目标对象或 symbol，同时不阻止其被垃圾回收。如果目标尚未被垃圾回收，WeakRef 可以被解引用以访问该目标值。</p>

    <emu-clause id="sec-weak-ref-constructor">
      <h1>WeakRef 构造函数</h1>
      <p><dfn variants="WeakRefs">WeakRef</dfn> 构造函数：</p>
      <ul>
        <li>是 <dfn>%WeakRef%</dfn>。</li>
        <li>
          是全局对象 *"WeakRef"* 属性的初始值。
        </li>
        <li>
          作为构造函数调用时创建并初始化一个新的 WeakRef。
        </li>
        <li>
          不应作为普通函数调用；若以此方式调用将抛出异常。
        </li>
        <li>
          可作为类定义 `extends` 子句中的值。希望继承指定 `WeakRef` 行为的子类构造函数必须包含对 `WeakRef` 构造函数的 `super` 调用，以创建并初始化具有支持 `WeakRef.prototype` 内置方法所需内部状态的子类实例。
        </li>
      </ul>

      <emu-clause id="sec-weak-ref-target">
        <h1>WeakRef ( _target_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 如果 CanBeHeldWeakly(_target_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _weakRef_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakRef.prototype%"*, « [[WeakRefTarget]] »)。
          1. 执行 AddToKeptObjects(_target_)。
          1. 将 _weakRef_.[[WeakRefTarget]] 设为 _target_。
          1. 返回 _weakRef_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor">
      <h1>WeakRef 构造函数的属性</h1>
      <p>WeakRef 构造函数：</p>
      <ul>
        <li>
          有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
        </li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype">
        <h1>WeakRef.prototype</h1>
        <p>`WeakRef.prototype` 的初始值是 WeakRef 原型对象。</p>
        <p>该属性的特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-prototype-object">
      <h1>WeakRef 原型对象的属性</h1>
      <p><dfn>WeakRef 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%WeakRef.prototype%</dfn>。</li>
        <li>
          有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
        </li>
        <li>是一个普通对象。</li>
        <li>没有 [[WeakRefTarget]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype.constructor" normative-optional>
        <h1>WeakRef.prototype.constructor</h1>

        <p>`WeakRef.prototype.constructor` 的初始值是 %WeakRef%。</p>
      </emu-clause>

      <emu-clause id="sec-weak-ref.prototype.deref">
        <h1>WeakRef.prototype.deref ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _weakRef_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]])。
          1. 返回 WeakRefDeref(_weakRef_)。
        </emu-alg>

        <emu-note>
          <p>如果 WeakRef 返回的 _target_ 值不是 *undefined*，那么该 _target_ 值在当前这次 ECMAScript 代码执行完成之前不应被垃圾回收。AddToKeptObjects 操作用于确保读取一致性。</p>

          <pre><code class="javascript">
            let target = { foo() {} };
            let weakRef = new WeakRef(target);

            // ... 稍后 ...

            if (weakRef.deref()) {
              weakRef.deref().foo();
            }
          </code></pre>

          <p>在上述示例中，如果第一次 deref 的结果不是 *undefined*，则第二次 deref 的结果也不可能是 *undefined*。</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-weak-ref.prototype-@@tostringtag" id="sec-weak-ref.prototype-%symbol.tostringtag%">
        <h1>WeakRef.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"WeakRef"*。</p>
        <p>该属性的特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-weakref-abstract-operations">
      <h1>WeakRef 抽象操作</h1>

      <emu-clause id="sec-weakrefderef" type="abstract operation">
        <h1>
          WeakRefDeref (
            _weakRef_: a WeakRef,
          ): an ECMAScript language value
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _target_ 为 _weakRef_.[[WeakRefTarget]]。
          1. 如果 _target_ 不为 ~empty~，则
            1. 执行 AddToKeptObjects(_target_)。
            1. 返回 _target_。
          1. 返回 *undefined*。
        </emu-alg>
        <emu-note>
          <p>该抽象操作与 WeakRef.prototype.deref 分开定义，仅是为了能简洁地定义存活性。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weak-ref-instances">
      <h1>WeakRef 实例的属性</h1>
      <p>WeakRef 实例是从 WeakRef 原型对象继承属性的普通对象。WeakRef 实例还具有 [[WeakRefTarget]] 内部槽。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry 对象</h1>
    <p>FinalizationRegistry 是一个对象，用于管理目标对象与 symbol 被垃圾回收时执行的清理操作的注册与取消注册。</p>

    <emu-clause id="sec-finalization-registry-constructor">
      <h1>FinalizationRegistry 构造函数</h1>
      <p><dfn variants="FinalizationRegistrys">FinalizationRegistry</dfn> 构造函数：</p>
      <ul>
        <li>是 <dfn>%FinalizationRegistry%</dfn>。</li>
        <li>
          是全局对象 *"FinalizationRegistry"* 属性的初始值。
        </li>
        <li>
          作为构造函数调用时创建并初始化一个新的 FinalizationRegistry。
        </li>
        <li>
          不应作为普通函数调用；若以此方式调用将抛出异常。
        </li>
        <li>
          可作为类定义 `extends` 子句中的值。希望继承指定 `FinalizationRegistry` 行为的子类构造函数必须包含对 `FinalizationRegistry` 构造函数的 `super` 调用，以创建并初始化具有支持 `FinalizationRegistry.prototype` 内置方法所需内部状态的子类实例。
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry-cleanup-callback">
        <h1>FinalizationRegistry ( _cleanupCallback_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 如果 IsCallable(_cleanupCallback_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _finalizationRegistry_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%FinalizationRegistry.prototype%"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »)。
          1. 令 _fn_ 为活动函数对象。
          1. 将 _finalizationRegistry_.[[Realm]] 设为 _fn_.[[Realm]]。
          1. 将 _finalizationRegistry_.[[CleanupCallback]] 设为 HostMakeJobCallback(_cleanupCallback_)。
          1. 将 _finalizationRegistry_.[[Cells]] 设为一个新的空 List。
          1. 返回 _finalizationRegistry_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor">
      <h1>FinalizationRegistry 构造函数的属性</h1>
      <p>FinalizationRegistry 构造函数：</p>
      <ul>
        <li>
          有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。
        </li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype">
        <h1>FinalizationRegistry.prototype</h1>
        <p>`FinalizationRegistry.prototype` 的初始值是 FinalizationRegistry 原型对象。</p>
        <p>该属性的特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-prototype-object">
      <h1>FinalizationRegistry 原型对象的属性</h1>
      <p><dfn>FinalizationRegistry 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%FinalizationRegistry.prototype%</dfn>。</li>
        <li>
          有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。
        </li>
        <li>是一个普通对象。</li>
        <li>
          没有 [[Cells]] 和 [[CleanupCallback]] 内部槽。
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype.constructor">
        <h1>FinalizationRegistry.prototype.constructor</h1>
        <p>`FinalizationRegistry.prototype.constructor` 的初始值是 %FinalizationRegistry%。</p>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.register">
        <h1>FinalizationRegistry.prototype.register ( _target_, _heldValue_ [ , _unregisterToken_ ] )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _finalizationRegistry_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_finalizationRegistry_, [[Cells]])。
          1. 如果 CanBeHeldWeakly(_target_) 为 *false*，抛出 *TypeError* 异常。
          1. 如果 SameValue(_target_, _heldValue_) 为 *true*，抛出 *TypeError* 异常。
          1. 如果 CanBeHeldWeakly(_unregisterToken_) 为 *false*，则
            1. 如果 _unregisterToken_ 不是 *undefined*，抛出 *TypeError* 异常。
            1. 将 _unregisterToken_ 设为 ~empty~。
          1. 令 _cell_ 为 Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }。
          1. 将 _cell_ 追加到 _finalizationRegistry_.[[Cells]]。
          1. 返回 *undefined*。
        </emu-alg>

        <emu-note>
          <p>基于本规范中的算法与定义，当 _finalizationRegistry_.[[Cells]] 包含 _cell_ 时，_cell_.[[HeldValue]] 是存活的；然而这并不一定意味着 _cell_.[[UnregisterToken]] 或 _cell_.[[Target]] 是存活的。例如，用对象自身作为其注销标记（unregister token）进行注册并不会使该对象永久存活。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.unregister">
        <h1>FinalizationRegistry.prototype.unregister ( _unregisterToken_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _finalizationRegistry_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_finalizationRegistry_, [[Cells]])。
          1. 如果 CanBeHeldWeakly(_unregisterToken_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _removed_ 为 *false*。
          1. 对 _finalizationRegistry_.[[Cells]] 中的每个 Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_，执行
            1. 如果 _cell_.[[UnregisterToken]] 不为 ~empty~ 且 SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) 为 *true*，则
              1. 从 _finalizationRegistry_.[[Cells]] 中移除 _cell_。
              1. 将 _removed_ 设为 *true*。
          1. 返回 _removed_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-finalization-registry.prototype-@@tostringtag" id="sec-finalization-registry.prototype-%symbol.tostringtag%">
        <h1>FinalizationRegistry.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"FinalizationRegistry"*。</p>
        <p>该属性的特性为 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-finalization-registry-instances">
      <h1>FinalizationRegistry 实例的属性</h1>
      <p>FinalizationRegistry 实例是从 FinalizationRegistry 原型对象继承属性的普通对象。FinalizationRegistry 实例还具有 [[Cells]] 与 [[CleanupCallback]] 内部槽。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>控制抽象对象</h1>

  <emu-clause id="sec-iteration">
    <h1>迭代</h1>

    <emu-clause id="sec-common-iteration-interfaces">
      <h1>通用迭代接口</h1>
      <p>接口是其关联值符合特定规范的一组属性键。任何对象只要提供了接口规范中描述的全部属性，就<em>符合</em>该接口。一个接口不由单独的对象来表示。可能存在许多独立实现且符合同一接口的对象。单个对象也可以同时符合多个接口。</p>

      <emu-clause id="sec-iterable-interface">
        <h1>Iterable 接口</h1>
        <p><dfn variants="iterable,iterables,iterable object,iterable objects">iterable interface</dfn> 包含 <emu-xref href="#table-iterable-interface-required-properties"></emu-xref> 中描述的属性：</p>
        <emu-table id="table-iterable-interface-required-properties" caption="Iterable 接口所需属性" oldids="table-52">
          <table>
            <thead>
              <tr>
                <th>
                  属性
                </th>
                <th>
                  值
                </th>
                <th>
                  要求
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `%Symbol.iterator%`
              </td>
              <td>
                一个返回迭代器对象的函数
              </td>
              <td>
                返回的对象必须符合 iterator 接口。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-iterator-interface">
        <h1>Iterator 接口</h1>
        <p>实现 <dfn variants="iterator object,iterator objects,iterator,iterators">iterator interface</dfn> 的对象必须包含 <emu-xref href="#table-iterator-interface-required-properties"></emu-xref> 中的属性。此类对象也可以实现 <emu-xref href="#table-iterator-interface-optional-properties"></emu-xref> 中的可选属性。</p>
        <emu-table id="table-iterator-interface-required-properties" caption="Iterator 接口所需属性" oldids="table-53">
          <table>
            <thead>
              <tr>
                <th>
                  属性
                </th>
                <th>
                  值
                </th>
                <th>
                  要求
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"next"*
              </td>
              <td>
                一个返回 IteratorResult 对象的函数
              </td>
              <td>
                返回的对象必须符合 IteratorResult 接口。如果之前对该迭代器的 `next` 方法的一次调用返回了 *"done"* 属性为 *true* 的 IteratorResult 对象，则后续对此对象的所有 `next` 调用也应当返回 *"done"* 属性为 *true* 的 IteratorResult 对象。然而，该要求不强制执行。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>可以向 `next` 函数传递参数，但其含义与合法性取决于目标迭代器。for-of 语句及其他常见迭代器使用者不会传递任何参数，所以期望以这种方式使用的迭代器对象必须准备好在无参数情况下被调用。</p>
        </emu-note>
        <emu-table id="table-iterator-interface-optional-properties" caption="Iterator 接口可选属性" oldids="table-54">
          <table>
            <thead>
              <tr>
                <th>
                  属性
                </th>
                <th>
                  值
                </th>
                <th>
                  要求
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"return"*
              </td>
              <td>
                一个返回 IteratorResult 对象的函数
              </td>
              <td>
                返回的对象必须符合 IteratorResult 接口。调用此方法通知迭代器对象调用方不打算再进行任何 `next` 方法调用。返回的 IteratorResult 对象通常具有 *"done"* 属性值为 *true*，并且 *"value"* 属性为传给 `return` 方法的参数值。然而，这一要求不强制执行。
              </td>
            </tr>
            <tr>
              <td>
                *"throw"*
              </td>
              <td>
                一个返回 IteratorResult 对象的函数
              </td>
              <td>
                返回的对象必须符合 IteratorResult 接口。调用此方法通知迭代器对象调用方检测到错误条件。该参数可用于标识错误条件，通常会是一个异常对象。典型响应是 `throw` 传入的参数值。如果该方法未 `throw`，返回的 IteratorResult 对象通常具有 *"done"* 属性值为 *true*。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>通常这些方法的调用方在调用前应检查其是否存在。包括 `for`-`of`、`yield*` 和数组解构在内的某些 ECMAScript 语言特性会在进行存在性检查后调用这些方法。大多数接受 iterable 对象作为参数的 ECMAScript 库函数也会有条件地调用它们。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-asynciterable-interface">
        <h1>Async Iterable 接口</h1>
        <p><dfn variants="async iterable,async iterables,async iterable object,async iterable objects">async iterable interface</dfn> 包含 <emu-xref href="#table-async-iterable"></emu-xref> 中描述的属性：</p>
        <emu-table id="table-async-iterable" caption="Async Iterable 接口所需属性">
          <table>
            <thead>
              <tr>
                <th>属性</th>
                <th>值</th>
                <th>要求</th>
              </tr>
            </thead>
            <tr>
              <td>`%Symbol.asyncIterator%`</td>
              <td>一个返回 async 迭代器对象的函数</td>
              <td>返回的对象必须符合 async iterator 接口。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asynciterator-interface">
        <h1>Async Iterator 接口</h1>
        <p>实现 <dfn variants="async iterator object,async iterator objects,async iterator,async iterators">async iterator interface</dfn> 的对象必须包含 <emu-xref href="#table-async-iterator-required"></emu-xref> 中的属性。此类对象也可以实现 <emu-xref href="#table-async-iterator-optional"></emu-xref> 中的属性。</p>
        <emu-table id="table-async-iterator-required" caption="Async Iterator 接口所需属性">
          <table>
            <thead>
              <tr>
                <th>属性</th>
                <th>值</th>
                <th>要求</th>
              </tr>
            </thead>
            <tr>
              <td>*"next"*</td>
              <td>一个返回 Promise（兑现为 IteratorResult 对象）的函数</td>
              <td>
                <p>返回的 promise 在兑现时，必须以符合 IteratorResult 接口的对象兑现。如果之前对某 async 迭代器的 `next` 方法的一次调用返回了一个其 *"done"* 属性为 *true* 的 IteratorResult 对象的 promise，则后续对该对象的所有 `next` 调用也应返回 *"done"* 属性为 *true* 的 IteratorResult 对象的 promise。然而，该要求不强制执行。</p>

                <p>另外，作为兑现值的 IteratorResult 对象的 *"value"* 属性的值应当不是一个 promise（或 “thenable”）。不过，这一要求同样不强制执行。</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>可以向 `next` 函数传递参数，但其解释与有效性取决于目标 async 迭代器。`for`-`await`-`of` 语句及其他常见 async 迭代器使用者不会传递任何参数，因此期望这样使用的 async 迭代器对象必须准备好在无参数情况下被调用。</p>
        </emu-note>
        <emu-table id="table-async-iterator-optional" caption="Async Iterator 接口可选属性">
          <table>
            <thead>
              <tr>
                <th>属性</th>
                <th>值</th>
                <th>要求</th>
              </tr>
            </thead>
            <tr>
              <td>*"return"*</td>
              <td>一个返回 Promise（兑现为 IteratorResult 对象）的函数</td>
              <td>
                <p>返回的 promise 在兑现时，必须以符合 IteratorResult 接口的对象兑现。调用此方法通知 async 迭代器对象调用方不打算再对该 async 迭代器进行更多 `next` 调用。返回的 promise 将兑现为 IteratorResult 对象，该对象通常具有 *"done"* 属性值为 *true*，以及 *"value"* 属性为传给 `return` 方法的参数值。然而，这一要求不强制执行。</p>

                <p>另外，作为兑现值的 IteratorResult 对象的 *"value"* 属性应当不是一个 promise（或 “thenable”）。如果参数值按典型方式使用，且其为一个被拒绝的 promise，则应返回一个以相同原因拒绝的 promise；如果其为一个已兑现的 promise，则其兑现值应作为返回 promise 的 IteratorResult 对象的 *"value"* 属性。然而，这些要求同样不强制执行。</p>
              </td>
            </tr>
            <tr>
              <td>*"throw"*</td>
              <td>一个返回 Promise（兑现为 IteratorResult 对象）的函数</td>
              <td>
                <p>返回的 promise 在兑现时，必须以符合 IteratorResult 接口的对象兑现。调用此方法通知 async 迭代器对象调用方已检测到错误条件。参数可用于标识该错误条件，并且通常为一个异常对象。典型响应是返回一个以该参数值拒绝的被拒绝 promise。</p>

                <p>如果返回的 promise 被兑现，IteratorResult 对象兑现值通常具有 *"done"* 属性值为 *true*。此外，它应当具有 *"value"* 属性，其值不是一个 promise（或 “thenable”），但该要求不强制执行。</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>通常这些方法的调用方在调用前应检查其是否存在。包括 `for`-`await`-`of` 和 `yield*` 在内的某些 ECMAScript 语言特性会在进行存在性检查后调用这些方法。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iteratorresult-interface">
        <h1>IteratorResult 接口</h1>
        <p><dfn variants="IteratorResult object,IteratorResult objects">IteratorResult interface</dfn> 包含 <emu-xref href="#table-iteratorresult-interface-properties"></emu-xref> 中列出的属性：</p>
        <emu-table id="table-iteratorresult-interface-properties" caption="IteratorResult 接口属性" oldids="table-55">
          <table>
            <thead>
              <tr>
                <th>
                  属性
                </th>
                <th>
                  值
                </th>
                <th>
                  要求
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"done"*
              </td>
              <td>
                一个 Boolean
              </td>
              <td>
                这是迭代器 `next` 方法调用的结果状态。如果已到达迭代器末尾，*"done"* 为 *true*。如果未到达末尾，*"done"* 为 *false* 且存在一个可用的值。如果不存在（自有或继承的）*"done"* 属性，则视为其值为 *false*。
              </td>
            </tr>
            <tr>
              <td>
                *"value"*
              </td>
              <td>
                一个 ECMAScript 语言值
              </td>
              <td>
                如果 done 为 *false*，这是当前迭代元素值。如果 done 为 *true*，这是迭代器的返回值（如果提供）。若迭代器没有返回值，*"value"* 为 *undefined*。在此情况下，如果对象未继承显式的 *"value"* 属性，则可从符合规范的对象中省略该 *"value"* 属性。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-helper-objects">
      <h1>迭代器辅助（Iterator Helper）对象</h1>
      <p><dfn variants="Iterator Helper objects">Iterator Helper object</dfn> 是一个普通对象，表示对某个特定源迭代器对象的惰性转换。Iterator Helper 对象没有具名构造函数。相反，它们通过调用 Iterator 实例对象的特定方法创建。</p>

      <emu-clause id="sec-%iteratorhelperprototype%-object">
        <h1>%IteratorHelperPrototype% 对象</h1>
        <p><dfn>%IteratorHelperPrototype%</dfn> 对象：</p>
        <ul>
          <li>具有所有 Iterator Helper 对象继承的属性。</li>
          <li>是一个普通对象。</li>
          <li>具有一个 [[Prototype]] 内部槽，其值为 %Iterator.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%iteratorhelperprototype%.next">
          <h1>%IteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? GeneratorResume(*this* value, *undefined*, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%.return">
          <h1>%IteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. 令 _O_ 为 *this* 值。
            1. 执行 ? RequireInternalSlot(_O_, [[UnderlyingIterator]]).
            1. 断言：_O_ 具有 [[GeneratorState]] 内部槽。
            1. 若 _O_.[[GeneratorState]] 为 ~suspended-start~，则
              1. 设 _O_.[[GeneratorState]] 为 ~completed~。
              1. 注：一旦生成器进入 completed 状态，它将不再离开该状态，且其关联的执行上下文不再被恢复。与 _O_ 关联的任何执行状态此时都可被丢弃。
              1. 执行 ? IteratorClose(_O_.[[UnderlyingIterator]], NormalCompletion(~unused~)).
              1. 返回 CreateIteratorResultObject(*undefined*, *true*)。
            1. 令 _C_ 为 ReturnCompletion(*undefined*)。
            1. 返回 ? GeneratorResumeAbrupt(_O_, _C_, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%-%symbol.tostringtag%">
          <h1>%IteratorHelperPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>%Symbol.toStringTag% 属性的初始值是字符串值 *"Iterator Helper"*。</p>
          <p>此属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-objects">
      <h1>迭代器对象</h1>

      <emu-clause id="sec-iterator-constructor">
        <h1>Iterator 构造函数</h1>
        <p><dfn>Iterator</dfn> 构造函数：</p>
        <ul>
          <li>是 <dfn>%Iterator%</dfn>。</li>
          <li>是全局对象 *"Iterator"* 属性的初始值。</li>
          <li>被设计为可子类化。它可用作类定义的 *extends* 子句的值。</li>
        </ul>

        <emu-clause id="sec-iterator">
          <h1>Iterator ( )</h1>
          <p>当调用此函数时，执行以下步骤：</p>
          <emu-alg>
            1. 若 NewTarget 为 *undefined* 或为活动函数对象，抛出一个 *TypeError* 异常。
            1. 返回 ? OrdinaryCreateFromConstructor(NewTarget, *"%Iterator.prototype%"*)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-iterator-constructor">
        <h1>Iterator 构造函数的属性</h1>
        <p>Iterator 构造函数：</p>
        <ul>
          <li>具有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-iterator.from">
          <h1>Iterator.from ( _O_ )</h1>
          <emu-alg>
            1. 令 _iteratorRecord_ 为 ? GetIteratorFlattenable(_O_, ~iterate-string-primitives~)。
            1. 令 _hasInstance_ 为 ? OrdinaryHasInstance(%Iterator%, _iteratorRecord_.[[Iterator]])。
            1. 若 _hasInstance_ 为 *true*，则
              1. 返回 _iteratorRecord_.[[Iterator]]。
            1. 令 _wrapper_ 为 OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] »)。
            1. 设 _wrapper_.[[Iterated]] 为 _iteratorRecord_。
            1. 返回 _wrapper_。
          </emu-alg>

          <emu-clause id="sec-%wrapforvaliditeratorprototype%-object">
            <h1>%WrapForValidIteratorPrototype% 对象</h1>
            <p><dfn>%WrapForValidIteratorPrototype%</dfn> 对象：</p>
            <ul>
              <li>是一个普通对象。</li>
              <li>具有一个 [[Prototype]] 内部槽，其值为 %Iterator.prototype%。</li>
            </ul>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.next">
              <h1>%WrapForValidIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. 令 _O_ 为 *this* 值。
                1. 执行 ? RequireInternalSlot(_O_, [[Iterated]]).
                1. 令 _iteratorRecord_ 为 _O_.[[Iterated]]。
                1. 返回 ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]])。
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.return">
              <h1>%WrapForValidIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. 令 _O_ 为 *this* 值。
                1. 执行 ? RequireInternalSlot(_O_, [[Iterated]]).
                1. 令 _iterator_ 为 _O_.[[Iterated]].[[Iterator]]。
                1. 断言：_iterator_ 是一个 Object。
                1. 令 _returnMethod_ 为 ? GetMethod(_iterator_, *"return"*)。
                1. 若 _returnMethod_ 为 *undefined*，则
                  1. 返回 CreateIteratorResultObject(*undefined*, *true*)。
                1. 返回 ? Call(_returnMethod_, _iterator_)。
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype">
          <h1>Iterator.prototype</h1>
          <p>Iterator.prototype 的初始值是 Iterator 原型对象。</p>
          <p>此属性具有特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-%iteratorprototype%-object" id="sec-%iterator.prototype%-object">
      <h1>Iterator 原型对象的属性</h1>
      <p><dfn>Iterator 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Iterator.prototype%</dfn>。</li>
        <li>具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
      </ul>
      <emu-note>
        <p>本规范中所有实现 iterator 接口的对象也都从 %Iterator.prototype% 继承。ECMAScript 代码也可以定义从 %Iterator.prototype% 继承的对象。%Iterator.prototype% 为可对所有迭代器对象适用的额外方法提供一个位置。</p>
        <p>以下表达式是 ECMAScript 代码访问 %Iterator.prototype% 对象的一种方式：</p>
        <pre><code class="javascript">Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))</code></pre>
      </emu-note>

      <emu-clause id="sec-iterator.prototype.constructor">
        <h1>Iterator.prototype.constructor</h1>
        <p>`Iterator.prototype.constructor` 是一个访问器属性，具有特性 { [[Enumerable]]: *false*, [[Configurable]]: *true* }。其 [[Get]] 和 [[Set]] 属性定义如下：</p>

        <emu-clause id="sec-get-iterator.prototype.constructor">
          <h1>get Iterator.prototype.constructor</h1>
          <p>[[Get]] 属性的值是一个不需要参数的内置函数。被调用时执行以下步骤：</p>
          <emu-alg>
            1. 返回 %Iterator%。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype.constructor">
          <h1>set Iterator.prototype.constructor</h1>
          <p>[[Set]] 属性的值是一个接受参数 _v_ 的内置函数。被调用时执行以下步骤：</p>
          <emu-alg>
            1. 执行 ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, *"constructor"*, _v_)。
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>与大多数内置原型上的 *"constructor"* 属性不同，出于 web 兼容性原因，此属性必须是访问器。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.drop">
        <h1>Iterator.prototype.drop ( _limit_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 令 _numLimit_ 为 Completion(ToNumber(_limit_))。
          1. IfAbruptCloseIterator(_numLimit_, _iterated_)。
          1. 若 _numLimit_ 为 *NaN*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *RangeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 令 _integerLimit_ 为 ! ToIntegerOrInfinity(_numLimit_)。
          1. 若 _integerLimit_ &lt; 0，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *RangeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _closure_ 为一个新的无参数抽象闭包，捕获 _iterated_ 与 _integerLimit_，调用时执行：
            1. 令 _remaining_ 为 _integerLimit_。
            1. 重复，当 _remaining_ > 0，
              1. 若 _remaining_ ≠ +∞，则
                1. 设 _remaining_ 为 _remaining_ - 1。
              1. 令 _next_ 为 ? IteratorStep(_iterated_)。
              1. 若 _next_ 为 ~done~，返回 ReturnCompletion(*undefined*)。
            1. 重复，
              1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
              1. 若 _value_ 为 ~done~，返回 ReturnCompletion(*undefined*)。
              1. 令 _completion_ 为 Completion(Yield(_value_))。
              1. IfAbruptCloseIterator(_completion_, _iterated_)。
          1. 令 _result_ 为 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)。
          1. 设 _result_.[[UnderlyingIterator]] 为 _iterated_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.every">
        <h1>Iterator.prototype.every ( _predicate_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_predicate_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _counter_ 为 0。
          1. 重复，
            1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _value_ 为 ~done~，返回 *true*。
            1. 令 _result_ 为 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. 若 ToBoolean(_result_) 为 *false*，返回 ? IteratorClose(_iterated_, NormalCompletion(*false*))。
            1. 设 _counter_ 为 _counter_ + 1。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.filter">
        <h1>Iterator.prototype.filter ( _predicate_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_predicate_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _closure_ 为一个新的无参数抽象闭包，捕获 _iterated_ 与 _predicate_，调用时执行：
            1. 令 _counter_ 为 0。
            1. 重复，
              1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
              1. 若 _value_ 为 ~done~，返回 ReturnCompletion(*undefined*)。
              1. 令 _selected_ 为 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))。
              1. IfAbruptCloseIterator(_selected_, _iterated_)。
              1. 若 ToBoolean(_selected_) 为 *true*，则
                1. 令 _completion_ 为 Completion(Yield(_value_))。
                1. IfAbruptCloseIterator(_completion_, _iterated_)。
              1. 设 _counter_ 为 _counter_ + 1。
          1. 令 _result_ 为 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)。
          1. 设 _result_.[[UnderlyingIterator]] 为 _iterated_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.find">
        <h1>Iterator.prototype.find ( _predicate_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_predicate_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _counter_ 为 0。
          1. 重复，
            1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _value_ 为 ~done~，返回 *undefined*。
            1. 令 _result_ 为 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. 若 ToBoolean(_result_) 为 *true*，返回 ? IteratorClose(_iterated_, NormalCompletion(_value_))。
            1. 设 _counter_ 为 _counter_ + 1。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.flatmap">
        <h1>Iterator.prototype.flatMap ( _mapper_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_mapper_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _closure_ 为一个新的无参数抽象闭包，捕获 _iterated_ 与 _mapper_，调用时执行：
            1. 令 _counter_ 为 0。
            1. 重复，
              1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
              1. 若 _value_ 为 ~done~，返回 ReturnCompletion(*undefined*)。
              1. 令 _mapped_ 为 Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »))。
              1. IfAbruptCloseIterator(_mapped_, _iterated_)。
              1. 令 _innerIterator_ 为 Completion(GetIteratorFlattenable(_mapped_, ~reject-primitives~))。
              1. IfAbruptCloseIterator(_innerIterator_, _iterated_)。
              1. 令 _innerAlive_ 为 *true*。
              1. 重复，当 _innerAlive_ 为 *true*，
                1. 令 _innerValue_ 为 Completion(IteratorStepValue(_innerIterator_))。
                1. IfAbruptCloseIterator(_innerValue_, _iterated_)。
                1. 若 _innerValue_ 为 ~done~，则
                  1. 设 _innerAlive_ 为 *false*。
                1. 否则，
                  1. 令 _completion_ 为 Completion(Yield(_innerValue_))。
                  1. 若 _completion_ 是一个 abrupt completion，则
                    1. 令 _backupCompletion_ 为 Completion(IteratorClose(_innerIterator_, _completion_))。
                    1. IfAbruptCloseIterator(_backupCompletion_, _iterated_)。
                    1. 返回 ? IteratorClose(_iterated_, _completion_)。
              1. 设 _counter_ 为 _counter_ + 1。
          1. 令 _result_ 为 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)。
          1. 设 _result_.[[UnderlyingIterator]] 为 _iterated_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.foreach">
        <h1>Iterator.prototype.forEach ( _procedure_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_procedure_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _counter_ 为 0。
          1. 重复，
            1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _value_ 为 ~done~，返回 *undefined*。
            1. 令 _result_ 为 Completion(Call(_procedure_, *undefined*, « _value_, 𝔽(_counter_) »))。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. 设 _counter_ 为 _counter_ + 1。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.map">
        <h1>Iterator.prototype.map ( _mapper_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_mapper_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _closure_ 为一个新的无参数抽象闭包，捕获 _iterated_ 与 _mapper_，调用时执行：
            1. 令 _counter_ 为 0。
            1. 重复，
              1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
              1. 若 _value_ 为 ~done~，返回 ReturnCompletion(*undefined*)。
              1. 令 _mapped_ 为 Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »))。
              1. IfAbruptCloseIterator(_mapped_, _iterated_)。
              1. 令 _completion_ 为 Completion(Yield(_mapped_))。
              1. IfAbruptCloseIterator(_completion_, _iterated_)。
              1. 设 _counter_ 为 _counter_ + 1。
          1. 令 _result_ 为 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)。
          1. 设 _result_.[[UnderlyingIterator]] 为 _iterated_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.reduce">
        <h1>Iterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_reducer_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 若 _initialValue_ 不存在，则
            1. 令 _accumulator_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _accumulator_ 为 ~done~，抛出一个 *TypeError* 异常。
            1. 令 _counter_ 为 1。
          1. 否则，
            1. 令 _accumulator_ 为 _initialValue_。
            1. 令 _counter_ 为 0。
          1. 重复，
            1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _value_ 为 ~done~，返回 _accumulator_。
            1. 令 _result_ 为 Completion(Call(_reducer_, *undefined*, « _accumulator_, _value_, 𝔽(_counter_) »))。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. 设 _accumulator_ 为 _result_。
            1. 设 _counter_ 为 _counter_ + 1。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.some">
        <h1>Iterator.prototype.some ( _predicate_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 若 IsCallable(_predicate_) 为 *false*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _counter_ 为 0。
          1. 重复，
            1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _value_ 为 ~done~，返回 *false*。
            1. 令 _result_ 为 Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »))。
            1. IfAbruptCloseIterator(_result_, _iterated_)。
            1. 若 ToBoolean(_result_) 为 *true*，返回 ? IteratorClose(_iterated_, NormalCompletion(*true*))。
            1. 设 _counter_ 为 _counter_ + 1。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.take">
        <h1>Iterator.prototype.take ( _limit_ )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }。
          1. 令 _numLimit_ 为 Completion(ToNumber(_limit_))。
          1. IfAbruptCloseIterator(_numLimit_, _iterated_)。
          1. 若 _numLimit_ 为 *NaN*，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *RangeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 令 _integerLimit_ 为 ! ToIntegerOrInfinity(_numLimit_)。
          1. 若 _integerLimit_ &lt; 0，则
            1. 令 _error_ 为 ThrowCompletion(一个新建的 *RangeError* 对象)。
            1. 返回 ? IteratorClose(_iterated_, _error_)。
          1. 设 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _closure_ 为一个新的无参数抽象闭包，捕获 _iterated_ 与 _integerLimit_，调用时执行：
            1. 令 _remaining_ 为 _integerLimit_。
            1. 重复，
              1. 若 _remaining_ = 0，则
                1. 返回 ? IteratorClose(_iterated_, ReturnCompletion(*undefined*))。
              1. 若 _remaining_ ≠ +∞，则
                1. 设 _remaining_ 为 _remaining_ - 1。
              1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
              1. 若 _value_ 为 ~done~，返回 ReturnCompletion(*undefined*)。
              1. 令 _completion_ 为 Completion(Yield(_value_))。
              1. IfAbruptCloseIterator(_completion_, _iterated_)。
          1. 令 _result_ 为 CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »)。
          1. 设 _result_.[[UnderlyingIterator]] 为 _iterated_。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.toarray">
        <h1>Iterator.prototype.toArray ( )</h1>
        <p>当调用此方法时，执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 如果 _O_ 不是一个 Object，抛出一个 *TypeError* 异常。
          1. 令 _iterated_ 为 ? GetIteratorDirect(_O_)。
          1. 令 _items_ 为一个新的空 List。
          1. 重复，
            1. 令 _value_ 为 ? IteratorStepValue(_iterated_)。
            1. 若 _value_ 为 ~done~，返回 CreateArrayFromList(_items_)。
            1. 将 _value_ 追加至 _items_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%iteratorprototype%-@@iterator,sec-%iteratorprototype%-%symbol.iterator%" id="sec-iterator.prototype-%symbol.iterator%">
        <h1>Iterator.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>当调用此函数时，执行以下步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>此函数 *"name"* 属性的值为 *"[Symbol.iterator]"*。</p>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype-%symbol.tostringtag%">
        <h1>Iterator.prototype [ %Symbol.toStringTag% ]</h1>
        <p>`Iterator.prototype[%Symbol.toStringTag%]` 是一个访问器属性，具有特性 { [[Enumerable]]: *false*, [[Configurable]]: *true* }。其 [[Get]] 和 [[Set]] 属性定义如下：</p>

        <emu-clause id="sec-get-iterator.prototype-%symbol.tostringtag%">
          <h1>get Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>[[Get]] 属性的值是一个不需要参数的内置函数。被调用时执行以下步骤：</p>
          <emu-alg>
            1. 返回 *"Iterator"*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype-%symbol.tostringtag%">
          <h1>set Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>[[Set]] 属性的值是一个接受参数 _v_ 的内置函数。被调用时执行以下步骤：</p>
          <emu-alg>
            1. 执行 ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, %Symbol.toStringTag%, _v_)。
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>与大多数内置原型上的 %Symbol.toStringTag% 属性不同，出于 web 兼容性原因，此属性必须是访问器。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>%AsyncIteratorPrototype% 对象</h1>
      <p><dfn>%AsyncIteratorPrototype%</dfn> 对象：</p>
      <ul>
        <li>具有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
      </ul>
      <emu-note>
        <p>本规范中所有实现 async iterator 接口的对象也都从 %AsyncIteratorPrototype% 继承。ECMAScript 代码也可以定义从 %AsyncIteratorPrototype% 继承的对象。%AsyncIteratorPrototype% 对象为可对所有 async 迭代器对象适用的额外方法提供一个位置。</p>
      </emu-note>

      <emu-clause oldids="sec-asynciteratorprototype-asynciterator" id="sec-%asynciteratorprototype%-%symbol.asynciterator%">
        <h1>%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )</h1>
        <p>当调用此函数时，执行以下步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>此函数 *"name"* 属性的值为 *"[Symbol.asyncIterator]"*。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-from-sync-iterator-objects">
      <h1>Async-from-Sync 迭代器对象</h1>
      <p><dfn variants="Async-from-Sync Iterator objects">Async-from-Sync Iterator object</dfn> 是一个将特定同步迭代器适配为 async 迭代器的对象。Async-from-Sync Iterator 对象永远不会被 ECMAScript 代码直接访问。它们没有具名构造函数，而是按需通过 CreateAsyncFromSyncIterator 抽象操作创建。</p>

      <emu-clause id="sec-createasyncfromsynciterator" type="abstract operation">
        <h1>
          CreateAsyncFromSyncIterator (
            _syncIteratorRecord_: an Iterator Record,
          ): an Iterator Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于从一个同步 Iterator Record 创建一个 async Iterator Record。</dd>
        </dl>
        <emu-alg>
          1. 令 _asyncIterator_ 为 OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »)。
          1. 设 _asyncIterator_.[[SyncIteratorRecord]] 为 _syncIteratorRecord_。
          1. 令 _nextMethod_ 为 ! Get(_asyncIterator_, *"next"*)。
          1. 令 _iteratorRecord_ 为 Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }。
          1. 返回 _iteratorRecord_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%asyncfromsynciteratorprototype%-object">
        <h1>%AsyncFromSyncIteratorPrototype% 对象</h1>
        <p><dfn>%AsyncFromSyncIteratorPrototype%</dfn> 对象：</p>
        <ul>
          <li>具有所有 Async-from-Sync Iterator 对象继承的属性。</li>
          <li>是一个普通对象。</li>
          <li>具有一个 [[Prototype]] 内部槽，其值为 %AsyncIteratorPrototype%。</li>
          <li>永远不会被 ECMAScript 代码直接访问。</li>
          <li>具有以下属性：</li>
        </ul>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.next">
          <h1>%AsyncFromSyncIteratorPrototype%.next ( [ _value_ ] )</h1>
          <emu-alg>
            1. 令 _O_ 为 *this* 值。
            1. 断言：_O_ 是一个具有 [[SyncIteratorRecord]] 内部槽的 Object。
            1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
            1. 令 _syncIteratorRecord_ 为 _O_.[[SyncIteratorRecord]]。
            1. 若 _value_ 存在，则
              1. 令 _result_ 为 Completion(IteratorNext(_syncIteratorRecord_, _value_))。
            1. 否则，
              1. 令 _result_ 为 Completion(IteratorNext(_syncIteratorRecord_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
            1. 返回 AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.return">
          <h1>%AsyncFromSyncIteratorPrototype%.return ( [ _value_ ] )</h1>

          <emu-alg>
            1. 令 _O_ 为 *this* 值。
            1. 断言：_O_ 是一个具有 [[SyncIteratorRecord]] 内部槽的 Object。
            1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
            1. 令 _syncIteratorRecord_ 为 _O_.[[SyncIteratorRecord]]。
            1. 令 _syncIterator_ 为 _syncIteratorRecord_.[[Iterator]]。
            1. 令 _return_ 为 Completion(GetMethod(_syncIterator_, *"return"*)).
            1. IfAbruptRejectPromise(_return_, _promiseCapability_)。
            1. 若 _return_ 为 *undefined*，则
              1. 令 _iteratorResult_ 为 CreateIteratorResultObject(_value_, *true*)。
              1. 执行 ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »)。
              1. 返回 _promiseCapability_.[[Promise]]。
            1. 若 _value_ 存在，则
              1. 令 _result_ 为 Completion(Call(_return_, _syncIterator_, « _value_ »))。
            1. 否则，
              1. 令 _result_ 为 Completion(Call(_return_, _syncIterator_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
            1. 若 _result_ 不是一个 Object，则
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 一个新建的 *TypeError* 对象 »)。
              1. 返回 _promiseCapability_.[[Promise]]。
            1. 返回 AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *false*)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.throw">
          <h1>%AsyncFromSyncIteratorPrototype%.throw ( [ _value_ ] )</h1>
          <emu-note>在本规范中，_value_ 总是被提供，但为与 <emu-xref title href="#sec-%asyncfromsynciteratorprototype%.return"></emu-xref> 保持一致而保留为可选。</emu-note>

          <emu-alg>
            1. 令 _O_ 为 *this* 值。
            1. 断言：_O_ 是一个具有 [[SyncIteratorRecord]] 内部槽的 Object。
            1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
            1. 令 _syncIteratorRecord_ 为 _O_.[[SyncIteratorRecord]]。
            1. 令 _syncIterator_ 为 _syncIteratorRecord_.[[Iterator]]。
            1. 令 _throw_ 为 Completion(GetMethod(_syncIterator_, *"throw"*))。
            1. IfAbruptRejectPromise(_throw_, _promiseCapability_)。
            1. 若 _throw_ 为 *undefined*，则
              1. 注：如果 _syncIterator_ 没有 `throw` 方法，在我们拒绝该 capability 前关闭它以便其有机会清理。
              1. 令 _closeCompletion_ 为 NormalCompletion(~empty~)。
              1. 令 _result_ 为 Completion(IteratorClose(_syncIteratorRecord_, _closeCompletion_))。
              1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
              1. 注：下一步抛出一个 *TypeError* 以指示存在协议违规：_syncIterator_ 没有 `throw` 方法。
              1. 注：如果关闭 _syncIterator_ 不抛出，则忽略该操作的结果，即使其产生了一个被拒绝的 promise。
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 一个新建的 *TypeError* 对象 »)。
              1. 返回 _promiseCapability_.[[Promise]]。
            1. 若 _value_ 存在，则
              1. 令 _result_ 为 Completion(Call(_throw_, _syncIterator_, « _value_ »))。
            1. 否则，
              1. 令 _result_ 为 Completion(Call(_throw_, _syncIterator_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
            1. 若 _result_ 不是一个 Object，则
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « 一个新建的 *TypeError* 对象 »)。
              1. 返回 _promiseCapability_.[[Promise]]。
            1. 返回 AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-async-from-sync-iterator-instances">
        <h1>Async-from-Sync 迭代器实例的属性</h1>
        <p>Async-from-Sync 迭代器实例是从 %AsyncFromSyncIteratorPrototype% 内在对象继承属性的普通对象。它们最初以 <emu-xref href="#table-async-from-sync-iterator-internal-slots"></emu-xref> 中列出的内部槽创建。</p>
        <emu-table id="table-async-from-sync-iterator-internal-slots" caption="Async-from-Sync 迭代器实例的内部槽">
          <table>
            <thead>
              <tr>
                <th>
                  内部槽
                </th>
                <th>
                  类型
                </th>
                <th>
                  描述
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[SyncIteratorRecord]]
              </td>
              <td>
                an Iterator Record
              </td>
              <td>
                表示正在被适配的原始同步迭代器。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncfromsynciteratorcontinuation" type="abstract operation" oldids="sec-async-from-sync-iterator-value-unwrap-functions">
        <h1>
          AsyncFromSyncIteratorContinuation (
            _result_: an Object,
            _promiseCapability_: a PromiseCapability Record for an intrinsic %Promise%,
            _syncIteratorRecord_: an Iterator Record,
            _closeOnRejection_: a Boolean,
          ): a Promise
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 注：由于 _promiseCapability_ 来自内在 %Promise%，下面使用 IfAbruptRejectPromise 所导致对 _promiseCapability_.[[Reject]] 的调用保证不会抛出。
          1. 令 _done_ 为 Completion(IteratorComplete(_result_))。
          1. IfAbruptRejectPromise(_done_, _promiseCapability_)。
          1. 令 _value_ 为 Completion(IteratorValue(_result_))。
          1. IfAbruptRejectPromise(_value_, _promiseCapability_)。
          1. 令 _valueWrapper_ 为 Completion(PromiseResolve(%Promise%, _value_))。
          1. 若 _valueWrapper_ 是一个 abrupt completion，_done_ 为 *false*，且 _closeOnRejection_ 为 *true*，则
            1. 设 _valueWrapper_ 为 Completion(IteratorClose(_syncIteratorRecord_, _valueWrapper_))。
          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_)。
          1. 令 _unwrap_ 为一个新的具有参数 (_v_) 且捕获 _done_ 的抽象闭包，调用时执行：
            1. 返回 CreateIteratorResultObject(_v_, _done_)。
          1. 令 _onFulfilled_ 为 CreateBuiltinFunction(_unwrap_, 1, *""*, « »)。
          1. 注：_onFulfilled_ 用于处理 IteratorResult 对象的 *"value"* 属性，以便在其值为 promise 时等待，并将结果重新打包为一个新的“解包后的” IteratorResult 对象。
          1. 若 _done_ 为 *true*，或 _closeOnRejection_ 为 *false*，则
            1. 令 _onRejected_ 为 *undefined*。
          1. 否则，
            1. 令 _closeIterator_ 为一个新的具有参数 (_error_) 且捕获 _syncIteratorRecord_ 的抽象闭包，调用时执行：
              1. 返回 ? IteratorClose(_syncIteratorRecord_, ThrowCompletion(_error_))。
            1. 令 _onRejected_ 为 CreateBuiltinFunction(_closeIterator_, 1, *""*, « »)。
            1. 注：_onRejected_ 用于在其产生的 IteratorResult 对象的 *"value"* 属性为一个被拒绝的 promise 时关闭迭代器。
          1. 执行 PerformPromiseThen(_valueWrapper_, _onFulfilled_, _onRejected_, _promiseCapability_)。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise 对象</h1>
    <p>Promise 是一个对象，用作延迟（且可能是异步）计算最终结果的占位符。</p>
    <p>任一 Promise 处于三个互斥状态之一：<em>fulfilled</em>、<em>rejected</em> 和 <em>pending</em>：</p>
    <ul>
      <li>
        当对一个 promise `p` 执行 `p.then(f, r)` 会立即入列一个调用函数 `f` 的 Job 时，`p` 为 fulfilled。
      </li>
      <li>
        当对一个 promise `p` 执行 `p.then(f, r)` 会立即入列一个调用函数 `r` 的 Job 时，`p` 为 rejected。
      </li>
      <li>
        当一个 promise 既不是 fulfilled 也不是 rejected 时，它是 pending。
      </li>
    </ul>
    <p>若一个 promise 不是 pending（即已 fulfilled 或 rejected），则称其为 <em>settled</em>。</p>
    <p>一个 promise 若已 settled 或被“锁定”与另一个 promise 的状态匹配，则称其为 <em>resolved</em>。试图 resolve 或 reject 一个已 resolved 的 promise 不产生任何效果。一个 promise 若未 resolved 则为 <em>unresolved</em>。未 resolved 的 promise 始终处于 pending 状态。一个已 resolved 的 promise 可能是 pending、fulfilled 或 rejected。</p>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise 抽象操作</h1>

      <emu-clause id="sec-promisecapability-records">
        <h1>PromiseCapability 记录</h1>
        <p><dfn variants="PromiseCapability Records">PromiseCapability Record</dfn> 是一个 Record 值，用来封装一个 Promise 或类 Promise 对象及其可用于 resolve 或 reject 该 promise 的函数。PromiseCapability 记录由 NewPromiseCapability 抽象操作产生。</p>
        <p>PromiseCapability 记录具有 <emu-xref href="#table-promisecapability-record-fields"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-promisecapability-record-fields" caption="PromiseCapability Record 字段" oldids="table-57">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Promise]]
              </td>
              <td>
                一个 Object
              </td>
              <td>
                可用作 promise 的对象。
              </td>
            </tr>
            <tr>
              <td>
                [[Resolve]]
              </td>
              <td>
                一个函数对象
              </td>
              <td>
                用于 resolve 给定 promise 的函数。
              </td>
            </tr>
            <tr>
              <td>
                [[Reject]]
              </td>
              <td>
                一个函数对象
              </td>
              <td>
                用于 reject 给定 promise 的函数。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
          <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
          <p>IfAbruptRejectPromise 是一组使用 PromiseCapability Record 的算法步骤的简写。形如：</p>
          <emu-alg>
            1. IfAbruptRejectPromise(_value_, _capability_)。
          </emu-alg>
          <p>等价于：</p>
          <emu-alg>
            1. 断言：_value_ 是一个 Completion Record。
            1. 若 _value_ 是一个 abrupt completion，则
              1. 执行 ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »)。
              1. 返回 _capability_.[[Promise]]。
            1. 否则，
              1. 设 _value_ 为 ! _value_。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction 记录</h1>
        <p><dfn variants="PromiseReaction Records">PromiseReaction Record</dfn> 是一个 Record 值，用来存储当 promise 以给定值 resolved 或 rejected 时应如何响应的信息。PromiseReaction 记录由 PerformPromiseThen 抽象操作创建，并由 NewPromiseReactionJob 返回的抽象闭包使用。</p>
        <p>PromiseReaction 记录具有 <emu-xref href="#table-promisereaction-record-fields"></emu-xref> 中列出的字段。</p>
        <emu-table id="table-promisereaction-record-fields" caption="PromiseReaction Record 字段" oldids="table-58">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                一个 PromiseCapability Record 或 *undefined*
              </td>
              <td>
                该记录为其提供 reaction 处理器的 promise 的能力集合。
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                ~fulfill~ 或 ~reject~
              </td>
              <td>
                当 [[Handler]] 为 ~empty~ 时用于区分针对不同完成类型的行为。
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                一个 JobCallback Record 或 ~empty~
              </td>
              <td>
                应对传入值执行的函数，其返回值决定派生 promise 的后续行为。若 [[Handler]] 为 ~empty~，则基于 [[Type]] 的函数将被使用。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-createresolvingfunctions" type="abstract operation">
        <h1>
          CreateResolvingFunctions (
            _promise_: a Promise,
          ): 一个具有字段 [[Resolve]] (函数对象) 与 [[Reject]] (函数对象) 的 Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _alreadyResolved_ 为 Record { [[Value]]: *false* }。
          1. 令 _stepsResolve_ 为 <emu-xref href="#sec-promise-resolve-functions" title></emu-xref> 中定义的算法步骤。
          1. 令 _lengthResolve_ 为 <emu-xref href="#sec-promise-resolve-functions" title></emu-xref> 中函数定义的非可选参数数量。
          1. 令 _resolve_ 为 CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *""*, « [[Promise]], [[AlreadyResolved]] »)。
          1. 设 _resolve_.[[Promise]] 为 _promise_。
          1. 设 _resolve_.[[AlreadyResolved]] 为 _alreadyResolved_。
          1. 令 _stepsReject_ 为 <emu-xref href="#sec-promise-reject-functions" title></emu-xref> 中定义的算法步骤。
          1. 令 _lengthReject_ 为 <emu-xref href="#sec-promise-reject-functions" title></emu-xref> 中函数定义的非可选参数数量。
          1. 令 _reject_ 为 CreateBuiltinFunction(_stepsReject_, _lengthReject_, *""*, « [[Promise]], [[AlreadyResolved]] »)。
          1. 设 _reject_.[[Promise]] 为 _promise_。
          1. 设 _reject_.[[AlreadyResolved]] 为 _alreadyResolved_。
          1. 返回 Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }。
        </emu-alg>

        <emu-clause id="sec-promise-reject-functions">
          <h1>Promise Reject 函数</h1>
          <p>Promise reject 函数是一个匿名内置函数，具有 [[Promise]] 与 [[AlreadyResolved]] 内部槽。</p>
          <p>当以参数 _reason_ 调用一个 promise reject 函数时，执行以下步骤：</p>
          <emu-alg>
            1. 令 _F_ 为活动函数对象。
            1. 断言：_F_ 具有一个值为 Object 的 [[Promise]] 内部槽。
            1. 令 _promise_ 为 _F_.[[Promise]]。
            1. 令 _alreadyResolved_ 为 _F_.[[AlreadyResolved]]。
            1. 若 _alreadyResolved_.[[Value]] 为 *true*，返回 *undefined*。
            1. 设 _alreadyResolved_.[[Value]] 为 *true*。
            1. 执行 RejectPromise(_promise_, _reason_)。
            1. 返回 *undefined*。
          </emu-alg>
          <p>Promise reject 函数的 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
        </emu-clause>

        <emu-clause id="sec-promise-resolve-functions">
          <h1>Promise Resolve 函数</h1>
          <p>Promise resolve 函数是一个匿名内置函数，具有 [[Promise]] 与 [[AlreadyResolved]] 内部槽。</p>
          <p>当以参数 _resolution_ 调用一个 promise resolve 函数时，执行以下步骤：</p>
          <emu-alg>
            1. 令 _F_ 为活动函数对象。
            1. 断言：_F_ 具有一个值为 Object 的 [[Promise]] 内部槽。
            1. 令 _promise_ 为 _F_.[[Promise]]。
            1. 令 _alreadyResolved_ 为 _F_.[[AlreadyResolved]]。
            1. 若 _alreadyResolved_.[[Value]] 为 *true*，返回 *undefined*。
            1. 设 _alreadyResolved_.[[Value]] 为 *true*。
            1. 若 SameValue(_resolution_, _promise_) 为 *true*，则
              1. 令 _selfResolutionError_ 为一个新建的 *TypeError* 对象。
              1. 执行 RejectPromise(_promise_, _selfResolutionError_)。
              1. 返回 *undefined*。
            1. 若 _resolution_ 不是一个 Object，则
              1. 执行 FulfillPromise(_promise_, _resolution_)。
              1. 返回 *undefined*。
            1. 令 _then_ 为 Completion(Get(_resolution_, *"then"*))。
            1. 若 _then_ 是一个 abrupt completion，则
              1. 执行 RejectPromise(_promise_, _then_.[[Value]])。
              1. 返回 *undefined*。
            1. 令 _thenAction_ 为 _then_.[[Value]]。
            1. 若 IsCallable(_thenAction_) 为 *false*，则
              1. 执行 FulfillPromise(_promise_, _resolution_)。
              1. 返回 *undefined*。
            1. 令 _thenJobCallback_ 为 HostMakeJobCallback(_thenAction_)。
            1. 令 _job_ 为 NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_)。
            1. 执行 HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]])。
            1. 返回 *undefined*。
          </emu-alg>
          <p>Promise resolve 函数的 *"length"* 属性为 *1*<sub>𝔽</sub>。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-fulfillpromise" type="abstract operation">
        <h1>
          FulfillPromise (
            _promise_: a Promise,
            _value_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_promise_.[[PromiseState]] 为 ~pending~。
          1. 令 _reactions_ 为 _promise_.[[PromiseFulfillReactions]]。
          1. 设 _promise_.[[PromiseResult]] 为 _value_。
          1. 设 _promise_.[[PromiseFulfillReactions]] 为 *undefined*。
          1. 设 _promise_.[[PromiseRejectReactions]] 为 *undefined*。
          1. 设 _promise_.[[PromiseState]] 为 ~fulfilled~。
          1. 执行 TriggerPromiseReactions(_reactions_, _value_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromisecapability" type="abstract operation" oldids="sec-getcapabilitiesexecutor-functions">
        <h1>
          NewPromiseCapability (
            _C_: an ECMAScript language value,
          ): 正常完成（含一个 PromiseCapability Record）或抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>尝试以与内置 Promise 构造函数相同的方式使用 _C_ 作为构造器来创建一个 promise，并提取其 `resolve` 与 `reject` 函数。该 promise 及其 `resolve` 与 `reject` 函数用于初始化一个新的 PromiseCapability Record。</dd>
        </dl>
        <emu-alg>
          1. 若 IsConstructor(_C_) 为 *false*，抛出一个 *TypeError* 异常。
          1. 注：假定 _C_ 是一个支持 Promise 构造函数参数约定的构造函数（见 <emu-xref href="#sec-promise-executor"></emu-xref>）。
          1. 令 _resolvingFunctions_ 为 Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }。
          1. 令 _executorClosure_ 为一个具有参数 (_resolve_, _reject_) 且捕获 _resolvingFunctions_ 的新抽象闭包，调用时执行：
            1. 若 _resolvingFunctions_.[[Resolve]] 不为 *undefined*，抛出一个 *TypeError* 异常。
            1. 若 _resolvingFunctions_.[[Reject]] 不为 *undefined*，抛出一个 *TypeError* 异常。
            1. 设 _resolvingFunctions_.[[Resolve]] 为 _resolve_。
            1. 设 _resolvingFunctions_.[[Reject]] 为 _reject_。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _executor_ 为 CreateBuiltinFunction(_executorClosure_, 2, *""*, « »)。
          1. 令 _promise_ 为 ? Construct(_C_, « _executor_ »)。
          1. 若 IsCallable(_resolvingFunctions_.[[Resolve]]) 为 *false*，抛出一个 *TypeError* 异常。
          1. 若 IsCallable(_resolvingFunctions_.[[Reject]]) 为 *false*，抛出一个 *TypeError* 异常。
          1. 返回 PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }。
        </emu-alg>
        <emu-note>
          <p>该抽象操作支持 Promise 子类化，因为它对任何以与 Promise 构造函数相同方式调用传入 executor 函数参数的构造器都是通用的。它用于将 Promise 构造函数的静态方法泛化到任意子类。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-ispromise" type="abstract operation">
        <h1>
          IsPromise (
            _x_: an ECMAScript language value,
          ): 一个 Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>检查对象上是否具有 promise 品牌标记。</dd>
        </dl>
        <emu-alg>
          1. 若 _x_ 不是一个 Object，返回 *false*。
          1. 若 _x_ 不具有 [[PromiseState]] 内部槽，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rejectpromise" type="abstract operation">
        <h1>
          RejectPromise (
            _promise_: a Promise,
            _reason_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_promise_.[[PromiseState]] 为 ~pending~。
          1. 令 _reactions_ 为 _promise_.[[PromiseRejectReactions]]。
          1. 设 _promise_.[[PromiseResult]] 为 _reason_。
          1. 设 _promise_.[[PromiseFulfillReactions]] 为 *undefined*。
          1. 设 _promise_.[[PromiseRejectReactions]] 为 *undefined*。
          1. 设 _promise_.[[PromiseState]] 为 ~rejected~。
          1. 若 _promise_.[[PromiseIsHandled]] 为 *false*，执行 HostPromiseRejectionTracker(_promise_, *"reject"*)。
          1. 执行 TriggerPromiseReactions(_reactions_, _reason_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-triggerpromisereactions" type="abstract operation">
        <h1>
          TriggerPromiseReactions (
            _reactions_: a List of PromiseReaction Records,
            _argument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>为 _reactions_ 中的每个记录入列一个新的 Job。每个这样的 Job 处理该 PromiseReaction Record 的 [[Type]] 与 [[Handler]]，若 [[Handler]] 不是 ~empty~，则以给定参数调用它。若 [[Handler]] 为 ~empty~，行为由 [[Type]] 决定。</dd>
        </dl>
        <emu-alg>
          1. 对于 _reactions_ 的每个元素 _reaction_，执行
            1. 令 _job_ 为 NewPromiseReactionJob(_reaction_, _argument_)。
            1. 执行 HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]])。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" type="host-defined abstract operation">
        <h1>
          HostPromiseRejectionTracker (
            _promise_: a Promise,
            _operation_: *"reject"* or *"handle"*,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>允许宿主环境追踪 promise 拒绝。</dd>
        </dl>
        <p>HostPromiseRejectionTracker 的默认实现是返回 ~unused~。</p>

        <emu-note>
          <p>HostPromiseRejectionTracker 在两种场景被调用：</p>

          <ul>
            <li>当一个 promise 在没有任何处理器的情况下被拒绝时，以 _operation_ 参数为 *"reject"* 调用。</li>
            <li>当首次向一个已拒绝的 promise 添加处理器时，以 _operation_ 参数为 *"handle"* 调用。</li>
          </ul>

          <p>一个典型实现可能尝试通知开发者未处理的拒绝，同时在随后新处理器附加使先前通知失效时再次适当通知。</p>
        </emu-note>

        <emu-note>
          <p>若 _operation_ 为 *"handle"*，实现不应以影响垃圾回收的方式持有对 _promise_ 的引用。若 _operation_ 为 *"reject"*，实现可以持有引用，因为预期拒绝是少见且不在热点路径上。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise 作业</h1>

      <emu-clause id="sec-newpromisereactionjob" type="abstract operation" oldids="sec-promisereactionjob">
        <h1>
          NewPromiseReactionJob (
            _reaction_: 一个 PromiseReaction Record，,
            _argument_: 一个 ECMAScript 语言值,
          ): 一个具有字段 [[Job]] (一个 Job 抽象闭包) 和 [[Realm]] (一个 Realm Record 或 *null*) 的 Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>返回一个新的 Job 抽象闭包，该闭包对传入的值应用合适的处理器，并使用该处理器的返回值来根据该处理器关联的派生 promise 进行 resolve 或 reject。</dd>
        </dl>
        <emu-alg>
          1. 令 _job_ 为一个无参数的新 Job 抽象闭包，捕获 _reaction_ 和 _argument_，在被调用时执行下列步骤：
            1. 令 _promiseCapability_ 为 _reaction_.[[Capability]]。
            1. 令 _type_ 为 _reaction_.[[Type]]。
            1. 令 _handler_ 为 _reaction_.[[Handler]]。
            1. 如果 _handler_ 是 ~empty~，则
              1. 如果 _type_ 是 ~fulfill~，则
                1. 令 _handlerResult_ 为 NormalCompletion(_argument_)。
              1. 否则，
                1. 断言：_type_ 是 ~reject~。
                1. 令 _handlerResult_ 为 ThrowCompletion(_argument_)。
            1. 否则，
              1. 令 _handlerResult_ 为 Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »))。
            1. 如果 _promiseCapability_ 是 *undefined*，则
              1. 断言：_handlerResult_ 不是一个 abrupt completion。
              1. 返回 ~empty~。
            1. 断言：_promiseCapability_ 是一个 PromiseCapability Record。
            1. 如果 _handlerResult_ 是一个 abrupt completion，则
              1. 返回 ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »)。
            1. 否则，
              1. 返回 ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »)。
          1. 令 _handlerRealm_ 为 *null*。
          1. 如果 _reaction_.[[Handler]] 不为 ~empty~，则
            1. 令 _getHandlerRealmResult_ 为 Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]]))。
            1. 如果 _getHandlerRealmResult_ 是一个 normal completion，则将 _handlerRealm_ 设为 _getHandlerRealmResult_.[[Value]]。
            1. 否则，将 _handlerRealm_ 设为当前 Realm Record。
            1. 注：除非处理器是 *undefined*，否则 _handlerRealm_ 永不为 *null*。当处理器是已撤销的 Proxy 且没有 ECMAScript 代码运行时，_handlerRealm_ 用来创建错误对象。
          1. 返回 Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromiseresolvethenablejob" type="abstract operation" oldids="sec-promiseresolvethenablejob">
        <h1>
          NewPromiseResolveThenableJob (
            _promiseToResolve_: 一个 Promise,
            _thenable_: 一个 Object,
            _then_: 一个 JobCallback Record,
          ): 一个具有字段 [[Job]] (一个 Job 抽象闭包) 和 [[Realm]] (一个 Realm Record) 的 Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _job_ 为一个无参数的新 Job 抽象闭包，捕获 _promiseToResolve_, _thenable_, 以及 _then_，在被调用时执行下列步骤：
            1. 令 _resolvingFunctions_ 为 CreateResolvingFunctions(_promiseToResolve_)。
            1. 令 _thenCallResult_ 为 Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »))。
            1. 如果 _thenCallResult_ 是一个 abrupt completion，则
              1. 返回 ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »)。
            1. 返回 ! _thenCallResult_。
          1. 令 _getThenRealmResult_ 为 Completion(GetFunctionRealm(_then_.[[Callback]]))。
          1. 如果 _getThenRealmResult_ 是一个 normal completion，令 _thenRealm_ 为 _getThenRealmResult_.[[Value]]。
          1. 否则，令 _thenRealm_ 为当前 Realm Record。
          1. 注：_thenRealm_ 永不为 *null*。当 _then_.[[Callback]] 是一个已撤销的 Proxy 且无代码运行时，_thenRealm_ 用于创建错误对象。
          1. 返回 Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }。
        </emu-alg>
        <emu-note>
          <p>该作业使用提供的 thenable 及其 `then` 方法来 resolve 给定的 promise。此过程必须作为一个 Job 进行，以确保对 `then` 方法的求值发生在任意外围代码求值完成之后。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-constructor">
      <h1>Promise 构造函数</h1>
      <p>Promise 构造函数：</p>
      <ul>
        <li>是 <dfn>%Promise%</dfn>。</li>
        <li>是全局对象 *"Promise"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Promise。</li>
        <li>不应作为普通函数调用，若以那种方式调用将抛出异常。</li>
        <li>可用作类定义中 `extends` 子句的值。意图继承指定 Promise 行为的子类构造函数必须包含对 Promise 构造函数的 `super` 调用，以使用支持 `Promise` 和 `Promise.prototype` 内建方法所需的内部状态创建并初始化子类实例。</li>
      </ul>

      <emu-clause id="sec-promise-executor">
        <h1>Promise ( _executor_ )</h1>
        <p>此函数在被调用时执行下列步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 是 *undefined*，抛出 *TypeError* 异常。
          1. 如果 IsCallable(_executor_) 是 *false*，抛出 *TypeError* 异常。
          1. 令 _promise_ 为 ? OrdinaryCreateFromConstructor(NewTarget, *"%Promise.prototype%"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »)。
          1. 将 _promise_.[[PromiseState]] 设为 ~pending~。
          1. 将 _promise_.[[PromiseResult]] 设为 ~empty~。
          1. 将 _promise_.[[PromiseFulfillReactions]] 设为一个新的空 List。
          1. 将 _promise_.[[PromiseRejectReactions]] 设为一个新的空 List。
          1. 将 _promise_.[[PromiseIsHandled]] 设为 *false*。
          1. 令 _resolvingFunctions_ 为 CreateResolvingFunctions(_promise_)。
          1. 令 _completion_ 为 Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »))。
          1. 如果 _completion_ 是一个 abrupt completion，则
            1. 执行 ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »)。
          1. 返回 _promise_。
        </emu-alg>
        <emu-note>
          <p>_executor_ 参数必须是一个函数对象。它被调用以发起并报告该 Promise 所表示的可能延迟动作的完成情况。executor 以两个参数调用：_resolve_ 与 _reject_。executor 函数可使用这些函数报告延迟计算的最终完成或失败。从 executor 函数返回并不意味着延迟动作已经完成，仅表示执行延迟动作的请求已被接受。</p>
          <p>传给 _executor_ 的 _resolve_ 函数接受一个参数。_executor_ 代码最终可以调用 _resolve_ 来表示其希望 resolve 关联的 Promise。传给 _resolve_ 的参数表示延迟动作的最终值，可以是实际的 fulfill 值，也可以是另一个在 fulfill 后提供该值的 promise。</p>
          <p>传给 _executor_ 的 _reject_ 函数接受一个参数。_executor_ 代码最终可以调用 _reject_ 来表示关联的 Promise 已被 reject 且永不会 fulfill。传给 _reject_ 的参数用作该 promise 的拒绝值。典型情况下它将是一个 Error 对象。</p>
          <p>Promise 构造函数传给 _executor_ 的 resolve 与 reject 函数具有实际 resolve 和 reject 关联 promise 的能力。子类可能有不同的构造函数行为，向 executor 传入自定义的 resolve 与 reject 值。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Promise 构造函数的属性</h1>
      <p>Promise 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-promise.all">
        <h1>Promise.all ( _iterable_ )</h1>
        <p>该函数返回一个新的 promise：若传入的各个 promise 全部 fulfill，则以其 fulfill 值数组进行 fulfill；若其中第一个 reject，则以该 reject 原因进行 reject。它在运行本算法时会将传入可迭代对象的所有元素解析为 promise。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 令 _promiseResolve_ 为 Completion(GetPromiseResolve(_C_))。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. 令 _iteratorRecord_ 为 Completion(GetIterator(_iterable_, ~sync~))。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. 令 _result_ 为 Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_))。
          1. 如果 _result_ 是一个 abrupt completion，则
            1. 如果 _iteratorRecord_.[[Done]] 是 *false*，将 _result_ 设为 Completion(IteratorClose(_iteratorRecord_, _result_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 返回 ! _result_。
        </emu-alg>
        <emu-note>
          <p>该函数要求其 *this* 值为一个支持 Promise 构造函数参数约定的构造函数。</p>
        </emu-note>

        <emu-clause id="sec-getpromiseresolve" type="abstract operation">
          <h1>
            GetPromiseResolve (
              _promiseConstructor_: 一个 constructor,
            ): 要么是包含一个函数对象的 normal completion，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _promiseResolve_ 为 ? Get(_promiseConstructor_, *"resolve"*)。
            1. 如果 IsCallable(_promiseResolve_) 是 *false*，抛出 *TypeError* 异常。
            1. 返回 _promiseResolve_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-performpromiseall" type="abstract operation">
          <h1>
            PerformPromiseAll (
              _iteratorRecord_: 一个 Iterator Record,
              _constructor_: 一个 constructor,
              _resultCapability_: 一个 PromiseCapability Record,
              _promiseResolve_: 一个函数对象,
            ): 要么是包含一个 ECMAScript 语言值的 normal completion，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _values_ 为一个新的空 List。
            1. 令 _remainingElementsCount_ 为 Record { [[Value]]: 1 }。
            1. 令 _index_ 为 0。
            1. 重复，
              1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
              1. 如果 _next_ 是 ~done~，则
                1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
                1. 如果 _remainingElementsCount_.[[Value]] = 0，则
                  1. 令 _valuesArray_ 为 CreateArrayFromList(_values_)。
                  1. 执行 ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »)。
                1. 返回 _resultCapability_.[[Promise]]。
              1. 将 *undefined* 追加到 _values_。
              1. 令 _nextPromise_ 为 ? Call(_promiseResolve_, _constructor_, « _next_ »)。
              1. 令 _steps_ 为 <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref> 中定义的算法步骤。
              1. 令 _length_ 为 <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref> 中函数定义的非可选参数个数。
              1. 令 _onFulfilled_ 为 CreateBuiltinFunction(_steps_, _length_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »)。
              1. 将 _onFulfilled_.[[AlreadyCalled]] 设为 *false*。
              1. 将 _onFulfilled_.[[Index]] 设为 _index_。
              1. 将 _onFulfilled_.[[Values]] 设为 _values_。
              1. 将 _onFulfilled_.[[Capability]] 设为 _resultCapability_。
              1. 将 _onFulfilled_.[[RemainingElements]] 设为 _remainingElementsCount_。
              1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] + 1。
              1. 执行 ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _resultCapability_.[[Reject]] »)。
              1. 将 _index_ 设为 _index_ + 1。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.all-resolve-element-functions">
          <h1>`Promise.all` Resolve 元素函数</h1>
          <p>`Promise.all` resolve 元素函数是一个匿名内建函数，用于 resolve 某个特定的 `Promise.all` 元素。每个此类函数具有 [[Index]]、[[Values]]、[[Capability]]、[[RemainingElements]] 和 [[AlreadyCalled]] 内部槽。</p>
          <p>当一个 `Promise.all` resolve 元素函数以参数 _x_ 被调用时，执行下列步骤：</p>
          <emu-alg>
            1. 令 _F_ 为活动函数对象。
            1. 如果 _F_.[[AlreadyCalled]] 是 *true*，返回 *undefined*。
            1. 将 _F_.[[AlreadyCalled]] 设为 *true*。
            1. 令 _index_ 为 _F_.[[Index]]。
            1. 令 _values_ 为 _F_.[[Values]]。
            1. 令 _promiseCapability_ 为 _F_.[[Capability]]。
            1. 令 _remainingElementsCount_ 为 _F_.[[RemainingElements]]。
            1. 将 _values_[_index_] 设为 _x_。
            1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
            1. 如果 _remainingElementsCount_.[[Value]] = 0，则
              1. 令 _valuesArray_ 为 CreateArrayFromList(_values_)。
              1. 返回 ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »)。
            1. 返回 *undefined*。
          </emu-alg>
          <p>`Promise.all` resolve 元素函数的 *"length"* 属性是 *1*<sub>𝔽</sub>。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.allsettled">
        <h1>Promise.allSettled ( _iterable_ )</h1>
        <p>该函数返回一个 promise，当所有原始 promise 均已 settle（即变为 fulfilled 或 rejected）后，以包含 promise 状态快照的数组 fulfill。它在运行本算法时将传入可迭代对象的所有元素解析为 promise。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 令 _promiseResolve_ 为 Completion(GetPromiseResolve(_C_))。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. 令 _iteratorRecord_ 为 Completion(GetIterator(_iterable_, ~sync~))。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. 令 _result_ 为 Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_))。
          1. 如果 _result_ 是一个 abrupt completion，则
            1. 如果 _iteratorRecord_.[[Done]] 是 *false*，将 _result_ 设为 Completion(IteratorClose(_iteratorRecord_, _result_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 返回 ! _result_。
        </emu-alg>
        <emu-note>
          <p>该函数要求其 *this* 值为一个支持 Promise 构造函数参数约定的构造函数。</p>
        </emu-note>

        <emu-clause id="sec-performpromiseallsettled" type="abstract operation">
          <h1>
            PerformPromiseAllSettled (
              _iteratorRecord_: 一个 Iterator Record,
              _constructor_: 一个 constructor,
              _resultCapability_: 一个 PromiseCapability Record,
              _promiseResolve_: 一个函数对象,
            ): 要么是包含一个 ECMAScript 语言值的 normal completion，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _values_ 为一个新的空 List。
            1. 令 _remainingElementsCount_ 为 Record { [[Value]]: 1 }。
            1. 令 _index_ 为 0。
            1. 重复，
              1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
              1. 如果 _next_ 是 ~done~，则
                1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
                1. 如果 _remainingElementsCount_.[[Value]] = 0，则
                  1. 令 _valuesArray_ 为 CreateArrayFromList(_values_)。
                  1. 执行 ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »)。
                1. 返回 _resultCapability_.[[Promise]]。
              1. 将 *undefined* 追加到 _values_。
              1. 令 _nextPromise_ 为 ? Call(_promiseResolve_, _constructor_, « _next_ »)。
              1. 令 _stepsFulfilled_ 为 <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref> 中定义的算法步骤。
              1. 令 _lengthFulfilled_ 为 <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref> 中函数定义的非可选参数个数。
              1. 令 _onFulfilled_ 为 CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »)。
              1. 令 _alreadyCalled_ 为 Record { [[Value]]: *false* }。
              1. 将 _onFulfilled_.[[AlreadyCalled]] 设为 _alreadyCalled_。
              1. 将 _onFulfilled_.[[Index]] 设为 _index_。
              1. 将 _onFulfilled_.[[Values]] 设为 _values_。
              1. 将 _onFulfilled_.[[Capability]] 设为 _resultCapability_。
              1. 将 _onFulfilled_.[[RemainingElements]] 设为 _remainingElementsCount_。
              1. 令 _stepsRejected_ 为 <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref> 中定义的算法步骤。
              1. 令 _lengthRejected_ 为 <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref> 中函数定义的非可选参数个数。
              1. 令 _onRejected_ 为 CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »)。
              1. 将 _onRejected_.[[AlreadyCalled]] 设为 _alreadyCalled_。
              1. 将 _onRejected_.[[Index]] 设为 _index_。
              1. 将 _onRejected_.[[Values]] 设为 _values_。
              1. 将 _onRejected_.[[Capability]] 设为 _resultCapability_。
              1. 将 _onRejected_.[[RemainingElements]] 设为 _remainingElementsCount_。
              1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] + 1。
              1. 执行 ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _onRejected_ »)。
              1. 将 _index_ 设为 _index_ + 1。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-resolve-element-functions">
          <h1>`Promise.allSettled` Resolve 元素函数</h1>
          <p>`Promise.allSettled` resolve 元素函数是一个匿名内建函数，用于 resolve 某个特定的 `Promise.allSettled` 元素。每个此类函数具有 [[Index]]、[[Values]]、[[Capability]]、[[RemainingElements]] 和 [[AlreadyCalled]] 内部槽。</p>
          <p>当一个 `Promise.allSettled` resolve 元素函数以参数 _x_ 被调用时，执行下列步骤：</p>
          <emu-alg>
            1. 令 _F_ 为活动函数对象。
            1. 令 _alreadyCalled_ 为 _F_.[[AlreadyCalled]]。
            1. 如果 _alreadyCalled_.[[Value]] 是 *true*，返回 *undefined*。
            1. 将 _alreadyCalled_.[[Value]] 设为 *true*。
            1. 令 _index_ 为 _F_.[[Index]]。
            1. 令 _values_ 为 _F_.[[Values]]。
            1. 令 _promiseCapability_ 为 _F_.[[Capability]]。
            1. 令 _remainingElementsCount_ 为 _F_.[[RemainingElements]]。
            1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"fulfilled"*)。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"value"*, _x_)。
            1. 将 _values_[_index_] 设为 _obj_。
            1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
            1. 如果 _remainingElementsCount_.[[Value]] = 0，则
              1. 令 _valuesArray_ 为 CreateArrayFromList(_values_)。
              1. 返回 ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »)。
            1. 返回 *undefined*。
          </emu-alg>
          <p>`Promise.allSettled` resolve 元素函数的 *"length"* 属性是 *1*<sub>𝔽</sub>。</p>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-reject-element-functions">
          <h1>`Promise.allSettled` Reject 元素函数</h1>
          <p>`Promise.allSettled` reject 元素函数是一个匿名内建函数，用于 reject 某个特定的 `Promise.allSettled` 元素。每个此类函数具有 [[Index]]、[[Values]]、[[Capability]]、[[RemainingElements]] 和 [[AlreadyCalled]] 内部槽。</p>
          <p>当一个 `Promise.allSettled` reject 元素函数以参数 _x_ 被调用时，执行下列步骤：</p>
          <emu-alg>
            1. 令 _F_ 为活动函数对象。
            1. 令 _alreadyCalled_ 为 _F_.[[AlreadyCalled]]。
            1. 如果 _alreadyCalled_.[[Value]] 是 *true*，返回 *undefined*。
            1. 将 _alreadyCalled_.[[Value]] 设为 *true*。
            1. 令 _index_ 为 _F_.[[Index]]。
            1. 令 _values_ 为 _F_.[[Values]]。
            1. 令 _promiseCapability_ 为 _F_.[[Capability]]。
            1. 令 _remainingElementsCount_ 为 _F_.[[RemainingElements]]。
            1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"rejected"*)。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"reason"*, _x_)。
            1. 将 _values_[_index_] 设为 _obj_。
            1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
            1. 如果 _remainingElementsCount_.[[Value]] = 0，则
              1. 令 _valuesArray_ 为 CreateArrayFromList(_values_)。
              1. 返回 ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »)。
            1. 返回 *undefined*。
          </emu-alg>
          <p>`Promise.allSettled` reject 元素函数的 *"length"* 属性是 *1*<sub>𝔽</sub>。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.any">
        <h1>Promise.any ( _iterable_ )</h1>
        <p>该函数返回一个 promise：由第一个 fulfill 的输入 promise 来 fulfill；如果所有输入 promise 均被 reject，则以一个包含所有拒绝原因的 `AggregateError` 进行 reject。它在运行本算法时将传入可迭代对象的所有元素解析为 promise。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 令 _promiseResolve_ 为 Completion(GetPromiseResolve(_C_))。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. 令 _iteratorRecord_ 为 Completion(GetIterator(_iterable_, ~sync~))。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. 令 _result_ 为 Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_))。
          1. 如果 _result_ 是一个 abrupt completion，则
            1. 如果 _iteratorRecord_.[[Done]] 是 *false*，将 _result_ 设为 Completion(IteratorClose(_iteratorRecord_, _result_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 返回 ! _result_。
        </emu-alg>
        <emu-note>
          <p>该函数要求其 *this* 值为一个支持 `Promise` 构造函数参数约定的构造函数。</p>
        </emu-note>

        <emu-clause id="sec-performpromiseany" type="abstract operation">
          <h1>
            PerformPromiseAny (
              _iteratorRecord_: 一个 Iterator Record,
              _constructor_: 一个 constructor,
              _resultCapability_: 一个 PromiseCapability Record,
              _promiseResolve_: 一个函数对象,
            ): 要么是包含一个 ECMAScript 语言值的 normal completion，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _errors_ 为一个新的空 List。
            1. 令 _remainingElementsCount_ 为 Record { [[Value]]: 1 }。
            1. 令 _index_ 为 0。
            1. 重复，
              1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
              1. 如果 _next_ 是 ~done~，则
                1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
                1. 如果 _remainingElementsCount_.[[Value]] = 0，则
                  1. 令 _error_ 为一个新创建的 *AggregateError* 对象。
                  1. 执行 ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) })。
                  1. 返回 ThrowCompletion(_error_)。
                1. 返回 _resultCapability_.[[Promise]]。
              1. 将 *undefined* 追加到 _errors_。
              1. 令 _nextPromise_ 为 ? Call(_promiseResolve_, _constructor_, « _next_ »)。
              1. 令 _stepsRejected_ 为 <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref> 中定义的算法步骤。
              1. 令 _lengthRejected_ 为 <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref> 中函数定义的非可选参数个数。
              1. 令 _onRejected_ 为 CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »)。
              1. 将 _onRejected_.[[AlreadyCalled]] 设为 *false*。
              1. 将 _onRejected_.[[Index]] 设为 _index_。
              1. 将 _onRejected_.[[Errors]] 设为 _errors_。
              1. 将 _onRejected_.[[Capability]] 设为 _resultCapability_。
              1. 将 _onRejected_.[[RemainingElements]] 设为 _remainingElementsCount_。
              1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] + 1。
              1. 执行 ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _onRejected_ »)。
              1. 将 _index_ 设为 _index_ + 1。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.any-reject-element-functions">
          <h1>`Promise.any` Reject 元素函数</h1>
          <p>`Promise.any` reject 元素函数是一个匿名内建函数，用于 reject 某个特定的 `Promise.any` 元素。每个此类函数具有 [[Index]]、[[Errors]]、[[Capability]]、[[RemainingElements]] 和 [[AlreadyCalled]] 内部槽。</p>
          <p>当一个 `Promise.any` reject 元素函数以参数 _x_ 被调用时，执行下列步骤：</p>
          <emu-alg>
            1. 令 _F_ 为活动函数对象。
            1. 如果 _F_.[[AlreadyCalled]] 是 *true*，返回 *undefined*。
            1. 将 _F_.[[AlreadyCalled]] 设为 *true*。
            1. 令 _index_ 为 _F_.[[Index]]。
            1. 令 _errors_ 为 _F_.[[Errors]]。
            1. 令 _promiseCapability_ 为 _F_.[[Capability]]。
            1. 令 _remainingElementsCount_ 为 _F_.[[RemainingElements]]。
            1. 将 _errors_[_index_] 设为 _x_。
            1. 将 _remainingElementsCount_.[[Value]] 设为 _remainingElementsCount_.[[Value]] - 1。
            1. 如果 _remainingElementsCount_.[[Value]] = 0，则
              1. 令 _error_ 为一个新创建的 *AggregateError* 对象。
              1. 执行 ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) })。
              1. 返回 ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ »)。
            1. 返回 *undefined*。
          </emu-alg>
          <p>`Promise.any` reject 元素函数的 *"length"* 属性是 *1*<sub>𝔽</sub>。</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype">
        <h1>Promise.prototype</h1>
        <p>`Promise.prototype` 的初始值是 Promise 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* } 属性。</p>
      </emu-clause>

      <emu-clause id="sec-promise.race">
        <h1>Promise.race ( _iterable_ )</h1>
        <p>该函数返回一个新的 promise，其 settle 方式与第一个 settle 的传入 promise 相同。它在运行本算法时将传入的 _iterable_ 的所有元素解析为 promise。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 令 _promiseResolve_ 为 Completion(GetPromiseResolve(_C_))。
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_)。
          1. 令 _iteratorRecord_ 为 Completion(GetIterator(_iterable_, ~sync~))。
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_)。
          1. 令 _result_ 为 Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_))。
          1. 如果 _result_ 是一个 abrupt completion，则
            1. 如果 _iteratorRecord_.[[Done]] 是 *false*，将 _result_ 设为 Completion(IteratorClose(_iteratorRecord_, _result_))。
            1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 返回 ! _result_。
        </emu-alg>
        <emu-note>
          <p>如果 _iterable_ 参数不产生任何值，或其产生的 promise 都永不 settle，则此方法返回的挂起 promise 将永不 settle。</p>
        </emu-note>
        <emu-note>
          <p>该函数期望其 *this* 值为一个支持 Promise 构造函数参数约定的构造函数。它还期望其 *this* 值提供一个 `resolve` 方法。</p>
        </emu-note>

        <emu-clause id="sec-performpromiserace" type="abstract operation">
          <h1>
            PerformPromiseRace (
              _iteratorRecord_: 一个 Iterator Record,
              _constructor_: 一个 constructor,
              _resultCapability_: 一个 PromiseCapability Record,
              _promiseResolve_: 一个函数对象,
            ): 要么是包含一个 ECMAScript 语言值的 normal completion，要么是一个 throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 重复，
              1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
              1. 如果 _next_ 是 ~done~，则
                1. 返回 _resultCapability_.[[Promise]]。
              1. 令 _nextPromise_ 为 ? Call(_promiseResolve_, _constructor_, « _next_ »)。
              1. 执行 ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »)。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.reject">
        <h1>Promise.reject ( _r_ )</h1>
        <p>该函数返回一个以传入参数为拒绝原因而被 reject 的新 promise。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 执行 ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »)。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
        <emu-note>
          <p>该函数期望其 *this* 值为一个支持 Promise 构造函数参数约定的构造函数。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.resolve">
        <h1>Promise.resolve ( _x_ )</h1>
        <p>该函数要么返回一个以传入参数 resolve 的新 promise，要么若该参数本身是由此构造函数产生的 promise，则直接返回该参数。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 如果 _C_ 不是一个 Object，抛出 *TypeError* 异常。
          1. 返回 ? PromiseResolve(_C_, _x_)。
        </emu-alg>
        <emu-note>
          <p>该函数期望其 *this* 值为一个支持 Promise 构造函数参数约定的构造函数。</p>
        </emu-note>

        <emu-clause id="sec-promise-resolve" type="abstract operation">
          <h1>
            PromiseResolve (
              _C_: 一个 Object,
              _x_: 一个 ECMAScript 语言值,
            ): 要么是包含一个 ECMAScript 语言值的 normal completion，要么是一个 throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>返回一个以 _x_ resolve 的新 promise。</dd>
          </dl>
          <emu-alg>
            1. 如果 IsPromise(_x_) 是 *true*，则
              1. 令 _xConstructor_ 为 ? Get(_x_, *"constructor"*)。
              1. 如果 SameValue(_xConstructor_, _C_) 是 *true*，返回 _x_。
            1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
            1. 执行 ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »)。
            1. 返回 _promiseCapability_.[[Promise]]。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.try">
        <h1>Promise.try ( _callback_, ..._args_ )</h1>
        <p>该函数在被调用时执行下列步骤：</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 如果 _C_ 不是一个 Object，抛出 *TypeError* 异常。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 令 _status_ 为 Completion(Call(_callback_, *undefined*, _args_))。
          1. 如果 _status_ 是一个 abrupt completion，则
            1. 执行 ? Call(_promiseCapability_.[[Reject]], *undefined*, « _status_.[[Value]] »)。
          1. 否则，
            1. 执行 ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _status_.[[Value]] »)。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
        <emu-note>
          <p>该函数期望其 *this* 值为一个支持 Promise 构造函数参数约定的构造函数。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.withResolvers">
        <h1>Promise.withResolvers ( )</h1>
        <p>该函数返回一个具有三个属性的对象：一个新 promise 以及与之关联的 `resolve` 和 `reject` 函数。</p>
        <emu-alg>
          1. 令 _C_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"promise"*, _promiseCapability_.[[Promise]])。
          1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"resolve"*, _promiseCapability_.[[Resolve]])。
          1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"reject"*, _promiseCapability_.[[Reject]])。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-get-promise-@@species" id="sec-get-promise-%symbol.species%">
        <h1>get Promise [ %Symbol.species% ]</h1>
        <p>`Promise[%Symbol.species%]` 是一个访问器属性，其 set 访问器函数为 *undefined*。其 get 访问器函数在被调用时执行下列步骤：</p>
        <emu-alg>
          1. 返回 *this* 值。
        </emu-alg>
        <p>该函数的 *"name"* 属性值是 *"get [Symbol.species]"*。</p>
        <emu-note>
          <p>Promise 原型方法通常使用其 *this* 值的构造函数来创建一个派生对象。然而，一个子类构造函数可以通过重新定义其 %Symbol.species% 属性来覆盖该默认行为。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Promise 原型对象的属性</h1>
      <p><dfn>Promise 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%Promise.prototype%</dfn>。</li>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Object.prototype%。</li>
        <li>是一个普通对象。</li>
        <li>不具有 [[PromiseState]] 内部槽，也不具有 Promise 实例的其他任何内部槽。</li>
      </ul>

      <emu-clause id="sec-promise.prototype.catch">
        <h1>Promise.prototype.catch ( _onRejected_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _promise_ 为 *this* 值。
          1. 返回 ? Invoke(_promise_, *"then"*, « *undefined*, _onRejected_ »)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.constructor">
        <h1>Promise.prototype.constructor</h1>
        <p>`Promise.prototype.constructor` 的初始值是 %Promise%。</p>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.finally" oldids="sec-thenfinallyfunctions,sec-catchfinallyfunctions">
        <h1>Promise.prototype.finally ( _onFinally_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _promise_ 为 *this* 值。
          1. 如果 _promise_ 不是一个 Object，抛出 *TypeError* 异常。
          1. 令 _C_ 为 ? SpeciesConstructor(_promise_, %Promise%)。
          1. 断言：IsConstructor(_C_) 为 *true*。
          1. 如果 IsCallable(_onFinally_) 为 *false*，则
            1. 令 _thenFinally_ 为 _onFinally_。
            1. 令 _catchFinally_ 为 _onFinally_。
          1. 否则，
            1. 令 _thenFinallyClosure_ 为一个具有参数 (_value_) 的新抽象闭包，捕获 _onFinally_ 与 _C_，在被调用时执行以下步骤：
              1. 令 _result_ 为 ? Call(_onFinally_, *undefined*)。
              1. 令 _p_ 为 ? PromiseResolve(_C_, _result_)。
              1. 令 _returnValue_ 为一个无参数的新抽象闭包，捕获 _value_ 并在被调用时执行以下步骤：
                1. 返回 NormalCompletion(_value_)。
              1. 令 _valueThunk_ 为 CreateBuiltinFunction(_returnValue_, 0, *""*, « »)。
              1. 返回 ? Invoke(_p_, *"then"*, « _valueThunk_ »)。
            1. 令 _thenFinally_ 为 CreateBuiltinFunction(_thenFinallyClosure_, 1, *""*, « »)。
            1. 令 _catchFinallyClosure_ 为一个具有参数 (_reason_) 的新抽象闭包，捕获 _onFinally_ 与 _C_，在被调用时执行以下步骤：
              1. 令 _result_ 为 ? Call(_onFinally_, *undefined*)。
              1. 令 _p_ 为 ? PromiseResolve(_C_, _result_)。
              1. 令 _throwReason_ 为一个无参数的新抽象闭包，捕获 _reason_ 并在被调用时执行以下步骤：
                1. 返回 ThrowCompletion(_reason_)。
              1. 令 _thrower_ 为 CreateBuiltinFunction(_throwReason_, 0, *""*, « »)。
              1. 返回 ? Invoke(_p_, *"then"*, « _thrower_ »)。
            1. 令 _catchFinally_ 为 CreateBuiltinFunction(_catchFinallyClosure_, 1, *""*, « »)。
          1. 返回 ? Invoke(_promise_, *"then"*, « _thenFinally_, _catchFinally_ »)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _promise_ 为 *this* 值。
          1. 如果 IsPromise(_promise_) 为 *false*，抛出 *TypeError* 异常。
          1. 令 _C_ 为 ? SpeciesConstructor(_promise_, %Promise%)。
          1. 令 _resultCapability_ 为 ? NewPromiseCapability(_C_)。
          1. 返回 PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_)。
        </emu-alg>

        <emu-clause id="sec-performpromisethen" type="abstract operation">
          <h1>
            PerformPromiseThen (
              _promise_: a Promise,
              _onFulfilled_: an ECMAScript language value,
              _onRejected_: an ECMAScript language value,
              optional _resultCapability_: a PromiseCapability Record,
            ): an ECMAScript language value
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>使用 _onFulfilled_ 和 _onRejected_ 作为 settle 动作在 _promise_ 上执行 “then” 操作。若传入 _resultCapability_，则通过更新 _resultCapability_ 的 promise 来存储结果；若未传入，则表示 PerformPromiseThen 是由规范内部操作调用，其结果不重要。</dd>
          </dl>
          <emu-alg>
            1. 断言：IsPromise(_promise_) 为 *true*。
            1. 如果 _resultCapability_ 未传入，则
              1. 将 _resultCapability_ 设为 *undefined*。
            1. 如果 IsCallable(_onFulfilled_) 为 *false*，则
              1. 令 _onFulfilledJobCallback_ 为 ~empty~。
            1. 否则，
              1. 令 _onFulfilledJobCallback_ 为 HostMakeJobCallback(_onFulfilled_)。
            1. 如果 IsCallable(_onRejected_) 为 *false*，则
              1. 令 _onRejectedJobCallback_ 为 ~empty~。
            1. 否则，
              1. 令 _onRejectedJobCallback_ 为 HostMakeJobCallback(_onRejected_)。
            1. 令 _fulfillReaction_ 为 PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ }。
            1. 令 _rejectReaction_ 为 PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ }。
            1. 如果 _promise_.[[PromiseState]] 是 ~pending~，则
              1. 将 _fulfillReaction_ 追加到 _promise_.[[PromiseFulfillReactions]]。
              1. 将 _rejectReaction_ 追加到 _promise_.[[PromiseRejectReactions]]。
            1. 否则如果 _promise_.[[PromiseState]] 是 ~fulfilled~，则
              1. 令 _value_ 为 _promise_.[[PromiseResult]]。
              1. 令 _fulfillJob_ 为 NewPromiseReactionJob(_fulfillReaction_, _value_)。
              1. 执行 HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]])。
            1. 否则，
              1. 断言：_promise_.[[PromiseState]] 是 ~rejected~。
              1. 令 _reason_ 为 _promise_.[[PromiseResult]]。
              1. 如果 _promise_.[[PromiseIsHandled]] 为 *false*，执行 HostPromiseRejectionTracker(_promise_, *"handle"*)。
              1. 令 _rejectJob_ 为 NewPromiseReactionJob(_rejectReaction_, _reason_)。
              1. 执行 HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]])。
            1. 将 _promise_.[[PromiseIsHandled]] 设为 *true*。
            1. 如果 _resultCapability_ 是 *undefined*，则
              1. 返回 *undefined*。
            1. 否则，
              1. 返回 _resultCapability_.[[Promise]]。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-promise.prototype-@@tostringtag" id="sec-promise.prototype-%symbol.tostringtag%">
        <h1>Promise.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串值 *"Promise"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* } 属性。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-promise-instances">
      <h1>Promise 实例的属性</h1>
      <p>Promise 实例是普通对象，从 Promise 原型对象（那个内在对象 %Promise.prototype%）继承属性。Promise 实例最初按照 <emu-xref href="#table-internal-slots-of-promise-instances"></emu-xref> 描述的内部槽创建。</p>
      <emu-table id="table-internal-slots-of-promise-instances" caption="Promise 实例的内部槽" oldids="table-59">
        <table>
          <thead>
            <tr>
              <th>
                内部槽
              </th>
              <th>
                类型
              </th>
              <th>
                描述
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[PromiseState]]
            </td>
            <td>
              ~pending~, ~fulfilled~, 或 ~rejected~
            </td>
            <td>
              决定该 promise 对其 `then` 方法的传入调用如何作出反应。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseResult]]
            </td>
            <td>
              一个 ECMAScript 语言值或 ~empty~
            </td>
            <td>
              promise 被 fulfill 或 reject 时的值（若有）。当且仅当 [[PromiseState]] 为 ~pending~ 时为 ~empty~。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseFulfillReactions]]
            </td>
            <td>
              一个 PromiseReaction Record 的 List
            </td>
            <td>
              当（如果）promise 从 ~pending~ 转变为 ~fulfilled~ 状态时要处理的记录。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseRejectReactions]]
            </td>
            <td>
              一个 PromiseReaction Record 的 List
            </td>
            <td>
              当（如果）promise 从 ~pending~ 转变为 ~rejected~ 状态时要处理的记录。
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseIsHandled]]
            </td>
            <td>
              一个 Boolean
            </td>
            <td>
              指示该 promise 是否曾拥有过 fulfill 或 reject 处理器；用于未处理拒绝的跟踪。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generatorfunction-objects">
    <h1>GeneratorFunction 对象</h1>
    <p>GeneratorFunction 是通常通过求值 |GeneratorDeclaration|、|GeneratorExpression| 和 |GeneratorMethod| 产生的函数。也可通过调用内在对象 %GeneratorFunction% 创建。</p>
    <emu-figure id="figure-2" caption="Generator 对象关系" informative>
      <img alt="大量框与箭头的示意图。" height="700" src="https://tc39.es/ecma262/img/figure-2.svg" width="900">
    </emu-figure>

    <emu-clause id="sec-generatorfunction-constructor">
      <h1>GeneratorFunction 构造函数</h1>
      <p>GeneratorFunction 构造函数：</p>
      <ul>
        <li>是 <dfn>%GeneratorFunction%</dfn>。</li>
        <li>是 `Function` 的子类。</li>
        <li>当以函数（而非构造函数）方式调用时创建并初始化一个新的 GeneratorFunction。故函数调用 `GeneratorFunction (…)` 等价于以相同参数的对象创建表达式 `new GeneratorFunction (…)`。</li>
        <li>可用作类定义中 `extends` 子句的值。意图继承指定 GeneratorFunction 行为的子类构造函数必须包含对 GeneratorFunction 构造函数的 `super` 调用，以创建并初始化带有内建 GeneratorFunction 行为所需内部槽的子类实例。所有用于定义 generator 函数对象的 ECMAScript 语法形式都会创建 GeneratorFunction 的直接实例。没有语法手段创建 GeneratorFunction 子类的实例。</li>
      </ul>

      <emu-clause id="sec-generatorfunction">
        <h1>GeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最后一个参数（如果存在）指定生成器函数的函数体（可执行代码）；之前的任意参数指定形式参数。</p>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _C_ 为活动函数对象。
          1. 如果 _bodyArg_ 不存在，将 _bodyArg_ 设为空字符串。
          1. 返回 ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_)。
        </emu-alg>
        <emu-note>
          <p>参见 <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> 的注。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-constructor">
      <h1>GeneratorFunction 构造函数的属性</h1>
      <p>GeneratorFunction 构造函数：</p>
      <ul>
        <li>是一个继承自 Function 构造函数的标准内建函数对象。</li>
        <li>具有值为 %Function% 的 [[Prototype]] 内部槽。</li>
        <li oldids="sec-generatorfunction.length">具有值为 *1*<sub>𝔽</sub> 的 *"length"* 属性。</li>
        <li>具有值为 *"GeneratorFunction"* 的 *"name"* 属性。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype">
        <h1>GeneratorFunction.prototype</h1>
        <p>`GeneratorFunction.prototype` 的初始值是 GeneratorFunction 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-prototype-object">
      <h1>GeneratorFunction 原型对象的属性</h1>
      <p><dfn>GeneratorFunction 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%GeneratorFunction.prototype%</dfn>（见 <emu-xref href="#figure-2"></emu-xref>）。</li>
        <li>是一个普通对象。</li>
        <li>不是函数对象，且没有 [[ECMAScriptCode]] 内部槽，也没有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 或 <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref> 中列出的任何其他内部槽。</li>
        <li>具有值为 %Function.prototype% 的 [[Prototype]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype.constructor">
        <h1>GeneratorFunction.prototype.constructor</h1>
        <p>`GeneratorFunction.prototype.constructor` 的初始值是 %GeneratorFunction%。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype.prototype">
        <h1>GeneratorFunction.prototype.prototype</h1>
        <p>`GeneratorFunction.prototype.prototype` 的初始值是 %GeneratorPrototype%。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-generatorfunction.prototype-@@tostringtag" id="sec-generatorfunction.prototype-%symbol.tostringtag%">
        <h1>GeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"GeneratorFunction"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-generatorfunction-instances">
      <h1>GeneratorFunction 实例</h1>
      <p>每个 GeneratorFunction 实例都是一个 ECMAScript 函数对象，并拥有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。所有此类实例的 [[IsClassConstructor]] 内部槽的值为 *false*。</p>
      <p>每个 GeneratorFunction 实例具有以下自有属性：</p>

      <emu-clause id="sec-generatorfunction-instances-length">
        <h1>length</h1>
        <p><emu-xref href="#sec-function-instances-length"></emu-xref> 中给出的 Function 实例 *"length"* 属性规范同样适用于 GeneratorFunction 实例。</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> 中给出的 Function 实例 *"name"* 属性规范同样适用于 GeneratorFunction 实例。</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-prototype">
        <h1>prototype</h1>
        <p>每当创建一个 GeneratorFunction 实例时，也会创建另一个普通对象，作为该生成器函数 *"prototype"* 属性的初始值。该 prototype 属性的值用于在以 [[Call]] 调用该生成器函数对象时初始化新建 Generator 的 [[Prototype]] 内部槽。</p>
        <p>该属性具有 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>不同于 Function 实例，GeneratorFunction 的 *"prototype"* 属性值对象没有 *"constructor"* 属性，其值为该 GeneratorFunction 实例。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgeneratorfunction-objects">
    <h1>AsyncGeneratorFunction 对象</h1>
    <p>AsyncGeneratorFunction 是通常通过求值 |AsyncGeneratorDeclaration|、|AsyncGeneratorExpression| 和 |AsyncGeneratorMethod| 语法产生式创建的函数。也可通过调用内在对象 %AsyncGeneratorFunction% 创建。</p>

    <emu-clause id="sec-asyncgeneratorfunction-constructor">
      <h1>AsyncGeneratorFunction 构造函数</h1>
      <p>AsyncGeneratorFunction 构造函数：</p>
      <ul>
        <li>是 <dfn>%AsyncGeneratorFunction%</dfn>。</li>
        <li>是 `Function` 的子类。</li>
        <li>当以函数（而非构造函数）方式调用时创建并初始化一个新的 AsyncGeneratorFunction。故函数调用 `AsyncGeneratorFunction (...)` 等价于以相同参数的对象创建表达式 `new AsyncGeneratorFunction (...)`。</li>
        <li>可用作类定义中 `extends` 子句的值。意图继承指定 AsyncGeneratorFunction 行为的子类构造函数必须包含对 AsyncGeneratorFunction 构造函数的 `super` 调用，以创建并初始化带有内建 AsyncGeneratorFunction 行为所需内部槽的子类实例。所有用于定义 async generator 函数对象的 ECMAScript 语法形式都会创建 AsyncGeneratorFunction 的直接实例。没有语法手段创建 AsyncGeneratorFunction 子类的实例。</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction">
        <h1>AsyncGeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最后一个参数（如果存在）指定异步生成器函数的函数体（可执行代码）；之前的任意参数指定形式参数。</p>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _C_ 为活动函数对象。
          1. 如果 _bodyArg_ 不存在，将 _bodyArg_ 设为空字符串。
          1. 返回 ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_)。
        </emu-alg>
        <emu-note>
          <p>参见 <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> 的注。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction">
      <h1>AsyncGeneratorFunction 构造函数的属性</h1>
      <p>AsyncGeneratorFunction 构造函数：</p>
      <ul>
        <li>是一个继承自 Function 构造函数的标准内建函数对象。</li>
        <li>具有值为 %Function% 的 [[Prototype]] 内部槽。</li>
        <li oldids="sec-asyncgeneratorfunction-length">具有值为 *1*<sub>𝔽</sub> 的 *"length"* 属性。</li>
        <li>具有值为 *"AsyncGeneratorFunction"* 的 *"name"* 属性。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype">
        <h1>AsyncGeneratorFunction.prototype</h1>
        <p>`AsyncGeneratorFunction.prototype` 的初始值是 AsyncGeneratorFunction 原型对象。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction-prototype">
      <h1>AsyncGeneratorFunction 原型对象的属性</h1>
      <p><dfn>AsyncGeneratorFunction 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%AsyncGeneratorFunction.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是函数对象，且没有 [[ECMAScriptCode]] 内部槽，也没有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 或 <emu-xref href="#table-internal-slots-of-asyncgenerator-instances"></emu-xref> 中列出的任何其他内部槽。</li>
        <li>具有值为 %Function.prototype% 的 [[Prototype]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-constructor">
        <h1>AsyncGeneratorFunction.prototype.constructor</h1>
        <p>`AsyncGeneratorFunction.prototype.constructor` 的初始值是 %AsyncGeneratorFunction%。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-prototype">
        <h1>AsyncGeneratorFunction.prototype.prototype</h1>
        <p>`AsyncGeneratorFunction.prototype.prototype` 的初始值是 %AsyncGeneratorPrototype%。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-asyncgeneratorfunction-prototype-tostringtag" id="sec-asyncgeneratorfunction-prototype-%symbol.tostringtag%">
        <h1>AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"AsyncGeneratorFunction"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunction-instances">
      <h1>AsyncGeneratorFunction 实例</h1>
      <p>每个 AsyncGeneratorFunction 实例都是一个 ECMAScript 函数对象，并拥有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。所有此类实例的 [[IsClassConstructor]] 内部槽的值为 *false*。</p>
      <p>每个 AsyncGeneratorFunction 实例具有以下自有属性：</p>

      <emu-clause id="sec-asyncgeneratorfunction-instance-length">
        <h1>length</h1>
        <p>*"length"* 属性的值是一个整数 Number，表示该 AsyncGeneratorFunction 期望的典型参数个数。然而，语言允许以其他参数个数调用该函数。以不同于其 *"length"* 属性指定参数个数调用时 AsyncGeneratorFunction 的行为依赖于函数本身。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> 中给出的 Function 实例 *"name"* 属性规范同样适用于 AsyncGeneratorFunction 实例。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-prototype">
        <h1>prototype</h1>
        <p>每当创建一个 AsyncGeneratorFunction 实例时，也会创建另一个普通对象，作为该异步生成器函数 *"prototype"* 属性的初始值。该 prototype 属性的值用于在以 [[Call]] 调用该生成器函数对象时初始化新建 AsyncGenerator 的 [[Prototype]] 内部槽。</p>
        <p>该属性具有 { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <emu-note>
          <p>不同于函数实例，AsyncGeneratorFunction 的 *"prototype"* 属性值对象没有 *"constructor"* 属性，其值为该 AsyncGeneratorFunction 实例。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator 对象</h1>
    <p>Generator 通过调用一个生成器函数创建，并符合迭代器接口与可迭代接口。</p>
    <p>Generator 实例直接从创建该实例的生成器函数 *"prototype"* 属性初始值继承属性。Generator 实例间接从 %GeneratorPrototype% 继承属性。</p>

    <emu-clause id="sec-properties-of-generator-prototype">
      <h1>%GeneratorPrototype% 对象</h1>
      <p><dfn>%GeneratorPrototype%</dfn> 对象：</p>
      <ul>
        <li>是 <dfn>%GeneratorFunction.prototype.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是一个 Generator 实例，且没有 [[GeneratorState]] 内部槽。</li>
        <li>具有值为 %Iterator.prototype% 的 [[Prototype]] 内部槽。</li>
        <li>具有被所有 Generator 实例间接继承的属性。</li>
      </ul>

      <emu-clause id="sec-generator.prototype.constructor">
        <h1>%GeneratorPrototype%.constructor</h1>
        <p>%GeneratorPrototype%`.constructor` 的初始值是 %GeneratorFunction.prototype%。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.next">
        <h1>%GeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. 返回 ? GeneratorResume(*this* value, _value_, ~empty~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.return">
        <h1>%GeneratorPrototype%.return ( _value_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _g_ 为 *this* 值。
          1. 令 _C_ 为 ReturnCompletion(_value_)。
          1. 返回 ? GeneratorResumeAbrupt(_g_, _C_, ~empty~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.throw">
        <h1>%GeneratorPrototype%.throw ( _exception_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _g_ 为 *this* 值。
          1. 令 _C_ 为 ThrowCompletion(_exception_)。
          1. 返回 ? GeneratorResumeAbrupt(_g_, _C_, ~empty~)。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-generator.prototype-@@tostringtag" id="sec-generator.prototype-%symbol.tostringtag%">
        <h1>%GeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Generator"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Generator 实例的属性</h1>
      <p>Generator 实例最初按 <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref> 中描述的内部槽创建。</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Generator 实例的内部槽" oldids="table-56">
        <table>
          <thead>
            <tr>
              <th>
                内部槽
              </th>
              <th>
                类型
              </th>
              <th>
                描述
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              ~suspended-start~, ~suspended-yield~, ~executing~, 或 ~completed~
            </td>
            <td>
              该生成器的当前执行状态。
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              一个执行上下文
            </td>
            <td>
              执行该生成器代码时使用的执行上下文。
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              一个 String 或 ~empty~
            </td>
            <td>
              用于区分不同种类生成器的标记。由 ECMAScript 源文本声明的生成器的 [[GeneratorBrand]] 始终为 ~empty~。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator 抽象操作</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_generator_.[[GeneratorState]] 是 ~suspended-start~。
          1. 令 _genContext_ 为正在运行的执行上下文。
          1. 将 _genContext_ 的 Generator 组件设为 _generator_。
          1. 令 _closure_ 为一个无参数的新抽象闭包，捕获 _generatorBody_ 并在被调用时执行以下步骤：
            1. 令 _acGenContext_ 为正在运行的执行上下文。
            1. 令 _acGenerator_ 为 _acGenContext_ 的 Generator 组件。
            1. 如果 _generatorBody_ 是一个 Parse Node，则
              1. 令 _result_ 为 Completion(Evaluation of _generatorBody_)。
            1. 否则，
              1. 断言：_generatorBody_ 是一个无参数抽象闭包。
              1. 令 _result_ 为 Completion(_generatorBody_())。
            1. 断言：若我们在此返回，生成器要么抛出了异常，要么执行了隐式或显式的 return。
            1. 将 _acGenContext_ 从执行上下文栈移除，并恢复栈顶执行上下文为正在运行的执行上下文。
            1. 将 _acGenerator_.[[GeneratorState]] 设为 ~completed~。
            1. 注：一旦生成器进入 ~completed~ 状态，它将不再离开该状态，其关联执行上下文不再恢复。此时可丢弃与 _acGenerator_ 相关的任意执行状态。
            1. 如果 _result_ 是一个 normal completion，则
              1. 令 _resultValue_ 为 *undefined*。
            1. 否则如果 _result_ 是一个 return completion，则
              1. 令 _resultValue_ 为 _result_.[[Value]]。
            1. 否则，
              1. 断言：_result_ 是一个 throw completion。
              1. 返回 ? _result_。
            1. 返回 NormalCompletion(CreateIteratorResultObject(_resultValue_, *true*))。
          1. 设定 _genContext_ 的代码求值状态，使得当该执行上下文恢复求值时，将无参数调用 _closure_。
          1. 将 _generator_.[[GeneratorContext]] 设为 _genContext_。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing one of ~suspended-start~, ~suspended-yield~, or ~completed~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_generator_, [[GeneratorState]])。
          1. 执行 ? RequireInternalSlot(_generator_, [[GeneratorBrand]])。
          1. 如果 _generator_.[[GeneratorBrand]] 不等于 _generatorBrand_，抛出 *TypeError* 异常。
          1. 断言：_generator_ 也有 [[GeneratorContext]] 内部槽。
          1. 令 _state_ 为 _generator_.[[GeneratorState]]。
          1. 如果 _state_ 是 ~executing~，抛出 *TypeError* 异常。
          1. 返回 _state_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _state_ 为 ? GeneratorValidate(_generator_, _generatorBrand_)。
          1. 如果 _state_ 是 ~completed~，返回 CreateIteratorResultObject(*undefined*, *true*)。
          1. 断言：_state_ 是 ~suspended-start~ 或 ~suspended-yield~。
          1. 令 _genContext_ 为 _generator_.[[GeneratorContext]]。
          1. 令 _methodContext_ 为正在运行的执行上下文。
          1. 挂起 _methodContext_。
          1. 将 _generator_.[[GeneratorState]] 设为 ~executing~。
          1. 将 _genContext_ 压入执行上下文栈；_genContext_ 现在是正在运行的执行上下文。
          1. <emu-meta effects="user-code">恢复 _genContext_ 的挂起求值</emu-meta>，使用 NormalCompletion(_value_) 作为使其挂起的操作的结果。令 _result_ 为恢复计算返回的值。
          1. 断言：当我们在此返回时，_genContext_ 已从执行上下文栈移除且 _methodContext_ 是当前正在运行的执行上下文。
          1. 返回 ? _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _state_ 为 ? GeneratorValidate(_generator_, _generatorBrand_)。
          1. 如果 _state_ 是 ~suspended-start~，则
            1. 将 _generator_.[[GeneratorState]] 设为 ~completed~。
            1. 注：一旦生成器进入 ~completed~ 状态，它将不再离开该状态，其关联执行上下文不再恢复。此时可丢弃与 _generator_ 相关的任意执行状态。
            1. 将 _state_ 设为 ~completed~。
          1. 如果 _state_ 是 ~completed~，则
            1. 如果 _abruptCompletion_ 是一个 return completion，则
              1. 返回 CreateIteratorResultObject(_abruptCompletion_.[[Value]], *true*)。
            1. 返回 ? _abruptCompletion_。
          1. 断言：_state_ 是 ~suspended-yield~。
          1. 令 _genContext_ 为 _generator_.[[GeneratorContext]]。
          1. 令 _methodContext_ 为正在运行的执行上下文。
          1. 挂起 _methodContext_。
          1. 将 _generator_.[[GeneratorState]] 设为 ~executing~。
          1. 将 _genContext_ 压入执行上下文栈；_genContext_ 现在是正在运行的执行上下文。
          1. <emu-meta effects="user-code">恢复 _genContext_ 的挂起求值</emu-meta>，使用 _abruptCompletion_ 作为使其挂起的操作的结果。令 _result_ 为恢复计算返回的 Completion Record。
          1. 断言：当我们在此返回时，_genContext_ 已从执行上下文栈移除且 _methodContext_ 是当前正在运行的执行上下文。
          1. 返回 ? _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getgeneratorkind" type="abstract operation">
        <h1>GetGeneratorKind ( ): ~non-generator~, ~sync~, or ~async~</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _genContext_ 为正在运行的执行上下文。
          1. 如果 _genContext_ 没有 Generator 组件，返回 ~non-generator~。
          1. 令 _generator_ 为 _genContext_ 的 Generator 组件。
          1. 如果 _generator_ 具有 [[AsyncGeneratorState]] 内部槽，返回 ~async~。
          1. 否则，返回 ~sync~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatoryield" type="abstract operation">
        <h1>
          GeneratorYield (
            _iteratorResult_: an Object that conforms to the IteratorResult interface,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. 令 _genContext_ 为正在运行的执行上下文。
          1. 断言：_genContext_ 是一个生成器的执行上下文。
          1. 令 _generator_ 为 _genContext_ 的 Generator 组件的值。
          1. 断言：GetGeneratorKind() 是 ~sync~。
          1. 将 _generator_.[[GeneratorState]] 设为 ~suspended-yield~。
          1. 将 _genContext_ 从执行上下文栈移除，恢复栈顶执行上下文为正在运行的执行上下文。
          1. 令 _callerContext_ 为正在运行的执行上下文。
          1. 恢复 _callerContext_，传入 NormalCompletion(_iteratorResult_)。如果 _genContext_ 之后再次被恢复，令 _resumptionValue_ 为恢复时使用的 Completion Record。
          1. 断言：若控制流到达此处，则 _genContext_ 再次成为正在运行的执行上下文。
          1. 返回 _resumptionValue_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yield" type="abstract operation">
        <h1>
          Yield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _generatorKind_ 为 GetGeneratorKind()。
          1. 如果 _generatorKind_ 是 ~async~，返回 ? AsyncGeneratorYield(? Await(_value_))。
          1. 否则，返回 ? GeneratorYield(CreateIteratorResultObject(_value_, *false*))。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
            optional _extraSlots_: a List of names of internal slots,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 注：_closure_ 可以包含对 Yield 操作的使用，以产出一个 IteratorResult 对象。
          1. 如果 _extraSlots_ 不存在，将 _extraSlots_ 设为一个新的空 List。
          1. 令 _internalSlotsList_ 为 _extraSlots_ 与 « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] » 的列表连接。
          1. 令 _generator_ 为 OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_)。
          1. 将 _generator_.[[GeneratorBrand]] 设为 _generatorBrand_。
          1. 将 _generator_.[[GeneratorState]] 设为 ~suspended-start~。
          1. 令 _callerContext_ 为正在运行的执行上下文。
          1. 令 _calleeContext_ 为一个新的执行上下文。
          1. 将 _calleeContext_ 的 Function 设为 *null*。
          1. 将 _calleeContext_ 的 Realm 设为当前 Realm Record。
          1. 将 _calleeContext_ 的 ScriptOrModule 设为 _callerContext_ 的 ScriptOrModule。
          1. 如果 _callerContext_ 尚未被挂起，则挂起 _callerContext_。
          1. 将 _calleeContext_ 压入执行上下文栈；_calleeContext_ 现在是正在运行的执行上下文。
          1. 执行 GeneratorStart(_generator_, _closure_)。
          1. 将 _calleeContext_ 从执行上下文栈移除并恢复 _callerContext_ 为正在运行的执行上下文。
          1. 返回 _generator_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator 对象</h1>
    <p>AsyncGenerator 通过调用一个 async 生成器函数创建，并同时符合异步迭代器接口与异步可迭代接口。</p>

    <p>AsyncGenerator 实例直接从创建该实例的异步生成器函数 *"prototype"* 属性的初始值继承属性。AsyncGenerator 实例间接从 %AsyncGeneratorPrototype% 继承属性。</p>

    <emu-clause id="sec-properties-of-asyncgenerator-prototype">
      <h1>%AsyncGeneratorPrototype% 对象</h1>
      <p><dfn>%AsyncGeneratorPrototype%</dfn> 对象：</p>
      <ul>
        <li>是 <dfn>%AsyncGeneratorFunction.prototype.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是 AsyncGenerator 实例，并且没有 [[AsyncGeneratorState]] 内部槽。</li>
        <li>具有值为 %AsyncIteratorPrototype% 的 [[Prototype]] 内部槽。</li>
        <li>具有被所有 AsyncGenerator 实例间接继承的属性。</li>
      </ul>

      <emu-clause id="sec-asyncgenerator-prototype-constructor">
        <h1>%AsyncGeneratorPrototype%.constructor</h1>
        <p>%AsyncGeneratorPrototype%`.constructor` 的初始值是 %AsyncGeneratorFunction.prototype%。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-next">
        <h1>%AsyncGeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. 令 _generator_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
          1. 令 _result_ 为 Completion(AsyncGeneratorValidate(_generator_, ~empty~))。
          1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 令 _state_ 为 _generator_.[[AsyncGeneratorState]]。
          1. 如果 _state_ 是 ~completed~，则
            1. 令 _iteratorResult_ 为 CreateIteratorResultObject(*undefined*, *true*)。
            1. 执行 ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »)。
            1. 返回 _promiseCapability_.[[Promise]]。
          1. 令 _completion_ 为 NormalCompletion(_value_)。
          1. 执行 AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_)。
          1. 如果 _state_ 是 ~suspended-start~ 或 ~suspended-yield~，则
            1. 执行 AsyncGeneratorResume(_generator_, _completion_)。
          1. 否则，
            1. 断言：_state_ 是 ~executing~ 或 ~draining-queue~。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-return">
        <h1>%AsyncGeneratorPrototype%.return ( _value_ )</h1>
        <emu-alg>
          1. 令 _generator_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
          1. 令 _result_ 为 Completion(AsyncGeneratorValidate(_generator_, ~empty~))。
          1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 令 _completion_ 为 ReturnCompletion(_value_)。
          1. 执行 AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_)。
          1. 令 _state_ 为 _generator_.[[AsyncGeneratorState]]。
          1. 如果 _state_ 是 ~suspended-start~ 或 ~completed~，则
            1. 将 _generator_.[[AsyncGeneratorState]] 设为 ~draining-queue~。
            1. 执行 AsyncGeneratorAwaitReturn(_generator_)。
          1. 否则如果 _state_ 是 ~suspended-yield~，则
            1. 执行 AsyncGeneratorResume(_generator_, _completion_)。
          1. 否则，
            1. 断言：_state_ 是 ~executing~ 或 ~draining-queue~。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-throw">
        <h1>%AsyncGeneratorPrototype%.throw ( _exception_ )</h1>
        <emu-alg>
          1. 令 _generator_ 为 *this* 值。
          1. 令 _promiseCapability_ 为 ! NewPromiseCapability(%Promise%)。
          1. 令 _result_ 为 Completion(AsyncGeneratorValidate(_generator_, ~empty~))。
          1. IfAbruptRejectPromise(_result_, _promiseCapability_)。
          1. 令 _state_ 为 _generator_.[[AsyncGeneratorState]]。
          1. 如果 _state_ 是 ~suspended-start~，则
            1. 将 _generator_.[[AsyncGeneratorState]] 设为 ~completed~。
            1. 将 _state_ 设为 ~completed~。
          1. 如果 _state_ 是 ~completed~，则
            1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »)。
            1. 返回 _promiseCapability_.[[Promise]]。
          1. 令 _completion_ 为 ThrowCompletion(_exception_)。
          1. 执行 AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_)。
          1. 如果 _state_ 是 ~suspended-yield~，则
            1. 执行 AsyncGeneratorResume(_generator_, _completion_)。
          1. 否则，
            1. 断言：_state_ 是 ~executing~ 或 ~draining-queue~。
          1. 返回 _promiseCapability_.[[Promise]]。
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-asyncgenerator-prototype-tostringtag" id="sec-asyncgenerator-prototype-%symbol.tostringtag%">
        <h1>%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"AsyncGenerator"*。</p>
        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>AsyncGenerator 实例的属性</h1>
      <p>AsyncGenerator 实例最初按如下描述的内部槽创建：</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="AsyncGenerator 实例的内部槽">
        <table>
          <thead>
            <tr>
              <th>内部槽</th>
              <th>类型</th>
              <th>描述</th>
            </tr>
          </thead>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>~suspended-start~, ~suspended-yield~, ~executing~, ~draining-queue~, 或 ~completed~</td>
            <td>异步生成器的当前执行状态。</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>一个执行上下文</td>
            <td>执行该异步生成器代码时使用的执行上下文。</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>一个 AsyncGeneratorRequest Record 的 List</td>
            <td>表示恢复该异步生成器请求的记录。除状态转换期间外，当且仅当 [[AsyncGeneratorState]] 为 ~executing~ 或 ~draining-queue~ 时其非空。</td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>一个 String 或 ~empty~</td>
            <td>用于区分不同种类异步生成器的标记。由 ECMAScript 源文本声明的异步生成器的 [[GeneratorBrand]] 始终为 ~empty~。</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator 抽象操作</h1>

      <emu-clause id="sec-asyncgeneratorrequest-records">
        <h1>AsyncGeneratorRequest 记录</h1>
        <p><dfn variants="AsyncGeneratorRequests">AsyncGeneratorRequest</dfn> 是一个 Record 值，用于存储关于异步生成器应如何恢复的信息，并包含履行或拒绝相应 promise 的能力。</p>
        <p>其具有以下字段：</p>
        <emu-table caption="AsyncGeneratorRequest Record 字段">
          <table>
            <thead>
              <tr>
                <th>字段名</th>
                <th>取值</th>
                <th>含义</th>
              </tr>
            </thead>
            <tr>
              <td>[[Completion]]</td>
              <td>一个 Completion Record</td>
              <td>用于恢复该异步生成器的 Completion Record。</td>
            </tr>
            <tr>
              <td>[[Capability]]</td>
              <td>一个 PromiseCapability Record</td>
              <td>与此请求关联的 promise 能力。</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_generator_.[[AsyncGeneratorState]] 是 ~suspended-start~。
          1. 令 _genContext_ 为正在运行的执行上下文。
          1. 将 _genContext_ 的 Generator 组件设为 _generator_。
          1. 令 _closure_ 为一个无参数的新抽象闭包，捕获 _generatorBody_ 并在被调用时执行以下步骤：
            1. 令 _acGenContext_ 为正在运行的执行上下文。
            1. 令 _acGenerator_ 为 _acGenContext_ 的 Generator 组件。
            1. 如果 _generatorBody_ 是一个 Parse Node，则
              1. 令 _result_ 为 Completion(Evaluation of _generatorBody_)。
            1. 否则，
              1. 断言：_generatorBody_ 是一个无参数抽象闭包。
              1. 令 _result_ 为 Completion(_generatorBody_())。
            1. 断言：若我们在此返回，异步生成器要么抛出异常，要么执行了隐式或显式的 return。
            1. 将 _acGenContext_ 从执行上下文栈移除，并恢复栈顶执行上下文为正在运行的执行上下文。
            1. 将 _acGenerator_.[[AsyncGeneratorState]] 设为 ~draining-queue~。
            1. 如果 _result_ 是一个 normal completion，将 _result_ 设为 NormalCompletion(*undefined*)。
            1. 如果 _result_ 是一个 return completion，将 _result_ 设为 NormalCompletion(_result_.[[Value]])。
            1. 执行 AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*)。
            1. 执行 AsyncGeneratorDrainQueue(_acGenerator_)。
            1. 返回 NormalCompletion(*undefined*)。
          1. 设定 _genContext_ 的代码求值状态，使得当该执行上下文恢复求值时，将无参数调用 _closure_。
          1. 将 _generator_.[[AsyncGeneratorContext]] 设为 _genContext_。
          1. 将 _generator_.[[AsyncGeneratorQueue]] 设为一个新的空 List。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 执行 ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]])。
          1. 执行 ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]])。
          1. 执行 ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]])。
          1. 如果 _generator_.[[GeneratorBrand]] 不等于 _generatorBrand_，抛出 *TypeError* 异常。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorenqueue" type="abstract operation">
        <h1>
          AsyncGeneratorEnqueue (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _promiseCapability_: a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _request_ 为 AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }。
          1. 将 _request_ 追加到 _generator_.[[AsyncGeneratorQueue]]。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorcompletestep" type="abstract operation">
        <h1>
          AsyncGeneratorCompleteStep (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _done_: a Boolean,
            optional _realm_: a Realm Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_generator_.[[AsyncGeneratorQueue]] 非空。
          1. 令 _next_ 为 _generator_.[[AsyncGeneratorQueue]] 的第一个元素。
          1. 移除 _generator_.[[AsyncGeneratorQueue]] 的第一个元素。
          1. 令 _promiseCapability_ 为 _next_.[[Capability]]。
          1. 令 _value_ 为 _completion_.[[Value]]。
          1. 如果 _completion_ 是一个 throw completion，则
            1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »)。
          1. 否则，
            1. 断言：_completion_ 是一个 normal completion。
            1. 如果存在 _realm_，则
              1. 令 _oldRealm_ 为正在运行的执行上下文的 Realm。
              1. 将正在运行的执行上下文的 Realm 设为 _realm_。
              1. 令 _iteratorResult_ 为 CreateIteratorResultObject(_value_, _done_)。
              1. 将正在运行的执行上下文的 Realm 设回 _oldRealm_。
            1. 否则，
              1. 令 _iteratorResult_ 为 CreateIteratorResultObject(_value_, _done_)。
            1. 执行 ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_generator_.[[AsyncGeneratorState]] 是 ~suspended-start~ 或 ~suspended-yield~。
          1. 令 _genContext_ 为 _generator_.[[AsyncGeneratorContext]]。
          1. 令 _callerContext_ 为正在运行的执行上下文。
          1. 挂起 _callerContext_。
          1. 将 _generator_.[[AsyncGeneratorState]] 设为 ~executing~。
          1. 将 _genContext_ 压入执行上下文栈；_genContext_ 现在是正在运行的执行上下文。
          1. <emu-meta effects="user-code">恢复 _genContext_ 的挂起求值</emu-meta>，使用 _completion_ 作为使其挂起的操作的结果。令 _result_ 为恢复计算返回的 Completion Record。
          1. 断言：_result_ 永不是一个 abrupt completion。
          1. 断言：当我们在此返回时，_genContext_ 已从执行上下文栈移除且 _callerContext_ 是当前正在运行的执行上下文。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorunwrapyieldresumption" type="abstract operation">
        <h1>
          AsyncGeneratorUnwrapYieldResumption (
            _resumptionValue_: a Completion Record,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _resumptionValue_ 不是一个 return completion，返回 ? _resumptionValue_。
          1. 令 _awaited_ 为 Completion(Await(_resumptionValue_.[[Value]]))。
          1. 如果 _awaited_ 是一个 throw completion，返回 ? _awaited_。
          1. 断言：_awaited_ 是一个 normal completion。
          1. 返回 ReturnCompletion(_awaited_.[[Value]])。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratoryield" type="abstract operation">
        <h1>
          AsyncGeneratorYield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _genContext_ 为正在运行的执行上下文。
          1. 断言：_genContext_ 是一个生成器的执行上下文。
          1. 令 _generator_ 为 _genContext_ 的 Generator 组件的值。
          1. 断言：GetGeneratorKind() 是 ~async~。
          1. 令 _completion_ 为 NormalCompletion(_value_)。
          1. 断言：执行上下文栈至少有两个元素。
          1. 令 _previousContext_ 为执行上下文栈倒数第二个元素。
          1. 令 _previousRealm_ 为 _previousContext_ 的 Realm。
          1. 执行 AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_)。
          1. 令 _queue_ 为 _generator_.[[AsyncGeneratorQueue]]。
          1. 如果 _queue_ 非空，则
            1. 注：执行在不挂起生成器的情况下继续。
            1. 令 _toYield_ 为 _queue_ 的第一个元素。
            1. 令 _resumptionValue_ 为 Completion(_toYield_.[[Completion]])。
            1. 返回 ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_)。
          1. 否则，
            1. 将 _generator_.[[AsyncGeneratorState]] 设为 ~suspended-yield~。
            1. 将 _genContext_ 从执行上下文栈移除并恢复栈顶执行上下文为正在运行的执行上下文。
            1. 令 _callerContext_ 为正在运行的执行上下文。
            1. 恢复 _callerContext_，传入 *undefined*。如果 _genContext_ 之后再次被恢复，令 _resumptionValue_ 为恢复时使用的 Completion Record。
            1. 断言：若控制流到达此处，则 _genContext_ 再次成为正在运行的执行上下文。
            1. 返回 ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorawaitreturn" type="abstract operation">
        <h1>
          AsyncGeneratorAwaitReturn (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_generator_.[[AsyncGeneratorState]] 是 ~draining-queue~。
          1. 令 _queue_ 为 _generator_.[[AsyncGeneratorQueue]]。
          1. 断言：_queue_ 非空。
          1. 令 _next_ 为 _queue_ 的第一个元素。
          1. 令 _completion_ 为 Completion(_next_.[[Completion]])。
          1. 断言：_completion_ 是一个 return completion。
          1. 令 _promiseCompletion_ 为 Completion(PromiseResolve(%Promise%, _completion_.[[Value]]))。
          1. 如果 _promiseCompletion_ 是一个 abrupt completion，则
            1. 执行 AsyncGeneratorCompleteStep(_generator_, _promiseCompletion_, *true*)。
            1. 执行 AsyncGeneratorDrainQueue(_generator_)。
            1. 返回 ~unused~。
          1. 断言：_promiseCompletion_ 是一个 normal completion。
          1. 令 _promise_ 为 _promiseCompletion_.[[Value]]。
          1. 令 _fulfilledClosure_ 为一个具有参数 (_value_) 的新抽象闭包，捕获 _generator_ 并在被调用时执行以下步骤：
            1. 断言：_generator_.[[AsyncGeneratorState]] 是 ~draining-queue~。
            1. 令 _result_ 为 NormalCompletion(_value_)。
            1. 执行 AsyncGeneratorCompleteStep(_generator_, _result_, *true*)。
            1. 执行 AsyncGeneratorDrainQueue(_generator_)。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _onFulfilled_ 为 CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « »)。
          1. 令 _rejectedClosure_ 为一个具有参数 (_reason_) 的新抽象闭包，捕获 _generator_ 并在被调用时执行以下步骤：
            1. 断言：_generator_.[[AsyncGeneratorState]] 是 ~draining-queue~。
            1. 令 _result_ 为 ThrowCompletion(_reason_)。
            1. 执行 AsyncGeneratorCompleteStep(_generator_, _result_, *true*)。
            1. 执行 AsyncGeneratorDrainQueue(_generator_)。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _onRejected_ 为 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »)。
          1. 执行 PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratordrainqueue" type="abstract operation">
        <h1>
          AsyncGeneratorDrainQueue (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>它会耗尽生成器的 AsyncGeneratorQueue，直到遇到持有 return completion 的 AsyncGeneratorRequest。</dd>
        </dl>
        <emu-alg>
          1. 断言：_generator_.[[AsyncGeneratorState]] 是 ~draining-queue~。
          1. 令 _queue_ 为 _generator_.[[AsyncGeneratorQueue]]。
          1. 当 _queue_ 非空时重复，
            1. 令 _next_ 为 _queue_ 的第一个元素。
            1. 令 _completion_ 为 Completion(_next_.[[Completion]])。
            1. 如果 _completion_ 是一个 return completion，则
              1. 执行 AsyncGeneratorAwaitReturn(_generator_)。
              1. 返回 ~unused~。
            1. 否则，
              1. 如果 _completion_ 是一个 normal completion，则
                1. 将 _completion_ 设为 NormalCompletion(*undefined*)。
              1. 执行 AsyncGeneratorCompleteStep(_generator_, _completion_, *true*)。
          1. 将 _generator_.[[AsyncGeneratorState]] 设为 ~completed~。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 注：_closure_ 可以包含 Await 操作的使用以及 Yield 操作以产出一个 IteratorResult 对象。
          1. 令 _internalSlotsList_ 为 « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »。
          1. 令 _generator_ 为 OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_)。
          1. 将 _generator_.[[GeneratorBrand]] 设为 _generatorBrand_。
          1. 将 _generator_.[[AsyncGeneratorState]] 设为 ~suspended-start~。
          1. 令 _callerContext_ 为正在运行的执行上下文。
          1. 令 _calleeContext_ 为一个新的执行上下文。
          1. 将 _calleeContext_ 的 Function 设为 *null*。
          1. 将 _calleeContext_ 的 Realm 设为当前 Realm Record。
          1. 将 _calleeContext_ 的 ScriptOrModule 设为 _callerContext_ 的 ScriptOrModule。
          1. 如果 _callerContext_ 尚未被挂起，则挂起 _callerContext_。
          1. 将 _calleeContext_ 压入执行上下文栈；_calleeContext_ 现在是正在运行的执行上下文。
          1. 执行 AsyncGeneratorStart(_generator_, _closure_)。
          1. 将 _calleeContext_ 从执行上下文栈移除并恢复 _callerContext_ 为正在运行的执行上下文。
          1. 返回 _generator_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction 对象</h1>
    <p>AsyncFunction 通常通过求值 |AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncMethod|、|AsyncArrowFunction| 创建。也可通过调用内在对象 %AsyncFunction% 创建。</p>

    <emu-clause id="sec-async-function-constructor">
      <h1>AsyncFunction 构造函数</h1>

      <p>AsyncFunction 构造函数：</p>
      <ul>
        <li>是 <dfn>%AsyncFunction%</dfn>。</li>
        <li>是 `Function` 的子类。</li>
        <li>当以函数（而非构造函数）方式调用时创建并初始化一个新的 AsyncFunction。故函数调用 `AsyncFunction(…)` 等价于以相同参数的对象创建表达式 `new AsyncFunction(…)`。</li>
        <li>可用作类定义中 `extends` 子句的值。意图继承指定 AsyncFunction 行为的子类构造函数必须包含对 AsyncFunction 构造函数的 `super` 调用，以创建并初始化具有内建异步函数行为所需内部槽的子类实例。所有用于定义异步函数对象的 ECMAScript 语法形式都会创建 AsyncFunction 的直接实例。没有语法手段创建 AsyncFunction 子类的实例。</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-arguments">
        <h1>AsyncFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>最后一个参数（如果存在）指定异步函数的函数体（可执行代码）。之前的任意参数指定形式参数。</p>
        <p>该函数被调用时执行以下步骤：</p>

        <emu-alg>
          1. 令 _C_ 为活动函数对象。
          1. 如果 _bodyArg_ 不存在，将 _bodyArg_ 设为空字符串。
          1. 返回 ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_)。
        </emu-alg>

        <emu-note>参见 <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref> 的注。</emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-constructor-properties">
      <h1>AsyncFunction 构造函数的属性</h1>

      <p>AsyncFunction 构造函数：</p>
      <ul>
        <li>是一个继承自 Function 构造函数的标准内建函数对象。</li>
        <li>具有值为 %Function% 的 [[Prototype]] 内部槽。</li>
        <li oldids="sec-async-function-constructor-length">具有值为 *1*<sub>𝔽</sub> 的 *"length"* 属性。</li>
        <li>具有值为 *"AsyncFunction"* 的 *"name"* 属性。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-prototype">
        <h1>AsyncFunction.prototype</h1>
        <p>`AsyncFunction.prototype` 的初始值是 AsyncFunction 原型对象。</p>

        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-prototype-properties">
      <h1>AsyncFunction 原型对象的属性</h1>
      <p><dfn>AsyncFunction 原型对象</dfn>：</p>
      <ul>
        <li>是 <dfn>%AsyncFunction.prototype%</dfn>。</li>
        <li>是一个普通对象。</li>
        <li>不是函数对象，并且没有 [[ECMAScriptCode]] 内部槽，也没有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的任何其他内部槽。</li>
        <li>具有值为 %Function.prototype% 的 [[Prototype]] 内部槽。</li>
      </ul>

      <emu-clause id="sec-async-function-prototype-properties-constructor">
        <h1>AsyncFunction.prototype.constructor</h1>

        <p>`AsyncFunction.prototype.constructor` 的初始值是 %AsyncFunction%。</p>

        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>

      <emu-clause oldids="sec-async-function-prototype-properties-toStringTag" id="sec-async-function-prototype-%symbol.tostringtag%">
        <h1>AsyncFunction.prototype [ %Symbol.toStringTag% ]</h1>

        <p>%Symbol.toStringTag% 属性的初始值是字符串 *"AsyncFunction"*。</p>

        <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-instances">
      <h1>AsyncFunction 实例</h1>

      <p>每个 AsyncFunction 实例都是一个 ECMAScript 函数对象，并拥有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。所有此类实例的 [[IsClassConstructor]] 内部槽的值为 *false*。AsyncFunction 实例不是构造函数，且没有 [[Construct]] 内部方法。由于不可构造，AsyncFunction 实例没有 prototype 属性。</p>
      <p>每个 AsyncFunction 实例具有以下自有属性：</p>

      <emu-clause id="sec-async-function-instances-length">
        <h1>length</h1>
        <p><emu-xref href="#sec-function-instances-length"></emu-xref> 中给出的 Function 实例 *"length"* 属性规范同样适用于 AsyncFunction 实例。</p>
      </emu-clause>

      <emu-clause id="sec-async-function-instances-name">
        <h1>name</h1>
        <p><emu-xref href="#sec-function-instances-name"></emu-xref> 中给出的 Function 实例 *"name"* 属性规范同样适用于 AsyncFunction 实例。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async 函数的抽象操作</h1>

      <emu-clause id="sec-async-functions-abstract-operations-async-function-start" type="abstract operation">
        <h1>
          AsyncFunctionStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncFunctionBody_: a |FunctionBody| Parse Node, an |ExpressionBody| Parse Node, or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _runningContext_ 为正在运行的执行上下文。
          1. 令 _asyncContext_ 为 _runningContext_ 的一个副本。
          1. 注：复制执行状态是 AsyncBlockStart 恢复其执行所需。恢复一个当前正在执行的上下文是未定义的。
          1. 执行 AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncblockstart" type="abstract operation">
        <h1>
          AsyncBlockStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncBody_: a Parse Node or an Abstract Closure with no parameters,
            _asyncContext_: an execution context,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _runningContext_ 为正在运行的执行上下文。
          1. 令 _closure_ 为一个无参数的新抽象闭包，捕获 _promiseCapability_ 与 _asyncBody_ 并在被调用时执行以下步骤：
            1. 令 _acAsyncContext_ 为正在运行的执行上下文。
            1. 如果 _asyncBody_ 是一个 Parse Node，则
              1. 令 _result_ 为 Completion(Evaluation of _asyncBody_)。
            1. 否则，
              1. 断言：_asyncBody_ 是一个无参数抽象闭包。
              1. 令 _result_ 为 Completion(_asyncBody_())。
            1. 断言：若我们在此返回，异步函数要么抛出异常，要么执行了隐式或显式 return；所有等待均已完成。
            1. 将 _acAsyncContext_ 从执行上下文栈移除，并恢复栈顶执行上下文为正在运行的执行上下文。
            1. 如果 _result_ 是一个 normal completion，则
              1. 执行 ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »)。
            1. 否则如果 _result_ 是一个 return completion，则
              1. 执行 ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »)。
            1. 否则，
              1. 断言：_result_ 是一个 throw completion。
              1. 执行 ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »)。
            1. [id="step-asyncblockstart-return-undefined"] 返回 NormalCompletion(~unused~)。
          1. 设定 _asyncContext_ 的代码求值状态，使得当该执行上下文恢复求值时，将无参数调用 _closure_。
          1. 将 _asyncContext_ 压入执行上下文栈；_asyncContext_ 现在是正在运行的执行上下文。
          1. <emu-meta effects="user-code">恢复 _asyncContext_ 的挂起求值</emu-meta>。令 _result_ 为恢复计算返回的值。
          1. 断言：当我们在此返回时，_asyncContext_ 已从执行上下文栈移除且 _runningContext_ 是当前正在运行的执行上下文。
          1. 断言：_result_ 是一个取值为 ~unused~ 的 normal completion。该值的可能来源是 Await，或当异步函数未等待任何内容时，上文步骤 <emu-xref href="#step-asyncblockstart-return-undefined"></emu-xref>。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="await" oldids="await-fulfilled,await-rejected" type="abstract operation">
        <h1>
          Await (
            _value_: an ECMAScript language value,
          ): either a normal completion containing either an ECMAScript language value or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _asyncContext_ 为正在运行的执行上下文。
          1. 令 _promise_ 为 ? PromiseResolve(%Promise%, _value_)。
          1. 令 _fulfilledClosure_ 为一个具有参数 (_v_) 的新抽象闭包，捕获 _asyncContext_ 并在被调用时执行以下步骤：
            1. 令 _prevContext_ 为正在运行的执行上下文。
            1. 挂起 _prevContext_。
            1. 将 _asyncContext_ 压入执行上下文栈；_asyncContext_ 现在是正在运行的执行上下文。
            1. <emu-meta effects="user-code">恢复 _asyncContext_ 的挂起求值</emu-meta>，使用 NormalCompletion(_v_) 作为使其挂起的操作的结果。
            1. 断言：当我们到达此步骤时，_asyncContext_ 已从执行上下文栈移除且 _prevContext_ 是当前正在运行的执行上下文。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _onFulfilled_ 为 CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « »)。
          1. 令 _rejectedClosure_ 为一个具有参数 (_reason_) 的新抽象闭包，捕获 _asyncContext_ 并在被调用时执行以下步骤：
            1. 令 _prevContext_ 为正在运行的执行上下文。
            1. 挂起 _prevContext_。
            1. 将 _asyncContext_ 压入执行上下文栈；_asyncContext_ 现在是正在运行的执行上下文。
            1. <emu-meta effects="user-code">恢复 _asyncContext_ 的挂起求值</emu-meta>，使用 ThrowCompletion(_reason_) 作为使其挂起的操作的结果。
            1. 断言：当我们到达此步骤时，_asyncContext_ 已从执行上下文栈移除且 _prevContext_ 是当前正在运行的执行上下文。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _onRejected_ 为 CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »)。
          1. 执行 PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_)。
          1. 将 _asyncContext_ 从执行上下文栈移除并恢复栈顶执行上下文为正在运行的执行上下文。
          1. 令 _callerContext_ 为正在运行的执行上下文。
          1. 恢复 _callerContext_，传入 ~empty~。如果 _asyncContext_ 之后再次被恢复，令 _completion_ 为恢复时使用的 Completion Record。
          1. 断言：若控制流到达此处，则 _asyncContext_ 再次成为正在运行的执行上下文。
          1. 返回 _completion_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection">
  <h1>反射</h1>

  <emu-clause id="sec-reflect-object">
    <h1>Reflect 对象</h1>
    <p>Reflect 对象：</p>
    <ul>
      <li>是 <dfn>%Reflect%</dfn>。</li>
      <li>是全局对象 *"Reflect"* 属性的初始值。</li>
      <li>是一个普通对象。</li>
      <li>具有值为 %Object.prototype% 的 [[Prototype]] 内部槽。</li>
      <li>不是函数对象。</li>
      <li>没有 [[Construct]] 内部方法；不能用 `new` 作为构造函数调用。</li>
      <li>没有 [[Call]] 内部方法；不能当作函数调用。</li>
    </ul>

    <emu-clause id="sec-reflect.apply">
      <h1>Reflect.apply ( _target_, _thisArgument_, _argumentsList_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 IsCallable(_target_) 为 *false*，抛出 *TypeError* 异常。
        1. 令 _args_ 为 ? CreateListFromArrayLike(_argumentsList_)。
        1. 执行 PrepareForTailCall()。
        1. 返回 ? Call(_target_, _thisArgument_, _args_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.construct">
      <h1>Reflect.construct ( _target_, _argumentsList_ [ , _newTarget_ ] )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 IsConstructor(_target_) 为 *false*，抛出 *TypeError* 异常。
        1. 如果 _newTarget_ 不存在，将 _newTarget_ 设为 _target_。
        1. 否则如果 IsConstructor(_newTarget_) 为 *false*，抛出 *TypeError* 异常。
        1. 令 _args_ 为 ? CreateListFromArrayLike(_argumentsList_)。
        1. 返回 ? Construct(_target_, _args_, _newTarget_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.defineproperty">
      <h1>Reflect.defineProperty ( _target_, _propertyKey_, _attributes_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _key_ 为 ? ToPropertyKey(_propertyKey_)。
        1. 令 _desc_ 为 ? ToPropertyDescriptor(_attributes_)。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.deleteproperty">
      <h1>Reflect.deleteProperty ( _target_, _propertyKey_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _key_ 为 ? ToPropertyKey(_propertyKey_)。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_key_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.get">
      <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _key_ 为 ? ToPropertyKey(_propertyKey_)。
        1. 如果 _receiver_ 不存在，则
          1. 将 _receiver_ 设为 _target_。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_key_, _receiver_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getownpropertydescriptor">
      <h1>Reflect.getOwnPropertyDescriptor ( _target_, _propertyKey_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _key_ 为 ? ToPropertyKey(_propertyKey_)。
        1. 令 _desc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_)。
        1. 返回 FromPropertyDescriptor(_desc_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getprototypeof">
      <h1>Reflect.getPrototypeOf ( _target_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]()</emu-meta>。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.has">
      <h1>Reflect.has ( _target_, _propertyKey_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _key_ 为 ? ToPropertyKey(_propertyKey_)。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_key_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.isextensible">
      <h1>Reflect.isExtensible ( _target_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[IsExtensible]]()</emu-meta>。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.ownkeys">
      <h1>Reflect.ownKeys ( _target_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _keys_ 为 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>。
        1. 返回 CreateArrayFromList(_keys_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.preventextensions">
      <h1>Reflect.preventExtensions ( _target_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta>。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.set">
      <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 令 _key_ 为 ? ToPropertyKey(_propertyKey_)。
        1. 如果 _receiver_ 不存在，则
          1. 将 _receiver_ 设为 _target_。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.setprototypeof">
      <h1>Reflect.setPrototypeOf ( _target_, _proto_ )</h1>
      <p>该函数被调用时执行以下步骤：</p>
      <emu-alg>
        1. 如果 _target_ 不是一个 Object，抛出 *TypeError* 异常。
        1. 如果 _proto_ 不是一个 Object 且 _proto_ 不为 *null*，抛出 *TypeError* 异常。
        1. 返回 ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_)。
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-reflect-@@tostringtag" id="sec-reflect-%symbol.tostringtag%">
      <h1>Reflect [ %Symbol.toStringTag% ]</h1>
      <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Reflect"*。</p>
      <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-objects">
    <h1>Proxy 对象</h1>

    <emu-clause id="sec-proxy-constructor">
      <h1>Proxy 构造函数</h1>
      <p>Proxy 构造函数：</p>
      <ul>
        <li>是 <dfn>%Proxy%</dfn>。</li>
        <li>是全局对象 *"Proxy"* 属性的初始值。</li>
        <li>作为构造函数调用时创建并初始化一个新的 Proxy 对象。</li>
        <li>不应作为普通函数调用；若以此方式调用将抛出异常。</li>
      </ul>

      <emu-clause id="sec-proxy-target-handler">
        <h1>Proxy ( _target_, _handler_ )</h1>
        <p>该函数被调用时执行以下步骤：</p>
        <emu-alg>
          1. 如果 NewTarget 为 *undefined*，抛出 *TypeError* 异常。
          1. 返回 ? ProxyCreate(_target_, _handler_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-proxy-constructor">
      <h1>Proxy 构造函数的属性</h1>
      <p>Proxy 构造函数：</p>
      <ul>
        <li>有一个 [[Prototype]] 内部槽，其值为 %Function.prototype%。</li>
        <li>没有 *"prototype"* 属性，因为 Proxy 对象没有需要初始化的 [[Prototype]] 内部槽。</li>
        <li>具有以下属性：</li>
      </ul>

      <emu-clause id="sec-proxy.revocable" oldids="sec-proxy-revocation-functions">
        <h1>Proxy.revocable ( _target_, _handler_ )</h1>
        <p>该函数创建一个可撤销的 Proxy 对象。</p>
        <p>被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _proxy_ 为 ? ProxyCreate(_target_, _handler_)。
          1. 令 _revokerClosure_ 为一个无参数的新抽象闭包（不捕获任何东西），调用时执行：
            1. 令 _F_ 为活动函数对象。
            1. 令 _p_ 为 _F_.[[RevocableProxy]]。
            1. 如果 _p_ 为 *null*，返回 NormalCompletion(*undefined*)。
            1. 将 _F_.[[RevocableProxy]] 设为 *null*。
            1. 断言：_p_ 是一个 Proxy 奇异对象。
            1. 将 _p_.[[ProxyTarget]] 设为 *null*。
            1. 将 _p_.[[ProxyHandler]] 设为 *null*。
            1. 返回 NormalCompletion(*undefined*)。
          1. 令 _revoker_ 为 CreateBuiltinFunction(_revokerClosure_, 0, *""*, « [[RevocableProxy]] »)。
          1. 将 _revoker_.[[RevocableProxy]] 设为 _proxy_。
            1. 令 _result_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ! CreateDataPropertyOrThrow(_result_, *"proxy"*, _proxy_)。
          1. 执行 ! CreateDataPropertyOrThrow(_result_, *"revoke"*, _revoker_)。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-module-namespace-objects">
    <h1>模块命名空间对象</h1>
    <p>模块命名空间对象是一种模块命名空间奇异对象，提供在运行时以属性方式访问模块导出绑定的机制。没有用于模块命名空间对象的构造函数。相反，对每个由包含 |NameSpaceImport| 的 |ImportDeclaration| 导入的模块创建这样的对象。</p>
    <p>除 <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> 指定的属性外，每个模块命名空间对象还有以下自有属性：</p>

    <emu-clause oldids="sec-@@tostringtag" id="sec-%symbol.tostringtag%">
      <h1>%Symbol.toStringTag%</h1>
      <p>%Symbol.toStringTag% 属性的初始值是字符串 *"Module"*。</p>
      <p>该属性具有 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-memory-model">
  <h1>内存模型</h1>
  <p>内存一致性模型（或称 <dfn>内存模型</dfn>）规定了共享数据块事件的可能排序，这些事件通过访问由 SharedArrayBuffer 支持的 TypedArray 实例以及调用 Atomics 对象的方法产生。当程序无数据竞争（定义见下）时，事件的排序表现为顺序一致，即各代理动作的交错。当程序存在数据竞争时，共享内存操作可能表现为非顺序一致。例如，程序可能出现因果违反行为和其他令人惊讶的现象。这些惊讶源于编译器变换和 CPU 设计（例如乱序执行与推测执行）。内存模型定义了程序表现顺序一致行为的精确条件，以及数据竞争中可能读取的值。换言之，不存在未定义行为。</p>
  <p>内存模型以关系约束形式定义，这些约束作用于在求值过程中由对 SharedArrayBuffer 的抽象操作或 Atomics 对象的方法引入的事件。</p>
  <emu-note>
    <p>本节提供了对 SharedArrayBuffer 抽象操作引入事件的公理化模型。需强调该模型不同于规范其余部分，并非可算法表达。抽象操作非确定性引入事件，是 ECMAScript 求值的操作语义与内存模型公理语义之间的接口。事件语义通过考虑一次求值中所有事件组成的图来定义。它们既非静态语义，也非运行时语义。目前没有演示的算法实现，而是一组约束，用来判定某事件图是否被允许。</p>
  </emu-note>

  <emu-clause id="sec-memory-model-fundamentals">
    <h1>内存模型基础</h1>
    <p>共享内存访问（读与写）分为两类：原子访问和数据访问（下文定义）。原子访问是顺序一致的，即存在一个所有代理都同意的严格全序。非原子访问在所有代理之间没有严格全序，即无序。</p>
    <emu-note>
      <p>不支持比顺序一致更弱、比无序更强的次序（如 release-acquire）。</p>
    </emu-note>
    <p><dfn variants="Shared Data Block events">共享数据块事件</dfn> 是 <dfn>ReadSharedMemory</dfn>、<dfn>WriteSharedMemory</dfn> 或 <dfn>ReadModifyWriteSharedMemory</dfn> Record。</p>

    <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory 事件字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>取值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~ 或 ~unordered~</td>
          <td>内存模型对该事件保证的最弱次序。</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>一个 Boolean</td>
          <td>该事件是否允许从多个范围与其相等的写事件读取。</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>一个共享数据块</td>
          <td>事件操作的块。</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>一个非负整数</td>
          <td>在 [[Block]] 中读取的字节地址。</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>一个非负整数</td>
          <td>读取的大小。</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory 事件字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>取值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~、~unordered~ 或 ~init~</td>
          <td>内存模型对该事件保证的最弱次序。</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>一个 Boolean</td>
          <td>该事件是否允许被多个范围与其相等的读事件读取。</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>一个共享数据块</td>
          <td>事件操作的块。</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>一个非负整数</td>
          <td>在 [[Block]] 中写入的字节地址。</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>一个非负整数</td>
          <td>写入的大小。</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>一个字节值的 List</td>
          <td>供其他事件读取的字节值列表。</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory 事件字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>取值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~</td>
          <td>读-改-写事件始终顺序一致。</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>*true*</td>
          <td>读-改-写事件不可撕裂。</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>一个共享数据块</td>
          <td>事件操作的块。</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>一个非负整数</td>
          <td>在 [[Block]] 中读改写的字节地址。</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>一个非负整数</td>
          <td>读改写的大小。</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>一个字节值的 List</td>
          <td>传递给 [[ModifyOp]] 的字节值列表。</td>
        </tr>
        <tr>
          <td>[[ModifyOp]]</td>
          <td>一个读-改-写修改函数</td>
          <td>从读取的字节值 List 与 [[Payload]] 返回修改后字节值 List 的抽象闭包。</td>
        </tr>
      </table>
    </emu-table>

    <p>这些事件由抽象操作或 Atomics 对象的方法引入。</p>
    <p>某些操作还可能引入 <dfn>Synchronize</dfn> 事件。一个 <dfn variants="Synchronize events">Synchronize 事件</dfn> 没有字段，仅用于直接约束其他事件的允许顺序。</p>
    <p>除共享数据块事件与 Synchronize 事件外，还存在宿主特定事件。</p>
    <p>令 ReadSharedMemory、WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件的范围为从其 [[ByteIndex]] 到 [[ByteIndex]] + [[ElementSize]] - 1 的连续整数集合。两个事件的范围相等当且仅当它们具有相同 [[Block]] 且范围逐元素相等。若两个事件有相同 [[Block]]、范围不等且交集非空则范围重叠。若两个事件没有相同 [[Block]] 或其范围既不相等也不重叠则范围不相交。</p>
    <emu-note>
      <p>应考虑的宿主特定同步事件示例：将一个 SharedArrayBuffer 从一代理发送至另一代理（例如浏览器中的 `postMessage`），代理的启动与停止，以及通过共享内存之外的通道在代理集群内通信。对于某次执行 _execution_，这些事件由宿主通过 host-synchronizes-with 严格偏序提供。此外，宿主可以将宿主特定同步事件加入 _execution_.[[EventList]] 以参与 is-agent-order-before 关系。</p>
    </emu-note>
    <p>候选执行中的事件由下列定义的关系排序。</p>
  </emu-clause>

  <emu-clause id="sec-agent-event-records">
    <h1>代理事件记录</h1>
    <p><dfn variants="Agent Events Records">Agent Events Record</dfn> 是具有以下字段的 Record。</p>
    <emu-table id="table-agent-events-records" caption="Agent Events Record 字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>取值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[AgentSignifier]]</td>
          <td>一个代理标识符</td>
          <td>其求值导致此排序的代理。</td>
        </tr>
        <tr>
          <td>[[EventList]]</td>
          <td>一个事件的 List</td>
          <td>求值过程中事件被追加到该列表。</td>
        </tr>
        <tr>
          <td>[[AgentSynchronizesWith]]</td>
          <td>一对 Synchronize 事件的 List</td>
          <td>由操作语义引入的同步关系。</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-chosen-value-records">
    <h1>选定值记录</h1>
    <p><dfn variants="Chosen Value Records">Chosen Value Record</dfn> 是具有以下字段的 Record。</p>
    <emu-table id="table-chosen-value-records" caption="Chosen Value Record 字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>取值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[Event]]</td>
          <td>一个共享数据块事件</td>
          <td>为该选定值引入的 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件。</td>
        </tr>
        <tr>
          <td>[[ChosenValue]]</td>
          <td>一个字节值的 List</td>
          <td>求值过程中非确定性选出的字节。</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-candidate-executions">
    <h1>候选执行</h1>
    <p>代理集群求值的一个 <dfn variants="candidate executions">candidate execution</dfn> 是具有以下字段的 Record。</p>
    <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record 字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>取值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[EventsRecords]]</td>
          <td>Agent Events Record 的 List</td>
          <td>映射一个代理到求值过程中追加的事件列表。</td>
        </tr>
        <tr>
          <td>[[ChosenValues]]</td>
          <td>Chosen Value Record 的 List</td>
          <td>将 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件映射为求值过程中选定的字节值列表。</td>
        </tr>
      </table>
    </emu-table>

    <p><dfn variants="empty candidate executions">empty candidate execution</dfn> 是各字段为空 List 的候选执行 Record。</p>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-the-memory-model" oldids="sec-synchronizeeventset">
    <h1>内存模型的抽象操作</h1>

    <emu-clause id="sec-event-set" type="abstract operation">
      <h1>
        EventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _events_ 为一个空 Set。
        1. 对于 _execution_.[[EventsRecords]] 中的每个 Agent Events Record _aer_，执行
          1. 对 _aer_.[[EventList]] 中的每个事件 _E_，执行
            1. 将 _E_ 加入 _events_。
        1. 返回 _events_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedatablockeventset" type="abstract operation">
      <h1>
        SharedDataBlockEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _events_ 为一个空 Set。
        1. 对 EventSet(_execution_) 中的每个事件 _E_，执行
          1. 如果 _E_ 是 ReadSharedMemory、WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件，将 _E_ 加入 _events_。
        1. 返回 _events_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hosteventset" type="abstract operation">
      <h1>
        HostEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _events_ 为一个空 Set。
        1. 对 EventSet(_execution_) 中的每个事件 _E_，执行
          1. 如果 _E_ 不在 SharedDataBlockEventSet(_execution_) 中，将 _E_ 加入 _events_。
        1. 返回 _events_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-composewriteeventbytes" type="abstract operation">
      <h1>
        ComposeWriteEventBytes (
          _execution_: a candidate execution,
          _byteIndex_: a non-negative integer,
          _Ws_: a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _byteLocation_ 为 _byteIndex_。
        1. 令 _bytesRead_ 为一个新的空 List。
        1. 对 _Ws_ 中每个元素 _W_，执行
          1. 断言：_W_ 的范围包含 _byteLocation_。
          1. 令 _payloadIndex_ 为 _byteLocation_ - _W_.[[ByteIndex]]。
          1. 如果 _W_ 是 WriteSharedMemory 事件，则
            1. 令 _byte_ 为 _W_.[[Payload]][_payloadIndex_]。
          1. 否则，
            1. 断言：_W_ 是 ReadModifyWriteSharedMemory 事件。
            1. 令 _bytes_ 为 ValueOfReadEvent(_execution_, _W_)。
            1. 令 _bytesModified_ 为 _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]])。
            1. 令 _byte_ 为 _bytesModified_[_payloadIndex_]。
          1. 将 _byte_ 追加到 _bytesRead_。
          1. 将 _byteLocation_ 设为 _byteLocation_ + 1。
        1. 返回 _bytesRead_。
      </emu-alg>
      <emu-note>
        <p>读-改-写修改 [[ModifyOp]] 由 Atomics 对象上引入 ReadModifyWriteSharedMemory 事件的函数属性给出。</p>
      </emu-note>
      <emu-note>
        <p>此抽象操作将写事件的 List 组合为字节值的 List。用于 ReadSharedMemory 和 ReadModifyWriteSharedMemory 事件的事件语义。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valueofreadevent" type="abstract operation">
      <h1>
        ValueOfReadEvent (
          _execution_: a candidate execution,
          _R_: a ReadSharedMemory or ReadModifyWriteSharedMemory event,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _Ws_ 为 reads-bytes-from(_R_) in _execution_。
        1. 断言：_Ws_ 是长度等于 _R_.[[ElementSize]] 的 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 List。
        1. 返回 ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_)。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relations-of-candidate-executions">
    <h1>候选执行的关系</h1>

    <p>以下关系与数学函数以特定候选执行为参数，对其事件排序。</p>

    <emu-clause id="sec-agent-order">
      <h1>is-agent-order-before</h1>
      <p>对候选执行 _execution_，其 <dfn>is-agent-order-before</dfn> 关系是满足以下条件的事件上的最小关系。</p>
      <ul>
        <li>对事件 _E_ 与 _D_，若存在 _execution_.[[EventsRecords]] 中的某个 Agent Events Record _aer_，使得 _aer_.[[EventList]] 同时包含 _E_ 与 _D_ 且 _E_ 在该 List 顺序上位于 _D_ 之前，则 _E_ 在 _execution_ 中 is-agent-order-before _D_。</li>
      </ul>

      <emu-note>
        <p>每个代理在求值期间按代理内严格全序引入事件。这些严格全序的并集即本关系。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-reads-bytes-from" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>对候选执行 _execution_，其 <em>reads-bytes-from</em> 函数是一个数学函数，将 SharedDataBlockEventSet(_execution_) 中的事件映射到该集合中事件的 List，满足下列条件。</p>
      <ul>
        <li>
          <p>对 SharedDataBlockEventSet(_execution_) 中每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 _R_，reads-bytes-from(_R_) in _execution_ 为长度 _R_.[[ElementSize]] 的 List，其元素为 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 _Ws_，满足：</p>
          <ul>
            <li>_Ws_ 中索引 _i_ 的每个事件 _W_ 的范围包含 _R_.[[ByteIndex]] + _i_。</li>
            <li>_R_ 不在 _Ws_ 中。</li>
          </ul>
        </li>
      </ul>
      <p>一个候选执行总能容纳一个 reads-bytes-from 函数。</p>
    </emu-clause>

    <emu-clause id="sec-reads-from">
      <h1>reads-from</h1>
      <p>对候选执行 _execution_，其 <dfn>reads-from</dfn> 关系是满足以下条件的事件上的最小关系。</p>
      <ul>
        <li>对事件 _R_ 与 _W_，若 SharedDataBlockEventSet(_execution_) 同时包含 _R_ 与 _W_ 且 reads-bytes-from(_R_) in _execution_ 包含 _W_，则 _R_ reads-from _W_。</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>对候选执行 _execution_，其 <dfn>host-synchronizes-with</dfn> 关系是宿主提供的、在宿主特定事件上的严格偏序，至少满足：</p>
      <ul>
        <li>若 _E_ host-synchronizes-with _D_，则 HostEventSet(_execution_) 包含 _E_ 与 _D_。</li>
        <li>host-synchronizes-with 与 is-agent-order-before 的并集中不存在环。</li>
      </ul>

      <emu-note>
        <p>对候选执行 _execution_ 中两个宿主特定事件 _E_ 与 _D_，若 _E_ host-synchronizes-with _D_，则 _E_ happens-before _D_。</p>
      </emu-note>
      <emu-note>
        <p>该关系允许宿主提供额外同步机制，如在 HTML workers 间使用 `postMessage`。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>对候选执行 _execution_，其 <dfn>synchronizes-with</dfn> 关系是满足以下条件的事件上的最小关系：</p>
      <ul>
        <li>
          对事件 _R_ 与 _W_，若 _R_ reads-from _W_ in _execution_、_R_.[[Order]] 为 ~seq-cst~、_W_.[[Order]] 为 ~seq-cst~ 且 _R_ 与 _W_ 范围相等，则 _W_ synchronizes-with _R_。
        </li>
        <li>
          对 _execution_.[[EventsRecords]] 的每个元素 _eventsRecord_，以下成立：
          <ul>
            <li>若 _eventsRecord_.[[AgentSynchronizesWith]] 包含 (_S_, _Sw_)，则 _S_ synchronizes-with _Sw_。</li>
          </ul>
        </li>
        <li>对事件 _E_ 与 _D_，若 _execution_.[[HostSynchronizesWith]] 包含 (_E_, _D_)，则 _E_ synchronizes-with _D_。</li>
      </ul>

      <emu-note>
        <p>按内存模型文献惯例，写事件 synchronizes-with 读事件，而不是反之。</p>
      </emu-note>

      <emu-note>
        <p>~init~ 事件不参与该关系，而由 happens-before 直接约束。</p>
      </emu-note>

      <emu-note>
        <p>并非所有通过 reads-from 关联的 ~seq-cst~ 事件都由 synchronizes-with 关联，只有范围相等者才关联。</p>
      </emu-note>

      <emu-note>
        <p>若共享数据块事件 _W_ synchronizes-with _R_，_R_ 仍可 reads-from 除 _W_ 之外的写。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-happens-before">
      <h1>happens-before</h1>
      <p>对候选执行 _execution_，其 <dfn>happens-before</dfn> 关系是满足以下条件的事件上的最小关系。</p>

      <ul>
        <li>
          <p>对事件 _E_ 与 _D_，若以下任一成立则 _E_ happens-before _D_：</p>
          <ul>
            <li>_E_ is-agent-order-before _D_。</li>
            <li>_E_ synchronizes-with _D_。</li>
            <li>SharedDataBlockEventSet(_execution_) 同时包含 _E_ 与 _D_，_E_.[[Order]] 为 ~init~，且 _E_ 与 _D_ 范围重叠。</li>
            <li>存在事件 _F_ 使得 _E_ happens-before _F_ 且 _F_ happens-before _D_。</li>
          </ul>
        </li>
      </ul>

      <emu-note>
        <p>因 happens-before 是 agent-order 的超集，候选执行与 ECMAScript 的单线程求值语义一致。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-valid-executions">
    <h1>合法执行的性质</h1>

    <emu-clause id="sec-valid-chosen-reads">
      <h1>有效选定读取</h1>
      <p>候选执行 _execution_ 具有有效选定读取当且仅当以下算法返回 *true*。</p>
      <emu-alg>
        1. 对 SharedDataBlockEventSet(_execution_) 中每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 _R_，执行
          1. 令 _chosenValueRecord_ 为 _execution_.[[ChosenValues]] 中 [[Event]] 字段为 _R_ 的元素。
          1. 令 _chosenValue_ 为 _chosenValueRecord_.[[ChosenValue]]。
          1. 令 _readValue_ 为 ValueOfReadEvent(_execution_, _R_)。
          1. 令 _chosenLen_ 为 _chosenValue_ 的元素个数。
          1. 令 _readLen_ 为 _readValue_ 的元素个数。
          1. 如果 _chosenLen_ ≠ _readLen_，则
            1. 返回 *false*。
          1. 如果 存在整数 _i_ 属于 [0, _chosenLen_) 使 _chosenValue_[_i_] ≠ _readValue_[_i_]，则
            1. 返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-coherent-reads">
      <h1>相干读取</h1>
      <p>候选执行 _execution_ 具有相干读取当且仅当以下算法返回 *true*。</p>
      <emu-alg>
        1. 对 SharedDataBlockEventSet(_execution_) 中每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 _R_，执行
          1. 令 _Ws_ 为 reads-bytes-from(_R_) in _execution_。
          1. 令 _byteLocation_ 为 _R_.[[ByteIndex]]。
          1. 对 _Ws_ 中每个元素 _W_，执行
            1. 如果 _R_ happens-before _W_，则
              1. 返回 *false*。
            1. 如果 存在 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 _V_，其范围包含 _byteLocation_，且 _W_ happens-before _V_ 且 _V_ happens-before _R_，则
              1. 返回 *false*。
            1. 将 _byteLocation_ 设为 _byteLocation_ + 1。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tear-free-aligned-reads">
      <h1>无撕裂读取</h1>
      <p>候选执行 _execution_ 具有无撕裂读取当且仅当以下算法返回 *true*。</p>
      <emu-alg>
        1. 对 SharedDataBlockEventSet(_execution_) 中每个 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件 _R_，执行
          1. 如果 _R_.[[NoTear]] 为 *true*，则
            1. 断言：_R_.[[ByteIndex]] 除以 _R_.[[ElementSize]] 的余数为 0。
            1. 对每个事件 _W_（满足 _R_ reads-from _W_ 且 _W_.[[NoTear]] 为 *true*），执行
              1. 如果 _R_ 与 _W_ 范围相等且存在事件 _V_ 使得 _V_ 与 _W_ 范围相等、_V_.[[NoTear]] 为 *true*、_W_ 与 _V_ 非同一共享数据块事件且 _R_ reads-from _V_，则
                1. 返回 *false*。
        1. 返回 *true*。
      </emu-alg>

      <emu-note>
        <p>事件的 [[NoTear]] 字段为 *true* 表示该事件通过访问整数 TypedArray 引入；为 *false* 则表示通过访问浮点 TypedArray 或 DataView 引入。</p>
        <p>直观地，该要求表示当内存范围以整数 TypedArray 对齐方式访问时，在与其他范围相等写事件的数据竞争中，必须由“单个”写事件“胜出”。更精确地：对齐的读事件不能读取由多个范围相等写事件的字节混合组成的值。然而对齐读事件仍可能读取来自范围重叠写事件的字节。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-memory-order">
      <h1>顺序一致原子</h1>
      <p>对候选执行 _execution_，<dfn>is-memory-order-before</dfn> 是 EventSet(_execution_) 所有事件的严格全序，且满足：</p>
      <ul>
        <li>对事件 _E_ 与 _D_，若 _E_ happens-before _D_，则 _E_ is-memory-order-before _D_。</li>
        <li>
          <p>对 _R_ 与 _W_（满足 _R_ reads-from _W_），不存在 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 _V_ 属于 SharedDataBlockEventSet(_execution_)，使 _V_.[[Order]] 为 ~seq-cst~、_W_ is-memory-order-before _V_、_V_ is-memory-order-before _R_，且以下任一成立：</p>
          <ul>
            <li>_W_ synchronizes-with _R_ 且 _V_ 与 _R_ 范围相等。</li>
            <li>_W_ happens-before _R_ 且 _V_ happens-before _R_，_W_.[[Order]] 为 ~seq-cst~，且 _W_ 与 _V_ 范围相等。</li>
            <li>_W_ happens-before _R_ 且 _W_ happens-before _V_，_R_.[[Order]] 为 ~seq-cst~，且 _V_ 与 _R_ 范围相等。</li>
          </ul>
          <emu-note>
            <p>此条款额外约束范围相等的 ~seq-cst~ 事件。</p>
          </emu-note>
        </li>
        <li>
          <p>对 SharedDataBlockEventSet(_execution_) 中每个 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件 _W_，若 _W_.[[Order]] 为 ~seq-cst~，则不可能存在无限多个与 _W_ 范围相等且 memory-order 位于 _W_ 之前的 ReadSharedMemory 或 ReadModifyWriteSharedMemory 事件。</p>
          <emu-note>
            <p>该条款与代理的前向进展保证一起确保：~seq-cst~ 写在有限时间内对范围相等的 ~seq-cst~ 读可见。</p>
          </emu-note>
        </li>
      </ul>
      <p>若候选执行存在一个 is-memory-order-before 关系，则其具有顺序一致原子。</p>

      <emu-note>
        <p>虽然 is-memory-order-before 包含 EventSet(_execution_) 的所有事件，但未被 happens-before 或 synchronizes-with 约束的事件可在该顺序中任意位置出现。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valid-executions">
      <h1>合法执行</h1>
      <p>候选执行 _execution_ 是合法执行（或简称执行）当且仅当以下各项均为真：</p>
      <ul>
        <li>宿主为 _execution_ 提供 host-synchronizes-with 关系。</li>
        <li>_execution_ 存在一个为严格偏序的 happens-before 关系。</li>
        <li>_execution_ 具有有效选定读取。</li>
        <li>_execution_ 具有相干读取。</li>
        <li>_execution_ 具有无撕裂读取。</li>
        <li>_execution_ 具有顺序一致原子。</li>
      </ul>
      <p>所有程序至少有一个合法执行。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-races">
    <h1>竞争</h1>
    <p>对执行 _execution_ 及其中 SharedDataBlockEventSet(_execution_) 的事件 _E_ 与 _D_，若以下算法返回 *true*，则 _E_ 与 _D_ 处于一个 <em>race</em> 中。</p>
    <emu-alg>
      1. 如果 _E_ 与 _D_ 不是同一共享数据块事件，则
        1. 如果并非 _E_ happens-before _D_ 且 _D_ happens-before _E_ 同时成立，则
          1. 如果 _E_ 与 _D_ 均为 WriteSharedMemory 或 ReadModifyWriteSharedMemory 事件且范围不相交为假，则
            1. 返回 *true*。
          1. 如果 _E_ reads-from _D_ 或 _D_ reads-from _E_，则
            1. 返回 *true*。
      1. 返回 *false*。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-races">
    <h1>数据竞争</h1>
    <p>对执行 _execution_ 及其中 SharedDataBlockEventSet(_execution_) 的事件 _E_ 与 _D_，若以下算法返回 *true*，则 _E_ 与 _D_ 处于一个 <dfn>data race</dfn> 中。</p>
    <emu-alg>
      1. 如果 _E_ 与 _D_ 在 _execution_ 中处于 <emu-xref href="#sec-races">race</emu-xref>，则
        1. 如果 _E_.[[Order]] 不是 ~seq-cst~ 或 _D_.[[Order]] 不是 ~seq-cst~，则
          1. 返回 *true*。
        1. 如果 _E_ 与 _D_ 范围重叠，则
          1. 返回 *true*。
      1. 返回 *false*。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-race-freedom">
    <h1>数据竞争自由</h1>
    <p>执行 _execution_ 是 <dfn>data race free</dfn> 当且仅当 SharedDataBlockEventSet(_execution_) 中不存在两事件处于数据竞争。</p>
    <p>若程序所有执行均数据竞争自由，则该程序为数据竞争自由程序。</p>
    <p>内存模型保证数据竞争自由程序所有事件的顺序一致性。</p>
  </emu-clause>

  <emu-clause id="sec-shared-memory-guidelines">
    <h1>共享内存指南</h1>
    <emu-note>
      <p>以下是面向使用共享内存的 ECMAScript 程序员的指南。</p>
      <p>推荐保持程序数据竞争自由，即使同一内存位置不可能同时发生并发非原子操作。数据竞争自由程序具有交错语义：每个代理的每一步求值语义互相交错。此时无需理解内存模型细节，细节对编写 ECMAScript 的直觉帮助有限。</p>
      <p>更一般地，即便程序非数据竞争自由，也可能具可预测行为，只要原子操作不参与任何数据竞争，且竞争操作的访问大小一致。最简单方式是保证原子与非原子操作使用不同内存单元，且不同大小的原子访问不同时访问相同单元。实质上，程序应尽量将共享内存视为强类型。仍不可依赖竞争的非原子访问的顺序与时序，但若内存被强类型对待，竞争访问不会“撕裂”（其值的位不会混合）。</p>
    </emu-note>

    <emu-note>
      <p>以下是面向为使用共享内存程序编写编译器变换的 ECMAScript 实现者的指南。</p>
      <p>希望在多代理环境中允许大多数在单代理环境有效的程序变换，以确保多代理程序中每个代理的性能与单代理时一样。此类变换往往难以判定。我们概述若干应视为规范性的规则（由内存模型蕴含或比其更强），但不一定穷尽。规则适用于在组成 is-agent-order-before 关系的事件引入之前的程序变换。</p>
      <p>令 <dfn variants="agent-order slices">agent-order slice</dfn> 为 is-agent-order-before 关系中属于单一代理的子集。</p>
      <p>令读取事件的 <dfn>possible read values</dfn> 为该事件在所有合法执行中 ValueOfReadEvent 的所有值集合。</p>
      <p>在无共享内存时有效的任意 agent-order slice 变换在存在共享内存时亦有效，以下例外：</p>
      <ul>
        <li>
          <p><em>原子操作不可动摇</em>：程序变换不得使 agent-order slice 中的 ~seq-cst~ 事件与其 ~unordered~ 操作重排，亦不得重排其 ~seq-cst~ 操作之间的顺序，也不得移除 ~seq-cst~ 操作。</p>
          <p>（实践中，该限制迫使编译器假设每个 ~seq-cst~ 操作均为同步点并被包含在最终 is-memory-order-before 关系中。）</p>
        </li>
        <li>
          <p><em>读取必须稳定</em>：任一共享内存读取在一次执行中只能观察到单一值。</p>
          <p>（例如，若语义上单次读取被多次执行，则程序只能观察其中一个值；某些再物化变换可违反此规则。）</p>
        </li>
        <li>
          <p><em>写入必须稳定</em>：所有可观察写入必须源于该次执行的程序语义。</p>
          <p>（例如，变换不能引入程序本不可能的写，如对更大位置的读改写来写较小数据，写入程序原本不可写的值，或将刚读取的值写回其位置且期间可能被他代理覆盖。）</p>
        </li>
        <li>
          <p><em>可能读取值不得为空</em>：程序变换不能使某共享内存读取的可能读取值集合为空。</p>
          <p>（反直觉地，该规则实际限制对写的变换，因为写的作用仅在被读事件读取。例如写可移动、合并，有时在两个 ~seq-cst~ 操作间重排，但不可删掉所有更新某位置的写，必须保留一个。）</p>
        </li>
      </ul>
      <p>仍然有效的变换示例：合并多个对同一位置的非原子读；重排非原子读；引入推测非原子读；合并多个对同一位置的非原子写；对不同位置的非原子写重排；将非原子读外提出循环（即使影响终止性）。注意别名 TypedArrays 使证明位置不同变得困难。</p>
    </emu-note>

    <emu-note>
      <p>以下是面向为共享内存访问生成机器码的 ECMAScript 实现者的指南。</p>
      <p>对内存模型不弱于 ARM 或 Power 的架构，非原子存取可编译为裸存取。原子存取可编译为保证顺序一致的指令。若不存在此类指令，则使用内存屏障（如在裸存/取两侧放置）。读改写操作可编译为目标架构的读改写指令，如 x86 上的 <code>LOCK</code> 前缀指令，ARM 的 load-exclusive/store-exclusive，Power 的 load-link/store-conditional。</p>
      <p>具体而言，内存模型旨在允许如下代码生成：</p>
      <ul>
        <li>程序中的每个原子操作都被视为必要。</li>
        <li>原子操作不与其他原子或非原子操作重排。</li>
        <li>函数被假定执行原子操作。</li>
        <li>原子操作不以更大数据的读改写实现，而在不支持相应大小原子时使用非锁自由原子（假定平台具备所有必要尺寸的普通内存访问）。</li>
      </ul>
      <p>朴素代码生成模式：</p>
      <ul>
        <li>常规加载与存储 -> 单条加载/存储指令。</li>
        <li>锁自由原子加载与存储 -> 全栅栏，常规加载/存储，再全栅栏。</li>
        <li>锁自由原子读改写 -> 全栅栏，原子读改写指令序列，全栅栏。</li>
        <li>非锁自由原子 -> 自旋锁获取，全栅栏，一系列非原子读写，全栅栏，自旋锁释放。</li>
      </ul>
      <p>该映射在原子操作与非原子写或不同大小原子不竞争下正确；若竞争，内存模型将相关原子操作降级为非原子。但此朴素映射很强：允许原子操作充当顺序一致栅栏，这超出模型实际保证。</p>
      <p>局部优化在模型约束下也是允许的，例如：</p>
      <ul>
        <li>平台相关的消除冗余栅栏（例如 x86 上锁自由原子读写的栅栏多可省略，除写后的栅栏）。</li>
        <li>多数现代平台支持所需数据大小的锁自由原子；若需非锁自由原子，可将原子操作体周围栅栏折叠进锁操作；最简单是每个 SharedArrayBuffer 一个锁字。</li>
        <li>更复杂的局部优化，如合并背靠背栅栏；x86 上分隔原子写的栅栏可省，因写后所需栅栏仅用于分隔与后续读。</li>
      </ul>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-grammar-summary">
  <h1>语法概要</h1>

  <emu-annex id="sec-lexical-grammar">
    <h1>词法语法</h1>
    <emu-prodref name="SourceCharacter"></emu-prodref>
    <emu-prodref name="InputElementDiv"></emu-prodref>
    <emu-prodref name="InputElementRegExp"></emu-prodref>
    <emu-prodref name="InputElementRegExpOrTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementHashbangOrRegExp"></emu-prodref>
    <emu-prodref name="WhiteSpace"></emu-prodref>
    <emu-prodref name="LineTerminator"></emu-prodref>
    <emu-prodref name="LineTerminatorSequence"></emu-prodref>
    <emu-prodref name="Comment"></emu-prodref>
    <emu-prodref name="MultiLineComment"></emu-prodref>
    <emu-prodref name="MultiLineCommentChars"></emu-prodref>
    <emu-prodref name="PostAsteriskCommentChars"></emu-prodref>
    <emu-prodref name="MultiLineNotAsteriskChar"></emu-prodref>
    <emu-prodref name="MultiLineNotForwardSlashOrAsteriskChar"></emu-prodref>
    <emu-prodref name="SingleLineComment"></emu-prodref>
    <emu-prodref name="SingleLineCommentChars"></emu-prodref>
    <emu-prodref name="SingleLineCommentChar"></emu-prodref>
    <emu-prodref name="HashbangComment"></emu-prodref>
    <emu-prodref name="CommonToken"></emu-prodref>
    <emu-prodref name="PrivateIdentifier"></emu-prodref>
    <emu-prodref name="IdentifierName"></emu-prodref>
    <emu-prodref name="IdentifierStart"></emu-prodref>
    <emu-prodref name="IdentifierPart"></emu-prodref>
    <emu-prodref name="IdentifierStartChar"></emu-prodref>
    <emu-prodref name="IdentifierPartChar"></emu-prodref>
    <emu-prodref name="AsciiLetter"></emu-prodref>
    <emu-prodref name="UnicodeIDStart"></emu-prodref>
    <emu-prodref name="UnicodeIDContinue"></emu-prodref>
    <emu-prodref name="ReservedWord"></emu-prodref>
    <emu-prodref name="Punctuator"></emu-prodref>
    <emu-prodref name="OptionalChainingPunctuator"></emu-prodref>
    <emu-prodref name="OtherPunctuator"></emu-prodref>
    <emu-prodref name="DivPunctuator"></emu-prodref>
    <emu-prodref name="RightBracePunctuator"></emu-prodref>
    <emu-prodref name="NullLiteral"></emu-prodref>
    <emu-prodref name="BooleanLiteral"></emu-prodref>
    <emu-prodref name="NumericLiteralSeparator"></emu-prodref>
    <emu-prodref name="NumericLiteral"></emu-prodref>
    <emu-prodref name="DecimalBigIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="BigIntLiteralSuffix"></emu-prodref>
    <emu-prodref name="DecimalLiteral"></emu-prodref>
    <emu-prodref name="DecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="DecimalDigits"></emu-prodref>
    <emu-prodref name="DecimalDigit"></emu-prodref>
    <emu-prodref name="NonZeroDigit"></emu-prodref>
    <emu-prodref name="ExponentPart"></emu-prodref>
    <emu-prodref name="ExponentIndicator"></emu-prodref>
    <emu-prodref name="SignedInteger"></emu-prodref>
    <emu-prodref name="BinaryIntegerLiteral"></emu-prodref>
    <emu-prodref name="BinaryDigits"></emu-prodref>
    <emu-prodref name="BinaryDigit"></emu-prodref>
    <emu-prodref name="OctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigits"></emu-prodref>
    <emu-prodref name="LegacyOctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonOctalDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="LegacyOctalLikeDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigit"></emu-prodref>
    <emu-prodref name="NonOctalDigit"></emu-prodref>
    <emu-prodref name="HexIntegerLiteral"></emu-prodref>
    <emu-prodref name="HexDigits"></emu-prodref>
    <emu-prodref name="HexDigit"></emu-prodref>
    <emu-prodref name="StringLiteral"></emu-prodref>
    <emu-prodref name="DoubleStringCharacters"></emu-prodref>
    <emu-prodref name="SingleStringCharacters"></emu-prodref>
    <emu-prodref name="DoubleStringCharacter"></emu-prodref>
    <emu-prodref name="SingleStringCharacter"></emu-prodref>
    <emu-prodref name="LineContinuation"></emu-prodref>
    <emu-prodref name="EscapeSequence"></emu-prodref>
    <emu-prodref name="CharacterEscapeSequence"></emu-prodref>
    <emu-prodref name="SingleEscapeCharacter"></emu-prodref>
    <emu-prodref name="NonEscapeCharacter"></emu-prodref>
    <emu-prodref name="EscapeCharacter"></emu-prodref>
    <emu-prodref name="LegacyOctalEscapeSequence"></emu-prodref>
    <emu-prodref name="NonZeroOctalDigit"></emu-prodref>
    <emu-prodref name="ZeroToThree"></emu-prodref>
    <emu-prodref name="FourToSeven"></emu-prodref>
    <emu-prodref name="NonOctalDecimalEscapeSequence"></emu-prodref>
    <emu-prodref name="HexEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="Hex4Digits"></emu-prodref>
    <emu-prodref name="RegularExpressionLiteral"></emu-prodref>
    <emu-prodref name="RegularExpressionBody"></emu-prodref>
    <emu-prodref name="RegularExpressionChars"></emu-prodref>
    <emu-prodref name="RegularExpressionFirstChar"></emu-prodref>
    <emu-prodref name="RegularExpressionChar"></emu-prodref>
    <emu-prodref name="RegularExpressionBackslashSequence"></emu-prodref>
    <emu-prodref name="RegularExpressionNonTerminator"></emu-prodref>
    <emu-prodref name="RegularExpressionClass"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChars"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChar"></emu-prodref>
    <emu-prodref name="RegularExpressionFlags"></emu-prodref>
    <emu-prodref name="Template"></emu-prodref>
    <emu-prodref name="NoSubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateHead"></emu-prodref>
    <emu-prodref name="TemplateSubstitutionTail"></emu-prodref>
    <emu-prodref name="TemplateMiddle"></emu-prodref>
    <emu-prodref name="TemplateTail"></emu-prodref>
    <emu-prodref name="TemplateCharacters"></emu-prodref>
    <emu-prodref name="TemplateCharacter"></emu-prodref>
    <emu-prodref name="TemplateEscapeSequence"></emu-prodref>
    <emu-prodref name="NotEscapeSequence"></emu-prodref>
    <emu-prodref name="NotCodePoint"></emu-prodref>
    <emu-prodref name="CodePoint"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-expressions">
    <h1>表达式</h1>
    <emu-prodref name="IdentifierReference"></emu-prodref>
    <emu-prodref name="BindingIdentifier"></emu-prodref>
    <emu-prodref name="LabelIdentifier"></emu-prodref>
    <emu-prodref name="Identifier"></emu-prodref>
    <emu-prodref name="PrimaryExpression"></emu-prodref>
    <emu-prodref name="CoverParenthesizedExpressionAndArrowParameterList"></emu-prodref>
    <p>
      当处理产生式实例<br>
      <emu-prodref name="PrimaryExpression" a="parencover"></emu-prodref><br>
      时，|CoverParenthesizedExpressionAndArrowParameterList| 的解释使用以下语法进行细化：
    </p>
    <emu-prodref name="ParenthesizedExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Literal"></emu-prodref>
    <emu-prodref name="ArrayLiteral"></emu-prodref>
    <emu-prodref name="ElementList"></emu-prodref>
    <emu-prodref name="Elision"></emu-prodref>
    <emu-prodref name="SpreadElement"></emu-prodref>
    <emu-prodref name="ObjectLiteral"></emu-prodref>
    <emu-prodref name="PropertyDefinitionList"></emu-prodref>
    <emu-prodref name="PropertyDefinition"></emu-prodref>
    <emu-prodref name="PropertyName"></emu-prodref>
    <emu-prodref name="LiteralPropertyName"></emu-prodref>
    <emu-prodref name="ComputedPropertyName"></emu-prodref>
    <emu-prodref name="CoverInitializedName"></emu-prodref>
    <emu-prodref name="Initializer"></emu-prodref>
    <emu-prodref name="TemplateLiteral"></emu-prodref>
    <emu-prodref name="SubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateSpans"></emu-prodref>
    <emu-prodref name="TemplateMiddleList"></emu-prodref>
    <emu-prodref name="MemberExpression"></emu-prodref>
    <emu-prodref name="SuperProperty"></emu-prodref>
    <emu-prodref name="MetaProperty"></emu-prodref>
    <emu-prodref name="NewTarget"></emu-prodref>
    <emu-prodref name="ImportMeta"></emu-prodref>
    <emu-prodref name="NewExpression"></emu-prodref>
    <emu-prodref name="CallExpression"></emu-prodref>
    <p>
      当处理产生式实例<br>
      <emu-prodref name="CallExpression" a="callcover"></emu-prodref><br>
      时，|CoverCallExpressionAndAsyncArrowHead| 的解释使用以下语法进行细化：
    </p>
    <emu-prodref name="CallMemberExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="SuperCall"></emu-prodref>
    <emu-prodref name="ImportCall"></emu-prodref>
    <emu-prodref name="Arguments"></emu-prodref>
    <emu-prodref name="ArgumentList"></emu-prodref>
    <emu-prodref name="OptionalExpression"></emu-prodref>
    <emu-prodref name="OptionalChain"></emu-prodref>
    <emu-prodref name="LeftHandSideExpression"></emu-prodref>
    <emu-prodref name="UpdateExpression"></emu-prodref>
    <emu-prodref name="UnaryExpression"></emu-prodref>
    <emu-prodref name="ExponentiationExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeOperator"></emu-prodref>
    <emu-prodref name="AdditiveExpression"></emu-prodref>
    <emu-prodref name="ShiftExpression"></emu-prodref>
    <emu-prodref name="RelationalExpression"></emu-prodref>
    <emu-prodref name="EqualityExpression"></emu-prodref>
    <emu-prodref name="BitwiseANDExpression"></emu-prodref>
    <emu-prodref name="BitwiseXORExpression"></emu-prodref>
    <emu-prodref name="BitwiseORExpression"></emu-prodref>
    <emu-prodref name="LogicalANDExpression"></emu-prodref>
    <emu-prodref name="LogicalORExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpressionHead"></emu-prodref>
    <emu-prodref name="ShortCircuitExpression"></emu-prodref>
    <emu-prodref name="ConditionalExpression"></emu-prodref>
    <emu-prodref name="AssignmentExpression"></emu-prodref>
    <emu-prodref name="AssignmentOperator"></emu-prodref>
    <p>
      在特定情况下，当处理产生式实例<br>
      <emu-prodref name="AssignmentExpression" a="assignment"></emu-prodref><br>
      时，|LeftHandSideExpression| 的解释使用以下语法进行细化：
    </p>
    <emu-prodref name="AssignmentPattern"></emu-prodref>
    <emu-prodref name="ObjectAssignmentPattern"></emu-prodref>
    <emu-prodref name="ArrayAssignmentPattern"></emu-prodref>
    <emu-prodref name="AssignmentRestProperty"></emu-prodref>
    <emu-prodref name="AssignmentPropertyList"></emu-prodref>
    <emu-prodref name="AssignmentElementList"></emu-prodref>
    <emu-prodref name="AssignmentElisionElement"></emu-prodref>
    <emu-prodref name="AssignmentProperty"></emu-prodref>
    <emu-prodref name="AssignmentElement"></emu-prodref>
    <emu-prodref name="AssignmentRestElement"></emu-prodref>
    <emu-prodref name="DestructuringAssignmentTarget"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Expression"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-statements">
    <h1>语句</h1>
    <emu-prodref name="Statement"></emu-prodref>
    <emu-prodref name="Declaration"></emu-prodref>
    <emu-prodref name="HoistableDeclaration"></emu-prodref>
    <emu-prodref name="BreakableStatement"></emu-prodref>
    <emu-prodref name="BlockStatement"></emu-prodref>
    <emu-prodref name="Block"></emu-prodref>
    <emu-prodref name="StatementList"></emu-prodref>
    <emu-prodref name="StatementListItem"></emu-prodref>
    <emu-prodref name="LexicalDeclaration"></emu-prodref>
    <emu-prodref name="LetOrConst"></emu-prodref>
    <emu-prodref name="BindingList"></emu-prodref>
    <emu-prodref name="LexicalBinding"></emu-prodref>
    <emu-prodref name="VariableStatement"></emu-prodref>
    <emu-prodref name="VariableDeclarationList"></emu-prodref>
    <emu-prodref name="VariableDeclaration"></emu-prodref>
    <emu-prodref name="BindingPattern"></emu-prodref>
    <emu-prodref name="ObjectBindingPattern"></emu-prodref>
    <emu-prodref name="ArrayBindingPattern"></emu-prodref>
    <emu-prodref name="BindingRestProperty"></emu-prodref>
    <emu-prodref name="BindingPropertyList"></emu-prodref>
    <emu-prodref name="BindingElementList"></emu-prodref>
    <emu-prodref name="BindingElisionElement"></emu-prodref>
    <emu-prodref name="BindingProperty"></emu-prodref>
    <emu-prodref name="BindingElement"></emu-prodref>
    <emu-prodref name="SingleNameBinding"></emu-prodref>
    <emu-prodref name="BindingRestElement"></emu-prodref>
    <emu-prodref name="EmptyStatement"></emu-prodref>
    <emu-prodref name="ExpressionStatement"></emu-prodref>
    <emu-prodref name="IfStatement"></emu-prodref>
    <emu-prodref name="IterationStatement"></emu-prodref>
    <emu-prodref name="DoWhileStatement"></emu-prodref>
    <emu-prodref name="WhileStatement"></emu-prodref>
    <emu-prodref name="ForStatement"></emu-prodref>
    <emu-prodref name="ForInOfStatement"></emu-prodref>
    <emu-prodref name="ForDeclaration"></emu-prodref>
    <emu-prodref name="ForBinding"></emu-prodref>
    <emu-prodref name="ContinueStatement"></emu-prodref>
    <emu-prodref name="BreakStatement"></emu-prodref>
    <emu-prodref name="ReturnStatement"></emu-prodref>
    <emu-prodref name="WithStatement"></emu-prodref>
    <emu-prodref name="SwitchStatement"></emu-prodref>
    <emu-prodref name="CaseBlock"></emu-prodref>
    <emu-prodref name="CaseClauses"></emu-prodref>
    <emu-prodref name="CaseClause"></emu-prodref>
    <emu-prodref name="DefaultClause"></emu-prodref>
    <emu-prodref name="LabelledStatement"></emu-prodref>
    <emu-prodref name="LabelledItem"></emu-prodref>
    <emu-prodref name="ThrowStatement"></emu-prodref>
    <emu-prodref name="TryStatement"></emu-prodref>
    <emu-prodref name="Catch"></emu-prodref>
    <emu-prodref name="Finally"></emu-prodref>
    <emu-prodref name="CatchParameter"></emu-prodref>
    <emu-prodref name="DebuggerStatement"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-functions-and-classes">
    <h1>函数与类</h1>
    <emu-prodref name="UniqueFormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameterList"></emu-prodref>
    <emu-prodref name="FunctionRestParameter"></emu-prodref>
    <emu-prodref name="FormalParameter"></emu-prodref>
    <emu-prodref name="FunctionDeclaration"></emu-prodref>
    <emu-prodref name="FunctionExpression"></emu-prodref>
    <emu-prodref name="FunctionBody"></emu-prodref>
    <emu-prodref name="FunctionStatementList"></emu-prodref>
    <emu-prodref name="ArrowFunction"></emu-prodref>
    <emu-prodref name="ArrowParameters"></emu-prodref>
    <emu-prodref name="ConciseBody"></emu-prodref>
    <emu-prodref name="ExpressionBody"></emu-prodref>
    <p>
      当处理产生式实例<br>
      <emu-prodref name="ArrowParameters" a="parencover"></emu-prodref><br>
      时，|CoverParenthesizedExpressionAndArrowParameterList| 的解释使用以下语法进行细化：
    </p>
    <emu-prodref name="ArrowFormalParameters"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="AsyncArrowFunction"></emu-prodref>
    <emu-prodref name="AsyncConciseBody"></emu-prodref>
    <emu-prodref name="AsyncArrowBindingIdentifier"></emu-prodref>
    <emu-prodref name="CoverCallExpressionAndAsyncArrowHead"></emu-prodref>
    <p>
      当处理产生式实例<br>
      <emu-prodref name="AsyncArrowFunction" a="callcover"></emu-prodref><br>
      时，|CoverCallExpressionAndAsyncArrowHead| 的解释使用以下语法进行细化：
    </p>
    <emu-prodref name="AsyncArrowHead"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="MethodDefinition"></emu-prodref>
    <emu-prodref name="PropertySetParameterList"></emu-prodref>
    <emu-prodref name="GeneratorDeclaration"></emu-prodref>
    <emu-prodref name="GeneratorExpression"></emu-prodref>
    <emu-prodref name="GeneratorMethod"></emu-prodref>
    <emu-prodref name="GeneratorBody"></emu-prodref>
    <emu-prodref name="YieldExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorDeclaration"></emu-prodref>
    <emu-prodref name="AsyncGeneratorExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorMethod"></emu-prodref>
    <emu-prodref name="AsyncGeneratorBody"></emu-prodref>
    <emu-prodref name="AsyncFunctionDeclaration"></emu-prodref>
    <emu-prodref name="AsyncFunctionExpression"></emu-prodref>
    <emu-prodref name="AsyncMethod"></emu-prodref>
    <emu-prodref name="AsyncFunctionBody"></emu-prodref>
    <emu-prodref name="AwaitExpression"></emu-prodref>
    <emu-prodref name="ClassDeclaration"></emu-prodref>
    <emu-prodref name="ClassExpression"></emu-prodref>
    <emu-prodref name="ClassTail"></emu-prodref>
    <emu-prodref name="ClassHeritage"></emu-prodref>
    <emu-prodref name="ClassBody"></emu-prodref>
    <emu-prodref name="ClassElementList"></emu-prodref>
    <emu-prodref name="ClassElement"></emu-prodref>
    <emu-prodref name="FieldDefinition"></emu-prodref>
    <emu-prodref name="ClassElementName"></emu-prodref>
    <emu-prodref name="ClassStaticBlock"></emu-prodref>
    <emu-prodref name="ClassStaticBlockBody"></emu-prodref>
    <emu-prodref name="ClassStaticBlockStatementList"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-scripts-and-modules">
    <h1>脚本与模块</h1>
    <emu-prodref name="Script"></emu-prodref>
    <emu-prodref name="ScriptBody"></emu-prodref>
    <emu-prodref name="Module"></emu-prodref>
    <emu-prodref name="ModuleBody"></emu-prodref>
    <emu-prodref name="ModuleItemList"></emu-prodref>
    <emu-prodref name="ModuleItem"></emu-prodref>
    <emu-prodref name="ModuleExportName"></emu-prodref>
    <emu-prodref name="ImportDeclaration"></emu-prodref>
    <emu-prodref name="ImportClause"></emu-prodref>
    <emu-prodref name="ImportedDefaultBinding"></emu-prodref>
    <emu-prodref name="NameSpaceImport"></emu-prodref>
    <emu-prodref name="NamedImports"></emu-prodref>
    <emu-prodref name="FromClause"></emu-prodref>
    <emu-prodref name="ImportsList"></emu-prodref>
    <emu-prodref name="ImportSpecifier"></emu-prodref>
    <emu-prodref name="ModuleSpecifier"></emu-prodref>
    <emu-prodref name="ImportedBinding"></emu-prodref>
    <emu-prodref name="WithClause"></emu-prodref>
    <emu-prodref name="WithEntries"></emu-prodref>
    <emu-prodref name="AttributeKey"></emu-prodref>
    <emu-prodref name="ExportDeclaration"></emu-prodref>
    <emu-prodref name="ExportFromClause"></emu-prodref>
    <emu-prodref name="NamedExports"></emu-prodref>
    <emu-prodref name="ExportsList"></emu-prodref>
    <emu-prodref name="ExportSpecifier"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-number-conversions">
    <h1>数值转换</h1>
    <emu-prodref name="StringNumericLiteral"></emu-prodref>
    <emu-prodref name="StrWhiteSpace"></emu-prodref>
    <emu-prodref name="StrWhiteSpaceChar"></emu-prodref>
    <emu-prodref name="StrNumericLiteral"></emu-prodref>
    <emu-prodref name="StrDecimalLiteral"></emu-prodref>
    <emu-prodref name="StrUnsignedDecimalLiteral"></emu-prodref>
    <p>所有未被 |StringNumericLiteral| 语法显式定义的语法符号，其定义与 <emu-xref href="#sec-literals-numeric-literals">数字字面量的词法语法</emu-xref> 中使用的定义相同。</p>
    <emu-prodref name="StringIntegerLiteral"></emu-prodref>
    <emu-prodref name="StrIntegerLiteral"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-time-zone-offset-string-format">
    <h1>时区偏移字符串格式</h1>
    <emu-prodref name="UTCOffset"></emu-prodref>
    <emu-prodref name="ASCIISign"></emu-prodref>
    <emu-prodref name="Hour"></emu-prodref>
    <emu-prodref name="HourSubcomponents"></emu-prodref>
    <emu-prodref name="TimeSeparator"></emu-prodref>
    <emu-prodref name="MinuteSecond"></emu-prodref>
    <emu-prodref name="TemporalDecimalFraction"></emu-prodref>
    <emu-prodref name="TemporalDecimalSeparator"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-regular-expressions">
    <h1>正则表达式</h1>
    <emu-prodref name="Pattern"></emu-prodref>
    <emu-prodref name="Disjunction"></emu-prodref>
    <emu-prodref name="Alternative"></emu-prodref>
    <emu-prodref name="Term"></emu-prodref>
    <emu-prodref name="Assertion"></emu-prodref>
    <emu-prodref name="Quantifier"></emu-prodref>
    <emu-prodref name="QuantifierPrefix"></emu-prodref>
    <emu-prodref name="Atom"></emu-prodref>
    <emu-prodref name="RegularExpressionModifiers"></emu-prodref>
    <emu-prodref name="RegularExpressionModifier"></emu-prodref>
    <emu-prodref name="SyntaxCharacter"></emu-prodref>
    <emu-prodref name="PatternCharacter"></emu-prodref>
    <emu-prodref name="AtomEscape"></emu-prodref>
    <emu-prodref name="CharacterEscape"></emu-prodref>
    <emu-prodref name="ControlEscape"></emu-prodref>
    <emu-prodref name="GroupSpecifier"></emu-prodref>
    <emu-prodref name="GroupName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierStart"></emu-prodref>
    <emu-prodref name="RegExpIdentifierPart"></emu-prodref>
    <emu-prodref name="RegExpUnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeLeadSurrogate"></emu-prodref>
    <emu-prodref name="UnicodeTrailSurrogate"></emu-prodref>
    <p>对于每个 `\\u` |HexTrailSurrogate|（其关联的 `u` |HexLeadSurrogate| 选择存在歧义），应与最近的、否则将没有对应 `\\u` |HexTrailSurrogate| 的可能 `u` |HexLeadSurrogate| 进行关联。</p>
    <p>&nbsp;</p>
    <emu-prodref name="HexLeadSurrogate"></emu-prodref>
    <emu-prodref name="HexTrailSurrogate"></emu-prodref>
    <emu-prodref name="HexNonSurrogate"></emu-prodref>
    <emu-prodref name="IdentityEscape"></emu-prodref>
    <emu-prodref name="DecimalEscape"></emu-prodref>
    <emu-prodref name="CharacterClassEscape"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueExpression"></emu-prodref>
    <emu-prodref name="UnicodePropertyName"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValue"></emu-prodref>
    <emu-prodref name="LoneUnicodePropertyNameOrValue"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacter"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacter"></emu-prodref>
    <emu-prodref name="CharacterClass"></emu-prodref>
    <emu-prodref name="ClassContents"></emu-prodref>
    <emu-prodref name="NonemptyClassRanges"></emu-prodref>
    <emu-prodref name="NonemptyClassRangesNoDash"></emu-prodref>
    <emu-prodref name="ClassAtom"></emu-prodref>
    <emu-prodref name="ClassAtomNoDash"></emu-prodref>
    <emu-prodref name="ClassEscape"></emu-prodref>
    <emu-prodref name="ClassSetExpression"></emu-prodref>
    <emu-prodref name="ClassUnion"></emu-prodref>
    <emu-prodref name="ClassIntersection"></emu-prodref>
    <emu-prodref name="ClassSubtraction"></emu-prodref>
    <emu-prodref name="ClassSetRange"></emu-prodref>
    <emu-prodref name="ClassSetOperand"></emu-prodref>
    <emu-prodref name="NestedClass"></emu-prodref>
    <emu-prodref name="ClassStringDisjunction"></emu-prodref>
    <emu-prodref name="ClassStringDisjunctionContents"></emu-prodref>
    <emu-prodref name="ClassString"></emu-prodref>
    <emu-prodref name="NonEmptyClassString"></emu-prodref>
    <emu-prodref name="ClassSetCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedDoublePunctuator"></emu-prodref>
    <emu-prodref name="ClassSetSyntaxCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedPunctuator"></emu-prodref>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>供网页浏览器使用的额外 ECMAScript 特性</h1>
  <p>当 ECMAScript 宿主是网页浏览器时，本附录中定义的 ECMAScript 语言语法和语义是必需的。如果 ECMAScript 宿主不是网页浏览器，则本附录内容是规范性的但可选。</p>
  <p>本附录中定义的一些特性在本附录中具体说明，另一些则在本文档主体中说明。</p>
  <p>当某个特性在正文中定义时，每个其影响文档的点都会用带颜色框中的 “Normative Optional” 字样标记。此外，如果该特性牵涉算法或早期错误规则中的特定措辞，则这些措辞会以 “<dfn variants="otherwise supports">the host supports</dfn>” 该相关特性为条件加以保护。网页浏览器被要求支持所有此类特性。</p>
  <emu-note>
    <p>本附录描述了各种历史遗留特性，以及网页浏览器 ECMAScript 宿主的其他特征。本附录中规定的所有语言特性和行为都具有一个或多个不理想的特征，如果没有遗留使用，它们本应从本规范中移除。然而，大量现有网页使用这些特性，意味着浏览器必须继续支持它们。本附录中的规范定义了这些遗留特性的互操作实现要求。</p>
    <p>这些特性不被视为 ECMAScript 语言的核心部分。编写新的 ECMAScript 代码时，程序员不应使用或假设这些特性和行为的存在。除非实现是网页浏览器的一部分，或需要运行与浏览器遇到的相同遗留 ECMAScript 代码，否则不鼓励 ECMAScript 实现实现这些特性。</p>
  </emu-note>

  <emu-annex id="sec-additional-syntax">
    <h1>附加语法</h1>

    <emu-annex id="sec-html-like-comments">
      <h1>类 HTML 注释</h1>
      <p><emu-xref href="#sec-comments"></emu-xref> 的语法和语义按如下方式扩展，但在使用目标符号 |Module| 解析源码文本时不允许此扩展：</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        InputElementHashbangOrRegExp ::
          WhiteSpace
          LineTerminator
          Comment
          CommonToken
          HashbangComment
          RegularExpressionLiteral
          HTMLCloseComment

        Comment ::
          MultiLineComment
          SingleLineComment
          SingleLineHTMLOpenComment
          SingleLineHTMLCloseComment
          SingleLineDelimitedComment

        MultiLineComment ::
          `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

        FirstCommentLine ::
          SingleLineDelimitedCommentChars

        SingleLineHTMLOpenComment ::
          `&lt;!--` SingleLineCommentChars?

        SingleLineHTMLCloseComment ::
          LineTerminatorSequence HTMLCloseComment

        SingleLineDelimitedComment ::
          `/*` SingleLineDelimitedCommentChars? `*/`

        HTMLCloseComment ::
          WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `--&gt;` SingleLineCommentChars?

        SingleLineDelimitedCommentChars ::
          SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotAsteriskChar ::
          SourceCharacter but not one of `*` or LineTerminator

        SingleLinePostAsteriskCommentChars ::
          SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotForwardSlashOrAsteriskChar ::
          SourceCharacter but not one of `/` or `*` or LineTerminator

        WhiteSpaceSequence ::
          WhiteSpace WhiteSpaceSequence?

        SingleLineDelimitedCommentSequence ::
          SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?
      </emu-grammar>
      <p>类似包含行终止符代码点的 |MultiLineComment|，|SingleLineHTMLCloseComment| 在句法语法解析目的上被视为一个 |LineTerminator|。</p>
    </emu-annex>

    <emu-annex id="sec-regular-expressions-patterns">
      <h1>正则表达式模式</h1>
      <p><emu-xref href="#sec-patterns"></emu-xref> 的语法按如下方式修改与扩展。这些更改引入了通过文法产生式的排序与上下文信息消解的歧义。使用下列语法解析时，只有此前的产生式候选不匹配时才考虑后续候选。</p>
      <p>这种替代模式文法与语义只改变 BMP 模式的语法与语义。下面的语法扩展包含带有 [UnicodeMode] 参数的产生式。然而，这些扩展均不改变在目标符号上存在 [UnicodeMode] 参数时被识别的 Unicode 模式的语法。</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [+UnicodeMode] Assertion[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] Assertion[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups]

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          [+UnicodeMode] `(?=` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [+UnicodeMode] `(?!` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups]
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        QuantifiableAssertion[NamedCaptureGroups] ::
          `(?=` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`

        ExtendedAtom[NamedCaptureGroups] ::
          `.`
          `\` AtomEscape[~UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]
          CharacterClass[~UnicodeMode, ~UnicodeSetsMode]
          `(` GroupSpecifier[~UnicodeMode]? Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          InvalidBracedQuantifier
          ExtendedPatternCharacter

        InvalidBracedQuantifier ::
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        ExtendedPatternCharacter ::
          SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] DecimalEscape
          [~UnicodeMode] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &le; CountLeftCapturingParensWithin(the |Pattern| containing |DecimalEscape|)]
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode, NamedCaptureGroups] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          [~UnicodeMode] LegacyOctalEscapeSequence
          IdentityEscape[?UnicodeMode, ?NamedCaptureGroups]

        IdentityEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacterIdentityEscape[?NamedCaptureGroups]

        SourceCharacterIdentityEscape[NamedCaptureGroups] ::
          [~NamedCaptureGroups] SourceCharacter but not `c`
          [+NamedCaptureGroups] SourceCharacter but not one of `c` or `k`

        ClassAtomNoDash[UnicodeMode, NamedCaptureGroups] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]

        ClassEscape[UnicodeMode, NamedCaptureGroups] ::
          `b`
          [+UnicodeMode] `-`
          [~UnicodeMode] `c` ClassControlLetter
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]

        ClassControlLetter ::
          DecimalDigit
          `_`
      </emu-grammar>
      <emu-note>
        <p>当同一左侧同时出现带 [+UnicodeMode] 与 [~UnicodeMode] 守卫时，用于控制消解优先级。</p>
      </emu-note>

      <emu-annex id="sec-patterns-static-semantics-early-errors-annexb">
        <h1>静态语义：早期错误</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-early-errors"></emu-xref> 的语义按如下扩展：</p>
        <emu-grammar>ExtendedAtom :: InvalidBracedQuantifier</emu-grammar>
        <ul>
          <li>
            若任意源码文本被此产生式匹配，则为语法错误。
          </li>
        </ul>
        <p>此外，下列产生式的规则添加 <ins>高亮</ins> 文本后被修改：</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            若第一个 |ClassAtom| 的 IsCharacterClass 为 *true* 或第二个 |ClassAtom| 的 IsCharacterClass 为 *true* <ins>且该产生式具有 <sub>[UnicodeMode]</sub> 参数</ins>，则为语法错误。
          </li>
          <li>
            若第一个 |ClassAtom| 的 IsCharacterClass 为 *false*，第二个 |ClassAtom| 的 IsCharacterClass 为 *false*，且第一个 |ClassAtom| 的 CharacterValue 严格大于第二个的 CharacterValue，则为语法错误。
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            若 |ClassAtomNoDash| 的 IsCharacterClass 为 *true* 或 |ClassAtom| 的 IsCharacterClass 为 *true* <ins>且该产生式具有 <sub>[UnicodeMode]</sub> 参数</ins>，则为语法错误。
          </li>
          <li>
            若 |ClassAtomNoDash| 的 IsCharacterClass 为 *false*，|ClassAtom| 的 IsCharacterClass 为 *false*，且 |ClassAtomNoDash| 的 CharacterValue 严格大于 |ClassAtom| 的 CharacterValue，则为语法错误。
          </li>
        </ul>
      </emu-annex>

      <emu-annex id="sec-countleftcapturingparens-annexb">
        <h1>静态语义：CountLeftCapturingParensWithin 与 CountLeftCapturingParensBefore</h1>
        <p>在 CountLeftCapturingParensWithin 与 CountLeftCapturingParensBefore 的定义中，对 “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ” 的引用应解释为 “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ” 或 “<emu-grammar>ExtendedAtom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ”。</p>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-is-character-class-annexb">
        <h1>静态语义：IsCharacterClass</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-is-character-class"></emu-xref> 的语义按如下扩展：</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-character-value-annexb">
        <h1>静态语义：CharacterValue</h1>
        <p><emu-xref href="#sec-patterns-static-semantics-character-value"></emu-xref> 的语义按如下扩展：</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. 返回 U+005C (REVERSE SOLIDUS) 的数值。
        </emu-alg>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |ClassControlLetter| 匹配的代码点。
          1. 令 _i_ 为 _ch_ 的数值。
          1. 返回 _i_ 除以 32 的余数。
        </emu-alg>
        <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar>
        <emu-alg>
          1. 返回 |LegacyOctalEscapeSequence| 的 MV（见 <emu-xref href="#sec-string-literals-static-semantics-mv"></emu-xref>）。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compilesubpattern-annexb" oldids="sec-regular-expression-patterns-semantics">
        <h1>运行时语义：CompileSubpattern</h1>
        <p>CompileSubpattern 的语义按如下扩展：</p>

        <p><emu-grammar>Term :: QuantifiableAssertion Quantifier</emu-grammar> 的规则与 <emu-grammar>Term :: Atom Quantifier</emu-grammar> 相同，但用 |QuantifiableAssertion| 替换 |Atom|。</p>
        <p><emu-grammar>Term :: ExtendedAtom Quantifier</emu-grammar> 的规则与 <emu-grammar>Term :: Atom Quantifier</emu-grammar> 相同，但用 |ExtendedAtom| 替换 |Atom|。</p>
        <p><emu-grammar>Term :: ExtendedAtom</emu-grammar> 的规则与 <emu-grammar>Term :: Atom</emu-grammar> 相同，但用 |ExtendedAtom| 替换 |Atom|。</p>
      </emu-annex>

      <emu-annex id="sec-compileassertion-annexb">
        <h1>运行时语义：CompileAssertion</h1>
        <p><emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar> 与 <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar> 产生式的 CompileAssertion 规则同样用于 |QuantifiableAssertion| 产生式，但用 |QuantifiableAssertion| 替换 |Assertion|。</p>
      </emu-annex>

      <emu-annex id="sec-compileatom-annexb">
        <h1>运行时语义：CompileAtom</h1>
        <p>除 <emu-grammar>Atom :: PatternCharacter</emu-grammar> 外，|Atom| 产生式的 CompileAtom 规则也用于 |ExtendedAtom| 产生式，但用 |ExtendedAtom| 替换 |Atom|。同时添加以下带参数 _direction_ 的规则：</p>
        <emu-grammar>ExtendedAtom :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为包含单个字符 `\\` U+005C (REVERSE SOLIDUS) 的 CharSet。
          1. 返回 CharacterSetMatcher(_rer_, _A_, *false*, _direction_)。
        </emu-alg>
        <emu-grammar>ExtendedAtom :: ExtendedPatternCharacter</emu-grammar>
        <emu-alg>
          1. 令 _ch_ 为 |ExtendedPatternCharacter| 所表示的字符。
          1. 令 _A_ 为包含字符 _ch_ 的单元素 CharSet。
          1. 返回 CharacterSetMatcher(_rer_, _A_, *false*, _direction_)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compiletocharset-annexb">
        <h1>运行时语义：CompileToCharSet</h1>
        <p><emu-xref href="#sec-compiletocharset"></emu-xref> 的语义按如下扩展：</p>

        <p>以下两条规则替换 CompileToCharSet 对应规则。</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为第一个 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为第二个 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _C_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 令 _D_ 为 CharacterRangeOrUnion(_rer_, _A_, _B_)。
          1. 返回 _D_ 与 _C_ 的并集。
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. 令 _A_ 为 |ClassAtomNoDash| 的 CompileToCharSet，参数 _rer_。
          1. 令 _B_ 为 |ClassAtom| 的 CompileToCharSet，参数 _rer_。
          1. 令 _C_ 为 |ClassContents| 的 CompileToCharSet，参数 _rer_。
          1. 令 _D_ 为 CharacterRangeOrUnion(_rer_, _A_, _B_)。
          1. 返回 _D_ 与 _C_ 的并集。
        </emu-alg>

        <p>另外，向 CompileToCharSet 添加以下规则。</p>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. 令 _cv_ 为该 |ClassEscape| 的 CharacterValue。
          1. 令 _c_ 为字符值为 _cv_ 的字符。
          1. 返回包含单个字符 _c_ 的 CharSet。
        </emu-alg>
        <emu-grammar>ClassAtomNoDash :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. 返回包含单个字符 `\\` U+005C (REVERSE SOLIDUS) 的 CharSet。
        </emu-alg>

        <emu-note>该产生式只能从字符类中出现的序列 `\c`（其后未跟可接受控制字符）到达。</emu-note>

        <emu-annex id="sec-runtime-semantics-characterrangeorunion-abstract-operation" type="abstract operation">
          <h1>
            CharacterRangeOrUnion (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 若 HasEitherUnicodeFlag(_rer_) 为 *false*，则
              1. 若 _A_ 不正好包含一个字符或 _B_ 不正好包含一个字符，则
                1. 令 _C_ 为包含单个字符 `-` U+002D (HYPHEN-MINUS) 的 CharSet。
                1. 返回 CharSet _A_、_B_ 与 _C_ 的并集。
            1. 返回 CharacterRange(_A_, _B_)。
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-parsepattern-annexb">
        <h1>静态语义：ParsePattern ( _patternText_, _u_, _v_ )</h1>
        <p><emu-xref href="#sec-parsepattern"></emu-xref> 的语义按如下扩展：</p>
        <p>抽象操作 ParsePattern 接受参数 _patternText_（一串 Unicode 代码点）、_u_（一个 Boolean）与 _v_（一个 Boolean）。调用时执行以下步骤：</p>
        <emu-alg>
          1. 若 _v_ 为 *true* 且 _u_ 为 *true*，则
            1. 令 _parseResult_ 为包含一个或多个 *SyntaxError* 对象的 List。
          1. 否则若 _v_ 为 *true*，则
            1. 令 _parseResult_ 为 ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|)。
          1. 否则若 _u_ 为 *true*，则
            1. 令 _parseResult_ 为 ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|)。
          1. 否则，
            1. 令 _parseResult_ 为 ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, ~NamedCaptureGroups]|)。
            1. 若 _parseResult_ 是 Parse Node 且 _parseResult_ 包含 |GroupName|，则
              1. 将 _parseResult_ 设为 ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|)。
          1. 返回 _parseResult_。
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-additional-built-in-properties">
    <h1>额外内建属性</h1>
    <p>当 ECMAScript 宿主是网页浏览器时，标准内建对象具有以下额外属性。</p>

    <emu-annex id="sec-additional-properties-of-the-global-object">
      <h1>全局对象的额外属性</h1>
      <p><emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref> 中的条目被添加到 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>。</p>
      <emu-table id="table-additional-well-known-intrinsic-objects" caption="额外的著名内在对象" oldids="table-60">
        <table>
          <thead>
            <tr>
              <th>
                内在名称
              </th>
              <th>
                全局名称
              </th>
              <th>
                ECMAScript 语言关联
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              %escape%
            </td>
            <td>
              `escape`
            </td>
            <td>
              `escape` 函数 (<emu-xref href="#sec-escape-string"></emu-xref>)
            </td>
          </tr>
          <tr>
            <td>
              %unescape%
            </td>
            <td>
              `unescape`
            </td>
            <td>
              `unescape` 函数 (<emu-xref href="#sec-unescape-string"></emu-xref>)
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-annex id="sec-escape-string">
        <h1>escape ( _string_ )</h1>
        <p>该函数是全局对象的一个属性。它计算一个字符串值的新版本，其中某些代码单元被十六进制转义序列替换。</p>
        <p>当替换数值 ≤ 0x00FF 的代码单元时，使用形如 <code>%<var>xx</var></code> 的两位转义序列。替换数值严格大于 0x00FF 的代码单元时，使用形如 <code>%u<var>xxxx</var></code> 的四位转义序列。</p>
        <p>它是 <dfn>%escape%</dfn> 内在对象。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 将 _string_ 设为 ? ToString(_string_)。
          1. 令 _len_ 为 _string_ 的长度。
          1. 令 _R_ 为空字符串。
          1. 令 _unescapedSet_ 为 ASCII 单词字符与 *"@\*+-./"* 的串联。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _C_ 为 _string_ 中索引 _k_ 处的代码单元。
            1. 若 _unescapedSet_ 包含 _C_，则
              1. 令 _S_ 为 _C_。
            1. 否则，
              1. 令 _n_ 为 _C_ 的数值。
              1. 若 _n_ &lt; 256，则
                1. 令 _hex_ 为将 _n_ 格式化为大写十六进制数的字符串表示。
                1. 令 _S_ 为 *"%"* 与 StringPad(_hex_, 2, *"0"*, ~start~) 的串联。
              1. 否则，
                1. 令 _hex_ 为将 _n_ 格式化为大写十六进制数的字符串表示。
                1. 令 _S_ 为 *"%u"* 与 StringPad(_hex_, 4, *"0"*, ~start~) 的串联。
            1. 将 _R_ 设为 _R_ 与 _S_ 的串联。
            1. 将 _k_ 设为 _k_ + 1。
          1. 返回 _R_。
        </emu-alg>
        <emu-note>
          <p>该编码部分基于 RFC 1738 描述的编码，但本标准指定的全部编码如上所述，与 RFC 1738 内容无关。该编码不反映 RFC 3986 对 RFC 1738 的更改。</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-unescape-string">
        <h1>unescape ( _string_ )</h1>
        <p>该函数是全局对象的一个属性。它计算一个字符串值的新版本，其中每个可能由 `escape` 函数引入的转义序列被其表示的代码单元替换。</p>
        <p>它是 <dfn>%unescape%</dfn> 内在对象。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 将 _string_ 设为 ? ToString(_string_)。
          1. 令 _len_ 为 _string_ 的长度。
          1. 令 _R_ 为空字符串。
          1. 令 _k_ 为 0。
          1. 当 _k_ &lt; _len_ 重复，
            1. 令 _C_ 为 _string_ 中索引 _k_ 处的代码单元。
            1. 若 _C_ 是代码单元 0x0025 (PERCENT SIGN)，则
              1. 令 _hexDigits_ 为空字符串。
              1. 令 _optionalAdvance_ 为 0。
              1. 若 _k_ + 5 &lt; _len_ 且 _string_ 中索引 _k_ + 1 处代码单元为 0x0075 (LATIN SMALL LETTER U)，则
                1. 将 _hexDigits_ 设为 _string_ 从 _k_ + 2 到 _k_ + 6 的子串。
                1. 将 _optionalAdvance_ 设为 5。
              1. 否则若 _k_ + 3 ≤ _len_，则
                1. 将 _hexDigits_ 设为 _string_ 从 _k_ + 1 到 _k_ + 3 的子串。
                1. 将 _optionalAdvance_ 设为 2。
              1. 令 _parseResult_ 为 ParseText(_hexDigits_, |HexDigits[~Sep]|)。
              1. 若 _parseResult_ 是 Parse Node，则
                1. 令 _n_ 为 _parseResult_ 的 MV。
                1. 将 _C_ 设为数值为 _n_ 的代码单元。
                1. 将 _k_ 设为 _k_ + _optionalAdvance_。
            1. 将 _R_ 设为 _R_ 与 _C_ 的串联。
            1. 将 _k_ 设为 _k_ + 1。
          1. 返回 _R_。
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-string.prototype-object">
      <h1>String.prototype 对象的额外属性</h1>

      <emu-annex id="sec-string.prototype.substr">
        <h1>String.prototype.substr ( _start_, _length_ )</h1>
        <p>该方法返回将 *this* 值转换为字符串后的一个<emu-not-ref>substring</emu-not-ref>，从索引 _start_ 开始，长度为 _length_ 个代码单元（或如果 _length_ 为 *undefined* 则直到字符串末尾）。若 _start_ 为负，则将其视为 <emu-eqn>_sourceLength_ + _start_</emu-eqn>，其中 _sourceLength_ 是字符串长度。结果是一个字符串值，而不是字符串对象。</p>
        <p>调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireObjectCoercible(_O_)。
          1. 令 _S_ 为 ? ToString(_O_)。
          1. 令 _size_ 为 _S_ 的长度。
          1. 令 _intStart_ 为 ? ToIntegerOrInfinity(_start_)。
          1. 若 _intStart_ = -∞，将 _intStart_ 设为 0。
          1. 否则若 _intStart_ &lt; 0，将 _intStart_ 设为 max(_size_ + _intStart_, 0)。
          1. 否则，将 _intStart_ 设为 min(_intStart_, _size_)。
          1. 若 _length_ 为 *undefined*，令 _intLength_ 为 _size_；否则令 _intLength_ 为 ? ToIntegerOrInfinity(_length_)。
          1. 将 _intLength_ 夹取到 0 与 _size_ 之间。
          1. 令 _intEnd_ 为 min(_intStart_ + _intLength_, _size_)。
          1. 返回 _S_ 从 _intStart_ 到 _intEnd_ 的子串。
        </emu-alg>
        <emu-note>
          <p>该方法有意设计为泛型；它不要求其 *this* 值为字符串对象。因此可以被转移到其他对象上用作方法。</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-string.prototype.anchor">
        <h1>String.prototype.anchor ( _name_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"a"*, *"name"*, _name_)。
        </emu-alg>

        <emu-annex id="sec-createhtml" type="abstract operation">
          <h1>
            CreateHTML (
              _string_: an ECMAScript language value,
              _tag_: a String,
              _attribute_: a String,
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 执行 ? RequireObjectCoercible(_string_)。
            1. 令 _S_ 为 ? ToString(_string_)。
            1. 令 _p1_ 为 *"&lt;"* 与 _tag_ 的串联。
            1. 若 _attribute_ 不是空字符串，则
              1. 令 _V_ 为 ? ToString(_value_)。
              1. 令 _escapedV_ 为与 _V_ 相同的字符串值，除了 _V_ 中每个代码单元 0x0022 (QUOTATION MARK) 被六个代码单元序列 *"&amp;quot;"* 替换。
              1. 将 _p1_ 设为以下串联：
                * _p1_
                * 代码单元 0x0020 (SPACE)
                * _attribute_
                * 代码单元 0x003D (EQUALS SIGN)
                * 代码单元 0x0022 (QUOTATION MARK)
                * _escapedV_
                * 代码单元 0x0022 (QUOTATION MARK)
            1. 令 _p2_ 为 _p1_ 与 *">"* 的串联。
            1. 令 _p3_ 为 _p2_ 与 _S_ 的串联。
            1. 令 _p4_ 为 _p3_、*"&lt;/"*、_tag_ 与 *">"* 的串联。
            1. 返回 _p4_。
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-string.prototype.big">
        <h1>String.prototype.big ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"big"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.blink">
        <h1>String.prototype.blink ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"blink"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.bold">
        <h1>String.prototype.bold ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"b"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fixed">
        <h1>String.prototype.fixed ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"tt"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontcolor">
        <h1>String.prototype.fontcolor ( _colour_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"font"*, *"color"*, _colour_)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontsize">
        <h1>String.prototype.fontsize ( _size_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"font"*, *"size"*, _size_)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.italics">
        <h1>String.prototype.italics ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"i"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.link">
        <h1>String.prototype.link ( _url_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"a"*, *"href"*, _url_)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.small">
        <h1>String.prototype.small ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"small"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.strike">
        <h1>String.prototype.strike ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"strike"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sub">
        <h1>String.prototype.sub ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"sub"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sup">
        <h1>String.prototype.sup ( )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _S_ 为 *this* 值。
          1. 返回 ? CreateHTML(_S_, *"sup"*, *""*, *""*)。
        </emu-alg>
      </emu-annex>

      <emu-annex id="String.prototype.trimleft">
        <h1>String.prototype.trimLeft ( )</h1>
        <emu-note>
          <p>优先使用 *"trimStart"* 属性。*"trimLeft"* 属性主要为兼容旧代码而提供。建议在新的 ECMAScript 代码中使用 *"trimStart"* 属性。</p>
        </emu-note>
        <p>*"trimLeft"* 属性的初始值是 %String.prototype.trimStart%，定义见 <emu-xref href="#sec-string.prototype.trimstart"></emu-xref>。</p>
      </emu-annex>

      <emu-annex id="String.prototype.trimright">
        <h1>String.prototype.trimRight ( )</h1>
        <emu-note>
          <p>优先使用 *"trimEnd"* 属性。*"trimRight"* 属性主要为兼容旧代码而提供。建议在新的 ECMAScript 代码中使用 *"trimEnd"* 属性。</p>
        </emu-note>
        <p>*"trimRight"* 属性的初始值是 %String.prototype.trimEnd%，定义见 <emu-xref href="#sec-string.prototype.trimend"></emu-xref>。</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-date.prototype-object">
      <h1>Date.prototype 对象的额外属性</h1>

      <emu-annex id="sec-date.prototype.getyear">
        <h1>Date.prototype.getYear ( )</h1>
        <emu-note>
          <p>`getFullYear` 方法在几乎所有场景中更可取，因为它避免“2000 年问题”。</p>
        </emu-note>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 若 _t_ 为 *NaN*，返回 *NaN*。
          1. 返回 YearFromTime(LocalTime(_t_)) - *1900*<sub>𝔽</sub>。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.setyear">
        <h1>Date.prototype.setYear ( _year_ )</h1>
        <emu-note>
          <p>`setFullYear` 方法在几乎所有场景中更可取，因为它避免“2000 年问题”。</p>
        </emu-note>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _dateObject_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_dateObject_, [[DateValue]])。
          1. 令 _t_ 为 _dateObject_.[[DateValue]]。
          1. 令 _y_ 为 ? ToNumber(_year_)。
          1. 若 _t_ 为 *NaN*，将 _t_ 设为 *+0*<sub>𝔽</sub>；否则将 _t_ 设为 LocalTime(_t_)。
          1. 令 _yyyy_ 为 MakeFullYear(_y_)。
          1. 令 _d_ 为 MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_))。
          1. 令 _date_ 为 MakeDate(_d_, TimeWithinDay(_t_))。
          1. 令 _u_ 为 TimeClip(UTC(_date_))。
          1. 将 _dateObject_.[[DateValue]] 设为 _u_。
          1. 返回 _u_。
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.togmtstring">
        <h1>Date.prototype.toGMTString ( )</h1>
        <emu-note>
          <p>更推荐使用 `toUTCString` 方法。本方法主要为兼容旧代码而提供。</p>
        </emu-note>
        <p>*"toGMTString"* 属性的初始值是 %Date.prototype.toUTCString%，定义见 <emu-xref href="#sec-date.prototype.toutcstring"></emu-xref>。</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-regexp.prototype-object">
      <h1>RegExp.prototype 对象的额外属性</h1>

      <emu-annex id="sec-regexp.prototype.compile">
        <h1>RegExp.prototype.compile ( _pattern_, _flags_ )</h1>
        <p>该方法被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _O_ 为 *this* 值。
          1. 执行 ? RequireInternalSlot(_O_, [[RegExpMatcher]])。
          1. 若 _pattern_ 是一个对象且具有 [[RegExpMatcher]] 内部槽，则
            1. 若 _flags_ 不为 *undefined*，抛出 *TypeError* 异常。
            1. 令 _P_ 为 _pattern_.[[OriginalSource]]。
            1. 令 _F_ 为 _pattern_.[[OriginalFlags]]。
          1. 否则，
            1. 令 _P_ 为 _pattern_。
            1. 令 _F_ 为 _flags_。
          1. 返回 ? RegExpInitialize(_O_, _P_, _F_)。
        </emu-alg>
        <emu-note>
          <p>该方法使用新的模式与标志完全重新初始化 *this* RegExp。实现可以将使用此方法视为对结果 RegExp 对象将被多次使用的断言，从而可进行额外优化。</p>
        </emu-note>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-other-additional-features">
    <h1>其他附加特性</h1>

    <emu-annex id="sec-labelled-function-declarations">
      <h1>带标签的函数声明</h1>
      <p>在 ECMAScript 2015 之前，|LabelledStatement| 的规范不允许将语句标签与 |FunctionDeclaration| 关联。然而，带标签的 |FunctionDeclaration| 是非严格代码的允许扩展，且多数浏览器宿主 ECMAScript 实现支持该扩展。ECMAScript 2015 及之后，|LabelledStatement| 的语法产生式允许将 |FunctionDeclaration| 用作 |LabelledItem|，但 <emu-xref href="#sec-labelled-statements-static-semantics-early-errors"></emu-xref> 包含的早期错误规则在发生时产生语法错误。然后该规则被修改，在宿主支持该特性的非严格代码中抑制该语法错误。</p>
      <emu-note>
        <p>|WithStatement|、|IfStatement| 与 |IterationStatement| 的早期错误规则阻止它们在非严格代码中包含带标签的 |FunctionDeclaration|。</p>
      </emu-note>
    </emu-annex>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>块级函数声明 Web 历史兼容语义</h1>
      <p>在 ECMAScript 2015 之前，规范未定义 |FunctionDeclaration| 作为 |Block| 语句 |StatementList| 元素的出现。然而，以这种形式的 |FunctionDeclaration| 的支持是允许扩展，多数浏览器宿主实现允许它们。不幸的是，此类声明的语义在这些实现之间有所不同。由于这些语义差异，使用 |Block| 级函数声明的现有网页 ECMAScript 源文本只有在其用法仅依赖所有浏览器实现对该声明语义的交集部分时才是可移植的。以下用例落在该交集语义内：</p>
      <ol>
        <li>
          <p>在单个块内声明并仅在该块内引用函数。</p>
          <ul>
            <li>
              一个或多个 |FunctionDeclaration|，其 |BindingIdentifier| 名称为 _f_，出现在封闭函数 _g_ 的函数代码内，并嵌套在一个 |Block| 中。
            </li>
            <li>
              在 _g_ 的函数代码内不存在其他非 `var` 的 _f_ 声明。
            </li>
            <li>
              所有 _f_ 作为 |IdentifierReference| 的出现均位于包含 _f_ 声明的 |Block| 的 |StatementList| 内。
            </li>
          </ul>
        </li>
        <li>
          <p>在单个 |Block| 中声明函数并可能使用，同时被不在该 |Block| 内的内部函数引用。</p>
          <ul>
            <li>
              一个或多个 |FunctionDeclaration|，其 |BindingIdentifier| 名称为 _f_，出现在封闭函数 _g_ 的函数代码内，且该声明嵌套在一个 |Block| 中。
            </li>
            <li>
              在 _g_ 的函数代码内不存在其他非 `var` 的 _f_ 声明。
            </li>
            <li>
              在包含 _f_ 声明的 |Block| 的 |StatementList| 内可以有 _f_ 作为 |IdentifierReference| 的出现。
            </li>
            <li>
              在嵌套于 _g_ 之内的另一个函数 _h_ 中至少有一次 _f_ 作为 |IdentifierReference| 的出现，且不存在其他 _f_ 声明屏蔽 _h_ 内对 _f_ 的引用。
            </li>
            <li>
              所有对 _h_ 的调用都发生在 _f_ 声明已被求值之后。
            </li>
          </ul>
        </li>
        <li>
          <p>在单个块中声明函数并可能使用，同时也在后续块中被引用。</p>
          <ul>
            <li>
              一个或多个 |FunctionDeclaration|，其 |BindingIdentifier| 名称为 _f_，出现在封闭函数 _g_ 的函数代码内，并嵌套在一个 |Block| 中。
            </li>
            <li>
              在 _g_ 的函数代码内不存在其他非 `var` 的 _f_ 声明。
            </li>
            <li>
              在包含 _f_ 声明的 |Block| 的 |StatementList| 内可以有 _f_ 作为 |IdentifierReference| 的出现。
            </li>
            <li>
              在 _g_ 的函数代码中至少有一次 _f_ 作为 |IdentifierReference| 的出现，其词法位置位于包含 _f_ 声明的 |Block| 之后。
            </li>
          </ul>
        </li>
      </ol>
      <p>第一种用例与 ECMAScript 2015 提供的 |Block| 级函数声明语义可互操作。任何使用该用例的既有 ECMAScript 源文本都将使用 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>、<emu-xref href="#sec-ecmascript-language-statements-and-declarations"></emu-xref> 与 <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref> 章节定义的块级函数声明语义运行。</p>
      <p>第二与第三种用例的 ECMAScript 2015 互操作性需要对 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>、<emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>、<emu-xref href="#sec-eval-x"></emu-xref> 与 <emu-xref href="#sec-globaldeclarationinstantiation"></emu-xref> 章节语义做出以下扩展。</p>
      <p>如果 ECMAScript 实现有报告诊断警告消息的机制，当代码包含应用这些兼容语义并对非兼容语义引入可观察差异的 |FunctionDeclaration| 时应产生警告。例如，如果由于引入会造成早期错误而未引入 var 绑定，则不应产生警告。</p>
      <p>该特性在以下点涉及特殊语义：</p>
      <ul>
        <li><emu-grammar>Block : `{` StatementList `}`</emu-grammar> 于 <emu-xref href="#sec-block-static-semantics-early-errors"></emu-xref> 中的某条早期错误规则</li>
        <li><emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar> 于 <emu-xref href="#sec-switch-statement-static-semantics-early-errors"></emu-xref> 中的某条早期错误规则</li>
        <li>FunctionDeclarationInstantiation 中的步骤 <emu-xref href="#step-functiondeclarationinstantiation-web-compat-insertion-point"></emu-xref></li>
        <li>BlockDeclarationInstantiation 中的步骤 <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref></li>
        <li>BlockDeclarationInstantiation 中的步骤 <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref></li>
        <li>GlobalDeclarationInstantiation 中的步骤 <emu-xref href="#step-globaldeclarationinstantiation-web-compat-insertion-point"></emu-xref></li>
        <li>EvalDeclarationInstantiation 中的步骤 <emu-xref href="#step-evaldeclarationinstantiation-web-compat-insertion-point"></emu-xref></li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-functiondeclarations-in-ifstatement-statement-clauses">
      <h1>IfStatement 语句子句中的 FunctionDeclarations</h1>
      <p>以下内容扩展了 <emu-xref href="#sec-if-statement"></emu-xref> 中的 |IfStatement| 产生式：</p>
      <emu-grammar type="definition">
        IfStatement[Yield, Await, Return] :
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] [lookahead != `else`]
      </emu-grammar>
      <p>该产生式仅在解析非严格代码时适用。被该产生式匹配的源码文本按如下处理：每个匹配出现的 |FunctionDeclaration[?Yield, ?Await, ~Default]| 被视为占据该位置的 |BlockStatement| 的唯一 |StatementListItem|。此类合成 |BlockStatement| 的语义包括 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref> 中规定的网页历史兼容语义。</p>
    </emu-annex>

    <emu-annex id="sec-variablestatements-in-catch-blocks">
      <h1>Catch 块中的 VariableStatements</h1>
      <p>该特性中，|Catch| 子句的 |Block| 可以包含将名称绑定到也由 |CatchParameter| 绑定的名称的 `var` 声明。通过修改 <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar> 于 <emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref> 中的一条早期错误规则实现。</p>
      <emu-note>
        <p>运行时，此类绑定在 VariableDeclarationEnvironment 中实例化。它们不会遮蔽由 |CatchParameter| 引入的同名绑定，因此此类 `var` 声明的 |Initializer| 将赋值给对应的 catch 参数，而非该 `var` 绑定。</p>
      </emu-note>
      <p>该修改行为也适用于包含于 |Catch| 子句 |Block| 内直接 eval 调用引入的 `var` 与 `function` 声明。通过修改 EvalDeclarationInstantiation 中步骤 <emu-xref href="#step-evaldeclarationinstantiation-throw-duplicate-binding"></emu-xref> 与 <emu-xref href="#step-evaldeclarationinstantiation-web-compat-bindingexists"></emu-xref> 实现。</p>
    </emu-annex>

    <emu-annex id="sec-initializers-in-forin-statement-heads">
      <h1>ForIn 语句头中的初始值设定项</h1>
      <p>以下内容扩展了 <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref> 中的 |ForInOfStatement| 产生式：</p>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>
      <p>该产生式仅在解析非严格代码时适用。</p>
      <p><emu-xref href="#sec-static-semantics-containsduplicatelabels"></emu-xref> 中 ContainsDuplicateLabels 的静态语义扩展如下：</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels，参数 _labelSet_。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-containsundefinedbreaktarget"></emu-xref> 中 ContainsUndefinedBreakTarget 的静态语义扩展如下：</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget，参数 _labelSet_。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-containsundefinedcontinuetarget"></emu-xref> 中 ContainsUndefinedContinueTarget 的静态语义扩展如下：</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget，参数 _iterationSet_ 与 « »。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-isdestructuring"></emu-xref> 中 IsDestructuring 的静态语义扩展如下：</p>
      <emu-grammar>
        BindingIdentifier :
          Identifier
          `yield`
          `await`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-vardeclarednames"></emu-xref> 中 VarDeclaredNames 的静态语义扩展如下：</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingIdentifier| 的 BoundNames。
        1. 令 _names2_ 为 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表串联。
      </emu-alg>
      <p><emu-xref href="#sec-static-semantics-varscopeddeclarations"></emu-xref> 中 VarScopedDeclarations 的静态语义扩展如下：</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 « |BindingIdentifier| »。
        1. 令 _declarations2_ 为 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表串联。
      </emu-alg>
      <p><emu-xref href="#sec-runtime-semantics-forinofloopevaluation"></emu-xref> 中 ForInOfLoopEvaluation 的运行时语义扩展如下：</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _lhs_ 为 ? ResolveBinding(_bindingId_)。
        1. 若 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
          1. 令 _value_ 为 ? NamedEvaluation(|Initializer|, 参数 _bindingId_)。
        1. 否则，
          1. 令 _rhs_ 为 ? Evaluation(|Initializer|)。
          1. 令 _value_ 为 ? GetValue(_rhs_)。
        1. 执行 ? PutValue(_lhs_, _value_)。
        1. 令 _keyResult_ 为 ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~)。
        1. 返回 ? ForIn/OfBodyEvaluation(|BindingIdentifier|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_)。
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-IsHTMLDDA-internal-slot">
      <h1>[[IsHTMLDDA]] 内部槽</h1>
      <p>宿主定义对象上可存在一个 <dfn>[[IsHTMLDDA]] internal slot</dfn>。具有 [[IsHTMLDDA]] 内部槽的对象在 <emu-xref href="#sec-toboolean">ToBoolean</emu-xref> 与 IsLooselyEqual 抽象操作中以及作为 <emu-xref href="#sec-typeof-operator">`typeof` 运算符</emu-xref> 操作数时表现得像 *undefined*。</p>
      <emu-note>
        <p>本规范从不创建具有 [[IsHTMLDDA]] 内部槽的对象。然而，网页浏览器中的 <a href="https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all"><code>document.all</code> 对象</a> 是一个带有该槽的宿主定义奇异对象，为网页兼容而存在。没有其它已知示例，实现除 `document.all` 外不应创建任何此类对象。</p>
      </emu-note>
      <p>该特性在以下点涉及特殊语义：</p>
      <ul>
        <li>ToBoolean 中的步骤 <emu-xref href="#step-to-boolean-web-compat-insertion-point"></emu-xref></li>
        <li>IsLooselyEqual 中的步骤 <emu-xref href="#step-abstract-equality-comparison-web-compat-insertion-point"></emu-xref></li>
        <li>`typeof` 求值语义中的步骤 <emu-xref href="#step-typeof-web-compat-insertion-point"></emu-xref></li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-make-job-callback">
      <h1>HostMakeJobCallback 中的非默认行为</h1>
      <p>HostMakeJobCallback 抽象操作允许作为网页浏览器的宿主指定非默认行为。</p>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-ensure-can-add-private-field">
      <h1>HostEnsureCanAddPrivateElement 中的非默认行为</h1>
      <p>HostEnsureCanAddPrivateElement 抽象操作允许作为网页浏览器的宿主指定非默认行为。</p>
    </emu-annex>

    <emu-annex id="sec-runtime-errors-for-function-call-assignment-targets">
      <h1>函数调用赋值目标的运行时错误</h1>
      <p>当函数调用（<emu-xref href="#sec-function-calls"></emu-xref>）在非严格代码中作为赋值目标使用时，不再产生早期错误，而是在赋值求值期间抛出 *ReferenceError* 异常。</p>
      <emu-note>
        <p>当赋值目标是 |AssignmentExpression| 的 |LeftHandSideExpression| 时，赋值运算符必须是 `=` 或一个 |AssignmentOperator|；特别地，此处允许不适用于逻辑赋值运算符（`??=`、`&&=`、`||=`）。</p>
      </emu-note>
      <p>参见 AssignmentTargetType 的步骤 <emu-xref href="#step-assignmenttargettype-web-compat"></emu-xref>，适用于 <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> 与 <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>。</p>
    </emu-annex>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-strict-mode-of-ecmascript">
  <h1>ECMAScript 的严格模式</h1>
  <p><b>严格模式的限制与例外</b></p>
  <ul>
    <li>
      在严格模式代码中，`implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static` 和 `yield` 是保留字（<emu-xref href="#sec-keywords-and-reserved-words"></emu-xref>）。
    </li>
    <li>
      一个符合规范的实现，在处理严格模式代码时，必须禁止出现产生式 <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar> 和 <emu-grammar>DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral</emu-grammar> 的实例。
    </li>
    <li>
      一个符合规范的实现，在处理严格模式代码时，必须禁止出现产生式 <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> 和 <emu-grammar>EscapeSequence :: NonOctalDecimalEscapeSequence</emu-grammar> 的实例。
    </li>
    <li>
      对未声明标识符或其他无法解析引用的赋值不会在全局对象上创建属性。当一个简单赋值发生在严格模式代码中，其 |LeftHandSideExpression| 不能求值为一个不可解析的 Reference，否则会抛出 *ReferenceError* 异常（<emu-xref href="#sec-putvalue"></emu-xref>）。|LeftHandSideExpression| 也不能是具有属性值 { [[Writable]]: *false* } 的数据属性、具有属性值 { [[Set]]: *undefined* } 的访问器属性，或 [[Extensible]] 内部槽为 *false* 的对象上不存在的属性。在这些情况下会抛出 `TypeError` 异常（<emu-xref href="#sec-assignment-operators"></emu-xref>）。
    </li>
    <li>
      StringValue 为 *"eval"* 或 *"arguments"* 的 |IdentifierReference| 不能作为赋值运算符（<emu-xref href="#sec-assignment-operators"></emu-xref>）的 |LeftHandSideExpression|，也不能作为 |UpdateExpression|（<emu-xref href="#sec-update-expressions"></emu-xref>），亦或作为前缀自增（<emu-xref href="#sec-prefix-increment-operator"></emu-xref>）或前缀自减（<emu-xref href="#sec-prefix-decrement-operator"></emu-xref>）运算符所操作的 |UnaryExpression|。
    </li>
    <li>
      严格函数的 Arguments 对象定义一个不可配置的访问器属性 *"callee"*，访问时抛出 *TypeError* 异常（<emu-xref href="#sec-createunmappedargumentsobject"></emu-xref>）。
    </li>
    <li>
      严格函数的 Arguments 对象不会与其函数对应形式参数绑定动态共享其 <emu-xref href="#array-index">按数组索引</emu-xref> 的属性值（<emu-xref href="#sec-arguments-exotic-objects"></emu-xref>）。
    </li>
    <li>
      对于严格函数，如果创建了 arguments 对象，则局部标识符 `arguments` 到该 arguments 对象的绑定是不可变的，因此不能作为赋值表达式的目标（<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>）。
    </li>
    <li>
      如果在严格模式代码中，一个 |BindingIdentifier| 的 StringValue 是 *"eval"* 或 *"arguments"*，则为 *SyntaxError*（<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>）。
    </li>
    <li>
      严格模式的 eval 代码不能在调用者的变量环境中实例化变量或函数。相反，会创建一个新的变量环境，并使用该环境为 eval 代码进行声明绑定实例化（<emu-xref href="#sec-eval-x"></emu-xref>）。
    </li>
    <li>
      如果在严格模式代码中对 *this* 求值，则该 *this* 值不会被强制转换为对象。*this* 值为 *undefined* 或 *null* 时不会被转换为全局对象，原始值不会被转换为包装对象。通过函数调用（包括使用 `Function.prototype.apply` 和 `Function.prototype.call` 进行的调用）传入的 *this* 值不会被强制转换为对象（<emu-xref href="#sec-ordinarycallbindthis"></emu-xref>, <emu-xref href="#sec-function.prototype.apply"></emu-xref>, <emu-xref href="#sec-function.prototype.call"></emu-xref>）。
    </li>
    <li>
      当 `delete` 运算符出现在严格模式代码中，如果其 |UnaryExpression| 是对变量、函数参数或函数名的直接引用，则抛出 *SyntaxError*（<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>）。
    </li>
    <li>
      当 `delete` 运算符出现在严格模式代码中，如果要删除的属性具有属性 { [[Configurable]]: *false* } 或无法被删除，则抛出 *TypeError*（<emu-xref href="#sec-delete-operator-runtime-semantics-evaluation"></emu-xref>）。
    </li>
    <li>
      严格模式代码中不能包含 |WithStatement|。在该上下文出现 |WithStatement| 是 *SyntaxError*（<emu-xref href="#sec-with-statement-static-semantics-early-errors"></emu-xref>）。
    </li>
    <li>
      如果在严格模式代码中出现 |CatchParameter| 且其 BoundNames 包含 `eval` 或 `arguments`，则为 *SyntaxError*（<emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>）。
    </li>
    <li>
      如果同一个 |BindingIdentifier| 在严格函数的 |FormalParameters| 中出现多次，则为 *SyntaxError*。尝试使用 Function、Generator 或 AsyncFunction 构造函数创建这样的函数会是 *SyntaxError*（<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-createdynamicfunction"></emu-xref>）。
    </li>
    <li>
      实现不得超出本规范定义的范围，扩展严格函数中函数实例名为 *"caller"* 或 *"arguments"* 的属性含义。
    </li>
  </ul>
</emu-annex>

<emu-annex id="sec-host-layering-points">
  <h1>宿主分层点</h1>
  <p>宿主的定义见 <emu-xref href="#sec-hosts-and-implementations"></emu-xref>。</p>

  <emu-annex id="sec-host-hooks-summary">
    <h1>宿主钩子</h1>
    <p><b>HostCallJobCallback(...)</b></p>
    <p><b>HostEnqueueFinalizationRegistryCleanupJob(...)</b></p>
    <p><b>HostEnqueueGenericJob(...)</b></p>
    <p><b>HostEnqueuePromiseJob(...)</b></p>
    <p><b>HostEnqueueTimeoutJob(...)</b></p>
    <p><b>HostEnsureCanCompileStrings(...)</b></p>
    <p><b>HostFinalizeImportMeta(...)</b></p>
    <p><b>HostGetImportMetaProperties(...)</b></p>
    <p><b>HostGrowSharedArrayBuffer(...)</b></p>
    <p><b>HostHasSourceTextAvailable(...)</b></p>
    <p><b>HostLoadImportedModule(...)</b></p>
    <p><b>HostGetSupportedImportAttributes(...)</b></p>
    <p><b>HostMakeJobCallback(...)</b></p>
    <p><b>HostPromiseRejectionTracker(...)</b></p>
    <p><b>HostResizeArrayBuffer(...)</b></p>
    <p><b>InitializeHostDefinedRealm(...)</b></p>
  </emu-annex>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>宿主定义字段</h1>
    <p>Realm Record 上的 [[HostDefined]]：见 <emu-xref href="#table-realm-record-fields"></emu-xref>。</p>
    <p>Script Record 上的 [[HostDefined]]：见 <emu-xref href="#table-script-records"></emu-xref>。</p>
    <p>Module Record 上的 [[HostDefined]]：见 <emu-xref href="#table-module-record-fields"></emu-xref>。</p>
    <p>JobCallback Record 上的 [[HostDefined]]：见 <emu-xref href="#table-jobcallback-records"></emu-xref>。</p>
    <p>Candidate Executions 上的 [[HostSynchronizesWith]]：见 <emu-xref href="#table-candidate-execution-records"></emu-xref>。</p>
    <p>[[IsHTMLDDA]]：见 <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref>。</p>
  </emu-annex>

  <emu-annex id="sec-host-defined-objects-summary">
    <h1>宿主定义对象</h1>
    <p>全局对象：见 <emu-xref href="#sec-global-object"></emu-xref>。</p>
  </emu-annex>

  <emu-annex id="sec-host-running-jobs">
    <h1>运行作业</h1>
    <p>调用作业抽象闭包前的准备步骤与之后的清理步骤。见 <emu-xref href="#sec-jobs"></emu-xref>。</p>
  </emu-annex>

  <emu-annex id="sec-host-internal-methods-of-exotic-objects">
    <h1>奇异对象的内部方法</h1>
    <p>本规范中未指定的任意奇异对象在 <emu-xref href="#table-essential-internal-methods"></emu-xref> 中的任何基本内部方法。</p>
  </emu-annex>

  <emu-annex id="sec-host-built-in-objects-and-methods">
    <h1>内建对象与方法</h1>
    <p>任何本规范未定义的内建对象与方法，除非在 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 中受到限制。</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact">
  <h1>ECMAScript 2015 中的更正与澄清（可能的兼容性影响）</h1>
  <p><emu-xref href="#sec-candeclareglobalvar"></emu-xref>-<emu-xref href="#sec-createglobalfunctionbinding"></emu-xref>：第 5 与 5.1 版使用属性存在性测试来判断与新全局声明对应的全局对象属性是否已存在。ECMAScript 2015 使用自有属性存在性测试。这与多数浏览器实现最常见的行为一致。</p>
  <p><emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>：第 5 版将捕获当前数组长度的操作移至数组索引或新长度值进行整数转换之前。然而，如果转换过程有改变数组长度的副作用，捕获的长度可能失效。ECMAScript 2015 规定当前数组长度必须在此类副作用可能发生之后捕获。</p>
  <p><emu-xref href="#sec-timeclip"></emu-xref>：之前的版本允许 TimeClip 抽象操作返回 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub> 作为 0 时间值的表示。ECMAScript 2015 规定始终返回 *+0*<sub>𝔽</sub>。这意味着在 ECMAScript 2015 中 Date 的时间值不会可观察到 *-0*<sub>𝔽</sub>，返回时间值的方法也不会返回 *-0*<sub>𝔽</sub>。</p>
  <p><emu-xref href="#sec-date-time-string-format"></emu-xref>：如果不存在 UTC 偏移表示，则使用本地时区。第 5.1 版错误地说缺失的时区应解释为 *"z"*。</p>
  <p><emu-xref href="#sec-date.prototype.toisostring"></emu-xref>：若年份无法用 <emu-xref href="#sec-date-time-string-format"></emu-xref> 指定的日期时间字符串格式表示，则抛出 RangeError。之前版本未指定该情况的行为。</p>
  <p><emu-xref href="#sec-date.prototype.tostring"></emu-xref>：之前版本未指定当时间值为 *NaN* 时 `Date.prototype.toString` 返回的值。ECMAScript 2015 规定结果为字符串 *"Invalid Date"*。</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>, <emu-xref href="#sec-escaperegexppattern"></emu-xref>：RegExp 实例 *"source"* 属性值中的任何 LineTerminator 代码点必须使用转义序列表示。第 5.1 版仅要求转义 `/`。</p>
  <p><emu-xref href="#sec-regexp.prototype-%symbol.match%"></emu-xref>, <emu-xref href="#sec-regexp.prototype-%symbol.replace%"></emu-xref>：在之前版本中，`String.prototype.match` 与 `String.prototype.replace` 对于 pattern 参数为设置了 `global` 标志的 RegExp 值的情况的规范不正确。旧规范指出每次尝试匹配模式时，如果 `lastIndex` 未改变，则应加 1。正确行为是只有当模式匹配到空字符串时才加 1。</p>
  <p><emu-xref href="#sec-array.prototype.sort"></emu-xref>：之前版本未指定 `Array.prototype.sort` 如何解释由 _comparator_ 返回的 *NaN* 值。ECMAScript 2015 规定此类值视为 _comparator_ 返回 *+0*<sub>𝔽</sub>。还规定对 _comparator_ 返回的结果应用 ToNumber。之前版本对结果非 Number 的情况是实现自定。实践中实现会调用 ToNumber。</p>
</emu-annex>

<emu-annex id="sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions">
  <h1>引入与先前版本不兼容的新增与变更</h1>
  <p><emu-xref href="#sec-reference-record-specification-type"></emu-xref>：在 ECMAScript 2015 中，函数调用不允许返回一个 Reference Record。</p>
  <p><emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>：在 ECMAScript 2015 中，对字符串值执行 ToNumber 现在识别并转换 |BinaryIntegerLiteral| 和 |OctalIntegerLiteral| 数字字符串。之前版本转换为 *NaN*。</p>
  <p><emu-xref href="#sec-code-realms"></emu-xref>：在 ECMAScript 2018 中，模板对象按 Parse Node（源位置）规范化，而不是如之前版本那样在 Realm 中该模板字面量或标记模板的所有出现之间。</p>
  <p><emu-xref href="#sec-white-space"></emu-xref>：在 ECMAScript 2016 中，要求 Unicode 8.0.0 或更高，而 ECMAScript 2015 要求 Unicode 5.1。特别地，这导致 U+180E 蒙古元音分隔符从 `Space_Separator` (`Zs`) 类别（因此在 ECMAScript 2015 中视为空白）移动到 `Format` (`Cf`) 类别（自 Unicode 6.3.0 起）。这导致对空白敏感的方法表现不同。例如，之前版本 `"\u180E".trim().length` 为 `0`，在 ECMAScript 2016 及后为 `1`。此外，ECMAScript 2017 要求始终使用最新 Unicode 标准。</p>
  <p><emu-xref href="#sec-names-and-keywords"></emu-xref>：在 ECMAScript 2015 中，|IdentifierName| 的有效代码点以 Unicode 属性 “ID_Start” 与 “ID_Continue” 表述。之前版本通过列举各种 Unicode 代码点类别指定有效的 |IdentifierName| 或 |Identifier| 代码点。</p>
  <p><emu-xref href="#sec-rules-of-automatic-semicolon-insertion"></emu-xref>：在 ECMAScript 2015 中，自动分号插入会在缺少分号的 do-while 语句末尾添加分号。该变更使规范与现有多数实现的实际行为一致。</p>
  <p><emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>：在 ECMAScript 2015 中，对象初始值设定中出现重复属性名不再是早期错误。</p>
  <p><emu-xref href="#sec-assignment-operators-static-semantics-early-errors"></emu-xref>：在 ECMAScript 2015 中，严格模式代码中对不可变绑定（如 |FunctionExpression| 的函数名）的赋值不再产生早期错误，而是产生运行时错误。</p>
  <p><emu-xref href="#sec-block"></emu-xref>：在 ECMAScript 2015 中，以 token let 开头，后跟输入元素 |LineTerminator| 再跟 |Identifier| 的 |StatementList| 是一个 |LexicalDeclaration| 的起始。之前版本中自动分号插入会在该 |Identifier| 输入元素前插入分号。</p>
  <p><emu-xref href="#sec-expression-statement"></emu-xref>：在 ECMAScript 2015 中，以 token `let` 开头后跟 token `[` 的 |StatementListItem| 是 |LexicalDeclaration| 的起始。之前版本该序列会是 |ExpressionStatement| 的起始。</p>
  <p><emu-xref href="#sec-if-statement-runtime-semantics-evaluation"></emu-xref>：在 ECMAScript 2015 中，|IfStatement| 的正常结果不再是值 ~empty~。如果没有求值任何 |Statement| 部分或求值的 |Statement| 部分产生包含 ~empty~ 的正常完成，则结果为 *undefined*。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>：在 ECMAScript 2015 中，如果 for 语句的 `(` token 紧跟 token 序列 `let [` 则 `let` 视为 |LexicalDeclaration| 的起始。之前版本该序列是 |Expression| 的起始。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>：在 ECMAScript 2015 中，如果 for-in 语句的 ( token 紧跟 token 序列 `let [` 则 `let` 视为 |ForDeclaration| 的起始。之前版本该序列是 |LeftHandSideExpression| 的起始。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>：在 ECMAScript 2015 之前，初始化表达式可出现在紧接 `in` 关键字之前的 |VariableDeclaration| 中。ECMAScript 2015 中相同位置的 |ForBinding| 不允许此初始化器出现。ECMAScript 2017 中，此初始化器仅在非严格代码中允许。</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>：在 ECMAScript 2015 中，对 |IterationStatement| 的求值结果不再是 [[Value]] 为 ~empty~ 的正常完成。若其 |Statement| 部分未被求值或最终求值结果为 [[Value]] 为 ~empty~ 的正常完成，则结果为 [[Value]] 为 *undefined* 的正常完成。</p>
  <p><emu-xref href="#sec-with-statement-runtime-semantics-evaluation"></emu-xref>：在 ECMAScript 2015 中，对 |WithStatement| 的求值结果不再是 [[Value]] 为 ~empty~ 的正常完成。若其 |Statement| 部分求值产生 [[Value]] 为 ~empty~ 的正常完成，结果为 [[Value]] 为 *undefined* 的正常完成。</p>
  <p><emu-xref href="#sec-switch-statement-runtime-semantics-evaluation"></emu-xref>：在 ECMAScript 2015 中，对 |SwitchStatement| 的求值结果不再是 [[Value]] 为 ~empty~ 的正常完成。若其 |CaseBlock| 部分求值产生 [[Value]] 为 ~empty~ 的正常完成，结果为 [[Value]] 为 *undefined* 的正常完成。</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>：在 ECMAScript 2015 中，|Catch| 子句包含与其参数相同 |Identifier| 的 `var` 声明是早期错误。之前版本该变量声明会在外层变量环境中实例化，但声明的 |Initializer| 值会赋给 |Catch| 参数。</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>, <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref>：在 ECMAScript 2015 中，如果 |Catch| 子句求值一个非严格直接 `eval` 且其 eval 代码包含绑定与 |Catch| 参数同名的 `var` 或 `FunctionDeclaration` 声明，则抛出运行时 *SyntaxError*。</p>
  <p><emu-xref href="#sec-try-statement-runtime-semantics-evaluation"></emu-xref>：在 ECMAScript 2015 中，|TryStatement| 的结果不再是值 ~empty~。如果其 |Block| 部分求值为包含 ~empty~ 的正常完成，则结果为 *undefined*。如果 |Block| 部分求值为抛出完成，且其 |Catch| 部分求值为包含 ~empty~ 的正常完成，在没有 |Finally| 子句或 |Finally| 子句求值为 ~empty~ 正常完成时结果为 *undefined*。</p>
  <p><emu-xref href="#sec-runtime-semantics-methoddefinitionevaluation"></emu-xref>：在 ECMAScript 2015 中，作为 |ObjectLiteral| 中访问器属性 [[Get]] 或 [[Set]] 属性值创建的函数对象不是构造函数，也没有 *"prototype"* 自有属性。之前版本它们是构造函数并有 *"prototype"* 属性。</p>
  <p><emu-xref href="#sec-object.freeze"></emu-xref>：在 ECMAScript 2015 中，如果传给 `Object.freeze` 的参数不是对象，按无自有属性的不可扩展普通对象处理。之前版本非对象参数总是抛出 *TypeError*。</p>
  <p><emu-xref href="#sec-object.getownpropertydescriptor"></emu-xref>：在 ECMAScript 2015 中，如果传给 `Object.getOwnPropertyDescriptor` 的参数不是对象，尝试用 ToObject 强制转换，成功则使用结果替代原参数。之前版本非对象参数总是抛出 *TypeError*。</p>
  <p><emu-xref href="#sec-object.getownpropertynames"></emu-xref>：同上。</p>
  <p><emu-xref href="#sec-object.getprototypeof"></emu-xref>：同上。</p>
  <p><emu-xref href="#sec-object.isextensible"></emu-xref>：在 ECMAScript 2015 中，非对象参数按无自有属性的不可扩展普通对象处理。之前版本抛出 *TypeError*。</p>
  <p><emu-xref href="#sec-object.isfrozen"></emu-xref>：同上。</p>
  <p><emu-xref href="#sec-object.issealed"></emu-xref>：同上。</p>
  <p><emu-xref href="#sec-object.keys"></emu-xref>：在 ECMAScript 2015 中，非对象参数尝试 ToObject 成功则使用结果。之前版本抛出 *TypeError*。</p>
  <p><emu-xref href="#sec-object.preventextensions"></emu-xref>：非对象参数按不可扩展空对象处理。之前版本抛出 *TypeError*。</p>
  <p><emu-xref href="#sec-object.seal"></emu-xref>：同上。</p>
  <p><emu-xref href="#sec-function.prototype.bind"></emu-xref>：在 ECMAScript 2015 中，绑定函数的 [[Prototype]] 内部槽设为其目标函数的 [[GetPrototypeOf]] 值。之前版本始终设为 %Function.prototype%。</p>
  <p><emu-xref href="#sec-function-instances-length"></emu-xref>：在 ECMAScript 2015 中，函数实例的 *"length"* 属性是可配置的。之前版本不可配置。</p>
  <p><emu-xref href="#sec-properties-of-the-nativeerror-constructors"></emu-xref>：在 ECMAScript 2015 中，_NativeError_ 构造函数的 [[Prototype]] 内部槽是 Error 构造函数。之前版本是 Function 原型对象。</p>
  <p><emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref>：在 ECMAScript 2015 中，Date 原型对象不是 Date 实例。之前版本它是 TimeValue 为 *NaN* 的 Date 实例。</p>
  <p><emu-xref href="#sec-string.prototype.localecompare"></emu-xref>：在 ECMAScript 2015 中，`String.prototype.localeCompare` 必须将 Unicode 标准下规范等价的字符串视为相同。之前版本允许忽略规范等价，使用按位比较。</p>
  <p><emu-xref href="#sec-string.prototype.tolowercase"></emu-xref> 与 <emu-xref href="#sec-string.prototype.touppercase"></emu-xref>：在 ECMAScript 2015 中，大小写转换处理基于代码点。之前版本仅对单个代码单元。受影响的代码点仅在 Deseret 区块。</p>
  <p><emu-xref href="#sec-string.prototype.trim"></emu-xref>：在 ECMAScript 2015 中，`String.prototype.trim` 识别可能存在于 Unicode BMP 之外的空白代码点。然而截至 Unicode 7 尚无此类代码点。之前版本这些代码点不会被识别为空白。</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>：在 ECMAScript 2015 中，如果 _pattern_ 参数是 RegExp 实例且 _flags_ 参数不为 *undefined*，则创建一个新 RegExp，其模式与 _pattern_ 相同但标志为 _flags_。之前版本当 _pattern_ 为 RegExp 且 _flags_ 非 *undefined* 时抛出 *TypeError*。</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref>：在 ECMAScript 2015 中，RegExp 原型对象不是 RegExp 实例。之前版本它是模式为空字符串的 RegExp 实例。</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref>：在 ECMAScript 2015 中，*"source"*、*"global"*、*"ignoreCase"* 与 *"multiline"* 是定义在 RegExp 原型对象上的访问器属性。之前版本它们是定义在 RegExp 实例上的数据属性。</p>
  <p><emu-xref href="#sec-atomics.notify"></emu-xref>：在 ECMAScript 2019 中，`Atomics.wake` 重命名为 `Atomics.notify` 以避免与 `Atomics.wait` 混淆。</p>
  <p><emu-xref href="#sec-asyncfromsynciteratorcontinuation"></emu-xref>, <emu-xref href="#sec-asyncgeneratorresume"></emu-xref>：在 ECMAScript 2019 中，`await` 入队的作业数量减少，可能在 `then()` 调用与 `await` 表达式之间创建可观察到的解析顺序差异。</p>
</emu-annex>

<emu-annex id="sec-bibliography" back-matter>
  <h1>参考文献</h1>
  <ol>
    <li>
      <dfn>IEEE 754-2019</dfn>：<i>IEEE Standard for Floating-Point Arithmetic</i>。电气与电子工程师协会，纽约（2019）
      <emu-note>
        <p>IEEE 754-2008 与 IEEE 754-2019 之间没有影响 ECMA-262 规范的规范性变更。</p>
      </emu-note>
    </li>
    <li>
      <i>The Unicode Standard</i>，可访问 &lt;<a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>>
    </li>
    <li>
      <i>Unicode Technical Note #5: Canonical Equivalence in Applications</i>，可访问 &lt;<a href="https://unicode.org/notes/tn5/">https://unicode.org/notes/tn5/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #10: Unicode Collation Algorithm</i>，可访问 &lt;<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #15, Unicode Normalization Forms</i>，可访问 &lt;<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #18: Unicode Regular Expressions</i>，可访问 &lt;<a href="https://unicode.org/reports/tr18/">https://unicode.org/reports/tr18/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #24: Unicode `Script` Property</i>，可访问 &lt;<a href="https://unicode.org/reports/tr24/">https://unicode.org/reports/tr24/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax</i>，可访问 &lt;<a href="https://unicode.org/reports/tr31/">https://unicode.org/reports/tr31/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #44: Unicode Character Database</i>，可访问 &lt;<a href="https://unicode.org/reports/tr44/">https://unicode.org/reports/tr44/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #51: Unicode Emoji</i>，可访问 &lt;<a href="https://unicode.org/reports/tr51/">https://unicode.org/reports/tr51/</a>>
    </li>
    <li>
      <i>IANA Time Zone Database</i>，可访问 &lt;<a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>>
    </li>
    <li>
      ISO 8601:2004(E) <i>Data elements and interchange formats — Information interchange — Representation of dates and times</i>
    </li>
    <li>
      <i>RFC 1738 “Uniform Resource Locators (URL)”</i>，可访问 &lt;<a href="https://tools.ietf.org/html/rfc1738">https://tools.ietf.org/html/rfc1738</a>>
    </li>
    <li>
      <i>RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”</i>，可访问 &lt;<a href="https://tools.ietf.org/html/rfc2396">https://tools.ietf.org/html/rfc2396</a>>
    </li>
    <li>
      <i>RFC 3629 “UTF-8, a transformation format of ISO 10646”</i>，可访问 &lt;<a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>>
    </li>
    <li>
      <i>RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”</i>，可访问 &lt;<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>>
    </li>
  </ol>
</emu-annex>

<emu-annex id="sec-colophon" back-matter>
  <h1>版本后记</h1>
  <p>本规范在 <a href="https://github.com/tc39/ecma262">GitHub</a> 上以一种称为 <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a> 的纯文本源格式编写。Ecmarkup 是一种 HTML 与 Markdown 方言，提供框架与工具集，用于以纯文本编写 Ecma 规范，并将其处理为遵循本文档编辑惯例的全功能 HTML 呈现。Ecmarkup 构建并集成了多种其他格式与技术，包括用于定义语法的 <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a> 与用于编写算法步骤的 <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a>。本规范的 PDF 呈现使用一个打印样式表生成，该样式表利用 CSS 分页媒体规范，并使用 <a href="https://www.princexml.com/">PrinceXML</a> 转换。</p>
  <p>之前版本的本规范使用 Word 编写——构成本版本基础的 Ecmarkup 源文本是通过自动转换工具将 ECMAScript 2015 的 Word 文档转换为 Ecmarkup 生成的。</p>
</emu-annex>
