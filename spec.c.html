<!DOCTYPE html>
<html lang="zh-hans">
<meta charset="utf-8">
<link rel="icon" href="img/favicon.ico">
<style>
  .unicode-property-table {
    table-layout: fixed;
    width: 100%;
    font-size: 80%;
  }

  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }

  #ecma-logo {
    width: 500px;
  }

  .corner-cell {
    position: relative;
    height: 2lh;
  }
  .corner-cell .slash {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom left, transparent calc(50% - 1px), gray, transparent calc(50% + 1px));
  }
  .corner-cell > .column {
    position: absolute;
    bottom: 0.4em;
    left: 1em;
  }
  .corner-cell > .row {
    position: absolute;
    top: 0.4em;
    right: 1em;
  }
</style>
<style media="print">
  /**
  * ECMA-262-specific hacks. Shouldn't require a ton of maintenance; audit if
  * visual inspection results in unexpected page breaks.
  *
  * For print version, the table captioned "Module fields after the initial Evaluate() call" _may_ need to set the row
  * EVALUATING-ASYNC to one cell with a colspan of 5. It typically does not fit on the page, but the cell merging is
  * not a perfectly accurate solution and will not be merged back in to the specification.
  * See https://github.com/tc39/ecma262/pull/3623#issuecomment-3029366960
  */

  /* Make sure tables are wide enough for their captions */
  table {
    min-width: 135mm;
  }

  /* 2.2 Examples of legacy/normative-optional are small enough to be aggressive against breaks */
  #sec-conformance [example],
  /* 16.2.1.xxx many tables */
  #sec-example-cyclic-module-record-graphs table {
    break-inside: avoid-page;
  }

  /* 12.10.1 long note can break wherever it wants */
  #sec-rules-of-automatic-semicolon-insertion > emu-note {
    break-before: initial;
    break-inside: initial;
  }

  /* 12.10.X Sections start with an <em> not inside a <p> */
  #sec-examples-of-automatic-semicolon-insertion > em,
  #sec-interesting-cases-of-automatic-semicolon-insertion > em,
  #sec-asi-cases-with-no-lineterminator-here > em {
    display: block;
    margin-top: 1.25ex;
  }

  /* 15.1.X missing spacing between intro and first emu-grammar */
  #sec-static-semantics-containsexpression > emu-grammar:first-of-type {
    margin-top: 2ex;
  }

  /* 15.3 A very long term combined with inline-block, nowrap, and justified text resulting in weird punctuation */
  #sec-arrow-function-definitions > p > emu-grammar {
    text-align: left;
  }

  /* 20.X legacy title */
  #sec-object\.prototype\.__proto__ > .attributes-tag {
    break-before: avoid-page;
    break-after: avoid-page;
  }

  /* 21.X table middle column is too narrow */
  #table-time-zone-identifier-record-fields > figure > table th:nth-of-type(2) {
    min-width: 19mm;
  }

  /* 29.X extremely long note */
  #sec-shared-memory-guidelines > emu-note {
    break-inside: auto;
  }

  .unicode-property-table {
    table-layout: initial;
    width: auto;
    font-size: 90%;
  }

  .unicode-property-table th:first-of-type {
    width: 33%;
  }

  .corner-cell {
    background-image: url(data:image/svg+xml;base64,PHN2ZyBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaGVpZ2h0PSI0NiIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEuNSIgd2lkdGg9IjI0MiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtMzE1LjI2NiAzOTYuMzQzIDI0MS4zOTQgNDUuMTU1IiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS4wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMxNC45MyAtMzk1LjkzNSkiLz48L3N2Zz4=);
    background-repeat: no-repeat;
    background-size: 100% 3em;
    height: 3em;
    padding: 0;
    vertical-align: inherit;
    position: static;
  }

  .corner-cell .slash {
    display: none;
  }

  .corner-cell > .column, .corner-cell > .row {
    display: block;
    position: relative;
  }

  .corner-cell > .row {
    text-align: right;
    top: -0.75em
  }

  .corner-cell > .column {
    text-align: left;
    bottom: -1.25em;
  }
</style>
<pre class="metadata">
  title: ECMAScript<sup>&reg;</sup> 2026 语言规范
  shortname: ECMA-262
  status: draft
  location: https://tc39.es/ecma262/
  markEffects: true
</pre>
<p><img src="img/ecma-logo.svg" id="ecma-logo" alt="Ecma International 标志"></p>
<div id="metadata-block">
  <h1>关于本规范</h1>
  <p>位于 <a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a> 的文档是最准确且最新的 ECMAScript 规范。它包含了最近年度快照的内容，以及自该快照以来所有已完成的 <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md">提案</a>（即已在 <a href="https://tc39.es/process-document/">提案流程</a>中达到第 4 阶段，并且已在多个实现中落地、将在下一次实际修订中包含的提案）。</p>
  <p>本文件可作为<a href>单页</a>或<a href="multipage/">多页</a>形式获取。</p>
  <h1>如何参与规范制定</h1>
  <p>本规范在 GitHub 上由 ECMAScript 社区协作开发。您可以通过以下几种方式参与本规范的制定：</p>
  <ul>
    <li>GitHub 仓库：<a href="https://github.com/tc39/ecma262">https://github.com/tc39/ecma262</a></li>
    <li>问题反馈：<a href="https://github.com/tc39/ecma262/issues">所有问题</a>，<a href="https://github.com/tc39/ecma262/issues/new">提交新问题</a></li>
    <li>拉取请求：<a href="https://github.com/tc39/ecma262/pulls">所有拉取请求</a>，<a href="https://github.com/tc39/ecma262/pulls/new">创建新拉取请求</a></li>
    <li>测试套件：<a href="https://github.com/tc39/test262">Test262</a></li>
    <li>
      编辑：
      <ul>
        <li><a href="mailto:shu at rfrn dot org">Shu-yu Guo</a></li>
        <li><a href="mailto:ecma262-editor-list at michael dot ficarra dot me">Michael Ficarra</a> (<a href="https://bsky.app/profile/michael.ficarra.me">@michael.ficarra.me</a>)</li>
        <li><a href="mailto:bakkot at gmail dot com">Kevin Gibbons</a></li>
      </ul>
    </li>
    <li>
      社区：
      <ul>
        <li>Discourse: <a href="https://es.discourse.group">https://es.discourse.group/</a></li>
        <li>聊天：<a href="https://github.com/tc39/how-we-work/blob/HEAD/matrix-guide.md">Matrix</a></li>
        <li>邮件<emu-not-ref>列表</emu-not-ref>存档：<a href="https://esdiscuss.org">https://esdiscuss.org/</a></li>
      </ul>
    </li>
  </ul>
  <p>更多关于本文件创建方式的信息请参阅 <emu-xref href="#sec-colophon">colophon</emu-xref>。</p>
</div>

<emu-intro id="sec-intro">
  <h1>简介</h1>
  <p>本 Ecma 标准定义了 ECMAScript 2026 语言，这是 ECMAScript 语言规范的第十七版。自1997年第一版发布以来，ECMAScript已发展为全球使用最广泛的通用编程语言之一。它最著名的应用是在网页浏览器中嵌入的语言，但也在服务器和嵌入式应用中被广泛采用。</p>
  <p>ECMAScript 基于多种起源技术，其中最知名的是 JavaScript（Netscape）和 JScript（Microsoft）。该语言由 Brendan Eich 在 Netscape 发明，并首次出现在该公司 Navigator 2.0 浏览器中。随后，Netscape 的所有浏览器以及 Microsoft 从 Internet Explorer 3.0 起的所有浏览器均支持该语言。</p>
  <p>ECMAScript 语言规范的开发始于 1996 年 11 月。该 Ecma 标准的第一版由 Ecma 大会在 1997 年 6 月通过。</p>
  <p>该 Ecma 标准按快速通道程序提交至 ISO/IEC JTC 1，并于 1998 年 4 月获批为国际标准 ISO/IEC 16262。Ecma 大会于 1998 年 6 月批准了 ECMA-262 的第二版，以确保其与 ISO/IEC 16262 完全一致。第一版与第二版之间的更改仅为编辑性质。</p>
  <p>标准的第三版引入了强大的正则表达式、更好的字符串处理、新的控制语句、try/catch 异常处理、更严格的错误定义、数字输出格式，以及为未来语言发展做出的细微调整。第三版由 Ecma 大会于 1999 年 12 月通过，并作为 ISO/IEC 16262:2002 于 2002 年 6 月发布。</p>
  <p>第三版发布后，ECMAScript 在万维网环境下得到广泛采用，成为几乎所有浏览器支持的编程语言。曾有大量工作投入到 ECMAScript 第四版的开发中，但该工作最终未完成并未以第四版发布，部分内容被融入到第六版的开发中。</p>
  <p>ECMAScript 第五版（作为 ECMA-262 第 5 版发布）规范化了已成为浏览器实现间通用的语言解释方式，并加入了自第三版发布以来出现的新特性。这些特性包括访问器属性、对象的反射创建与检查、属性特性程序控制、更多数组操作函数、对 JSON 对象编码格式的支持，以及增强错误检查和程序安全性的严格模式。第五版由 Ecma 大会于 2009 年 12 月通过。</p>
  <p>第五版按快速通道程序提交至 ISO/IEC JTC 1，并获批为国际标准 ISO/IEC 16262:2011。ECMAScript 标准第 5.1 版包含了细微修正，与 ISO/IEC 16262:2011 的文本一致。5.1 版由 Ecma 大会于 2011 年 6 月通过。</p>
  <p>第六版的集中开发始于 2009 年，在第五版准备发布期间。但在此之前，自 1999 年第三版发布起，已进行了大量实验和语言增强设计。实际上，第六版的完成是十五年努力的结晶。本版目标包括更好地支持大型应用、库创建，以及将 ECMAScript 作为其他语言编译目标。主要增强包括模块、类声明、词法块作用域、迭代器和生成器、异步编程的 Promise、解构模式和尾调用优化。内置库扩展以支持更多数据抽象，如 Map、Set 和二进制数值数组，并进一步支持字符串和正则表达式中的 Unicode 补充字符。内置对象也可以通过子类化进行扩展。第六版为语言和库的常规、增量性增强奠定了基础。第六版由 2015 年 6 月的大会通过。</p>
  <p>ECMAScript 2016 是 Ecma TC39 新的年度发布节奏和开放开发流程下发布的首个 ECMAScript 版本。基础文档由 ECMAScript 2015 的源文档转换成纯文本格式，并在 GitHub 上持续开发。在本标准开发期间，提交了数百个拉取请求和问题，修复了数千个错误、编辑问题和其他改进。此外，开发了许多软件工具以支持此过程，包括 Ecmarkup、Ecmarkdown 和 Grammarkdown。ES2016 还新增了指数运算符和 `Array.prototype` 的 `includes` 方法。</p>
  <p>ECMAScript 2017 引入了异步函数、共享内存和原子操作，以及多项语言和库的增强、错误修复和编辑更新。异步函数通过提供 Promise 返回函数的语法改善了异步编程体验。共享内存和原子操作引入了新的内存模型，使多代理程序可以使用原子操作进行通信，即使在并行 CPU 上也能确保有序执行。还新增了 Object 的静态方法：`Object.values`、`Object.entries` 和 `Object.getOwnPropertyDescriptors`。</p>
  <p>ECMAScript 2018 引入了通过异步迭代器协议和异步生成器实现的异步迭代支持。还新增了四种正则表达式特性：`dotAll` 标志、命名捕获组、Unicode 属性转义和后行断言。最后还包括对象剩余和展开属性。</p>
  <p>ECMAScript 2019 新增了几种内置函数：用于数组扁平化的 `Array.prototype` 上的 `flat` 和 `flatMap`，用于直接将 `Object.entries` 的返回值转为新对象的 `Object.fromEntries`，以及作为更合理命名替代的 `String.prototype` 上的 `trimStart` 和 `trimEnd`（替代广泛实现但未标准化的 `String.prototype.trimLeft` 和 `trimRight`）。此外还包括对语法和语义的细微更新。语法更新包括可选的 catch 绑定参数以及在字符串字面量中允许 U+2028（行分隔符）和 U+2029（段分隔符），以与 JSON 保持一致。其他更新包括要求 `Array.prototype.sort` 必须为稳定排序，要求 `JSON.stringify` 无论输入如何都返回格式正确的 UTF-8，以及明确要求 `Function.prototype.toString` 返回相应的原始源代码或标准占位符。</p>
  <p>ECMAScript 2020，第 11 版，引入了字符串的 `matchAll` 方法，可通过全局正则表达式生成所有匹配对象的迭代器；`import()`，一种可动态指定异步导入模块的语法；`BigInt`，用于任意精度整数的新数值原语；`Promise.allSettled`，一种不会短路的 Promise 组合器；`globalThis`，一种通用访问全局 `this` 的方式；模块内专用的 `export * as ns from 'module'` 语法；`for-in` 枚举顺序的标准化提升；模块内由宿主环境填充的 `import.meta` 对象，可包含关于模块的上下文信息；以及为“空值”(*undefined* 或 *null*) 增强体验的新语法特性：空值合并运算符和可选链运算符，分别用于值选择和属性访问/函数调用时遇到空值自动短路。</p>
  <p>ECMAScript 2021，第 12 版，引入了字符串的 `replaceAll` 方法；`Promise.any`，一种在输入值满足条件时短路的 Promise 组合器；`AggregateError`，用于同时表示多个错误的新错误类型；逻辑赋值运算符（`??=`, `&&=`, `||=`）；`WeakRef`，用于引用目标对象但不阻止其被垃圾回收，以及 `FinalizationRegistry`，用于注册和注销在目标对象被垃圾回收时执行的清理操作；数字字面量分隔符（如 `1_000`）；并且 `Array.prototype.sort` 更加精确，减少了实现定义排序结果的情况。</p>
  <p>ECMAScript 2022，第 13 版，引入了顶层 `await`，允许在模块顶层使用该关键字；新增类元素：公有和私有实例字段、静态字段、私有实例方法和访问器、私有静态方法和访问器；类中的静态块，用于每个类的初始化；`#x in obj` 语法，用于检测对象上的私有字段是否存在；正则表达式匹配索引（通过 `/d` 标志），可提供匹配子字符串的起止索引；错误对象的 `cause` 属性，可用于记录错误因果链；字符串、数组和 TypedArray 的 `at` 方法，实现相对索引；以及 `Object.hasOwn`，作为更方便的 `Object.prototype.hasOwnProperty` 替代方案。</p>
  <p>ECMAScript 2023，第 14 版，在 `Array.prototype` 和 `TypedArray.prototype` 上新增了 `toSorted`、`toReversed`、`with`、`findLast` 和 `findLastIndex` 方法，并在 `Array.prototype` 上新增了 `toSpliced` 方法；支持文件开头的 `#!` 注释，以更好地支持可执行 ECMAScript 文件；允许在弱集合中使用大多数 Symbol 作为键。</p>
  <p>ECMAScript 2024，第 15 版，增加了 ArrayBuffer 和 SharedArrayBuffer 的动态调整大小和转移功能；新增了用于处理字符串集合的高级特性的新正则表达式 `/v` 标志；引入了便捷构造 Promise 的 `Promise.withResolvers` 方法，数据聚合的 `Object.groupBy` 和 `Map.groupBy` 方法，异步等待共享内存变更的 `Atomics.waitAsync` 方法，以及用于检测和保证字符串仅包含格式正确 Unicode 的 `String.prototype.isWellFormed` 和 `String.prototype.toWellFormed` 方法。</p>
  <p>ECMAScript 2025，第 16 版，新增了带有相关静态方法和原型方法的全局 `Iterator`，用于迭代器操作；为 `Set.prototype` 增加了常用集合操作方法；支持导入 JSON 模块，以及声明导入模块属性的语法；新增了用于安全处理字符串的 `RegExp.escape` 方法；支持在正则表达式中内联启用和禁用修饰符标志的语法；新增了用于处理可能返回 Promise 或非 Promise 的函数并确保返回值始终是 Promise 的 `Promise.try` 方法；并新增了新的 `Float16Array` 类型数组及相关的 `DataView.prototype.getFloat16`、`DataView.prototype.setFloat16` 和 `Math.f16round` 方法。</p>
  <p>有数十位代表众多机构的个人在 Ecma TC39 中为本版及以往版本的开发做出了重要贡献。此外，支持 TC39 ECMAScript 工作的社区也日益活跃。该社区审查了大量草案，提交了成千上万个错误报告，进行了实现实验，贡献了测试套件，并向全球开发者介绍 ECMAScript。遗憾的是，无法逐一列举和感谢每一位做出贡献的个人和机构。</p>
  <p>
    Allen Wirfs-Brock<br>
    ECMA-262，第 6 版项目编辑
  </p>
  <p>
    Brian Terlson<br>
    ECMA-262，第 7–10 版项目编辑
  </p>
  <p>
    Jordan Harband<br>
    ECMA-262，第 10–12 版项目编辑
  </p>
  <p>
    Shu-yu Guo<br>
    ECMA-262，第 12–16 版项目编辑
  </p>
  <p>
    Michael Ficarra<br>
    ECMA-262，第 12–16 版项目编辑
  </p>
  <p>
    Kevin Gibbons<br>
    ECMA-262，第 12–16 版项目编辑
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>范围</h1>
  <p>本标准定义了 ECMAScript 2026 通用编程语言。</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>一致性</h1>
  <p>符合规范的 ECMAScript 实现必须提供并支持本规范中描述的所有类型、值、对象、属性、函数，以及程序的语法和语义。</p>
  <p>符合规范的 ECMAScript 实现必须按照最新版 Unicode 标准和 ISO/IEC 10646 的要求解释源文本输入。</p>
  <p>符合规范的 ECMAScript 实现如果提供支持不同语言和国家的语言习惯和文化规范的应用程序编程接口（API），则必须实现与本规范兼容的最新版 ECMA-402 所定义的接口。</p>
  <p>符合规范的 ECMAScript 实现可以提供本规范未描述的其他类型、值、对象、属性和函数。特别地，符合规范的 ECMAScript 实现可以为本规范所描述的对象提供未在本规范中描述的属性，以及这些属性的值。</p>
  <p>符合规范的 ECMAScript 实现可以支持本规范未描述的程序和正则表达式语法。特别地，符合规范的 ECMAScript 实现可以支持使用本规范 <emu-xref href="#sec-keywords-and-reserved-words"></emu-xref> 分条中所述任何“未来保留字”的程序语法。</p>
  <p>符合规范的 ECMAScript 实现不得实现本规范 <emu-xref href="#sec-forbidden-extensions"></emu-xref> 分条中列为禁止扩展的任何扩展。</p>
  <p>符合规范的 ECMAScript 实现不得重新定义任何非实现自定义、非近似实现或非宿主自定义的机制。</p>
  <p>符合规范的 ECMAScript 实现可以选择实现或不实现 <dfn>规范性可选</dfn> 子条款，除非另有说明。通常情况下，网页浏览器要求实现所有规范性可选子条款。（参见附录 <emu-xref href="#sec-additional-ecmascript-features-for-web-browsers"></emu-xref>。）如果实现了任何规范性可选行为，则必须实现包含该行为的所有规范性可选条款。规范性可选条款在本规范中以彩色框显示“规范性可选”字样，如下所示。</p>

  <emu-clause id="sec-conformance-normative-optional" oldids="sec-conformance.normative-optional" example normative-optional>
    <h1>规范性可选条款标题示例</h1>
    <p>条款内容示例。</p>
  </emu-clause>
  <p>符合规范的 ECMAScript 实现必须实现 <dfn>遗留</dfn> 子条款，除非它们也被标记为规范性可选。遗留子条款中指定的所有语言特性和行为都具有一个或多个不理想的特性，但由于现有应用仍在使用，无法从规范中移除这些特性。这些特性不属于 ECMAScript 语言核心。编程人员在编写新的 ECMAScript 代码时不应使用或假定这些特性和行为的存在。</p>

  <emu-clause id="sec-conformance-legacy" example legacy>
    <h1>遗留条款标题示例</h1>
    <p>条款内容示例。</p>
  </emu-clause>

  <emu-clause id="sec-conformance-legacy-normative-optional" example legacy normative-optional>
    <h1>遗留规范性可选条款标题示例</h1>
    <p>条款内容示例。</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-normative-references">
  <h1>规范性引用文件</h1>
  <p>下列引用文件对于本文件的应用是不可或缺的。对于有日期的引用，仅适用于所引用的版本；对于无日期的引用，适用于引用文件的最新版本（包括任何修订）。</p>
  <p>IEEE 754-2019，《浮点数运算标准》。</p>
  <p>
    Unicode 标准。<br>
    <a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>
  </p>
  <p>ISO/IEC 10646，《信息技术——通用多字节编码字符集（UCS）》，包括修订1:2005、修订2:2006、修订3:2008、修订4:2008，以及更多修订和勘误，或后续版本。</p>
  <p>
    ECMA-402，《ECMAScript 国际化 API 规范》，特别是与本规范版本相对应的年度版本。<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-402/">https://www.ecma-international.org/publications-and-standards/standards/ecma-402/</a>
  </p>
  <p>
    ECMA-404，《JSON 数据交换格式》。<br>
    <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>
  </p>
</emu-clause>

<emu-clause id="sec-overview">
  <h1>概述</h1>
  <p>本节包含 ECMAScript 语言的非规范性概述。</p>
  <p>ECMAScript 是一种面向对象的编程语言，用于在宿主环境中进行计算和操作计算对象。本规范中的 ECMAScript 并不旨在具备完全自给自足的计算能力；实际上，本规范未为外部数据输入或计算结果输出提供规定。而是预期 ECMAScript 程序的计算环境不仅提供本规范描述的对象和其他机制，还提供某些特定于环境的对象，其描述和行为超出本规范范围，仅说明它们可以提供可访问的属性和可从 ECMAScript 程序调用的函数。</p>
  <p>ECMAScript 最初设计为脚本语言，但现已广泛用作通用编程语言。<em>脚本语言</em>是用于操作、定制和自动化现有系统功能的编程语言。在此类系统中，实用功能通常通过用户界面提供，脚本语言则是让程序能够控制这些功能的机制。这样，现有系统就提供了对象和机制组成的宿主环境，补足了脚本语言的能力。脚本语言面向专业和非专业程序员。</p>
  <p>ECMAScript 最初设计为<em>Web 脚本语言</em>，用于在浏览器中为 Web 页面赋予动态行为，并在基于 Web 的客户端-服务器架构中执行服务器端计算。如今，ECMAScript 被用于为多种宿主环境提供核心脚本能力。因此，核心语言在本文件中独立于任何特定宿主环境进行描述。</p>
  <p>ECMAScript 的使用已超越简单脚本，现在在许多环境和规模下用于各类编程任务。随着 ECMAScript 应用范围的扩大，其所提供的特性和机制也不断丰富。ECMAScript 现已成为功能完备的通用编程语言。</p>

  <emu-clause id="sec-web-scripting">
    <h1>Web 脚本</h1>
    <p>网页浏览器为客户端计算提供 ECMAScript 宿主环境，例如用于表示窗口、菜单、弹窗、对话框、文本区域、锚点、框架、历史、Cookie 和输入/输出的对象。此外，宿主环境提供了将脚本代码绑定到事件的方法，如焦点变化、页面和图片加载、卸载、错误和中断、选择、表单提交和鼠标操作。脚本代码出现在 HTML 内，显示的页面是用户界面元素与固定及计算文本和图片的结合。脚本代码响应用户交互，无需主程序。</p>
    <p>Web 服务器则为服务端计算提供不同的宿主环境，包括用于表示请求、客户端和文件的对象，以及锁定与共享数据的机制。通过结合浏览器端和服务器端脚本，可以在客户端和服务器间分布计算，同时为 Web 应用提供定制化用户界面。</p>
    <p>支持 ECMAScript 的每个 Web 浏览器和服务器都提供自己的宿主环境，完善了 ECMAScript 的执行环境。</p>
  </emu-clause>

  <emu-clause id="sec-hosts-and-implementations">
    <h1>宿主和实现</h1>
    <p>为便于将 ECMAScript 集成到宿主环境中，本规范将某些机制（如抽象操作）全部或部分定义留给规范外部的来源。本规范在编辑上区分如下几种委托方式。</p>
    <p><em id="implementation">实现</em>指的是进一步定义附件 <emu-xref href="#sec-host-layering-points"></emu-xref> 列举的机制，或被标记为实现自定义或实现近似的机制的外部来源。在非正式用法中，实现通常指某个具体产物，如某个网页浏览器。</p>
    <p><dfn id="implementation-defined">实现自定义</dfn>指将某个机制的定义无附加限定地委托给外部来源。本规范未对具体行为做任何建议，符合规范的实现可在规范约束范围内自由选择行为。</p>
    <p><dfn id="implementation-approximated">实现近似</dfn>指将某个机制的定义委托给外部来源，同时建议理想行为。符合规范的实现可在规范约束范围内自由选择行为，但鼓励尽量接近理想。例如部分数学操作，如 <emu-xref href="#sec-math.exp"><code>Math.exp</code></emu-xref>，采用实现近似方式。</p>
    <p><dfn id="host" variants="hosts">宿主</dfn>指进一步定义附件 <emu-xref href="#sec-host-layering-points"></emu-xref> 所列机制，但不进一步定义其他实现自定义或近似机制的外部来源。在非正式用法中，宿主指以相同方式通过附件 <emu-xref href="#sec-host-layering-points"></emu-xref> 与本规范接口的所有实现集合，如所有网页浏览器。宿主通常是外部规范，如 WHATWG HTML（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）。换句话说，宿主自定义机制常在外部规范中进一步定义。</p>
    <p><dfn id="host-hook" variants="host hooks">宿主钩子</dfn>是由外部来源全部或部分定义的抽象操作。所有宿主钩子须列于附件 <emu-xref href="#sec-host-layering-points"></emu-xref>。宿主钩子须至少满足以下要求：</p>
    <ul>
      <li>必须返回正常完成或抛出完成。</li>
    </ul>
    <p><dfn id="host-defined">宿主自定义</dfn>指无附加限定地将机制定义委托给外部来源，并列于附件 <emu-xref href="#sec-host-layering-points"></emu-xref>。非宿主的实现也可为宿主自定义机制提供定义。</p>
    <p><dfn id="host-environment" variants="host environments">宿主环境</dfn>指对所有宿主自定义机制的具体定义选择。宿主环境通常包括一些对象或函数，通过全局对象的宿主自定义属性实现输入输出。</p>
    <p>本规范在编辑上始终采用最具体术语。例如，如果某机制为宿主自定义，不应称其为实现自定义。</p>
    <p>宿主和实现都可通过本规范定义的语言类型、规范类型、抽象操作、语法产生式、内在对象和内在符号与本规范接口。</p>
  </emu-clause>

  <emu-clause id="sec-ecmascript-overview">
    <h1>ECMAScript 概览</h1>
    <p>以下是 ECMAScript 的非正式概览，未描述语言的所有部分。本概览不是标准正文的一部分。</p>
    <p>ECMAScript 是基于对象的：基本语言机制和宿主机制由对象提供，ECMAScript 程序是一组相互通信的对象。在 ECMAScript 中，<em>对象</em>是包含零个或多个<em>属性</em>的集合，每个属性具有<em>特性</em>，这些特性决定属性的使用方式——例如，当属性的 Writable 特性为 *false* 时，任何 ECMAScript 代码尝试为该属性赋新值都将失败。属性是用来保存其他对象、<em>原始值</em>或<em>函数</em>的容器。原始值属于以下内建类型之一：<b>Undefined</b>、<b>Null</b>、<b>Boolean</b>、<b>Number</b>、<b>BigInt</b>、<b>String</b> 和 <b>Symbol</b>；对象属于内建类型 <b>Object</b>；函数是可调用的对象。通过属性与对象关联的函数称为<em>方法</em>。</p>
    <p>ECMAScript 定义了一组<em>内建对象</em>，补充了 ECMAScript 实体的定义。这些内建对象包括全局对象；与语言运行时语义密切相关的对象，如 `Object`、`Function`、`Boolean`、`Symbol` 及各类 `Error` 对象；用于表示和操作数值的对象，如 `Math`、`Number` 和 `Date`；用于文本处理的对象 `String` 和 `RegExp`；用于值索引集合的对象，如 `Array` 以及具有特定数值表示的九种 Typed Array；用于键值集合的 `Map` 和 `Set`；用于结构化数据的对象，如 `JSON`、`ArrayBuffer`、`SharedArrayBuffer` 和 `DataView`；用于控制抽象的对象，如生成器函数和 `Promise`；以及用于反射的对象，如 `Proxy` 和 `Reflect`。</p>
    <p>ECMAScript 还定义了一组内建<em>运算符</em>。ECMAScript 运算符包括各类一元运算、乘法运算、加法运算、位移运算、关系运算、相等运算、二元位运算、二元逻辑运算、赋值运算和逗号运算。</p>
    <p>大型 ECMAScript 程序通过<em>模块</em>得到支持，允许将程序划分为多个语句和声明序列。每个模块明确标识需要由其他模块提供的声明，以及哪些声明可供其他模块使用。</p>
    <p>ECMAScript 的语法有意与 Java 语法相似。ECMAScript 的语法较为宽松，便于其作为易用的脚本语言。例如，变量无需声明类型，属性也无类型约束，定义的函数无需在调用前出现在文本中。</p>

    <emu-clause id="sec-objects">
      <h1>对象</h1>
      <p>尽管 ECMAScript 包含类定义语法，但 ECMAScript 对象本质上不是 C++、Smalltalk 或 Java 那样的类基础对象。对象可以通过多种方式创建，包括字面量方式或通过<em>构造函数</em>创建对象并执行初始化代码为属性赋初值。每个构造函数都是一个函数，拥有名为 *"prototype"* 的属性，用于实现<em>基于原型的继承</em>和<em>共享属性</em>。对象可通过 <b>new</b> 表达式使用构造函数创建，例如 `new Date(2009, 11)` 创建一个新的 Date 对象。直接调用构造函数而不使用 <b>new</b> 的行为取决于构造函数，例如 `Date()` 返回当前日期和时间的字符串而不是对象。</p>
      <p>每个由构造函数创建的对象都隐式引用（称为对象的<em>原型</em>）其构造函数的 *"prototype"* 属性。此外，原型还可以非 *null* 地隐式引用其原型，依此类推；这被称为<em>原型链</em>。访问对象属性时，查找的是原型链中第一个包含该属性的对象。即，首先检查直接引用的对象是否有该属性，若有则访问该属性，若无则检查该对象的原型，依此类推。</p>
      <emu-figure id="figure-1" caption="对象/原型关系">
        <img alt="一个包含许多方框和箭头的图示。" height="354" src="img/figure-1.svg" width="719">
      </emu-figure>
      <p>在基于类的面向对象语言中，状态通常由实例承载，方法由类承载，继承仅限结构和行为。而在 ECMAScript 中，状态和方法都由对象承载，结构、行为和状态都可继承。</p>
      <p>所有未直接拥有其原型属性的对象共享该属性及其值。图1对此进行了说明：</p>
      <p><b>CF</b> 是一个构造函数（也是一个对象）。通过 `new` 表达式创建了五个对象：<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 和 <b>cf<sub>5</sub></b>。每个对象都包含名为 *"q1"* 和 *"q2"* 的属性。虚线表示隐式原型关系；例如，<b>cf<sub>3</sub></b> 的原型是 <b>CF<sub>p</sub></b>。构造函数 <b>CF</b> 自身有两个属性，分别为 *"P1"* 和 *"P2"*，这些属性对 <b>CF<sub>p</sub></b>、<b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 或 <b>cf<sub>5</sub></b> 不可见。<b>CF<sub>p</sub></b> 的 *"CFP1"* 属性被 <b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 和 <b>cf<sub>5</sub></b> 共享（但不包括 <b>CF</b>），以及 <b>CF<sub>p</sub></b> 的隐式原型链上除 *"q1"*、*"q2"* 和 *"CFP1"* 外的所有属性。注意 <b>CF</b> 和 <b>CF<sub>p</sub></b> 之间没有隐式原型链接。</p>
      <p>与多数基于类的对象语言不同，可以通过为对象赋值动态添加属性。即，构造函数无需为所有或任何构造对象的属性命名或赋值。在上述图示中，可以通过为 <b>CF<sub>p</sub></b> 属性赋新值，为 <b>cf<sub>1</sub></b>、<b>cf<sub>2</sub></b>、<b>cf<sub>3</sub></b>、<b>cf<sub>4</sub></b> 和 <b>cf<sub>5</sub></b> 新增共享属性。</p>
      <p>虽然 ECMAScript 对象本质上不是类基础，但基于通用的构造函数、原型对象和方法模式定义类式抽象通常很方便。ECMAScript 的内建对象本身也遵循此类模式。从 ECMAScript 2015 起，ECMAScript 语言包含类定义语法，允许程序员简洁地定义符合内建对象所用类式抽象模式的对象。</p>
    </emu-clause>

    <emu-clause id="sec-strict-variant-of-ecmascript">
      <h1>ECMAScript 的严格模式变体</h1>
      <p>ECMAScript 语言考虑到部分用户可能希望限制语言中的某些特性使用。这样做可能出于安全考虑、避免易出错特性、获得更强的错误检查或其他原因。为此，ECMAScript 定义了语言的严格模式变体。严格模式变体排除了常规 ECMAScript 语言中的部分特定语法和语义特性，并对部分特性进行了详细语义修改。严格模式还规定了在非严格模式下不视为错误的情况下必须抛出错误异常的额外错误条件。</p>
      <p>ECMAScript 的严格模式变体通常被称为语言的<em>严格模式</em>。严格模式的选择及语法和语义的使用在单个 ECMAScript 源文本单元级进行，如 <emu-xref href="#sec-strict-mode-code"></emu-xref> 所述。由于严格模式在语法源文本单元级选择，严格模式仅在该单元内产生局部影响。严格模式不会限制或修改必须跨多个源文本单元一致运行的 ECMAScript 语义。完整的 ECMAScript 程序可以包含严格模式和非严格模式的源文本单元。此时，严格模式仅在实际执行定义于严格模式源文本单元的代码时生效。</p>
      <p>为符合本规范，ECMAScript 实现必须实现本规范定义的完整的非受限 ECMAScript 语言和严格模式变体，并支持将非受限和严格模式源文本单元组合为单一复合程序。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-terms-and-definitions">
    <h1>术语和定义</h1>
    <p>本文件的目的所涉及的术语和定义如下。</p>

    <emu-clause id="sec-terms-and-definitions-implementation-approximated">
      <h1>实现近似</h1>
      <p>实现近似机制由外部来源全部或部分定义，但本规范推荐理想行为</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-implementation-defined">
      <h1>实现自定义</h1>
      <p>实现自定义机制由外部来源全部或部分定义</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-host-defined">
      <h1>宿主自定义</h1>
      <p>同实现自定义</p>
      <emu-note>
        <p>编辑说明，见 <emu-xref href="#sec-hosts-and-implementations"></emu-xref> 条款。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-type">
      <h1>类型</h1>
      <p>如 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 条款所定义的数据值集合</p>
    </emu-clause>

    <emu-clause id="sec-primitive-value">
      <h1>原始值</h1>
      <p>属于 Undefined、Null、Boolean、Number、BigInt、Symbol 或 String 类型之一，如 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 条款所定义</p>
      <emu-note>
        <p>原始值是由语言实现直接在最低层级表示的数据项。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-object">
      <h1>对象</h1>
      <p>属于 Object 类型的成员</p>
      <emu-note>
        <p>对象是属性集合，并且有唯一的原型对象。原型可以为 *null*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-constructor">
      <h1>构造函数</h1>
      <p>用于创建和初始化对象的函数对象</p>
      <emu-note>
        <p>构造函数的 *"prototype"* 属性值是实现继承和共享属性所用的原型对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-prototype">
      <h1>原型</h1>
      <p>为其他对象提供共享属性的对象</p>
      <emu-note>
        <p>构造函数创建对象时，该对象隐式引用构造函数的 *"prototype"* 属性以解析属性引用。构造函数的 *"prototype"* 属性可通过程序表达式 <code><var>constructor</var>.prototype</code> 访问，向原型添加属性，通过继承，所有共享该原型的对象都可访问这些属性。或者，可以通过 `Object.create` 内建函数创建具有指定原型的新对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinary-object">
      <h1>普通对象</h1>
      <p>具有所有对象必须支持的基本内部方法默认行为的对象</p>
    </emu-clause>

    <emu-clause id="sec-exotic-object">
      <h1>特殊对象</h1>
      <p>在一个或多个基本内部方法上不具有默认行为的对象</p>
      <emu-note>
        <p>任何非普通对象都是特殊对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-standard-object">
      <h1>标准对象</h1>
      <p>其语义由本规范定义的对象</p>
    </emu-clause>

    <emu-clause id="sec-built-in-object">
      <h1>内建对象</h1>
      <p>由 ECMAScript 实现指定并提供的对象</p>
      <emu-note>
        <p>标准内建对象由本规范定义。ECMAScript 实现可以指定和提供其他类型的内建对象。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-undefined-value">
      <h1>undefined 值</h1>
      <p>在变量未赋值时使用的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-undefined-type">
      <h1>Undefined 类型</h1>
      <p>其唯一值为 *undefined* 的类型</p>
    </emu-clause>

    <emu-clause id="sec-null-value">
      <h1>null 值</h1>
      <p>表示有意无对象值的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-null-type">
      <h1>Null 类型</h1>
      <p>其唯一值为 *null* 的类型</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-value">
      <h1>Boolean 值</h1>
      <p>属于 Boolean 类型的成员</p>
      <emu-note>
        <p>只有两个 Boolean 值，*true* 和 *false*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-boolean-type">
      <h1>Boolean 类型</h1>
      <p>由原始值 *true* 和 *false* 组成的类型</p>
    </emu-clause>

    <emu-clause id="sec-boolean-object">
      <h1>Boolean 对象</h1>
      <p>属于 Object 类型且为标准内建 Boolean 构造函数实例的成员</p>
      <emu-note>
        <p>Boolean 对象通过在 `new` 表达式中使用 Boolean 构造函数并传递 Boolean 值参数创建。生成的对象有一个内部插槽，值为 Boolean 值。Boolean 对象可被强制转换为 Boolean 值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-value">
      <h1>String 值</h1>
      <p>为有限有序的零个或多个 16 位无符号整数值序列的原始值</p>
      <emu-note>
        <p>String 值属于 String 类型。序列中的每个整数值通常表示一个 UTF-16 文本的 16 位单元。但 ECMAScript 不对这些值做任何限制或要求，仅要求其为 16 位无符号整数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-string-type">
      <h1>String 类型</h1>
      <p>所有可能的 String 值的集合</p>
    </emu-clause>

    <emu-clause id="sec-string-object">
      <h1>String 对象</h1>
      <p>属于 Object 类型且为标准内建 String 构造函数实例的成员</p>
      <emu-note>
        <p>String 对象通过在 `new` 表达式中使用 String 构造函数并传递 String 值参数创建。生成的对象有一个内部插槽，值为 String 值。String 对象可通过将 String 构造函数作为函数调用（<emu-xref href="#sec-string-constructor-string-value"></emu-xref>）被强制转换为 String 值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-value">
      <h1>Number 值</h1>
      <p>与双精度 64 位二进制格式 IEEE 754-2019 值对应的原始值</p>
      <emu-note>
        <p>Number 值属于 Number 类型，是数字的直接表示。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-number-type">
      <h1>Number 类型</h1>
      <p>所有可能的 Number 值集合，包括 *NaN*（非数字）、*+∞*<sub>𝔽</sub>（正无穷）、*-∞*<sub>𝔽</sub>（负无穷）</p>
    </emu-clause>

    <emu-clause id="sec-number-object">
      <h1>Number 对象</h1>
      <p>属于 Object 类型且为标准内建 Number 构造函数实例的成员</p>
      <emu-note>
        <p>Number 对象通过在 `new` 表达式中使用 Number 构造函数并传递 Number 值参数创建。生成的对象有一个内部插槽，值为 Number 值。Number 对象可通过将 Number 构造函数作为函数调用（<emu-xref href="#sec-number-constructor-number-value"></emu-xref>）被强制转换为 Number 值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-infinity">
      <h1>Infinity</h1>
      <p>为正无穷值的 Number 值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-nan">
      <h1>NaN</h1>
      <p>为 IEEE 754-2019 NaN（非数字）值的 Number 值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-value">
      <h1>BigInt 值</h1>
      <p>对应于任意精度整数值的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-bigint-type">
      <h1>BigInt 类型</h1>
      <p>所有可能的 BigInt 值集合</p>
    </emu-clause>

    <emu-clause id="sec-bigint-object">
      <h1>BigInt 对象</h1>
      <p>属于 Object 类型且为标准内建 BigInt 构造函数实例的成员</p>
    </emu-clause>

    <emu-clause id="sec-symbol-value">
      <h1>Symbol 值</h1>
      <p>表示唯一、非 String 对象属性键的原始值</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-symbol-type">
      <h1>Symbol 类型</h1>
      <p>所有可能的 Symbol 值集合</p>
    </emu-clause>

    <emu-clause id="sec-symbol-object">
      <h1>Symbol 对象</h1>
      <p>属于 Object 类型且为标准内建 Symbol 构造函数实例的成员</p>
    </emu-clause>

    <emu-clause id="sec-terms-and-definitions-function">
      <h1>函数</h1>
      <p>属于 Object 类型，可作为子程序调用的成员</p>
      <emu-note>
        <p>函数除具有属性外，还包含可执行代码和状态，决定调用时的行为。函数代码可能用 ECMAScript 编写，也可能不是。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-function">
      <h1>内建函数</h1>
      <p>为函数的内建对象</p>
      <emu-note>
        <p>内建函数示例包括 `parseInt` 和 `Math.exp`。宿主或实现可提供未在本规范描述的其他内建函数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-constructor">
      <h1>内建构造函数</h1>
      <p>为构造函数的内建函数</p>
      <emu-note>
        <p>内建构造函数示例包括 `Object` 和 `Function`。宿主或实现可提供未在本规范描述的其他内建构造函数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-property">
      <h1>属性</h1>
      <p>对象的一部分，将键（String 值或 Symbol 值）与值关联</p>
      <emu-note>
        <p>根据属性形式，值可以直接表示为数据值（原始值、对象或函数对象），也可以通过一对访问器函数间接表示。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-method">
      <h1>方法</h1>
      <p>作为属性值的函数</p>
      <emu-note>
        <p>当函数作为对象的方法调用时，该对象作为 *this* 值传递给函数。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-built-in-method">
      <h1>内建方法</h1>
      <p>为内建函数的方法</p>
      <emu-note>
        <p>标准内建方法由本规范定义。宿主或实现可提供未在本规范描述的其他内建方法。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-attribute">
      <h1>特性</h1>
      <p>定义属性某些特性的内部值</p>
    </emu-clause>

    <emu-clause id="sec-own-property">
      <h1>自身属性</h1>
      <p>直接由对象包含的属性</p>
    </emu-clause>

    <emu-clause id="sec-inherited-property">
      <h1>继承属性</h1>
      <p>不是对象自身属性但属于对象原型（自身或继承）的属性</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-organization-of-this-specification">
    <h1>本规范的结构</h1>
    <p>本规范余下内容组织如下：</p>
    <p><emu-xref href="#sec-notational-conventions"></emu-xref> 条款定义了贯穿规范的符号约定。</p>
    <p><emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 至 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 条款定义了 ECMAScript 程序运行的执行环境。</p>
    <p><emu-xref href="#sec-ecmascript-language-source-code"></emu-xref> 至 <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 条款定义了实际的 ECMAScript 编程语言，包括语法编码和所有语言特性的执行语义。</p>
    <p><emu-xref href="#sec-ecmascript-standard-built-in-objects"></emu-xref> 至 <emu-xref href="#sec-reflection"></emu-xref> 条款定义了 ECMAScript 标准库，包含 ECMAScript 程序执行时可用的所有标准对象定义。</p>
    <p><emu-xref href="#sec-memory-model"></emu-xref> 条款描述了对 SharedArrayBuffer 支持的内存一致性模型以及 Atomics 对象的方法。</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>符号约定</h1>

  <emu-clause id="sec-syntactic-and-lexical-grammars">
    <h1>句法和词法文法</h1>

    <emu-clause id="sec-context-free-grammars">
      <h1>上下文无关文法</h1>
      <p><em>上下文无关文法</em>由若干<em>产生式</em>组成。每个产生式都有一个抽象符号，称为<em>非终结符</em>，作为其<em>左部</em>，以及由零个或多个非终结符和<em>终结符</em>组成的序列，作为其<em>右部</em>。对于每个文法，终结符来自指定的字母表。</p>
      <p><dfn variants="chain productions">链式产生式</dfn>是指其右部恰好只有一个非终结符和零个或多个终结符的产生式。</p>
      <p>从一个仅包含单一特殊非终结符的句子开始，称为<dfn variants="goal symbols">目标符号</dfn>，给定的上下文无关文法定义了一个<em>语言</em>，即通过不断将序列中的任意非终结符替换为以该非终结符为左部的某个产生式的右部，最终可能得到的所有终结符序列的集合（可能是无限的）。</p>
    </emu-clause>

    <emu-clause id="sec-lexical-and-regexp-grammars">
      <h1>词法和正则表达式文法</h1>
      <p>ECMAScript 的<em>词法文法</em>见 <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>。该文法的终结符是符合 <emu-xref href="#sec-source-text"></emu-xref> 中 |SourceCharacter| 规则的 Unicode 码点。它定义了一组产生式，从目标符号 |InputElementDiv|、|InputElementTemplateTail|、|InputElementRegExp|、|InputElementRegExpOrTemplateTail| 或 |InputElementHashbangOrRegExp| 开始，描述了这些码点序列如何转换为输入元素序列。</p>
      <p>除空白和注释外的输入元素构成 ECMAScript 句法文法的终结符，被称为 ECMAScript <em>标记</em>。这些标记包括 ECMAScript 语言的保留字、标识符、字面量和标点符号。此外，行终止符虽然不是标记，但也成为输入元素流的一部分，引导自动分号插入过程（<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>）。简单空白和单行注释会被丢弃，不会出现在句法文法的输入元素流中。|MultiLineComment|（即形如 `/*`…`*/` 的注释，无论是否跨越多行）如果不包含行终止符，则同样被丢弃；但若包含一个或多个行终止符，则被替换为一个单一行终止符，后者成为句法文法输入元素流的一部分。</p>
      <p>ECMAScript 的<em>正则表达式文法</em>见 <emu-xref href="#sec-patterns"></emu-xref>。该文法的终结符同样为 |SourceCharacter| 所定义的码点。它定义了一组产生式，从目标符号 |Pattern| 开始，描述了码点序列如何转换为正则表达式模式。</p>
      <p>词法和正则表达式文法的产生式以两个冒号“<b>::</b>”作为分隔标志。词法文法和正则表达式文法共享部分产生式。</p>
    </emu-clause>

    <emu-clause id="sec-numeric-string-grammar">
      <h1>数值字符串文法</h1>
      <p><em>数值字符串文法</em>见 <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>。其终结符为 |SourceCharacter|，用于将字符串从目标符号 |StringNumericLiteral| 开始转换为数值（与 <emu-xref href="#sec-literals-numeric-literals">数值字面量的词法文法</emu-xref> 类似但不同）。</p>
      <p>数值字符串文法的产生式以三个冒号“<b>:::</b>”为标点，并从不用于解析源文本。</p>
    </emu-clause>

    <emu-clause id="sec-syntactic-grammar">
      <h1>句法文法</h1>
      <p>ECMAScript 的<em>句法文法</em>见 <emu-xref href="#sec-ecmascript-language-expressions"></emu-xref> 到 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref>。该文法的终结符为词法文法定义的 ECMAScript 标记（<emu-xref href="#sec-lexical-and-regexp-grammars"></emu-xref>）。它定义了一组产生式，从两个备选目标符号 |Script| 和 |Module| 开始，描述了标记序列如何组成语法正确的 ECMAScript 程序独立组件。</p>
      <p>当要将码点流解析为 ECMAScript 的 |Script| 或 |Module| 时，首先通过反复应用词法文法，将其转换为输入元素流；然后该输入元素流通过一次句法文法解析。若输入元素流中的标记无法解析为一个目标非终结符（|Script| 或 |Module|）的实例，且没有剩余标记，则输入流存在语法错误。</p>
      <p>解析成功时会构建一个<em>解析树</em>，即以根为起点的树结构，每个节点为一个<dfn variants="Parse Nodes">解析节点</dfn>。每个解析节点是文法符号的一个<em>实例</em>，表示可由该符号导出的源文本片段。解析树的根节点，代表整个源文本，是解析目标符号的一个实例。当解析节点是非终结符的实例时，也是以该非终结符为左部的某个产生式的实例。此外，它有零个或多个<em>子节点</em>，每个对应产生式右部的一个符号：每个子节点是相应符号的解析节点实例。</p>
      <p>每次解析器调用都会实例化新的解析节点，即使解析的源文本完全相同，解析节点也不会复用。只有当解析节点代表同一源文本片段、是同一文法符号的实例且来源于同一次解析器调用时，才认为它们<dfn>是同一个解析节点</dfn>。</p>
      <emu-note>
        <p>多次解析同一个字符串会得到不同的解析节点。例如：</p>
        <pre><code class="javascript">
          let str = "1 + 1;";
          eval(str);
          eval(str);
        </code></pre>
        <p>每次调用 `eval` 都会将 `str` 的值转换为 ECMAScript 源文本，并进行独立解析，生成各自独立的解析节点树。即使每次解析的源文本都来自同一个字符串值，树结构也是不同的。</p>
      </emu-note>
      <emu-note>解析节点是规范中的抽象实体，具体实现无需采用类似的数据结构。</emu-note>
      <p>句法文法的产生式以单个冒号“<b>:</b>”作为标点。</p>
      <p>在 <emu-xref href="#sec-ecmascript-language-expressions"></emu-xref> 到 <emu-xref href="#sec-ecmascript-language-scripts-and-modules"></emu-xref> 条款中呈现的句法文法并未完全覆盖所有可作为正确 ECMAScript |Script| 或 |Module| 被接受的标记序列。额外接受的标记序列包括那些仅需在某些位置（如行终止符前）添加分号即可被文法描述的序列。此外，某些文法描述的标记序列若在某些“特殊”位置出现行终止符，则不被接受。</p>
      <p>为避免歧义，句法文法在某些情况下使用了广义产生式，允许不形成有效 ECMAScript |Script| 或 |Module| 的标记序列。例如，对象字面量和对象解构模式采用此技术。在这些情况下，会提供更严格的<em>补充文法</em>以进一步限制可接受的标记序列。一般情况下，早期错误规则会规定，在某些上下文中，“_P_ <dfn id="must-cover">必须覆盖</dfn> _N_”，其中 _P_ 是解析节点（广义产生式的实例），_N_ 是补充文法中的非终结符。这表示：</p>
      <ol>
        <li>对 _P_ 最初匹配的标记序列，以 _N_ 作为目标符号再次解析。如果 _N_ 有文法参数，则使用 _P_ 最初解析时的参数值。</li>
        <li>如果标记序列能作为 _N_ 的唯一实例解析，且无剩余标记，则：
          <ol>
            <li>我们称该实例（唯一对应于某个 _P_ 的解析节点）为“_P_ 所<dfn>覆盖</dfn>的 _N_”。</li>
            <li>所有对 _N_ 及其派生产生式的早期错误规则也适用于 _P_ 所覆盖的 _N_。</li>
          </ol>
        </li>
        <li>否则（解析失败），则为早期语法错误。</li>
      </ol>
    </emu-clause>

    <emu-clause id="sec-grammar-notation" namespace="grammar-notation">
      <h1>文法记号</h1>

      <emu-clause id="sec-terminal-symbols">
        <h1>终结符号</h1>
        <p>在 ECMAScript 文法中，部分终结符以 `等宽字体` 展示。这些符号应在源文本中完全按原样出现。此类终结符指定的所有码点均应理解为基本拉丁区（Basic Latin block）中对应的 Unicode 码点，不包括其他 Unicode 区段中外观相似的码点。终结符中的码点不能用 `\\` |UnicodeEscapeSequence| 表示。</p>
        <p>在以单个 Unicode 码点为终结符的文法（即词法、正则和数值字符串文法）中，产生式中连续出现的多个等宽码点是一种简写，表示同样顺序的独立终结符。</p>
        <p>例如如下产生式：</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0x` HexDigits
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          HexIntegerLiteral :: `0` `x` HexDigits
        </emu-grammar>
        <p>而在句法文法中，连续的等宽码点则视为单一终结符。</p>
        <p>终结符还可以有两种形式：</p>
        <ul>
          <li>在词法和正则文法中，无传统印刷表示的 Unicode 码点以“&lt;ABBREV>”形式展示，其中“ABBREV”是该码点或码点集的助记符。这些形式在 <emu-xref href="#sec-unicode-format-control-characters" title></emu-xref>、<emu-xref href="#sec-white-space" title></emu-xref> 和 <emu-xref href="#sec-line-terminators" title></emu-xref> 中定义。</li>
          <li>在句法文法中，某些终结符（如 |IdentifierName| 和 |RegularExpressionLiteral|）以斜体显示，表示它们引用词法文法中同名非终结符。</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-nonterminal-symbols-and-productions">
        <h1>非终结符号和产生式</h1>
        <p>非终结符以<i>斜体</i>展示。非终结符的定义（也称“产生式”）由被定义的非终结符名称后跟一个或多个冒号引出。（冒号数量表明该产生式属于哪种文法。）随后为该非终结符的一个或多个备选右部。例如，句法定义：</p>
        <emu-grammar type="definition" example>
          WhileStatement :
            `while` `(` Expression `)` Statement
        </emu-grammar>
        <p>说明非终结符 |WhileStatement| 表示标记 `while`，后跟左括号标记，再跟 |Expression|，再跟右括号标记，最后跟 |Statement|。其中 |Expression| 和 |Statement| 本身也是非终结符。另一个例子，句法定义：</p>
        <emu-grammar type="definition" example>
          ArgumentList :
            AssignmentExpression
            ArgumentList `,` AssignmentExpression
        </emu-grammar>
        <p>说明 |ArgumentList| 可以表示单个 |AssignmentExpression|，或 |ArgumentList| 后跟逗号，再跟 |AssignmentExpression|。该定义是递归的，即用自身定义自身。因此 |ArgumentList| 可包含任意数量且大于零的参数，每个参数表达式为 |AssignmentExpression|，参数间以逗号分隔。此类递归定义很常见。</p>
      </emu-clause>

      <emu-clause id="sec-optional-symbols">
        <h1>可选符号</h1>
        <p>下标后缀“<sub>opt</sub>”用于终结符或非终结符之后，表示该符号为可选。包含可选符号的备选实际上指定了两个右部：一个省略可选元素，一个包含可选元素。即：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer?
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer
        </emu-grammar>
        <p>同理：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression? `)` Statement
        </emu-grammar>
        <p>进一步简写为：</p>
        <emu-grammar type="definition" example>
          ForStatement :
            `for` `(` LexicalDeclaration `;` `)` Statement
            `for` `(` LexicalDeclaration `;` Expression `)` Statement
            `for` `(` LexicalDeclaration Expression `;` `)` Statement
            `for` `(` LexicalDeclaration Expression `;` Expression `)` Statement
        </emu-grammar>
        <p>所以在此例中，非终结符 |ForStatement| 实际有四个备选右部。</p>
      </emu-clause>

      <emu-clause id="sec-grammatical-parameters">
        <h1>文法参数</h1>
        <p>产生式可以通过下标标注“<sub>[参数]</sub>”进行参数化，该标注可作为产生式定义的非终结符后缀。“<sub>参数</sub>”可以是单个名称或以逗号分隔的名称列表。参数化产生式是对一组产生式的简写，定义了所有参数名称组合，组合名以下划线为前缀，附加到参数化非终结符后。即：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>同理：</p>
        <emu-grammar type="definition" example>
          StatementList[Return, In] :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement

          StatementList_In :
            ReturnStatement
            ExpressionStatement

          StatementList_Return_In :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>多个参数会生成组合数量的产生式，但完整文法中并不一定全部引用。</p>
        <p>产生式右部对非终结符的引用也可以参数化。例如：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[+In]
        </emu-grammar>
        <p>等价于：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement_In
        </emu-grammar>
        <p>而：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement[~In]
        </emu-grammar>
        <p>等价于：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>非终结符引用可以同时有参数列表和“<sub>opt</sub>”后缀。例如：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer[+In]?
        </emu-grammar>
        <p>简写为：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>在右部非终结符引用上用“<sub>?</sub>”作为参数名前缀，使该参数取值依赖于当前产生式左部符号引用是否出现该参数。例如：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration[In] :
            BindingIdentifier Initializer[?In]
        </emu-grammar>
        <p>是如下写法的简写：</p>
        <emu-grammar type="definition" example>
          VariableDeclaration :
            BindingIdentifier Initializer

          VariableDeclaration_In :
            BindingIdentifier Initializer_In
        </emu-grammar>
        <p>如果右部备选以“[+参数]”为前缀，表示仅当引用产生式非终结符时使用了该参数名才可用该备选。如果以“[\~参数]”为前缀，则仅在未使用该参数名时可用该备选。即：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [+Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>简写为：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ExpressionStatement

          StatementList_Return :
            ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>同理：</p>
        <emu-grammar type="definition" example>
          StatementList[Return] :
            [~Return] ReturnStatement
            ExpressionStatement
        </emu-grammar>
        <p>简写为：</p>
        <emu-grammar type="definition" example>
          StatementList :
            ReturnStatement
            ExpressionStatement

          StatementList_Return :
            ExpressionStatement
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-one-of">
        <h1>one of</h1>
        <p>当“<b>one of</b>”出现在文法定义中的冒号后，表示后续每个终结符都是一个备选定义。例如 ECMAScript 的词法文法包含如下产生式：</p>
        <emu-grammar type="definition" example>
          NonZeroDigit :: one of
            `1` `2` `3` `4` `5` `6` `7` `8` `9`
        </emu-grammar>
        <p>实际上是如下简写：</p>
        <emu-grammar type="definition" example>
          NonZeroDigit ::
            `1`
            `2`
            `3`
            `4`
            `5`
            `6`
            `7`
            `8`
            `9`
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-empty">
        <h1>[empty]</h1>
        <p>如果“[empty]”出现在产生式右部，表示该产生式右部不包含任何终结符或非终结符。</p>
      </emu-clause>

      <emu-clause id="sec-lookahead-restrictions">
        <h1>前瞻限制</h1>
        <p>若“[lookahead = _seq_]”出现在产生式右部，表示只有当标记序列 _seq_ 是紧跟输入标记序列的前缀时，才能使用该产生式。同理，“[lookahead ∈ _set_]”，其中 _set_ 为有限非空标记序列集合，表示只有当集合中的某个元素是紧跟输入标记序列的前缀时才能使用该产生式。为了方便，也可以将集合写为非终结符，此时表示该非终结符可能扩展到的所有标记序列。若非终结符能扩展为无限多种不同标记序列，则视为编辑错误。</p>
        <p>这些条件可以取反。“[lookahead ≠ _seq_]”表示只有当 _seq_ <em>不是</em>紧跟输入标记序列的前缀时才能使用该产生式，而“[lookahead ∉ _set_]”表示只有当集合中无元素是紧跟输入标记序列的前缀时才能使用该产生式。</p>
        <p>例如，给定如下定义：</p>
        <emu-grammar type="definition" example>
          DecimalDigit :: one of
            `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

          DecimalDigits ::
            DecimalDigit
            DecimalDigits DecimalDigit
        </emu-grammar>
        <p>则如下定义：</p>
        <emu-grammar type="definition" example>
          LookaheadExample ::
            `n` [lookahead &notin; { `1`, `3`, `5`, `7`, `9` }] DecimalDigits
            DecimalDigit [lookahead &notin; DecimalDigit]
        </emu-grammar>
        <p>匹配字符 `n` 后跟一个或多个十进制数字，且首位为偶数，或匹配一个十进制数字且后面不再有十进制数字。</p>
        <p>注意，这些短语用于句法文法时，可能无法明确识别紧跟的标记序列，因为确定后续标记需要知道后续使用哪个词法目标符号。因此，在句法文法中使用这些短语时，若前缀标记序列 _seq_ 的词法目标符号选择会影响其是否作为结果标记序列前缀，则视为编辑错误。</p>
      </emu-clause>

      <emu-clause id="sec-no-lineterminator-here">
        <h1>[此处无 |LineTerminator|]</h1>
        <p>若“[no |LineTerminator| here]”出现在句法文法产生式右部，表示该产生式为<em>受限产生式</em>：若在指定位置的输入流中出现 |LineTerminator|，则不能使用该产生式。例如如下产生式：</p>
        <emu-grammar type="definition" example>
          ThrowStatement :
            `throw` [no LineTerminator here] Expression `;`
        </emu-grammar>
        <p>表示若在脚本中的 `throw` 标记和 |Expression| 之间出现 |LineTerminator|，则不能使用该产生式。</p>
        <p>除非受限产生式禁止出现 |LineTerminator|，否则在输入元素流的任意两个连续标记之间可以出现任意数量的 |LineTerminator|，不会影响脚本的语法合法性。</p>
      </emu-clause>

      <emu-clause id="sec-but-not">
        <h1>but not</h1>
        <p>产生式右部可用“<b>but not</b>”短语指定某些扩展不允许。例如如下产生式：</p>
        <emu-grammar type="definition" example>
          Identifier ::
            IdentifierName but not ReservedWord
        </emu-grammar>
        <p>表示非终结符 |Identifier| 可替换为可替换 |IdentifierName| 的任何码点序列，但不能替换为可替换 |ReservedWord| 的同一序列。</p>
      </emu-clause>

      <emu-clause id="sec-descriptive-phrases">
        <h1>描述性短语</h1>
        <p>最后，少数非终结符用无衬线字体描述性短语来说明，当枚举所有备选项不切实际时使用：</p>
        <emu-grammar type="definition" example>
          SourceCharacter ::
            &gt; 任意 Unicode 码点
        </emu-grammar>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-algorithm-conventions">
    <h1>算法约定</h1>
    <p>规范经常使用编号列表来指定算法步骤。这些算法用于精确定义 ECMAScript 语言结构所需的语义。算法并不意味着必须采用任何特定的实现技术。实际应用中，可能有更高效的算法可用于实现某个特性。</p>
    <p>算法可以显式使用有序、逗号分隔的别名序列进行参数化，在算法步骤中可以通过这些别名引用对应位置传入的参数。可选参数用括号（[ , _name_ ]）标记，在算法步骤中与必选参数没有区别。参数列表末尾可以出现剩余参数，用前置省略号（, ..._name_）标记。剩余参数会将所有必选和可选参数之后传入的参数收集到一个 List 中。如果没有额外参数，则该 List 为空。</p>
    <p>算法步骤可以细分为顺序子步骤。子步骤缩进显示，并且自身可以进一步划分为缩进子步骤。大纲编号用于标识子步骤：第一层使用小写字母，第二层使用小写罗马数字。如需超过三层，则第四层用数字编号。例如：</p>
    <emu-alg example>
      1. 顶层步骤
        1. 子步骤。
        1. 子步骤。
          1. 子子步骤。
            1. 子子子步骤
              1. 子子子子步骤
                1. 子子子子子步骤
    </emu-alg>
    <p>某个步骤或子步骤可以写成“if”条件，控制其子步骤。此时，只有条件为真时才执行子步骤。如果步骤或子步骤以“else”开头，则表示该条件是同级前一个“if”条件的否定。</p>
    <p>步骤可以指定对子步骤的迭代应用。</p>
    <p>以“<dfn id="assert">Assert</dfn>:”开头的步骤表示断言该算法的不变条件。这样的断言用于显式表达本应隐含的算法不变量，不增加语义要求，因此实现无需检查。它们仅用于澄清算法。</p>
    <p>算法步骤可以用“Let _x_ be _someValue_”声明命名别名。这些别名类似引用，即 _x_ 和 _someValue_ 都引用相同的数据，对任一的修改都可见。若算法步骤希望避免引用行为，应显式复制右侧值：“Let _x_ be a copy of _someValue_”会创建 _someValue_ 的浅复制。</p>
    <p>别名声明后可在后续步骤引用，但不可在声明前引用。别名可用“Set _x_ to _someOtherValue_”进行赋值。</p>

    <emu-clause id="sec-algorithm-conventions-abstract-operations">
      <h1>抽象操作</h1>
      <p>为便于在规范多个部分中使用，部分算法（称为<dfn>抽象操作</dfn>）采用命名并参数化的函数形式书写，以便在其他算法中通过名称引用。抽象操作通常以函数调用形式引用，如 OperationName(_arg1_, _arg2_)。有些抽象操作作为类似类的规范抽象的多态分派方法对待，这类方法通常以 _someValue_.OperationName(_arg1_, _arg2_) 形式引用。</p>
    </emu-clause>

    <emu-clause id="sec-algorithm-conventions-syntax-directed-operations">
      <h1>语法导向操作</h1>
      <p><dfn variants="syntax-directed operations">语法导向操作</dfn>是指以名称定义、由若干算法组成，并与 ECMAScript 某个文法中的一个或多个产生式关联的操作。具有多个备选定义的产生式通常为每个备选定义关联一个独立算法。若算法与某个文法产生式关联，则可将产生式备选中的终结符和非终结符视为算法参数进行引用。以此方式使用时，非终结符引用实际为解析源文本时匹配的具体备选定义。<dfn oldids="sec-static-semantics-sourcetext">某个文法产生式或其派生的解析节点所匹配的源文本</dfn>是指从第一个参与匹配的终结符开始到最后一个终结符结束的源文本片段。</p>
      <p>当算法与产生式备选关联时，备选一般不带“[ ]”文法标注。这些标注仅影响备选的句法识别，对备选相关语义无影响。</p>
      <p>语法导向操作通过解析节点和可选参数调用，具体调用方式见以下算法的 <emu-xref href="#step-sdo-invocation-example-1"></emu-xref>、<emu-xref href="#step-sdo-invocation-example-2"></emu-xref> 和 <emu-xref href="#step-sdo-invocation-example-3"></emu-xref> 步骤：</p>
      <emu-alg example>
        1. [id="step-sdo-invocation-example-1"] Let _status_ be SyntaxDirectedOperation of |SomeNonTerminal|.
        1. Let _someParseNode_ be the parse of some source text.
        1. [id="step-sdo-invocation-example-2"] Perform SyntaxDirectedOperation of _someParseNode_.
        1. [id="step-sdo-invocation-example-3"] Perform SyntaxDirectedOperation of _someParseNode_ with argument *"value"*.
      </emu-alg>
      <p>除非另有说明，所有链式产生式都隐含定义了对该产生式左部非终结符可应用的所有操作的隐含定义。隐含定义即对链式产生式唯一右部非终结符以相同参数重复应用同一操作，返回结果。例如，假设某算法有如下步骤：“Return Evaluation of |Block|”且有如下产生式：</p>
      <emu-grammar example>
        Block :
          `{` StatementList `}`
      </emu-grammar>
      <p>但 Evaluation 操作未与该产生式关联算法，则此时 Evaluation 操作隐含如下关联：</p>
      <p><b>运行时语义：Evaluation</b></p>
      <emu-grammar example>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg example>
        1. Return Evaluation of |StatementList|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics">
      <h1>运行时语义</h1>
      <p>指定运行时必须调用的语义的算法称为<dfn>运行时语义</dfn>。运行时语义通过抽象操作或语法导向操作定义。</p>

      <emu-clause id="sec-completion-ao" type="abstract operation">
        <h1>
          Completion (
            _completionRecord_: a Completion Record,
          ): a Completion Record
        </h1>
        <dl class="header">
          <dt>描述</dt>
          <dd>用于强调返回的是 Completion Record。</dd>
          <dt>跳过返回检查</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: _completionRecord_ 是 Completion Record。
          1. Return _completionRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throw-an-exception">
        <h1>抛出异常</h1>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Return ThrowCompletion(a newly created *TypeError* object).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt" aoid="ReturnIfAbrupt">
        <h1>ReturnIfAbrupt</h1>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_argument_).
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Assert: _argument_ 是 Completion Record。
          1. 如果 _argument_ 是异常完成，则返回 Completion(_argument_)。
          1. 否则，将 _argument_ 设为 _argument_.[[Value]]。
        </emu-alg>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(AbstractOperation()).
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Let _hygienicTemp_ be AbstractOperation().
          1. Assert: _hygienicTemp_ 是 Completion Record。
          1. 如果 _hygienicTemp_ 是异常完成，则返回 Completion(_hygienicTemp_)。
          1. 否则，将 _hygienicTemp_ 设为 _hygienicTemp_.[[Value]]。
        </emu-alg>
        <p>其中 _hygienicTemp_ 仅在 ReturnIfAbrupt 相关步骤中可见且为临时变量。</p>
        <p>算法步骤如：</p>
        <emu-alg example>
          1. Let _result_ be AbstractOperation(ReturnIfAbrupt(_argument_)).
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Assert: _argument_ 是 Completion Record。
          1. 如果 _argument_ 是异常完成，则返回 Completion(_argument_)。
          1. 否则，将 _argument_ 设为 _argument_.[[Value]]。
          1. Let _result_ be AbstractOperation(_argument_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returnifabrupt-shorthands">
        <h1>ReturnIfAbrupt 简记法</h1>
        <p>抽象操作和语法导向操作调用前加 `?` 表示应对返回的 Completion Record 应用 ReturnIfAbrupt。例如：</p>
        <emu-alg example>
          1. ? OperationName().
        </emu-alg>
        <p>等价于：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(OperationName()).
        </emu-alg>
        <p>类似地，方法调用风格：</p>
        <emu-alg example>
          1. ? _someValue_.OperationName().
        </emu-alg>
        <p>等价于：</p>
        <emu-alg example>
          1. ReturnIfAbrupt(_someValue_.OperationName()).
        </emu-alg>
        <p>类似地，前缀 `!` 表示后续抽象或语法导向操作的调用不会返回异常完成，结果应取 Completion Record 的 [[Value]] 字段作为操作的返回值。例如：</p>
        <emu-alg example>
          1. Let _val_ be ! OperationName().
        </emu-alg>
        <p>等价于：</p>
        <emu-alg example>
          1. Let _val_ be OperationName()。
          1. Assert: _val_ 是正常完成。
          1. Set _val_ to _val_.[[Value]]。
        </emu-alg>
        <p>运行时语义的语法导向操作会通过在操作调用前加 `!` 或 `?` 使用此简记法：</p>
        <emu-alg example>
          1. Perform ! SyntaxDirectedOperation of |NonTerminal|。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-implicit-normal-completion" oldids="sec-implicit-completion-values">
        <h1>隐式正常完成</h1>
        <p>对于声明为返回 Completion Record 的抽象操作算法以及所有内建函数，其返回值会先传递给 NormalCompletion，再使用结果。该规则不适用于 Completion 算法内部或返回值明确标为 Completion Record 的步骤；包括：</p>
        <ul>
          <li>直接返回 Completion、NormalCompletion、ThrowCompletion 或 ReturnCompletion 的结果</li>
          <li>直接返回构造的 Completion Record 的结果</li>
        </ul>
        <p>如果通过其他方式从此类抽象操作返回 Completion Record，则属于编辑错误。例如，在这些抽象操作中，</p>
        <emu-alg example>
          1. Return *true*.
        </emu-alg>
        <p>与如下语句含义相同：</p>
        <emu-alg example>
          1. Return NormalCompletion(*true*)。
        </emu-alg>
        <p>或</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*)。
          1. Return Completion(_completion_)。
        </emu-alg>
        <p>或</p>
        <emu-alg example>
          1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: *true*, [[Target]]: ~empty~ }。
        </emu-alg>
        <p>注意，通过 ReturnIfAbrupt 展开，以下写法允许，因为在展开步骤中，异常情况直接返回 Completion，正常情况在解包后隐式应用 NormalCompletion。</p>
        <emu-alg example>
          1. Return ? _completion_。
        </emu-alg>
        <p>以下示例则属于编辑错误，因为返回 Completion Record 时未在该步骤标注。</p>
        <emu-alg example>
          1. Let _completion_ be NormalCompletion(*true*)。
          1. Return _completion_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-static-semantic-rules">
      <h1>静态语义</h1>
      <p>上下文无关文法无法表达所有判断输入元素流是否能组成可求值的有效 ECMAScript |Script| 或 |Module| 的规则。在某些情况下需补充规则，可用 ECMAScript 算法约定或散文要求表达。这些规则总是与某个文法产生式关联，称为该产生式的<dfn>静态语义</dfn>。</p>
      <p>静态语义规则有名称，通常用算法定义。命名静态语义规则与文法产生式关联，具有多个备选定义的产生式通常为每个备选和每个适用的命名静态语义规则定义独立算法。</p>
      <p>一种特殊的静态语义规则是<dfn id="early-error-rule">早期错误规则</dfn>。早期错误规则定义了与特定文法产生式关联的早期错误条件（见 <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 条款）。大多数早期错误规则的判断不会在规范算法中显式调用。符合规范的实现必须在首次求值 |Script| 或 |Module| 之前，验证用于解析该 |Script| 或 |Module| 的所有产生式的早期错误规则。如果有任何早期错误规则被违反，则该 |Script| 或 |Module| 无效且不可求值。</p>
    </emu-clause>

    <emu-clause id="sec-mathematical-operations">
      <h1>数学运算</h1>
      <p>规范涉及以下数值类型：</p>
      <ul>
        <li><dfn id="mathematical-value" variants="mathematical value,mathematical values">数学值</dfn>：任意实数，作为默认数值类型。</li>
        <li><dfn id="extended-mathematical-value" variants="extended mathematical value,extended mathematical values">扩展数学值</dfn>：数学值加上 +∞ 和 -∞。</li>
        <li><em>Numbers</em>：IEEE 754-2019 binary64（双精度浮点数）值。</li>
        <li><em>BigInts</em>：ECMAScript 语言值，一一对应表示任意整数。</li>
      </ul>

      <p>在规范语言中，不同数值类型通过下标后缀区分。下标 <sub>𝔽</sub> 表示 Numbers，下标 <sub>ℤ</sub> 表示 BigInts。无下标后缀的数值表示数学值。规范多数数值以十进制表示，也用 0x 加数字 0-9 或 A-F 表示十六进制。</p>
      <p>一般来说，规范提及数值时，如“_y_ 的长度”或“四个十六进制数字表示的整数”，未显式说明数值类型时，指的是数学值。指明 Number 或 BigInt 时会明确标注，如“表示代码点数量的 Number 值”或“表示某值的 BigInt 值”。</p>
      <p>规范中的<dfn id="integer" oldids="mathematical integer" variants="integers">integer</dfn>指数学上的整数，除非另有说明。<dfn id="integral-number" oldids="sec-isintegralnumber,sec-isinteger" variants="integral Numbers">integral Number</dfn>指数学值为整数的有限 Number 值。</p>
      <p>如 +、×、=、≥ 等数值运算符，具体操作取决于操作数类型。用于数学值时为常规数学运算，扩展数学值时为扩展实数运算（不定义不定型，规范中出现为编辑错误），用于 Number 时为 IEEE 754-2019 运算，BigInt 时为 BigInt 的数学值运算。混合类型操作数（如 Number 与数学值）不定义，规范中出现为编辑错误。</p>
      <p>数学值与 Number 或 BigInt 间转换均为显式。数学值或扩展数学值 _x_ 转 Number 表示为“_x_ 的 Number 值”或 <emu-eqn id="𝔽" aoid="𝔽">𝔽(_x_)</emu-eqn>，见 <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>。整数 _x_ 转 BigInt 表示为“_x_ 的 <dfn id="bigint-value-for">BigInt 值</dfn>”或 <emu-eqn id="ℤ" aoid="ℤ">ℤ(_x_)</emu-eqn>。Number 或 BigInt _x_ 转数学值表示为“_x_ 的 <dfn id="mathematical-value-of">数学值</dfn>”或 <emu-eqn id="ℝ" aoid="ℝ">ℝ(_x_)</emu-eqn>。*+0*<sub>𝔽</sub> 和 *-0*<sub>𝔽</sub> 的数学值为 0，非有限值的数学值不定义。<dfn id="extended-mathematical-value-of">_x_ 的扩展数学值</dfn> 对于有限值为数学值，*+∞*<sub>𝔽</sub> 和 *-∞*<sub>𝔽</sub> 分别为 +∞ 和 -∞，*NaN* 不定义。</p>
      <p>数学函数 <emu-eqn id="eqn-abs" aoid="abs">abs(_x_)</emu-eqn> 返回 _x_ 的绝对值，即当 _x_ &lt; 0 时为 <emu-eqn>-_x_</emu-eqn>，否则为 _x_。</p>
      <p>数学函数 <emu-eqn id="eqn-min" aoid="min">min(_x1_, _x2_, … , _xN_)</emu-eqn> 取 <emu-eqn>_x1_</emu-eqn> 到 <emu-eqn>_xN_</emu-eqn> 中最小值，<emu-eqn id="eqn-max" aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn> 取最大值，定义域和值域为扩展数学值。</p>
      <p>记号“<emu-eqn id="eqn-modulo" aoid="modulo">_x_ 模 _y_</emu-eqn>”（_y_ 必须为有限且非零）计算与 _y_ 同号或为零的值 _k_，满足 <emu-eqn>abs(_k_) &lt; abs(_y_) 且 _x_ - _k_ = _q_ × _y_</emu-eqn>，其中 _q_ 为整数。</p>
      <p>“将 _x_ 限制在 _lower_ 与 _upper_ 之间”（_x_ 为扩展数学值，_lower_ 和 _upper_ 为满足 _lower_ ≤ _upper_ 的数学值）表示若 _x_ &lt; _lower_，则取 _lower_，若 _x_ > _upper_，则取 _upper_，否则取 _x_。</p>
      <p>数学函数 <emu-eqn id="eqn-floor" aoid="floor">floor(_x_)</emu-eqn> 返回不大于 _x_ 的最大整数（最接近 +∞）。</p>
      <emu-note>
        <p><emu-eqn>floor(_x_) = _x_ - (_x_ 模 1)</emu-eqn>。</p>
      </emu-note>
      <p>数学函数 <emu-eqn id="eqn-truncate" aoid="truncate">truncate(_x_)</emu-eqn> 通过向零舍入移除 _x_ 的小数部分，当 _x_ &lt; 0 时为 <emu-eqn>-floor(-_x_)</emu-eqn>，否则为 <emu-eqn>floor(_x_)</emu-eqn>。</p>
      <p>数学函数 min、max、abs、floor 和 truncate 不用于 Numbers 和 BigInts，对非数学值参数使用这些方法属于编辑错误。</p>
      <p><dfn id="interval">区间</dfn>从下界 _a_ 到上界 _b_，是同一数值类型的可能无限或空的数值集合。每个边界描述为闭或开，不可兼有。区间分为四种：</p>
      <ul>
        <li>从 _a_（闭）到 _b_（闭），亦称<dfn id="inclusive-interval">闭区间</dfn>，包含所有满足 _a_ ≤ _x_ ≤ _b_ 的同类型值 _x_。</li>
        <li>从 _a_（闭）到 _b_（开），包含所有满足 _a_ ≤ _x_ &lt; _b_ 的同类型值 _x_。</li>
        <li>从 _a_（开）到 _b_（闭），包含所有满足 _a_ &lt; _x_ ≤ _b_ 的同类型值 _x_。</li>
        <li>从 _a_（开）到 _b_（开），包含所有满足 _a_ &lt; _x_ &lt; _b_ 的同类型值 _x_。</li>
      </ul>
      <p>例如，1（闭）到 2（开）区间包含所有 1 到 2 之间的数学值，包括 1 不包括 2。定义区间时，*-0*<sub>𝔽</sub> &lt; *+0*<sub>𝔽</sub>，因此下界为 *+0*<sub>𝔽</sub> 的闭区间包含 *+0*<sub>𝔽</sub> 但不包含 *-0*<sub>𝔽</sub>。*NaN* 永不包含在区间内。</p>
    </emu-clause>

    <emu-clause id="sec-value-notation">
      <h1>值记号</h1>
      <p>本规范中，ECMAScript 语言值用 *粗体* 显示，如 *null*、*true* 或 *"hello"*。这与 ECMAScript 源文本（如 `Function.prototype.apply` 或 `let n = 42;`）区分开。</p>
    </emu-clause>

    <emu-clause id="sec-identity">
      <h1>同一性</h1>
      <p>本规范中，规范值和 ECMAScript 语言值都可进行相等性比较。比较时，值分为两类。<dfn variants="values without identity,value without identity">无同一性的值</dfn>，若所有固有特性相同（如整数的大小或序列的长度）则彼此相等。无同一性值可通过完全描述其特性直接表现，无需先前引用。相比之下，<dfn variants="values with identity">有同一性的值</dfn>是唯一的，仅与自身相等。有同一性的值除了拥有无同一性值的特性，还具有不可猜测、不可变、全局唯一的特性，称为<em>同一性</em>。对现有有同一性的值的引用不能仅通过描述其特性表现，同一性本身无法描述，必须显式传递。有同一性的值有些可变，可原地改变其特性（除了同一性），所有持有者都能观察到新特性。无同一性值永远不等于有同一性值。</p>
      <p>在规范角度，“is”用于比较两个值是否相等，例如“If _bool_ is *true*, then ...”；“contains”用于在列表中用相等性比较查找值，如“If _list_ contains a Record _r_ such that _r_.[[Foo]] is *true*, then ...”。规范值的<em>规范同一性</em>决定了这些比较结果，是规范中的公理。</p>
      <p>ECMAScript 语言角度，语言值通过 SameValue 抽象操作及其递归调用比较相等性。这些比较算法决定 ECMAScript 语言值的<em>语言同一性</em>。</p>
      <p>规范值中，无规范同一性的例子包括但不限于：数学值和扩展数学值；ECMAScript 源文本、代理对、指令序言等；UTF-16 码元；Unicode 码点；枚举；抽象操作（包括语法导向操作、宿主钩子等）；有序对。有规范同一性的例子包括但不限于：各种记录（包括属性描述符、PrivateElements 等）；解析节点；列表；<emu-xref href="#sec-set-and-relation-specification-type">集合</emu-xref>与关系；抽象闭包；数据块；私有名称；执行上下文及上下文栈；代理标识符；WaiterList 记录。</p>
      <p>对所有 ECMAScript 语言值，除由 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 生成的 Symbol 外，规范同一性与语言同一性一致。无规范同一性且无语言同一性的 ECMAScript 语言值包括 <emu-xref href="#sec-ecmascript-language-types-undefined-type">*undefined*</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-null-type">*null*</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-boolean-type">Boolean</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-string-type">String</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-number-type">Number</emu-xref>、<emu-xref href="#sec-ecmascript-language-types-bigint-type">BigInt</emu-xref>。有规范同一性和语言同一性的 ECMAScript 语言值包括 <emu-xref href="#sec-ecmascript-language-types-symbol-type">Symbol</emu-xref>（非 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 生成）和 <emu-xref href="#sec-object-type">Object</emu-xref>。由 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 生成的 Symbol 有规范同一性但无语言同一性。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript 数据类型和值</h1>
  <p>本规范中的算法操作的值都具有相关的类型。可能的值类型正是本条款中定义的类型。类型进一步分为 ECMAScript 语言类型和规范类型。</p>

  <emu-clause id="sec-ecmascript-language-types">
    <h1>ECMAScript 语言类型</h1>
    <p><dfn variants="ECMAScript language types">ECMAScript 语言类型</dfn>对应于 ECMAScript 编程人员可直接通过 ECMAScript 语言操作的值。ECMAScript 语言类型包括 Undefined、Null、Boolean、String、Symbol、Number、BigInt 和 Object。<dfn variants="ECMAScript language values">ECMAScript 语言值</dfn>是指具有 ECMAScript 语言类型特征的值。</p>

    <emu-clause id="sec-ecmascript-language-types-undefined-type">
      <h1>Undefined 类型</h1>
      <p>Undefined 类型只有一个值，称为 *undefined*。任何尚未赋值的变量，其值均为 *undefined*。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-null-type">
      <h1>Null 类型</h1>
      <p>Null 类型只有一个值，称为 *null*。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-boolean-type">
      <h1>Boolean 类型</h1>
      <p><dfn variants="is a Boolean,is not a Boolean">Boolean 类型</dfn>表示一个逻辑实体，具有两个值，分别为 *true* 和 *false*。</p>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-string-type">
      <h1>String 类型</h1>
      <p><dfn variants="is a String,is not a String">String 类型</dfn>是所有有序的零个或多个 16 位无符号整数值（“元素”）序列的集合，最大长度为 2<sup>53</sup> - 1 个元素。String 类型通常用于表示 ECMAScript 程序中的文本数据，此时每个元素都被视为一个 UTF-16 码元值。每个元素被认为在序列中占据一个位置，这些位置用非负整数索引。第一个元素（如果有）索引为 0，第二个元素索引为 1，依此类推。String 的长度即其包含的元素（即 16 位值）数。空字符串长度为零，因此不含任何元素。</p>
      <p>未解释字符串内容的 ECMAScript 操作不施加进一步语义。解释字符串值的操作则将每个元素视为单个 UTF-16 码元。然而，ECMAScript 不限制这些码元的值或相互关系，因此进一步将字符串内容解释为 UTF-16 编码的 Unicode 码点序列时，必须考虑不规范的子序列。此类操作会对数值在闭区间 0xD800 到 0xDBFF 的码元（Unicode 标准定义为 <dfn id="leading-surrogate" variants="leading surrogates">前导代理</dfn>，或正式称为 <dfn id="high-surrogate-code-unit" variants="high-surrogate code units">高代理码元</dfn>）以及闭区间 0xDC00 到 0xDFFF 的码元（定义为 <dfn id="trailing-surrogate" variants="trailing surrogates">后导代理</dfn>，或正式称为 <dfn id="low-surrogate-code-unit" variants="low-surrogate code units">低代理码元</dfn>）做如下处理：</p>
      <ul>
        <li>
          既不是前导代理也不是后导代理的码元，按其数值解释为码点。
        </li>
        <li>
          两个码元组成的序列，第一个码元 _c1_ 为前导代理，第二个码元 _c2_ 为后导代理，则为一个<dfn id="surrogate-pair" variants="surrogate pairs">代理对</dfn>，按码点值 (_c1_ - 0xD800) × 0x400 + (_c2_ - 0xDC00) + 0x10000 解释。（见 <emu-xref href="#sec-utf16decodesurrogatepair"></emu-xref>）
        </li>
        <li>
          独立的前导代理或后导代理码元（未作为代理对的一部分），按其数值解释为码点。
        </li>
      </ul>
      <p>可使用 `String.prototype.normalize`（见 <emu-xref href="#sec-string.prototype.normalize"></emu-xref>）显式规范化字符串值。`String.prototype.localeCompare`（见 <emu-xref href="#sec-string.prototype.localecompare"></emu-xref>）会在内部规范化字符串值，但其它操作不会隐式规范化其操作的字符串。操作结果除非另有说明，否则不具备语言或区域敏感性。</p>
      <emu-note>
        <p>该设计的理由是使字符串实现尽量简单且高效。如果 ECMAScript 源文本为标准化形式 C，则字符串字面量也一定是标准化的，只要其中不包含 Unicode 转义序列。</p>
      </emu-note>
      <p>在本规范中，“the <dfn id="string-concatenation">string-concatenation</dfn> of _A_, _B_, ...”（每个参数为字符串值、码元或码元序列）表示顺序连接每个参数的码元后得到的字符串值。</p>
      <p>“the <dfn id="substring">substring</dfn> of _S_ from _inclusiveStart_ to _exclusiveEnd_”（_S_ 为字符串值或码元序列，_inclusiveStart_ 和 _exclusiveEnd_ 为整数）表示从索引 _inclusiveStart_ 到紧邻索引 _exclusiveEnd_ 之前的顺序码元组成的字符串值（当 _inclusiveStart_ = _exclusiveEnd_ 时为空字符串）。若省略 "to" 后缀，则 _exclusiveEnd_ 取 _S_ 的长度。</p>
      <p>
        “<dfn id="ASCII-word-characters">the ASCII word characters</dfn>”表示如下字符串值，仅包含 Unicode 基本拉丁区的所有字母和数字以及 U+005F（下划线）：<br>
        *"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"*。<br>
        出于历史原因，在多种算法中具有特殊意义。
      </p>

      <emu-clause id="sec-stringindexof" type="abstract operation">
        <h1>
          StringIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 的长度。
          1. 如果 _searchValue_ 是空字符串且 _fromIndex_ ≤ _len_，返回 _fromIndex_。
          1. 令 _searchLen_ 为 _searchValue_ 的长度。
          1. 对每个满足 _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_ 的整数 _i_，按升序执行
            1. 令 _candidate_ 为 _string_ 从 _i_ 到 _i_ + _searchLen_ 的子串。
            1. 如果 _candidate_ 等于 _searchValue_，返回 _i_。
          1. 返回 ~not-found~。
        </emu-alg>
        <emu-note>
          <p>如果 _searchValue_ 是空字符串且 _fromIndex_ ≤ _string_ 的长度，则返回 _fromIndex_。空字符串在字符串的每个位置都可找到，包括最后一个码元之后。</p>
        </emu-note>
        <emu-note>
          <p>如果 _fromIndex_ + _searchValue_ 的长度大于 _string_ 的长度，则本算法总是返回 ~not-found~。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-stringlastindexof" type="abstract operation">
        <h1>
          StringLastIndexOf (
            _string_: a String,
            _searchValue_: a String,
            _fromIndex_: a non-negative integer,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _string_ 的长度。
          1. 令 _searchLen_ 为 _searchValue_ 的长度。
          1. Assert: _fromIndex_ + _searchLen_ ≤ _len_。
          1. 对每个满足 0 ≤ _i_ ≤ _fromIndex_ 的整数 _i_，按降序执行
            1. 令 _candidate_ 为 _string_ 从 _i_ 到 _i_ + _searchLen_ 的子串。
            1. 如果 _candidate_ 等于 _searchValue_，返回 _i_。
          1. 返回 ~not-found~。
        </emu-alg>
        <emu-note>
          <p>如果 _searchValue_ 是空字符串，则算法返回 _fromIndex_。空字符串在字符串的每个位置都可找到，包括最后一个码元之后。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-language-types-symbol-type">
      <h1>Symbol 类型</h1>
      <p><dfn variants="is a Symbol,is not a Symbol">Symbol 类型</dfn>是所有可用作对象属性键的非字符串值的集合（<emu-xref href="#sec-object-type"></emu-xref>）。</p>
      <p>每个 Symbol 都是唯一且不可变的。</p>
      <p>每个 Symbol 都有一个不可变的 [[Description]] 内部槽，其值为字符串或 *undefined*。</p>

      <emu-clause id="sec-well-known-symbols">
        <h1>知名 Symbol</h1>
        <p>知名 Symbol 是规范算法明确引用的内建 Symbol 值。它们通常用作属性键，这些属性的值作为规范算法的扩展点。除非另有说明，知名 Symbol 在所有 realm（<emu-xref href="#sec-code-realms"></emu-xref>）间共享。</p>
        <p>在本规范中，知名 Symbol 使用标准的 <emu-xref href="#sec-well-known-intrinsic-objects">内在记号</emu-xref>引用，其中内在对象为 <emu-xref href="#table-well-known-symbols"></emu-xref> 所列值之一。</p>
        <emu-note>规范的早期版本采用 @@name 记号，而本版本采用 %Symbol.name%。具体包括：@@asyncIterator、@@hasInstance、@@isConcatSpreadable、@@<emu-not-ref>iterator</emu-not-ref>、@@match、@@matchAll、@@replace、@@search、@@species、@@split、@@toPrimitive、@@toStringTag 和 @@unscopables。</emu-note>
        <emu-table id="table-well-known-symbols" caption="知名 Symbol" oldids="table-1">
          <table>
            <thead>
              <tr>
                <th>
                  规范名称
                </th>
                <th>
                  [[Description]]
                </th>
                <th>
                  值及用途
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                <dfn>%Symbol.asyncIterator%</dfn>
              </td>
              <td>
                *"Symbol.asyncIterator"*
              </td>
              <td>
                返回对象默认异步迭代器的方法。由 `for`-`await`-`of` 语句语义调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.hasInstance%</dfn>
              </td>
              <td>
                *"Symbol.hasInstance"*
              </td>
              <td>
                判断构造函数对象是否识别某对象为其实例的方法。由 `instanceof` 运算符语义调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.isConcatSpreadable%</dfn>
              </td>
              <td>
                *"Symbol.isConcatSpreadable"*
              </td>
              <td>
                一个布尔属性，若为 true 则 <emu-xref href="#sec-array.prototype.concat">`Array.prototype.concat`</emu-xref> 会将对象按数组元素展开。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.iterator%</dfn>
              </td>
              <td>
                *"Symbol.iterator"*
              </td>
              <td>
                返回对象默认迭代器的方法。由 for-of 语句语义调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.match%</dfn>
              </td>
              <td>
                *"Symbol.match"*
              </td>
              <td>
                正则表达式方法，用于匹配字符串。由 <emu-xref href="#sec-string.prototype.match">`String.prototype.match`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.matchAll%</dfn>
              </td>
              <td>
                *"Symbol.matchAll"*
              </td>
              <td>
                正则表达式方法，返回迭代器，用于遍历字符串的所有匹配项。由 <emu-xref href="#sec-string.prototype.matchall">`String.prototype.matchAll`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.replace%</dfn>
              </td>
              <td>
                *"Symbol.replace"*
              </td>
              <td>
                正则表达式方法，用于替换字符串中的匹配子串。由 <emu-xref href="#sec-string.prototype.replace">`String.prototype.replace`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.search%</dfn>
              </td>
              <td>
                *"Symbol.search"*
              </td>
              <td>
                正则表达式方法，返回匹配字符串的索引。由 <emu-xref href="#sec-string.prototype.search">`String.prototype.search`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.species%</dfn>
              </td>
              <td>
                *"Symbol.species"*
              </td>
              <td>
                一个函数属性，是用于创建派生对象的构造函数。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.split%</dfn>
              </td>
              <td>
                *"Symbol.split"*
              </td>
              <td>
                正则表达式方法，用于在匹配索引处分割字符串。由 <emu-xref href="#sec-string.prototype.split">`String.prototype.split`</emu-xref> 方法调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toPrimitive%</dfn>
              </td>
              <td>
                *"Symbol.toPrimitive"*
              </td>
              <td>
                将对象转换为对应原始值的方法。由 ToPrimitive 抽象操作调用。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.toStringTag%</dfn>
              </td>
              <td>
                *"Symbol.toStringTag"*
              </td>
              <td>
                用于创建对象默认字符串描述的字符串属性。通过内建方法 <emu-xref href="#sec-object.prototype.tostring">`Object.prototype.toString`</emu-xref> 访问。
              </td>
            </tr>
            <tr>
              <td>
                <dfn>%Symbol.unscopables%</dfn>
              </td>
              <td>
                *"Symbol.unscopables"*
              </td>
              <td>
                一个对象属性，其自身和继承的属性名是关联对象的 `with` 环境绑定中被排除的属性名。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-numeric-types">
      <h1>数值类型</h1>
      <p>ECMAScript 有两种内建数值类型：Number 和 BigInt。以下抽象操作定义于这些数值类型之上。“结果”列显示返回类型，同时指明部分调用可能返回异常完成。</p>
      <emu-table id="table-numeric-type-ops" caption="数值类型操作">
        <table>
          <thead>
            <tr>
              <th>
                操作
              </th>
              <th>
                示例源码
              </th>
              <th>
                在...的求值语义中调用
              </th>
              <th>
                结果
              </th>
            </tr>
          </thead>

          <tr>
            <td>
              Number::unaryMinus
            </td>
            <td rowspan="2">
              `-x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unary-minus-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unaryMinus
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseNOT
            </td>
            <td rowspan="2">
              `~x`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-bitwise-not-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseNOT
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::exponentiate
            </td>
            <td rowspan="2">
              `x&nbsp;**&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-exp-operator" title></emu-xref>
              and <emu-xref href="#sec-math.pow" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::exponentiate
            </td>
            <td>
              返回正常完成的 BigInt 或抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::multiply
            </td>
            <td rowspan="2">
              `x&nbsp;*&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::multiply
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::divide
            </td>
            <td rowspan="2">
              `x&nbsp;/&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::divide
            </td>
            <td>
              返回正常完成的 BigInt 或抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::remainder
            </td>
            <td rowspan="2">
              `x&nbsp;%&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-multiplicative-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::remainder
            </td>
            <td>
              返回正常完成的 BigInt 或抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::add
            </td>
            <td rowspan="2">
              `x ++`<br>
              `++ x`<br>
              `x&nbsp;+&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-increment-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-increment-operator" title></emu-xref>,
              and <emu-xref href="#sec-addition-operator-plus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::add
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::subtract
            </td>
            <td rowspan="2">
              `x --`<br>
              `-- x`<br>
              `x&nbsp;-&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-postfix-decrement-operator" title></emu-xref>,
              <emu-xref href="#sec-prefix-decrement-operator" title></emu-xref>,
              and <emu-xref href="#sec-subtraction-operator-minus" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::subtract
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::leftShift
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&lt;&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-left-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::leftShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::signedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-signed-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::signedRightShift
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::unsignedRightShift
            </td>
            <td rowspan="2">
              `x&nbsp;>>>&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-unsigned-right-shift-operator" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::unsignedRightShift
            </td>
            <td>
              抛出完成
            </td>
          </tr>

          <tr>
            <td>
              Number::lessThan
            </td>
            <td rowspan="2">
              `x&nbsp;&lt;&nbsp;y`<br>
              `x&nbsp;>&nbsp;y`<br>
              `x&nbsp;&lt;=&nbsp;y`<br>
              `x&nbsp;>=&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-relational-operators" title></emu-xref>,
              via <emu-xref href="#sec-islessthan" title></emu-xref>
            </td>
            <td>
              Boolean 或 *undefined*（用于无序输入）
            </td>
          </tr>

          <tr>
            <td>
              BigInt::lessThan
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::equal
            </td>
            <td rowspan="2">
              `x&nbsp;==&nbsp;y`<br>
              `x&nbsp;!=&nbsp;y`<br>
              `x&nbsp;===&nbsp;y`<br>
              `x&nbsp;!==&nbsp;y`
            </td>
            <td rowspan="2">
              <emu-xref href="#sec-equality-operators" title></emu-xref>,
              via <emu-xref href="#sec-isstrictlyequal" title></emu-xref>
            </td>
            <td rowspan="2">
              Boolean
            </td>
          </tr>
          <tr>
            <td>
              BigInt::equal
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValue
            </td>
            <td>
              `Object.is(x, y)`
            </td>
            <td>
              对象内部方法，
              via <emu-xref href="#sec-samevalue" title></emu-xref>，
              用于测试精确值相等性
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::sameValueZero
            </td>
            <td>
              `[x].includes(y)`
            </td>
            <td>
              via <emu-xref href="#sec-samevaluezero" title></emu-xref>，
              用于测试值相等性，忽略 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub> 的区别，如 Array、Map 和 Set 方法
            </td>
            <td>
              Boolean
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseAND
            </td>
            <td rowspan="2">
              `x&nbsp;&amp;&nbsp;y`
            </td>
            <td rowspan="6">
              <emu-xref href="#sec-binary-bitwise-operators" title></emu-xref>
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseAND
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseXOR
            </td>
            <td rowspan="2">
              `x&nbsp;^&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseXOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::bitwiseOR
            </td>
            <td rowspan="2">
              `x&nbsp;|&nbsp;y`
            </td>
            <td>
              Number
            </td>
          </tr>
          <tr>
            <td>
              BigInt::bitwiseOR
            </td>
            <td>
              BigInt
            </td>
          </tr>

          <tr>
            <td>
              Number::toString
            </td>
            <td rowspan="2">
              `String(x)`
            </td>
            <td rowspan="2">
              多种表达式和内建函数，via <emu-xref href="#sec-tostring" title></emu-xref>
            </td>
            <td rowspan="2">
              String
            </td>
          </tr>
          <tr>
            <td>
              BigInt::toString
            </td>
          </tr>
        </table>
      </emu-table>
      <p>由于数值类型通常无法在不丢失精度或截断的情况下进行转换，ECMAScript 语言不提供这些类型之间的隐式转换。程序员必须显式调用 `Number` 和 `BigInt` 函数来在调用需要另一种类型的函数时进行类型转换。</p>
      <emu-note>
        <p>ECMAScript 的第一版及后续版本为某些运算符提供了可能丢失精度或截断的隐式数值转换。为了兼容旧代码，这些传统的隐式转换仍然保留，但对于 BigInt 不再提供，以最大程度减少程序员出错的机会，并为将来版本支持更广泛的 <em>值类型</em> 留下空间。</p>
      </emu-note>

      <emu-clause id="sec-ecmascript-language-types-number-type">
        <h1>Number 类型</h1>
        <p><dfn variants="是 Number,不是 Number">Number 类型</dfn>一共有 18,437,736,874,454,810,627 个值（即 <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>），表示 IEEE 754-2019 binary64 双精度浮点数值，遵循 IEEE 二进制浮点运算标准。不同于 IEEE 标准的 9,007,199,254,740,990 个 NaN 值（即 <emu-eqn>2<sup>53</sup> - 2</emu-eqn>），ECMAScript 将这些 NaN 都表示为一个特殊的 *NaN* 值。（注意，*NaN* 值可由表达式 `NaN` 得到。）在某些实现中，外部代码可能能区分不同的 NaN，但这种行为由实现定义；对于 ECMAScript 代码，所有 *NaN* 都无法区分。</p>
        <emu-note>
          <p>将 Number 值存入 ArrayBuffer（参见 <emu-xref href="#sec-arraybuffer-objects"></emu-xref>）或 SharedArrayBuffer（参见 <emu-xref href="#sec-sharedarraybuffer-objects"></emu-xref>）后观察到的比特模式，不一定与 ECMAScript 内部表示该 Number 值的方式一致。</p>
        </emu-note>
        <p>还有两个特殊值，称为 *正无穷* 和 *负无穷*。为了简便，分别用符号 *+∞*<sub>𝔽</sub> 和 *-∞*<sub>𝔽</sub> 表示。（注意，这两个无限值可由表达式 `+Infinity`（或简写为 `Infinity`）和 `-Infinity` 得到。）</p>
        <p>其余 18,437,736,874,454,810,624 个值（即 <emu-eqn>2<sup>64</sup> - 2<sup>53</sup></emu-eqn>）称为 <dfn id="finite">有限</dfn>数值。这些数值一半为正，一半为负，对于每一个有限的正数，都有一个相同绝对值的负数。</p>
        <p>注意，存在 *正零* 和 *负零*。为了简便，分别用符号 *+0*<sub>𝔽</sub> 和 *-0*<sub>𝔽</sub> 表示。（注意，这两个零值可由表达式 `+0`（或简写为 `0`）和 `-0` 得到。）</p>
        <p>18,437,736,874,454,810,622 个有限非零值（即 <emu-eqn>2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>）分为两类：</p>
        <p>其中 18,428,729,675,200,069,632 个（即 <emu-eqn>2<sup>64</sup> - 2<sup>54</sup></emu-eqn>）是规格化的，形式为：</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>其中 _s_ 为 1 或 -1，_m_ 是区间 [2<sup>52</sup>, 2<sup>53</sup>) 内的整数，_e_ 为 [-1074, 971] 间的整数。</p>
        <p>剩下的 9,007,199,254,740,990 个值（即 <emu-eqn>2<sup>53</sup> - 2</emu-eqn>）是非规格化的，形式为：</p>
        <div class="math-display">
          _s_ × _m_ × 2<sup>_e_</sup>
        </div>
        <p>其中 _s_ 为 1 或 -1，_m_ 是 (0, 2<sup>52</sup>) 区间的整数，_e_ 等于 -1074。</p>
        <p>注意，所有绝对值不超过 2<sup>53</sup> 的正负整数都能用 Number 类型表示。整数 0 在 Number 类型中有两种表示：*+0*<sub>𝔽</sub> 和 *-0*<sub>𝔽</sub>。</p>
        <p>有限数值如果非零且表达式中的整数 _m_ 为奇数，则称其为 <em>奇有效数字</em>；否则为 <em>偶有效数字</em>。</p>
        <p>在本规范中，“<dfn id="number-value-for" oldids="number-value">_x_ 的 Number 值</dfn>”表示 _x_ 是某个精确的数学实数（甚至可能是无理数如 π），其 Number 值按如下方式选取：取所有有限 Number 类型值的集合，去掉 *-0*<sub>𝔽</sub> 并加上两个 Number 类型不可表示的值，即 2<sup>1024</sup>（即 <emu-eqn>+1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>）和 <emu-eqn>-2<sup>1024</sup></emu-eqn>（即 <emu-eqn>-1 × 2<sup>53</sup> × 2<sup>971</sup></emu-eqn>）。选取与 _x_ 最接近的集合成员。如果有两个值一样接近，则选有效数字为偶数的那个；这时额外的两个值 2<sup>1024</sup> 和 <emu-eqn>-2<sup>1024</sup></emu-eqn> 被认为是偶有效数字。最后，如果选中 2<sup>1024</sup>，则用 *+∞*<sub>𝔽</sub> 替换；如果选中 <emu-eqn>-2<sup>1024</sup></emu-eqn>，则用 *-∞*<sub>𝔽</sub> 替换；如果选中 *+0*<sub>𝔽</sub>，则仅当 _x_ &lt; 0 时替换为 *-0*<sub>𝔽</sub>；其他选中的值不变。结果就是 _x_ 的 Number 值。（此过程与 IEEE 754-2019 的 roundTiesToEven 模式完全一致。）</p>
        <p>+∞ 的 Number 值为 *+∞*<sub>𝔽</sub>，-∞ 的 Number 值为 *-∞*<sub>𝔽</sub>。</p>
        <p>某些 ECMAScript 运算符只处理范围特定的整数，比如 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 或 [0, 2<sup>16</sup> - 1]。这些运算符接受任意 Number 类型值，但会先将其转换为预期范围的整数。具体转换见 <emu-xref href="#sec-type-conversion"></emu-xref>。</p>

        <emu-clause id="sec-numeric-types-number-unaryMinus" type="numeric method">
          <h1>
            Number::unaryMinus (
              _x_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *NaN*。
            1. 返回 _x_ 的相反数；即生成一个数值，大小相同，符号相反。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseNOT" type="numeric method">
          <h1>
            Number::bitwiseNOT (
              _x_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _oldValue_ 为 ! ToInt32(_x_)。
            1. 返回 _oldValue_ 的按位取反。结果的数学值正好能表示为一个 32 位补码二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-exponentiate" type="numeric method" oldids="sec-applying-the-exp-operator">
          <h1>
            Number::exponentiate (
              _base_: 一个 Number,
              _exponent_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>返回一个实现近似的值，表示 _base_ 的 _exponent_ 次幂。</dd>
          </dl>
          <emu-alg>
            1. 如果 _exponent_ 是 *NaN*，返回 *NaN*。
            1. 如果 _exponent_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *1*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *NaN*，返回 *NaN*。
            1. 如果 _base_ 是 *+∞*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *-∞*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-∞*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
              1. 否则：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-0*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *+0*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
            1. 如果 _base_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _exponent_ > *+0*<sub>𝔽</sub>：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-0*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
              1. 否则：
                1. 如果 _exponent_ 是奇数整数 Number，返回 *-∞*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
            1. 断言：_base_ 是有限值且不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>。
            1. 如果 _exponent_ 是 *+∞*<sub>𝔽</sub>：
              1. 如果 abs(ℝ(_base_)) > 1，返回 *+∞*<sub>𝔽</sub>。
              1. 如果 abs(ℝ(_base_)) = 1，返回 *NaN*。
              1. 如果 abs(ℝ(_base_)) &lt; 1，返回 *+0*<sub>𝔽</sub>。
            1. 如果 _exponent_ 是 *-∞*<sub>𝔽</sub>：
              1. 如果 abs(ℝ(_base_)) > 1，返回 *+0*<sub>𝔽</sub>。
              1. 如果 abs(ℝ(_base_)) = 1，返回 *NaN*。
              1. 如果 abs(ℝ(_base_)) &lt; 1，返回 *+∞*<sub>𝔽</sub>。
            1. 断言：_exponent_ 是有限值且不是 *+0*<sub>𝔽</sub> 也不是 *-0*<sub>𝔽</sub>。
            1. 如果 _base_ &lt; *-0*<sub>𝔽</sub> 且 _exponent_ 不是整数 Number，返回 *NaN*。
            1. 返回一个实现近似的 Number 值，表示 ℝ(_base_) 的 ℝ(_exponent_) 次幂。
          </emu-alg>
          <emu-note>
            <p>当 _base_ 为 *1*<sub>𝔽</sub> 或 *-1*<sub>𝔽</sub>，且 _exponent_ 为 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，或当 _base_ 为 *1*<sub>𝔽</sub> 且 _exponent_ 为 *NaN* 时，_base_ `**` _exponent_ 的结果与 IEEE 754-2019 不同。ECMAScript 第一版规定此操作结果为 *NaN*，而后续 IEEE 754 修订版规定为 *1*<sub>𝔽</sub>。此处保留 ECMAScript 历史行为以兼容。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-multiply" type="numeric method" oldids="sec-applying-the-mul-operator">
          <h1>
            Number::multiply (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>按 IEEE 754-2019 双精度算术规则执行乘法，得到 _x_ 和 _y_ 的乘积。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 或 _y_ 是 *NaN*，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _y_ > *+0*<sub>𝔽</sub>，返回 _x_。
              1. 返回 -_x_。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>：
              1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _x_ > *+0*<sub>𝔽</sub>，返回 _y_。
              1. 返回 -_y_。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *-0*<sub>𝔽</sub> 或 _y_ &lt; *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
              1. 否则，返回 *-0*<sub>𝔽</sub>。
            1. 如果 _y_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _x_ &lt; *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
              1. 否则，返回 *-0*<sub>𝔽</sub>。
            1. 返回 𝔽(ℝ(_x_) × ℝ(_y_))。
          </emu-alg>
          <emu-note>
            <p>有限精度乘法是可交换的，但不总是结合的。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-divide" type="numeric method" oldids="sec-applying-the-div-operator">
          <h1>
            Number::divide (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>按 IEEE 754-2019 双精度算术规则执行除法，得到 _x_ 除以 _y_ 的商，其中 _x_ 为被除数，_y_ 为除数。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 或 _y_ 是 *NaN*，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _y_ 是 *+0*<sub>𝔽</sub> 或 _y_ > *+0*<sub>𝔽</sub>，返回 _x_。
              1. 返回 -_x_。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub>：
              1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 _x_ > *+0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>；否则返回 *-0*<sub>𝔽</sub>。
            1. 如果 _y_ 是 *-∞*<sub>𝔽</sub>：
              1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 _x_ > *+0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>；否则返回 *+0*<sub>𝔽</sub>。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>：
              1. 如果 _y_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
              1. 如果 _y_ > *+0*<sub>𝔽</sub>，返回 _x_。
              1. 返回 -_x_。
            1. 如果 _y_ 是 *+0*<sub>𝔽</sub>：
              1. 如果 _x_ > *+0*<sub>𝔽</sub>，返回 *+∞*<sub>𝔽</sub>；否则返回 *-∞*<sub>𝔽</sub>。
            1. 如果 _y_ 是 *-0*<sub>𝔽</sub>：
              1. 如果 _x_ > *+0*<sub>𝔽</sub>，返回 *-∞*<sub>𝔽</sub>；否则返回 *+∞*<sub>𝔽</sub>。
            1. 返回 𝔽(ℝ(_x_) / ℝ(_y_))。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-remainder" type="numeric method" oldids="sec-applying-the-mod-operator">
          <h1>
            Number::remainder (
              _n_: 一个 Number,
              _d_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>产生隐式除法的余数，其中 _n_ 为被除数，_d_ 为除数。</dd>
          </dl>
          <emu-alg>
            1. 如果 _n_ 或 _d_ 是 *NaN*，返回 *NaN*。
            1. 如果 _n_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _d_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 _n_。
            1. 如果 _d_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _n_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 _n_。
            1. 断言：_n_ 和 _d_ 都是有限且非零值。
            1. 令 _quotient_ 为 ℝ(_n_) / ℝ(_d_)。
            1. 令 _q_ 为 truncate(_quotient_)。
            1. 令 _r_ 为 ℝ(_n_) - (ℝ(_d_) × _q_)。
            1. 如果 _r_ = 0 且 _n_ &lt; *-0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回 𝔽(_r_)。
          </emu-alg>
          <emu-note>
            <p>C 和 C++ 的余数运算符只接受整数操作数；而 ECMAScript 也接受浮点数操作数。</p>
          </emu-note>
          <emu-note>浮点数余数运算 `%` 的结果与 IEEE 754-2019 中定义的“余数”操作不同。IEEE 的余数操作基于四舍五入除法，而非截断除法，因此行为不同于通常的 <emu-not-ref>整数</emu-not-ref> 余数运算符。ECMAScript 定义 `%` 运算针对浮点数时的行为类似于 Java <emu-not-ref>整数</emu-not-ref> 余数运算符；可与 C 库函数 fmod 作比较。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-add" type="numeric method" oldids="sec-applying-the-additive-operators-to-numbers">
          <h1>
            Number::add (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>按 IEEE 754-2019 双精度算术规则执行加法，产生两个参数的和。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 或 _y_ 是 *NaN*，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 且 _y_ 是 *-∞*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _x_ 是 *-∞*<sub>𝔽</sub> 且 _y_ 是 *+∞*<sub>𝔽</sub>，返回 *NaN*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 _x_。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub> 或 *-∞*<sub>𝔽</sub>，返回 _y_。
            1. 断言：_x_ 和 _y_ 都是有限值。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回 𝔽(ℝ(_x_) + ℝ(_y_))。
          </emu-alg>
          <emu-note>
            <p>有限精度加法是可交换的，但不总是结合的。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-subtract" type="numeric method">
          <h1>
            Number::subtract (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>执行减法，产生操作数的差值；_x_ 为被减数，_y_ 为减数。</dd>
          </dl>
          <emu-alg>
            1. 返回 Number::add(_x_, Number::unaryMinus(_y_))。
          </emu-alg>
          <emu-note>
            <p>始终有 `x - y` 的结果与 `x + (-y)` 相同。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-leftShift" type="numeric method">
          <h1>
            Number::leftShift (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToInt32(_x_)。
            1. 令 _rNum_ 为 ! ToUint32(_y_)。
            1. 令 _shiftCount_ 为 ℝ(_rNum_) 模 32。
            1. 返回将 _lNum_ 左移 _shiftCount_ 位的结果。结果的数学值正好能表示为 32 位补码二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-signedRightShift" type="numeric method">
          <h1>
            Number::signedRightShift (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToInt32(_x_)。
            1. 令 _rNum_ 为 ! ToUint32(_y_)。
            1. 令 _shiftCount_ 为 ℝ(_rNum_) 模 32。
            1. 返回将 _lNum_ 进行符号扩展右移 _shiftCount_ 位的结果。最高位会被扩展。结果的数学值正好能表示为 32 位补码二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-unsignedRightShift" type="numeric method">
          <h1>
            Number::unsignedRightShift (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToUint32(_x_)。
            1. 令 _rNum_ 为 ! ToUint32(_y_)。
            1. 令 _shiftCount_ 为 ℝ(_rNum_) 模 32。
            1. 返回将 _lNum_ 进行零填充右移 _shiftCount_ 位的结果。空出的位用零填充。结果的数学值正好能表示为 32 位无符号二进制串。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-lessThan" type="numeric method">
          <h1>
            Number::lessThan (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean 或 *undefined*
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *undefined*。
            1. 如果 _y_ 是 *NaN*，返回 *undefined*。
            1. 如果 _x_ 等于 _y_，返回 *false*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _y_ 是 *+∞*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _y_ 是 *-∞*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *-∞*<sub>𝔽</sub>，返回 *true*。
            1. 断言：_x_ 和 _y_ 都是有限值。
            1. 如果 ℝ(_x_) &lt; ℝ(_y_)，返回 *true*；否则返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-equal" type="numeric method">
          <h1>
            Number::equal (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *false*。
            1. 如果 _y_ 是 *NaN*，返回 *false*。
            1. 如果 _x_ 等于 _y_，返回 *true*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValue" type="numeric method">
          <h1>
            Number::sameValue (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 和 _y_ 都是 *NaN*，返回 *true*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *false*。
            1. 如果 _x_ 等于 _y_，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-sameValueZero" type="numeric method">
          <h1>
            Number::sameValueZero (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ 和 _y_ 都是 *NaN*，返回 *true*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 且 _y_ 是 *-0*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _x_ 是 *-0*<sub>𝔽</sub> 且 _y_ 是 *+0*<sub>𝔽</sub>，返回 *true*。
            1. 如果 _x_ 等于 _y_，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numberbitwiseop" type="abstract operation">
          <h1>
            NumberBitwiseOp (
              _op_: `&amp;`, `^`, 或 `|`,
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _lNum_ 为 ! ToInt32(_x_)。
            1. 令 _rNum_ 为 ! ToInt32(_y_)。
            1. 令 _lBits_ 为表示 ℝ(_lNum_) 的 32 位补码二进制串。
            1. 令 _rBits_ 为表示 ℝ(_rNum_) 的 32 位补码二进制串。
            1. 如果 _op_ 是 `&amp;`：
              1. 令 _result_ 为对 _lBits_ 和 _rBits_ 应用按位与操作的结果。
            1. 否则如果 _op_ 是 `^`：
              1. 令 _result_ 为对 _lBits_ 和 _rBits_ 应用按位异或操作的结果。
            1. 否则：
              1. 断言 _op_ 为 `|`。
              1. 令 _result_ 为对 _lBits_ 和 _rBits_ 应用按位或操作的结果。
            1. 返回由 32 位补码二进制串 _result_ 表示的整数的 Number 值。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseAND" type="numeric method">
          <h1>
            Number::bitwiseAND (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 NumberBitwiseOp(`&amp;`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseXOR" type="numeric method">
          <h1>
            Number::bitwiseXOR (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 NumberBitwiseOp(`^`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-bitwiseOR" type="numeric method">
          <h1>
            Number::bitwiseOR (
              _x_: 一个 Number,
              _y_: 一个 Number,
            ): 一个整数 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 NumberBitwiseOp(`|`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-number-tostring" type="numeric method" oldids="sec-tostring-applied-to-the-number-type">
          <h1>
            Number::toString (
              _x_: 一个 Number,
              _radix_: 2 到 36 之间的整数,
            ): 一个字符串
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>用基数 _radix_ 的位置数字系统将 _x_ 表示为字符串。用基数 _r_ 时，数字取自 *"0123456789abcdefghijklmnopqrstuvwxyz"* 的前 _r_ 个码位。表示绝对值大于等于 *1*<sub>𝔽</sub> 的数时，结果不会包含前导零。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ 是 *NaN*，返回 *"NaN"*。
            1. 如果 _x_ 是 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *"0"*。
            1. 如果 _x_ &lt; *-0*<sub>𝔽</sub>，返回 *"-"* 与 Number::toString(-_x_, _radix_) 的拼接字符串。
            1. 如果 _x_ 是 *+∞*<sub>𝔽</sub>，返回 *"Infinity"*。
            1. [id="step-number-tostring-intermediate-values"] 令 _n_、_k_、_s_ 为整数，满足 _k_ ≥ 1，_radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>，𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) 为 _x_，且 _k_ 尽可能小。注意 _k_ 是用基数 _radix_ 表示 _s_ 时的位数，_s_ 不能被 _radix_ 整除，且最低位未必唯一。
            1. 如果 _radix_ ≠ 10 或 _n_ 在 -5 到 21 的区间内：
              1. 如果 _n_ ≥ _k_：
                1. 返回拼接字符串：
                  * 用基数 _radix_ 表示 _s_ 的 _k_ 位数字
                  * _n_ - _k_ 个 0x0030（数字零）码位
              1. 否则如 _n_ > 0：
                1. 返回拼接字符串：
                  * 用基数 _radix_ 表示 _s_ 的最高 _n_ 位数字
                  * 0x002E（英文句点）
                  * 剩余 _k_ - _n_ 位数字
              1. 否则：
                1. 断言：_n_ ≤ 0。
                1. 返回拼接字符串：
                  * 0x0030（数字零）码位
                  * 0x002E（英文句点）
                  * -_n_ 个 0x0030（数字零）码位
                  * 用基数 _radix_ 表示 _s_ 的 _k_ 位数字
            1. 注意：此时输入会用科学 E 记数法表示，如 `1.2e+3`。
            1. 断言：_radix_ 为 10。
            1. 如果 _n_ &lt; 0：
              1. 令 _exponentSign_ 为 0x002D（减号）。
            1. 否则：
              1. 令 _exponentSign_ 为 0x002B（加号）。
            1. 如果 _k_ = 1：
              1. 返回拼接字符串：
                * _s_ 的单一数字码位
                * 0x0065（小写字母 e）
                * _exponentSign_
                * abs(_n_ - 1) 的十进制表示码位
            1. 返回拼接字符串：
              * _s_ 十进制表示的最高位数字码位
              * 0x002E（英文句点）
              * _s_ 十进制表示的剩余 _k_ - 1 位码位
              * 0x0065（小写字母 e）
              * _exponentSign_
              * abs(_n_ - 1) 的十进制表示码位
          </emu-alg>
          <emu-note>
            <p>以下观察可为实现提供参考，但不是标准的规范要求：</p>
            <ul>
              <li>
                除 *-0*<sub>𝔽</sub> 外，任意 Number 值 x 都满足 ToNumber(ToString(x)) === x。
              </li>
              <li>
                步骤 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 中 _s_ 的最低位不总是唯一确定。
              </li>
            </ul>
          </emu-note>
          <emu-note>
            <p>对于提供比上述规则更精确转换的实现，建议参考如下步骤 <emu-xref href="#step-number-tostring-intermediate-values"></emu-xref> 的替代版本：</p>
            <emu-alg replaces-step="step-number-tostring-intermediate-values">
              1. 令 _n_、_k_、_s_ 为整数，满足 _k_ ≥ 1，_radix_<sup>_k_ - 1</sup> ≤ _s_ &lt; _radix_<sup>_k_</sup>，𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) 为 _x_，且 _k_ 尽可能小。如果有多个 _s_，选择 _s_ × _radix_<sup>_n_ - _k_</sup> 最接近 ℝ(_x_) 的那个；如有两个结果，选偶数的那个。注意 _k_ 是用基数 _radix_ 表示 _s_ 的位数，且 _s_ 不能被 _radix_ 整除。
            </emu-alg>
          </emu-note>
          <emu-note>
            <p>ECMAScript 实现者可参考 David M. Gay 关于浮点数二进制到十进制转换的论文和代码：</p>
            <p>
              Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). 1990 年 11 月 30 日。参见<br>
              <a href="https://ampl.com/_archive/first-website/REFS/rounding.pdf">https://ampl.com/_archive/first-website/REFS/rounding.pdf</a>。相关代码见<br>
              <a href="http://netlib.sandia.gov/fp/dtoa.c">http://netlib.sandia.gov/fp/dtoa.c</a> 以及<br>
              <a href="http://netlib.sandia.gov/fp/g_fmt.c">http://netlib.sandia.gov/fp/g_fmt.c</a>，也可在多个 `netlib` 镜像站点找到。
            </p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ecmascript-language-types-bigint-type">
        <h1>BigInt 类型</h1>
        <p><dfn variants="是 BigInt,不是 BigInt">BigInt 类型</dfn>表示整数值。该值可以为任意大小，不受特定位宽限制。通常，除非另有说明，相关操作都设计为返回精确的数学答案。对于二元运算，BigInt 被视为二进制补码字符串，负数则被视为左边有无限个被置位的位。</p>

        <emu-clause id="sec-numeric-types-bigint-unaryMinus" type="numeric method">
          <h1>
            BigInt::unaryMinus (
              _x_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = *0*<sub>ℤ</sub>，返回 *0*<sub>ℤ</sub>。
            1. 返回 -_x_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseNOT" type="numeric method">
          <h1>
            BigInt::bitwiseNOT (
              _x_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>返回 _x_ 的按位取反（一元补码）。</dd>
          </dl>
          <emu-alg>
            1. 返回 -_x_ - *1*<sub>ℤ</sub>。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-exponentiate" type="numeric method">
          <h1>
            BigInt::exponentiate (
              _base_: 一个 BigInt,
              _exponent_: 一个 BigInt,
            ): 正常返回一个 BigInt 或抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _exponent_ &lt; *0*<sub>ℤ</sub>，抛出 *RangeError* 异常。
            1. 如果 _base_ = *0*<sub>ℤ</sub> 且 _exponent_ = *0*<sub>ℤ</sub>，返回 *1*<sub>ℤ</sub>。
            1. 返回 _base_ 的 _exponent_ 次幂。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-multiply" type="numeric method">
          <h1>
            BigInt::multiply (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 _x_ × _y_。
          </emu-alg>
          <emu-note>即使结果的位宽远大于输入，返回的也是精确的数学答案。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-divide" type="numeric method">
          <h1>
            BigInt::divide (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 正常返回一个 BigInt 或抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _y_ = *0*<sub>ℤ</sub>，抛出 *RangeError* 异常。
            1. 令 _quotient_ 为 ℝ(_x_) / ℝ(_y_)。
            1. 返回 ℤ(truncate(_quotient_))。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-remainder" type="numeric method">
          <h1>
            BigInt::remainder (
              _n_: 一个 BigInt,
              _d_: 一个 BigInt,
            ): 正常返回一个 BigInt 或抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _d_ = *0*<sub>ℤ</sub>，抛出 *RangeError* 异常。
            1. 如果 _n_ = *0*<sub>ℤ</sub>，返回 *0*<sub>ℤ</sub>。
            1. 令 _quotient_ 为 ℝ(_n_) / ℝ(_d_)。
            1. 令 _q_ 为 ℤ(truncate(_quotient_))。
            1. 返回 _n_ - (_d_ × _q_)。
          </emu-alg>
          <emu-note>结果的符号与被除数一致。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-add" type="numeric method">
          <h1>
            BigInt::add (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 _x_ + _y_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-subtract" type="numeric method">
          <h1>
            BigInt::subtract (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 _x_ - _y_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-leftShift" type="numeric method">
          <h1>
            BigInt::leftShift (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _y_ &lt; *0*<sub>ℤ</sub>，
              1. 返回 ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>))。
            1. 返回 _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>。
          </emu-alg>
          <emu-note>此处的语义应等价于按位移位，将 BigInt 视为无限长度的二进制补码数字串。</emu-note>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-signedRightShift" type="numeric method">
          <h1>
            BigInt::signedRightShift (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigInt::leftShift(_x_, -_y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-unsignedRightShift" type="numeric method">
          <h1>
            BigInt::unsignedRightShift (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 抛出异常
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 抛出 *TypeError* 异常。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-lessThan" type="numeric method">
          <h1>
            BigInt::lessThan (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 ℝ(_x_) &lt; ℝ(_y_)，返回 *true*；否则返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-equal" type="numeric method" oldids="sec-numeric-types-bigint-sameValue,sec-numeric-types-bigint-sameValueZero">
          <h1>
            BigInt::equal (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 ℝ(_x_) = ℝ(_y_)，返回 *true*；否则返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryand" type="abstract operation">
          <h1>
            BinaryAnd (
              _x_: 0 或 1,
              _y_: 0 或 1,
            ): 0 或 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = 1 且 _y_ = 1，返回 1。
            1. 否则，返回 0。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryor" type="abstract operation">
          <h1>
            BinaryOr (
              _x_: 0 或 1,
              _y_: 0 或 1,
            ): 0 或 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = 1 或 _y_ = 1，返回 1。
            1. 否则，返回 0。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-binaryxor" type="abstract operation">
          <h1>
            BinaryXor (
              _x_: 0 或 1,
              _y_: 0 或 1,
            ): 0 或 1
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 如果 _x_ = 1 且 _y_ = 0，返回 1。
            1. 否则如果 _x_ = 0 且 _y_ = 1，返回 1。
            1. 否则，返回 0。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-bigintbitwiseop" type="abstract operation">
          <h1>
            BigIntBitwiseOp (
              _op_: `&amp;`, `^`, 或 `|`,
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _x_ 为 ℝ(_x_)。
            1. 令 _y_ 为 ℝ(_y_)。
            1. 令 _result_ 为 0。
            1. 令 _shift_ 为 0。
            1. 重复，直到 (_x_ = 0 或 _x_ = -1) 且 (_y_ = 0 或 _y_ = -1) 为止，
              1. 令 _xDigit_ 为 _x_ 模 2。
              1. 令 _yDigit_ 为 _y_ 模 2。
              1. 如果 _op_ 是 `&amp;`，
                1. 令 _result_ 为 _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_)。
              1. 否则如果 _op_ 是 `|`，
                1. 令 _result_ 为 _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_)。
              1. 否则，
                1. 断言：_op_ 为 `^`。
                1. 令 _result_ 为 _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_)。
              1. 令 _shift_ 为 _shift_ + 1。
              1. 令 _x_ 为 (_x_ - _xDigit_) / 2。
              1. 令 _y_ 为 (_y_ - _yDigit_) / 2。
            1. 如果 _op_ 是 `&amp;`，
              1. 令 _tmp_ 为 BinaryAnd(_x_ 模 2, _y_ 模 2)。
            1. 否则如果 _op_ 是 `|`，
              1. 令 _tmp_ 为 BinaryOr(_x_ 模 2, _y_ 模 2)。
            1. 否则，
              1. 断言：_op_ 为 `^`。
              1. 令 _tmp_ 为 BinaryXor(_x_ 模 2, _y_ 模 2)。
            1. 如果 _tmp_ ≠ 0，
              1. 令 _result_ 为 _result_ - 2<sup>_shift_</sup>。
              1. 注意：此操作会扩展符号位。
            1. 返回 _result_ 的 BigInt 值。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseAND" type="numeric method">
          <h1>
            BigInt::bitwiseAND (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigIntBitwiseOp(`&amp;`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseXOR" type="numeric method">
          <h1>
            BigInt::bitwiseXOR (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigIntBitwiseOp(`^`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-bitwiseOR" type="numeric method">
          <h1>
            BigInt::bitwiseOR (
              _x_: 一个 BigInt,
              _y_: 一个 BigInt,
            ): 一个 BigInt
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 返回 BigIntBitwiseOp(`|`, _x_, _y_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-numeric-types-bigint-tostring" type="numeric method">
          <h1>
            BigInt::toString (
              _x_: 一个 BigInt,
              _radix_: 2 到 36 之间的整数,
            ): 一个字符串
          </h1>
          <dl class="header">
            <dt>说明</dt>
            <dd>用基数 _radix_ 的位置数字系统将 _x_ 表示为字符串。用基数 _r_ 表示 BigInt 时，数字取自 *"0123456789abcdefghijklmnopqrstuvwxyz"* 的前 _r_ 个码位。除 *0*<sub>ℤ</sub> 外，BigInt 的表示不会包含前导零。</dd>
          </dl>
          <emu-alg>
            1. 如果 _x_ &lt; *0*<sub>ℤ</sub>，返回 *"-"* 和 BigInt::toString(-_x_, _radix_) 的拼接字符串。
            1. 返回用基数 _radix_ 表示 _x_ 的字符串值。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-type">
      <h1>对象类型</h1>
      <p>每个 <dfn variants="是 Object,不是 Object">Object 类型</dfn>的实例，也简称为“对象”，表示一组属性的集合。每个属性要么是数据属性，要么是访问器属性：</p>
      <ul>
        <li>
          <dfn variants="数据属性">数据属性</dfn>将一个键值与一个 ECMAScript 语言值以及一组布尔属性关联起来。
        </li>
        <li>
          <dfn variants="访问器属性">访问器属性</dfn>将一个键值与一个或两个访问器函数以及一组布尔属性关联起来。访问器函数用于存储或获取与该属性相关联的 ECMAScript 语言值。
        </li>
      </ul>
      <p>对象的属性通过属性键唯一标识。<dfn id="property-key" variants="属性键" oldids="sec-ispropertykey">属性键</dfn>可以是字符串或符号。所有字符串和符号，包括空字符串，都是有效的属性键。<dfn id="property-name">属性名</dfn>是属性键为字符串的情况。</p>
      <p><dfn id="integer-index" variants="整数索引,integer-indexed">整数索引</dfn>是属性名 _n_，满足 CanonicalNumericIndexString(_n_) 返回一个在 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>53</sup> - 1) 的闭区间内的整数 Number。<dfn id="array-index" variants="数组索引">数组索引</dfn>是整数索引 _n_，且 CanonicalNumericIndexString(_n_) 返回一个在 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>32</sup> - 2) 的闭区间内的整数 Number。</p>
      <emu-note>
        <p>每个非负安全整数都有对应的整数索引。每个 32 位无符号整数（除 <emu-eqn>2<sup>32</sup> - 1</emu-eqn>）都有对应的数组索引。*"-0"* 既不是整数索引，也不是数组索引。</p>
      </emu-note>
      <p>属性键用于访问属性及其值。属性有两种访问方式：<em>获取</em>和<em>设置</em>，分别对应值的读取和赋值。可通过 get 和 set 访问的属性包括作为对象直接组成部分的<em>自身属性</em>和通过属性继承关系由其他关联对象提供的<em>继承属性</em>。继承属性可以是关联对象的自身属性或继承属性。对象的每个自身属性都必须有一个与该对象其他自身属性不同的键值。</p>
      <p>所有对象在逻辑上都是属性的集合，但对象有多种形式，不同形式在访问和操作属性时语义有所区别。参见 <emu-xref href="#sec-object-internal-methods-and-internal-slots"></emu-xref> 以了解对象的多种形式定义。</p>
      <p>此外，某些对象可调用，被称为函数或函数对象，详见下文。所有 ECMAScript 中的函数都是 Object 类型成员。</p>

      <emu-clause id="sec-property-attributes">
        <h1>属性特性</h1>
        <p>本规范使用属性（attributes）来定义和解释对象属性的状态，详见 <emu-xref href="#table-object-property-attributes"></emu-xref>。除非明确说明，每个属性的初始值为其默认值。</p>
        <emu-table id="table-object-property-attributes" caption="对象属性的特性" oldids="table-2,table-3,table-4,table-data-property-attributes,table-accessor-property-attributes,table-default-attribute-values">
          <table>
            <thead>
              <tr>
                <th>特性名称</th>
                <th>适用属性类型</th>
                <th>值域</th>
                <th>默认值</th>
                <th>描述</th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                数据属性
              </td>
              <td>
                一个 ECMAScript 语言值
              </td>
              <td>
                *undefined*
              </td>
              <td>
                通过 get 访问属性时获得的值。
              </td>
            </tr>
            <tr>
              <td>
                [[Writable]]
              </td>
              <td>
                数据属性
              </td>
              <td>
                布尔值
              </td>
              <td>
                *false*
              </td>
              <td>
                如果为 *false*，则 ECMAScript 代码通过 [[Set]] 尝试改变属性的 [[Value]] 特性不会成功。
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                访问器属性
              </td>
              <td>
                对象或 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                如果值是对象，则必须为函数对象。每次对属性进行 get 访问时，调用该函数的 [[Call]] 内部方法（参见 <emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>），参数列表为空，以获取属性值。
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                访问器属性
              </td>
              <td>
                对象或 *undefined*
              </td>
              <td>
                *undefined*
              </td>
              <td>
                如果值是对象，则必须为函数对象。每次对属性进行 set 访问时，调用该函数的 [[Call]] 内部方法（参见 <emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref>），参数列表只包含要赋值的值。属性的 [[Set]] 内部方法的效果可以影响后续 [[Get]] 的返回值，但不是必须的。
              </td>
            </tr>
            <tr>
              <td>
                [[Enumerable]]
              </td>
              <td>
                数据属性或访问器属性
              </td>
              <td>
                布尔值
              </td>
              <td>
                *false*
              </td>
              <td>
                如果为 *true*，属性会被 for-in 枚举（参见 <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>）；否则，该属性被称为不可枚举。
              </td>
            </tr>
            <tr>
              <td>
                [[Configurable]]
              </td>
              <td>
                数据属性或访问器属性
              </td>
              <td>
                布尔值
              </td>
              <td>
                *false*
              </td>
              <td>
                如果为 *false*，尝试删除属性、将其从数据属性变为访问器属性或反之，以及对其特性的任何修改（除了替换已有 [[Value]] 或设置 [[Writable]] 为 *false*）都不会成功。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>对象的内部方法与内部槽</h1>
        <p>ECMAScript 中对象的实际语义通过称为<em>内部方法</em>的算法来定义。每个 ECMAScript 引擎中的对象都关联一组内部方法，定义其运行时行为。这些内部方法不是 ECMAScript 语言的一部分，仅供规范说明之用。但 ECMAScript 的每个对象都必须符合其关联的内部方法的行为，具体实现方式由实现决定。</p>
        <p>内部方法名称是多态的。意味着不同对象值在调用相同内部方法名时可以执行不同的算法。被调用的实际对象是该方法的“目标”。如果在运行时算法实现尝试使用一个对象未支持的内部方法，则抛出 *TypeError* 异常。</p>
        <p>内部槽对应于与对象、Symbol 或私有名称关联的内部状态，被 ECMAScript 规范的各种算法使用。内部槽不是对象属性，也不会被继承。根据具体内部槽的规定，这些状态可以是任意 ECMAScript 类型值或特定 ECMAScript 规范类型值。除非另有说明，内部槽在创建对象、Symbol 或私有名称时分配，不能动态添加。除非另有说明，内部槽的初始值是 *undefined*。本规范中的各种算法会创建具有内部槽的值。但 ECMAScript 语言无法直接操作内部槽。</p>
        <p>所有对象都有名为 [[PrivateElements]] 的内部槽，是一个 PrivateElements 列表，表示对象的私有字段、方法和访问器的值。初始为一个空列表。</p>
        <p>规范中用双中括号 [[ ]] 标识内部方法和内部槽。</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref> 总结了本规范用于所有 ECMAScript 创建或操作的对象所适用的<em>基本内部方法</em>。每个对象必须实现所有这些基本内部方法的算法，但并不一定所有对象都用相同的算法。</p>
        <p><dfn id="ordinary-object" variants="普通对象">普通对象</dfn>是满足以下条件的对象：</p>
        <ul>
          <li>
            对于 <emu-xref href="#table-essential-internal-methods"></emu-xref> 列出的内部方法，对象采用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中定义的方法。
          </li>
          <li>
            如果对象有 [[Call]] 内部方法，则采用 <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 或 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref> 中定义的方法。
          </li>
          <li>
            如果对象有 [[Construct]] 内部方法，则采用 <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 或 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 中定义的方法。
          </li>
        </ul>
        <p><dfn id="exotic-object" variants="特殊对象">特殊对象</dfn>是不满足普通对象条件的对象。</p>
        <p>本规范通过对象的内部方法区分不同类型的特殊对象。如果一个对象在行为上等同于某种特殊对象（如数组特殊对象或绑定函数特殊对象），但没有实现该类型指定的所有内部方法，则不被视为该类型的特殊对象。</p>
        <p><emu-xref href="#table-essential-internal-methods"></emu-xref>和类似表格的“签名”列描述了每个内部方法的调用模式。调用模式总包括一个括号包裹的参数名列表。如果参数名与 ECMAScript 类型名相同，则表示该参数值必须为该类型。如果内部方法显式返回值，则参数列表后跟符号“→”和返回值类型名。签名中类型名指本规范 <emu-xref href="#sec-ecmascript-data-types-and-values"></emu-xref> 定义的类型，并补充如下额外类型名。“<em>any</em>”表示值可以是任意 ECMAScript 语言类型。</p>
        <p>除了参数之外，内部方法始终能访问作为方法调用目标的对象。</p>
        <p>内部方法隐式返回一个 Completion Record，要么是包装返回类型值的正常完成，要么是抛出完成。</p>
        <emu-table id="table-essential-internal-methods" caption="基本内部方法" oldids="table-5">
          <table>
            <thead>
              <tr>
                <th>
                  内部方法
                </th>
                <th>
                  签名
                </th>
                <th>
                  描述
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[GetPrototypeOf]]
              </td>
              <td>
                ( ) <b>→</b> Object | Null
              </td>
              <td>
                获取为此对象提供继承属性的对象。*null* 表示没有继承属性。
              </td>
            </tr>
            <tr>
              <td>
                [[SetPrototypeOf]]
              </td>
              <td>
                (Object | Null) <b>→</b> Boolean
              </td>
              <td>
                将此对象与另一个提供继承属性的对象关联。传递 *null* 表示没有继承属性。返回 *true* 表示操作成功，返回 *false* 表示操作未成功。
              </td>
            </tr>
            <tr>
              <td>
                [[IsExtensible]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                判断是否允许向此对象添加新属性。
              </td>
            </tr>
            <tr>
              <td>
                [[PreventExtensions]]
              </td>
              <td>
                ( ) <b>→</b> Boolean
              </td>
              <td>
                控制是否可向对象添加新属性。返回 *true* 表示操作成功，*false* 表示操作失败。
              </td>
            </tr>
            <tr>
              <td>
                [[GetOwnProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Undefined | Property Descriptor
              </td>
              <td>
                返回此对象自身属性中键为 _propertyKey_ 的属性描述符，若无则返回 *undefined*。
              </td>
            </tr>
            <tr>
              <td>
                [[DefineOwnProperty]]
              </td>
              <td>
                (_propertyKey_, _PropertyDescriptor_) <b>→</b> Boolean
              </td>
              <td>
                创建或更改自身属性（键为 _propertyKey_），使其状态与 _PropertyDescriptor_ 描述一致。成功时返回 *true*，否则返回 *false*。
              </td>
            </tr>
            <tr>
              <td>
                [[HasProperty]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                返回布尔值，表示此对象是否已有自身或继承属性，其键为 _propertyKey_。
              </td>
            </tr>
            <tr>
              <td>
                [[Get]]
              </td>
              <td>
                (_propertyKey_, _Receiver_) <b>→</b> <em>any</em>
              </td>
              <td>
                获取此对象中键为 _propertyKey_ 的属性值。若需执行 ECMAScript 代码以获取属性值，则 _Receiver_ 作为 *this* 值用于代码执行。
              </td>
            </tr>
            <tr>
              <td>
                [[Set]]
              </td>
              <td>
                (_propertyKey_, _value_, _Receiver_) <b>→</b> Boolean
              </td>
              <td>
                将键为 _propertyKey_ 的属性值设为 _value_。若需执行 ECMAScript 代码以设置属性值，则 _Receiver_ 作为 *this* 值用于代码执行。成功返回 *true*，否则返回 *false*。
              </td>
            </tr>
            <tr>
              <td>
                [[Delete]]
              </td>
              <td>
                (_propertyKey_) <b>→</b> Boolean
              </td>
              <td>
                删除自身属性键为 _propertyKey_ 的属性。删除失败且属性仍在时返回 *false*，否则返回 *true*。
              </td>
            </tr>
            <tr>
              <td>
                [[OwnPropertyKeys]]
              </td>
              <td>
                ( ) <b>→</b> 属性键列表
              </td>
              <td>
                返回对象所有自身属性键的列表。
              </td>
            </tr>
          </table>
        </emu-table>
        <p><emu-xref href="#table-additional-essential-internal-methods-of-function-objects"></emu-xref> 总结了函数对象支持的附加基本内部方法。<dfn id="function-object" variants="函数对象">函数对象</dfn>是支持 [[Call]] 内部方法的对象。<dfn id="constructor" variants="构造函数">构造函数</dfn>是支持 [[Construct]] 内部方法的对象。每个支持 [[Construct]] 的对象都必须支持 [[Call]]，即每个构造函数也是函数对象。因此构造函数也可称为<em>构造函数对象</em>。</p>
        <emu-table id="table-additional-essential-internal-methods-of-function-objects" caption="函数对象的附加基本内部方法" oldids="table-6">
          <table>
            <thead>
              <tr>
                <th>
                  内部方法
                </th>
                <th>
                  签名
                </th>
                <th>
                  描述
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Call]]
              </td>
              <td>
                (<em>any</em>, <em>any</em> 列表) <b>→</b> <em>any</em>
              </td>
              <td>
                执行与此对象关联的代码。通过函数调用表达式调用。方法参数为 *this* 值及调用表达式传递的参数列表。实现此方法的对象为<em>可调用</em>对象。
              </td>
            </tr>
            <tr>
              <td>
                [[Construct]]
              </td>
              <td>
                (<em>any</em> 列表, Object) <b>→</b> Object
              </td>
              <td>
                创建对象。通过 `new` 操作符或 `super` 调用。第一个参数为构造器调用或 `super` 调用的参数列表，第二个参数为最初应用 `new` 操作符的对象。实现此方法的对象为<em>构造函数</em>。函数对象不一定是构造函数，非构造函数对象没有 [[Construct]] 方法。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>普通对象和标准特殊对象的基本内部方法语义在 <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref> 中定义。如果实现不支持对某特殊对象指定的内部方法，则尝试该用法时必须抛出 *TypeError* 异常。</p>
      </emu-clause>

      <emu-clause id="sec-invariants-of-the-essential-internal-methods">
        <h1>基本内部方法的不变量</h1>
        <p>ECMAScript 引擎中的对象的内部方法必须符合下列不变量。普通 ECMAScript 对象以及本规范中的所有标准特殊对象都保持这些不变量。ECMAScript Proxy 对象通过对 [[ProxyHandler]] 对象上的 trap 调用结果进行运行时检查来保持这些不变量。</p>
        <p>任何实现提供的特殊对象也必须为这些对象保持这些不变量。违反这些不变量可能导致 ECMAScript 代码行为不可预测并引发安全问题。但违反这些不变量决不能影响实现的内存安全。</p>
        <p>实现不得以任何方式绕过这些不变量，比如提供不强制不变量的方法接口来实现基本内部方法。</p>
        <h2>定义：</h2>
        <ul>
          <li>
            内部方法的<em>目标</em>是调用该内部方法的对象。
          </li>
          <li>
            如果目标的 [[IsExtensible]] 方法返回 *false* 或 [[PreventExtensions]] 方法返回 *true*，则称为<em>不可扩展</em>。
          </li>
          <li>
            <em>不存在</em>属性指在不可扩展目标对象上不存在的自身属性。
          </li>
          <li>
            所有对 <em>SameValue</em> 的引用均依照 SameValue 算法定义。
          </li>
        </ul>
        <h2>返回值：</h2>
        <p>任何内部方法返回的值必须是一个 Completion Record，包含以下之一：</p>
        <ul>
          <li>[[Type]] = ~normal~，[[Target]] = ~empty~，[[Value]] = 该内部方法下方“正常返回类型”对应的值，或</li>
          <li>[[Type]] = ~throw~，[[Target]] = ~empty~，[[Value]] = 任意 ECMAScript 语言值。</li>
        </ul>
        <emu-note>
          <p>内部方法不得返回 continue、break 或 return 类型的 Completion Record。</p>
        </emu-note>
        <h2>[[GetPrototypeOf]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Object 或 Null。
          </li>
          <li>
            如果目标为不可扩展，且 [[GetPrototypeOf]] 返回值 _V_，则未来对 [[GetPrototypeOf]] 的调用都应返回与 _V_ SameValue 的值。
          </li>
        </ul>
        <emu-note>
          <p>对象的原型链应有限（即从任意对象递归调用 [[GetPrototypeOf]] 最终应到达 *null*）。但如果原型链中包含未采用普通对象定义的特殊对象，则无法作为对象级不变量强制此要求。出现环形原型链时，访问对象属性可能导致无限循环。</p>
        </emu-note>
        <h2>[[SetPrototypeOf]] ( _V_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果目标为不可扩展，[[SetPrototypeOf]] 必须返回 *false*，除非 _V_ 与目标已观察到的 [[GetPrototypeOf]] 值 SameValue。
          </li>
        </ul>
        <h2>[[IsExtensible]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 [[IsExtensible]] 返回 *false*，则未来对目标的所有 [[IsExtensible]] 调用都必须返回 *false*。
          </li>
        </ul>
        <h2>[[PreventExtensions]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 [[PreventExtensions]] 返回 *true*，则未来对目标的所有 [[IsExtensible]] 调用都必须返回 *false*，且目标被视为不可扩展。
          </li>
        </ul>
        <h2>[[GetOwnProperty]] ( _P_ )</h2>
        <ul>
          <li>
            正常返回类型为 Property Descriptor 或 Undefined。
          </li>
          <li>
            如果返回值为 Property Descriptor，必须是完整的 Property Descriptor。
          </li>
          <li>
            如果 _P_ 被描述为不可配置、不可写的自身数据属性，则未来对 [[GetOwnProperty]] ( _P_ ) 的所有调用都必须返回 [[Value]] 与 _P_ 的 [[Value]] 属性 SameValue 的 Property Descriptor。
          </li>
          <li>
            如果 _P_ 除 [[Writable]] 和 [[Value]] 外的属性可能随时间变化，或属性可能被删除，则 _P_ 的 [[Configurable]] 属性必须为 *true*。
          </li>
          <li>
            如果 [[Writable]] 属性可能从 *false* 变为 *true*，则 [[Configurable]] 属性必须为 *true*。
          </li>
          <li>
            如果目标为不可扩展且 _P_ 不存在，则未来对目标的所有 [[GetOwnProperty]] (_P_) 调用都必须描述 _P_ 为不存在（即返回 *undefined*）。
          </li>
        </ul>
        <emu-note>
          <p>由第三条不变量可知，如果某属性被描述为数据属性且可能随时间返回不同值，则无论是否暴露机制修改值，只要有可能，[[Writable]] 和 [[Configurable]] 属性至少有一个必须为 *true*。</p>
        </emu-note>
        <h2>[[DefineOwnProperty]] ( _P_, _Desc_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            除非满足以下之一，否则 [[DefineOwnProperty]] 必须返回 *false*，如果 _P_ 已被观察为目标的不可配置自身属性：
            <ol>
              <li>
                _P_ 是可写数据属性。不可配置且可写的数据属性可以变为不可配置且不可写的数据属性。
              </li>
              <li>
                _Desc_ 的所有属性与 _P_ 的属性 SameValue。
              </li>
            </ol>
          </li>
          <li>
            如果目标为不可扩展且 _P_ 是不存在的自身属性，则 [[DefineOwnProperty]] (_P_, _Desc_) 必须返回 *false*。即不可扩展对象不能添加新属性。
          </li>
        </ul>
        <h2>[[HasProperty]] ( _P_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身数据或访问器属性，则 [[HasProperty]] 必须返回 *true*。
          </li>
        </ul>
        <h2>[[Get]] ( _P_, _Receiver_ )</h2>
        <ul>
          <li>
            正常返回类型为任意 ECMAScript 语言类型。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置、不可写自身数据属性且值为 _V_，则 [[Get]] 必须返回与 _V_ SameValue 的值。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身访问器属性且 [[Get]] 属性为 *undefined*，则 [[Get]] 操作必须返回 *undefined*。
          </li>
        </ul>
        <h2>[[Set]] ( _P_, _V_, _Receiver_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置、不可写自身数据属性，则除非 _V_ 与 _P_ 的 [[Value]] 属性 SameValue，[[Set]] 必须返回 *false*。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身访问器属性且 [[Set]] 属性为 *undefined*，则 [[Set]] 操作必须返回 *false*。
          </li>
        </ul>
        <h2>[[Delete]] ( _P_ )</h2>
        <ul>
          <li>
            正常返回类型为 Boolean。
          </li>
          <li>
            如果 _P_ 已被观察为目标的不可配置自身数据或访问器属性，则 [[Delete]] 必须返回 *false*。
          </li>
        </ul>
        <h2>[[OwnPropertyKeys]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 List。
          </li>
          <li>
            返回的 List 不能有重复项。
          </li>
          <li>
            返回的 List 的每个元素必须是属性键。
          </li>
          <li>
            返回的 List 至少含有所有已观察到的不可配置自身属性的键。
          </li>
          <li>
            如果目标为不可扩展，则返回的 List 只能包含所有可通过 [[GetOwnProperty]] 观察到的自身属性键。
          </li>
        </ul>
        <h2>[[Call]] ( )</h2>
        <ul>
          <li>
            正常返回类型为任意 ECMAScript 语言类型。
          </li>
        </ul>
        <h2>[[Construct]] ( )</h2>
        <ul>
          <li>
            正常返回类型为 Object。
          </li>
          <li>
            目标还必须有 [[Call]] 内部方法。
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-well-known-intrinsic-objects">
        <h1>知名内置对象</h1>
        <p>知名内置对象是本规范的算法显式引用的内置对象，通常具有特定于“域”（realm）的身份。除非另有说明，每个内置对象实际对应一组类似对象，每个域各一个。</p>
        <p>在本规范中，%name% 表示当前域关联的对应名称的内置对象。%name.a.b% 表示在执行任何 ECMAScript 代码之前，访问内置对象 %name% 的属性 "a"，再访问该属性的 "b" 属性。当前域和其内置对象的确定见 <emu-xref href="#sec-execution-contexts"></emu-xref>。知名内置对象列表见 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>。</p>
        <emu-table id="table-well-known-intrinsic-objects" caption="知名内置对象" oldids="table-7">
          <table>
            <thead>
              <tr>
                <th>
                  内置名称
                </th>
                <th>
                  全局名称
                </th>
                <th>
                  ECMAScript 语言关联
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                %AggregateError%
              </td>
              <td>
                `AggregateError`
              </td>
              <td>
                `AggregateError` 构造函数（参见 <emu-xref href="#sec-aggregate-error-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Array%
              </td>
              <td>
                `Array`
              </td>
              <td>
                Array 构造函数（参见 <emu-xref href="#sec-array-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ArrayBuffer%
              </td>
              <td>
                `ArrayBuffer`
              </td>
              <td>
                ArrayBuffer 构造函数（参见 <emu-xref href="#sec-arraybuffer-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ArrayIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                数组迭代器对象的原型（参见 <emu-xref href="#sec-array-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFromSyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Async-from-Sync 迭代器对象的原型（参见 <emu-xref href="#sec-async-from-sync-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncFunction%
              </td>
              <td>
              </td>
              <td>
                async 函数对象的构造函数（参见 <emu-xref href="#sec-async-function-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                async 生成器函数对象的构造函数（参见 <emu-xref href="#sec-asyncgeneratorfunction-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncGeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                async 生成器对象的原型（参见 <emu-xref href="#sec-asyncgenerator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %AsyncIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                所有标准内置 async 迭代器对象的间接继承对象
              </td>
            </tr>
            <tr>
              <td>
                %Atomics%
              </td>
              <td>
                `Atomics`
              </td>
              <td>
                `Atomics` 对象（参见 <emu-xref href="#sec-atomics-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigInt%
              </td>
              <td>
                `BigInt`
              </td>
              <td>
                BigInt 构造函数（参见 <emu-xref href="#sec-bigint-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigInt64Array%
              </td>
              <td>
                `BigInt64Array`
              </td>
              <td>
                BigInt64Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %BigUint64Array%
              </td>
              <td>
                `BigUint64Array`
              </td>
              <td>
                BigUint64Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Boolean%
              </td>
              <td>
                `Boolean`
              </td>
              <td>
                Boolean 构造函数（参见 <emu-xref href="#sec-boolean-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %DataView%
              </td>
              <td>
                `DataView`
              </td>
              <td>
                DataView 构造函数（参见 <emu-xref href="#sec-dataview-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Date%
              </td>
              <td>
                `Date`
              </td>
              <td>
                Date 构造函数（参见 <emu-xref href="#sec-date-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %decodeURI%
              </td>
              <td>
                `decodeURI`
              </td>
              <td>
                `decodeURI` 函数（参见 <emu-xref href="#sec-decodeuri-encodeduri"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %decodeURIComponent%
              </td>
              <td>
                `decodeURIComponent`
              </td>
              <td>
                `decodeURIComponent` 函数（参见 <emu-xref href="#sec-decodeuricomponent-encodeduricomponent"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %encodeURI%
              </td>
              <td>
                `encodeURI`
              </td>
              <td>
                `encodeURI` 函数（参见 <emu-xref href="#sec-encodeuri-uri"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %encodeURIComponent%
              </td>
              <td>
                `encodeURIComponent`
              </td>
              <td>
                `encodeURIComponent` 函数（参见 <emu-xref href="#sec-encodeuricomponent-uricomponent"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Error%
              </td>
              <td>
                `Error`
              </td>
              <td>
                Error 构造函数（参见 <emu-xref href="#sec-error-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %eval%
              </td>
              <td>
                `eval`
              </td>
              <td>
                `eval` 函数（参见 <emu-xref href="#sec-eval-x"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %EvalError%
              </td>
              <td>
                `EvalError`
              </td>
              <td>
                EvalError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %FinalizationRegistry%
              </td>
              <td>
                `FinalizationRegistry`
              </td>
              <td>
                FinalizationRegistry 构造函数（参见 <emu-xref href="#sec-finalization-registry-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float16Array%
              </td>
              <td>
                `Float16Array`
              </td>
              <td>
                Float16Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float32Array%
              </td>
              <td>
                `Float32Array`
              </td>
              <td>
                Float32Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Float64Array%
              </td>
              <td>
                `Float64Array`
              </td>
              <td>
                Float64Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ForInIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                For-In 迭代器对象的原型（参见 <emu-xref href="#sec-for-in-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Function%
              </td>
              <td>
                `Function`
              </td>
              <td>
                Function 构造函数（参见 <emu-xref href="#sec-function-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorFunction%
              </td>
              <td>
              </td>
              <td>
                生成器函数对象的构造函数（参见 <emu-xref href="#sec-generatorfunction-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %GeneratorPrototype%
              </td>
              <td>
              </td>
              <td>
                生成器对象的原型（参见 <emu-xref href="#sec-generator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int8Array%
              </td>
              <td>
                `Int8Array`
              </td>
              <td>
                Int8Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int16Array%
              </td>
              <td>
                `Int16Array`
              </td>
              <td>
                Int16Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Int32Array%
              </td>
              <td>
                `Int32Array`
              </td>
              <td>
                Int32Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %isFinite%
              </td>
              <td>
                `isFinite`
              </td>
              <td>
                `isFinite` 函数（参见 <emu-xref href="#sec-isfinite-number"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %isNaN%
              </td>
              <td>
                `isNaN`
              </td>
              <td>
                `isNaN` 函数（参见 <emu-xref href="#sec-isnan-number"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Iterator%
              </td>
              <td>
                `Iterator`
              </td>
              <td>
                `Iterator` 构造函数（参见 <emu-xref href="#sec-iterator-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %IteratorHelperPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator Helper 对象的原型（参见 <emu-xref href="#sec-%iteratorhelperprototype%-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %JSON%
              </td>
              <td>
                `JSON`
              </td>
              <td>
                `JSON` 对象（参见 <emu-xref href="#sec-json-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Map%
              </td>
              <td>
                `Map`
              </td>
              <td>
                Map 构造函数（参见 <emu-xref href="#sec-map-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %MapIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Map 迭代器对象的原型（参见 <emu-xref href="#sec-map-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Math%
              </td>
              <td>
                `Math`
              </td>
              <td>
                `Math` 对象（参见 <emu-xref href="#sec-math-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Number%
              </td>
              <td>
                `Number`
              </td>
              <td>
                Number 构造函数（参见 <emu-xref href="#sec-number-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Object%
              </td>
              <td>
                `Object`
              </td>
              <td>
                Object 构造函数（参见 <emu-xref href="#sec-object-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %parseFloat%
              </td>
              <td>
                `parseFloat`
              </td>
              <td>
                `parseFloat` 函数（参见 <emu-xref href="#sec-parsefloat-string"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %parseInt%
              </td>
              <td>
                `parseInt`
              </td>
              <td>
                `parseInt` 函数（参见 <emu-xref href="#sec-parseint-string-radix"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Promise%
              </td>
              <td>
                `Promise`
              </td>
              <td>
                Promise 构造函数（参见 <emu-xref href="#sec-promise-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Proxy%
              </td>
              <td>
                `Proxy`
              </td>
              <td>
                Proxy 构造函数（参见 <emu-xref href="#sec-proxy-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RangeError%
              </td>
              <td>
                `RangeError`
              </td>
              <td>
                RangeError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ReferenceError%
              </td>
              <td>
                `ReferenceError`
              </td>
              <td>
                ReferenceError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Reflect%
              </td>
              <td>
                `Reflect`
              </td>
              <td>
                `Reflect` 对象（参见 <emu-xref href="#sec-reflect-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RegExp%
              </td>
              <td>
                `RegExp`
              </td>
              <td>
                RegExp 构造函数（参见 <emu-xref href="#sec-regexp-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %RegExpStringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                正则表达式字符串迭代器对象的原型（参见 <emu-xref href="#sec-regexp-string-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Set%
              </td>
              <td>
                `Set`
              </td>
              <td>
                Set 构造函数（参见 <emu-xref href="#sec-set-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SetIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Set 迭代器对象的原型（参见 <emu-xref href="#sec-set-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SharedArrayBuffer%
              </td>
              <td>
                `SharedArrayBuffer`
              </td>
              <td>
                SharedArrayBuffer 构造函数（参见 <emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %String%
              </td>
              <td>
                `String`
              </td>
              <td>
                String 构造函数（参见 <emu-xref href="#sec-string-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %StringIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                字符串迭代器对象的原型（参见 <emu-xref href="#sec-string-iterator-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Symbol%
              </td>
              <td>
                `Symbol`
              </td>
              <td>
                Symbol 构造函数（参见 <emu-xref href="#sec-symbol-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %SyntaxError%
              </td>
              <td>
                `SyntaxError`
              </td>
              <td>
                SyntaxError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %ThrowTypeError%
              </td>
              <td>
              </td>
              <td>
                一个函数对象，总是抛出新的 %TypeError% 实例
              </td>
            </tr>
            <tr>
              <td>
                %TypedArray%
              </td>
              <td>
              </td>
              <td>
                所有类型化数组构造函数的超类（参见 <emu-xref href="#sec-%typedarray%-intrinsic-object"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %TypeError%
              </td>
              <td>
                `TypeError`
              </td>
              <td>
                TypeError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint8Array%
              </td>
              <td>
                `Uint8Array`
              </td>
              <td>
                Uint8Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint8ClampedArray%
              </td>
              <td>
                `Uint8ClampedArray`
              </td>
              <td>
                Uint8ClampedArray 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint16Array%
              </td>
              <td>
                `Uint16Array`
              </td>
              <td>
                Uint16Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %Uint32Array%
              </td>
              <td>
                `Uint32Array`
              </td>
              <td>
                Uint32Array 构造函数（参见 <emu-xref href="#sec-typedarray-objects"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %URIError%
              </td>
              <td>
                `URIError`
              </td>
              <td>
                URIError 构造函数（参见 <emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakMap%
              </td>
              <td>
                `WeakMap`
              </td>
              <td>
                WeakMap 构造函数（参见 <emu-xref href="#sec-weakmap-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakRef%
              </td>
              <td>
                `WeakRef`
              </td>
              <td>
                WeakRef 构造函数（参见 <emu-xref href="#sec-weak-ref-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WeakSet%
              </td>
              <td>
                `WeakSet`
              </td>
              <td>
                WeakSet 构造函数（参见 <emu-xref href="#sec-weakset-constructor"></emu-xref>）
              </td>
            </tr>
            <tr>
              <td>
                %WrapForValidIteratorPrototype%
              </td>
              <td>
              </td>
              <td>
                Iterator.from 返回的包装迭代器对象的原型（参见 <emu-xref href="#sec-%wrapforvaliditeratorprototype%-object"></emu-xref>）
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>更多条目见 <emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref>。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript 规范类型</h1>
    <p>规范类型对应于算法中用于描述 ECMAScript 语言结构和 ECMAScript 语言类型语义的元值。规范类型包括 Reference Record、List、Completion Record、Property Descriptor、Environment Record、Abstract Closure 和 Data Block。规范类型值是规范中的产物，不一定对应于 ECMAScript 实现中的具体实体。规范类型值可用于描述 ECMAScript 表达式求值的中间结果，但这些值不能作为对象的属性或 ECMAScript 语言变量的值存储。</p>

    <emu-clause id="sec-enum-specification-type">
      <h1>枚举规范类型</h1>
      <p><dfn variants="enum,enums">枚举</dfn>是规范内部使用的值，不能被 ECMAScript 代码直接观察。枚举用 ~无衬线体~ 表示。例如，Completion Record 的 [[Type]] 字段会取 ~normal~、~return~ 或 ~throw~ 等值。枚举除了名称外没有其他特性。枚举的名称仅用于与其他枚举区分，并不暗示其在上下文中的用途或意义。</p>
    </emu-clause>

    <emu-clause id="sec-list-and-record-specification-type">
      <h1>List 和 Record 规范类型</h1>
      <p><dfn variants="Lists">List</dfn> 类型用于解释参数列表（参见 <emu-xref href="#sec-argument-lists"></emu-xref>）在 `new` 表达式、函数调用以及需要简单有序值列表的其他算法中的求值。List 类型的值就是包含各个值的有序元素序列，序列长度可任意。List 的元素可用 0 起始的索引随机访问。为方便记号，可用类似数组的语法访问 List 元素。例如，_arguments_[2] 表示 List _arguments_ 的第 3 个元素。</p>
      <p>当算法遍历 List 元素但未指定顺序时，使用 List 元素的原有顺序。</p>
      <p>在本规范中，为方便记号，可用字面量语法表达新的 List 值。例如，« 1, 2 » 定义了一个有两个元素的 List 值，每个元素初始化为特定值。空 List 可写作 « »。</p>
      <p>在本规范中，“_A_、_B_... 的<dfn id="list-concatenation">列表拼接</dfn>”（每个参数都是可能为空的 List）表示一个新 List，其元素是各参数元素（按顺序）拼接而成。</p>
      <p>对于字符串 List，“按<dfn id="lexicographic-code-unit-order">字典序码位顺序</dfn>排序”意指按较短字符串长度以内各码位的数值排序，如相等则短字符串排前，详见抽象操作 IsLessThan。</p>
      <p><dfn variants="Records">Record</dfn> 类型用于规范算法中的数据聚合。Record 类型值由一个或多个具名字段组成，每个字段的值为 ECMAScript 语言值或规范值。字段名总用双括号包裹，例如 [[Value]]。</p>
      <p>在规范中，为方便记号，可用类似对象字面量的语法表达 Record 值。例如，{ [[Field1]]: 42, [[Field2]]: *false*, [[Field3]]: ~empty~ } 表示一个包含三个字段的 Record 值，每个字段初始化为特定值。字段名顺序无关紧要，未列出的字段视为不存在。</p>
      <p>在规范文本和算法中，可用点号表示法引用 Record 的某个字段。例如，若 R 为上文的 Record，则 R.[[Field2]] 表示“R 的 [[Field2]] 字段”。</p>
      <p>常用字段组合的 Record 可以命名，并作为字面量前缀，以标识描述的聚合类型。例如：PropertyDescriptor { [[Value]]: 42, [[Writable]]: *false*, [[Configurable]]: *true* }。</p>
    </emu-clause>

    <emu-clause id="sec-set-and-relation-specification-type">
      <h1>Set 和 Relation 规范类型</h1>
      <p><em>Set</em> 类型用于说明内存模型中无序元素集合。它不同于 ECMAScript 集合类型 Set。为区分，规范中 ECMAScript 集合类型始终称为“Set 对象”。Set 类型值是元素集合，每个元素只出现一次。元素可加入或移除集合，集合之间可以并集、交集或相减。</p>
      <p><dfn variants="Relations">Relation</dfn> 类型用于说明集合上的约束。Relation 类型值是其值域上的有序对集合。例如，事件上的 Relation 是事件有序对的集合。若 Relation _R_，值域中的 _a_ 和 _b_，则 _a_ _R_ _b_ 表示有序对 (_a_, _b_) 属于 _R_。Relation 是满足某些条件的<dfn id="least-relation">最小 Relation</dfn>，即满足条件的最小 Relation。</p>
      <p><dfn variants="strict partial orders">严格偏序</dfn>是满足以下条件的 Relation 值 _R_。</p>
      <ul>
        <li>
          <p>对 _R_ 的值域内所有 _a_、_b_、_c_：</p>
          <ul>
            <li>不存在 _a_ _R_ _a_，且</li>
            <li>若 _a_ _R_ _b_ 且 _b_ _R_ _c_，则 _a_ _R_ _c_。</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>上述两个条件分别称为反自反性和传递性。</p>
      </emu-note>
      <p><dfn variants="strict total orders">严格全序</dfn>是满足以下条件的 Relation 值 _R_。</p>
      <ul>
        <li>
          <p>对 _R_ 的值域内所有 _a_、_b_、_c_：</p>
          <ul>
            <li>_a_ 等于 _b_ 或 _a_ _R_ _b_ 或 _b_ _R_ _a_，且</li>
            <li>不存在 _a_ _R_ _a_，且</li>
            <li>若 _a_ _R_ _b_ 且 _b_ _R_ _c_，则 _a_ _R_ _c_。</li>
          </ul>
        </li>
      </ul>
      <emu-note>
        <p>上述三个条件分别称为全序性、反自反性和传递性。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-completion-record-specification-type">
      <h1>Completion Record 规范类型</h1>
      <p><dfn variants="Completion Records">Completion Record</dfn> 规范类型用于解释运行时值和控制流的传播，如语句（`break`、`continue`、`return` 和 `throw`）实现的非局部控制转移行为。</p>
      <p>Completion Record 包含 <emu-xref href="#table-completion-record-fields"></emu-xref> 定义的字段。</p>
      <emu-table id="table-completion-record-fields" caption="Completion Record 字段" oldids="table-8">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Type]]
            </td>
            <td>
              ~normal~、~break~、~continue~、~return~ 或 ~throw~
            </td>
            <td>
              发生的完成类型。
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              除 Completion Record 外的任何值
            </td>
            <td>
              产生的值。
            </td>
          </tr>
          <tr>
            <td>
              [[Target]]
            </td>
            <td>
              字符串或 ~empty~
            </td>
            <td>
              用于定向控制转移的目标标签。
            </td>
          </tr>
        </table>
      </emu-table>
      <p>下列术语有时用于指代 Completion Record：</p>
      <ul>
        <li><dfn variants="normal completions">正常完成</dfn>指 [[Type]] 值为 ~normal~ 的 Completion Record。</li>
        <li><dfn variants="break completions">break 完成</dfn>指 [[Type]] 值为 ~break~ 的 Completion Record。</li>
        <li><dfn variants="continue completions">continue 完成</dfn>指 [[Type]] 值为 ~continue~ 的 Completion Record。</li>
        <li><dfn variants="return completions">return 完成</dfn>指 [[Type]] 值为 ~return~ 的 Completion Record。</li>
        <li><dfn variants="throw completions">throw 完成</dfn>指 [[Type]] 值为 ~throw~ 的 Completion Record。</li>
        <li><dfn variants="abrupt completions">异常完成</dfn>指 [[Type]] 值不是 ~normal~ 的 Completion Record。</li>
        <li>“<dfn variants="normal completions containing">包含某类型值的正常完成</dfn>”指 [[Value]] 字段为该类型值的正常完成。</li>
      </ul>
      <p>规范中定义的可调用对象只返回正常完成或 throw 完成。返回其他类型的 Completion Record 属于编辑错误。</p>
      <p>实现自定义的可调用对象也必须只返回正常完成或 throw 完成。</p>

      <emu-clause id="sec-normalcompletion" type="abstract operation">
        <h1>
          NormalCompletion (
            _value_: 除 Completion Record 外的任何值,
          ): 正常完成
        </h1>
        <dl class="header">
          <dt>跳过 return 检查</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. 返回 Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-throwcompletion" type="abstract operation">
        <h1>
          ThrowCompletion (
            _value_: 一个 ECMAScript 语言值,
          ): throw 完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-returncompletion" type="abstract operation">
        <h1>
          ReturnCompletion (
            _value_: 一个 ECMAScript 语言值,
          ): return 完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-updateempty" type="abstract operation">
        <h1>
          UpdateEmpty (
            _completionRecord_: 一个 Completion Record,
            _value_: 除 Completion Record 外的任何值,
          ): 一个 Completion Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：若 _completionRecord_ 是 return 完成或 throw 完成，则 _completionRecord_.[[Value]] 不是 ~empty~。
          1. 若 _completionRecord_.[[Value]] 不是 ~empty~，返回 ? _completionRecord_。
          1. 返回 Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>Reference Record 规范类型</h1>
      <p><dfn variants="Reference Records">Reference Record</dfn> 类型用于解释如 `delete`、`typeof`、赋值运算符、`super` 关键字等操作的行为。例如，赋值的左操作数应产生一个 Reference Record。</p>
      <p>Reference Record 是已解析的名称或（可能尚未解析的）属性绑定；其字段定义见 <emu-xref href="#table-reference-record-fields"></emu-xref>。</p>

      <emu-table id="table-reference-record-fields" caption="Reference Record 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td oldids="sec-getbase,ao-getbase">[[Base]]</td>
            <td>一个 ECMAScript 语言值、Environment Record 或 ~unresolvable~</td>
            <td>持有绑定的值或 Environment Record。[[Base]] 为 ~unresolvable~ 表示绑定无法解析。</td>
          </tr>
          <tr>
            <td oldids="sec-getreferencedname,ao-getreferencedname">[[ReferencedName]]</td>
            <td>一个 ECMAScript 语言值或 Private Name</td>
            <td>绑定的名称。若 [[Base]] 为 Environment Record，则总为字符串。否则，可能为除字符串和符号外的 ECMAScript 语言值，直到执行 ToPropertyKey。</td>
          </tr>
          <tr>
            <td oldids="sec-isstrictreference,ao-isstrictreference">[[Strict]]</td>
            <td>布尔值</td>
            <td>若 Reference Record 来源于严格模式代码，则为 *true*，否则为 *false*。</td>
          </tr>
          <tr>
            <td>[[ThisValue]]</td>
            <td>一个 ECMAScript 语言值或 ~empty~</td>
            <td>若非 ~empty~，则代表用 `super` 关键字表达的属性绑定，称为 <dfn id="super-reference-record" oldids="super-reference" variants="Super Reference Records">Super Reference Record</dfn>，其 [[Base]] 不会是 Environment Record。此时 [[ThisValue]] 字段保存创建 Reference Record 时的 *this* 值。</td>
          </tr>
        </table>
      </emu-table>

      <p>本规范使用以下抽象操作处理 Reference Record：</p>

      <emu-clause id="sec-ispropertyreference" type="abstract operation" oldids="ao-ispropertyreference">
        <h1>
          IsPropertyReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[Base]] 为 ~unresolvable~，返回 *false*。
          1. 若 _V_.[[Base]] 为 Environment Record，返回 *false*；否则返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunresolvablereference" type="abstract operation" oldids="ao-isunresolvablereference">
        <h1>
          IsUnresolvableReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[Base]] 为 ~unresolvable~，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issuperreference" type="abstract operation" oldids="ao-issuperreference">
        <h1>
          IsSuperReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[ThisValue]] 非 ~empty~，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isprivatereference" type="abstract operation">
        <h1>
          IsPrivateReference (
            _V_: 一个 Reference Record,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_.[[ReferencedName]] 是 Private Name，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvalue" type="abstract operation">
        <h1>
          GetValue (
            _V_: 一个 Reference Record 或 ECMAScript 语言值,
          ): 返回包含 ECMAScript 语言值的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_ 不是 Reference Record，返回 _V_。
          1. 若 IsUnresolvableReference(_V_) 为 *true*，抛出 *ReferenceError* 异常。
          1. 若 IsPropertyReference(_V_) 为 *true*，
            1. [id="step-getvalue-toobject"] 令 _baseObj_ 为 ? ToObject(_V_.[[Base]])。
            1. 若 IsPrivateReference(_V_) 为 *true*，
              1. 返回 ? PrivateGet(_baseObj_, _V_.[[ReferencedName]])。
            1. 若 _V_.[[ReferencedName]] 不是属性键，
              1. 令 _V_.[[ReferencedName]] 为 ? ToPropertyKey(_V_.[[ReferencedName]])。
            1. 返回 ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_))。
          1. 否则，
            1. 令 _base_ 为 _V_.[[Base]]。
            1. 断言：_base_ 是 Environment Record。
            1. 返回 ? <emu-meta effects="user-code">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]])（参见 <emu-xref href="#sec-environment-records"></emu-xref>）。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-getvalue-toobject"></emu-xref> 可能创建的对象仅在上述抽象操作和普通对象 [[Get]] 内部方法中可访问。实现可选择避免实际创建该对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" type="abstract operation">
        <h1>
          PutValue (
            _V_: 一个 Reference Record 或 ECMAScript 语言值,
            _W_: 一个 ECMAScript 语言值,
          ): 返回包含 ~unused~ 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _V_ 不是 Reference Record，抛出 *ReferenceError* 异常。
          1. 若 IsUnresolvableReference(_V_) 为 *true*，
            1. 若 _V_.[[Strict]] 为 *true*，抛出 *ReferenceError* 异常。
            1. 令 _globalObj_ 为 GetGlobalObject()。
            1. 执行 ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*)。
            1. 返回 ~unused~。
          1. 若 IsPropertyReference(_V_) 为 *true*，
            1. [id="step-putvalue-toobject"] 令 _baseObj_ 为 ? ToObject(_V_.[[Base]])。
            1. 若 IsPrivateReference(_V_) 为 *true*，
              1. 返回 ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_)。
            1. 若 _V_.[[ReferencedName]] 不是属性键，
              1. 令 _V_.[[ReferencedName]] 为 ? ToPropertyKey(_V_.[[ReferencedName]])。
            1. 令 _succeeded_ 为 ? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_))。
            1. 若 _succeeded_ 为 *false* 且 _V_.[[Strict]] 为 *true*，抛出 *TypeError* 异常。
            1. 返回 ~unused~。
          1. 否则，
            1. 令 _base_ 为 _V_.[[Base]]。
            1. 断言：_base_ 是 Environment Record。
            1. 返回 ? <emu-meta effects="user-code">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]])（参见 <emu-xref href="#sec-environment-records"></emu-xref>）。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-putvalue-toobject"></emu-xref> 可能创建的对象仅在上述抽象操作和普通对象 [[Set]] 内部方法中可访问。实现可选择避免实际创建该对象。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getthisvalue" type="abstract operation">
        <h1>
          GetThisValue (
            _V_: 一个 Reference Record,
          ): 一个 ECMAScript 语言值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsPropertyReference(_V_) 为 *true*。
          1. 若 IsSuperReference(_V_) 为 *true*，返回 _V_.[[ThisValue]]；否则返回 _V_.[[Base]]。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-initializereferencedbinding" type="abstract operation">
        <h1>
          InitializeReferencedBinding (
            _V_: 一个 Reference Record,
            _W_: 一个 ECMAScript 语言值,
          ): 返回包含 ~unused~ 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsUnresolvableReference(_V_) 为 *false*。
          1. 令 _base_ 为 _V_.[[Base]]。
          1. 断言：_base_ 是 Environment Record。
          1. 返回 ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makeprivatereference" type="abstract operation">
        <h1>
          MakePrivateReference (
            _baseValue_: 一个 ECMAScript 语言值,
            _privateIdentifier_: 字符串,
          ): 一个 Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _privateEnv_ 为当前执行上下文的 PrivateEnvironment。
          1. 断言：_privateEnv_ 不为 *null*。
          1. 令 _privateName_ 为 ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_)。
          1. 返回 Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-descriptor-specification-type">
      <h1>Property Descriptor 规范类型</h1>
      <p><dfn variants="Property Descriptors">Property Descriptor</dfn> 类型用于解释对象属性特性的操作及具现。Property Descriptor 是一个包含零个或多个字段的 Record，每个字段名为特性名，值为 <emu-xref href="#sec-property-attributes"></emu-xref> 所定义的特性值。本规范用 “PropertyDescriptor” 作为字面量描述 Property Descriptor Record 的标签名称。</p>
      <p>Property Descriptor 值可根据某些字段的存在或用途进一步分为数据 Property Descriptor 和访问器 Property Descriptor。包含 [[Value]] 或 [[Writable]] 字段的为数据 Property Descriptor；包含 [[Get]] 或 [[Set]] 字段的为访问器 Property Descriptor。任意 Property Descriptor 都可包含 [[Enumerable]] 和 [[Configurable]] 字段。Property Descriptor 值不能同时为数据和访问器 Property Descriptor，但可以两者都不是（此时为通用 Property Descriptor）。<dfn>完全填充的 Property Descriptor</dfn>指为访问器 Property Descriptor 或数据 Property Descriptor 且已定义所有对应字段（见 <emu-xref href="#table-object-property-attributes"></emu-xref>）。</p>
      <p>本规范用以下抽象操作处理 Property Descriptor 值：</p>

      <emu-clause id="sec-isaccessordescriptor" type="abstract operation">
        <h1>
          IsAccessorDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 有 [[Get]] 字段，返回 *true*。
          1. 若 _Desc_ 有 [[Set]] 字段，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdatadescriptor" type="abstract operation">
        <h1>
          IsDataDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 有 [[Value]] 字段，返回 *true*。
          1. 若 _Desc_ 有 [[Writable]] 字段，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isgenericdescriptor" type="abstract operation">
        <h1>
          IsGenericDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): 布尔值
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，返回 *false*。
          1. 若 IsDataDescriptor(_Desc_) 为 *true*，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-frompropertydescriptor" type="abstract operation">
        <h1>
          FromPropertyDescriptor (
            _Desc_: 一个 Property Descriptor 或 *undefined*,
          ): 一个对象或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 为 *undefined*，返回 *undefined*。
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 断言：_obj_ 是可扩展的普通对象且无自身属性。
          1. 若 _Desc_ 有 [[Value]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"value"*, _Desc_.[[Value]])。
          1. 若 _Desc_ 有 [[Writable]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"writable"*, _Desc_.[[Writable]])。
          1. 若 _Desc_ 有 [[Get]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"get"*, _Desc_.[[Get]])。
          1. 若 _Desc_ 有 [[Set]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"set"*, _Desc_.[[Set]])。
          1. 若 _Desc_ 有 [[Enumerable]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"enumerable"*, _Desc_.[[Enumerable]])。
          1. 若 _Desc_ 有 [[Configurable]] 字段，
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"configurable"*, _Desc_.[[Configurable]])。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-topropertydescriptor" type="abstract operation">
        <h1>
          ToPropertyDescriptor (
            _Obj_: 一个 ECMAScript 语言值,
          ): 返回包含 Property Descriptor 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Obj_ 不是对象，抛出 *TypeError* 异常。
          1. 令 _desc_ 为一个初始无字段的新 Property Descriptor。
          1. 令 _hasEnumerable_ 为 ? HasProperty(_Obj_, *"enumerable"*)。
          1. 若 _hasEnumerable_ 为 *true*，
            1. 令 _enumerable_ 为 ToBoolean(? Get(_Obj_, *"enumerable"*))。
            1. 设置 _desc_.[[Enumerable]] 为 _enumerable_。
          1. 令 _hasConfigurable_ 为 ? HasProperty(_Obj_, *"configurable"*)。
          1. 若 _hasConfigurable_ 为 *true*，
            1. 令 _configurable_ 为 ToBoolean(? Get(_Obj_, *"configurable"*))。
            1. 设置 _desc_.[[Configurable]] 为 _configurable_。
          1. 令 _hasValue_ 为 ? HasProperty(_Obj_, *"value"*)。
          1. 若 _hasValue_ 为 *true*，
            1. 令 _value_ 为 ? Get(_Obj_, *"value"*)。
            1. 设置 _desc_.[[Value]] 为 _value_。
          1. 令 _hasWritable_ 为 ? HasProperty(_Obj_, *"writable"*)。
          1. 若 _hasWritable_ 为 *true*，
            1. 令 _writable_ 为 ToBoolean(? Get(_Obj_, *"writable"*))。
            1. 设置 _desc_.[[Writable]] 为 _writable_。
          1. 令 _hasGet_ 为 ? HasProperty(_Obj_, *"get"*)。
          1. 若 _hasGet_ 为 *true*，
            1. 令 _getter_ 为 ? Get(_Obj_, *"get"*)。
            1. 若 IsCallable(_getter_) 为 *false* 且 _getter_ 不为 *undefined*，抛出 *TypeError* 异常。
            1. 设置 _desc_.[[Get]] 为 _getter_。
          1. 令 _hasSet_ 为 ? HasProperty(_Obj_, *"set"*)。
          1. 若 _hasSet_ 为 *true*，
            1. 令 _setter_ 为 ? Get(_Obj_, *"set"*)。
            1. 若 IsCallable(_setter_) 为 *false* 且 _setter_ 不为 *undefined*，抛出 *TypeError* 异常。
            1. 设置 _desc_.[[Set]] 为 _setter_。
          1. 若 _desc_ 有 [[Get]] 字段或 [[Set]] 字段，
            1. 若 _desc_ 有 [[Value]] 字段或 [[Writable]] 字段，抛出 *TypeError* 异常。
          1. 返回 _desc_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-completepropertydescriptor" type="abstract operation">
        <h1>
          CompletePropertyDescriptor (
            _Desc_: 一个 Property Descriptor,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _like_ 为 Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。
          1. 若 IsGenericDescriptor(_Desc_) 为 *true* 或 IsDataDescriptor(_Desc_) 为 *true*，
            1. 若 _Desc_ 无 [[Value]] 字段，设置 _Desc_.[[Value]] 为 _like_.[[Value]]。
            1. 若 _Desc_ 无 [[Writable]] 字段，设置 _Desc_.[[Writable]] 为 _like_.[[Writable]]。
          1. 否则，
            1. 若 _Desc_ 无 [[Get]] 字段，设置 _Desc_.[[Get]] 为 _like_.[[Get]]。
            1. 若 _Desc_ 无 [[Set]] 字段，设置 _Desc_.[[Set]] 为 _like_.[[Set]]。
          1. 若 _Desc_ 无 [[Enumerable]] 字段，设置 _Desc_.[[Enumerable]] 为 _like_.[[Enumerable]]。
          1. 若 _Desc_ 无 [[Configurable]] 字段，设置 _Desc_.[[Configurable]] 为 _like_.[[Configurable]]。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-lexical-environment-and-environment-record-specification-types">
      <h1>Environment Record 规范类型</h1>
      <p>Environment Record 类型用于解释嵌套函数和块中的名称解析行为。此类型及其操作定义见 <emu-xref href="#sec-environment-records"></emu-xref>。</p>
    </emu-clause>

    <emu-clause id="sec-abstract-closure">
      <h1>Abstract Closure 规范类型</h1>
      <p><dfn variants="Abstract Closures">Abstract Closure</dfn> 规范类型用于引用算法步骤及一组值。Abstract Closure 是元值，用函数调用风格如 _closure_(_arg1_, _arg2_) 调用。和抽象操作类似，调用时执行 Abstract Closure 描述的算法步骤。</p>
      <p>创建 Abstract Closure 的算法步骤，用 “capture” 和别名列表描述需捕获的值。创建时，按别名捕获当时关联的值。指定 Abstract Closure 被调用时的算法步骤时，每个捕获值都用其别名引用。</p>
      <p>若 Abstract Closure 返回 Completion Record，则必须是正常完成或 throw 完成。</p>
      <p>Abstract Closure 通常作为其他算法的一部分内联创建，示例如下：</p>
      <emu-alg example>
        1. 令 _addend_ 为 41。
        1. 令 _closure_ 为新建 Abstract Closure，参数 (_x_)，捕获 _addend_，调用时执行以下步骤：
          1. 返回 _x_ + _addend_。
        1. 令 _val_ 为 _closure_(1)。
        1. 断言：_val_ 为 42。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-data-blocks">
      <h1>数据块</h1>
      <p><dfn variants="Data Blocks">Data Block</dfn> 规范类型用于描述一段独立且可变的字节（8 位）数值序列。<dfn variants="byte values">字节值</dfn>是 0 到 255 的整数。Data Block 值创建时拥有固定数量字节，每个初始值为 0。</p>
      <p>在规范中，为方便记号，可用类似数组的语法访问 Data Block 的各字节。该记号将 Data Block 视为 0 起始<emu-not-ref>整数索引</emu-not-ref>的字节序列。例如，若 _db_ 为 5 字节 Data Block，则 _db_[2] 用于访问第 3 个字节。</p>
      <p>可被多个 agent 并发引用的驻留于内存的数据块称为 <dfn variants="Shared Data Blocks">Shared Data Block</dfn>。Shared Data Block 有一个用于相等性测试的<em>无地址</em>身份：它不是绑定到任何进程的虚拟地址，而是与所代表的内存位置集合绑定。只有包含的内存位置集合相等，两数据块才相等，否则不等且其集合交集为空。Shared Data Block 可与 Data Block 区分。</p>
      <p>Shared Data Block 的语义由内存模型通过 Shared Data Block 事件定义。下述抽象操作引入 Shared Data Block 事件，并作为求值语义与内存模型事件语义的接口。事件构成候选执行，内存模型对其进行筛选。完整语义参见内存模型。</p>
      <p>Shared Data Block 事件由内存模型定义的 Record 表示。</p>
      <p>本规范用以下抽象操作处理 Data Block 值：</p>

      <emu-clause id="sec-createbytedatablock" type="abstract operation">
        <h1>
          CreateByteDataBlock (
            _size_: 非负整数,
          ): 返回包含 Data Block 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _size_ > 2<sup>53</sup> - 1，抛出 *RangeError* 异常。
          1. 令 _db_ 为由 _size_ 字节组成的新 Data Block 值。若无法创建该 Data Block，抛出 *RangeError* 异常。
          1. 将 _db_ 的所有字节设为 0。
          1. 返回 _db_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createsharedbytedatablock" type="abstract operation">
        <h1>
          CreateSharedByteDataBlock (
            _size_: 非负整数,
          ): 返回包含 Shared Data Block 的正常完成或异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _db_ 为由 _size_ 字节组成的新 Shared Data Block 值。若无法创建该 Shared Data Block，抛出 *RangeError* 异常。
          1. 令 _execution_ 为当前 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
          1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
          1. 令 _zero_ 为 « 0 »。
          1. 对 _db_ 的每个索引 _i_，
            1. 将 WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } 添加到 _eventsRecord_.[[EventList]]。
          1. 返回 _db_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-copydatablockbytes" type="abstract operation">
        <h1>
          CopyDataBlockBytes (
            _toBlock_: Data Block 或 Shared Data Block,
            _toIndex_: 非负整数,
            _fromBlock_: Data Block 或 Shared Data Block,
            _fromIndex_: 非负整数,
            _count_: 非负整数,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_fromBlock_ 和 _toBlock_ 是不同值。
          1. 令 _fromSize_ 为 _fromBlock_ 的字节数。
          1. 断言：_fromIndex_ + _count_ ≤ _fromSize_。
          1. 令 _toSize_ 为 _toBlock_ 的字节数。
          1. 断言：_toIndex_ + _count_ ≤ _toSize_。
          1. 当 _count_ > 0 时重复：
            1. 若 _fromBlock_ 是 Shared Data Block，
              1. 令 _execution_ 为当前 agent 的 Agent Record 的 [[CandidateExecution]] 字段。
              1. 令 _eventsRecord_ 为 _execution_.[[EventsRecords]] 中 [[AgentSignifier]] 为 AgentSignifier() 的 Agent Events Record。
              1. 令 _bytes_ 为仅有一个由非确定性选择的字节值的 List。
              1. 注：在实现中，_bytes_ 是底层硬件非原子读指令的结果。非确定性由内存模型语义规定，以描述弱一致性硬件的可观察行为。
              1. 令 _readEvent_ 为 ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }。
              1. 将 _readEvent_ 添加到 _eventsRecord_.[[EventList]]。
              1. 将 Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } 添加到 _execution_.[[ChosenValues]]。
              1. 若 _toBlock_ 是 Shared Data Block，
                1. 将 WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } 添加到 _eventsRecord_.[[EventList]]。
              1. 否则，
                1. 设置 _toBlock_[_toIndex_] 为 _bytes_[0]。
            1. 否则，
              1. 断言：_toBlock_ 不是 Shared Data Block。
              1. 设置 _toBlock_[_toIndex_] 为 _fromBlock_[_fromIndex_]。
            1. 设置 _toIndex_ 为 _toIndex_ + 1。
            1. 设置 _fromIndex_ 为 _fromIndex_ + 1。
            1. 设置 _count_ 为 _count_ - 1。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-privateelement-specification-type">
      <h1>PrivateElement 规范类型</h1>
      <p>PrivateElement 类型是用于规范私有类字段、方法和访问器的 Record。虽然 PrivateElement 不用 Property Descriptor，但私有字段的行为类似于不可配置、不可枚举、可写的数据属性，私有方法类似于不可配置、不可枚举、不可写的数据属性，私有访问器类似于不可配置、不可枚举的访问器属性。</p>
      <p>PrivateElement 类型的值是包含 <emu-xref href="#table-privateelement-fields"></emu-xref> 定义字段的 Record。此类值称为 <dfn variants="PrivateElement">PrivateElements</dfn>。</p>
      <emu-table id="table-privateelement-fields" caption="PrivateElement 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>存在时 [[Kind]] 字段的值</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Key]]
            </td>
            <td>
              所有
            </td>
            <td>
              Private Name
            </td>
            <td>
              字段、方法或访问器的名称。
            </td>
          </tr>
          <tr>
            <td>
              [[Kind]]
            </td>
            <td>
              所有
            </td>
            <td>
              ~field~、~method~ 或 ~accessor~
            </td>
            <td>
              元素类型。
            </td>
          </tr>
          <tr>
            <td>
              [[Value]]
            </td>
            <td>
              ~field~ 和 ~method~
            </td>
            <td>
              一个 ECMAScript 语言值
            </td>
            <td>
              字段的值。
            </td>
          </tr>
          <tr>
            <td>
              [[Get]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              函数对象或 *undefined*
            </td>
            <td>
              私有访问器的 getter。
            </td>
          </tr>
          <tr>
            <td>
              [[Set]]
            </td>
            <td>
              ~accessor~
            </td>
            <td>
              函数对象或 *undefined*
            </td>
            <td>
              私有访问器的 setter。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-classfielddefinition-record-specification-type">
      <h1>ClassFieldDefinition Record 规范类型</h1>
      <p>ClassFieldDefinition 类型是用于规范类字段的 Record。</p>
      <p>ClassFieldDefinition 类型的值是包含 <emu-xref href="#table-classfielddefinition-fields"></emu-xref> 定义字段的 Record。此类值称为 <dfn variants="ClassFieldDefinition Record">ClassFieldDefinition Records</dfn>。</p>
      <emu-table id="table-classfielddefinition-fields" caption="ClassFieldDefinition Record 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Name]]
            </td>
            <td>
              Private Name、字符串或符号
            </td>
            <td>
              字段的名称。
            </td>
          </tr>
          <tr>
            <td>
              [[Initializer]]
            </td>
            <td>
              ECMAScript 函数对象或 ~empty~
            </td>
            <td>
              字段的初始化器（如有）。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-private-names">
      <h1>Private Name</h1>
      <p><dfn variants="Private Names">Private Name</dfn> 规范类型用于描述全局唯一值（即使与其他 Private Name 外观一致也不同），用于表示私有类元素（字段、方法或访问器）的键。每个 Private Name 有不可变的 [[Description]] 内部槽，为字符串。Private Name 可通过 PrivateFieldAdd 或 PrivateMethodOrAccessorAdd 安装到任意 ECMAScript 对象上，然后可用 PrivateGet 和 PrivateSet 读取或写入。</p>
    </emu-clause>

    <emu-clause id="sec-classstaticblockdefinition-record-specification-type">
      <h1>ClassStaticBlockDefinition Record 规范类型</h1>
      <p><dfn variants="ClassStaticBlockDefinition Records">ClassStaticBlockDefinition Record</dfn> 是用于封装类静态初始化块可执行代码的 Record 值。</p>
      <p>ClassStaticBlockDefinition Record 包含 <emu-xref href="#table-classstaticblockdefinition-record-fields"></emu-xref> 列出的字段。</p>
      <emu-table id="table-classstaticblockdefinition-record-fields" caption="ClassStaticBlockDefinition Record 字段">
        <table>
          <thead>
            <tr>
              <th>字段名</th>
              <th>值</th>
              <th>含义</th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BodyFunction]]
            </td>
            <td>
              一个 ECMAScript 函数对象
            </td>
            <td>
              类静态初始化时要调用的函数对象。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>抽象操作 (Abstract Operations)</h1>
  <p>这些操作不属于 ECMAScript 语言本身；它们仅在此定义，用于辅助描述 ECMAScript 语言语义。本规范其余部分还定义了其他更专业的抽象操作。</p>

  <emu-clause id="sec-type-conversion">
    <h1>类型转换 (Type Conversion)</h1>
    <p>ECMAScript 语言会按需隐式执行自动类型转换。为澄清某些结构的语义，有必要定义一组转换类抽象操作。转换抽象操作是多态的；它们可以接受任意 ECMAScript 语言类型的值。但不会与其它规范类型（specification types）一起使用。</p>
    <p>BigInt 类型在 ECMAScript 语言中没有隐式转换；程序员必须显式调用 BigInt 以从其他类型转换值。</p>

    <emu-clause id="sec-toprimitive" type="abstract operation" oldids="table-9">
      <h1>
        ToPrimitive (
        _input_: 一个 ECMAScript 语言值,
        可选 _preferredType_: ~string~ 或 ~number~,
        ): 返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将参数 _input_ 转换为非 Object 的类型。如果一个对象可以转换为多个不同的原始类型，它可利用可选提示 _preferredType_ 来偏向该类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _input_ 是一个 Object，则
          1. 令 _exoticToPrim_ 为 ? GetMethod(_input_, %Symbol.toPrimitive%)。
          1. 如果 _exoticToPrim_ 不为 *undefined*，则
            1. 如果 _preferredType_ 不存在，
              1. 令 _hint_ 为 *"default"*。
            1. 否则如果 _preferredType_ 是 ~string~，
              1. 令 _hint_ 为 *"string"*。
            1. 否则，
              1. 断言：_preferredType_ 是 ~number~。
              1. 令 _hint_ 为 *"number"*。
            1. 令 _result_ 为 ? Call(_exoticToPrim_, _input_, « _hint_ »)。
            1. 如果 _result_ 不是一个 Object，返回 _result_。
            1. 抛出 *TypeError* 异常。
          1. 如果 _preferredType_ 不存在，令 _preferredType_ 为 ~number~。
          1. 返回 ? OrdinaryToPrimitive(_input_, _preferredType_)。
        1. 返回 _input_。
      </emu-alg>
      <emu-note>
        <p>当 ToPrimitive 未带 hint 被调用时，一般表现为 hint 为 ~number~。但对象可通过定义 %Symbol.toPrimitive% 方法来覆写此行为。本规范中只有 Date（参见 <emu-xref href="#sec-date.prototype-%symbol.toprimitive%"></emu-xref>）和 Symbol 对象（参见 <emu-xref href="#sec-symbol.prototype-%symbol.toprimitive%"></emu-xref>）覆写默认行为。Date 在缺少 hint 时将其视为 ~string~。</p>
      </emu-note>

      <emu-clause id="sec-ordinarytoprimitive" type="abstract operation">
        <h1>
          OrdinaryToPrimitive (
            _O_: 一个 Object,
            _hint_: ~string~ 或 ~number~,
          ): 返回包含一个 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _hint_ 是 ~string~，则
            1. 令 _methodNames_ 为 « *"toString"*, *"valueOf"* »。
          1. 否则，
            1. 令 _methodNames_ 为 « *"valueOf"*, *"toString"* »。
          1. 对于 _methodNames_ 的每个元素 _name_，执行
            1. 令 _method_ 为 ? Get(_O_, _name_)。
            1. 如果 IsCallable(_method_) 是 *true*，则
              1. 令 _result_ 为 ? Call(_method_, _O_)。
              1. 如果 _result_ 不是一个 Object，返回 _result_。
          1. 抛出 *TypeError* 异常。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toboolean" oldids="table-toboolean-conversions,sec-IsHTMLDDA-internal-slot-to-boolean" type="abstract operation">
      <h1>
        ToBoolean (
          _argument_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 Boolean 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 Boolean，返回 _argument_。
        1. 如果 _argument_ 是 *undefined*、*null*、*+0*<sub>𝔽</sub>、*-0*<sub>𝔽</sub>、*NaN*、*0*<sub>ℤ</sub> 或空字符串，返回 *false*。
        1. [id="step-to-boolean-web-compat-insertion-point", normative-optional] 如果宿主是 web 浏览器或支持 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>，则
          1. 如果 _argument_ 是 Object 且具有 [[IsHTMLDDA]] 内部槽，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumeric" type="abstract operation">
      <h1>
        ToNumeric (
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含 Number 或 BigInt 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回 _value_ 转换后的 Number 或 BigInt。</dd>
      </dl>
      <emu-alg>
        1. 令 _primValue_ 为 ? ToPrimitive(_value_, ~number~)。
        1. 如果 _primValue_ 是 BigInt，返回 _primValue_。
        1. 返回 ? <emu-meta suppress-effects="user-code">ToNumber(_primValue_)</emu-meta>。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tonumber" oldids="table-tonumber-conversions" type="abstract operation">
      <h1>
        ToNumber (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 Number 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 Number，返回 _argument_。
        1. 如果 _argument_ 是 Symbol 或 BigInt，抛出 *TypeError* 异常。
        1. 如果 _argument_ 是 *undefined*，返回 *NaN*。
        1. 如果 _argument_ 是 *null* 或 *false*，返回 *+0*<sub>𝔽</sub>。
        1. 如果 _argument_ 是 *true*，返回 *1*<sub>𝔽</sub>。
        1. 如果 _argument_ 是 String，返回 StringToNumber(_argument_)。
        1. 断言：_argument_ 是一个 Object。
        1. 令 _primValue_ 为 ? ToPrimitive(_argument_, ~number~)。
        1. 断言：_primValue_ 不是 Object。
        1. 返回 ? ToNumber(_primValue_)。
      </emu-alg>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>应用于 String 类型的 ToNumber</h1>
        <p>抽象操作 StringToNumber 规定如何使用下列语法将一个 String 值转换为 Number 值。</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringNumericLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

          StrWhiteSpace :::
            StrWhiteSpaceChar StrWhiteSpace?

          StrWhiteSpaceChar :::
            WhiteSpace
            LineTerminator

          StrNumericLiteral :::
            StrDecimalLiteral
            NonDecimalIntegerLiteral[~Sep]

          StrDecimalLiteral :::
            StrUnsignedDecimalLiteral
            `+` StrUnsignedDecimalLiteral
            `-` StrUnsignedDecimalLiteral

          StrUnsignedDecimalLiteral :::
            `Infinity`
            DecimalDigits[~Sep] `.` DecimalDigits[~Sep]? ExponentPart[~Sep]?
            `.` DecimalDigits[~Sep] ExponentPart[~Sep]?
            DecimalDigits[~Sep] ExponentPart[~Sep]?
        </emu-grammar>
        <p>未在上方显式定义的语法符号，采用数字字面量词法语法 (<emu-xref href="#sec-literals-numeric-literals"></emu-xref>) 中的定义。</p>
        <emu-note>
          <p>需要注意 |StringNumericLiteral| 与 |NumericLiteral| 语法之间的一些差异：</p>
          <ul>
            <li>|StringNumericLiteral| 可包含前导和/或尾随空白及/或行终止符。</li>
            <li>十进制的 |StringNumericLiteral| 可以有任意数量的前导 `0`。</li>
            <li>十进制的 |StringNumericLiteral| 可以包含 `+` 或 `-` 来表示符号。</li>
            <li>空的或只含空白的 |StringNumericLiteral| 被转换为 *+0*<sub>𝔽</sub>。</li>
            <li>`Infinity` 和 `-Infinity` 被识别为 |StringNumericLiteral| 而非 |NumericLiteral|。</li>
            <li>|StringNumericLiteral| 不能包含 |BigIntLiteralSuffix|。</li>
            <li>|StringNumericLiteral| 不能包含 |NumericLiteralSeparator|。</li>
          </ul>
        </emu-note>

        <emu-clause id="sec-stringtonumber" type="abstract operation">
          <h1>
            StringToNumber (
              _str_: 一个 String,
            ): 一个 Number
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. 令 _literal_ 为 ParseText(_str_, |StringNumericLiteral|)。
            1. 如果 _literal_ 是一个错误列表，返回 *NaN*。
            1. 返回 _literal_ 的 StringNumericValue。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-stringnumericvalue" type="sdo" oldids="sec-runtime-semantics-mv-s">
          <h1>运行时语义：StringNumericValue ( ): 一个 Number</h1>
          <dl class="header">
          </dl>
          <emu-note>
            <p>将 |StringNumericLiteral| 转换为 Number 值的整体过程与确定 |NumericLiteral| 的 NumericValue 类似（参见 <emu-xref href="#sec-literals-numeric-literals"></emu-xref>），但细节有所不同。</p>
          </emu-note>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. 返回 *+0*<sub>𝔽</sub>。
          </emu-alg>
          <emu-grammar>StringNumericLiteral ::: StrWhiteSpace? StrNumericLiteral StrWhiteSpace?</emu-grammar>
          <emu-alg>
            1. 返回 |StrNumericLiteral| 的 StringNumericValue。
          </emu-alg>
          <emu-grammar>StrNumericLiteral ::: NonDecimalIntegerLiteral</emu-grammar>
          <emu-alg>
            1. 返回 𝔽(|NonDecimalIntegerLiteral| 的 MV)。
          </emu-alg>
          <emu-grammar>StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral</emu-grammar>
          <emu-alg>
            1. 令 _a_ 为 |StrUnsignedDecimalLiteral| 的 StringNumericValue。
            1. 如果 _a_ 是 *+0*<sub>𝔽</sub>，返回 *-0*<sub>𝔽</sub>。
            1. 返回 -_a_。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `Infinity`</emu-grammar>
          <emu-alg>
            1. 返回 *+∞*<sub>𝔽</sub>。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits? ExponentPart?</emu-grammar>
          <emu-alg>
            1. 令 _a_ 为第一个 |DecimalDigits| 的 MV。
            1. 如果第二个 |DecimalDigits| 存在，则
              1. 令 _b_ 为第二个 |DecimalDigits| 的 MV。
              1. 令 _n_ 为第二个 |DecimalDigits| 的码点数量。
            1. 否则，
              1. 令 _b_ 为 0。
              1. 令 _n_ 为 0。
            1. 如果 |ExponentPart| 存在，令 _e_ 为其 MV；否则令 _e_ 为 0。
            1. 返回 RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>)。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. 令 _b_ 为 |DecimalDigits| 的 MV。
            1. 如果 |ExponentPart| 存在，令 _e_ 为其 MV；否则令 _e_ 为 0。
            1. 令 _n_ 为 |DecimalDigits| 的码点数量。
            1. 返回 RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>)。
          </emu-alg>
          <emu-grammar>StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart?</emu-grammar>
          <emu-alg>
            1. 令 _a_ 为 |DecimalDigits| 的 MV。
            1. 如果 |ExponentPart| 存在，令 _e_ 为其 MV；否则令 _e_ 为 0。
            1. 返回 RoundMVResult(_a_ × 10<sup>_e_</sup>)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-roundmvresult" type="abstract operation">
          <h1>
            RoundMVResult (
              _n_: 一个数学值,
            ): 一个 Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>以实现定义的方式将 _n_ 转换为 Number。对本抽象操作而言，若一位数字不是 0，或其左侧与右侧存在非零数字，则该位为有效数字。此处“数学值的表示所表示的数学值”与“数学值的十进制表示”互为逆过程。</dd>
          </dl>
          <emu-alg>
            1. 如果 _n_ 的十进制表示有不超过 20 个有效数字，返回 𝔽(_n_)。
            1. 令 _option1_ 为将 _n_ 十进制表示中第 20 位之后的每个有效数字替换为 0 后所表示的数学值。
            1. 令 _option2_ 为将 _n_ 十进制表示中第 20 位之后的每个有效数字替换为 0，然后对第 20 位进位（必要时连锁进位）后所表示的数学值。
            1. 令 _chosen_ 为实现定义地在 _option1_ 与 _option2_ 中选择的其中一个。
            1. 返回 𝔽(_chosen_)。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tointegerorinfinity" type="abstract operation" oldids="sec-tointeger">
      <h1>
        ToIntegerOrInfinity (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整数、+&infin;、- &infin; 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为其 Number 值去掉小数部分后的整数；若该 Number 值为无穷大，则转换为 +∞ 或 -∞。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 是 *NaN*、*+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 0。
        1. 如果 _number_ 是 *+∞*<sub>𝔽</sub>，返回 +∞。
        1. 如果 _number_ 是 *-∞*<sub>𝔽</sub>，返回 -∞。
        1. 返回 truncate(ℝ(_number_))。
      </emu-alg>
      <emu-note>
        𝔽(ToIntegerOrInfinity(_x_)) 对任意 _x_ 都不会返回 *-0*<sub>𝔽</sub>。截断小数部分在将 _x_ 转换为数学值之后执行。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint32" type="abstract operation">
      <h1>
        ToInt32 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>32</sup> 个整型 Number 值之一，范围为 𝔽(-2<sup>31</sup>) 到 𝔽(2<sup>31</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int32bit_ 为 _int_ modulo 2<sup>32</sup>。
        1. 如果 _int32bit_ ≥ 2<sup>31</sup>，返回 𝔽(_int32bit_ - 2<sup>32</sup>)；否则返回 𝔽(_int32bit_)。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>ToInt32 是幂等的：对其输出再次应用结果不变。</li>
          <li>对所有 _x_，ToInt32(ToUint32(_x_)) 与 ToInt32(_x_) 相同。（为保持此性质，*+∞*<sub>𝔽</sub> 与 *-∞*<sub>𝔽</sub> 被映射为 *+0*<sub>𝔽</sub>。）</li>
          <li>ToInt32 将 *-0*<sub>𝔽</sub> 映射为 *+0*<sub>𝔽</sub>。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-touint32" type="abstract operation">
      <h1>
        ToUint32 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>32</sup> 个整型 Number 值之一，范围为 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>32</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int32bit_ 为 _int_ modulo 2<sup>32</sup>。
        1. [id="step-touint32-return"] 返回 𝔽(_int32bit_)。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>步骤 <emu-xref href="#step-touint32-return"></emu-xref> 是 ToUint32 与 ToInt32 的唯一差别。</li>
          <li>ToUint32 幂等。</li>
          <li>对所有 _x_，ToUint32(ToInt32(_x_)) 与 ToUint32(_x_) 相同。（为保持此性质，*+∞*<sub>𝔽</sub> 与 *-∞*<sub>𝔽</sub> 被映射为 *+0*<sub>𝔽</sub>。）</li>
          <li>ToUint32 将 *-0*<sub>𝔽</sub> 映射为 *+0*<sub>𝔽</sub>。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint16" type="abstract operation">
      <h1>
        ToInt16 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>16</sup> 个整型 Number 之一，范围 𝔽(-2<sup>15</sup>) 到 𝔽(2<sup>15</sup> - 1)。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int16bit_ 为 _int_ modulo 2<sup>16</sup>。
        1. 如果 _int16bit_ ≥ 2<sup>15</sup>，返回 𝔽(_int16bit_ - 2<sup>16</sup>)；否则返回 𝔽(_int16bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint16" type="abstract operation">
      <h1>
        ToUint16 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>16</sup> 个整型 Number 之一，范围 *+0*<sub>𝔽</sub> 到 𝔽(2<sup>16</sup> - 1)。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. [id="step-touint16-mod"] 令 _int16bit_ 为 _int_ modulo 2<sup>16</sup>。
        1. 返回 𝔽(_int16bit_)。
      </emu-alg>
      <emu-note>
        <p>基于上述定义：</p>
        <ul>
          <li>在步骤 <emu-xref href="#step-touint16-mod"></emu-xref> 中把 2<sup>16</sup> 代替 2<sup>32</sup> 是 ToUint32 与 ToUint16 的唯一差别。</li>
          <li>ToUint16 将 *-0*<sub>𝔽</sub> 映射为 *+0*<sub>𝔽</sub>。</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-toint8" type="abstract operation">
      <h1>
        ToInt8 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>8</sup> 个整型 Number 之一，范围 *-128*<sub>𝔽</sub> 到 *127*<sub>𝔽</sub>。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int8bit_ 为 _int_ modulo 2<sup>8</sup>。
        1. 如果 _int8bit_ ≥ 2<sup>7</sup>，返回 𝔽(_int8bit_ - 2<sup>8</sup>)；否则返回 𝔽(_int8bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8" type="abstract operation">
      <h1>
        ToUint8 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>转换为 2<sup>8</sup> 个整型 Number 之一，范围 *+0*<sub>𝔽</sub> 到 *255*<sub>𝔽</sub>。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 不是有限数或为 *+0*<sub>𝔽</sub> 或 *-0*<sub>𝔽</sub>，返回 *+0*<sub>𝔽</sub>。
        1. 令 _int_ 为 truncate(ℝ(_number_))。
        1. 令 _int8bit_ 为 _int_ modulo 2<sup>8</sup>。
        1. 返回 𝔽(_int8bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-touint8clamp" type="abstract operation">
      <h1>
        ToUint8Clamp (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>对 _argument_ 进行钳制并取整，结果为 2<sup>8</sup> 个整型 Number 之一，范围 *+0*<sub>𝔽</sub> 到 *255*<sub>𝔽</sub>。</dd>
      </dl>
      <emu-alg>
        1. 令 _number_ 为 ? ToNumber(_argument_)。
        1. 如果 _number_ 是 *NaN*，返回 *+0*<sub>𝔽</sub>。
        1. 令 _mv_ 为 _number_ 的扩展数学值。
        1. 令 _clamped_ 为 _mv_ 在 0 与 255 之间钳制的结果。
        1. 令 _f_ 为 floor(_clamped_)。
        1. 如果 _clamped_ &lt; _f_ + 0.5，返回 𝔽(_f_)。
        1. 如果 _clamped_ > _f_ + 0.5，返回 𝔽(_f_ + 1)。
        1. 如果 _f_ 是偶数，返回 𝔽(_f_)；否则返回 𝔽(_f_ + 1)。
      </emu-alg>
      <emu-note>
        <p>不同于大多数整数转换操作，ToUint8Clamp 会四舍五入而不是截断非整数值，它使用“round half to even”平分舍入规则，不同于 <emu-xref href="#sec-math.round">`Math.round`</emu-xref> 的“round half up”。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-tobigint" type="abstract operation">
      <h1>
        ToBigInt (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 BigInt 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 BigInt；若需要从 Number 的隐式转换则抛出。</dd>
      </dl>
      <emu-alg>
        1. 令 _prim_ 为 ? ToPrimitive(_argument_, ~number~)。
        1. 返回 _prim_ 在 <emu-xref href="#table-tobigint"></emu-xref> 中对应的值。
      </emu-alg>
      <emu-table id="table-tobigint" caption="BigInt 转换">
        <table>
          <thead>
            <tr>
              <th>
                参数类型
              </th>
              <th>
                结果
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              Undefined
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
          <tr>
            <td>
              Null
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
          <tr>
            <td>
              Boolean
            </td>
            <td>
              若 _prim_ 为 *true* 返回 `1n`，若为 *false* 返回 `0n`。
            </td>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              返回 _prim_。
            </td>
          </tr>
          <tr>
            <td>
              Number
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
          <tr>
            <td>
              String
            </td>
            <td>
              <emu-alg>
                1. 令 _n_ 为 StringToBigInt(_prim_)。
                1. 如果 _n_ 是 *undefined*，抛出 *SyntaxError* 异常。
                1. 返回 _n_。
              </emu-alg>
            </td>
          </tr>
          <tr>
            <td>
              Symbol
            </td>
            <td>
              抛出 *TypeError* 异常。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-stringtobigint" type="abstract operation">
      <h1>
        StringToBigInt (
          _str_: 一个 String,
        ): 一个 BigInt 或 *undefined*
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _literal_ 为 ParseText(_str_, |StringIntegerLiteral|)。
        1. 如果 _literal_ 是一个错误列表，返回 *undefined*。
        1. 令 _mv_ 为 _literal_ 的 MV。
        1. 断言：_mv_ 是整数。
        1. 返回 ℤ(_mv_)。
      </emu-alg>

      <emu-clause id="sec-stringintegerliteral-grammar">
        <h1>StringIntegerLiteral 语法</h1>
        <p>StringToBigInt 使用以下语法。</p>
        <h2>Syntax</h2>
        <emu-grammar type="definition">
          StringIntegerLiteral :::
            StrWhiteSpace?
            StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?

          StrIntegerLiteral :::
            SignedInteger[~Sep]
            NonDecimalIntegerLiteral[~Sep]
        </emu-grammar>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-mv-for-stringintegerliteral">
        <h1>运行时语义：MV</h1>
        <ul>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace?</emu-grammar> 的 MV 为 0。
          </li>
          <li>
            <emu-grammar>StringIntegerLiteral ::: StrWhiteSpace? StrIntegerLiteral StrWhiteSpace?</emu-grammar> 的 MV 为 |StrIntegerLiteral| 的 MV。
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tobigint64" type="abstract operation">
      <h1>
        ToBigInt64 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 BigInt 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>64</sup> 个 BigInt 之一，范围 ℤ(-2<sup>63</sup>) 到 ℤ(2<sup>63</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _n_ 为 ? ToBigInt(_argument_)。
        1. 令 _int64bit_ 为 ℝ(_n_) modulo 2<sup>64</sup>。
        1. 如果 _int64bit_ ≥ 2<sup>63</sup>，返回 ℤ(_int64bit_ - 2<sup>64</sup>)；否则返回 ℤ(_int64bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tobiguint64" type="abstract operation">
      <h1>
        ToBigUint64 (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 BigInt 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 2<sup>64</sup> 个 BigInt 之一，范围 *0*<sub>ℤ</sub> 到 ℤ(2<sup>64</sup> - 1)（含）。</dd>
      </dl>
      <emu-alg>
        1. 令 _n_ 为 ? ToBigInt(_argument_)。
        1. 令 _int64bit_ 为 ℝ(_n_) modulo 2<sup>64</sup>。
        1. 返回 ℤ(_int64bit_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tostring" oldids="table-tostring-conversions" type="abstract operation">
      <h1>
        ToString (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个 String 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 String 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 String，返回 _argument_。
        1. 如果 _argument_ 是 Symbol，抛出 *TypeError* 异常。
        1. 如果 _argument_ 是 *undefined*，返回 *"undefined"*。
        1. 如果 _argument_ 是 *null*，返回 *"null"*。
        1. 如果 _argument_ 是 *true*，返回 *"true"*。
        1. 如果 _argument_ 是 *false*，返回 *"false"*。
        1. 如果 _argument_ 是 Number，返回 Number::toString(_argument_, 10)。
        1. 如果 _argument_ 是 BigInt，返回 BigInt::toString(_argument_, 10)。
        1. 断言：_argument_ 是 Object。
        1. 令 _primValue_ 为 ? ToPrimitive(_argument_, ~string~)。
        1. 断言：_primValue_ 不是 Object。
        1. 返回 ? ToString(_primValue_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-toobject" type="abstract operation" oldids="table-toobject-conversions,table-13">
      <h1>
        ToObject (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个 Object 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为 Object 类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 *undefined* 或 *null*，抛出 *TypeError* 异常。
        1. 如果 _argument_ 是 Boolean，返回一个新 Boolean 对象，其 [[BooleanData]] 内部槽设为 _argument_。详见 <emu-xref href="#sec-boolean-objects"></emu-xref>。
        1. 如果 _argument_ 是 Number，返回一个新 Number 对象，其 [[NumberData]] 设为 _argument_。详见 <emu-xref href="#sec-number-objects"></emu-xref>。
        1. 如果 _argument_ 是 String，返回一个新 String 对象，其 [[StringData]] 设为 _argument_。详见 <emu-xref href="#sec-string-objects"></emu-xref>。
        1. 如果 _argument_ 是 Symbol，返回一个新 Symbol 对象，其 [[SymbolData]] 设为 _argument_。详见 <emu-xref href="#sec-symbol-objects"></emu-xref>。
        1. 如果 _argument_ 是 BigInt，返回一个新 BigInt 对象，其 [[BigIntData]] 设为 _argument_。详见 <emu-xref href="#sec-bigint-objects"></emu-xref>。
        1. 断言：_argument_ 是一个 Object。
        1. 返回 _argument_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-topropertykey" type="abstract operation">
      <h1>
        ToPropertyKey (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含一个属性键的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 转换为可用作属性键的值。</dd>
      </dl>
      <emu-alg>
        1. 令 _key_ 为 ? ToPrimitive(_argument_, ~string~)。
        1. 如果 _key_ 是 Symbol，则
          1. 返回 _key_。
        1. 返回 ! ToString(_key_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tolength" type="abstract operation">
      <h1>
        ToLength (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含非负整型 Number 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _argument_ 钳制并截断为可用于类数组对象 length 的非负整型 Number。</dd>
      </dl>
      <emu-alg>
        1. 令 _len_ 为 ? ToIntegerOrInfinity(_argument_)。
        1. 如果 _len_ ≤ 0，返回 *+0*<sub>𝔽</sub>。
        1. 返回 𝔽(min(_len_, 2<sup>53</sup> - 1))。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalnumericindexstring" type="abstract operation">
      <h1>
        CanonicalNumericIndexString (
          _argument_: 一个 String,
        ): 一个 Number 或 *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>如果 _argument_ 是 *"-0"* 或者完全匹配某个 Number 值 _n_ 的 ToString(_n_)，则返回该 Number 值；否则返回 *undefined*。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 *"-0"*，返回 *-0*<sub>𝔽</sub>。
        1. 令 _n_ 为 ! ToNumber(_argument_)。
        1. 如果 ! ToString(_n_) 是 _argument_，返回 _n_。
        1. 返回 *undefined*。
      </emu-alg>
      <p><dfn variants="canonical numeric strings">规范数值字符串</dfn>是对其执行 CanonicalNumericIndexString 抽象操作不返回 *undefined* 的任意字符串。</p>
    </emu-clause>

    <emu-clause id="sec-toindex" type="abstract operation">
      <h1>
        ToIndex (
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含非负整数的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _value_ 转换为整数，若其为非负且对应整数索引则返回该整数；否则抛出异常。</dd>
      </dl>
      <emu-alg>
        1. 令 _integer_ 为 ? ToIntegerOrInfinity(_value_)。
        1. 如果 _integer_ 不在 0 到 2<sup>53</sup> - 1（含）内，抛出 *RangeError* 异常。
        1. 返回 _integer_。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>测试与比较操作 (Testing and Comparison Operations)</h1>

    <emu-clause id="sec-requireobjectcoercible" type="abstract operation" oldids="table-requireobjectcoercible-results,table-14">
      <h1>
        RequireObjectCoercible (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>若 _argument_ 不能通过 ToObject 转换为对象则抛出错误。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 是 *undefined* 或 *null*，抛出 *TypeError* 异常。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isarray" type="abstract operation">
      <h1>
        IsArray (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 如果 _argument_ 是 Array exotic object，返回 *true*。
        1. 如果 _argument_ 是 Proxy exotic object，则
          1. 执行 ? ValidateNonRevokedProxy(_argument_)。
          1. 令 _proxyTarget_ 为 _argument_.[[ProxyTarget]]。
          1. 返回 ? IsArray(_proxyTarget_)。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iscallable" type="abstract operation">
      <h1>
        IsCallable (
          _argument_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断 _argument_ 是否为具有 [[Call]] 内部方法的可调用函数。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 如果 _argument_ 具有 [[Call]] 内部方法，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isconstructor" type="abstract operation">
      <h1>
        IsConstructor (
          _argument_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断 _argument_ 是否为具有 [[Construct]] 内部方法的函数对象。</dd>
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 如果 _argument_ 具有 [[Construct]] 内部方法，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isextensible-o" type="abstract operation">
      <h1>
        IsExtensible (
          _O_: 一个 Object,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于判断是否可向 _O_ 添加额外属性。</dd>
      </dl>
      <emu-alg>
        1. 返回 ? <emu-meta effects="user-code">_O_.[[IsExtensible]]</emu-meta>()。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isregexp" type="abstract operation">
      <h1>
        IsRegExp (
          _argument_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _argument_ 不是 Object，返回 *false*。
        1. 令 _matcher_ 为 ? Get(_argument_, %Symbol.match%)。
        1. 如果 _matcher_ 不为 *undefined*，返回 ToBoolean(_matcher_)。
        1. 如果 _argument_ 有 [[RegExpMatcher]] 内部槽，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstringwellformedunicode" type="abstract operation">
      <h1>
        静态语义: IsStringWellFormedUnicode (
        _string_: 一个 String,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _string_ 视为 UTF-16 编码的代码点序列（见 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>），判断其是否为 <a href="http://www.unicode.org/glossary/#well_formed_code_unit_sequence">well formed</a> UTF-16 序列。</dd>
      </dl>
      <emu-alg>
        1. 令 _len_ 为 _string_ 的长度。
        1. 令 _k_ 为 0。
        1. 循环，当 _k_ &lt; _len_，
          1. 令 _cp_ 为 CodePointAt(_string_, _k_)。
          1. 如果 _cp_.[[IsUnpairedSurrogate]] 是 *true*，返回 *false*。
          1. 设 _k_ 为 _k_ + _cp_.[[CodeUnitCount]]。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sametype" type="abstract operation">
      <h1>
        SameType (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断两个参数是否是相同类型。</dd>
      </dl>
      <emu-alg>
        1. 如果 _x_ 是 *undefined* 且 _y_ 是 *undefined*，返回 *true*。
        1. 如果 _x_ 是 *null* 且 _y_ 是 *null*，返回 *true*。
        1. 如果 _x_ 是 Boolean 且 _y_ 是 Boolean，返回 *true*。
        1. 如果 _x_ 是 Number 且 _y_ 是 Number，返回 *true*。
        1. 如果 _x_ 是 BigInt 且 _y_ 是 BigInt，返回 *true*。
        1. 如果 _x_ 是 Symbol 且 _y_ 是 Symbol，返回 *true*。
        1. 如果 _x_ 是 String 且 _y_ 是 String，返回 *true*。
        1. 如果 _x_ 是 Object 且 _y_ 是 Object，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-samevalue" type="abstract operation">
      <h1>
        SameValue (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断两个参数是否为同一值。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *false*，返回 *false*。
        1. 如果 _x_ 是 Number，则
          1. 返回 Number::sameValue(_x_, _y_)。
        1. 返回 SameValueNonNumber(_x_, _y_)。
      </emu-alg>
      <emu-note>
        <p>该算法与严格相等算法不同之处在于：它将所有 *NaN* 视为等价，并区分 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub>。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluezero" type="abstract operation">
      <h1>
        SameValueZero (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断是否为同一值（忽略 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub> 的差别）。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *false*，返回 *false*。
        1. 如果 _x_ 是 Number，则
          1. 返回 Number::sameValueZero(_x_, _y_)。
        1. 返回 SameValueNonNumber(_x_, _y_)。
      </emu-alg>
      <emu-note>
        <p>SameValueZero 与 SameValue 唯一差别是它认为 *+0*<sub>𝔽</sub> 与 *-0*<sub>𝔽</sub> 等价。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" type="abstract operation" oldids="sec-samevaluenonnumeric">
      <h1>
        SameValueNonNumber (
          _x_: 一个 ECMAScript 语言值（非 Number),
          _y_: 一个 ECMAScript 语言值（非 Number),
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：SameType(_x_, _y_) 为 *true*。
        1. 如果 _x_ 是 *undefined* 或 *null*，返回 *true*。
        1. 如果 _x_ 是 BigInt，则
          1. 返回 BigInt::equal(_x_, _y_)。
        1. 如果 _x_ 是 String，则
          1. 如果 _x_ 与 _y_ 长度相同且相同位置的代码单元相同，返回 *true*；否则返回 *false*。
        1. 如果 _x_ 是 Boolean，则
          1. 若都为 *true* 或都为 *false*，返回 *true*；否则返回 *false*。
        1. NOTE: 其他 ECMAScript 语言值按身份比较。
        1. 如果 _x_ 是 _y_，返回 *true*；否则返回 *false*。
      </emu-alg>
      <emu-note>
        为了阐述目的，本算法中一些分支被单独列出，即便不是必须。
      </emu-note>
      <emu-note>
        “_x_ 是 _y_” 的具体含义详见 <emu-xref href="#sec-identity"></emu-xref>。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islessthan" type="abstract operation" oldids="sec-abstract-relational-comparison">
      <h1>
        IsLessThan (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
          _LeftFirst_: 一个 Boolean,
        ): 返回包含 Boolean 或 *undefined* 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>提供 _x_ &lt; _y_ 的语义，返回 *true*、*false* 或 *undefined*（表示至少一个操作数为 *NaN*）。_LeftFirst_ 标志控制可能具副作用的操作执行顺序，以符合 ECMAScript 自左向右求值规则。若 _LeftFirst_ 为 *true*，_x_ 对应的表达式位于 _y_ 左侧；否则顺序反转并需先对 _y_ 执行操作。</dd>
      </dl>
      <emu-alg>
        1. 如果 _LeftFirst_ 为 *true*，则
          1. 令 _px_ 为 ? ToPrimitive(_x_, ~number~)。
          1. 令 _py_ 为 ? ToPrimitive(_y_, ~number~)。
        1. 否则，
          1. NOTE: 需反转求值顺序以保持自左向右求值。
          1. 令 _py_ 为 ? ToPrimitive(_y_, ~number~)。
          1. 令 _px_ 为 ? ToPrimitive(_x_, ~number~)。
        1. [id="step-arc-string-check"] 如果 _px_ 是 String 且 _py_ 是 String，则
          1. 令 _lx_ 为 _px_ 的长度。
          1. 令 _ly_ 为 _py_ 的长度。
          1. 对每个整数 _i_，0 ≤ _i_ &lt; min(_lx_, _ly_) 递增：
            1. 令 _cx_ 为 _px_ 索引 _i_ 的代码单元数值。
            1. 令 _cy_ 为 _py_ 索引 _i_ 的代码单元数值。
            1. 如果 _cx_ &lt; _cy_，返回 *true*。
            1. 如果 _cx_ > _cy_，返回 *false*。
          1. 如果 _lx_ &lt; _ly_，返回 *true*；否则返回 *false*。
        1. 否则，
          1. 如果 _px_ 是 BigInt 且 _py_ 是 String，则
            1. 令 _ny_ 为 StringToBigInt(_py_)。
            1. 如果 _ny_ 是 *undefined*，返回 *undefined*。
            1. 返回 BigInt::lessThan(_px_, _ny_)。
          1. 如果 _px_ 是 String 且 _py_ 是 BigInt，则
            1. 令 _nx_ 为 StringToBigInt(_px_)。
            1. 如果 _nx_ 是 *undefined*，返回 *undefined*。
            1. 返回 BigInt::lessThan(_nx_, _py_)。
          1. NOTE: 因 _px_ 与 _py_ 是原始值，求值顺序无关。
          1. 令 _nx_ 为 ? <emu-meta suppress-effects="user-code">ToNumeric(_px_)</emu-meta>。
          1. 令 _ny_ 为 ? <emu-meta suppress-effects="user-code">ToNumeric(_py_)</emu-meta>。
          1. 如果 SameType(_nx_, _ny_) 为 *true*，则
            1. 如果 _nx_ 是 Number，
              1. 返回 Number::lessThan(_nx_, _ny_)。
            1. 否则，
              1. 断言：_nx_ 是 BigInt。
              1. 返回 BigInt::lessThan(_nx_, _ny_)。
          1. 断言：_nx_ 是 BigInt 且 _ny_ 是 Number，或 _nx_ 是 Number 且 _ny_ 是 BigInt。
          1. 如果 _nx_ 或 _ny_ 是 *NaN*，返回 *undefined*。
          1. 如果 _nx_ 是 *-∞*<sub>𝔽</sub> 或 _ny_ 是 *+∞*<sub>𝔽</sub>，返回 *true*。
          1. 如果 _nx_ 是 *+∞*<sub>𝔽</sub> 或 _ny_ 是 *-∞*<sub>𝔽</sub>，返回 *false*。
          1. 如果 ℝ(_nx_) &lt; ℝ(_ny_)，返回 *true*；否则返回 *false*。
      </emu-alg>
      <emu-note>
        <p>步骤 <emu-xref href="#step-arc-string-check"></emu-xref> 与加法运算符 `+` 算法 (<emu-xref href="#sec-applystringornumericbinaryoperator"></emu-xref>) 中的步骤 <emu-xref href="#step-binary-op-string-check"></emu-xref> 不同之处在于这里使用逻辑与，而非逻辑或。</p>
      </emu-note>
      <emu-note>
        <p>字符串比较使用 UTF-16 代码单元的简单字典序，不使用 Unicode 中更复杂的按语义等价或排序规则。因此按 Unicode 标准规范等价但不同规范化形式的字符串可能判定为不相等；含代理对的字符串按代码单元排序与按代码点排序可能不同。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-islooselyequal" type="abstract operation" oldids="sec-abstract-equality-comparison,sec-IsHTMLDDA-internal-slot-aec">
      <h1>
        IsLooselyEqual (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`==` 运算符的语义。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *true*，则
          1. 返回 IsStrictlyEqual(_x_, _y_)。
        1. 如果 _x_ 是 *null* 且 _y_ 是 *undefined*，返回 *true*。
        1. 如果 _x_ 是 *undefined* 且 _y_ 是 *null*，返回 *true*。
        1. [id="step-abstract-equality-comparison-web-compat-insertion-point", normative-optional] 若宿主是 web 浏览器或支持 <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>：
          1. 若 _x_ 是 Object、具有 [[IsHTMLDDA]] 且 _y_ 是 *undefined* 或 *null*，返回 *true*。
          1. 若 _x_ 是 *undefined* 或 *null*，_y_ 是具有 [[IsHTMLDDA]] 的 Object，返回 *true*。
        1. 如果 _x_ 是 Number 且 _y_ 是 String，返回 ! IsLooselyEqual(_x_, ! ToNumber(_y_))。
        1. 如果 _x_ 是 String 且 _y_ 是 Number，返回 ! IsLooselyEqual(! ToNumber(_x_), _y_)。
        1. 如果 _x_ 是 BigInt 且 _y_ 是 String，则
          1. 令 _n_ 为 StringToBigInt(_y_)。
          1. 如果 _n_ 是 *undefined*，返回 *false*。
          1. 返回 ! IsLooselyEqual(_x_, _n_)。
        1. 如果 _x_ 是 String 且 _y_ 是 BigInt，返回 ! IsLooselyEqual(_y_, _x_)。
        1. 如果 _x_ 是 Boolean，返回 ! IsLooselyEqual(! ToNumber(_x_), _y_)。
        1. 如果 _y_ 是 Boolean，返回 ! IsLooselyEqual(_x_, ! ToNumber(_y_))。
        1. 如果 _x_ 是 String / Number / BigInt / Symbol 且 _y_ 是 Object，返回 ! IsLooselyEqual(_x_, ? ToPrimitive(_y_))。
        1. 如果 _x_ 是 Object 且 _y_ 是 String / Number / BigInt / Symbol，返回 ! IsLooselyEqual(? ToPrimitive(_x_), _y_)。
        1. 如果 (_x_ BigInt 且 _y_ Number) 或 (_x_ Number 且 _y_ BigInt)，则
          1. 若 _x_ 非有限或 _y_ 非有限，返回 *false*。
          1. 若 ℝ(_x_) = ℝ(_y_)，返回 *true*；否则返回 *false*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isstrictlyequal" type="abstract operation" oldids="sec-strict-equality-comparison">
      <h1>
        IsStrictlyEqual (
          _x_: 一个 ECMAScript 语言值,
          _y_: 一个 ECMAScript 语言值,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>`===` 运算符的语义。</dd>
      </dl>
      <emu-alg>
        1. 如果 SameType(_x_, _y_) 为 *false*，返回 *false*。
        1. 如果 _x_ 是 Number，则
          1. 返回 Number::equal(_x_, _y_)。
        1. 返回 SameValueNonNumber(_x_, _y_)。
      </emu-alg>
      <emu-note>
        <p>该算法与 SameValue 算法在带符号零和 NaN 的处理上不同。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-objects">
    <h1>对象操作 (Operations on Objects)</h1>

    <emu-clause id="sec-makebasicobject" type="abstract operation">
      <h1>
        MakeBasicObject (
          _internalSlotsList_: 一个内部槽名称的 List,
        ): 一个 Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>是所有算法创建 ECMAScript 对象（普通或特殊）的基础，它抽出创建所有对象的通用步骤并集中化对象创建。</dd>
      </dl>

      <emu-alg>
        1. 将 _internalSlotsList_ 设为其与 « [[PrivateElements]] » 的列表拼接。
        1. 令 _obj_ 为一个新创建的对象，对 _internalSlotsList_ 中每个名称建一个内部槽。
        1. NOTE: 如 <emu-xref href="#sec-object-internal-methods-and-internal-slots" title></emu-xref> 所述，除非另有说明，每个内部槽初始值为 *undefined*。
        1. 设置 _obj_.[[PrivateElements]] 为一个新的空 List。
        1. 将 _obj_ 的基本内部方法设为 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 指定的普通对象默认定义。
        1. 断言：若调用者不会同时覆写 _obj_ 的 [[GetPrototypeOf]] 和 [[SetPrototypeOf]]，则 _internalSlotsList_ 包含 [[Prototype]]。
        1. 断言：若调用者不会全部覆写 _obj_ 的 [[SetPrototypeOf]]、[[IsExtensible]]、[[PreventExtensions]]，则 _internalSlotsList_ 包含 [[Extensible]]。
        1. 如果 _internalSlotsList_ 包含 [[Extensible]]，设 _obj_.[[Extensible]] 为 *true*。
        1. 返回 _obj_。
      </emu-alg>

      <emu-note>
        <p>在本规范中，特殊对象（exotic objects）通过如 ArrayCreate、BoundFunctionCreate 等抽象操作创建：先调用 MakeBasicObject 得到基础对象，再覆写其部分或全部内部方法。为封装特殊对象创建，其基本内部方法不会在这些操作之外被修改。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-get-o-p" type="abstract operation">
      <h1>
        Get (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于获取对象特定属性的值。</dd>
      </dl>
      <emu-alg>
        1. 返回 ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _O_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getv" type="abstract operation">
      <h1>
        GetV (
          _V_: 一个 ECMAScript 语言值,
          _P_: 一个属性键,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于获取一个 ECMAScript 语言值特定属性的值；若该值不是对象，则通过类型对应的包装对象执行属性查找。</dd>
      </dl>
      <emu-alg>
        1. 令 _O_ 为 ? ToObject(_V_)。
        1. 返回 ? <emu-meta effects="user-code">_O_.[[Get]]</emu-meta>(_P_, _V_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-set-o-p-v-throw" type="abstract operation">
      <h1>
        Set (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
          _Throw_: 一个 Boolean,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>设置对象特定属性的值，_V_ 是新值。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? <emu-meta effects="user-code">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_)。
        1. 若 _success_ 为 *false* 且 _Throw_ 为 *true*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createdataproperty" type="abstract operation">
      <h1>
        CreateDataProperty (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建对象的一个新的自身属性。</dd>
      </dl>
      <emu-alg>
        1. 令 _newDesc_ 为 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
        1. 返回 ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_)。
      </emu-alg>
      <emu-note>
        <p>此操作创建的属性特性与语言赋值运算符新建属性时的默认特性相同。通常该属性不存在；若已存在且不可配置，或 _O_ 不可扩展，则 [[DefineOwnProperty]] 返回 *false*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createdatapropertyorthrow" type="abstract operation">
      <h1>
        CreateDataPropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建对象一个新的自身属性。如果该属性更新无法执行则抛出 *TypeError*。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? CreateDataProperty(_O_, _P_, _V_)。
        1. 若 _success_ 为 *false*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>与 CreateDataProperty 类似，但失败时抛出异常。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createnonenumerabledatapropertyorthrow" type="abstract operation">
      <h1>
        CreateNonEnumerableDataPropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _V_: 一个 ECMAScript 语言值,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个新的不可枚举自身数据属性（普通对象）。</dd>
      </dl>
      <emu-alg>
        1. 断言：_O_ 是可扩展、普通对象，且无不可配置属性。
        1. 令 _newDesc_ 为 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }。
        1. 执行 ! DefinePropertyOrThrow(_O_, _P_, _newDesc_)。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>特性与赋值运算符默认值相同，唯独 [[Enumerable]] 为 *false*。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-definepropertyorthrow" type="abstract operation">
      <h1>
        DefinePropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
          _desc_: 一个 Property Descriptor,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>以会在失败时抛出 *TypeError* 的方式调用对象的 [[DefineOwnProperty]]。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? <emu-meta effects="user-code">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_)。
        1. 若 _success_ 为 *false*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-deletepropertyorthrow" type="abstract operation">
      <h1>
        DeletePropertyOrThrow (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>移除对象的指定自身属性；若属性不可配置则抛出异常。</dd>
      </dl>
      <emu-alg>
        1. 令 _success_ 为 ? <emu-meta effects="user-code">_O_.[[Delete]]</emu-meta>(_P_)。
        1. 若 _success_ 为 *false*，抛出 *TypeError*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getmethod" type="abstract operation">
      <h1>
        GetMethod (
          _V_: 一个 ECMAScript 语言值,
          _P_: 一个属性键,
        ): 返回包含函数对象或 *undefined* 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>获取一个 ECMAScript 语言值的指定属性值，并期望其为函数。</dd>
      </dl>
      <emu-alg>
        1. 令 _func_ 为 ? GetV(_V_, _P_)。
        1. 如果 _func_ 是 *undefined* 或 *null*，返回 *undefined*。
        1. 如果 IsCallable(_func_) 为 *false*，抛出 *TypeError*。
        1. 返回 _func_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasproperty" type="abstract operation">
      <h1>
        HasProperty (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断对象是否具有指定键的属性（自身或继承）。</dd>
      </dl>
      <emu-alg>
        1. 返回 ? <emu-meta effects="user-code">_O_.[[HasProperty]]</emu-meta>(_P_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hasownproperty" type="abstract operation">
      <h1>
        HasOwnProperty (
          _O_: 一个 Object,
          _P_: 一个属性键,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断对象是否具有指定键的自身属性。</dd>
      </dl>
      <emu-alg>
        1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 如果 _desc_ 是 *undefined*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-call" type="abstract operation">
      <h1>
        Call (
        _F_: 一个 ECMAScript 语言值,
        _V_: 一个 ECMAScript 语言值,
        可选 _argumentsList_: 一个 ECMAScript 语言值的 List,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用函数对象的 [[Call]] 内部方法。_F_ 是函数对象，_V_ 为 *this* 值，_argumentsList_ 为传递的参数列表。若 _argumentsList_ 不存在，使用新的空 List。</dd>
      </dl>
      <emu-alg>
        1. 若 _argumentsList_ 不存在，设其为新空 List。
        1. 若 IsCallable(_F_) 为 *false*，抛出 *TypeError*。
        1. 返回 ? <emu-meta effects="user-code">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-construct" type="abstract operation">
      <h1>
        Construct (
        _F_: 一个 constructor,
        可选 _argumentsList_: ECMAScript 语言值 List,
        可选 _newTarget_: 一个 constructor,
        ): 返回包含一个 Object 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用函数对象的 [[Construct]] 内部方法。_argumentsList_ 与 _newTarget_ 为对应参数；若 _argumentsList_ 缺省，用新空 List；若 _newTarget_ 缺省，用 _F_。</dd>
      </dl>
      <emu-alg>
        1. 若 _newTarget_ 不存在，设为 _F_。
        1. 若 _argumentsList_ 不存在，设为新空 List。
        1. 返回 ? <emu-meta effects="user-code">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_)。
      </emu-alg>
      <emu-note>
        <p>若 _newTarget_ 不存在，等价于：`new F(...argumentsList)`。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-setintegritylevel" type="abstract operation">
      <h1>
        SetIntegrityLevel (
          _O_: 一个 Object,
          _level_: ~sealed~ 或 ~frozen~,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>固定对象自身属性集合。</dd>
      </dl>
      <emu-alg>
        1. 令 _status_ 为 ? _O_.[[PreventExtensions]]()。
        1. 若 _status_ 为 *false*，返回 *false*。
        1. 令 _keys_ 为 ? _O_.[[OwnPropertyKeys]]()。
        1. 如果 _level_ 为 ~sealed~，则
          1. 对 _keys_ 中每个 _k_：
            1. 执行 ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* })。
        1. 否则，
          1. 断言：_level_ 为 ~frozen~。
          1. 对 _keys_ 中每个 _k_：
            1. 令 _currentDesc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)。
            1. 若 _currentDesc_ 不为 *undefined*，则
              1. 如果 IsAccessorDescriptor(_currentDesc_) 为 *true*，
                1. 令 _desc_ 为 PropertyDescriptor { [[Configurable]]: *false* }。
              1. 否则，
                1. 令 _desc_ 为 PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }。
              1. 执行 ? DefinePropertyOrThrow(_O_, _k_, _desc_)。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-testintegritylevel" type="abstract operation">
      <h1>
        TestIntegrityLevel (
          _O_: 一个 Object,
          _level_: ~sealed~ 或 ~frozen~,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>判断对象自身属性集合是否已固定。</dd>
      </dl>
      <emu-alg>
        1. 令 _extensible_ 为 ? IsExtensible(_O_)。
        1. 若 _extensible_ 为 *true*，返回 *false*。
        1. NOTE: 若对象可扩展，不检查属性。
        1. 令 _keys_ 为 ? _O_.[[OwnPropertyKeys]]()。
        1. 对 _keys_ 中每个 _k_：
          1. 令 _currentDesc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_k_)。
          1. 若 _currentDesc_ 不为 *undefined*，则
            1. 若 _currentDesc_.[[Configurable]] 为 *true*，返回 *false*。
            1. 若 _level_ 为 ~frozen~ 且 IsDataDescriptor(_currentDesc_) 为 *true*，则
              1. 若 _currentDesc_.[[Writable]] 为 *true*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createarrayfromlist" type="abstract operation">
      <h1>
        CreateArrayFromList (
          _elements_: 一个 ECMAScript 语言值的 List,
        ): 一个 Array
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个其元素由 _elements_ 提供的数组。</dd>
      </dl>
      <emu-alg>
        1. 令 _array_ 为 ! ArrayCreate(0)。
        1. 令 _n_ 为 0。
        1. 对 _elements_ 中每个 _e_：
          1. 执行 ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_)。
          1. 设 _n_ 为 _n_ + 1。
        1. 返回 _array_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-lengthofarraylike" type="abstract operation">
      <h1>
        LengthOfArrayLike (
          _obj_: 一个 Object,
        ): 返回包含非负整数的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回类数组对象 *"length"* 属性的值。</dd>
      </dl>
      <emu-alg>
        1. 返回 ℝ(? ToLength(? Get(_obj_, *"length"*))).
      </emu-alg>
      <p><dfn variants="array-like objects">类数组对象</dfn> 指此操作能正常完成的任意对象。</p>
      <emu-note>
        通常类数组对象也具有一些整型索引属性，但这不是定义要求。
      </emu-note>
      <emu-note>
        Array 和 String 对象是类数组对象的例子。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createlistfromarraylike" type="abstract operation">
      <h1>
        CreateListFromArrayLike (
        _obj_: 一个 ECMAScript 语言值,
        可选 _validElementTypes_: ~all~ 或 ~property-key~,
        ): 返回包含 ECMAScript 语言值 List 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个 List，其元素由 _obj_ 的按索引属性提供；_validElementTypes_ 指定允许的元素类型。</dd>
      </dl>
      <emu-alg>
        1. 若 _validElementTypes_ 不存在，设为 ~all~。
        1. 若 _obj_ 不是 Object，抛出 *TypeError*。
        1. 令 _len_ 为 ? LengthOfArrayLike(_obj_)。
        1. 令 _list_ 为新空 List。
        1. 令 _index_ 为 0。
        1. 当 _index_ &lt; _len_：
          1. 令 _indexName_ 为 ! ToString(𝔽(_index_))。
          1. 令 _next_ 为 ? Get(_obj_, _indexName_)。
          1. 若 _validElementTypes_ 为 ~property-key~ 且 _next_ 不是属性键，抛出 *TypeError*。
          1. 将 _next_ 附加到 _list_。
          1. 设 _index_ 为 _index_ + 1。
        1. 返回 _list_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-invoke" type="abstract operation">
      <h1>
        Invoke (
        _V_: 一个 ECMAScript 语言值,
        _P_: 一个属性键,
        可选 _argumentsList_: ECMAScript 语言值 List,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用一个 ECMAScript 语言值的方法属性，_V_ 既作为查找点又作为 *this* 值。_argumentsList_ 为传入参数，缺省用空 List。</dd>
      </dl>

      <emu-alg>
        1. 若 _argumentsList_ 不存在，设为新空 List。
        1. 令 _func_ 为 ? GetV(_V_, _P_)。
        1. 返回 ? Call(_func_, _V_, _argumentsList_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryhasinstance" type="abstract operation">
      <h1>
        OrdinaryHasInstance (
          _C_: 一个 ECMAScript 语言值,
          _O_: 一个 ECMAScript 语言值,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>实现默认算法：判断 _O_ 是否继承自 _C_ 提供的实例继承路径。</dd>
      </dl>
      <emu-alg>
        1. 若 IsCallable(_C_) 为 *false*，返回 *false*。
        1. 若 _C_ 有 [[BoundTargetFunction]] 内部槽，则
          1. 令 _BC_ 为 _C_.[[BoundTargetFunction]]。
          1. 返回 ? InstanceofOperator(_O_, _BC_)。
        1. 若 _O_ 不是 Object，返回 *false*。
        1. 令 _P_ 为 ? Get(_C_, *"prototype"*)。
        1. 若 _P_ 不是 Object，抛出 *TypeError*。
        1. 循环：
          1. 设 _O_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
          1. 若 _O_ 是 *null*，返回 *false*。
          1. 若 SameValue(_P_, _O_) 为 *true*，返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-speciesconstructor" type="abstract operation">
      <h1>
        SpeciesConstructor (
          _O_: 一个 Object,
          _defaultConstructor_: 一个 constructor,
        ): 返回包含 constructor 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>获取用于创建从 _O_ 派生的新对象的构造函数；若从 _O_ 开始找不到 %Symbol.species% 属性则使用 _defaultConstructor_。</dd>
      </dl>
      <emu-alg>
        1. 令 _C_ 为 ? Get(_O_, *"constructor"*)。
        1. 若 _C_ 是 *undefined*，返回 _defaultConstructor_。
        1. 若 _C_ 不是 Object，抛出 *TypeError*。
        1. 令 _S_ 为 ? Get(_C_, %Symbol.species%)。
        1. 若 _S_ 是 *undefined* 或 *null*，返回 _defaultConstructor_。
        1. 若 IsConstructor(_S_) 为 *true*，返回 _S_。
        1. 抛出 *TypeError*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-enumerableownproperties" type="abstract operation" oldids="sec-enumerableownpropertynames">
      <h1>
        EnumerableOwnProperties (
          _O_: 一个 Object,
          _kind_: ~key~, ~value~, 或 ~key+value~,
        ): 返回包含 ECMAScript 语言值 List 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _ownKeys_ 为 ? <emu-meta effects="user-code">_O_.[[OwnPropertyKeys]]</emu-meta>()。
        1. 令 _results_ 为新空 List。
        1. 对 _ownKeys_ 中每个 _key_：
          1. 如果 _key_ 是 String，则
            1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_)。
            1. 若 _desc_ 不为 *undefined* 且 _desc_.[[Enumerable]] 为 *true*，则
              1. 如果 _kind_ 为 ~key~，
                1. 将 _key_ 加入 _results_。
              1. 否则，
                1. 令 _value_ 为 ? Get(_O_, _key_)。
                1. 若 _kind_ 为 ~value~，
                  1. 将 _value_ 加入 _results_。
                1. 否则，
                  1. 断言：_kind_ 为 ~key+value~。
                  1. 令 _entry_ 为 CreateArrayFromList(« _key_, _value_ »)。
                  1. 将 _entry_ 加入 _results_。
        1. 返回 _results_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getfunctionrealm" type="abstract operation">
      <h1>
        GetFunctionRealm (
          _obj_: 一个函数对象,
        ): 返回包含 Realm Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _obj_ 有 [[Realm]] 内部槽，
          1. 返回 _obj_.[[Realm]]。
        1. 若 _obj_ 是绑定函数特殊对象，
          1. 令 _boundTargetFunction_ 为 _obj_.[[BoundTargetFunction]]。
          1. 返回 ? GetFunctionRealm(_boundTargetFunction_)。
        1. 若 _obj_ 是 Proxy 特殊对象，
          1. 执行 ? ValidateNonRevokedProxy(_obj_)。
          1. 令 _proxyTarget_ 为 _obj_.[[ProxyTarget]]。
          1. 断言：_proxyTarget_ 是函数对象。
          1. 返回 ? GetFunctionRealm(_proxyTarget_)。
        1. [id="step-getfunctionrealm-default-return"] 返回当前 Realm Record。
      </emu-alg>
      <emu-note>
        <p>仅当 _obj_ 是无 [[Realm]] 内部槽的非标准函数特殊对象时才会到达步骤 <emu-xref href="#step-getfunctionrealm-default-return"></emu-xref>。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-copydataproperties" type="abstract operation">
      <h1>
        CopyDataProperties (
          _target_: 一个 Object,
          _source_: 一个 ECMAScript 语言值,
          _excludedItems_: 一个属性键的 List,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _source_ 是 *undefined* 或 *null*，返回 ~unused~。
        1. 令 _from_ 为 ! ToObject(_source_)。
        1. 令 _keys_ 为 ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]</emu-meta>()。
        1. 对 _keys_ 中每个 _nextKey_：
          1. 令 _excluded_ 为 *false*。
          1. 对 _excludedItems_ 中每个 _e_：
            1. 若 SameValue(_e_, _nextKey_) 为 *true*，
              1. 设 _excluded_ 为 *true*。
          1. 若 _excluded_ 为 *false*，则
            1. 令 _desc_ 为 ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_)。
            1. 若 _desc_ 不为 *undefined* 且 _desc_.[[Enumerable]] 为 *true*，
              1. 令 _propValue_ 为 ? Get(_from_, _nextKey_)。
              1. 执行 ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_)。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>此处的 target 总是新创建且在抛错情况下不可被直接访问。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-privateelementfind" type="abstract operation">
      <h1>
        PrivateElementFind (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
        ): 一个 PrivateElement 或 ~empty~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _O_.[[PrivateElements]] 包含 PrivateElement _pe_ 且 _pe_.[[Key]] 是 _P_，
          1. 返回 _pe_。
        1. 返回 ~empty~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatefieldadd" type="abstract operation">
      <h1>
        PrivateFieldAdd (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若宿主是 web 浏览器，
          1. 执行 ? HostEnsureCanAddPrivateElement(_O_)。
        1. 令 _entry_ 为 PrivateElementFind(_O_, _P_)。
        1. 若 _entry_ 不为 ~empty~，抛出 *TypeError*。
        1. 将 PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ } 附加到 _O_.[[PrivateElements]]。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privatemethodoraccessoradd" type="abstract operation">
      <h1>
        PrivateMethodOrAccessorAdd (
          _O_: 一个 Object,
          _method_: 一个 PrivateElement,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_method_.[[Kind]] 是 ~method~ 或 ~accessor~。
        1. 若宿主是 web 浏览器，
          1. 执行 ? HostEnsureCanAddPrivateElement(_O_)。
        1. 令 _entry_ 为 PrivateElementFind(_O_, _method_.[[Key]])。
        1. 若 _entry_ 不为 ~empty~，抛出 *TypeError*。
        1. 将 _method_ 附加到 _O_.[[PrivateElements]]。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-note>
        <p>私有方法与访问器的值在实例之间共享，不会为每个实例复制。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostensurecanaddprivateelement" type="host-defined abstract operation">
      <h1>
        HostEnsureCanAddPrivateElement (
          _O_: 一个 Object,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>允许宿主环境阻止某些宿主定义特殊对象添加私有元素。</dd>
      </dl>
      <p>实现需符合：</p>
      <ul>
        <li>若 _O_ 不是宿主定义的特殊对象，则返回 NormalCompletion(~unused~) 且不做其它步骤。</li>
        <li>对相同参数的两次调用返回同种 Completion Record。</li>
      </ul>
      <p>默认实现为返回 NormalCompletion(~unused~)。</p>
      <p>仅由作为 web 浏览器的 ECMAScript 宿主调用。</p>
    </emu-clause>

    <emu-clause id="sec-privateget" type="abstract operation">
      <h1>
        PrivateGet (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _entry_ 为 PrivateElementFind(_O_, _P_)。
        1. 若 _entry_ 是 ~empty~，抛出 *TypeError*。
        1. 若 _entry_.[[Kind]] 是 ~field~ 或 ~method~，
          1. 返回 _entry_.[[Value]]。
        1. 断言：_entry_.[[Kind]] 是 ~accessor~。
        1. 若 _entry_.[[Get]] 是 *undefined*，抛出 *TypeError*。
        1. 令 _getter_ 为 _entry_.[[Get]]。
        1. 返回 ? Call(_getter_, _O_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-privateset" type="abstract operation">
      <h1>
        PrivateSet (
          _O_: 一个 Object,
          _P_: 一个 Private Name,
          _value_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _entry_ 为 PrivateElementFind(_O_, _P_)。
        1. 若 _entry_ 是 ~empty~，抛出 *TypeError*。
        1. 若 _entry_.[[Kind]] 是 ~field~，则
          1. 设 _entry_.[[Value]] 为 _value_。
        1. 否则如果 _entry_.[[Kind]] 是 ~method~，
          1. 抛出 *TypeError*。
        1. 否则，
          1. 断言：_entry_.[[Kind]] 是 ~accessor~。
          1. 若 _entry_.[[Set]] 是 *undefined*，抛出 *TypeError*。
          1. 令 _setter_ 为 _entry_.[[Set]]。
          1. 执行 ? Call(_setter_, _O_, « _value_ »)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definefield" type="abstract operation">
      <h1>
        DefineField (
          _receiver_: 一个 Object,
          _fieldRecord_: 一个 ClassFieldDefinition Record,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _fieldName_ 为 _fieldRecord_.[[Name]]。
        1. 令 _initializer_ 为 _fieldRecord_.[[Initializer]]。
        1. 如果 _initializer_ 不是 ~empty~，
          1. 令 _initValue_ 为 ? Call(_initializer_, _receiver_)。
        1. 否则，
          1. 令 _initValue_ 为 *undefined*。
        1. 若 _fieldName_ 是 Private Name，
          1. 执行 ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_)。
        1. 否则，
          1. 断言：_fieldName_ 是属性键。
          1. 执行 ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializeinstanceelements" type="abstract operation">
      <h1>
        InitializeInstanceElements (
          _O_: 一个 Object,
          _constructor_: 一个 ECMAScript 函数对象,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _methods_ 为 _constructor_.[[PrivateMethods]]。
        1. 对 _methods_ 中每个 PrivateElement _method_：
          1. 执行 ? PrivateMethodOrAccessorAdd(_O_, _method_)。
        1. 令 _fields_ 为 _constructor_.[[Fields]]。
        1. 对 _fields_ 中每个 _fieldRecord_：
          1. 执行 ? DefineField(_O_, _fieldRecord_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-add-value-to-keyed-group" type="abstract operation">
      <h1>
        AddValueToKeyedGroup (
          _groups_: 一个包含 [[Key]] (ECMAScript 语言值) 与 [[Elements]] (值 List) 字段的 Record List,
          _key_: 一个 ECMAScript 语言值,
          _value_: 一个 ECMAScript 语言值,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 对 _groups_ 中每个 Record { [[Key]], [[Elements]] } _g_：
          1. 若 SameValue(_g_.[[Key]], _key_) 为 *true*，则
            1. 断言：恰有一个元素符合。
            1. 将 _value_ 加入 _g_.[[Elements]]。
            1. 返回 ~unused~。
        1. 令 _group_ 为 Record { [[Key]]: _key_, [[Elements]]: « _value_ » }。
        1. 将 _group_ 加入 _groups_。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-groupby" type="abstract operation">
      <h1>
        GroupBy (
          _items_: 一个 ECMAScript 语言值,
          _callback_: 一个 ECMAScript 语言值,
          _keyCoercion_: ~property~ 或 ~collection~,
        ): 返回包含带 [[Key]] 与 [[Elements]] 字段的 Record List 的正常完成，或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 执行 ? RequireObjectCoercible(_items_)。
        1. 若 IsCallable(_callback_) 为 *false*，抛出 *TypeError*。
        1. 令 _groups_ 为新空 List。
        1. 令 _iteratorRecord_ 为 ? GetIterator(_items_, ~sync~)。
        1. 令 _k_ 为 0。
        1. 循环：
          1. 若 _k_ ≥ 2<sup>53</sup> - 1，则
            1. 令 _error_ 为 ThrowCompletion(新建 *TypeError* 对象)。
            1. 返回 ? IteratorClose(_iteratorRecord_, _error_)。
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 若 _next_ 是 ~done~，
            1. 返回 _groups_。
          1. 令 _value_ 为 _next_。
          1. 令 _key_ 为 Completion(Call(_callback_, *undefined*, « _value_, 𝔽(_k_) »))。
          1. IfAbruptCloseIterator(_key_, _iteratorRecord_)。
          1. 若 _keyCoercion_ 为 ~property~，则
            1. 设 _key_ 为 Completion(ToPropertyKey(_key_))。
            1. IfAbruptCloseIterator(_key_, _iteratorRecord_)。
          1. 否则，
            1. 断言：_keyCoercion_ 为 ~collection~。
            1. 设 _key_ 为 CanonicalizeKeyedCollectionKey(_key_)。
          1. 执行 AddValueToKeyedGroup(_groups_, _key_, _value_)。
          1. 设 _k_ 为 _k_ + 1。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-SetterThatIgnoresPrototypeProperties" type="abstract operation">
      <h1>
        SetterThatIgnoresPrototypeProperties (
          _thisValue_: 一个 ECMAScript 语言值,
          _home_: 一个 Object,
          _p_: 一个属性键,
          _v_: 一个 ECMAScript 语言值,
        ): 返回包含 ~unused~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _thisValue_ 不是 Object，
          1. 抛出 *TypeError*。
        1. 如果 SameValue(_thisValue_, _home_) 为 *true*，
          1. NOTE: 此处抛出模拟在严格模式下给 _home_ 不可写数据属性赋值。
          1. 抛出 *TypeError*。
        1. 令 _desc_ 为 ? _thisValue_.[[GetOwnProperty]](_p_)。
        1. 若 _desc_ 是 *undefined*，
          1. 执行 ? CreateDataPropertyOrThrow(_thisValue_, _p_, _v_)。
        1. 否则，
          1. 执行 ? Set(_thisValue_, _p_, _v_, *true*)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-operations-on-iterator-objects">
    <h1>迭代器对象操作 (Operations on Iterator Objects)</h1>
    <p>参见通用迭代接口 (<emu-xref href="#sec-iteration"></emu-xref>)。</p>

    <emu-clause id="sec-iterator-records">
      <h1>Iterator Records</h1>
      <p><dfn variants="Iterator Records">Iterator Record</dfn> 是一个 Record，用于封装迭代器或异步迭代器及其 `next` 方法。</p>
      <p>Iterator Record 拥有 <emu-xref href="#table-iterator-record-fields"></emu-xref> 所列字段。</p>
      <emu-table id="table-iterator-record-fields" caption="Iterator Record 字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Iterator]]
            </td>
            <td>
              一个 Object
            </td>
            <td>
              符合迭代器或异步迭代器接口的对象。
            </td>
          </tr>
          <tr>
            <td>
              [[NextMethod]]
            </td>
            <td>
              一个 ECMAScript 语言值
            </td>
            <td>
              [[Iterator]] 对象的 `next` 方法。
            </td>
          </tr>
          <tr>
            <td>
              [[Done]]
            </td>
            <td>
              一个 Boolean
            </td>
            <td>
              迭代器是否已完成或被关闭。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-getiteratordirect" type="abstract operation">
      <h1>
        GetIteratorDirect (
          _obj_: 一个 Object,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _nextMethod_ 为 ? Get(_obj_, *"next"*)。
        1. 令 _iteratorRecord_ 为 Iterator Record { [[Iterator]]: _obj_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }。
        1. 返回 _iteratorRecord_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorfrommethod" type="abstract operation">
      <h1>
        GetIteratorFromMethod (
          _obj_: 一个 ECMAScript 语言值,
          _method_: 一个函数对象,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _iterator_ 为 ? Call(_method_, _obj_)。
        1. 若 _iterator_ 不是 Object，抛出 *TypeError*。
        1. 返回 ? GetIteratorDirect(_iterator_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiterator" type="abstract operation">
      <h1>
        GetIterator (
          _obj_: 一个 ECMAScript 语言值,
          _kind_: ~sync~ 或 ~async~,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _kind_ 为 ~async~，则
          1. 令 _method_ 为 ? GetMethod(_obj_, %Symbol.asyncIterator%)。
          1. 若 _method_ 是 *undefined*，则
            1. 令 _syncMethod_ 为 ? GetMethod(_obj_, %Symbol.iterator%)。
            1. 若 _syncMethod_ 是 *undefined*，抛出 *TypeError*。
            1. 令 _syncIteratorRecord_ 为 ? GetIteratorFromMethod(_obj_, _syncMethod_)。
            1. 返回 CreateAsyncFromSyncIterator(_syncIteratorRecord_)。
        1. 否则，
          1. 令 _method_ 为 ? GetMethod(_obj_, %Symbol.iterator%)。
        1. 若 _method_ 是 *undefined*，抛出 *TypeError*。
        1. 返回 ? GetIteratorFromMethod(_obj_, _method_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getiteratorflattenable" type="abstract operation">
      <h1>
        GetIteratorFlattenable (
          _obj_: 一个 ECMAScript 语言值,
          _primitiveHandling_: ~iterate-string-primitives~ 或 ~reject-primitives~,
        ): 返回包含 Iterator Record 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _obj_ 不是 Object，则
          1. 若 _primitiveHandling_ 为 ~reject-primitives~，抛出 *TypeError*。
          1. 断言：_primitiveHandling_ 为 ~iterate-string-primitives~。
          1. 若 _obj_ 不是 String，抛出 *TypeError*。
        1. 令 _method_ 为 ? GetMethod(_obj_, %Symbol.iterator%)。
        1. 若 _method_ 是 *undefined*，
          1. 令 _iterator_ 为 _obj_。
        1. 否则，
          1. 令 _iterator_ 为 ? Call(_method_, _obj_)。
        1. 若 _iterator_ 不是 Object，抛出 *TypeError*。
        1. 返回 ? GetIteratorDirect(_iterator_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratornext" type="abstract operation">
      <h1>
        IteratorNext (
        _iteratorRecord_: 一个 Iterator Record,
        可选 _value_: 一个 ECMAScript 语言值,
        ): 返回包含一个 Object 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 如果 _value_ 不存在，
          1. 令 _result_ 为 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]))。
        1. 否则，
          1. 令 _result_ 为 Completion(Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »))。
        1. 若 _result_ 是 throw completion，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 返回 ? _result_。
        1. 设 _result_ 为 ! _result_。
        1. 若 _result_ 不是 Object，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 抛出 *TypeError*。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorcomplete" type="abstract operation">
      <h1>
        IteratorComplete (
          _iteratorResult_: 一个 Object,
        ): 返回包含 Boolean 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 返回 ToBoolean(? Get(_iteratorResult_, *"done"*))。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorvalue" type="abstract operation">
      <h1>
        IteratorValue (
          _iteratorResult_: 一个 Object,
        ): 返回包含一个 ECMAScript 语言值的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 返回 ? Get(_iteratorResult_, *"value"*)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstep" type="abstract operation">
      <h1>
        IteratorStep (
          _iteratorRecord_: 一个 Iterator Record,
        ): 返回包含一个 Object 或 ~done~ 的正常完成或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>调用 _iteratorRecord_.[[NextMethod]] 请求下一个值；若迭代结束返回 ~done~，否则返回 IteratorResult 对象。</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为 ? IteratorNext(_iteratorRecord_)。
        1. 令 _done_ 为 Completion(IteratorComplete(_result_))。
        1. 若 _done_ 是 throw completion，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 返回 ? _done_。
        1. 设 _done_ 为 ! _done_。
        1. 若 _done_ 为 *true*，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
          1. 返回 ~done~。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorstepvalue" type="abstract operation">
      <h1>
        IteratorStepValue (
          _iteratorRecord_: 一个 Iterator Record,
        ): 返回包含 ECMAScript 语言值或 ~done~ 的正常完成，或抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>与 IteratorStep 类似，但若有值则直接返回值，否则 ~done~。</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为 ? IteratorStep(_iteratorRecord_)。
        1. 若 _result_ 是 ~done~，
          1. 返回 ~done~。
        1. 令 _value_ 为 Completion(IteratorValue(_result_))。
        1. 若 _value_ 是 throw completion，
          1. 设 _iteratorRecord_.[[Done]] 为 *true*。
        1. 返回 ? _value_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-iteratorclose" type="abstract operation">
      <h1>
        IteratorClose (
          _iteratorRecord_: 一个 Iterator Record,
          _completion_: 一个 Completion Record,
        ): 一个 Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>通知迭代器执行其完成状态下的收尾动作。</dd>
      </dl>
      <emu-alg>
        1. 断言：_iteratorRecord_.[[Iterator]] 是 Object。
        1. 令 _iterator_ 为 _iteratorRecord_.[[Iterator]]。
        1. 令 _innerResult_ 为 Completion(GetMethod(_iterator_, *"return"*))。
        1. 若 _innerResult_ 是 normal completion，
          1. 令 _return_ 为 _innerResult_.[[Value]]。
          1. 若 _return_ 是 *undefined*，返回 ? _completion_。
          1. 设 _innerResult_ 为 Completion(Call(_return_, _iterator_))。
        1. 若 _completion_ 是 throw completion，返回 ? _completion_。
        1. 若 _innerResult_ 是 throw completion，返回 ? _innerResult_。
        1. 若 _innerResult_.[[Value]] 不是 Object，抛出 *TypeError*。
        1. 返回 ? _completion_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ifabruptcloseiterator" aoid="IfAbruptCloseIterator">
      <h1>IfAbruptCloseIterator ( _value_, _iteratorRecord_ )</h1>
      <p>IfAbruptCloseIterator 是使用 Iterator Record 相关步骤的简写。形如：</p>
      <emu-alg>
        1. IfAbruptCloseIterator(_value_, _iteratorRecord_)。
      </emu-alg>
      <p>等价于：</p>
      <emu-alg>
        1. 断言：_value_ 是 Completion Record。
        1. 若 _value_ 是 abrupt completion，返回 ? IteratorClose(_iteratorRecord_, _value_)。
        1. 否则，设 _value_ 为 ! _value_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-asynciteratorclose" type="abstract operation">
      <h1>
        AsyncIteratorClose (
          _iteratorRecord_: 一个 Iterator Record,
          _completion_: 一个 Completion Record,
        ): 一个 Completion Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>通知异步迭代器执行其完成状态下的收尾动作。</dd>
      </dl>
      <emu-alg>
        1. 断言：_iteratorRecord_.[[Iterator]] 是 Object。
        1. 令 _iterator_ 为 _iteratorRecord_.[[Iterator]]。
        1. 令 _innerResult_ 为 Completion(GetMethod(_iterator_, *"return"*))。
        1. 若 _innerResult_ 是 normal completion，
          1. 令 _return_ 为 _innerResult_.[[Value]]。
          1. 若 _return_ 是 *undefined*，返回 ? _completion_。
          1. 设 _innerResult_ 为 Completion(Call(_return_, _iterator_))。
          1. 若 _innerResult_ 是 normal completion，设其为 Completion(Await(_innerResult_.[[Value]]))。
        1. 若 _completion_ 是 throw completion，返回 ? _completion_。
        1. 若 _innerResult_ 是 throw completion，返回 ? _innerResult_。
        1. 若 _innerResult_.[[Value]] 不是 Object，抛出 *TypeError*。
        1. 返回 ? _completion_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createiteratorresultobject" type="abstract operation">
      <h1>
        CreateIteratorResultObject (
          _value_: 一个 ECMAScript 语言值,
          _done_: 一个 Boolean,
        ): 一个符合 IteratorResult 接口的 Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个符合 IteratorResult 接口的对象。</dd>
      </dl>
      <emu-alg>
        1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%)。
        1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"value"*, _value_)。
        1. 执行 ! CreateDataPropertyOrThrow(_obj_, *"done"*, _done_)。
        1. 返回 _obj_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createlistiteratorRecord" type="abstract operation" oldids="sec-createlistiterator,sec-listiteratornext-functions,sec-listiterator-next">
      <h1>
        CreateListIteratorRecord (
          _list_: 一个 ECMAScript 语言值的 List,
        ): 一个 Iterator Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>创建一个 Iterator Record，其 [[NextMethod]] 依次返回 _list_ 的元素。</dd>
      </dl>
      <emu-alg>
        1. 令 _closure_ 为一个新建的 Abstract Closure（无参数），捕获 _list_，被调用时：
          1. 对 _list_ 中每个 _E_：
            1. 执行 ? GeneratorYield(CreateIteratorResultObject(_E_, *false*))。
          1. 返回 NormalCompletion(*undefined*)。
        1. 令 _iterator_ 为 CreateIteratorFromClosure(_closure_, ~empty~, %Iterator.prototype%)。
        1. 返回 Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorPrototype.next%, [[Done]]: *false* }。
      </emu-alg>
      <emu-note>
        <p>该列表迭代器对象对 ECMAScript 代码不可直接访问。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-iteratortolist" oldids="sec-iterabletolist" type="abstract operation">
      <h1>
        IteratorToList (
          _iteratorRecord_: 一个 Iterator Record,
        ): 返回包含 ECMAScript 语言值 List 的正常完成或抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _values_ 为新空 List。
        1. 循环：
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 若 _next_ 是 ~done~，
            1. 返回 _values_。
          1. 将 _next_ 加入 _values_。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>语法指引操作 (Syntax-Directed Operations)</h1>
  <p>除了本节定义的操作外，规范其余部分还定义了许多专门的语法指引操作。</p>

  <emu-clause id="sec-evaluation" type="sdo">
    <h1>运行时语义：Evaluation ( ): 一个 Completion Record</h1>
    <dl class="header">
      <dt>effects</dt>
      <dd>user-code</dd>
    </dl>
    <emu-note>
      本操作的定义分布在本规范“ECMAScript Language”各章节中。每个定义出现在相关产生式首次定义之后。
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-scope-analysis">
    <h1>作用域分析 (Scope Analysis)</h1>

    <emu-clause id="sec-static-semantics-boundnames" oldids="sec-identifiers-static-semantics-boundnames,sec-let-and-const-declarations-static-semantics-boundnames,sec-variable-statement-static-semantics-boundnames,sec-destructuring-binding-patterns-static-semantics-boundnames,sec-for-in-and-for-of-statements-static-semantics-boundnames,sec-function-definitions-static-semantics-boundnames,sec-arrow-function-definitions-static-semantics-boundnames,sec-generator-function-definitions-static-semantics-boundnames,sec-async-generator-function-definitions-static-semantics-boundnames,sec-class-definitions-static-semantics-boundnames,sec-async-function-definitions-static-semantics-BoundNames,sec-async-arrow-function-definitions-static-semantics-BoundNames,sec-imports-static-semantics-boundnames,sec-exports-static-semantics-boundnames" type="sdo">
      <h1>静态语义：BoundNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-note id="note-star-default-star">
        <p>*"\*default\*"* 在本规范中用作模块默认导出的合成名称（当它没有其它名称时）。模块的 [[Environment]] 中会以该名称创建一个条目并保存相应的值，对该模块调用 <emu-xref href="#sec-resolveexport" title></emu-xref> 解析名为 *"default"* 的导出会返回一个 [[BindingName]] 为 *"\*default\*"* 的 ResolvedBinding Record，随后它在模块的 [[Environment]] 中解析为上述的值。此举仅为规范书写方便，使匿名默认导出能与其它导出统一解析。该 *"\*default\*"* 字符串在 ECMAScript 代码及模块链接算法中不可见。</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. 返回仅含 |Identifier| 的 StringValue 的列表。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. 返回 « *"yield"* »。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. 返回 « *"await"* »。
      </emu-alg>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingList| 的 BoundNames。
      </emu-alg>
      <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingList| 的 BoundNames。
        1. 令 _names2_ 为 |LexicalBinding| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 |BindingPattern| 的 BoundNames。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |VariableDeclarationList| 的 BoundNames。
        1. 令 _names2_ 为 |VariableDeclaration| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. 返回 |BindingPattern| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingPropertyList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingRestProperty| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingRestElement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingElementList| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingElementList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingRestElement| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingPropertyList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingProperty| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |BindingElementList| 的 BoundNames。
        1. 令 _names2_ 为 |BindingElisionElement| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. 返回 |BindingElement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. 返回 |BindingElement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. 返回 |BindingPattern| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
      <emu-alg>
        1. 返回 |ForBinding| 的 BoundNames。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |FormalParameterList| 的 BoundNames。
        1. 令 _names2_ 为 |FunctionRestParameter| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |FormalParameterList| 的 BoundNames。
        1. 令 _names2_ 为 |FormalParameter| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 覆盖的 |ArrowFormalParameters|。
        1. 返回 _formals_ 的 BoundNames。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |BindingIdentifier| 的 BoundNames。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. 令 _head_ 为 |CoverCallExpressionAndAsyncArrowHead| 覆盖的 |AsyncArrowHead|。
        1. 返回 _head_ 的 BoundNames。
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 返回 |ImportClause| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ImportedDefaultBinding| 的 BoundNames。
        1. 令 _names2_ 为 |NameSpaceImport| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ImportedDefaultBinding| 的 BoundNames。
        1. 令 _names2_ 为 |NamedImports| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>NamedImports : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ImportsList| 的 BoundNames。
        1. 令 _names2_ 为 |ImportSpecifier| 的 BoundNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
      <emu-alg>
        1. 返回 |ImportedBinding| 的 BoundNames。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
      <emu-alg>
        1. 返回 |VariableStatement| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. 返回 |Declaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _declarationNames_ 为 |HoistableDeclaration| 的 BoundNames。
        1. 若 _declarationNames_ 不含 *"\*default\*"*，将 *"\*default\*"* 添加到 _declarationNames_。
        1. 返回 _declarationNames_。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _declarationNames_ 为 |ClassDeclaration| 的 BoundNames。
        1. 若 _declarationNames_ 不含 *"\*default\*"*，将 *"\*default\*"* 添加到 _declarationNames_。
        1. 返回 _declarationNames_。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 返回 « *"\*default\*"* »。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-declarationpart" type="sdo">
      <h1>静态语义：DeclarationPart ( ): 一个 Parse Node</h1>
      <dl class="header">
      </dl>
      <emu-grammar>HoistableDeclaration : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration|。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : GeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |GeneratorDeclaration|。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncFunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |AsyncFunctionDeclaration|。
      </emu-alg>
      <emu-grammar>HoistableDeclaration : AsyncGeneratorDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |AsyncGeneratorDeclaration|。
      </emu-alg>
      <emu-grammar>Declaration : ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |ClassDeclaration|。
      </emu-alg>
      <emu-grammar>Declaration : LexicalDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |LexicalDeclaration|。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isconstantdeclaration" oldids="sec-let-and-const-declarations-static-semantics-isconstantdeclaration,sec-function-definitions-static-semantics-isconstantdeclaration,sec-generator-function-definitions-static-semantics-isconstantdeclaration,sec-async-generator-function-definitions-static-semantics-isconstantdeclaration,sec-class-definitions-static-semantics-isconstantdeclaration,sec-async-function-definitions-static-semantics-IsConstantDeclaration,sec-exports-static-semantics-isconstantdeclaration" type="sdo">
      <h1>静态语义：IsConstantDeclaration ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
      <emu-alg>
        1. 返回 |LetOrConst| 的 IsConstantDeclaration。
      </emu-alg>
      <emu-grammar>LetOrConst : `let`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LetOrConst : `const`</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        ClassDeclaration :
          `class` BindingIdentifier ClassTail
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause `;`
          `export` NamedExports `;`
          `export` `default` AssignmentExpression `;`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>无需将 `export default` |AssignmentExpression| 视作常量声明，因为不存在语法允许对用于引用模块默认对象的内部绑定名赋值。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallydeclarednames" oldids="sec-block-static-semantics-lexicallydeclarednames,sec-switch-statement-static-semantics-lexicallydeclarednames,sec-labelled-statements-static-semantics-lexicallydeclarednames,sec-function-definitions-static-semantics-lexicallydeclarednames,sec-arrow-function-definitions-static-semantics-lexicallydeclarednames,sec-async-arrow-function-definitions-static-semantics-LexicallyDeclaredNames,sec-scripts-static-semantics-lexicallydeclarednames,sec-module-semantics-static-semantics-lexicallydeclarednames" type="sdo">
      <h1>静态语义：LexicallyDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 LexicallyDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 LexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |LabelledStatement| 的 LexicallyDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回 |Declaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _names1_ 为其 LexicallyDeclaredNames；否则 _names1_ 为新空列表。
        1. 令 _names2_ 为 |DefaultClause| 的 LexicallyDeclaredNames。
        1. 若第二个 |CaseClauses| 存在，令 _names3_ 为其 LexicallyDeclaredNames；否则 _names3_ 为新空列表。
        1. 返回 _names1_、_names2_、_names3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |CaseClauses| 的 LexicallyDeclaredNames。
        1. 令 _names2_ 为 |CaseClause| 的 LexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 LexicallyDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyDeclaredNames。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyDeclaredNames。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyDeclaredNames。
      </emu-alg>
      <emu-note>
        <p>|Script| 顶层的函数声明按 var 声明处理，而非按词法声明处理。</p>
      </emu-note>
      <emu-note>
        <p>|Module| 的 LexicallyDeclaredNames 包含其所有导入绑定的名称。</p>
      </emu-note>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ModuleItemList| 的 LexicallyDeclaredNames。
        1. 令 _names2_ 为 |ModuleItem| 的 LexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |ImportDeclaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. 若 |ExportDeclaration| 为 `export` |VariableStatement|，返回一个新的空列表。
        1. 返回 |ExportDeclaration| 的 BoundNames。
      </emu-alg>
      <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
      <emu-alg>
        1. 返回 |StatementListItem| 的 LexicallyDeclaredNames。
      </emu-alg>
      <emu-note>
        <p>|Module| 顶层的函数声明按词法声明处理，而非按 var 声明。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-lexicallyscopeddeclarations" oldids="sec-block-static-semantics-lexicallyscopeddeclarations,sec-switch-statement-static-semantics-lexicallyscopeddeclarations,sec-labelled-statements-static-semantics-lexicallyscopeddeclarations,sec-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-arrow-function-definitions-static-semantics-lexicallyscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-LexicallyScopedDeclarations,sec-scripts-static-semantics-lexicallyscopeddeclarations,sec-module-semantics-static-semantics-lexicallyscopeddeclarations,sec-exports-static-semantics-lexicallyscopeddeclarations" type="sdo">
      <h1>静态语义：LexicallyScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 LexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 LexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |LabelledStatement| 的 LexicallyScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |Declaration| 的 DeclarationPart 的列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _declarations1_ 为其 LexicallyScopedDeclarations；否则 _declarations1_ 为新空列表。
        1. 令 _declarations2_ 为 |DefaultClause| 的 LexicallyScopedDeclarations。
        1. 若第二个 |CaseClauses| 存在，令 _declarations3_ 为其 LexicallyScopedDeclarations；否则 _declarations3_ 为新空列表。
        1. 返回 _declarations1_、_declarations2_、_declarations3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |CaseClauses| 的 LexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |CaseClause| 的 LexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 LexicallyScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 LexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 « |FunctionDeclaration| »。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |ModuleItemList| 的 LexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |ModuleItem| 的 LexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |Declaration| 的 DeclarationPart 的列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |HoistableDeclaration| 的 DeclarationPart 的列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
      <emu-alg>
        1. 返回仅含 |ClassDeclaration| 的列表。
      </emu-alg>
      <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
      <emu-alg>
        1. 返回仅含本 |ExportDeclaration| 的列表。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-vardeclarednames" oldids="sec-statement-semantics-static-semantics-vardeclarednames,sec-block-static-semantics-vardeclarednames,sec-variable-statement-static-semantics-vardeclarednames,sec-if-statement-static-semantics-vardeclarednames,sec-do-while-statement-static-semantics-vardeclarednames,sec-while-statement-static-semantics-vardeclarednames,sec-for-statement-static-semantics-vardeclarednames,sec-for-in-and-for-of-statements-static-semantics-vardeclarednames,sec-with-statement-static-semantics-vardeclarednames,sec-switch-statement-static-semantics-vardeclarednames,sec-labelled-statements-static-semantics-vardeclarednames,sec-try-statement-static-semantics-vardeclarednames,sec-function-definitions-static-semantics-vardeclarednames,sec-arrow-function-definitions-static-semantics-vardeclarednames,sec-async-arrow-function-definitions-static-semantics-VarDeclaredNames,sec-scripts-static-semantics-vardeclarednames,sec-module-semantics-static-semantics-vardeclarednames" type="sdo">
      <h1>静态语义：VarDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
      <emu-alg>
        1. 返回 |VariableDeclarationList| 的 BoundNames。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为第一个 |Statement| 的 VarDeclaredNames。
        1. 令 _names2_ 为第二个 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |VariableDeclarationList| 的 BoundNames。
        1. 令 _names2_ 为 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ForBinding| 的 BoundNames。
        1. 令 _names2_ 为 |Statement| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-note>
        <p>本节由附件 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _names1_ 为其 VarDeclaredNames；否则 _names1_ 为新空列表。
        1. 令 _names2_ 为 |DefaultClause| 的 VarDeclaredNames。
        1. 若第二个 |CaseClauses| 存在，令 _names3_ 为其 VarDeclaredNames；否则 _names3_ 为新空列表。
        1. 返回 _names1_、_names2_、_names3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |CaseClauses| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |CaseClause| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarDeclaredNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |Block| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |Catch| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |Block| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |Finally| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |Block| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |Catch| 的 VarDeclaredNames。
        1. 令 _names3_ 为 |Finally| 的 VarDeclaredNames。
        1. 返回 _names1_、_names2_、_names3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |ModuleItemList| 的 VarDeclaredNames。
        1. 令 _names2_ 为 |ModuleItem| 的 VarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. 若 |ExportDeclaration| 为 `export` |VariableStatement|，返回 |ExportDeclaration| 的 BoundNames。
        1. 返回一个新的空列表。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-varscopeddeclarations" oldids="sec-statement-semantics-static-semantics-varscopeddeclarations,sec-block-static-semantics-varscopeddeclarations,sec-variable-statement-static-semantics-varscopeddeclarations,sec-if-statement-static-semantics-varscopeddeclarations,sec-do-while-statement-static-semantics-varscopeddeclarations,sec-while-statement-static-semantics-varscopeddeclarations,sec-for-statement-static-semantics-varscopeddeclarations,sec-for-in-and-for-of-statements-static-semantics-varscopeddeclarations,sec-with-statement-static-semantics-varscopeddeclarations,sec-switch-statement-static-semantics-varscopeddeclarations,sec-labelled-statements-static-semantics-varscopeddeclarations,sec-try-statement-static-semantics-varscopeddeclarations,sec-function-definitions-static-semantics-varscopeddeclarations,sec-arrow-function-definitions-static-semantics-varscopeddeclarations,sec-async-arrow-function-definitions-static-semantics-VarScopedDeclarations,sec-scripts-static-semantics-varscopeddeclarations,sec-module-semantics-static-semantics-varscopeddeclarations" type="sdo">
      <h1>静态语义：VarScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 « |VariableDeclaration| »。
      </emu-alg>
      <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |VariableDeclarationList| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 « |VariableDeclaration| » 的列表拼接。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为第一个 |Statement| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为第二个 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |VariableDeclarationList| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 « |ForBinding| »。
        1. 令 _declarations2_ 为 |Statement| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-note>
        <p>本节由附件 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，令 _declarations1_ 为其 VarScopedDeclarations；否则 _declarations1_ 为新空列表。
        1. 令 _declarations2_ 为 |DefaultClause| 的 VarScopedDeclarations。
        1. 若第二个 |CaseClauses| 存在，令 _declarations3_ 为其 VarScopedDeclarations；否则 _declarations3_ 为新空列表。
        1. 返回 _declarations1_、_declarations2_、_declarations3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |CaseClauses| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |CaseClause| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 VarScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |Block| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Catch| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |Block| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Finally| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |Block| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |Catch| 的 VarScopedDeclarations。
        1. 令 _declarations3_ 为 |Finally| 的 VarScopedDeclarations。
        1. 返回 _declarations1_、_declarations2_、_declarations3_ 的列表拼接。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>FunctionStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <emu-alg>
        1. 返回 |StatementList| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |ModuleItemList| 的 VarScopedDeclarations。
        1. 令 _declarations2_ 为 |ModuleItem| 的 VarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
      <emu-alg>
        1. 若 |ExportDeclaration| 为 `export` |VariableStatement|，返回 |VariableStatement| 的 VarScopedDeclarations。
        1. 返回一个新的空列表。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallydeclarednames" oldids="sec-block-static-semantics-toplevellexicallydeclarednames,sec-labelled-statements-static-semantics-toplevellexicallydeclarednames" type="sdo">
      <h1>静态语义：TopLevelLexicallyDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 TopLevelLexicallyDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 TopLevelLexicallyDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 返回一个新的空列表。
        1. 返回 |Declaration| 的 BoundNames。
      </emu-alg>
      <emu-note>
        <p>函数或脚本顶层中，函数声明按 var 声明而非词法声明处理。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevellexicallyscopeddeclarations" oldids="sec-block-static-semantics-toplevellexicallyscopeddeclarations,sec-labelled-statements-static-semantics-toplevellexicallyscopeddeclarations" type="sdo">
      <h1>静态语义：TopLevelLexicallyScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 TopLevelLexicallyScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 TopLevelLexicallyScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 返回一个新的空列表。
        1. 返回 « |Declaration| »。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvardeclarednames" oldids="sec-block-static-semantics-toplevelvardeclarednames,sec-labelled-statements-static-semantics-toplevelvardeclarednames" type="sdo">
      <h1>静态语义：TopLevelVarDeclaredNames ( ): 一个字符串列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _names1_ 为 |StatementList| 的 TopLevelVarDeclaredNames。
        1. 令 _names2_ 为 |StatementListItem| 的 TopLevelVarDeclaredNames。
        1. 返回 _names1_ 与 _names2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 返回 |HoistableDeclaration| 的 BoundNames。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarDeclaredNames。
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-note>
        <p>函数或脚本顶层的内部函数声明按 var 声明处理。</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 TopLevelVarDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarDeclaredNames。
        1. 返回 |Statement| 的 VarDeclaredNames。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration| 的 BoundNames。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-toplevelvarscopeddeclarations" oldids="sec-block-static-semantics-toplevelvarscopeddeclarations,sec-labelled-statements-static-semantics-toplevelvarscopeddeclarations" type="sdo">
      <h1>静态语义：TopLevelVarScopedDeclarations ( ): 一个 Parse Node 列表</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _declarations1_ 为 |StatementList| 的 TopLevelVarScopedDeclarations。
        1. 令 _declarations2_ 为 |StatementListItem| 的 TopLevelVarScopedDeclarations。
        1. 返回 _declarations1_ 与 _declarations2_ 的列表拼接。
      </emu-alg>
      <emu-grammar>StatementListItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarScopedDeclarations。
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>StatementListItem : Declaration</emu-grammar>
      <emu-alg>
        1. 若 |Declaration| 为 <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>，
          1. 令 _declaration_ 为 |HoistableDeclaration| 的 DeclarationPart。
          1. 返回 « _declaration_ »。
        1. 返回一个新的空列表。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 返回 |LabelledItem| 的 TopLevelVarScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : Statement</emu-grammar>
      <emu-alg>
        1. 若 |Statement| 为 <emu-grammar>Statement : LabelledStatement</emu-grammar>，返回 |Statement| 的 TopLevelVarScopedDeclarations。
        1. 返回 |Statement| 的 VarScopedDeclarations。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 « |FunctionDeclaration| »。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-labels">
    <h1>标签 (Labels)</h1>

    <emu-clause id="sec-static-semantics-containsduplicatelabels" oldids="sec-statement-semantics-static-semantics-containsduplicatelabels,sec-block-static-semantics-containsduplicatelabels,sec-if-statement-static-semantics-containsduplicatelabels,sec-do-while-statement-static-semantics-containsduplicatelabels,sec-while-statement-static-semantics-containsduplicatelabels,sec-for-statement-static-semantics-containsduplicatelabels,sec-for-in-and-for-of-statements-static-semantics-containsduplicatelabels,sec-with-statement-static-semantics-containsduplicatelabels,sec-switch-statement-static-semantics-containsduplicatelabels,sec-labelled-statements-static-semantics-containsduplicatelabels,sec-try-statement-static-semantics-containsduplicatelabels,sec-function-definitions-static-semantics-containsduplicatelabels,sec-module-semantics-static-semantics-containsduplicatelabels" type="sdo">
      <h1>
        静态语义：ContainsDuplicateLabels (
          _labelSet_: 一个字符串列表,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |StatementList| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |StatementListItem| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicate_ 为第一个 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicate_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，则
          1. 若第一个 |CaseClauses| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |DefaultClause| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 不存在，返回 *false*。
        1. 返回第二个 |CaseClauses| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |CaseClauses| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |CaseClause| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 若 _labelSet_ 包含 _label_，返回 *true*。
        1. 令 _newLabelSet_ 为 _labelSet_ 与 « _label_ » 的列表拼接。
        1. 返回 |LabelledItem| 的 ContainsDuplicateLabels（参数 _newLabelSet_）。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |Catch| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 若 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |Catch| 的 ContainsDuplicateLabels（参数 _labelSet_）为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _hasDuplicates_ 为 |ModuleItemList| 的 ContainsDuplicateLabels（参数 _labelSet_）。
        1. 若 _hasDuplicates_ 为 *true*，返回 *true*。
        1. 返回 |ModuleItem| 的 ContainsDuplicateLabels（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedbreaktarget" oldids="sec-statement-semantics-static-semantics-containsundefinedbreaktarget,sec-block-static-semantics-containsundefinedbreaktarget,sec-if-statement-static-semantics-containsundefinedbreaktarget,sec-do-while-statement-static-semantics-containsundefinedbreaktarget,sec-while-statement-static-semantics-containsundefinedbreaktarget,sec-for-statement-static-semantics-containsundefinedbreaktarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedbreaktarget,sec-break-statement-static-semantics-containsundefinedbreaktarget,sec-with-statement-static-semantics-containsundefinedbreaktarget,sec-switch-statement-static-semantics-containsundefinedbreaktarget,sec-labelled-statements-static-semantics-containsundefinedbreaktarget,sec-try-statement-static-semantics-containsundefinedbreaktarget,sec-function-definitions-static-semantics-containsundefinedbreaktarget,sec-module-semantics-static-semantics-containsundefinedbreaktarget" type="sdo">
      <h1>
        静态语义：ContainsUndefinedBreakTarget (
          _labelSet_: 一个字符串列表,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |StatementList| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |StatementListItem| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为第一个 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. 若 _labelSet_ 不包含 |LabelIdentifier| 的 StringValue，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，则
          1. 若第一个 |CaseClauses| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |DefaultClause| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 不存在，返回 *false*。
        1. 返回第二个 |CaseClauses| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |CaseClauses| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |CaseClause| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 令 _newLabelSet_ 为 _labelSet_ 与 « _label_ » 的列表拼接。
        1. 返回 |LabelledItem| 的 ContainsUndefinedBreakTarget（参数 _newLabelSet_）。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Catch| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 若 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 若 |Catch| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |ModuleItemList| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |ModuleItem| 的 ContainsUndefinedBreakTarget（参数 _labelSet_）。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsundefinedcontinuetarget" oldids="sec-statement-semantics-static-semantics-containsundefinedcontinuetarget,sec-block-static-semantics-containsundefinedcontinuetarget,sec-if-statement-static-semantics-containsundefinedcontinuetarget,sec-do-while-statement-static-semantics-containsundefinedcontinuetarget,sec-while-statement-static-semantics-containsundefinedcontinuetarget,sec-for-statement-static-semantics-containsundefinedcontinuetarget,sec-for-in-and-for-of-statements-static-semantics-containsundefinedcontinuetarget,sec-continue-statement-static-semantics-containsundefinedcontinuetarget,sec-with-statement-static-semantics-containsundefinedcontinuetarget,sec-switch-statement-static-semantics-containsundefinedcontinuetarget,sec-labelled-statements-static-semantics-containsundefinedcontinuetarget,sec-try-statement-static-semantics-containsundefinedcontinuetarget,sec-function-definitions-static-semantics-containsundefinedcontinuetarget,sec-module-semantics-static-semantics-containsundefinedcontinuetarget" type="sdo">
      <h1>
        静态语义：ContainsUndefinedContinueTarget (
          _iterationSet_: 一个字符串列表,
          _labelSet_: 一个字符串列表,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          BreakStatement
          ReturnStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        StatementListItem :
          Declaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>Statement : BlockStatement</emu-grammar>
      <emu-alg>
        1. 返回 |BlockStatement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. 令 _newIterationSet_ 为 _iterationSet_ 与 _labelSet_ 的列表拼接。
        1. 返回 |IterationStatement| 的 ContainsUndefinedContinueTarget（参数 _newIterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |StatementList| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |StatementListItem| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为第一个 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回第二个 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>
        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>
        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
          `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-note>
        <p>本节由附录 <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> 扩展。</p>
      </emu-note>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. 若 _iterationSet_ 不包含 |LabelIdentifier| 的 StringValue，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. 返回 |Statement| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. 返回 |CaseBlock| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. 若第一个 |CaseClauses| 存在，则
          1. 若第一个 |CaseClauses| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 若 |DefaultClause| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 若第二个 |CaseClauses| 不存在，返回 *false*。
        1. 返回第二个 |CaseClauses| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |CaseClauses| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |CaseClause| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList?</emu-grammar>
      <emu-alg>
        1. 若 |StatementList| 存在，返回其 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. 令 _label_ 为 |LabelIdentifier| 的 StringValue。
        1. 令 _newLabelSet_ 为 _labelSet_ 与 « _label_ » 的列表拼接。
        1. 返回 |LabelledItem| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 _newLabelSet_）。
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Catch| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. 若 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 若 |Catch| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）为 *true*，返回 *true*。
        1. 返回 |Finally| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. 返回 |Block| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. 令 _hasUndefinedLabels_ 为 |ModuleItemList| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
        1. 若 _hasUndefinedLabels_ 为 *true*，返回 *true*。
        1. 返回 |ModuleItem| 的 ContainsUndefinedContinueTarget（参数 _iterationSet_ 与 « »）。
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ImportDeclaration
          ExportDeclaration
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-function-name-inference">
    <h1>函数名称推断 (Function Name Inference)</h1>

    <emu-clause id="sec-static-semantics-hasname" oldids="sec-semantics-static-semantics-hasname,sec-function-definitions-static-semantics-hasname,sec-arrow-function-definitions-static-semantics-hasname,sec-generator-function-definitions-static-semantics-hasname,sec-async-generator-function-definitions-static-semantics-hasname,sec-class-definitions-static-semantics-hasname,sec-async-function-definitions-static-semantics-HasName,sec-async-arrow-function-definitions-static-semantics-HasName" type="sdo">
      <h1>静态语义：HasName ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 如果 _expr_ 的 IsFunctionDefinition 为 *false*，返回 *false*。
        1. 返回 _expr_ 的 HasName。
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ArrowFunction :
          ArrowParameters `=>` ConciseBody

        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody

        ClassExpression :
          `class` ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        FunctionExpression :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isfunctiondefinition" oldids="sec-semantics-static-semantics-isfunctiondefinition,sec-grouping-operator-static-semantics-isfunctiondefinition,sec-static-semantics-static-semantics-isfunctiondefinition,sec-update-expressions-static-semantics-isfunctiondefinition,sec-unary-operators-static-semantics-isfunctiondefinition,sec-exp-operator-static-semantics-isfunctiondefinition,sec-multiplicative-operators-static-semantics-isfunctiondefinition,sec-additive-operators-static-semantics-isfunctiondefinition,sec-bitwise-shift-operators-static-semantics-isfunctiondefinition,sec-relational-operators-static-semantics-isfunctiondefinition,sec-equality-operators-static-semantics-isfunctiondefinition,sec-binary-bitwise-operators-static-semantics-isfunctiondefinition,sec-binary-logical-operators-static-semantics-isfunctiondefinition,sec-conditional-operator-static-semantics-isfunctiondefinition,sec-assignment-operators-static-semantics-isfunctiondefinition,sec-comma-operator-static-semantics-isfunctiondefinition,sec-function-definitions-static-semantics-isfunctiondefinition,sec-generator-function-definitions-static-semantics-isfunctiondefinition,sec-async-generator-function-definitions-static-semantics-isfunctiondefinition,sec-class-definitions-static-semantics-isfunctiondefinition,sec-async-function-definitions-static-semantics-IsFunctionDefinition" type="sdo">
      <h1>静态语义：IsFunctionDefinition ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 返回 _expr_ 的 IsFunctionDefinition。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          RegularExpressionLiteral
          TemplateLiteral

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        AssignmentExpression :
          ArrowFunction
          AsyncArrowFunction

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        ClassExpression :
          `class` BindingIdentifier? ClassTail
      </emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isanonymousfunctiondefinition" type="abstract operation">
      <h1>
        静态语义：IsAnonymousFunctionDefinition (
          _expr_: 一个 |AssignmentExpression| Parse Node、一个 |Initializer| Parse Node、或一个 |Expression| Parse Node,
        ): 一个 Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于判定其参数是否为未绑定名称的函数定义。</dd>
      </dl>
      <emu-alg>
        1. 如果 _expr_ 的 IsFunctionDefinition 为 *false*，返回 *false*。
        1. 令 _hasName_ 为 _expr_ 的 HasName。
        1. 如果 _hasName_ 为 *true*，返回 *false*。
        1. 返回 *true*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isidentifierref" oldids="sec-semantics-static-semantics-isidentifierref,sec-static-semantics-static-semantics-isidentifierref" type="sdo">
      <h1>静态语义：IsIdentifierRef ( ): 一个 Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>
      <emu-alg>
        1. 返回 *true*。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
          CoverParenthesizedExpressionAndArrowParameterList

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          MemberExpression TemplateLiteral
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        LeftHandSideExpression :
          CallExpression
          OptionalExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-namedevaluation" oldids="sec-grouping-operator-runtime-semantics-namedevaluation,sec-function-definitions-runtime-semantics-namedevaluation,sec-arrow-function-definitions-runtime-semantics-namedevaluation,sec-generator-function-definitions-runtime-semantics-namedevaluation,sec-asyncgenerator-definitions-namedevaluation,sec-class-definitions-runtime-semantics-namedevaluation,sec-async-function-definitions-runtime-semantics-namedevaluation,sec-async-arrow-function-definitions-runtime-semantics-namedevaluation" type="sdo">
      <h1>
        运行时语义：NamedEvaluation (
          _name_: 一个属性键或一个 Private Name,
        ): 返回包含一个函数对象的正常完成或一个异常完成
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 返回 ? _expr_ 的 NamedEvaluation（参数 _name_）。
      </emu-alg>
      <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
      <emu-alg>
        1. 断言：IsAnonymousFunctionDefinition(|Expression|) 为 *true*。
        1. 返回 ? |Expression| 的 NamedEvaluation（参数 _name_）。
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |FunctionExpression| 的 InstantiateOrdinaryFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |GeneratorExpression| 的 InstantiateGeneratorFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncGeneratorExpression| 的 InstantiateAsyncGeneratorFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncFunctionExpression| 的 InstantiateAsyncFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 返回 |ArrowFunction| 的 InstantiateArrowFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncArrowFunction| 的 InstantiateAsyncArrowFunctionExpression（参数 _name_）。
      </emu-alg>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. 令 _sourceText_ 为 |ClassExpression| 匹配的源文本。
        1. 返回 ? |ClassTail| 的 ClassDefinitionEvaluation（参数 *undefined*, _name_, _sourceText_）。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        静态语义：Contains (
          _symbol_: 一个语法符号,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>本规范中未列于下表的每个语法产生式替代都隐式具有如下默认的 Contains 定义：</p>
      <emu-alg>
        1. 对该解析节点的每个子节点 _child_，执行
          1. 若 _child_ 是 _symbol_ 的一个实例，返回 *true*。
          1. 若 _child_ 是一个非终结符实例，则
            1. 令 _contained_ 为 _child_ Contains _symbol_ 的结果。
            1. 若 _contained_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>依赖子结构的静态语义规则通常不会深入函数定义内部。</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <emu-alg>
        1. 如果 _symbol_ 是 |ClassBody|，返回 *true*。
        1. 如果 _symbol_ 是 |ClassHeritage|，则
          1. 若 |ClassHeritage| 存在，返回 *true*；否则返回 *false*。
        1. 若 |ClassHeritage| 存在，则
          1. 若 |ClassHeritage| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 |ClassBody| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-note>
        <p>依赖子结构的静态语义规则通常不会深入类主体，除了 |PropertyName|。</p>
      </emu-note>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-note>
        <p>依赖子结构的静态语义规则通常不会深入 `static` 初始化块。</p>
      </emu-note>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 不在 |NewTarget|、|SuperProperty|、|SuperCall|、`super`、`this` 之列，返回 *false*。
        1. 若 |ArrowParameters| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 |ConciseBody| Contains _symbol_。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ArrowFormalParameters|。
        1. 返回 _formals_ Contains _symbol_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 不在 |NewTarget|、|SuperProperty|、|SuperCall|、`super`、`this` 之列，返回 *false*。
        1. 返回 |AsyncConciseBody| Contains _symbol_。
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 不在 |NewTarget|、|SuperProperty|、|SuperCall|、`super`、`this` 之列，返回 *false*。
        1. 令 _head_ 为 |CoverCallExpressionAndAsyncArrowHead| 所覆盖的 |AsyncArrowHead|。
        1. 若 _head_ Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 |AsyncConciseBody| Contains _symbol_。
      </emu-alg>
      <emu-note>
        <p>Contains 用于在 |ArrowFunction| 或 |AsyncArrowFunction| 中检测 `new.target`、`this` 和 `super` 的使用。</p>
      </emu-note>
      <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
      <emu-alg>
        1. 如果 _symbol_ 是 |MethodDefinition|，返回 *true*。
        1. 返回 |MethodDefinition| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 |MemberExpression| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 _symbol_ 是保留字 `super`，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 |CallExpression| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
      <emu-alg>
        1. 若 |OptionalChain| Contains _symbol_ 为 *true*，返回 *true*。
        1. 返回 *false*。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-computedpropertycontains" oldids="sec-object-initializer-static-semantics-computedpropertycontains,sec-method-definitions-static-semantics-computedpropertycontains,sec-generator-function-definitions-static-semantics-computedpropertycontains,sec-async-generator-function-definitions-static-semantics-computedpropertycontains,sec-class-definitions-static-semantics-computedpropertycontains,sec-async-function-definitions-static-semantics-ComputedPropertyContains" type="sdo">
      <h1>
        静态语义：ComputedPropertyContains (
          _symbol_: 一个语法符号,
        ): 一个 Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ClassElementName : PrivateIdentifier

        PropertyName : LiteralPropertyName
      </emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
      <emu-alg>
        1. 返回 |ComputedPropertyName| Contains _symbol_ 的结果。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. 令 _inList_ 为 |ClassElementList| 的 ComputedPropertyContains（参数 _symbol_）。
        1. 若 _inList_ 为 *true*，返回 *true*。
        1. 返回 |ClassElement| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 *false*。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 ComputedPropertyContains（参数 _symbol_）结果。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>其它 (Miscellaneous)</h1>
    <p>这些操作在规范的多个位置被使用。</p>

    <emu-clause id="sec-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        运行时语义：InstantiateFunctionObject (
          _env_: 一个 Environment Record,
          _privateEnv_: 一个 PrivateEnvironment Record 或 *null*,
        ): 一个 ECMAScript 函数对象
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |FunctionDeclaration| 的 InstantiateOrdinaryFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |GeneratorDeclaration| 的 InstantiateGeneratorFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncGeneratorDeclaration| 的 InstantiateAsyncGeneratorFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |AsyncFunctionDeclaration| 的 InstantiateAsyncFunctionObject（参数 _env_ 与 _privateEnv_）。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindinginitialization" oldids="sec-identifiers-runtime-semantics-bindinginitialization,sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization" type="sdo">
      <h1>
        运行时语义：BindingInitialization (
          _value_: 一个 ECMAScript 语言值,
          _environment_: 一个 Environment Record 或 *undefined*,
        ): 返回包含 ~unused~ 的正常完成或一个异常完成
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>当 _environment_ 传入 *undefined* 时表示应使用 PutValue 操作来赋值初始化值。对于 `var` 语句以及某些非严格函数的形式参数列表即是这种情况（参见 <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>）。在这些情况下词法绑定在其初始化器求值前被提升并预初始化。</p>
      </emu-note>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <emu-alg>
        1. 令 _name_ 为 |Identifier| 的 StringValue。
        1. 返回 ? InitializeBoundName(_name_, _value_, _environment_)。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `yield`</emu-grammar>
      <emu-alg>
        1. 返回 ? InitializeBoundName(*"yield"*, _value_, _environment_)。
      </emu-alg>
      <emu-grammar>BindingIdentifier : `await`</emu-grammar>
      <emu-alg>
        1. 返回 ? InitializeBoundName(*"await"*, _value_, _environment_)。
      </emu-alg>
      <emu-grammar>BindingPattern : ObjectBindingPattern</emu-grammar>
      <emu-alg>
        1. 执行 ? RequireObjectCoercible(_value_)。
        1. 返回 ? |ObjectBindingPattern| 的 BindingInitialization（参数 _value_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingPattern : ArrayBindingPattern</emu-grammar>
      <emu-alg>
        1. 令 _iteratorRecord_ 为 ? GetIterator(_value_, ~sync~)。
        1. 令 _result_ 为 Completion(|ArrayBindingPattern| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）)。
        1. 如果 _iteratorRecord_.[[Done]] 为 *false*，返回 ? IteratorClose(_iteratorRecord_, _result_)。
        1. 返回 ? _result_。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` `}`</emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>
        ObjectBindingPattern :
          `{` BindingPropertyList `}`
          `{` BindingPropertyList `,` `}`
      </emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingPropertyList| 的 PropertyBindingInitialization（参数 _value_, _environment_）。
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 令 _excludedNames_ 为新的空列表。
        1. 返回 ? |BindingRestProperty| 的 RestBindingInitialization（参数 _value_, _environment_, _excludedNames_）。
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. 令 _excludedNames_ 为 ? |BindingPropertyList| 的 PropertyBindingInitialization（参数 _value_, _environment_）。
        1. 返回 ? |BindingRestProperty| 的 RestBindingInitialization（参数 _value_, _environment_, _excludedNames_）。
      </emu-alg>

      <emu-clause id="sec-initializeboundname" type="abstract operation">
        <h1>
          InitializeBoundName (
            _name_: 一个 String,
            _value_: 一个 ECMAScript 语言值,
            _environment_: 一个 Environment Record 或 *undefined*,
          ): 返回包含 ~unused~ 的正常完成或一个异常完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 如果 _environment_ 不为 *undefined*，则
            1. 执行 ! _environment_.InitializeBinding(_name_, _value_)。
            1. 返回 ~unused~。
          1. 否则，
            1. 令 _lhs_ 为 ? ResolveBinding(_name_)。
            1. 返回 ? PutValue(_lhs_, _value_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-iteratorbindinginitialization" oldids="sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization,sec-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-arrow-function-definitions-runtime-semantics-iteratorbindinginitialization,sec-async-arrow-function-definitions-IteratorBindingInitialization" type="sdo">
      <h1>
        运行时语义：IteratorBindingInitialization (
          _iteratorRecord_: 一个 Iterator Record,
          _environment_: 一个 Environment Record 或 *undefined*,
        ): 返回包含 ~unused~ 的正常完成或一个异常完成
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>当 _environment_ 为 *undefined* 时表示应使用 PutValue 操作来赋初始化值。这用于非严格函数的形式参数列表，在那种情况下形式参数绑定会被预初始化以应对同名参数出现的可能。</p>
      </emu-note>
      <emu-grammar>ArrayBindingPattern : `[` `]`</emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision `]`</emu-grammar>
      <emu-alg>
        1. 返回 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 如果 |Elision| 存在，则
          1. 执行 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
        1. 返回 ? |BindingRestElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision `]`</emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingElementList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingElementList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 如果 |Elision| 存在，则
          1. 执行 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
        1. 返回 ? |BindingRestElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. 执行 ? |BindingElementList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |BindingElisionElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision BindingElement</emu-grammar>
      <emu-alg>
        1. 执行 ? |Elision| 的 IteratorDestructuringAssignmentEvaluation（参数 _iteratorRecord_）。
        1. 返回 ? |BindingElement| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
      <emu-alg>
        1. 令 _bindingId_ 为 |BindingIdentifier| 的 StringValue。
        1. 令 _lhs_ 为 ? ResolveBinding(_bindingId_, _environment_)。
        1. 令 _v_ 为 *undefined*。
        1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 不是 ~done~，则
            1. 设 _v_ 为 _next_。
        1. 如果 |Initializer| 存在且 _v_ 为 *undefined*，则
          1. 如果 IsAnonymousFunctionDefinition(|Initializer|) 为 *true*，则
            1. 设 _v_ 为 ? |Initializer| 的 NamedEvaluation（参数 _bindingId_）。
          1. 否则，
            1. 令 _defaultValue_ 为 ? |Initializer| 的 Evaluation。
            1. 设 _v_ 为 ? GetValue(_defaultValue_)。
        1. 如果 _environment_ 为 *undefined*，返回 ? PutValue(_lhs_, _v_)。
        1. 返回 ? InitializeReferencedBinding(_lhs_, _v_)。
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
      <emu-alg>
        1. 令 _v_ 为 *undefined*。
        1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
          1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 不是 ~done~，则
            1. 设 _v_ 为 _next_。
        1. 如果 |Initializer| 存在且 _v_ 为 *undefined*，则
          1. 令 _defaultValue_ 为 ? |Initializer| 的 Evaluation。
          1. 设 _v_ 为 ? GetValue(_defaultValue_)。
        1. 返回 ? |BindingPattern| 的 BindingInitialization（参数 _v_, _environment_）。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 令 _lhs_ 为 ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_)。
        1. 令 _A_ 为 ! ArrayCreate(0)。
        1. 令 _n_ 为 0。
        1. 重复，
          1. 令 _next_ 为 ~done~。
          1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 设 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 是 ~done~，则
            1. 如果 _environment_ 为 *undefined*，返回 ? PutValue(_lhs_, _A_)。
            1. 返回 ? InitializeReferencedBinding(_lhs_, _A_)。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)。
          1. 设 _n_ 为 _n_ + 1。
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. 令 _A_ 为 ! ArrayCreate(0)。
        1. 令 _n_ 为 0。
        1. 重复，
          1. 令 _next_ 为 ~done~。
          1. 如果 _iteratorRecord_.[[Done]] 为 *false*，则
            1. 设 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
          1. 如果 _next_ 是 ~done~，则
            1. 返回 ? |BindingPattern| 的 BindingInitialization（参数 _A_, _environment_）。
          1. 执行 ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_)。
          1. 设 _n_ 为 _n_ + 1。
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. 返回 ~unused~。
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. 执行 ? |FormalParameterList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |FunctionRestParameter| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. 执行 ? |FormalParameterList| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
        1. 返回 ? |FormalParameter| 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. 令 _v_ 为 *undefined*。
        1. 断言：_iteratorRecord_.[[Done]] 为 *false*。
        1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
        1. 如果 _next_ 不是 ~done~，则
          1. 设 _v_ 为 _next_。
        1. 返回 ? |BindingIdentifier| 的 BindingInitialization（参数 _v_, _environment_）。
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. 令 _formals_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ArrowFormalParameters|。
        1. 返回 ? _formals_ 的 IteratorBindingInitialization（参数 _iteratorRecord_, _environment_）。
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. 令 _v_ 为 *undefined*。
        1. 断言：_iteratorRecord_.[[Done]] 为 *false*。
        1. 令 _next_ 为 ? IteratorStepValue(_iteratorRecord_)。
        1. 如果 _next_ 不是 ~done~，则
          1. 设 _v_ 为 _next_。
        1. 返回 ? |BindingIdentifier| 的 BindingInitialization（参数 _v_, _environment_）。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-assignmenttargettype" oldids="sec-identifiers-static-semantics-assignmenttargettype,sec-identifiers-static-semantics-isvalidsimpleassignmenttarget,sec-semantics-static-semantics-assignmenttargettype,sec-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-grouping-operator-static-semantics-assignmenttargettype,sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget,sec-static-semantics-static-semantics-assignmenttargettype,sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget,sec-update-expressions-static-semantics-assignmenttargettype,sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget,sec-unary-operators-static-semantics-assignmenttargettype,sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget,sec-exp-operator-static-semantics-assignmenttargettype,sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget,sec-multiplicative-operators-static-semantics-assignmenttargettype,sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget,sec-additive-operators-static-semantics-assignmenttargettype,sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget,sec-bitwise-shift-operators-static-semantics-assignmenttargettype,sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget,sec-relational-operators-static-semantics-assignmenttargettype,sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget,sec-equality-operators-static-semantics-assignmenttargettype,sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-bitwise-operators-static-semantics-assignmenttargettype,sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget,sec-binary-logical-operators-static-semantics-assignmenttargettype,sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget,sec-conditional-operator-static-semantics-assignmenttargettype,sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget,sec-assignment-operators-static-semantics-assignmenttargettype,sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget,sec-comma-operator-static-semantics-assignmenttargettype,sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget" type="sdo">
      <h1>静态语义：AssignmentTargetType ( ): ~simple~、~web-compat~ 或 ~invalid~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. 如果 IsStrict(this |IdentifierReference|) 为 *true* 且 |Identifier| 的 StringValue 是 *"eval"* 或 *"arguments"*，返回 ~invalid~。
        1. 返回 ~simple~。
      </emu-alg>
      <emu-grammar>
        IdentifierReference :
          `yield`
          `await`

        CallExpression :
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MemberExpression `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 ~simple~。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          CoverParenthesizedExpressionAndArrowParameterList
      </emu-grammar>
      <emu-alg>
        1. 令 _expr_ 为 |CoverParenthesizedExpressionAndArrowParameterList| 所覆盖的 |ParenthesizedExpression|。
        1. 返回 _expr_ 的 AssignmentTargetType。
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. [id="step-assignmenttargettype-web-compat", normative-optional] 如果宿主是 Web 浏览器或以其他方式支持 <emu-xref href="#sec-runtime-errors-for-function-call-assignment-targets" title></emu-xref> 且 IsStrict(this |CallExpression|) 为 *false*，则
          1. 返回 ~web-compat~。
        1. 返回 ~invalid~。
      </emu-alg>
      <emu-grammar>
        PrimaryExpression :
          `this`
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral

        CallExpression :
          SuperCall
          ImportCall
          CallExpression TemplateLiteral

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression TemplateLiteral
          `new` MemberExpression Arguments

        NewTarget :
          `new` `.` `target`

        ImportMeta :
          `import` `.` `meta`

        LeftHandSideExpression :
          OptionalExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        LogicalANDExpression :
          LogicalANDExpression `&amp;&amp;` BitwiseORExpression

        LogicalORExpression :
          LogicalORExpression `||` LogicalANDExpression

        CoalesceExpression :
          CoalesceExpressionHead `??` BitwiseORExpression

        ConditionalExpression :
          ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression

        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        Expression :
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. 返回 ~invalid~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-propname" oldids="sec-object-initializer-static-semantics-propname,sec-method-definitions-static-semantics-propname,sec-generator-function-definitions-static-semantics-propname,sec-async-generator-function-definitions-static-semantics-propname,sec-class-definitions-static-semantics-propname,sec-async-function-definitions-static-semantics-PropName" type="sdo">
      <h1>静态语义：PropName ( ): 一个 String 或 ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
      <emu-alg>
        1. 返回 |IdentifierReference| 的 StringValue。
      </emu-alg>
      <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. 返回 |PropertyName| 的 PropName。
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : IdentifierName

        AttributeKey : IdentifierName
      </emu-grammar>
      <emu-alg>
        1. 返回 |IdentifierName| 的 StringValue。
      </emu-alg>
      <emu-grammar>
        LiteralPropertyName : StringLiteral

        AttributeKey : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. 返回 |StringLiteral| 的 SV。
      </emu-alg>
      <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
      <emu-alg>
        1. 令 _nbr_ 为 |NumericLiteral| 的 NumericValue。
        1. 返回 ! ToString(_nbr_)。
      </emu-alg>
      <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. 返回 |ClassElementName| 的 PropName。
      </emu-alg>
      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. 返回 ~empty~。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>可执行代码与执行上下文 (Executable Code and Execution Contexts)</h1>

  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>环境记录 (Environment Records)</h1>
    <p><dfn variants="Environment Records">Environment Record</dfn> 是一种规范类型，用于基于 ECMAScript 代码的词法嵌套结构，将 |Identifier| 与特定变量及函数建立关联。通常一个 Environment Record 与某个特定的 ECMAScript 语法结构关联，如 |FunctionDeclaration|、|BlockStatement| 或 |TryStatement| 的 |Catch| 子句。每当这类代码被求值时，就会新建一个 Environment Record，用来记录该代码创建的标识符绑定。</p>
    <p>每个 Environment Record 都有一个 [[OuterEnv]] 字段，其值为 *null* 或指向一个外层 Environment Record，用来建模 Environment Record 值的逻辑嵌套。一个（内层）Environment Record 的外层引用指向在逻辑上包围它的 Environment Record。外层 Environment Record 当然也可以再有自己的外层引用。一个 Environment Record 可以作为多个内层 Environment Record 的外层环境。例如，若一个 |FunctionDeclaration| 内含两个嵌套的 |FunctionDeclaration|，那么这两个嵌套函数的 Environment Record 的外层 Environment Record 都是外层函数当前求值对应的 Environment Record。</p>
    <p>Environment Record 纯属规范机制，不需要对应到 ECMAScript 实现中的任何具体产物。ECMAScript 程序无法直接访问或操纵这些值。</p>

    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>Environment Record 类型层次 (The Environment Record Type Hierarchy)</h1>
      <p>可以将 Environment Record 看作是一个简单的面向对象层次结构：Environment Record 是一个抽象类，具有三个具体子类：Declarative Environment Record、Object Environment Record 和 Global Environment Record。Function Environment Record 与 Module Environment Record 是 Declarative Environment Record 的子类。</p>
      <ul>
        <li>
          <p>Environment Record (抽象)</p>
          <ul>
            <li>
              <p><em>Declarative Environment Record</em> 用于定义 ECMAScript 语言语法元素（如 |FunctionDeclaration|、|VariableDeclaration|、|Catch| 子句）对标识符绑定与 ECMAScript 语言值直接关联所产生的效果。</p>
              <ul>
                <li>
                  <p><em>Function Environment Record</em> 对应一次 ECMAScript 函数对象的调用，包含该函数顶层声明的绑定；它可以建立新的 `this` 绑定，并捕获支持 `super` 方法调用所需的状态。</p>
                </li>
                <li>
                  <p><em>Module Environment Record</em> 包含 |Module| 的顶层声明绑定，也包含该 |Module| 显式导入的绑定。其 [[OuterEnv]] 为一个 Global Environment Record。</p>
                </li>
              </ul>
            </li>
            <li>
              <p><em>Object Environment Record</em> 用于定义类似 |WithStatement| 那样把标识符绑定关联到某对象属性的 ECMAScript 元素的效果。</p>
            </li>
            <li>
              <p><em>Global Environment Record</em> 用于 |Script| 的全局声明。它没有外层环境；其 [[OuterEnv]] 为 *null*。它可被预填充标识符绑定，并包含一个关联的全局对象，该对象的属性提供部分全局环境的标识符绑定。随着 ECMAScript 代码执行，可以向全局对象增加属性或修改初始属性。</p>
            </li>
          </ul>
        </li>
      </ul>

      <p>Environment Record 抽象类包含 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> 中定义的抽象规范方法。这些抽象方法在各具体子类上有不同的具体算法。</p>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Environment Record 的抽象方法" oldids="table-15">
        <table>
          <thead>
            <tr>
              <th>
                方法
              </th>
              <th>
                目的
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              判断 Environment Record 是否存在字符串值 _N_ 的绑定；存在返回 *true*，否则返回 *false*。
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              创建一个新的、未初始化的可变绑定。字符串 _N_ 为名称文本。若布尔参数 _D_ 为 *true*，该绑定之后可删除。
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              创建新的、未初始化的不可变绑定。字符串 _N_ 为名称文本。若 _S_ 为 *true*，初始化后再设置将始终抛出异常（与引用该绑定的操作是否严格模式无关）。
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              为已存在但未初始化的绑定设置值。_N_ 为名称文本，_V_ 为任意 ECMAScript 语言类型的值。
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              为已存在的可变绑定设置值 _V_。_S_ 为布尔标记；若 _S_ 为 *true* 且绑定无法被设置则抛出 *TypeError*。
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              返回已存在绑定的值。_S_ 标记引用是否源自严格模式（或需要严格语义）。若 _S_ 为 *true* 且绑定不存在抛 *ReferenceError*。若绑定存在但未初始化，无论 _S_ 值为何都抛 *ReferenceError*。
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              删除名称为 _N_ 的绑定。存在则移除并返回 *true*；存在但不可移除返回 *false*；不存在返回 *true*。
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              判断是否建立 `this` 绑定；是返回 *true*，否则 *false*。
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              判断是否建立 `super` 方法绑定；是返回 *true*，否则 *false*。若返回 *true* 则表明该记录是 Function Environment Record（反之不一定）。
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              若该 Environment Record 与 `with` 语句关联则返回其对象；否则返回 *undefined*。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>声明式环境记录 (Declarative Environment Records)</h1>
        <p>每个 <dfn variants="Declarative Environment Records">Declarative Environment Record</dfn> 与一个 ECMAScript 程序作用域关联，该作用域包含变量、常量、let、class、module、import 以及（或）函数声明。Declarative Environment Record 绑定其作用域内声明定义的标识符集合。</p>

        <emu-clause id="sec-declarative-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>判定参数标识符是否在记录绑定的标识符之中。</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_ 对 _N_ 有绑定，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新的未初始化可变绑定。_envRec_ 中不得已存在该名称绑定。若 _D_ 为 *true*，新绑定标记为可删除。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 尚无 _N_ 绑定。
            1. 在 _envRec_ 中创建 _N_ 的可变绑定并记录其未初始化。若 _D_ 为 *true*，记录该绑定可被后续 DeleteBinding 删除。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新的未初始化不可变绑定。不得已存在绑定。若 _S_ 为 *true*，新绑定标记为严格绑定。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 尚无 _N_ 绑定。
            1. 在 _envRec_ 中创建 _N_ 的不可变绑定并记录其未初始化。若 _S_ 为 *true*，记录其为严格绑定。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>将名称为 _N_ 的当前绑定的值设为 _V_。必须已存在未初始化绑定。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 必须有 _N_ 的未初始化绑定。
            1. 将 _envRec_ 中 _N_ 的绑定值设为 _V_。
            1. <emu-not-ref>记录</emu-not-ref> _envRec_ 中 _N_ 的绑定已被初始化。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或一个抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>尝试将名称为 _N_ 的当前绑定的值改为 _V_。通常已有该绑定，但在少见情况下可能没有。若绑定为不可变且 _S_ 为 *true*，抛 *TypeError*。</dd>
          </dl>
          <emu-alg>
            1. [id="step-setmutablebinding-missing-binding"] 若 _envRec_ 无 _N_ 绑定，则
              1. 若 _S_ 为 *true*，抛 *ReferenceError*。
              1. 执行 ! _envRec_.CreateMutableBinding(_N_, *true*)。
              1. 执行 ! _envRec_.InitializeBinding(_N_, _V_)。
              1. 返回 ~unused~。
            1. 若 _envRec_ 中 _N_ 的绑定是严格绑定，将 _S_ 设为 *true*。
            1. 若 _envRec_ 中 _N_ 的绑定尚未初始化，则
              1. 抛 *ReferenceError*。
            1. 否则若为可变绑定，
              1. 将其值改为 _V_。
            1. 否则，
              1. 断言：正在尝试修改不可变绑定的值。
              1. 若 _S_ 为 *true*，抛 *TypeError*。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>导致在步骤 <emu-xref href="#step-setmutablebinding-missing-binding"></emu-xref> 出现缺失绑定的 ECMAScript 示例：</p>
            <pre><code class="javascript">function f() { eval("var x; x = (delete x, 0);"); }</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或一个抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回名称为 _N_ 的绑定值。若绑定存在但未初始化，无论 _S_ 值为何都抛 *ReferenceError*。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 有 _N_ 的绑定。
            1. 若其为未初始化绑定，抛 *ReferenceError*。
            1. 返回当前绑定于 _N_ 的值。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>只能删除已显式标记为可删除的绑定。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 有 _N_ 的绑定。
            1. 若该绑定不可删除，返回 *false*。
            1. 从 _envRec_ 移除该绑定。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>普通 Declarative Environment Record（即既不是 Function 也不是 Module Environment Record）不提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>普通 Declarative Environment Record 不提供 `super` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-declarative-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Declarative Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>对象环境记录 (Object Environment Records)</h1>
        <p>每个 <dfn variants="Object Environment Records">Object Environment Record</dfn> 关联一个称为其 <em>binding object</em> 的对象。它绑定该对象属性名中与字符串标识符名称直接对应的集合。不是 |IdentifierName| 形式字符串的属性键不计入。集合包含自有与继承属性，与其 [[Enumerable]] 属性设置无关。由于对象属性可动态添加/删除，对应绑定集合可能随任何添加或删除属性的操作产生副作用而变化。副作用新增的绑定被视为可变绑定，即使对应属性的 Writable 为 *false*。Object Environment Record 不存在不可变绑定。</p>
        <p>为 `with` 语句（<emu-xref href="#sec-with-statement"></emu-xref>）创建的 Object Environment Record 可以在函数调用中将其绑定对象作为隐式 *this* 值。该能力由布尔字段 [[IsWithEnvironment]] 控制。</p>
        <p>Object Environment Record 具有 <emu-xref href="#table-additional-fields-of-object-environment-records"></emu-xref> 所列附加状态字段。</p>
        <emu-table id="table-additional-fields-of-object-environment-records" caption="Object Environment Record 的附加字段">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[BindingObject]]
              </td>
              <td>
                一个 Object
              </td>
              <td>
                此 Environment Record 的绑定对象。
              </td>
            </tr>
            <tr>
              <td>
                [[IsWithEnvironment]]
              </td>
              <td>
                一个 Boolean
              </td>
              <td>
                指示该记录是否为 `with` 语句创建。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-object-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>判定其绑定对象是否有名为 _N_ 的属性。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 令 _foundBinding_ 为 ? HasProperty(_bindingObject_, _N_)。
            1. 若 _foundBinding_ 为 *false*，返回 *false*。
            1. 若 _envRec_.[[IsWithEnvironment]] 为 *false*，返回 *true*。
            1. 令 _unscopables_ 为 ? Get(_bindingObject_, %Symbol.unscopables%)。
            1. 若 _unscopables_ 是 Object，则
              1. 令 _blocked_ 为 ToBoolean(? Get(_unscopables_, _N_))。
              1. 若 _blocked_ 为 *true*，返回 *false*。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>在绑定对象上创建名为 _N_ 的属性，并初始化为 *undefined*。若 _D_ 为 *true*，新属性的 [[Configurable]] 设为 *true*，否则为 *false*。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 执行 ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ })。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>通常 _envRec_ 不会已有 _N_ 绑定；若已存在，DefinePropertyOrThrow 的语义可能替换、遮蔽或抛出异常。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-createimmutablebinding-n-s">
          <h1>CreateImmutableBinding ( _N_, _S_ )</h1>
          <p>Object Environment Record 的 CreateImmutableBinding 具体方法在本规范中从未使用。</p>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>将名称为 _N_ 的当前绑定的值设为 _V_。</dd>
          </dl>
          <emu-alg>
            1. 执行 ? <emu-meta effects="user-code">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*)。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>在本规范中，对 Object Environment Record 调用 CreateMutableBinding 后立即调用 InitializeBinding，因此不显式跟踪其初始化状态。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>尝试将绑定对象名为 _N_ 的属性值设为 _V_。该属性通常已存在；若不存在或当前不可写，错误处理由 _S_ 决定。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 令 _stillExists_ 为 ? HasProperty(_bindingObject_, _N_)。
            1. 若 _stillExists_ 为 *false* 且 _S_ 为 *true*，抛 *ReferenceError*。
            1. 执行 ? Set(_bindingObject_, _N_, _V_, _S_)。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回绑定对象名为 _N_ 的属性值。若属性不存在，结果取决于 _S_。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 令 _value_ 为 ? HasProperty(_bindingObject_, _N_)。
            1. 若 _value_ 为 *false*，则
              1. 若 _S_ 为 *false*，返回 *undefined*；否则抛 *ReferenceError*。
            1. 返回 ? Get(_bindingObject_, _N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>只能删除其环境对象上 [[Configurable]] 为 *true* 的属性对应的绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _bindingObject_ 为 _envRec_.[[BindingObject]]。
            1. 返回 ? <emu-meta effects="user-code">_bindingObject_.[[Delete]]</emu-meta>(_N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>Object Environment Record 不提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>Object Environment Record 不提供 `super` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-object-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): 一个 Object 或 *undefined*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Object Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_.[[IsWithEnvironment]] 为 *true*，返回 _envRec_.[[BindingObject]]。
            1. 否则返回 *undefined*。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records" oldids="function-environment">
        <h1>函数环境记录 (Function Environment Records)</h1>
        <p><dfn variants="Function Environment Records">Function Environment Record</dfn> 是一个 Declarative Environment Record，表示函数的顶层作用域，并且若函数不是 |ArrowFunction|，则提供 `this` 绑定。若一个非 |ArrowFunction| 函数引用 `super`，其 Function Environment Record 也包含执行 `super` 方法调用所需的状态。</p>
        <p>Function Environment Record 有 <emu-xref href="#table-additional-fields-of-function-environment-records"></emu-xref> 中列出的附加状态字段。</p>
        <emu-table id="table-additional-fields-of-function-environment-records" caption="Function Environment Record 的附加字段" oldids="table-16">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                一个 ECMAScript 语言值
              </td>
              <td>
                此次函数调用使用的 *this* 值。
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                ~lexical~, ~initialized~, 或 ~uninitialized~
              </td>
              <td>
                若为 ~lexical~，表明是 |ArrowFunction|，无本地 *this*。
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                一个 ECMAScript 函数对象
              </td>
              <td>
                其调用导致此 Environment Record 被创建的函数对象。
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                一个 constructor 或 *undefined*
              </td>
              <td>
                若由 [[Construct]] 创建，则为该内部方法 _newTarget_ 参数；否则为 *undefined*。
              </td>
            </tr>
          </table>
        </emu-table>
        <p>Function Environment Record 支持 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> 中列出的所有 Declarative Environment Record 方法，除 HasThisBinding 与 HasSuperBinding 外与其规范相同；另外支持 <emu-xref href="#table-additional-methods-of-function-environment-records"></emu-xref> 中列出的方法：</p>
        <emu-table id="table-additional-methods-of-function-environment-records" caption="Function Environment Record 的附加方法" oldids="table-17">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                返回该 Environment Record 的 `this` 绑定值，若尚未初始化则抛 *ReferenceError*。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-bindthisvalue" type="abstract operation">
          <h1>
            BindThisValue (
              _envRec_: 一个 Function Environment Record,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>设置 _envRec_.[[ThisValue]] 并记录其已初始化。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_.[[ThisBindingStatus]] 不为 ~lexical~。
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~initialized~，抛 *ReferenceError*。
            1. 设 _envRec_.[[ThisValue]] 为 _V_。
            1. 设 _envRec_.[[ThisBindingStatus]] 为 ~initialized~。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): 一个 Boolean</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~lexical~，返回 *false*；否则返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): 一个 Boolean</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~lexical~，返回 *false*。
            1. 若 _envRec_.[[FunctionObject]].[[HomeObject]] 为 *undefined*，返回 *false*；否则返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-function-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): 一个包含 ECMAScript 语言值的正常完成或抛出完成</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Function Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_.[[ThisBindingStatus]] 不为 ~lexical~。
            1. 若 _envRec_.[[ThisBindingStatus]] 为 ~uninitialized~，抛 *ReferenceError*。
            1. 返回 _envRec_.[[ThisValue]]。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getsuperbase" type="abstract operation">
          <h1>
            GetSuperBase (
              _envRec_: 一个 Function Environment Record,
            ): 一个 Object、*null* 或 *undefined*
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>返回在 _envRec_ 中绑定 `super` 属性访问的基对象。若为 *undefined*，表示该访问将产生运行时错误。</dd>
          </dl>
          <emu-alg>
            1. 令 _home_ 为 _envRec_.[[FunctionObject]].[[HomeObject]]。
            1. 若 _home_ 为 *undefined*，返回 *undefined*。
            1. 断言：_home_ 是普通对象。
            1. 返回 ! _home_.[[GetPrototypeOf]]()。
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records" oldids="global-environment">
        <h1>全局环境记录 (Global Environment Records)</h1>
        <p><dfn variants="Global Environment Records">Global Environment Record</dfn> 表示在同一 realm 中处理的所有 ECMAScript |Script| 元素共享的最外层作用域。提供内置全局（<emu-xref href="#sec-global-object"></emu-xref>）、全局对象属性以及所有顶层声明（<emu-xref href="#sec-static-semantics-toplevellexicallyscopeddeclarations"></emu-xref>，<emu-xref href="#sec-static-semantics-toplevelvarscopeddeclarations"></emu-xref>）的绑定。</p>
        <p>Global Environment Record 在逻辑上是单一记录，但被描述为封装一个 Object Environment Record 和一个 Declarative Environment Record 的复合体。Object Environment Record 的基对象为关联 Realm Record 的全局对象。该全局对象是其 GetThisBinding 具体方法返回的值。Object 组件包含内置全局与由 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableStatement| 引入的全局代码绑定；其余声明的绑定位于 Declarative 组件。</p>
        <p>可以直接在全局对象上创建属性，因此 Object 组件可能同时包含通过声明显式创建的绑定与作为全局对象属性隐式创建的绑定。为区分通过声明显式创建的绑定，Global Environment Record 维护使用 CreateGlobalVarBinding 与 CreateGlobalFunctionBinding 创建的名称列表。</p>
        <p>Global Environment Record 具有 <emu-xref href="#table-additional-fields-of-global-environment-records"></emu-xref> 中的附加字段和 <emu-xref href="#table-additional-methods-of-global-environment-records"></emu-xref> 中的附加方法。</p>
        <emu-table id="table-additional-fields-of-global-environment-records" caption="Global Environment Record 的附加字段" oldids="table-18">
          <table>
            <thead>
              <tr>
                <th>
                  字段名
                </th>
                <th>
                  值
                </th>
                <th>
                  含义
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ObjectRecord]]
              </td>
              <td>
                一个 Object Environment Record
              </td>
              <td>
                绑定对象是全局对象，包含全局内置绑定以及全局代码中 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableDeclaration| 的绑定。
              </td>
            </tr>
            <tr>
              <td>
                [[GlobalThisValue]]
              </td>
              <td>
                一个 Object
              </td>
              <td>
                全局作用域中 `this` 返回的值；宿主可提供任意 ECMAScript Object。
              </td>
            </tr>
            <tr>
              <td>
                [[DeclarativeRecord]]
              </td>
              <td>
                一个 Declarative Environment Record
              </td>
              <td>
                <emu-not-ref>包含</emu-not-ref> 全局代码中除 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration|、|AsyncGeneratorDeclaration|、|VariableDeclaration| 外所有声明的绑定。
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-additional-methods-of-global-environment-records" caption="Global Environment Record 的附加方法" oldids="table-19">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                返回该 Environment Record 的 `this` 绑定。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-global-environment-records-hasbinding-n" type="concrete method">
          <h1>
            HasBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>判定参数标识符是否被该记录绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，返回 *true*。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.HasBinding</emu-meta>(_N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createmutablebinding-n-d" type="concrete method">
          <h1>
            CreateMutableBinding (
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新的未初始化可变绑定，存于关联的 DeclarativeRecord 中，不得已存在；若 _D_ 为 *true*，标记为可删除。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，抛 *TypeError*。
            1. 返回 ! _DclRec_.CreateMutableBinding(_N_, _D_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-createimmutablebinding-n-s" type="concrete method">
          <h1>
            CreateImmutableBinding (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>创建新未初始化不可变绑定。不得已存在。若 _S_ 为 *true*，标记为严格绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，抛 *TypeError*。
            1. 返回 ! _DclRec_.CreateImmutableBinding(_N_, _S_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-initializebinding-n-v" type="concrete method">
          <h1>
            InitializeBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>将名称为 _N_ 的当前绑定值设为 _V_；必须已存在未初始化绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ! _DclRec_.InitializeBinding(_N_, _V_)。
            1. 断言：若存在绑定则位于 Object Environment Record 中。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-setmutablebinding-n-v-s" type="concrete method">
          <h1>
            SetMutableBinding (
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _S_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>尝试更改名称为 _N_ 的当前绑定值为 _V_。若为不可变绑定且 _S_ 为 *true*，抛 *TypeError*。若属性不存在或不可写，处理取决于 _S_。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ? _DclRec_.SetMutableBinding(_N_, _V_, _S_)。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回名称为 _N_ 的绑定值。若为未初始化绑定抛 *ReferenceError*。若属性不存在或不可写，处理取决于 _S_。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ? _DclRec_.GetBindingValue(_N_, _S_)。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 返回 ? <emu-meta effects="user-code">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-deletebinding-n" type="concrete method">
          <h1>
            DeleteBinding (
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>只能删除被标记为可删除的绑定。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 若 ! _DclRec_.HasBinding(_N_) 为 *true*，则
              1. 返回 ! _DclRec_.DeleteBinding(_N_)。
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? HasOwnProperty(_globalObject_, _N_)。
            1. 若 _existingProp_ 为 *true*，则
              1. 返回 ? <emu-meta effects="user-code">_ObjRec_.DeleteBinding</emu-meta>(_N_)。
            1. 返回 *true*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *true*。
          </emu-alg>
          <emu-note>
            <p>Global Environment Record 始终提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-hassuperbinding" type="concrete method">
          <h1>HasSuperBinding ( ): *false*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *false*。
          </emu-alg>
          <emu-note>
            <p>Global Environment Record 不提供 `super` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-withbaseobject" type="concrete method">
          <h1>WithBaseObject ( ): *undefined*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-global-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): 一个包含 Object 的正常完成</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Global Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 _envRec_.[[GlobalThisValue]]。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-haslexicaldeclaration" type="abstract operation">
          <h1>
            HasLexicalDeclaration (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个 Boolean
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判断参数标识符是否在 _envRec_ 中以 |LexicalDeclaration| 或 |ClassDeclaration| 等词法声明创建。</dd>
          </dl>
          <emu-alg>
            1. 令 _DclRec_ 为 _envRec_.[[DeclarativeRecord]]。
            1. 返回 ! _DclRec_.HasBinding(_N_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-hasrestrictedglobalproperty" type="abstract operation">
          <h1>
            HasRestrictedGlobalProperty (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判断参数标识符是否为不得被全局词法绑定遮蔽的全局对象属性之名。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)。
            1. 若 _existingProp_ 为 *undefined*，返回 *false*。
            1. 若 _existingProp_.[[Configurable]] 为 *true*，返回 *false*。
            1. 返回 *true*。
          </emu-alg>
          <emu-note>
            <p>可直接在全局对象上存在非声明创建的属性。不能创建与全局对象不可配置属性同名的全局词法绑定，例如 *"undefined"*。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalvar" type="abstract operation">
          <h1>
            CanDeclareGlobalVar (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判定同参数 _N_ 调用 CreateGlobalVarBinding 是否会成功；允许冗余 var 声明以及针对已存在全局对象属性的 var 声明。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _hasProperty_ 为 ? HasOwnProperty(_globalObject_, _N_)。
            1. 若 _hasProperty_ 为 *true*，返回 *true*。
            1. 返回 ? IsExtensible(_globalObject_)。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-candeclareglobalfunction" type="abstract operation">
          <h1>
            CanDeclareGlobalFunction (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
            ): 一个包含 Boolean 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>判定同参数 _N_ 调用 CreateGlobalFunctionBinding 是否会成功。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)。
            1. 若 _existingProp_ 为 *undefined*，返回 ? IsExtensible(_globalObject_)。
            1. 若 _existingProp_.[[Configurable]] 为 *true*，返回 *true*。
            1. 若 IsDataDescriptor(_existingProp_) 为 *true* 且 _existingProp_ 具属性 { [[Writable]]: *true*, [[Enumerable]]: *true* }，返回 *true*。
            1. 返回 *false*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalvarbinding" type="abstract operation">
          <h1>
            CreateGlobalVarBinding (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>在关联的 Object Environment Record 中创建并初始化可变绑定。若已存在则复用并视为已初始化。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _hasProperty_ 为 ? HasOwnProperty(_globalObject_, _N_)。
            1. 令 _extensible_ 为 ? IsExtensible(_globalObject_)。
            1. 若 _hasProperty_ 为 *false* 且 _extensible_ 为 *true*，则
              1. 执行 ? <emu-meta effects="user-code">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_)。
              1. 执行 ? <emu-meta effects="user-code">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*)。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createglobalfunctionbinding" type="abstract operation">
          <h1>
            CreateGlobalFunctionBinding (
              _envRec_: 一个 Global Environment Record,
              _N_: 一个 String,
              _V_: 一个 ECMAScript 语言值,
              _D_: 一个 Boolean,
            ): 一个包含 ~unused~ 的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>在关联 Object Environment Record 中创建并初始化可变绑定；若已存在则替换。</dd>
          </dl>
          <emu-alg>
            1. 令 _ObjRec_ 为 _envRec_.[[ObjectRecord]]。
            1. 令 _globalObject_ 为 _ObjRec_.[[BindingObject]]。
            1. 令 _existingProp_ 为 ? <emu-meta effects="user-code">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_)。
            1. 若 _existingProp_ 为 *undefined* 或其 [[Configurable]] 为 *true*，则
              1. 令 _desc_ 为 PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }。
            1. 否则，
              1. 令 _desc_ 为 PropertyDescriptor { [[Value]]: _V_ }。
            1. 执行 ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_)。
            1. [id="step-createglobalfunctionbinding-set"] 执行 ? Set(_globalObject_, _N_, _V_, *false*)。
            1. 返回 ~unused~。
          </emu-alg>
          <emu-note>
            <p>全局函数声明总以全局对象自有属性表示；若可行，重配置为标准属性集。步骤 <emu-xref href="#step-createglobalfunctionbinding-set"></emu-xref> 等价于调用 InitializeBinding，且若 _globalObject_ 为 Proxy 将产生相同的 trap 调用序列。</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-module-environment-records" oldids="module-environment">
        <h1>模块环境记录 (Module Environment Records)</h1>
        <p><dfn variants="Module Environment Records">Module Environment Record</dfn> 是一个 Declarative Environment Record，用于表示 ECMAScript |Module| 的外层作用域。除普通可变与不可变绑定外，还提供不可变的 import 绑定，这些绑定间接访问另一个 Environment Record 中的目标绑定。</p>
        <p>Module Environment Record 支持 <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> 中列出的所有 Declarative Environment Record 方法，除 GetBindingValue、DeleteBinding、HasThisBinding 与 GetThisBinding 外与其规范相同；另外支持 <emu-xref href="#table-additional-methods-of-module-environment-records"></emu-xref> 中的方法：</p>
        <emu-table id="table-additional-methods-of-module-environment-records" caption="Module Environment Record 的附加方法" oldids="table-20">
          <table>
            <thead>
              <tr>
                <th>
                  方法
                </th>
                <th>
                  目的
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                返回该 Environment Record 的 `this` 绑定值。
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-module-environment-records-getbindingvalue-n-s" type="concrete method">
          <h1>
            GetBindingValue (
              _N_: 一个 String,
              _S_: 一个 Boolean,
            ): 一个包含 ECMAScript 语言值的正常完成或抛出完成
          </h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Module Environment Record _envRec_</dd>

            <dt>描述</dt>
            <dd>返回名称为 _N_ 的绑定值；若为间接绑定则返回目标绑定的值。若存在但未初始化抛 *ReferenceError*。</dd>
          </dl>
          <emu-alg>
            1. 断言：_S_ 为 *true*。
            1. 断言：_envRec_ 有 _N_ 绑定。
            1. 若 _N_ 的绑定是间接绑定，则
              1. 令 _M_ 与 _N2_ 为创建该绑定时提供的间接值。
              1. 令 _targetEnv_ 为 _M_.[[Environment]]。
              1. 若 _targetEnv_ 为 ~empty~，抛 *ReferenceError*。
              1. 返回 ? <emu-meta effects="user-code">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*)。
            1. 若 _envRec_ 中 _N_ 的绑定为未初始化，抛 *ReferenceError*。
            1. 返回当前绑定于 _N_ 的值。
          </emu-alg>
          <emu-note>
            <p>_S_ 始终为 *true*，因为 |Module| 总是严格模式。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-deletebinding-n">
          <h1>DeleteBinding ( _N_ )</h1>
          <p>Module Environment Record 的 DeleteBinding 具体方法在本规范中从未使用。</p>
          <emu-note>
            <p>Module Environment Record 仅用于严格代码，并且早期错误规则阻止在严格代码中对解析到模块环境绑定的 Reference Record 使用 delete。见 <emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-hasthisbinding" type="concrete method">
          <h1>HasThisBinding ( ): *true*</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *true*。
          </emu-alg>
          <emu-note>
            <p>Module Environment Record 始终提供 `this` 绑定。</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-module-environment-records-getthisbinding" type="concrete method">
          <h1>GetThisBinding ( ): 一个包含 *undefined* 的正常完成</h1>
          <dl class="header">
            <dt>适用于</dt>
            <dd>Module Environment Record _envRec_</dd>
          </dl>
          <emu-alg>
            1. 返回 *undefined*。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-createimportbinding" type="abstract operation">
          <h1>
            CreateImportBinding (
              _envRec_: 一个 Module Environment Record,
              _N_: 一个 String,
              _M_: 一个 Module Record,
              _N2_: 一个 String,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>描述</dt>
            <dd>创建名称为 _N_ 的新已初始化不可变间接绑定；不得已存在。_N2_ 是 _M_ 的 Module Environment Record 中存在的绑定名。访问该新绑定的值将间接访问目标绑定的值。</dd>
          </dl>
          <emu-alg>
            1. 断言：_envRec_ 尚无 _N_ 绑定。
            1. 断言：当 _M_.[[Environment]] 实例化时会有 _N2_ 的直接绑定。
            1. 在 _envRec_ 中创建引用 _M_ 与 _N2_ 的不可变间接绑定并记录其已初始化。
            1. 返回 ~unused~。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>环境记录操作 (Environment Record Operations)</h1>
      <p>下列抽象操作用于在本规范中对 Environment Record 进行操作：</p>

      <emu-clause id="sec-getidentifierreference" type="abstract operation">
        <h1>
          GetIdentifierReference (
            _env_: 一个 Environment Record 或 *null*,
            _name_: 一个 String,
            _strict_: 一个 Boolean,
          ): 一个包含 Reference Record 的正常完成或抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _env_ 为 *null*，则
            1. 返回 Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }。
          1. 令 _exists_ 为 ? <emu-meta effects="user-code">_env_.HasBinding</emu-meta>(_name_)。
          1. 若 _exists_ 为 *true*，则
            1. 返回 Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }。
          1. 否则，
            1. 令 _outer_ 为 _env_.[[OuterEnv]]。
            1. 返回 ? GetIdentifierReference(_outer_, _name_, _strict_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newdeclarativeenvironment" type="abstract operation">
        <h1>
          NewDeclarativeEnvironment (
            _E_: 一个 Environment Record 或 *null*,
          ): 一个 Declarative Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个不含绑定的新 Declarative Environment Record。
          1. 设 _env_.[[OuterEnv]] 为 _E_。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newobjectenvironment" type="abstract operation">
        <h1>
          NewObjectEnvironment (
            _O_: 一个 Object,
            _W_: 一个 Boolean,
            _E_: 一个 Environment Record 或 *null*,
          ): 一个 Object Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个新 Object Environment Record。
          1. 设 _env_.[[BindingObject]] 为 _O_。
          1. 设 _env_.[[IsWithEnvironment]] 为 _W_。
          1. 设 _env_.[[OuterEnv]] 为 _E_。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newfunctionenvironment" type="abstract operation">
        <h1>
          NewFunctionEnvironment (
            _F_: 一个 ECMAScript 函数对象,
            _newTarget_: 一个 Object 或 *undefined*,
          ): 一个 Function Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个不含绑定的新 Function Environment Record。
          1. 设 _env_.[[FunctionObject]] 为 _F_。
          1. 若 _F_.[[ThisMode]] 为 ~lexical~，设 _env_.[[ThisBindingStatus]] 为 ~lexical~。
          1. 否则设 _env_.[[ThisBindingStatus]] 为 ~uninitialized~。
          1. 设 _env_.[[NewTarget]] 为 _newTarget_。
          1. 设 _env_.[[OuterEnv]] 为 _F_.[[Environment]]。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newglobalenvironment" type="abstract operation">
        <h1>
          NewGlobalEnvironment (
            _G_: 一个 Object,
            _thisValue_: 一个 Object,
          ): 一个 Global Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _objRec_ 为 NewObjectEnvironment(_G_, *false*, *null*)。
          1. 令 _dclRec_ 为 NewDeclarativeEnvironment(*null*)。
          1. 令 _env_ 为一个新 Global Environment Record。
          1. 设 _env_.[[ObjectRecord]] 为 _objRec_。
          1. 设 _env_.[[GlobalThisValue]] 为 _thisValue_。
          1. 设 _env_.[[DeclarativeRecord]] 为 _dclRec_。
          1. 设 _env_.[[OuterEnv]] 为 *null*。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newmoduleenvironment" type="abstract operation">
        <h1>
          NewModuleEnvironment (
            _E_: 一个 Environment Record,
          ): 一个 Module Environment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _env_ 为一个不含绑定的新 Module Environment Record。
          1. 设 _env_.[[OuterEnv]] 为 _E_。
          1. 返回 _env_。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-privateenvironment-records">
    <h1>PrivateEnvironment 记录 (PrivateEnvironment Records)</h1>
    <p><dfn id="privateenvironment-record" variants="PrivateEnvironment Records">PrivateEnvironment Record</dfn> 是一种规范机制，用于基于 ECMAScript 代码中 |ClassDeclaration| 与 |ClassExpression| 的词法嵌套结构跟踪 Private Name。它们与 Environment Record 类似但不同。每个 PrivateEnvironment Record 与一个 |ClassDeclaration| 或 |ClassExpression| 关联。每次此类 class 被求值时，会创建一个新的 PrivateEnvironment Record 来记录该 class 声明的 Private Name。</p>
    <p>每个 PrivateEnvironment Record 拥有 <emu-xref href="#table-privateenvironment-records"></emu-xref> 中定义的字段。</p>
    <emu-table id="table-privateenvironment-records" caption="PrivateEnvironment Record 字段">
      <table>
        <thead>
          <tr>
            <th>
              字段名
            </th>
            <th>
              值类型
            </th>
            <th>
              含义
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[OuterPrivateEnvironment]]
          </td>
          <td>
            一个 PrivateEnvironment Record 或 *null*
          </td>
          <td>
            最近包围的 class 的 PrivateEnvironment Record。若与此 PrivateEnvironment Record 关联的 class 未被任何其他 class 包含则为 *null*。
          </td>
        </tr>
        <tr>
          <td>
            [[Names]]
          </td>
          <td>
            一个 Private Name 列表
          </td>
          <td>
            该 class 声明的 Private Name。
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-privateenvironment-record-operations">
      <h1>PrivateEnvironment Record 操作 (PrivateEnvironment Record Operations)</h1>
      <p>以下抽象操作用于在本规范中对 PrivateEnvironment Record 进行操作：</p>

      <emu-clause id="sec-newprivateenvironment" type="abstract operation">
        <h1>
          NewPrivateEnvironment (
            _outerPrivateEnv_: a PrivateEnvironment Record or *null*,
          ): a PrivateEnvironment Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _names_ 为一个新的空 List。
          1. 返回 PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivateEnv_, [[Names]]: _names_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-resolve-private-identifier" type="abstract operation">
        <h1>
          ResolvePrivateIdentifier (
            _privateEnv_: a PrivateEnvironment Record,
            _identifier_: a String,
          ): a Private Name
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _names_ 为 _privateEnv_.[[Names]]。
          1. 对于 _names_ 中每个 Private Name _pn_，执行
            1. 若 _pn_.[[Description]] 为 _identifier_，则
              1. 返回 _pn_。
          1. 令 _outerPrivateEnv_ 为 _privateEnv_.[[OuterPrivateEnvironment]]。
          1. 断言：_outerPrivateEnv_ 不为 *null*。
          1. 返回 ResolvePrivateIdentifier(_outerPrivateEnv_, _identifier_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realm</h1>
    <p>在被求值之前，所有 ECMAScript 代码都必须与一个 <dfn id="realm" variants="realms">realm</dfn> 相关联。概念上，realm 由一组内在对象、一个 ECMAScript 全局环境、在该全局环境作用域内加载的所有 ECMAScript 代码，以及其他关联状态与资源组成。</p>
    <p>在本规范中，一个 realm 表示为具有 <emu-xref href="#table-realm-record-fields"></emu-xref> 中字段的 <dfn id="realm-record" variants="Realm Records">Realm Record</dfn>：</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record 字段" oldids="table-21">
      <table>
        <thead>
          <tr>
            <th>
              字段名
            </th>
            <th>
              值
            </th>
            <th>
              含义
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[AgentSignifier]]
          </td>
          <td>
            一个 agent 标识符
          </td>
          <td>
            拥有该 realm 的 agent
          </td>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td>
            一个 Record，其字段名为内在 key，值为对象
          </td>
          <td>
            与该 realm 关联的代码使用的内在值
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td>
            一个 Object
          </td>
          <td>
            该 realm 的全局对象
          </td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td>
            一个 Global Environment Record
          </td>
          <td>
            该 realm 的全局环境
          </td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td>
            一个 Record 列表，字段 [[Site]] (一个 |TemplateLiteral| Parse Node) 与 [[Array]] (一个 Array)
          </td>
          <td>
            <p>模板对象按 realm 独立规范化，使用其 Realm Record 的 [[TemplateMap]]。每个 [[Site]] 值是一个 |TemplateLiteral| Parse Node。其关联的 [[Array]] 是传递给 tag 函数的对应模板对象。</p>
            <emu-note>一旦某 Parse Node 变为不可达，对应 [[Array]] 也不可达；实现移除该对条目将不可观察。</emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[LoadedModules]]
          </td>
          <td>
            一个 LoadedModuleRequest Record 列表
          </td>
          <td>
            <p>从该 realm 导入的 specifier 字符串到解析后 Module Record 的映射。该列表不包含两个不同 Record _r1_ 与 _r2_ 使得 ModuleRequestsEqual(_r1_, _r2_) 为 *true*。</p>
            <emu-note>
              如 HostLoadImportedModule 中所述 (<emu-xref href="#note-HostLoadImportedModule-referrer-Realm-Record"></emu-xref>)，Realm Record 中的 [[LoadedModules]] 仅在在没有活动 script 或 module 的上下文中运行 `import()` 表达式时使用。
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td>
            任意 (默认值为 *undefined*)
          </td>
          <td>
            为需要与 Realm Record 关联附加信息的宿主保留的字段。
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-initializehostdefinedrealm" type="abstract operation" oldids="sec-createrealm,sec-setrealmglobalobject">
      <h1>InitializeHostDefinedRealm ( ): either a normal completion containing ~unused~ or a throw completion</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _realm_ 为一个新的 Realm Record。
        1. 执行 CreateIntrinsics(_realm_)。
        1. 设 _realm_.[[AgentSignifier]] 为 AgentSignifier()。
        1. 设 _realm_.[[TemplateMap]] 为一个新的空 List。
        1. 令 _newContext_ 为一个新的执行上下文。
        1. 将 _newContext_ 的 Function 设为 *null*。
        1. 将 _newContext_ 的 Realm 设为 _realm_。
        1. 将 _newContext_ 的 ScriptOrModule 设为 *null*。
        1. 将 _newContext_ 压入执行上下文栈；_newContext_ 现在是运行执行上下文。
        1. 若宿主要求使用一个特殊对象作为 _realm_ 的全局对象，则
          1. 令 _global_ 为以宿主定义方式创建的此对象。
        1. 否则，
          1. 令 _global_ 为 OrdinaryObjectCreate(_realm_.[[Intrinsics]].[[%Object.prototype%]])。
        1. 若宿主要求 _realm_ 全局作用域中的 `this` 绑定返回不同于全局对象的对象，则
          1. 令 _thisValue_ 为以宿主定义方式创建的该对象。
        1. 否则，
          1. 令 _thisValue_ 为 _global_。
        1. 设 _realm_.[[GlobalObject]] 为 _global_。
        1. 设 _realm_.[[GlobalEnv]] 为 NewGlobalEnvironment(_global_, _thisValue_)。
        1. 执行 ? SetDefaultGlobalBindings(_realm_)。
        1. 在 _global_ 上创建任意宿主定义的全局对象属性。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-createintrinsics" type="abstract operation">
      <h1>
        CreateIntrinsics (
          _realmRec_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 将 _realmRec_.[[Intrinsics]] 设为一个新的 Record。
        1. [declared="steps,name,length,slots,prototype"] 按 <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref> 中的值设置 _realmRec_.[[Intrinsics]] 的字段。字段名为该表第一列列出的名称。每个字段的值为一个根据 <emu-xref href="#sec-global-object"></emu-xref> 至 <emu-xref href="#sec-reflection"></emu-xref> 中各对象规范完全递归填充属性值的新对象。所有对象属性值均为新创建对象。所有内置函数对象通过执行 CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) 创建，其中 _steps_ 是本规范给出的该函数定义，_name_ 是函数 *"name"* 属性初始值，_length_ 是函数 *"length"* 属性初始值，_slots_ 是函数指定内部槽名称列表（若有），_prototype_ 是指定的 [[Prototype]] 内部槽值。内在对象及其属性的创建顺序必须避免依赖尚未创建的对象。
        1. 执行 AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setdefaultglobalbindings" type="abstract operation">
      <h1>
        SetDefaultGlobalBindings (
          _realmRec_: a Realm Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _global_ 为 _realmRec_.[[GlobalObject]]。
        1. 对 <emu-xref href="#sec-global-object"></emu-xref> 条款中指定的全局对象的每个属性，执行
          1. 令 _name_ 为该属性名的 String 值。
          1. 令 _desc_ 为该属性的完全填充数据属性描述符，包含该属性指定的特性。对于 <emu-xref href="#sec-function-properties-of-the-global-object"></emu-xref>、<emu-xref href="#sec-constructor-properties-of-the-global-object"></emu-xref> 或 <emu-xref href="#sec-other-properties-of-the-global-object"></emu-xref> 中列出的属性，其 [[Value]] 为来自 _realmRec_ 的对应内在对象。
          1. 执行 ? DefinePropertyOrThrow(_global_, _name_, _desc_)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>执行上下文 (Execution Contexts)</h1>
    <p><dfn variants="execution contexts">execution context</dfn> 是规范装置，用于跟踪 ECMAScript 实现对代码的运行时求值。在任意时刻，每个 agent 最多只有一个实际执行代码的执行上下文，称为该 agent 的 <dfn id="running-execution-context" variants="running execution contexts">运行执行上下文 (running execution context)</dfn>。本规范中所有对运行执行上下文的引用均指当前 agent 的运行执行上下文。</p>
    <p><dfn id="execution-context-stack" variants="execution context stacks">执行上下文栈 (execution context stack)</dfn> 用于跟踪执行上下文。运行执行上下文始终是该栈的顶部元素。当控制从当前运行执行上下文关联的可执行代码转移到不与其关联的可执行代码时，会创建一个新的执行上下文。新执行上下文被压入栈顶并成为运行执行上下文。</p>
    <p>执行上下文包含跟踪其关联代码执行进度所需的实现特定状态。每个执行上下文至少具有 <emu-xref href="#table-state-components-for-all-execution-contexts"></emu-xref> 中列出的状态组成部分。</p>
    <emu-table id="table-state-components-for-all-execution-contexts" caption="所有执行上下文的状态组成部分" oldids="table-22">
      <table>
        <thead>
          <tr>
            <th>
              组成部分
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            code evaluation state
          </td>
          <td>
            执行、暂停与恢复该上下文关联代码求值所需的任意状态。
          </td>
        </tr>
        <tr>
          <td>
            Function
          </td>
          <td>
            若该上下文正在求值某函数对象的代码，则为该函数对象；若求值 |Script| 或 |Module|，该值为 *null*。
          </td>
        </tr>
        <tr>
          <td>
            Realm
          </td>
          <td>
            关联代码访问 ECMAScript 资源所用的 Realm Record。
          </td>
        </tr>
        <tr>
          <td>
            ScriptOrModule
          </td>
          <td>
            关联代码来源的 Module Record 或 Script Record。若不存在来源脚本或模块（如 InitializeHostDefinedRealm 创建的初始执行上下文），该值为 *null*。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>运行执行上下文对代码的求值可在本规范定义的各种点被挂起。一旦挂起，另一个执行上下文可成为运行执行上下文并开始求值其代码。之后某个时间，被挂起的执行上下文可再次成为运行执行上下文并从之前挂起的位置继续。运行执行上下文在不同上下文间的转换通常按堆栈后进先出方式，但某些 ECMAScript 特性需要非 LIFO 的转换。</p>
    <p>运行执行上下文 Realm 组成部分的值也称为 <dfn id="current-realm">当前 Realm Record</dfn>。运行执行上下文 Function 组成部分的值也称为 <dfn id="active-function-object">活动函数对象 (active function object)</dfn>。</p>
    <p><dfn id="ecmascript-code-execution-context" variants="ECMAScript code execution context">ECMAScript 代码执行上下文</dfn> 具有 <emu-xref href="#table-additional-state-components-for-ecmascript-code-execution-contexts"></emu-xref> 中列出的附加状态组成部分。</p>
    <emu-table id="table-additional-state-components-for-ecmascript-code-execution-contexts" caption="ECMAScript 代码执行上下文的附加状态组成部分" oldids="table-23">
      <table>
        <thead>
          <tr>
            <th>
              组成部分
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            LexicalEnvironment
          </td>
          <td>
            标识用于解析该上下文中代码标识符引用的 Environment Record。
          </td>
        </tr>
        <tr>
          <td>
            VariableEnvironment
          </td>
          <td>
            标识在该上下文中由 |VariableStatement| 创建绑定的 Environment Record。
          </td>
        </tr>
        <tr>
          <td>
            PrivateEnvironment
          </td>
          <td>
            标识持有最近包围 class 中 |ClassElement| 创建的 Private Name 的 PrivateEnvironment Record。若无包围 class 则为 *null*。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>执行上下文的 LexicalEnvironment 与 VariableEnvironment 组成部分始终是 Environment Record。</p>
    <p>表示 Generator 求值的执行上下文具有 <emu-xref href="#table-additional-state-components-for-generator-execution-contexts"></emu-xref> 中列出的附加状态组成部分。</p>
    <emu-table id="table-additional-state-components-for-generator-execution-contexts" caption="Generator 执行上下文的附加状态组成部分" oldids="table-24">
      <table>
        <thead>
          <tr>
            <th>
              组成部分
            </th>
            <th>
              目的
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Generator
          </td>
          <td>
            该执行上下文正在求值的 Generator。
          </td>
        </tr>
      </table>
    </emu-table>
    <p>大多数情况下，只有运行执行上下文（执行上下文栈顶）被本规范内算法直接操作。因此当未限定使用 “LexicalEnvironment” 与 “VariableEnvironment” 时，指的是运行执行上下文的那些组成部分。</p>
    <p>执行上下文纯属规范机制，不必对应 ECMAScript 实现中的具体实体。ECMAScript 代码无法直接访问或观察执行上下文。</p>

    <emu-clause id="sec-getactivescriptormodule" type="abstract operation">
      <h1>GetActiveScriptOrModule ( ): a Script Record, a Module Record, or *null*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>基于运行执行上下文确定运行脚本或模块。</dd>
      </dl>

      <emu-alg>
        1. 若执行上下文栈为空，返回 *null*。
        1. 令 _ec_ 为执行上下文栈顶端第一个其 ScriptOrModule 组成部分不为 *null* 的执行上下文。
        1. 若不存在此执行上下文，返回 *null*；否则返回 _ec_ 的 ScriptOrModule。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvebinding" type="abstract operation">
      <h1>
        ResolveBinding (
          _name_: a String,
          optional _env_: an Environment Record or *undefined*,
        ): either a normal completion containing a Reference Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于确定 _name_ 的绑定。_env_ 可显式提供要搜索绑定的 Environment Record。</dd>
      </dl>
      <emu-alg>
        1. 若 _env_ 未提供或 _env_ 为 *undefined*，则
          1. 设 _env_ 为运行执行上下文的 LexicalEnvironment。
        1. 断言：_env_ 是一个 Environment Record。
        1. 令 _strict_ 为正被求值的语法产生式的 IsStrict 结果。
        1. 返回 ? GetIdentifierReference(_env_, _name_, _strict_)。
      </emu-alg>
      <emu-note>
        <p>ResolveBinding 的结果始终是一个 [[ReferencedName]] 字段为 _name_ 的 Reference Record。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-getthisenvironment" type="abstract operation">
      <h1>GetThisEnvironment ( ): an Environment Record</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>查找当前提供关键字 `this` 绑定的 Environment Record。</dd>
      </dl>
      <emu-alg>
        1. 令 _env_ 为运行执行上下文的 LexicalEnvironment。
        1. [id="step-getthisenvironment-loop"] 重复，
          1. 令 _exists_ 为 _env_.HasThisBinding()。
          1. 若 _exists_ 为 *true*，返回 _env_。
          1. 令 _outer_ 为 _env_.[[OuterEnv]]。
          1. 断言：_outer_ 不为 *null*。
          1. 设 _env_ 为 _outer_。
      </emu-alg>
      <emu-note>
        <p>步骤 <emu-xref href="#step-getthisenvironment-loop"></emu-xref> 中的循环总会终止，因为环境链最后以具有 `this` 绑定的全局环境结束。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-resolvethisbinding" type="abstract operation">
      <h1>ResolveThisBinding ( ): either a normal completion containing an ECMAScript language value or a throw completion</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>使用运行执行上下文的 LexicalEnvironment 确定关键字 `this` 的绑定。</dd>
      </dl>
      <emu-alg>
        1. 令 _envRec_ 为 GetThisEnvironment()。
        1. 返回 ? _envRec_.GetThisBinding()。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getnewtarget" type="abstract operation">
      <h1>GetNewTarget ( ): an Object or *undefined*</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>使用运行执行上下文的 LexicalEnvironment 确定 NewTarget 值。</dd>
      </dl>
      <emu-alg>
        1. 令 _envRec_ 为 GetThisEnvironment()。
        1. 断言：_envRec_ 有 [[NewTarget]] 字段。
        1. 返回 _envRec_.[[NewTarget]]。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getglobalobject" type="abstract operation">
      <h1>GetGlobalObject ( ): an Object</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回当前运行执行上下文使用的全局对象。</dd>
      </dl>
      <emu-alg>
        1. 令 _currentRealm_ 为当前 Realm Record。
        1. 返回 _currentRealm_.[[GlobalObject]]。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-jobs" oldids="sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue">
    <h1>作业 (Jobs) 以及用于入队作业的宿主操作</h1>
    <p><dfn id="job" variants="Jobs">Job（作业）</dfn> 是一个无参数的抽象闭包（Abstract Closure），当当前没有其它 ECMAScript 计算正在进行时，它会启动一次 ECMAScript 计算。</p>
    <p>作业由 ECMAScript 宿主环境在特定 agent 中调度执行。本规范描述宿主挂钩 HostEnqueueGenericJob、HostEnqueueFinalizationRegistryCleanupJob、HostEnqueuePromiseJob 与 HostEnqueueTimeoutJob 来调度作业。本规范中的宿主挂钩按对作业调度施加的附加约束进行组织。宿主可定义额外的抽象操作来调度作业。此类操作接受一个 Job 抽象闭包和一个 realm（一个 Realm Record 或 *null*）作为参数。若提供了 Realm Record，则这些操作会在拥有该 realm 的 agent 中，于未来某个时间安排执行该作业。若改为为 realm 提供 *null*，则该作业不求值 ECMAScript 代码。它们的实现必须符合以下要求：</p>

    <ul>
      <li>在未来某个时间点，当相应 agent 中没有正在运行的上下文且该 agent 的执行上下文栈为空时，实现必须：
        <ol>
          <li>执行任何宿主定义的准备步骤。</li>
          <li><emu-not-ref>调用</emu-not-ref>该 Job 抽象闭包。</li>
          <li>执行任何宿主定义的清理步骤，之后执行上下文栈必须再次为空。</li>
        </ol>
      </li>
      <li>在一个 agent 中任意时间只能有一个 Job 正在被求值。</li>
      <li>一旦开始求值某个 Job，在该 agent 中必须先运行至完成，之后才可开始另一个 Job 的求值。</li>
      <li>该抽象闭包必须返回一个正常完成（normal completion），并自行处理错误。</li>
    </ul>

    <emu-note>
      宿主环境在调度方面不需要对所有 Job 一视同仁。例如，Web 浏览器与 Node.js 将处理 Promise 的 Job 视为比其它工作更高的优先级；未来特性可能添加不会设为如此高优先级的 Job。
    </emu-note>

    <p>在任意时间，若下列条件全部成立，则 _scriptOrModule_（一个 Script Record、Module Record 或 *null*）是<dfn id="job-activescriptormodule">活动脚本或模块 (active script or module)</dfn>：</p>
    <ul>
      <li>GetActiveScriptOrModule() 的结果为 _scriptOrModule_。</li>
      <li>若 _scriptOrModule_ 是 Script Record 或 Module Record，令 _ec_ 为执行上下文栈顶端第一个其 ScriptOrModule 组成部分为 _scriptOrModule_ 的执行上下文。_ec_ 的 Realm 组成部分为 _scriptOrModule_.[[Realm]]。</li>
    </ul>

    <p>在任意时间，若以下条件全部成立，则某次执行<dfn id="job-preparedtoevaluatecode">已准备好求值 ECMAScript 代码 (prepared to evaluate ECMAScript code)</dfn>：</p>
    <ul>
      <li>执行上下文栈不为空。</li>
      <li>执行上下文栈顶端执行上下文的 Realm 组成部分是一个 Realm Record。</li>
    </ul>

    <emu-note>
      <p>宿主环境可以通过向执行上下文栈压入执行上下文来准备执行求值代码。具体步骤由实现定义。</p>
      <p>Realm 的具体选择由宿主环境决定。这个初始执行上下文与 Realm 仅在任何回调函数被调用之前使用。当与某个 Job 相关的回调（如 Promise 处理器）被调用时，该调用会压入其自身的执行上下文与 Realm。</p>
    </emu-note>

    <p>特定种类的 Job 还有额外的一致性要求。</p>

    <emu-clause id="sec-jobcallback-records">
      <h1>JobCallback 记录 (JobCallback Records)</h1>
      <p><dfn variants="JobCallback Records">JobCallback Record</dfn> 是用于存储一个函数对象与一个宿主定义值的 Record。通过宿主入队的 Job 调用的函数对象可能具备额外的宿主定义上下文。为传播该状态，Job 抽象闭包不应直接捕获并调用函数对象；应改用 HostMakeJobCallback 与 HostCallJobCallback。</p>
      <emu-note>
        <p>例如，WHATWG HTML 规范（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）使用该宿主定义值来传播 Promise 回调的 incumbent settings object。</p>
      </emu-note>
      <p>JobCallback Record 具有 <emu-xref href="#table-jobcallback-records"></emu-xref> 中列出的字段。</p>
      <emu-table id="table-jobcallback-records" caption="JobCallback Record 字段">
        <table>
          <thead>
            <tr>
              <th>
                字段名
              </th>
              <th>
                值
              </th>
              <th>
                含义
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Callback]]
            </td>
            <td>
              一个函数对象
            </td>
            <td>
              当该 Job 被调用时要调用的函数。
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              任意（默认值 ~empty~）
            </td>
            <td>
              保留给宿主使用的字段。
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-hostmakejobcallback" type="host-defined abstract operation">
      <h1>
        HostMakeJobCallback (
          _callback_: a function object,
        ): a JobCallback Record
      </h1>
      <dl class="header">
      </dl>
      <p>HostMakeJobCallback 的实现必须符合以下要求：</p>
      <ul>
        <li>它必须返回一个 [[Callback]] 字段为 _callback_ 的 JobCallback Record。</li>
      </ul>
      <p>HostMakeJobCallback 的默认实现被调用时执行下列步骤：</p>
      <emu-alg>
        1. 返回 JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }。
      </emu-alg>
      <p>不是 Web 浏览器的 ECMAScript 宿主必须使用 HostMakeJobCallback 的默认实现。</p>
      <emu-note>
        <p>调用发生在回调被传入负责最终调度并运行它的函数之时。例如，`promise.then(thenAction)` 在调用 `Promise.prototype.then` 时对 `thenAction` 调用 MakeJobCallback，而不是在调度 reaction Job 时。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostcalljobcallback" type="host-defined abstract operation">
      <h1>
        HostCallJobCallback (
          _jobCallback_: a JobCallback Record,
          _V_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <p>HostCallJobCallback 的实现必须符合以下要求：</p>
      <ul>
        <li>它必须执行并返回 Call(_jobCallback_.[[Callback]], _V_, _argumentsList_) 的结果。</li>
      </ul>
      <emu-note>
        <p>该要求意味着宿主不能改变本规范定义的函数对象的 [[Call]] 行为。</p>
      </emu-note>
      <p>HostCallJobCallback 的默认实现被调用时执行下列步骤：</p>
      <emu-alg>
        1. 断言：IsCallable(_jobCallback_.[[Callback]]) 为 *true*。
        1. 返回 ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)。
      </emu-alg>
      <p>不是 Web 浏览器的 ECMAScript 宿主必须使用 HostCallJobCallback 的默认实现。</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuegenericjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueGenericJob (
          _job_: a Job Abstract Closure,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>在 _realm_.[[AgentSignifier]] 所指示的 agent 中，将 _job_ 安排于未来某个时间在 realm _realm_ 中执行。与该算法一起使用的抽象闭包意在不带额外约束（如优先级与排序）地调度。</dd>
      </dl>
      <p>HostEnqueueGenericJob 的实现必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求。</p>
    </emu-clause>

    <emu-clause id="sec-hostenqueuepromisejob" type="host-defined abstract operation">
      <h1>
        HostEnqueuePromiseJob (
          _job_: a Job Abstract Closure,
          _realm_: a Realm Record or *null*,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>安排 _job_ 于未来某个时间执行。与该算法一起使用的抽象闭包意在与 Promise 处理相关，或以与 Promise 处理操作同等优先级被调度。</dd>
      </dl>

      <p>HostEnqueuePromiseJob 的实现必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求并且满足以下附加要求：</p>
      <ul>
        <li>若 _realm_ 不为 *null*，则每次 _job_ 被调用时，实现必须执行实现定义步骤，使得在 _job_ 调用时执行已准备好求值 ECMAScript 代码。</li>
        <li>令 _scriptOrModule_ 为调用 HostEnqueuePromiseJob 时的 GetActiveScriptOrModule()。若 _realm_ 不为 *null*，则每次 _job_ 被调用时，实现必须执行实现定义步骤，使得在 _job_ 调用时 _scriptOrModule_ 为活动脚本或模块。</li>
        <li>作业必须按调度它们的各次 HostEnqueuePromiseJob 调用的顺序运行。</li>
      </ul>

      <emu-note>
        <p>由 NewPromiseResolveThenableJob 返回的 Job 的 _realm_ 通常是对 _then_ 函数对象调用 GetFunctionRealm 的结果。由 NewPromiseReactionJob 返回的 Job 的 _realm_ 通常是对处理器（若该处理器不为 *undefined*）调用 GetFunctionRealm 的结果。若处理器为 *undefined*，_realm_ 为 *null*。对于这两类 Job，当 GetFunctionRealm 异常完成（例如在被撤销的 Proxy 上调用）时，_realm_ 为调用 GetFunctionRealm 时的当前 Realm Record。当 _realm_ 为 *null* 时，不会执行用户 ECMAScript 代码，也不会创建新的 ECMAScript 对象（例如 Error 对象）。例如，WHATWG HTML 规范（<a href="https://html.spec.whatwg.org/">https://html.spec.whatwg.org/</a>）使用 _realm_ 来检查脚本是否可运行，以及与 <a href="https://html.spec.whatwg.org/#entry">entry</a> 概念相关。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostenqueuetimeoutjob" type="host-defined abstract operation">
      <h1>
        HostEnqueueTimeoutJob (
          _timeoutJob_: a Job Abstract Closure,
          _realm_: a Realm Record,
          _milliseconds_: a non-negative finite Number,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>在 _realm_.[[AgentSignifier]] 所指示的 agent 中，将 _timeoutJob_ 安排于至少 _milliseconds_ 毫秒之后在 realm _realm_ 中执行。</dd>
      </dl>
      <p>HostEnqueueTimeoutJob 的实现必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agents">
    <h1>Agents（代理）</h1>

    <p><dfn id="agent" variants="agents">agent（代理）</dfn> 由一组 ECMAScript 执行上下文、一个执行上下文栈、一个运行执行上下文、一个 <dfn id="agent-record" variants="Agent Records">Agent Record</dfn> 以及一个 <dfn id="executing-thread" variants="executing threads">执行线程 (executing thread)</dfn> 组成。除执行线程外，agent 的各组成部分只属于该 agent 本身。</p>
    <p>agent 的执行线程独立于其它 agent 在其执行上下文上执行算法步骤；但是一个执行线程可被多个 agent 共享，前提是共享该线程的 agent 中没有其 Agent Record 的 [[CanBlock]] 字段为 *true* 的。</p>
    <emu-note>
      <p>例如，一些 Web 浏览器会在多个互不相关的标签页间共享单一执行线程。</p>
    </emu-note>
    <p>当一个 agent 的执行线程在执行算法步骤时，该 agent 就是这些步骤的 <dfn id="surrounding-agent" variants="surrounding agents">包围 agent (surrounding agent)</dfn>。这些步骤通过该包围 agent 访问其持有的规范级执行对象：运行执行上下文、执行上下文栈以及 Agent Record 的字段。</p>
    <p><dfn variants="agent signifiers">agent signifier（代理标识符）</dfn> 是用于标识一个 Agent 的全局唯一不透明值。</p>
    <emu-table id="table-agent-record" caption="Agent Record 字段">
      <table>
        <thead>
          <tr>
            <th>字段名</th>
            <th>值</th>
            <th>含义</th>
          </tr>
        </thead>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>a Boolean</td>
          <td>用于算法 GetValueFromBuffer 与 SetValueInBuffer 所需参数 <em>isLittleEndian</em> 的默认值。选择由实现定义，应为实现效率最高的选项。一旦被观察到便不可改变。</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>a Boolean</td>
          <td>决定该 agent 是否可以阻塞。</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>an agent signifier</td>
          <td>在其 agent 集群内唯一标识该 agent。</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>a Boolean</td>
          <td>若对单<emu-not-ref>字节值</emu-not-ref>的原子操作无锁则为 *true*，否则 *false*。</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>a Boolean</td>
          <td>若对双<emu-not-ref>字节值</emu-not-ref>的原子操作无锁则为 *true*，否则 *false*。</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>a Boolean</td>
          <td>若对八<emu-not-ref>字节值</emu-not-ref>的原子操作无锁则为 *true*，否则 *false*。</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>a candidate execution Record</td>
          <td>参见内存模型。</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>a List of either Objects or Symbols</td>
          <td>初始为空 List，表示在当前 Job 结束前需保持存活的对象和/或 symbol 列表。</td>
        </tr>
        <tr>
          <td>[[ModuleAsyncEvaluationCount]]</td>
          <td>an integer</td>
          <td>初始为 0，用于为异步或具有异步依赖的模块的 [[AsyncEvaluationOrder]] 字段分配递增唯一值。</td>
        </tr>
      </table>
    </emu-table>

    <p>一旦 [[Signifier]]、[[IsLockFree1]] 与 [[IsLockFree2]] 的值被 agent 集群中的任一 agent 观察到，它们就不可更改。</p>

    <emu-note>
      <p>[[IsLockFree1]] 与 [[IsLockFree2]] 的值不一定由硬件决定，也可反映可能随时间与实现而变的实现选择。</p>

      <p>没有 [[IsLockFree4]] 字段：4 字节原子操作总是无锁。</p>

      <p>实际上，如果某原子操作用任何形式的锁实现，该操作就不是无锁的。无锁不意味着无等待（wait-free）：完成一个无锁原子操作需要的机器步骤数没有上界。</p>

      <p>某大小 <em>n</em> 的原子访问无锁并不意味着对同大小 <em>n</em> 的非原子访问具备（感知的）原子性；具体来说，非原子访问仍可能分解为多个独立的内存访问。详见 ReadSharedMemory 与 WriteSharedMemory。</p>
    </emu-note>

    <emu-note>
      <p>agent 是规范机制，不需对应 ECMAScript 实现中的实际产物。</p>
    </emu-note>

    <emu-clause id="sec-agentsignifier" type="abstract operation">
      <h1>AgentSignifier ( ): an agent signifier</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _AR_ 为包围 agent 的 Agent Record。
        1. 返回 _AR_.[[Signifier]]。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-agentcansuspend" type="abstract operation">
      <h1>AgentCanSuspend ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _AR_ 为包围 agent 的 Agent Record。
        1. 返回 _AR_.[[CanBlock]]。
      </emu-alg>
      <emu-note>
        <p>在某些环境中，对某个 agent 来说暂停可能并不合适。例如，在 Web 浏览器环境中，可能不允许暂停文档的主事件处理线程，但允许 worker 的事件处理线程暂停。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-IncrementModuleAsyncEvaluationCount" type="abstract operation">
      <h1>IncrementModuleAsyncEvaluationCount ( ): an integer</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _AR_ 为包围 agent 的 Agent Record。
        1. 令 _count_ 为 _AR_.[[ModuleAsyncEvaluationCount]]。
        1. 设 _AR_.[[ModuleAsyncEvaluationCount]] 为 _count_ + 1。
        1. 返回 _count_。
      </emu-alg>
      <emu-note>
        <p>该值仅用于追踪待定模块之间的相对求值顺序。实现可在没有待定模块时不可观察地将 [[ModuleAsyncEvaluationCount]] 重置为 0。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-agent-clusters">
    <h1>Agent Clusters（代理集群）</h1>

    <p><dfn variants="agent clusters">agent cluster（代理集群）</dfn> 是能够通过操作共享内存进行通信的最大化的一组 agent。</p>

    <emu-note>
      <p>不同 agent 内的程序可能通过未指明的方式共享内存。至少，共享内存可包含 SharedArrayBuffer 的底层存储。</p>

      <p>可能存在只能通过消息传递通信而不能共享内存的 agent；它们永远不在同一个 agent cluster 中。</p>
    </emu-note>

    <p>每个 agent 恰好属于一个 agent cluster。</p>

    <emu-note>
      <p>集群中的 agent 不必在某个时间点全部“活着”。如果 agent <b>A</b> 创建了 agent <b>B</b>，随后 <b>A</b> 终止，而 <b>B</b> 又创建 agent <b>C</b>，如果 <b>A</b> 可以与 <b>B</b> 共享某些内存且 <b>B</b> 可以与 <b>C</b> 共享某些内存，则三个 agent 仍在同一集群。</p>
    </emu-note>

    <p>同一集群内所有 agent 在其各自 Agent Record 的 [[LittleEndian]] 字段上必须具有相同的值。</p>

    <emu-note>
      <p>若集群中不同 agent 的 [[LittleEndian]] 值不同，就难以在多字节数据上使用共享内存。</p>
    </emu-note>

    <p>同一集群内所有 agent 在其 [[IsLockFree1]] 字段上必须具有相同值；[[IsLockFree2]] 字段同理。</p>

    <p>同一集群内所有 agent 在其 [[Signifier]] 字段上必须具有不同值。</p>

    <p>嵌入环境可在 agent 不知情或不配合的情况下停用（停止前向进展）或激活（恢复前向进展）一个 agent。若这样做，不得使集群中某些 agent 长期保持激活而另一些被无限期停用。</p>

    <emu-note>
      <p>上述限制的目的是避免某个 agent 因另一个被停用的 agent 而死锁或饥饿。例如，若一个生命周期独立于任何窗口文档的 HTML shared worker 被允许与这样一个独立文档的 dedicated worker 共享内存，而该文档及其 dedicated worker 被停用时 dedicated worker 持有某个锁（如文档被推入窗口历史），随后 shared worker 尝试获取该锁，那么 shared worker 会被阻塞直到 dedicated worker 被重新激活（如果会的话）。同时其它试图从其它窗口访问该 shared worker 的 worker 会饥饿。</p>

      <p>该限制意味着无法在不属于同一“暂停/唤醒”集体的 agent 之间共享内存。</p>
    </emu-note>

    <p>嵌入环境可以在未提前通知或未获得集群内其它 agent 协作的情况下终止某个 agent。若某 agent 的终止不是其自身或集群内其它 agent 的程序化行为，而是由集群外部因素导致，则嵌入环境必须在两个策略中择一：要么终止该集群所有 agent，要么提供可靠的 API 让集群内 agent 协调，以便至少一个仍存活的成员能够检测到该终止，并且终止数据中包含足以标识被终止 agent 的信息。</p>

    <emu-note>
      <p>此类终止的例子包括：操作系统或用户终止在独立进程中运行的 agent；当按 agent 资源统计显示某 agent 失控时，嵌入环境终止与其它 agent 在同一进程内运行的该 agent。</p>
    </emu-note>

    <p>下列每个规范值以及从它们可传递抵达的值，恰好属于一个 agent cluster：</p>
    <ul>
      <li>candidate execution Record</li>
      <li>Shared Data Block</li>
      <li>WaiterList Record</li>
    </ul>

    <p>在集群中任何 agent 求值任意 ECMAScript 代码之前，集群中所有 agent 的 Agent Record 的 [[CandidateExecution]] 字段被设为初始 candidate execution。初始 candidate execution 是一个空的 candidate execution，其 [[EventsRecords]] 字段是一个 List，其中为每个 agent 含有一个 Agent Events Record，其 [[AgentSignifier]] 字段为该 agent 的 agent signifier，而 [[EventList]] 与 [[AgentSynchronizesWith]] 字段是空 List。</p>

    <emu-note>
      <p>同一 agent cluster 中所有 agent 在其 Agent Record 的 [[CandidateExecution]] 字段共享同一个 candidate execution。candidate execution 是内存模型使用的规范机制。</p>
    </emu-note>

    <emu-note>
      <p>agent cluster 是规范机制，不需对应 ECMAScript 实现中的实际产物。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-forward-progress">
    <h1>Forward Progress（前向进展）</h1>
    <p>某 agent <em>取得前向进展 (make forward progress)</em> 指其执行根据本规范的一次求值步骤。</p>
    <p>当一个 agent 的运行执行上下文同步且无限期地等待外部事件时，该 agent 变为 <em>阻塞 (blocked)</em>。只有 Agent Record 的 [[CanBlock]] 字段为 *true* 的 agent 才能以此方式阻塞。<em>未阻塞 (unblocked)</em> 的 agent 指未阻塞的。</p>

    <p>实现必须确保：</p>
    <ul>
      <li>每个拥有专用执行线程且未阻塞的 agent 最终取得前向进展</li>
      <li>共享一个执行线程的一组 agent 中，总有一个 agent 最终取得前向进展</li>
      <li>一个 agent 不得导致另一个 agent 阻塞，除非通过提供阻塞的显式 API</li>
    </ul>

    <emu-note>
      <p>这一点与内存模型中的活性保证一起，确保所有 ~seq-cst~ 写入最终对所有 agent 可观察。</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-weakref-processing-model">
    <h1>WeakRef 与 FinalizationRegistry 目标的处理模型</h1>

    <emu-clause id="sec-weakref-invariants">
      <h1>目标 (Objectives)</h1>

      <p>本规范不保证任何对象或 symbol 会被垃圾回收。非存活的对象或 symbol 可能在很长时间后才被释放，甚至永不释放。基于此，本规范在描述被垃圾回收触发的行为时使用 “may”。</p>

      <p>WeakRef 与 FinalizationRegistry 的语义基于在特定时间点发生的两个操作：</p>

      <ul>
        <li>
          当调用 `WeakRef.prototype.deref` 时，该引用对象（若未返回 *undefined*）被保持存活，以便后续同步访问也返回相同值。该列表在使用 ClearKeptObjects 抽象操作完成同步工作后被重置。
        </li>

        <li>
          当某个已注册到 FinalizationRegistry 的对象或 symbol 变得不可达后，在同步 ECMAScript 执行完成后，最终可能调用该 FinalizationRegistry 的清理回调。FinalizationRegistry 的清理通过 CleanupFinalizationRegistry 抽象操作执行。
        </li>
      </ul>

      <p>上述两个动作（ClearKeptObjects 或 CleanupFinalizationRegistry）都不得打断同步 ECMAScript 执行。由于宿主可以组合更长的同步 ECMAScript 执行段，本规范将 ClearKeptObjects 与 CleanupFinalizationRegistry 的调度推迟到宿主环境。</p>

      <p>一些 ECMAScript 实现包含在后台（包括 ECMAScript 空闲时）运行的垃圾回收器。让宿主环境调度 CleanupFinalizationRegistry 允许其恢复 ECMAScript 执行以运行 finalizer 工作，可能释放被持有的值，降低整体内存占用。</p>
    </emu-clause>

    <emu-clause id="sec-liveness">
      <h1>存活性 (Liveness)</h1>

      <p>对于一组对象和/或 symbol _S_，相对于 _S_ 的一次 <dfn>假设的 WeakRef-oblivious（弱引用无感）</dfn> 执行是指：任何将其 referent 属于 _S_ 的 WeakRef 的抽象操作 WeakRefDeref 总是返回 *undefined* 的执行。</p>

      <emu-note>
        WeakRef-obliviousness 与 liveness 一起捕获两个概念：其一，WeakRef 本身不会保持其 referent 存活；其二，存活性中的循环不意味着某值存活。具体地，若判定 _v_ 的存活性依赖判定某 WeakRef referent _r_ 的存活性，则 _r_ 的存活性不能假定 _v_ 的存活性，否则是循环论证。
      </emu-note>
      <emu-note>
        WeakRef-obliviousness 针对对象或 symbol 的集合而不是单个值定义，以处理循环。若对单个值定义，则一个循环中的 WeakRef referent 会被视为存活，即便其身份仅通过循环中其它 WeakRef referent 被观察。
      </emu-note>
      <emu-note>
        口语化地，若包含某个对象或 symbol 的每个集合都是存活的，则我们说该对象或 symbol 存活。
      </emu-note>

      <p>在求值任意时刻，若下列任一条件成立，则对象和/或 symbol 集合 _S_ 被视为 <dfn>live（存活）</dfn>：</p>

      <ul>
        <li>
          _S_ 中任一元素包含于任一 agent 的 [[KeptAlive]] List 中。
        </li>
        <li>
          存在相对于 _S_ 的某个未来合法的假设 WeakRef-oblivious 执行，在其中观察到 _S_ 中任一值的身份。
        </li>
      </ul>
      <emu-note>
        第二个条件旨在捕获这样的直觉：若一个值的身份可通过非 WeakRef 手段观察到，则该值是存活的。值的身份可通过严格相等比较或作为 Map 的键被观察到。
      </emu-note>
      <emu-note>
        <p>对象或 symbol 出现在某字段、内部槽或属性中并不意味着该值存活。例如若该值从未被返回给程序，则不可被观察。</p>

        <p>这适用于 WeakMap 的键、WeakSet 的成员，以及 FinalizationRegistry Cell 记录的 [[WeakRefTarget]] 与 [[UnregisterToken]] 字段。</p>

        <p>上述定义意味着：若 WeakMap 中的某键不存活，则其对应的值也不必定存活。</p>
      </emu-note>
      <emu-note>
        Liveness 是保证引擎不得清空哪些 WeakRef 的下界。此处定义的 liveness 是不可判定的。实际中，引擎使用 reachability 等保守近似，存在较大实现自由度。
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-execution">
      <h1>执行 (Execution)</h1>

      <p>在任意时刻，若一组对象和/或 symbol _S_ 不存活，ECMAScript 实现可原子地执行以下步骤：</p>

      <emu-alg>
        1. 对于 _S_ 的每个元素 _value_，执行
          1. 对每个 WeakRef _ref_（_ref_.[[WeakRefTarget]] 为 _value_），执行
            1. 设 _ref_.[[WeakRefTarget]] 为 ~empty~。
          1. 对每个 FinalizationRegistry _fg_（_fg_.[[Cells]] 含有记录 _cell_ 且 _cell_.[[WeakRefTarget]] 为 _value_），执行
            1. 设 _cell_.[[WeakRefTarget]] 为 ~empty~。
            1. 可选：执行 HostEnqueueFinalizationRegistryCleanupJob(_fg_)。
          1. 对每个 WeakMap _map_（_map_.[[WeakMapData]] 含有记录 _r_ 且 _r_.[[Key]] 为 _value_），执行
            1. 设 _r_.[[Key]] 为 ~empty~。
            1. 设 _r_.[[Value]] 为 ~empty~。
          1. 对每个 WeakSet _set_（_set_.[[WeakSetData]] 含有 _value_），执行
            1. 将 _set_.[[WeakSetData]] 中值为 _value_ 的元素替换为值为 ~empty~ 的元素。
      </emu-alg>

      <emu-note>
        <p>结合存活性的定义，本条款规定了实现可针对 WeakRef 应用的优化。</p>

        <p>可能存在在不观察对象身份的情况下访问对象的情形。诸如死变量消除、对非逃逸对象属性的标量替换等优化在对象身份未被观察时允许进行。因此，这些优化可在可观察范围内清空指向此类对象的 WeakRef。</p>

        <p>另一方面，若对象身份可被观察且该对象位于某 WeakRef 的 [[WeakRefTarget]] 内部槽中，则诸如重新物化（rematerialization）等会在可观察层面清空该 WeakRef 的优化被禁止。</p>

        <p>由于调用 HostEnqueueFinalizationRegistryCleanupJob 是可选的，注册在 FinalizationRegistry 中的对象不必定保持该 FinalizationRegistry 存活。实现可基于任何理由省略 FinalizationRegistry 回调，例如 FinalizationRegistry 自身变为“死”，或应用正在关闭。</p>
      </emu-note>
      <emu-note>
        <p>实现不要求针对最大的不存活对象或 symbol 集合清空 WeakRef。</p>
        <p>若实现选择一个不存活集合 _S_ 来清空 WeakRef，此定义要求它同时清空 _S_ 中所有值的 WeakRef。换言之，实现不能只清空指向值 _v_ 的 WeakRef 而保留其它可能在执行中观察到 _v_ 的 WeakRef 未清空。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-weakref-host-hooks">
      <h1>宿主挂钩 (Host Hooks)</h1>

      <emu-clause id="sec-host-cleanup-finalization-registry" type="host-defined abstract operation">
        <h1>
          HostEnqueueFinalizationRegistryCleanupJob (
            _finalizationRegistry_: a FinalizationRegistry,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <p>令 _cleanupJob_ 为一个无参数的新 Job 抽象闭包，它捕获 _finalizationRegistry_ 并在被调用时执行以下步骤：</p>
        <emu-alg>
          1. 令 _cleanupResult_ 为 Completion(CleanupFinalizationRegistry(_finalizationRegistry_))。
          1. 若 _cleanupResult_ 为异常完成，执行任意宿主定义步骤以报告错误。
          1. 返回 ~unused~。
        </emu-alg>
        <p>HostEnqueueFinalizationRegistryCleanupJob 的实现将 _cleanupJob_ 安排于未来某个时间（若可能）执行，并且还必须符合 <emu-xref href="#sec-jobs"></emu-xref> 中的要求。</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-clear-kept-objects" type="abstract operation">
    <h1>ClearKeptObjects ( ): ~unused~</h1>
    <dl class="header">
      <dt>description</dt>
      <dd>期望 ECMAScript 实现在一次同步的 ECMAScript 执行序列完成后调用 ClearKeptObjects。</dd>
    </dl>
    <emu-alg>
      1. 令 _agentRecord_ 为包围 agent 的 Agent Record。
      1. 设 _agentRecord_.[[KeptAlive]] 为一个新的空 List。
      1. 返回 ~unused~。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-addtokeptobjects" type="abstract operation">
    <h1>
      AddToKeptObjects (
        _value_: an Object or a Symbol,
      ): ~unused~
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. 令 _agentRecord_ 为包围 agent 的 Agent Record。
      1. 将 _value_ 追加到 _agentRecord_.[[KeptAlive]]。
      1. 返回 ~unused~。
    </emu-alg>
    <emu-note>
      当抽象操作 AddToKeptObjects 以某目标对象或 symbol 被调用时，它把该目标加入一个列表；在调用 ClearKeptObjects 之前，该列表会对目标保持强引用。
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-cleanup-finalization-registry" type="abstract operation">
    <h1>
      CleanupFinalizationRegistry (
        _finalizationRegistry_: a FinalizationRegistry,
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. 断言：_finalizationRegistry_ 具有 [[Cells]] 与 [[CleanupCallback]] 内部槽。
      1. 令 _callback_ 为 _finalizationRegistry_.[[CleanupCallback]]。
      1. 当 _finalizationRegistry_.[[Cells]] 含有某记录 _cell_ 且 _cell_.[[WeakRefTarget]] 为 ~empty~ 时，实现可以执行以下步骤：
        1. 任选一个这样的 _cell_。
        1. 从 _finalizationRegistry_.[[Cells]] 中移除 _cell_。
        1. 执行 ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »)。
      1. 返回 ~unused~。
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-canbeheldweakly" type="abstract operation">
    <h1>
      CanBeHeldWeakly (
        _v_: an ECMAScript language value,
      ): a Boolean
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>当且仅当 _v_ 适合作为弱引用使用时返回 *true*。只有适合作为弱引用使用的值才能成为 WeakMap 的键、WeakSet 的元素、WeakRef 的 target，或 FinalizationRegistry 的某个 target。</dd>
    </dl>
    <emu-alg>
      1. 若 _v_ 是一个 Object，返回 *true*。
      1. 若 _v_ 是一个 Symbol 且 KeyForSymbol(_v_) 为 *undefined*，返回 *true*。
      1. 返回 *false*。
    </emu-alg>
    <emu-note>
      <p>没有 <emu-xref href="#sec-identity">语言身份 (language identity)</emu-xref> 的语言值可以在没有先前引用的情况下被重新生成，不适合作为弱引用。由 <emu-xref href="#sec-symbol.for">Symbol.for</emu-xref> 产生的 Symbol 值与其他 Symbol 不同，它不具有语言身份，因此也不适合作为弱引用。<emu-xref href="#sec-well-known-symbols">Well-known symbols</emu-xref> 很可能永远不会被回收，但由于其数量有限，仍被视为适合用作弱引用，可通过多种实现手段管理。然而，在一个存活的 WeakMap 中与某个 well-known symbol 关联的任何值都不太可能被回收，可能在实现中“泄漏”内存资源。</p>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>普通与特异（Exotic）对象的行为 (Ordinary and Exotic Objects Behaviours)</h1>

  <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
    <h1>普通对象的内部方法与内部槽 (Ordinary Object Internal Methods and Internal Slots)</h1>
    <p>所有普通对象都有名为 [[Prototype]] 的内部槽。该内部槽的值要么是 *null* 要么是一个对象，用于实现继承。假设一个名为 _P_ 的属性在普通对象 _O_ 上缺失，但存在于其 [[Prototype]] 对象上。如果 _P_ 指向 [[Prototype]] 对象上的数据属性，则 _O_ 在“取值”访问（get access）时继承它，使其表现得仿佛 _P_ 是 _O_ 的一个属性。如果 _P_ 指向 [[Prototype]] 对象上的可写数据属性，在 _O_ 上对 _P_ 进行“设值”访问（set access）会在 _O_ 上创建一个名为 _P_ 的新数据属性。如果 _P_ 指向 [[Prototype]] 对象上的不可写数据属性，在 _O_ 上对 _P_ 的设值访问会失败。如果 _P_ 指向 [[Prototype]] 对象上的访问器属性（accessor property），则该访问器在 _O_ 上同时被继承用于 get 与 set 访问。</p>
    <p>每个普通对象都有一个布尔值内部槽 [[Extensible]]，用于满足 <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 中规定的与可扩展性相关的内部方法不变式。也就是说，一旦对象的 [[Extensible]] 内部槽被设为 *false*，就不再可能向该对象添加属性、修改该对象 [[Prototype]] 内部槽的值，或随后将 [[Extensible]] 的值重新改为 *true*。</p>
    <p>在下面的算法描述中，假设 _O_ 是一个普通对象，_P_ 是一个属性键值，_V_ 是任意 ECMAScript 语言值，_Desc_ 是一个 Property Descriptor 记录。</p>
    <p>每个普通对象内部方法委派给一个同名的抽象操作。如果该抽象操作依赖另一个内部方法，那么会在 _O_ 上调用该内部方法，而不是直接调用同名的抽象操作。这些语义确保当普通对象的内部方法应用到特异（exotic）对象时，被重写的内部方法能够被调用。</p>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): 一个正常完成，包含一个 Object 或 *null*</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryGetPrototypeOf(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinarygetprototypeof" type="abstract operation">
        <h1>
          OrdinaryGetPrototypeOf (
            _O_: an Object,
          ): an Object or *null*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 _O_.[[Prototype]]。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): 一个正常完成，包含一个 Boolean
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinarySetPrototypeOf(_O_, _V_)。
      </emu-alg>

      <emu-clause id="sec-ordinarysetprototypeof" type="abstract operation">
        <h1>
          OrdinarySetPrototypeOf (
            _O_: an Object,
            _V_: an Object or *null*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _current_ 为 _O_.[[Prototype]]。
          1. 若 SameValue(_V_, _current_) 为 *true*，返回 *true*。
          1. 令 _extensible_ 为 _O_.[[Extensible]]。
          1. 若 _extensible_ 为 *false*，返回 *false*。
          1. 令 _p_ 为 _V_。
          1. 令 _done_ 为 *false*。
          1. [id="step-ordinarysetprototypeof-loop"] 当 _done_ 为 *false* 重复，
            1. 若 _p_ 为 *null*，则
              1. 设 _done_ 为 *true*。
            1. 否则若 SameValue(_p_, _O_) 为 *true*，则
              1. 返回 *false*。
            1. 否则，
              1. 若 _p_.[[GetPrototypeOf]] 不是 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof"></emu-xref> 中定义的普通对象内部方法，设 _done_ 为 *true*。
              1. 否则，将 _p_ 设为 _p_.[[Prototype]]。
          1. 设 _O_.[[Prototype]] 为 _V_。
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>步骤 <emu-xref href="#step-ordinarysetprototypeof-loop"></emu-xref> 中的循环保证：任何仅包含使用普通对象定义之 [[GetPrototypeOf]] 和 [[SetPrototypeOf]] 的对象的原型链中不会出现循环。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): 一个正常完成，包含一个 Boolean</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryIsExtensible(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryisextensible" type="abstract operation">
        <h1>
          OrdinaryIsExtensible (
            _O_: an Object,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 _O_.[[Extensible]]。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): 一个正常完成，包含 *true*</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryPreventExtensions(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinarypreventextensions" type="abstract operation">
        <h1>
          OrdinaryPreventExtensions (
            _O_: an Object,
          ): *true*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 将 _O_.[[Extensible]] 设为 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): 一个正常完成，包含一个 Property Descriptor 或 *undefined*
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryGetOwnProperty(_O_, _P_)。
      </emu-alg>

      <emu-clause id="sec-ordinarygetownproperty" type="abstract operation">
        <h1>
          OrdinaryGetOwnProperty (
            _O_: an Object,
            _P_: a property key,
          ): a Property Descriptor or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _O_ 不存在键为 _P_ 的自身属性，返回 *undefined*。
          1. 令 _D_ 为一个新建的无字段 Property Descriptor。
          1. 令 _X_ 为 _O_ 的键为 _P_ 的自身属性。
          1. 若 _X_ 是数据属性，则
            1. 设 _D_.[[Value]] 为 _X_ 的 [[Value]] 特性的值。
            1. 设 _D_.[[Writable]] 为 _X_ 的 [[Writable]] 特性的值。
          1. 否则，
            1. 断言：_X_ 是访问器属性。
            1. 设 _D_.[[Get]] 为 _X_ 的 [[Get]] 特性的值。
            1. 设 _D_.[[Set]] 为 _X_ 的 [[Set]] 特性的值。
          1. 设 _D_.[[Enumerable]] 为 _X_ 的 [[Enumerable]] 特性的值。
          1. 设 _D_.[[Configurable]] 为 _X_ 的 [[Configurable]] 特性的值。
          1. 返回 _D_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)。
      </emu-alg>

      <emu-clause id="sec-ordinarydefineownproperty" type="abstract operation">
        <h1>
          OrdinaryDefineOwnProperty (
            _O_: an Object,
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _current_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 令 _extensible_ 为 ? IsExtensible(_O_)。
          1. 返回 ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iscompatiblepropertydescriptor" type="abstract operation">
        <h1>
          IsCompatiblePropertyDescriptor (
            _Extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _Current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 返回 ValidateAndApplyPropertyDescriptor(*undefined*, *""*, _Extensible_, _Desc_, _Current_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateandapplypropertydescriptor" type="abstract operation">
        <h1>
          ValidateAndApplyPropertyDescriptor (
            _O_: an Object or *undefined*,
            _P_: a property key,
            _extensible_: a Boolean,
            _Desc_: a Property Descriptor,
            _current_: a Property Descriptor or *undefined*,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>当且仅当 _Desc_ 可以在指定 _extensibility_ 与当前属性 _current_ 的条件下，作为某对象的属性（维护 <emu-xref href="#sec-invariants-of-the-essential-internal-methods">不变式</emu-xref>）被应用时，返回 *true*。当应用可行且 _O_ 不为 *undefined* 时，会对名为 _P_ 的属性执行（必要时创建）。</dd>
        </dl>
        <emu-alg>
          1. 断言：_P_ 是一个属性键。
          1. 若 _current_ 为 *undefined*，则
            1. 若 _extensible_ 为 *false*，返回 *false*。
            1. 若 _O_ 为 *undefined*，返回 *true*。
            1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，则
              1. 在对象 _O_ 上创建名为 _P_ 的自身访问器属性，其 [[Get]]、[[Set]]、[[Enumerable]]、[[Configurable]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 否则，
              1. 在对象 _O_ 上创建名为 _P_ 的自身数据属性，其 [[Value]]、[[Writable]]、[[Enumerable]]、[[Configurable]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 返回 *true*。
          1. 断言：_current_ 为一个完全填充的 Property Descriptor。
          1. 若 _Desc_ 不含任何字段，返回 *true*。
          1. 若 _current_.[[Configurable]] 为 *false*，则
            1. 若 _Desc_ 含 [[Configurable]] 且 _Desc_.[[Configurable]] 为 *true*，返回 *false*。
            1. 若 _Desc_ 含 [[Enumerable]] 且 _Desc_.[[Enumerable]] 不等于 _current_.[[Enumerable]]，返回 *false*。
            1. 若 IsGenericDescriptor(_Desc_) 为 *false* 且 IsAccessorDescriptor(_Desc_) 不等于 IsAccessorDescriptor(_current_)，返回 *false*。
            1. 若 IsAccessorDescriptor(_current_) 为 *true*，则
              1. 若 _Desc_ 含 [[Get]] 且 SameValue(_Desc_.[[Get]], _current_.[[Get]]) 为 *false*，返回 *false*。
              1. 若 _Desc_ 含 [[Set]] 且 SameValue(_Desc_.[[Set]], _current_.[[Set]]) 为 *false*，返回 *false*。
            1. 否则若 _current_.[[Writable]] 为 *false*，则
              1. 若 _Desc_ 含 [[Writable]] 且 _Desc_.[[Writable]] 为 *true*，返回 *false*。
              1. NOTE: SameValue 对 *NaN* 返回 *true*（可能通过其他方式区分）。此处返回可确保 _O_ 任何已有属性保持不变。
              1. 若 _Desc_ 含 [[Value]] 字段，返回 SameValue(_Desc_.[[Value]], _current_.[[Value]])。
          1. 若 _O_ 不为 *undefined*，则
            1. 若 IsDataDescriptor(_current_) 为 *true* 且 IsAccessorDescriptor(_Desc_) 为 *true*，则
              1. 若 _Desc_ 含 [[Configurable]]，令 _configurable_ 为 _Desc_.[[Configurable]]；否则令 _configurable_ 为 _current_.[[Configurable]]。
              1. 若 _Desc_ 含 [[Enumerable]]，令 _enumerable_ 为 _Desc_.[[Enumerable]]；否则令 _enumerable_ 为 _current_.[[Enumerable]]。
              1. 用一个访问器属性替换对象 _O_ 上名为 _P_ 的属性，其 [[Configurable]]、[[Enumerable]] 分别设为 _configurable_、_enumerable_，其 [[Get]]、[[Set]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 否则若 IsAccessorDescriptor(_current_) 为 *true* 且 IsDataDescriptor(_Desc_) 为 *true*，则
              1. 若 _Desc_ 含 [[Configurable]]，令 _configurable_ 为 _Desc_.[[Configurable]]；否则令 _configurable_ 为 _current_.[[Configurable]]。
              1. 若 _Desc_ 含 [[Enumerable]]，令 _enumerable_ 为 _Desc_.[[Enumerable]]；否则令 _enumerable_ 为 _current_.[[Enumerable]]。
              1. 用一个数据属性替换对象 _O_ 上名为 _P_ 的属性，其 [[Configurable]]、[[Enumerable]] 分别设为 _configurable_、_enumerable_，其 [[Value]]、[[Writable]] 特性若 _Desc_ 含该字段则取其值，否则取该特性的 <emu-xref href="#table-object-property-attributes">默认值</emu-xref>。
            1. 否则，
              1. 对 _Desc_ 的每个字段，将对象 _O_ 上名为 _P_ 的属性对应特性设为该字段的值。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinaryHasProperty(_O_, _P_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryhasproperty" type="abstract operation">
        <h1>
          OrdinaryHasProperty (
            _O_: an Object,
            _P_: a property key,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _hasOwn_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _hasOwn_ 不为 *undefined*，返回 *true*。
          1. 令 _parent_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
          1. 若 _parent_ 不为 *null*，则
            1. 返回 ? <emu-meta effects="user-code">_parent_.[[HasProperty]]</emu-meta>(_P_)。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): 一个正常完成（包含 ECMAScript 语言值）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>

      <emu-alg>
        1. 返回 ? OrdinaryGet(_O_, _P_, _Receiver_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryget" type="abstract operation">
        <h1>
          OrdinaryGet (
            _O_: an Object,
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _desc_ 为 *undefined*，则
            1. 令 _parent_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
            1. 若 _parent_ 为 *null*，返回 *undefined*。
            1. 返回 ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_)。
          1. 若 IsDataDescriptor(_desc_) 为 *true*，返回 _desc_.[[Value]]。
          1. 断言：IsAccessorDescriptor(_desc_) 为 *true*。
          1. 令 _getter_ 为 _desc_.[[Get]]。
          1. 若 _getter_ 为 *undefined*，返回 *undefined*。
          1. 返回 ? Call(_getter_, _Receiver_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinarySet(_O_, _P_, _V_, _Receiver_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryset" type="abstract operation">
        <h1>
          OrdinarySet (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 令 _ownDesc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 返回 ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarysetwithowndescriptor" type="abstract operation">
        <h1>
          OrdinarySetWithOwnDescriptor (
            _O_: an Object,
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
            _ownDesc_: a Property Descriptor or *undefined*,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 若 _ownDesc_ 为 *undefined*，则
            1. 令 _parent_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
            1. 若 _parent_ 不为 *null*，则
              1. 返回 ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_)。
            1. 否则，
              1. 将 _ownDesc_ 设为 PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
          1. 若 IsDataDescriptor(_ownDesc_) 为 *true*，则
            1. 若 _ownDesc_.[[Writable]] 为 *false*，返回 *false*。
            1. 若 _Receiver_ 不是 Object，返回 *false*。
            1. 令 _existingDescriptor_ 为 ? <emu-meta effects="user-code">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_)。
            1. 若 _existingDescriptor_ 不为 *undefined*，则
              1. 若 IsAccessorDescriptor(_existingDescriptor_) 为 *true*，返回 *false*。
              1. 若 _existingDescriptor_.[[Writable]] 为 *false*，返回 *false*。
              1. 令 _valueDesc_ 为 PropertyDescriptor { [[Value]]: _V_ }。
              1. 返回 ? <emu-meta effects="user-code">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_)。
            1. 否则，
              1. 断言：_Receiver_ 目前没有属性 _P_。
              1. 返回 ? CreateDataProperty(_Receiver_, _P_, _V_)。
          1. 断言：IsAccessorDescriptor(_ownDesc_) 为 *true*。
          1. 令 _setter_ 为 _ownDesc_.[[Set]]。
          1. 若 _setter_ 为 *undefined*，返回 *false*。
          1. 执行 ? Call(_setter_, _Receiver_, « _V_ »)。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): 一个正常完成（包含 Boolean）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? OrdinaryDelete(_O_, _P_)。
      </emu-alg>

      <emu-clause id="sec-ordinarydelete" type="abstract operation">
        <h1>
          OrdinaryDelete (
            _O_: an Object,
            _P_: a property key,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _desc_ 为 *undefined*，返回 *true*。
          1. 若 _desc_.[[Configurable]] 为 *true*，则
            1. 从 _O_ 中移除名为 _P_ 的自身属性。
            1. 返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 一个正常完成，包含一个属性键 List</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个普通对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 返回 OrdinaryOwnPropertyKeys(_O_)。
      </emu-alg>

      <emu-clause id="sec-ordinaryownpropertykeys" type="abstract operation">
        <h1>
          OrdinaryOwnPropertyKeys (
            _O_: an Object,
          ): a List of property keys
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. 令 _keys_ 为一个新的空 List。
          1. 对 _O_ 的每个自身属性键 _P_，若 _P_ 是数组索引，按数字索引升序：
            1. 将 _P_ 追加至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_，若 _P_ 是 String 且不是数组索引，按属性创建的时间顺序：
            1. 将 _P_ 追加至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_，若 _P_ 是 Symbol，按属性创建时间顺序：
            1. 将 _P_ 追加至 _keys_。
          1. 返回 _keys_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ordinaryobjectcreate" type="abstract operation" oldids="sec-objectcreate">
      <h1>
        OrdinaryObjectCreate (
          _proto_: an Object or *null*,
          optional _additionalInternalSlotsList_: a List of names of internal slots,
        ): an Object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于指定在运行时创建新的普通对象。_additionalInternalSlotsList_ 包含必须定义为该对象一部分的额外内部槽名称（除 [[Prototype]] 与 [[Extensible]] 之外）。若未提供 _additionalInternalSlotsList_，则使用一个新的空 List。</dd>
      </dl>
      <emu-alg>
        1. 令 _internalSlotsList_ 为 « [[Prototype]], [[Extensible]] »。
        1. 若 _additionalInternalSlotsList_ 存在，将 _internalSlotsList_ 设为 _internalSlotsList_ 与 _additionalInternalSlotsList_ 的列表连接。
        1. 令 _O_ 为 MakeBasicObject(_internalSlotsList_)。
        1. 将 _O_.[[Prototype]] 设为 _proto_。
        1. 返回 _O_。
      </emu-alg>

      <emu-note>
        <p>尽管 OrdinaryObjectCreate 除调用 MakeBasicObject 外做的事情很少，使用它明确传达了要创建一个“普通”对象而非特异对象的意图。因此，在本规范中，它不会被任何随后修改对象内部方法、从而使结果变为“非普通”的算法调用。创建特异对象的操作会直接调用 MakeBasicObject。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-ordinarycreatefromconstructor" type="abstract operation">
      <h1>
        OrdinaryCreateFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
          optional _internalSlotsList_: a List of names of internal slots,
        ): either a normal completion containing an Object or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>它创建一个普通对象，其 [[Prototype]] 值取自构造函数的 *"prototype"* 属性（若存在）。否则使用由 _intrinsicDefaultProto_ 命名的内在对象作为 [[Prototype]]。_internalSlotsList_ 包含需要定义的额外内部槽名称。若未提供 _internalSlotsList_，则使用新的空 List。</dd>
      </dl>
      <emu-alg>
        1. 断言：_intrinsicDefaultProto_ 是本规范对某内在对象的名称；对应对象必须是用作 [[Prototype]] 值的内在对象。
        1. 令 _proto_ 为 ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_)。
        1. 若 _internalSlotsList_ 存在，令 _slotsList_ 为 _internalSlotsList_。
        1. 否则，令 _slotsList_ 为一个新的空 List。
        1. 返回 OrdinaryObjectCreate(_proto_, _slotsList_)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-getprototypefromconstructor" type="abstract operation">
      <h1>
        GetPrototypeFromConstructor (
          _constructor_: a function object,
          _intrinsicDefaultProto_: a String,
        ): either a normal completion containing an Object or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>决定与特定构造函数对应之对象应使用的 [[Prototype]] 值。该值若构造函数具有 *"prototype"* 属性则从中取得，否则使用由 _intrinsicDefaultProto_ 命名的内在对象作为 [[Prototype]]。</dd>
      </dl>
      <emu-alg>
        1. 断言：_intrinsicDefaultProto_ 是本规范对某内在对象的名称；对应对象必须是用作对象 [[Prototype]] 值的内在对象。
        1. 令 _proto_ 为 ? Get(_constructor_, *"prototype"*)。
        1. 若 _proto_ 不是 Object，则
          1. 令 _realm_ 为 ? GetFunctionRealm(_constructor_)。
          1. 将 _proto_ 设为 _realm_ 中名为 _intrinsicDefaultProto_ 的内在对象。
        1. 返回 _proto_。
      </emu-alg>
      <emu-note>
        <p>若 _constructor_ 未提供 [[Prototype]] 值，则使用的默认值取自 _constructor_ 函数所属的 realm，而非当前运行执行上下文。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-requireinternalslot" type="abstract operation">
      <h1>
        RequireInternalSlot (
          _O_: an ECMAScript language value,
          _internalSlot_: an internal slot name,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>除非 _O_ 是一个 Object 且拥有给定内部槽，否则抛出异常。</dd>
      </dl>
      <emu-alg>
        1. 若 _O_ 不是 Object，抛出 *TypeError* 异常。
        1. 若 _O_ 不具有内部槽 _internalSlot_，抛出 *TypeError* 异常。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript 函数对象 (ECMAScript Function Objects)</h1>
    <p>ECMAScript 函数对象封装了带参数的、闭包于某词法环境之上的 ECMAScript 代码，并支持对该代码的动态求值。一个 ECMAScript 函数对象是一个普通对象，具有与其它普通对象相同的内部槽与内部方法。ECMAScript 函数对象的代码可以是严格模式代码（<emu-xref href="#sec-strict-mode-code"></emu-xref>）或非严格代码。其代码为严格模式代码的 ECMAScript 函数对象称为 <dfn id="strict-function" variants="strict functions">严格函数 (strict function)</dfn>。其代码不是严格模式代码的称为 <dfn id="non-strict-function" variants="non-strict functions">非严格函数 (non-strict function)</dfn>。</p>
    <p>除 [[Extensible]] 与 [[Prototype]] 之外，ECMAScript 函数对象还具有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="ECMAScript 函数对象的内部槽 (Internal Slots of ECMAScript Function Objects)" oldids="table-27">
      <table>
        <thead>
          <tr>
            <th>
              内部槽 (Internal Slot)
            </th>
            <th>
              类型 (Type)
            </th>
            <th>
              描述 (Description)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[Environment]]
          </td>
          <td>
            an Environment Record
          </td>
          <td>
            函数闭包所捕获的 Environment Record。作为求值该函数代码时的外层环境。
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateEnvironment]]
          </td>
          <td>
            a PrivateEnvironment Record or *null*
          </td>
          <td>
            函数闭包所捕获的 Private Names 的 PrivateEnvironment Record。若函数在语法上不被包含于 class 内则为 *null*。在求值该函数代码时，作为内部类的外层 PrivateEnvironment。
          </td>
        </tr>
        <tr>
          <td>
            [[FormalParameters]]
          </td>
          <td>
            a Parse Node
          </td>
          <td>
            定义函数形式参数列表的源文本根解析节点。
          </td>
        </tr>
        <tr>
          <td>
            [[ECMAScriptCode]]
          </td>
          <td>
            a Parse Node
          </td>
          <td>
            定义函数函数体的源文本根解析节点。
          </td>
        </tr>
        <tr>
          <td>
            [[ConstructorKind]]
          </td>
          <td>
            ~base~ or ~derived~
          </td>
          <td>
            指示该函数是否为派生类构造器。
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            a Realm Record
          </td>
          <td>
            函数被创建时所在的 realm；在求值该函数时提供所有被访问的内在对象。
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            a Script Record or a Module Record
          </td>
          <td>
            函数被创建所在的脚本或模块。
          </td>
        </tr>
        <tr>
          <td>
            [[ThisMode]]
          </td>
          <td>
            ~lexical~, ~strict~, or ~global~
          </td>
          <td>
            定义在函数形式参数与函数体内 `this` 引用如何解释。~lexical~ 表示 `this` 引用词法包围函数的 *this* 值。~strict~ 表示使用调用该函数时提供的 *this* 值而不加修改。~global~ 表示 *undefined* 或 *null* 的 *this* 值被解释为对全局对象的引用，其它 *this* 值会先传入 ToObject。
          </td>
        </tr>
        <tr>
          <td>
            [[Strict]]
          </td>
          <td>
            a Boolean
          </td>
          <td>
            若该函数为严格函数则为 *true*，若为非严格函数则为 *false*。
          </td>
        </tr>
        <tr>
          <td>
            [[HomeObject]]
          </td>
          <td>
            an Object
          </td>
          <td>
            若函数使用 `super`，此槽为其 `super` 属性查找起始的对象（通过该对象的 [[GetPrototypeOf]]）。
          </td>
        </tr>
        <tr>
          <td>
            [[SourceText]]
          </td>
          <td>
            a sequence of Unicode code points
          </td>
          <td>
            定义该函数的<emu-xref href="#sec-source-text">源文本</emu-xref>。
          </td>
        </tr>
        <tr>
          <td>
            [[Fields]]
          </td>
          <td>
            a List of ClassFieldDefinition Records
          </td>
          <td>
            若该函数是一个 class，则此列表为该类的非静态字段及其初始化器的记录。
          </td>
        </tr>
        <tr>
          <td>
            [[PrivateMethods]]
          </td>
          <td>
            a List of PrivateElements
          </td>
          <td>
            若该函数是一个 class，则此列表表示该类的非静态私有方法与访问器。
          </td>
        </tr>
        <tr>
          <td>
            [[ClassFieldInitializerName]]
          </td>
          <td>
            a String, a Symbol, a Private Name, or ~empty~
          </td>
          <td>
            若函数作为类字段的初始化器创建，则为对该字段进行 NamedEvaluation 所使用的名称；否则为 ~empty~。
          </td>
        </tr>
        <tr>
          <td>
            [[IsClassConstructor]]
          </td>
          <td>
            a Boolean
          </td>
          <td>
            指示该函数是否为类构造器。（若为 *true*，调用其 [[Call]] 将立即抛出 *TypeError* 异常。）
          </td>
        </tr>
      </table>
    </emu-table>
    <p>所有 ECMAScript 函数对象都具有此处定义的 [[Call]] 内部方法。作为构造器的 ECMAScript 函数还额外具有 [[Construct]] 内部方法。</p>

    <emu-clause id="sec-ecmascript-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): 一个正常完成（包含 ECMAScript 语言值）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个 ECMAScript 函数对象 _F_</dd>
      </dl>
      <emu-alg>
        1. 令 _callerContext_ 为当前运行执行上下文。
        1. 令 _calleeContext_ 为 PrepareForOrdinaryCall(_F_, *undefined*)。
        1. 断言：_calleeContext_ 现在是运行执行上下文。
        1. 若 _F_.[[IsClassConstructor]] 为 *true*，则
          1. 令 _error_ 为一个新创建的 *TypeError* 对象。
          1. NOTE: _error_ 在 _calleeContext_ 中、使用 _F_ 关联的 Realm Record 创建。
          1. 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
          1. 返回 ThrowCompletion(_error_)。
        1. 执行 OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_)。
        1. 令 _result_ 为 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_))。
        1. [id="step-call-pop-context-stack"] 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
        1. 若 _result_ 是一个 return completion，返回 _result_.[[Value]]。
        1. 断言：_result_ 是一个 throw completion。
        1. 返回 ? _result_。
      </emu-alg>
      <emu-note>
        <p>当在步骤 <emu-xref href="#step-call-pop-context-stack"></emu-xref> 中把 _calleeContext_ 自执行上下文栈移除时，若它被一个可访问的 Generator 挂起并保留以供后续恢复，则不得销毁它。</p>
      </emu-note>

      <emu-clause id="sec-prepareforordinarycall" type="abstract operation">
        <h1>
          PrepareForOrdinaryCall (
            _F_: an ECMAScript function object,
            _newTarget_: an Object or *undefined*,
          ): an execution context
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _callerContext_ 为当前运行执行上下文。
          1. 令 _calleeContext_ 为一个新的 ECMAScript 代码执行上下文。
          1. 将 _calleeContext_ 的 Function 设为 _F_。
          1. 令 _calleeRealm_ 为 _F_.[[Realm]]。
          1. 将 _calleeContext_ 的 Realm 设为 _calleeRealm_。
          1. 将 _calleeContext_ 的 ScriptOrModule 设为 _F_.[[ScriptOrModule]]。
          1. 令 _localEnv_ 为 NewFunctionEnvironment(_F_, _newTarget_)。
          1. 将 _calleeContext_ 的 LexicalEnvironment 设为 _localEnv_。
          1. 将 _calleeContext_ 的 VariableEnvironment 设为 _localEnv_。
          1. 将 _calleeContext_ 的 PrivateEnvironment 设为 _F_.[[PrivateEnvironment]]。
          1. 若 _callerContext_ 尚未被挂起，则挂起 _callerContext_。
          1. 将 _calleeContext_ 压入执行上下文栈；_calleeContext_ 现在是运行执行上下文。
          1. NOTE: 之后产生的任何异常对象与 _calleeRealm_ 关联。
          1. 返回 _calleeContext_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallbindthis" type="abstract operation">
        <h1>
          OrdinaryCallBindThis (
            _F_: an ECMAScript function object,
            _calleeContext_: an execution context,
            _thisArgument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _thisMode_ 为 _F_.[[ThisMode]]。
          1. 若 _thisMode_ 为 ~lexical~，返回 ~unused~。
          1. 令 _calleeRealm_ 为 _F_.[[Realm]]。
          1. 令 _localEnv_ 为 _calleeContext_ 的 LexicalEnvironment。
          1. 若 _thisMode_ 为 ~strict~，则
            1. 令 _thisValue_ 为 _thisArgument_。
          1. 否则，
            1. 若 _thisArgument_ 是 *undefined* 或 *null*，则
              1. 令 _globalEnv_ 为 _calleeRealm_.[[GlobalEnv]]。
              1. 断言：_globalEnv_ 是一个 Global Environment Record。
              1. 令 _thisValue_ 为 _globalEnv_.[[GlobalThisValue]]。
            1. 否则，
              1. 令 _thisValue_ 为 ! ToObject(_thisArgument_)。
              1. NOTE: ToObject 使用 _calleeRealm_ 产生包装对象。
          1. 断言：_localEnv_ 是一个 Function Environment Record。
          1. 断言：下一步不会返回一个 abrupt completion，因为 _localEnv_.[[ThisBindingStatus]] 不是 ~initialized~。
          1. 执行 ! BindThisValue(_localEnv_, _thisValue_)。
          1. 返回 ~unused~。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-evaluatebody" type="sdo">
        <h1>
          运行时语义：EvaluateBody (
            _functionObject_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateFunctionBody of |FunctionBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateConciseBody of |ConciseBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateGeneratorBody of |GeneratorBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          AsyncGeneratorBody : FunctionBody
        </emu-grammar>
        <emu-alg>
          1. Return ? EvaluateAsyncGeneratorBody of |AsyncGeneratorBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          AsyncFunctionBody : FunctionBody
        </emu-grammar>
        <emu-alg>
          1. Return ? EvaluateAsyncFunctionBody of |AsyncFunctionBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          AsyncConciseBody : ExpressionBody
        </emu-grammar>
        <emu-alg>
          1. Return ? EvaluateAsyncConciseBody of |AsyncConciseBody| with arguments _functionObject_ and _argumentsList_.
        </emu-alg>
        <emu-grammar>
          Initializer :
            `=` AssignmentExpression
        </emu-grammar>
        <emu-alg>
          1. Assert: _argumentsList_ is empty.
          1. Assert: _functionObject_.[[ClassFieldInitializerName]] is not ~empty~.
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _functionObject_.[[ClassFieldInitializerName]].
          1. Else,
            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Return ReturnCompletion(_value_).
        </emu-alg>
        <emu-note>
          <p>尽管字段初始化器构成了函数边界，调用 FunctionDeclarationInstantiation 没有可观察效果，因此省略。</p>
        </emu-note>
        <emu-grammar>
          ClassStaticBlockBody : ClassStaticBlockStatementList
        </emu-grammar>
        <emu-alg>
          1. Assert: _argumentsList_ is empty.
          1. Return ? EvaluateClassStaticBlockBody of |ClassStaticBlockBody| with argument _functionObject_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ordinarycallevaluatebody" type="abstract operation">
        <h1>
          OrdinaryCallEvaluateBody (
            _F_: an ECMAScript function object,
            _argumentsList_: a List of ECMAScript language values,
          ): a return completion or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return ? EvaluateBody of _F_.[[ECMAScriptCode]] with arguments _F_ and _argumentsList_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 一个正常完成（包含 Object）或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>一个 ECMAScript 函数对象 _F_</dd>
      </dl>
      <emu-alg>
        1. 令 _callerContext_ 为当前运行执行上下文。
        1. 令 _kind_ 为 _F_.[[ConstructorKind]]。
        1. 若 _kind_ 为 ~base~，则
          1. 令 _thisArgument_ 为 ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*)。
        1. 令 _calleeContext_ 为 PrepareForOrdinaryCall(_F_, _newTarget_)。
        1. 断言：_calleeContext_ 现在是运行执行上下文。
        1. 若 _kind_ 为 ~base~，则
          1. 执行 OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_)。
          1. 令 _initializeResult_ 为 Completion(InitializeInstanceElements(_thisArgument_, _F_))。
          1. 若 _initializeResult_ 是一个 abrupt completion，则
            1. 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
            1. 返回 ? _initializeResult_。
        1. 令 _constructorEnv_ 为 _calleeContext_ 的 LexicalEnvironment。
        1. 令 _result_ 为 Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_))。
        1. 从执行上下文栈移除 _calleeContext_ 并恢复 _callerContext_ 为运行执行上下文。
        1. 若 _result_ 是一个 throw completion，则
          1. 返回 ? _result_。
        1. 断言：_result_ 是一个 return completion。
        1. 若 _result_.[[Value]] 是一个 Object，返回 _result_.[[Value]]。
        1. 若 _kind_ 为 ~base~，返回 _thisArgument_。
        1. 若 _result_.[[Value]] 不是 *undefined*，抛出 *TypeError* 异常。
        1. 令 _thisBinding_ 为 ? _constructorEnv_.GetThisBinding()。
        1. 断言：_thisBinding_ 是一个 Object。
        1. 返回 _thisBinding_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" type="abstract operation" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>
        OrdinaryFunctionCreate (
          _functionPrototype_: an Object,
          _sourceText_: a sequence of Unicode code points,
          _ParameterList_: a Parse Node,
          _Body_: a Parse Node,
          _thisMode_: ~lexical-this~ or ~non-lexical-this~,
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于在运行时创建一个具有默认 [[Call]] 内部方法且无 [[Construct]] 内部方法（但后续可通过诸如 MakeConstructor 的操作增加）的新函数。_sourceText_ 是待创建函数语法定义的源文本。</dd>
      </dl>
      <emu-alg>
        1. 令 _internalSlotsList_ 为 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中列出的内部槽。
        1. 令 _F_ 为 OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_)。
        1. 将 _F_.[[Call]] 设为 <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref> 中指定的定义。
        1. 将 _F_.[[SourceText]] 设为 _sourceText_。
        1. 将 _F_.[[FormalParameters]] 设为 _ParameterList_。
        1. 将 _F_.[[ECMAScriptCode]] 设为 _Body_。
        1. 令 _Strict_ 为 IsStrict(_Body_)。
        1. 将 _F_.[[Strict]] 设为 _Strict_。
        1. 若 _thisMode_ 为 ~lexical-this~，将 _F_.[[ThisMode]] 设为 ~lexical~。
        1. 否则若 _Strict_ 为 *true*，将 _F_.[[ThisMode]] 设为 ~strict~。
        1. 否则，将 _F_.[[ThisMode]] 设为 ~global~。
        1. 将 _F_.[[IsClassConstructor]] 设为 *false*。
        1. 将 _F_.[[Environment]] 设为 _env_。
        1. 将 _F_.[[PrivateEnvironment]] 设为 _privateEnv_。
        1. 将 _F_.[[ScriptOrModule]] 设为 GetActiveScriptOrModule()。
        1. 将 _F_.[[Realm]] 设为当前 Realm Record。
        1. 将 _F_.[[HomeObject]] 设为 *undefined*。
        1. 将 _F_.[[Fields]] 设为一个新的空 List。
        1. 将 _F_.[[PrivateMethods]] 设为一个新的空 List。
        1. 将 _F_.[[ClassFieldInitializerName]] 设为 ~empty~。
        1. 令 _len_ 为 _ParameterList_ 的 ExpectedArgumentCount。
        1. 执行 SetFunctionLength(_F_, _len_)。
        1. 返回 _F_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addrestrictedfunctionproperties" type="abstract operation">
      <h1>
        AddRestrictedFunctionProperties (
          _F_: a function object,
          _realm_: a Realm Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_realm_.[[Intrinsics]].[[%ThrowTypeError%]] 存在并已初始化。
        1. 令 _thrower_ 为 _realm_.[[Intrinsics]].[[%ThrowTypeError%]]。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"caller"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"arguments"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 返回 ~unused~。
      </emu-alg>

      <emu-clause id="sec-%throwtypeerror%">
        <h1>%ThrowTypeError% ( )</h1>
        <p>该函数是 <dfn>%ThrowTypeError%</dfn> 内在对象。</p>
        <p>它是一个匿名内置函数对象，并在每个 realm 中各定义一次。</p>
        <p>当被调用时执行以下步骤：</p>
        <emu-alg>
          1. 抛出 *TypeError* 异常。
        </emu-alg>
        <p>此函数的 [[Extensible]] 内部槽的值为 *false*。</p>
        <p>该函数的 *"length"* 属性具备特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
        <p>该函数的 *"name"* 属性具备特性 { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }。</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-makeconstructor" type="abstract operation">
      <h1>
        MakeConstructor (
          _F_: an ECMAScript function object or a built-in function object,
          optional _writablePrototype_: a Boolean,
          optional _prototype_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _F_ 转换为构造器。</dd>
      </dl>
      <emu-alg>
        1. 若 _F_ 是 ECMAScript 函数对象，则
          1. 断言：IsConstructor(_F_) 为 *false*。
          1. 断言：_F_ 是一个可扩展对象且无 *"prototype"* 自身属性。
          1. 将 _F_.[[Construct]] 设为 <emu-xref href="#sec-ecmascript-function-objects-construct-argumentslist-newtarget"></emu-xref> 中指定的定义。
        1. 否则，
          1. 将 _F_.[[Construct]] 设为 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 中指定的定义。
        1. 将 _F_.[[ConstructorKind]] 设为 ~base~。
        1. 若未提供 _writablePrototype_，将 _writablePrototype_ 设为 *true*。
        1. 若未提供 _prototype_，则
          1. 将 _prototype_ 设为 OrdinaryObjectCreate(%Object.prototype%)。
          1. 执行 ! DefinePropertyOrThrow(_prototype_, *"constructor"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makeclassconstructor" type="abstract operation">
      <h1>
        MakeClassConstructor (
          _F_: an ECMAScript function object,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_F_.[[IsClassConstructor]] 为 *false*。
        1. 将 _F_.[[IsClassConstructor]] 设为 *true*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" type="abstract operation">
      <h1>
        MakeMethod (
          _F_: an ECMAScript function object,
          _homeObject_: an Object,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _F_ 配置为一个方法。</dd>
      </dl>
      <emu-alg>
        1. 断言：_homeObject_ 是一个普通对象。
        1. 将 _F_.[[HomeObject]] 设为 _homeObject_。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definemethodproperty" oldids="sec-createmethodproperty" type="abstract operation">
      <h1>
        DefineMethodProperty (
          _homeObject_: an Object,
          _key_: a property key or Private Name,
          _closure_: a function object,
          _enumerable_: a Boolean,
        ): either a normal completion containing either a PrivateElement or ~unused~, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：_homeObject_ 是一个普通、可扩展对象。
        1. 若 _key_ 是一个 Private Name，则
          1. 返回 PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ }。
        1. 否则，
          1. 令 _desc_ 为 PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }。
          1. 执行 ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_)。
          1. NOTE: DefinePropertyOrThrow 只有在尝试定义 _key_ 为 *"prototype"* 的类静态方法时才会返回一个 abrupt completion。
          1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionname" type="abstract operation">
      <h1>
        SetFunctionName (
          _F_: a function object,
          _name_: a property key or Private Name,
          optional _prefix_: a String,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>为 _F_ 添加一个 *"name"* 属性。</dd>
      </dl>
      <emu-alg>
        1. 断言：_F_ 是一个可扩展对象，且没有 *"name"* 自身属性。
        1. 若 _name_ 是一个 Symbol，则
          1. 令 _description_ 为 _name_.[[Description]]。
          1. 若 _description_ 为 *undefined*，将 _name_ 设为空字符串。
          1. 否则，将 _name_ 设为 *"["*、_description_、*" ]"* 的字符串连接。
        1. 否则若 _name_ 是一个 Private Name，则
          1. 将 _name_ 设为 _name_.[[Description]]。
        1. 若 _F_ 具有 [[InitialName]] 内部槽，则
          1. 将 _F_.[[InitialName]] 设为 _name_。
        1. 若提供了 _prefix_，则
          1. 将 _name_ 设为 _prefix_、代码单元 0x0020 (SPACE)、_name_ 的字符串连接。
          1. 若 _F_ 具有 [[InitialName]] 内部槽，则
            1. NOTE: 下述步骤中的选择在本抽象操作每次执行时独立决定。
            1. 可选地，将 _F_.[[InitialName]] 设为 _name_。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"name"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-setfunctionlength" type="abstract operation">
      <h1>
        SetFunctionLength (
          _F_: a function object,
          _length_: a non-negative integer or +&infin;,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>为 _F_ 添加一个 *"length"* 属性。</dd>
      </dl>
      <emu-alg>
        1. 断言：_F_ 是一个可扩展对象，且没有 *"length"* 自身属性。
        1. 执行 ! DefinePropertyOrThrow(_F_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-functiondeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-functiondeclarationinstantiation">
      <h1>
        FunctionDeclarationInstantiation (
          _func_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_func_ 是为其建立执行上下文的函数对象。</dd>
      </dl>
      <emu-note>
        <p>当为求值一个 ECMAScript 函数建立执行上下文时，会创建一个新的 Function Environment Record，并在其中实例化每个形式参数的绑定。函数体内的每个声明也会被实例化。若函数形式参数不包含任何默认值初始化器，则函数体声明与参数在同一个 Environment Record 中实例化。若存在默认值参数初始化器，则为函数体声明创建第二个 Environment Record。形式参数与函数在 FunctionDeclarationInstantiation 过程中被初始化。所有其它绑定在函数体求值期间初始化。</p>
      </emu-note>
      <p>被调用时执行以下步骤：</p>
      <emu-alg>
        1. 令 _calleeContext_ 为当前运行执行上下文。
        1. 令 _code_ 为 _func_.[[ECMAScriptCode]]。
        1. 令 _strict_ 为 _func_.[[Strict]]。
        1. 令 _formals_ 为 _func_.[[FormalParameters]]。
        1. 令 _parameterNames_ 为 _formals_ 的 BoundNames。
        1. 若 _parameterNames_ 含有任意重复项，令 _hasDuplicates_ 为 *true*；否则令其为 *false*。
        1. 令 _simpleParameterList_ 为 IsSimpleParameterList of _formals_。
        1. 令 _hasParameterExpressions_ 为 ContainsExpression of _formals_。
        1. 令 _varNames_ 为 _code_ 的 VarDeclaredNames。
        1. 令 _varDeclarations_ 为 _code_ 的 VarScopedDeclarations。
        1. 令 _lexicalNames_ 为 _code_ 的 LexicallyDeclaredNames。
        1. 令 _functionNames_ 为一个新的空 List。
        1. 令 _functionsToInitialize_ 为一个新的空 List。
        1. 依逆序遍历 _varDeclarations_ 中每个元素 _d_，执行
          1. 若 _d_ 既不是 |VariableDeclaration| 也不是 |ForBinding| 也不是 |BindingIdentifier|，则
            1. 断言：_d_ 是 |FunctionDeclaration|、|GeneratorDeclaration|、|AsyncFunctionDeclaration| 或 |AsyncGeneratorDeclaration| 之一。
            1. 令 _fn_ 为 _d_ 的 BoundNames 唯一元素。
            1. 若 _functionNames_ 不包含 _fn_，则
              1. 将 _fn_ 插入 _functionNames_ 首部。
              1. NOTE: 若同名函数声明出现多次，使用最后一个声明。
              1. 将 _d_ 插入 _functionsToInitialize_ 首部。
        1. 令 _argumentsObjectNeeded_ 为 *true*。
        1. 若 _func_.[[ThisMode]] 为 ~lexical~，则
          1. NOTE: 箭头函数永远没有 arguments 对象。
          1. 将 _argumentsObjectNeeded_ 设为 *false*。
        1. 否则若 _parameterNames_ 包含 *"arguments"*，则
          1. 将 _argumentsObjectNeeded_ 设为 *false*。
        1. 否则若 _hasParameterExpressions_ 为 *false*，则
          1. 若 _functionNames_ 包含 *"arguments"* 或 _lexicalNames_ 包含 *"arguments"*，则
            1. 将 _argumentsObjectNeeded_ 设为 *false*。
        1. 若 _strict_ 为 *true* 或 _hasParameterExpressions_ 为 *false*，则
          1. NOTE: 参数只需一个 Environment Record，因为严格模式代码中的 `eval` 调用不能创建对外可见的新绑定。
          1. 令 _env_ 为 _calleeContext_ 的 LexicalEnvironment。
        1. 否则，
          1. NOTE: 需要单独的 Environment Record 以确保形式参数列表中的直接 eval 创建的绑定不在参数声明的环境内。
          1. 令 _calleeEnv_ 为 _calleeContext_ 的 LexicalEnvironment。
          1. 令 _env_ 为 NewDeclarativeEnvironment(_calleeEnv_)。
          1. 断言：_calleeContext_ 的 VariableEnvironment 与 _calleeEnv_ 相同。
          1. 将 _calleeContext_ 的 LexicalEnvironment 设为 _env_。
        1. 对 _parameterNames_ 中每个字符串 _paramName_，执行
          1. 令 _alreadyDeclared_ 为 ! _env_.HasBinding(_paramName_)。
          1. NOTE: 早期错误确保重复参数名只可出现在无参数默认值或 rest 参数的非严格函数中。
          1. 若 _alreadyDeclared_ 为 *false*，则
            1. 执行 ! _env_.CreateMutableBinding(_paramName_, *false*)。
            1. 若 _hasDuplicates_ 为 *true*，则
              1. 执行 ! _env_.InitializeBinding(_paramName_, *undefined*)。
        1. 若 _argumentsObjectNeeded_ 为 *true*，则
          1. 若 _strict_ 为 *true* 或 _simpleParameterList_ 为 *false*，则
            1. 令 _ao_ 为 CreateUnmappedArgumentsObject(_argumentsList_)。
          1. 否则，
            1. NOTE: 仅对没有 rest 参数、没有任何参数默认值初始化器、且无解构参数的非严格函数提供映射 arguments 对象。
            1. 令 _ao_ 为 CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_)。
          1. 若 _strict_ 为 *true*，则
            1. 执行 ! _env_.CreateImmutableBinding(*"arguments"*, *false*)。
            1. NOTE: 严格模式代码的早期错误阻止对该绑定的赋值，因此其可变性不可观察。
          1. 否则，
            1. 执行 ! _env_.CreateMutableBinding(*"arguments"*, *false*)。
          1. 执行 ! _env_.InitializeBinding(*"arguments"*, _ao_)。
          1. 令 _parameterBindings_ 为 _parameterNames_ 与 « *"arguments"* » 的列表连接。
        1. 否则，
          1. 令 _parameterBindings_ 为 _parameterNames_。
        1. 令 _iteratorRecord_ 为 CreateListIteratorRecord(_argumentsList_)。
        1. 若 _hasDuplicates_ 为 *true*，则
          1. 令 _usedEnv_ 为 *undefined*。
        1. 否则，
          1. 令 _usedEnv_ 为 _env_。
        1. NOTE: 下列步骤不会返回 ReturnCompletion，因为在表达式位置唯一产生此类完成的方式是使用 |YieldExpression|，而其在参数列表中已由 <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref> 与 <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref> 的早期错误规则禁止。
        1. 执行 ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _usedEnv_。
        1. 若 _hasParameterExpressions_ 为 *false*，则
          1. NOTE: 参数与顶层 var 只需一个 Environment Record。
          1. 令 _instantiatedVarNames_ 为 _parameterBindings_ 的拷贝。
          1. 对 _varNames_ 中每个元素 _n_，执行
            1. 若 _instantiatedVarNames_ 不含 _n_，则
              1. 将 _n_ 追加至 _instantiatedVarNames_。
              1. 执行 ! _env_.CreateMutableBinding(_n_, *false*)。
              1. 执行 ! _env_.InitializeBinding(_n_, *undefined*)。
          1. 令 _varEnv_ 为 _env_。
        1. 否则，
          1. NOTE: 需要单独的 Environment Record 以确保形式参数列表中的表达式创建的闭包无法见到函数体内的声明。
          1. 令 _varEnv_ 为 NewDeclarativeEnvironment(_env_)。
          1. 将 _calleeContext_ 的 VariableEnvironment 设为 _varEnv_。
          1. 令 _instantiatedVarNames_ 为一个新的空 List。
          1. 对 _varNames_ 中每个元素 _n_，执行
            1. 若 _instantiatedVarNames_ 不含 _n_，则
              1. 将 _n_ 追加至 _instantiatedVarNames_。
              1. 执行 ! _varEnv_.CreateMutableBinding(_n_, *false*)。
              1. 若 _parameterBindings_ 不含 _n_，或 _functionNames_ 含 _n_，则
                1. 令 _initialValue_ 为 *undefined*。
              1. 否则，
                1. 令 _initialValue_ 为 ! _env_.GetBindingValue(_n_, *false*)。
              1. 执行 ! _varEnv_.InitializeBinding(_n_, _initialValue_)。
              1. NOTE: 与形式参数同名的 var 最初具有与对应已初始化参数相同的值。
        1. 若 _strict_ 为 *true*，则
          1. 令 _lexEnv_ 为 _varEnv_。
        1. 否则，
          1. [id="step-functiondeclarationinstantiation-web-compat-insertion-point", normative-optional] 若宿主是 Web 浏览器或以其它方式支持 <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>，则
            1. 对任意 |Block|、|CaseClause|、|DefaultClause| _x_ 的 |StatementList| 中直接包含，且 _code_ Contains _x_ 为 *true* 的每个 |FunctionDeclaration| _f_，执行
              1. 令 _F_ 为 _f_ 的 |BindingIdentifier| 的 StringValue。
              1. 若用以 _F_ 为 |BindingIdentifier| 的 |VariableStatement| 替换该 |FunctionDeclaration| _f_ 不会为 _func_ 产生早期错误，且 _parameterNames_ 不含 _F_，则
                1. NOTE: 仅当 _F_ 既不是 VarDeclaredName、也不是形式参数名、也不是另一个 |FunctionDeclaration| 时才在此实例化 _F_ 的 var 绑定。
                1. 若 _instantiatedVarNames_ 不含 _F_ 且 _F_ 不是 *"arguments"*，则
                  1. 执行 ! _varEnv_.CreateMutableBinding(_F_, *false*)。
                  1. 执行 ! _varEnv_.InitializeBinding(_F_, *undefined*)。
                  1. 将 _F_ 追加至 _instantiatedVarNames_。
                1. [id="step-functiondeclarationinstantiation-alt-funcdecl-eval"] 当 |FunctionDeclaration| _f_ 被求值时，用以下步骤取代 <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref> 中的 |FunctionDeclaration| Evaluation 算法：
                  1. 令 _fEnv_ 为当前运行执行上下文的 VariableEnvironment。
                  1. 令 _bEnv_ 为当前运行执行上下文的 LexicalEnvironment。
                  1. 令 _fObj_ 为 ! _bEnv_.GetBindingValue(_F_, *false*)。
                  1. 执行 ! _fEnv_.SetMutableBinding(_F_, _fObj_, *false*)。
                  1. 返回 ~unused~。
          1. 令 _lexEnv_ 为 NewDeclarativeEnvironment(_varEnv_)。
          1. NOTE: 非严格函数为顶层词法声明使用一个单独的 Environment Record，以便直接 eval 能确定 eval 代码引入的 var 作用域声明是否与预先存在的顶层词法作用域声明冲突。严格函数不需要此步骤，因为严格直接 eval 总是将所有声明放入新的 Environment Record。
        1. 将 _calleeContext_ 的 LexicalEnvironment 设为 _lexEnv_。
        1. 令 _lexDeclarations_ 为 _code_ 的 LexicallyScopedDeclarations。
        1. 对 _lexDeclarations_ 中每个元素 _d_，执行
          1. NOTE: 词法声明的名字不可能与函数/生成器声明、形式参数或 var 名相同。词法声明的名字在此仅被实例化但未初始化。
          1. 对 _d_ 的 BoundNames 中每个元素 _dn_，执行
            1. 若 IsConstantDeclaration of _d_ 为 *true*，则
              1. 执行 ! _lexEnv_.CreateImmutableBinding(_dn_, *true*)。
            1. 否则，
              1. 执行 ! _lexEnv_.CreateMutableBinding(_dn_, *false*)。
        1. 令 _privateEnv_ 为 _calleeContext_ 的 PrivateEnvironment。
        1. 对 _functionsToInitialize_ 中每个 Parse Node _f_，执行
          1. 令 _fn_ 为 _f_ 的 BoundNames 唯一元素。
          1. 令 _fo_ 为 InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_。
          1. 执行 ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*)。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-function-objects">
    <h1>内置函数对象 (Built-in Function Objects)</h1>
    <p>内置函数对象是普通对象；它必须符合 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中对普通对象的要求。</p>
    <p>除每个普通对象所需的内部槽（见 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>）外，内置函数对象还必须具有下列内部槽：</p>
    <ul>
      <li>[[Realm]]：一个 Realm Record，表示创建该函数的 realm。</li>
      <li>[[InitialName]]：一个 String，函数的初始名称，被 <emu-xref href="#sec-function.prototype.tostring"></emu-xref> 使用。</li>
    </ul>
    <p>内置函数对象的 [[Prototype]] 内部槽初始值为 %Function.prototype%，除非另有规定。</p>
    <p>内置函数对象必须具有符合 <emu-xref href="#sec-built-in-function-objects-call-thisargument-argumentslist"></emu-xref> 定义的 [[Call]] 内部方法。</p>
    <p>仅当被描述为 “constructor” 或本规范中的某个算法显式设置其 [[Construct]] 内部方法时，内置函数对象才具有 [[Construct]]。该 [[Construct]] 必须符合 <emu-xref href="#sec-built-in-function-objects-construct-argumentslist-newtarget"></emu-xref> 的定义。</p>
    <p>实现可以提供未在本规范中定义的额外内置函数对象。</p>

    <emu-clause id="sec-built-in-function-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>内置函数对象 _F_</dd>
      </dl>
      <emu-alg>
        1. 返回 ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*)。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-built-in-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 返回一个包含 Object 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>内置函数对象 _F_（当该方法存在时）</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为 ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_)。
        1. 断言：_result_ 是一个 Object。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-builtincallorconstruct" type="abstract operation">
      <h1>
        BuiltinCallOrConstruct (
          _F_: a built-in function object,
          _thisArgument_: an ECMAScript language value or ~uninitialized~,
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor or *undefined*,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 令 _callerContext_ 为正在运行的执行上下文。
        1. 若 _callerContext_ 尚未被挂起，则挂起 _callerContext_。
        1. 令 _calleeContext_ 为一个新的执行上下文。
        1. 将 _calleeContext_ 的 Function 设为 _F_。
        1. 令 _calleeRealm_ 为 _F_.[[Realm]]。
        1. 将 _calleeContext_ 的 Realm 设为 _calleeRealm_。
        1. 将 _calleeContext_ 的 ScriptOrModule 设为 *null*。
        1. 执行任何实现定义的、对 _calleeContext_ 必要的初始化。
        1. 将 _calleeContext_ 压入执行上下文栈；_calleeContext_ 现在为运行执行上下文。
        1. [id="step-call-builtin-function-result"] 令 _result_ 为 <emu-meta effects="user-code">对 _F_ 的求值</emu-meta> 且符合其规范描述的完成记录结果。若 _thisArgument_ 为 ~uninitialized~，则 *this* 值未初始化；否则由 _thisArgument_ 提供 *this* 值。_argumentsList_ 提供具名参数。_newTarget_ 提供 NewTarget 值。
        1. 注：若 _F_ 在本文档中定义，其“规范描述”即通过算法步骤或其他方式给出的行为。
        1. 将 _calleeContext_ 自执行上下文栈移除并恢复 _callerContext_ 为运行执行上下文。
        1. 返回 ? _result_。
      </emu-alg>
      <emu-note>
        <p>当 _calleeContext_ 被自执行上下文栈移除时，若其已被可访问的 Generator 挂起并被保留以供后续恢复，则不得销毁它。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-createbuiltinfunction" type="abstract operation">
      <h1>
        CreateBuiltinFunction (
          _behaviour_: an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification,
          _length_: a non-negative integer or +&infin;,
          _name_: a property key or a Private Name,
          _additionalInternalSlotsList_: a List of names of internal slots,
          optional _realm_: a Realm Record,
          optional _prototype_: an Object or *null*,
          optional _prefix_: a String,
        ): 一个内置函数对象
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_additionalInternalSlotsList_ 含必须作为该对象一部分定义的额外内部槽名称。此操作创建一个内置函数对象。</dd>
      </dl>
      <emu-alg>
        1. 若未提供 _realm_，则将 _realm_ 设为当前 Realm Record。
        1. 若未提供 _prototype_，则将 _prototype_ 设为 _realm_.[[Intrinsics]].[[%Function.prototype%]]。
        1. 令 _internalSlotsList_ 为包含 <emu-xref href="#sec-built-in-function-objects"></emu-xref> 要求的全部内部槽名称的列表，用于即将创建的内置函数对象。
        1. 将 _additionalInternalSlotsList_ 的各元素追加到 _internalSlotsList_。
        1. 令 _func_ 为一个新的内置函数对象；当被调用时，使用所提供实参作为 _behaviour_ 指定的对应形参值执行 _behaviour_ 描述的动作。该新函数对象具有名称为 _internalSlotsList_ 各元素的内部槽，以及一个 [[InitialName]] 内部槽。
        1. 将 _func_.[[Prototype]] 设为 _prototype_。
        1. 将 _func_.[[Extensible]] 设为 *true*。
        1. 将 _func_.[[Realm]] 设为 _realm_。
        1. 将 _func_.[[InitialName]] 设为 *null*。
        1. 执行 SetFunctionLength(_func_, _length_)。
        1. 若未提供 _prefix_，则
          1. 执行 SetFunctionName(_func_, _name_)。
        1. 否则，
          1. 执行 SetFunctionName(_func_, _name_, _prefix_)。
        1. 返回 _func_。
      </emu-alg>
      <p>本规范中定义的每个内置函数均通过调用 CreateBuiltinFunction 抽象操作创建。</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
    <h1>内置特异对象的内部方法与内部槽 (Built-in Exotic Object Internal Methods and Slots)</h1>
    <p>本规范定义了多种内置特异对象。除少数特定情形外，它们与普通对象的行为相似。以下特异对象除非下文明确另行规定，否则使用普通对象的内部方法：</p>

    <emu-clause id="sec-bound-function-exotic-objects">
      <h1>绑定函数特异对象 (Bound Function Exotic Objects)</h1>
      <p>绑定函数特异对象是包装另一个函数对象的特异对象。它是可调用的（具有 [[Call]]，可能具有 [[Construct]]）。调用它通常导致调用其被包装的函数。</p>

      <p>若对象的 [[Call]] 与（若适用）[[Construct]] 内部方法使用以下实现，且其他基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中的定义，则该对象是一个 <dfn id="bound-function-exotic-object" variants="bound function exotic objects">绑定函数特异对象</dfn>。这些方法在 BoundFunctionCreate 中安装。</p>

      <p>绑定函数特异对象不具有 <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> 中 ECMAScript 函数对象的内部槽；它们改为（除 [[Prototype]] 与 [[Extensible]] 外）具有 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 所列的内部槽。</p>
      <emu-table id="table-internal-slots-of-bound-function-exotic-objects" caption="绑定函数特异对象的内部槽 (Internal Slots of Bound Function Exotic Objects)" oldids="table-28">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[BoundTargetFunction]]
            </td>
            <td>
              a callable Object
            </td>
            <td>
              被包装的函数对象。
            </td>
          </tr>
          <tr>
            <td>
              [[BoundThis]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              调用被包装函数时始终作为 *this* 的值。
            </td>
          </tr>
          <tr>
            <td>
              [[BoundArguments]]
            </td>
            <td>
              a List of ECMAScript language values
            </td>
            <td>
              在任何调用中用作被包装函数前置实参的值列表。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-bound-function-exotic-objects-call-thisargument-argumentslist" type="internal method">
        <h1>
          [[Call]] (
            _thisArgument_: an ECMAScript language value,
            _argumentsList_: a List of ECMAScript language values,
          ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>绑定函数特异对象 _F_</dd>
        </dl>
        <emu-alg>
          1. 令 _target_ 为 _F_.[[BoundTargetFunction]]。
          1. 令 _boundThis_ 为 _F_.[[BoundThis]]。
          1. 令 _boundArgs_ 为 _F_.[[BoundArguments]]。
          1. 令 _args_ 为 _boundArgs_ 与 _argumentsList_ 的列表连接。
          1. 返回 ? Call(_target_, _boundThis_, _args_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bound-function-exotic-objects-construct-argumentslist-newtarget" type="internal method">
        <h1>
          [[Construct]] (
            _argumentsList_: a List of ECMAScript language values,
            _newTarget_: a constructor,
          ): 返回一个包含 Object 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>绑定函数特异对象 _F_</dd>
        </dl>
        <emu-alg>
          1. 令 _target_ 为 _F_.[[BoundTargetFunction]]。
          1. 断言：IsConstructor(_target_) 为 *true*。
          1. 令 _boundArgs_ 为 _F_.[[BoundArguments]]。
          1. 令 _args_ 为 _boundArgs_ 与 _argumentsList_ 的列表连接。
          1. 若 SameValue(_F_, _newTarget_) 为 *true*，则将 _newTarget_ 设为 _target_。
          1. 返回 ? Construct(_target_, _args_, _newTarget_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boundfunctioncreate" type="abstract operation">
        <h1>
          BoundFunctionCreate (
            _targetFunction_: a function object,
            _boundThis_: an ECMAScript language value,
            _boundArgs_: a List of ECMAScript language values,
          ): 返回一个包含 function object 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的绑定函数特异对象。</dd>
        </dl>
        <emu-alg>
          1. 令 _proto_ 为 ? <emu-meta effects="user-code">_targetFunction_.[[GetPrototypeOf]]</emu-meta>()。
          1. 令 _internalSlotsList_ 为 « [[Prototype]], [[Extensible]] » 与 <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref> 中内部槽列表的连接。
          1. 令 _obj_ 为 MakeBasicObject(_internalSlotsList_)。
          1. 将 _obj_.[[Prototype]] 设为 _proto_。
          1. 按 <emu-xref href="#sec-bound-function-exotic-objects-call-thisargument-argumentslist"></emu-xref> 所述设置 _obj_.[[Call]]。
          1. 若 IsConstructor(_targetFunction_) 为 *true*，则
            1. 按 <emu-xref href="#sec-bound-function-exotic-objects-construct-argumentslist-newtarget"></emu-xref> 所述设置 _obj_.[[Construct]]。
          1. 将 _obj_.[[BoundTargetFunction]] 设为 _targetFunction_。
          1. 将 _obj_.[[BoundThis]] 设为 _boundThis_。
          1. 将 _obj_.[[BoundArguments]] 设为 _boundArgs_。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-exotic-objects">
      <h1>数组特异对象 (Array Exotic Objects)</h1>
      <p>Array 是对数组索引属性键（见 <emu-xref href="#sec-object-type"></emu-xref>）做特殊处理的特异对象。属性名为数组索引的属性也称为 <em>element</em>。每个 Array 有一个不可配置的 *"length"* 属性，其值始终是数学值严格小于 2<sup>32</sup> 的非负整数 Number。*"length"* 的值在数值上大于其每个名称为数组索引的自身属性的名称；当 Array 的自身属性被创建或改变时，为保持该不变式，会按需要调整其他属性。具体地，当添加一个名称为数组索引的自身属性时，必要时将 *"length"* 的值改为该索引数值加一；当 *"length"* 值被改变时，删除所有名称为数组索引且其值不小于新 length 的自身属性。该约束仅适用于 Array 的自身属性，不受其原型链上继承的 *"length"* 或数组索引属性影响。</p>

      <p>若对象的 [[DefineOwnProperty]] 内部方法使用以下实现，且其其它基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中的定义，则其为 <dfn id="array-exotic-object" variants="Array exotic objects">数组特异对象</dfn>（简称 Array）。这些方法在 ArrayCreate 中安装。</p>

      <emu-clause id="sec-array-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>数组特异对象 _A_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 为 *"length"*，则
            1. 返回 ? ArraySetLength(_A_, _Desc_)。
          1. 否则若 _P_ 是数组索引，则
            1. 令 _lengthDesc_ 为 OrdinaryGetOwnProperty(_A_, *"length"*)。
            1. 断言：_lengthDesc_ 不为 *undefined*。
            1. 断言：IsDataDescriptor(_lengthDesc_) 为 *true*。
            1. 断言：_lengthDesc_.[[Configurable]] 为 *false*。
            1. 令 _length_ 为 _lengthDesc_.[[Value]]。
            1. 断言：_length_ 是非负整数 Number。
            1. 令 _index_ 为 ! ToUint32(_P_)。
            1. 若 _index_ ≥ _length_ 且 _lengthDesc_.[[Writable]] 为 *false*，返回 *false*。
            1. 令 _succeeded_ 为 ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_)。
            1. 若 _succeeded_ 为 *false*，返回 *false*。
            1. 若 _index_ ≥ _length_，则
              1. 将 _lengthDesc_.[[Value]] 设为 _index_ + *1*<sub>𝔽</sub>。
              1. 将 _succeeded_ 设为 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _lengthDesc_)。
              1. 断言：_succeeded_ 为 *true*。
            1. 返回 *true*。
          1. 返回 ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraycreate" type="abstract operation">
        <h1>
          ArrayCreate (
            _length_: a non-negative integer,
            optional _proto_: an Object,
          ): 返回一个包含数组特异对象的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的 Array。</dd>
        </dl>
        <emu-alg>
          1. 若 _length_ > 2<sup>32</sup> - 1，抛出 *RangeError* 异常。
          1. 若未提供 _proto_，则设 _proto_ 为 %Array.prototype%。
          1. 令 _A_ 为 MakeBasicObject(« [[Prototype]], [[Extensible]] »)。
          1. 将 _A_.[[Prototype]] 设为 _proto_。
          1. 按 <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref> 规定设置 _A_.[[DefineOwnProperty]]。
          1. 执行 ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arrayspeciescreate" type="abstract operation">
        <h1>
          ArraySpeciesCreate (
            _originalArray_: an Object,
            _length_: a non-negative integer,
          ): 返回一个包含 Object 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定通过由 _originalArray_ 派生的构造函数创建新的 Array 或相似对象；不强制该构造函数返回 Array。</dd>
        </dl>
        <emu-alg>
          1. 令 _isArray_ 为 ? IsArray(_originalArray_)。
          1. 若 _isArray_ 为 *false*，返回 ? ArrayCreate(_length_)。
          1. 令 _C_ 为 ? Get(_originalArray_, *"constructor"*)。
          1. 若 IsConstructor(_C_) 为 *true*，则
            1. 令 _thisRealm_ 为当前 Realm Record。
            1. 令 _realmC_ 为 ? GetFunctionRealm(_C_)。
            1. 若 _thisRealm_ 与 _realmC_ 不是同一 Realm Record，则
              1. 若 SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) 为 *true*，将 _C_ 设为 *undefined*。
          1. 若 _C_ 是一个 Object，则
            1. 将 _C_ 设为 ? Get(_C_, %Symbol.species%)。
            1. 若 _C_ 为 *null*，将 _C_ 设为 *undefined*。
          1. 若 _C_ 为 *undefined*，返回 ? ArrayCreate(_length_)。
          1. 若 IsConstructor(_C_) 为 *false*，抛出 *TypeError* 异常。
          1. 返回 ? Construct(_C_, « 𝔽(_length_) »)。
        </emu-alg>
        <emu-note>
          <p>若 _originalArray_ 使用非当前执行上下文 realm 的标准内置 Array 构造器创建，则新 Array 使用当前执行上下文的 realm 创建，以保持与历史浏览器行为兼容。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-arraysetlength" type="abstract operation">
        <h1>
          ArraySetLength (
            _A_: an Array,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _Desc_ 不含 [[Value]] 字段，则
            1. 返回 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _Desc_)。
          1. 令 _newLenDesc_ 为 _Desc_ 的拷贝。
          1. [id="step-arraysetlength-newlen"] 令 _newLen_ 为 ? ToUint32(_Desc_.[[Value]])。
          1. [id="step-arraysetlength-numberlen"] 令 _numberLen_ 为 ? ToNumber(_Desc_.[[Value]])。
          1. 若 SameValueZero(_newLen_, _numberLen_) 为 *false*，抛出 *RangeError* 异常。
          1. 将 _newLenDesc_.[[Value]] 设为 _newLen_。
          1. 令 _oldLenDesc_ 为 OrdinaryGetOwnProperty(_A_, *"length"*)。
          1. 断言：_oldLenDesc_ 不为 *undefined*。
          1. 断言：IsDataDescriptor(_oldLenDesc_) 为 *true*。
          1. 断言：_oldLenDesc_.[[Configurable]] 为 *false*。
          1. 令 _oldLen_ 为 _oldLenDesc_.[[Value]]。
          1. 若 _newLen_ ≥ _oldLen_，则
            1. 返回 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_)。
          1. 若 _oldLenDesc_.[[Writable]] 为 *false*，返回 *false*。
          1. 若 _newLenDesc_ 无 [[Writable]] 字段或 _newLenDesc_.[[Writable]] 为 *true*，则
            1. 令 _newWritable_ 为 *true*。
          1. 否则，
            1. 注：若某些元素无法删除，则延迟将 [[Writable]] 设为 *false*。
            1. 令 _newWritable_ 为 *false*。
            1. 将 _newLenDesc_.[[Writable]] 设为 *true*。
          1. 令 _succeeded_ 为 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_)。
          1. 若 _succeeded_ 为 *false*，返回 *false*。
          1. 对 _A_ 的每个自身属性键 _P_，若 _P_ 是数组索引且 ! ToUint32(_P_) ≥ _newLen_，按递减数值索引顺序：
            1. 令 _deleteSucceeded_ 为 ! _A_.[[Delete]](_P_)。
            1. 若 _deleteSucceeded_ 为 *false*，则
              1. 将 _newLenDesc_.[[Value]] 设为 ! ToUint32(_P_) + *1*<sub>𝔽</sub>。
              1. 若 _newWritable_ 为 *false*，将 _newLenDesc_.[[Writable]] 设为 *false*。
              1. 执行 ! OrdinaryDefineOwnProperty(_A_, *"length"*, _newLenDesc_)。
              1. 返回 *false*。
          1. 若 _newWritable_ 为 *false*，则
            1. 将 _succeeded_ 设为 ! OrdinaryDefineOwnProperty(_A_, *"length"*, PropertyDescriptor { [[Writable]]: *false* })。
            1. 断言：_succeeded_ 为 *true*。
          1. 返回 *true*。
        </emu-alg>
        <emu-note>
          <p>在步骤 <emu-xref href="#step-arraysetlength-newlen"></emu-xref> 与 <emu-xref href="#step-arraysetlength-numberlen"></emu-xref> 中，若 _Desc_.[[Value]] 是对象，其 `valueOf` 方法被调用两次（历史遗留行为）。</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-exotic-objects">
      <h1>字符串特异对象 (String Exotic Objects)</h1>
      <p>String 对象是封装一个 String 值并暴露与该值中各代码单元元素对应的虚拟整数索引数据属性的特异对象。字符串特异对象始终具有名为 *"length"* 的数据属性，其值为封装的 String 长度。代码单元数据属性与 *"length"* 属性均不可写且不可配置。</p>

      <p>若对象的 [[GetOwnProperty]]、[[DefineOwnProperty]] 与 [[OwnPropertyKeys]] 内部方法使用以下实现，且其他基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 中的定义，则该对象是 <dfn id="string-exotic-object" variants="String exotic objects">字符串特异对象</dfn>（或简称 String 对象）。这些方法在 StringCreate 中安装。</p>

      <p>字符串特异对象拥有与普通对象相同的内部槽，另有 [[StringData]] 内部槽。</p>

      <emu-clause id="sec-string-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回一个包含 Property Descriptor 或 *undefined* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>字符串特异对象 _S_</dd>
        </dl>
        <emu-alg>
          1. 令 _desc_ 为 OrdinaryGetOwnProperty(_S_, _P_)。
          1. 若 _desc_ 不为 *undefined*，返回 _desc_。
          1. 返回 StringGetOwnProperty(_S_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>字符串特异对象 _S_</dd>
        </dl>
        <emu-alg>
          1. 令 _stringDesc_ 为 StringGetOwnProperty(_S_, _P_)。
          1. 若 _stringDesc_ 不为 *undefined*，则
            1. 令 _extensible_ 为 _S_.[[Extensible]]。
            1. 返回 IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_)。
          1. 返回 ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 返回一个包含属性键列表的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>字符串特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 令 _keys_ 为一个新的空列表。
          1. 令 _str_ 为 _O_.[[StringData]]。
          1. 断言：_str_ 是一个 String。
          1. 令 _len_ 为 _str_ 的长度。
          1. 对每个整数 _i_（0 ≤ _i_ < _len_，按升序）：
            1. 追加 ! ToString(𝔽(_i_)) 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 是数组索引 且 ! ToIntegerOrInfinity(_P_) ≥ _len_，按数值索引升序）：
            1. 追加 _P_ 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 String 且非数组索引，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 Symbol，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 返回 _keys_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringcreate" type="abstract operation">
        <h1>
          StringCreate (
            _value_: a String,
            _prototype_: an Object,
          ): 一个字符串特异对象
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的字符串特异对象。</dd>
        </dl>
        <emu-alg>
          1. 令 _S_ 为 MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »)。
          1. 将 _S_.[[Prototype]] 设为 _prototype_。
          1. 将 _S_.[[StringData]] 设为 _value_。
          1. 按 <emu-xref href="#sec-string-exotic-objects-getownproperty-p"></emu-xref> 规定设置 _S_.[[GetOwnProperty]]。
          1. 按 <emu-xref href="#sec-string-exotic-objects-defineownproperty-p-desc"></emu-xref> 规定设置 _S_.[[DefineOwnProperty]]。
          1. 按 <emu-xref href="#sec-string-exotic-objects-ownpropertykeys"></emu-xref> 规定设置 _S_.[[OwnPropertyKeys]]。
          1. 令 _length_ 为 _value_ 的长度。
          1. 执行 ! DefinePropertyOrThrow(_S_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _S_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-stringgetownproperty" type="abstract operation">
        <h1>
          StringGetOwnProperty (
            _S_: an Object that has a [[StringData]] internal slot,
            _P_: a property key,
          ): 一个 Property Descriptor 或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _P_ 不是 String，返回 *undefined*。
          1. 令 _index_ 为 CanonicalNumericIndexString(_P_)。
          1. 若 _index_ 不是整数 Number，返回 *undefined*。
          1. 若 _index_ 为 *-0*<sub>𝔽</sub> 或 _index_ &lt; *-0*<sub>𝔽</sub>，返回 *undefined*。
          1. 令 _str_ 为 _S_.[[StringData]]。
          1. 断言：_str_ 是 String。
          1. 令 _len_ 为 _str_ 的长度。
          1. 若 ℝ(_index_) ≥ _len_，返回 *undefined*。
          1. 令 _resultStr_ 为从 ℝ(_index_) 到 ℝ(_index_) + 1 的 _str_ 子串。
          1. 返回 PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arguments-exotic-objects">
      <h1>Arguments 特异对象 (Arguments Exotic Objects)</h1>

      <p>大多数 ECMAScript 函数向其代码提供一个 arguments 对象。依据函数定义特征，该对象要么是普通对象，要么是 arguments 特异对象。arguments 特异对象的数组索引属性映射到其关联函数一次调用的形式参数绑定。</p>

      <p>若对象的内部方法按以下实现（未指明者使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 的定义），则为 <dfn id="arguments-exotic-object" variants="arguments exotic objects">arguments 特异对象</dfn>。这些方法在 CreateMappedArgumentsObject 中安装。</p>

      <emu-note>
        <p>虽 CreateUnmappedArgumentsObject 归入本条款，但它创建的是普通对象而非 arguments 特异对象。</p>
      </emu-note>

      <p>Arguments 特异对象与普通对象具有相同内部槽，并另有 [[ParameterMap]]。普通 arguments 对象也有 [[ParameterMap]]，其值恒为 *undefined*，仅被 `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) 用来识别。</p>

      <emu-note>
        <p>数值名称小于对应函数形式参数个数的整数索引数据属性初始与执行上下文中的参数绑定共享其值；修改其一会影响另一方。删除并重新定义该属性或将其改为访问器属性会打破这种对应。普通 arguments 对象的属性值仅是实参副本，不与形式参数动态联动。</p>
      </emu-note>
      <emu-note>
        <p>ParameterMap 对象及其属性值是描述 arguments 对象与参数绑定对应关系的机制；它们对 ECMAScript 代码不可直接观察，实现无需实际创建。</p>
      </emu-note>
      <emu-note>
        <p>普通 arguments 对象定义一个名为 *"callee"* 的不可配置访问器属性，访问时抛出 *TypeError*。在 arguments 特异对象上 *"callee"* 有更具体含义。普通变体的定义防止实现以其他方式定义它。</p>
      </emu-note>
      <emu-note>
        <p>历史上 arguments 特异对象实现包含 *"caller"* 访问器。ECMAScript 2017 之前规范在普通 arguments 对象上要求其抛出。此扩展已弃用，相关要求被移除。</p>
      </emu-note>

      <emu-clause id="sec-arguments-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回包含 Property Descriptor 或 *undefined* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _desc_ 为 OrdinaryGetOwnProperty(_args_, _P_)。
          1. 若 _desc_ 为 *undefined*，返回 *undefined*。
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 若 _isMapped_ 为 *true*，则
            1. 将 _desc_.[[Value]] 设为 ! Get(_map_, _P_)。
          1. 返回 _desc_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 令 _newArgDesc_ 为 _Desc_。
          1. 若 _isMapped_ 为 *true* 且 IsDataDescriptor(_Desc_) 为 *true*，则
            1. 若 _Desc_ 不含 [[Value]] 字段、含 [[Writable]] 字段且 _Desc_.[[Writable]] 为 *false*，则
              1. 将 _newArgDesc_ 设为 _Desc_ 的拷贝。
              1. 将 _newArgDesc_.[[Value]] 设为 ! Get(_map_, _P_)。
          1. 令 _allowed_ 为 ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_)。
          1. 若 _allowed_ 为 *false*，返回 *false*。
          1. 若 _isMapped_ 为 *true*，则
            1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，则
              1. 执行 ! _map_.[[Delete]](_P_)。
            1. 否则，
              1. 若 _Desc_ 含 [[Value]] 字段，则
                1. 断言：下面的 Set 会成功，因为被映射的形式参数总是可写。
                1. 执行 ! Set(_map_, _P_, _Desc_.[[Value]], *false*)。
              1. 若 _Desc_ 含 [[Writable]] 字段且 _Desc_.[[Writable]] 为 *false*，则
                1. 执行 ! _map_.[[Delete]](_P_)。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 若 _isMapped_ 为 *false*，则
            1. 返回 ? OrdinaryGet(_args_, _P_, _Receiver_)。
          1. 否则，
            1. 断言：_map_ 包含 _P_ 的形式参数映射。
            1. 返回 ! Get(_map_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 若 SameValue(_args_, _Receiver_) 为 *false*，则
            1. 令 _isMapped_ 为 *false*。
          1. 否则，
            1. 令 _map_ 为 _args_.[[ParameterMap]]。
            1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 若 _isMapped_ 为 *true*，则
            1. 断言：以下 Set 会成功，因为被映射形式参数总是可写。
            1. 执行 ! Set(_map_, _P_, _V_, *false*)。
          1. 返回 ? OrdinarySet(_args_, _P_, _V_, _Receiver_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arguments-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>arguments 特异对象 _args_</dd>
        </dl>
        <emu-alg>
          1. 令 _map_ 为 _args_.[[ParameterMap]]。
          1. 令 _isMapped_ 为 ! HasOwnProperty(_map_, _P_)。
          1. 令 _result_ 为 ? OrdinaryDelete(_args_, _P_)。
          1. 若 _result_ 为 *true* 且 _isMapped_ 为 *true*，则
            1. 执行 ! _map_.[[Delete]](_P_)。
          1. 返回 _result_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createunmappedargumentsobject" type="abstract operation">
        <h1>
          CreateUnmappedArgumentsObject (
            _argumentsList_: a List of ECMAScript language values,
          ): 一个普通对象
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _len_ 为 _argumentsList_ 中元素个数。
          1. 令 _obj_ 为 OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »)。
          1. 将 _obj_.[[ParameterMap]] 设为 *undefined*。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _len_ 重复：
            1. 令 _val_ 为 _argumentsList_[_index_]。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_)。
            1. 将 _index_ 设为 _index_ + 1。
          1. 执行 ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* })。
          1. 返回 _obj_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createmappedargumentsobject" type="abstract operation">
        <h1>
          CreateMappedArgumentsObject (
            _func_: an Object,
            _formals_: a Parse Node,
            _argumentsList_: a List of ECMAScript language values,
            _env_: an Environment Record,
          ): 一个 arguments 特异对象
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：_formals_ 不含 rest 参数、任何绑定模式或初始化器；可包含重复标识符。
          1. 令 _len_ 为 _argumentsList_ 元素个数。
          1. 令 _obj_ 为 MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »)。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-getownproperty-p"></emu-xref> 设置 _obj_.[[GetOwnProperty]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-defineownproperty-p-desc"></emu-xref> 设置 _obj_.[[DefineOwnProperty]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-get-p-receiver"></emu-xref> 设置 _obj_.[[Get]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-set-p-v-receiver"></emu-xref> 设置 _obj_.[[Set]]。
          1. 按 <emu-xref href="#sec-arguments-exotic-objects-delete-p"></emu-xref> 设置 _obj_.[[Delete]]。
          1. 将 _obj_.[[Prototype]] 设为 %Object.prototype%。
          1. 令 _map_ 为 OrdinaryObjectCreate(*null*)。
          1. 将 _obj_.[[ParameterMap]] 设为 _map_。
          1. 令 _parameterNames_ 为 _formals_ 的 BoundNames。
          1. 令 _numberOfParameters_ 为 _parameterNames_ 元素个数。
          1. 令 _index_ 为 0。
          1. 当 _index_ &lt; _len_ 重复：
            1. 令 _val_ 为 _argumentsList_[_index_]。
            1. 执行 ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_)。
            1. 将 _index_ 设为 _index_ + 1。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"length"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 令 _mappedNames_ 为新空列表。
          1. 将 _index_ 设为 _numberOfParameters_ - 1。
          1. 当 _index_ ≥ 0 重复：
            1. 令 _name_ 为 _parameterNames_[_index_]。
            1. 若 _mappedNames_ 不含 _name_，则
              1. 追加 _name_ 至 _mappedNames_。
              1. 若 _index_ &lt; _len_，则
                1. 令 _g_ 为 MakeArgGetter(_name_, _env_)。
                1. 令 _p_ 为 MakeArgSetter(_name_, _env_)。
                1. 执行 ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
            1. 将 _index_ 设为 _index_ - 1。
          1. 执行 ! DefinePropertyOrThrow(_obj_, %Symbol.iterator%, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 执行 ! DefinePropertyOrThrow(_obj_, *"callee"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* })。
          1. 返回 _obj_。
        </emu-alg>

        <emu-clause id="sec-makearggetter" type="abstract operation">
          <h1>
            MakeArgGetter (
              _name_: a String,
              _env_: an Environment Record,
            ): 一个函数对象
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>创建一个内置函数对象，执行时返回 _env_ 中对 _name_ 的绑定值。</dd>
          </dl>
          <emu-alg>
            1. 令 _getterClosure_ 为一个新的无参数 Abstract Closure，捕获 _name_ 与 _env_，调用时执行：
              1. 返回 NormalCompletion(! _env_.GetBindingValue(_name_, *false*))。
            1. 令 _getter_ 为 CreateBuiltinFunction(_getterClosure_, 0, *""*, « »)。
            1. 注：_getter_ 不会被 ECMAScript 代码直接访问。
            1. 返回 _getter_。
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-makeargsetter" type="abstract operation">
          <h1>
            MakeArgSetter (
              _name_: a String,
              _env_: an Environment Record,
            ): 一个函数对象
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>创建一个内置函数对象，执行时设置 _env_ 中 _name_ 的绑定值。</dd>
          </dl>
          <emu-alg>
            1. 令 _setterClosure_ 为一个带参数 (_value_) 的新 Abstract Closure，捕获 _name_ 与 _env_，调用时执行：
              1. 返回 NormalCompletion(! _env_.SetMutableBinding(_name_, _value_, *false*))。
            1. 令 _setter_ 为 CreateBuiltinFunction(_setterClosure_, 1, *""*, « »)。
            1. 注：_setter_ 不会被 ECMAScript 代码直接访问。
            1. 返回 _setter_。
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-exotic-objects" oldids="sec-integer-indexed-exotic-objects">
      <h1>TypedArray 特异对象 (TypedArray Exotic Objects)</h1>
      <p>TypedArray 是对规范数字字符串属性键做特殊处理的特异对象，使用其中属于界内整数索引的子集访问同类型元素，并在不遍历原型链的情况下确保其余索引缺失的不变式。</p>
      <emu-note>
        <p>由于对任意 Number _n_，ToString(_n_) 为规范数字字符串，实现可在无需真实字符串转换的情况下将 Number 当作属性键。</p>
      </emu-note>
      <p>TypedArrays 拥有普通对象的内部槽，并额外具有 [[ViewedArrayBuffer]]、[[TypedArrayName]]、[[ContentType]]、[[ByteLength]]、[[ByteOffset]]、[[ArrayLength]]。</p>
      <p>若对象的 [[PreventExtensions]]、[[GetOwnProperty]]、[[HasProperty]]、[[DefineOwnProperty]]、[[Get]]、[[Set]]、[[Delete]]、[[OwnPropertyKeys]] 内部方法使用本节定义，且其它基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 的定义，则其为 <dfn id="typedarray" oldids="integer-indexed-exotic-object" variants="TypedArrays">TypedArray</dfn>。这些方法由 TypedArrayCreate 安装。</p>

      <emu-clause id="sec-typedarray-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): 返回一个包含 Boolean 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 注：<emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 中的可扩展性不变式不允许在 _O_ 仍可能获得（或失去后再获得）属性时返回 *true*；当底层缓冲区重分配且涉及整数索引属性时可能发生该情况。
          1. 若 IsTypedArrayFixedLength(_O_) 为 *false*，返回 *false*。
          1. 返回 OrdinaryPreventExtensions(_O_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-getownproperty" oldids="sec-integer-indexed-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回包含 Property Descriptor 或 *undefined* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 令 _value_ 为 TypedArrayGetElement(_O_, _numericIndex_)。
              1. 若 _value_ 为 *undefined*，返回 *undefined*。
              1. 返回 PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }。
          1. 返回 OrdinaryGetOwnProperty(_O_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-hasproperty" oldids="sec-integer-indexed-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): 返回包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，返回 IsValidIntegerIndex(_O_, _numericIndex_)。
          1. 返回 ? OrdinaryHasProperty(_O_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-defineownproperty" oldids="sec-integer-indexed-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 若 IsValidIntegerIndex(_O_, _numericIndex_) 为 *false*，返回 *false*。
              1. 若 _Desc_ 有 [[Configurable]] 且为 *false*，返回 *false*。
              1. 若 _Desc_ 有 [[Enumerable]] 且为 *false*，返回 *false*。
              1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，返回 *false*。
              1. 若 _Desc_ 有 [[Writable]] 且为 *false*，返回 *false*。
              1. 若 _Desc_ 有 [[Value]] 字段，执行 ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]])。
              1. 返回 *true*。
          1. 返回 ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-get" oldids="sec-integer-indexed-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): 返回包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 返回 TypedArrayGetElement(_O_, _numericIndex_)。
          1. 返回 ? OrdinaryGet(_O_, _P_, _Receiver_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-set" oldids="sec-integer-indexed-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): 返回包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 若 SameValue(_O_, _Receiver_) 为 *true*，则
                1. 执行 ? TypedArraySetElement(_O_, _numericIndex_, _V_)。
                1. 返回 *true*。
              1. 若 IsValidIntegerIndex(_O_, _numericIndex_) 为 *false*，返回 *true*。
          1. 返回 ? OrdinarySet(_O_, _P_, _V_, _Receiver_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-delete" oldids="sec-integer-indexed-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): 返回包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 String，则
            1. 令 _numericIndex_ 为 CanonicalNumericIndexString(_P_)。
            1. 若 _numericIndex_ 不为 *undefined*，则
              1. 若 IsValidIntegerIndex(_O_, _numericIndex_) 为 *false*，返回 *true*；否则返回 *false*。
          1. 返回 ! OrdinaryDelete(_O_, _P_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-ownpropertykeys" oldids="sec-integer-indexed-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 返回包含属性键列表的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>TypedArray _O_</dd>
        </dl>
        <emu-alg>
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 令 _keys_ 为新空列表。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *false*，则
            1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
            1. 对每个整数 _i_（0 ≤ _i_ < _length_，升序）：
              1. 追加 ! ToString(𝔽(_i_)) 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 String 且不是整数索引，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 对 _O_ 的每个自身属性键 _P_（_P_ 为 Symbol，按创建时间升序）：
            1. 追加 _P_ 至 _keys_。
          1. 返回 _keys_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-with-buffer-witness-records" oldids="sec-integer-indexed-object-with-buffer-witness-records">
        <h1>带缓冲区见证记录的 TypedArray (TypedArray With Buffer Witness Records)</h1>
        <p><dfn variants="TypedArray With Buffer Witness Records">TypedArray With Buffer Witness Record</dfn> 是用于封装一个 TypedArray 及其被查看缓冲区缓存字节长度的 Record；当缓冲区为可增长 SharedArrayBuffer 时用于确保字节长度数据块的共享内存读取仅发生一次。</p>
        <p>其字段列于 <emu-xref href="#table-typedarray-with-buffer-witness-record-fields"></emu-xref>。</p>
        <emu-table id="table-typedarray-with-buffer-witness-record-fields" oldids="table-integer-indexed-object-with-buffer-witness-record-fields" caption="TypedArray With Buffer Witness Record 字段">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a TypedArray
              </td>
              <td>
                其缓冲区字节长度被加载的 TypedArray。
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                记录创建时对象 [[ViewedArrayBuffer]] 的字节长度。
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-maketypedarraywithbufferwitnessrecord" oldids="sec-makeintegerindexedobjectwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeTypedArrayWithBufferWitnessRecord (
            _obj_: a TypedArray,
            _order_: ~seq-cst~ or ~unordered~,
          ): 一个 TypedArray With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _buffer_ 为 _obj_.[[ViewedArrayBuffer]]。
          1. 若 IsDetachedBuffer(_buffer_) 为 *true*，则
            1. 令 _byteLength_ 为 ~detached~。
          1. 否则，
            1. 令 _byteLength_ 为 ArrayBufferByteLength(_buffer_, _order_)。
          1. 返回 TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraycreate" oldids="sec-integerindexedobjectcreate" type="abstract operation">
        <h1>
          TypedArrayCreate (
            _prototype_: an Object,
          ): 一个 TypedArray
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的 TypedArray。</dd>
        </dl>
        <emu-alg>
          1. 令 _internalSlotsList_ 为 « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] »。
          1. 令 _A_ 为 MakeBasicObject(_internalSlotsList_)。
          1. 按 <emu-xref href="#sec-typedarray-preventextensions"></emu-xref> 设置 _A_.[[PreventExtensions]]。
          1. 按 <emu-xref href="#sec-typedarray-getownproperty"></emu-xref> 设置 _A_.[[GetOwnProperty]]。
          1. 按 <emu-xref href="#sec-typedarray-hasproperty"></emu-xref> 设置 _A_.[[HasProperty]]。
          1. 按 <emu-xref href="#sec-typedarray-defineownproperty"></emu-xref> 设置 _A_.[[DefineOwnProperty]]。
          1. 按 <emu-xref href="#sec-typedarray-get"></emu-xref> 设置 _A_.[[Get]]。
          1. 按 <emu-xref href="#sec-typedarray-set"></emu-xref> 设置 _A_.[[Set]]。
          1. 按 <emu-xref href="#sec-typedarray-delete"></emu-xref> 设置 _A_.[[Delete]]。
          1. 按 <emu-xref href="#sec-typedarray-ownpropertykeys"></emu-xref> 设置 _A_.[[OwnPropertyKeys]]。
          1. 将 _A_.[[Prototype]] 设为 _prototype_。
          1. 返回 _A_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraybytelength" oldids="sec-integerindexedobjectbytelength" type="abstract operation">
        <h1>
          TypedArrayByteLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): 一个非负整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，返回 0。
          1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
          1. 若 _length_ = 0，返回 0。
          1. 令 _O_ 为 _taRecord_.[[Object]]。
          1. 若 _O_.[[ByteLength]] 不为 ~auto~，返回 _O_.[[ByteLength]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 返回 _length_ × _elementSize_。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraylength" oldids="sec-integerindexedobjectlength" type="abstract operation">
        <h1>
          TypedArrayLength (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): 一个非负整数
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 断言：IsTypedArrayOutOfBounds(_taRecord_) 为 *false*。
          1. 令 _O_ 为 _taRecord_.[[Object]]。
          1. 若 _O_.[[ArrayLength]] 不为 ~auto~，返回 _O_.[[ArrayLength]]。
          1. 断言：IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) 为 *false*。
          1. 令 _byteOffset_ 为 _O_.[[ByteOffset]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 令 _byteLength_ 为 _taRecord_.[[CachedBufferByteLength]]。
          1. 断言：_byteLength_ 不为 ~detached~。
          1. 返回 floor((_byteLength_ - _byteOffset_) / _elementSize_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayoutofbounds" oldids="sec-isintegerindexedobjectoutofbounds" type="abstract operation">
        <h1>
          IsTypedArrayOutOfBounds (
            _taRecord_: a TypedArray With Buffer Witness Record,
          ): 一个 Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>检查任一数值属性是否引用了底层缓冲区边界外的索引。</dd>
        </dl>
        <emu-alg>
          1. 令 _O_ 为 _taRecord_.[[Object]]。
          1. 令 _bufferByteLength_ 为 _taRecord_.[[CachedBufferByteLength]]。
          1. 断言：IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 为 *true* 当且仅当 _bufferByteLength_ 为 ~detached~。
          1. 若 _bufferByteLength_ 为 ~detached~，返回 *true*。
          1. 令 _byteOffsetStart_ 为 _O_.[[ByteOffset]]。
          1. 若 _O_.[[ArrayLength]] 为 ~auto~，则
            1. 令 _byteOffsetEnd_ 为 _bufferByteLength_。
          1. 否则，
            1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
            1. 令 _byteOffsetEnd_ 为 _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_。
          1. 若 _byteOffsetStart_ > _bufferByteLength_ 或 _byteOffsetEnd_ > _bufferByteLength_，返回 *true*。
          1. 注：长度为 0 的 TypedArray 不视为越界。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-istypedarrayfixedlength" type="abstract operation">
        <h1>
          IsTypedArrayFixedLength (
            _O_: a TypedArray,
          ): 一个 Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _O_.[[ArrayLength]] 为 ~auto~，返回 *false*。
          1. 令 _buffer_ 为 _O_.[[ViewedArrayBuffer]]。
          1. 若 IsFixedLengthArrayBuffer(_buffer_) 为 *false* 且 IsSharedArrayBuffer(_buffer_) 为 *false*，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isvalidintegerindex" type="abstract operation">
        <h1>
          IsValidIntegerIndex (
            _O_: a TypedArray,
            _index_: a Number,
          ): 一个 Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) 为 *true*，返回 *false*。
          1. 若 _index_ 不是整数 Number，返回 *false*。
          1. 若 _index_ 为 *-0*<sub>𝔽</sub> 或 _index_ &lt; *-0*<sub>𝔽</sub>，返回 *false*。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~)。
          1. 注：当 _O_ 的底层缓冲是可增长 SharedArrayBuffer 时，边界检查不是同步操作。
          1. 若 IsTypedArrayOutOfBounds(_taRecord_) 为 *true*，返回 *false*。
          1. 令 _length_ 为 TypedArrayLength(_taRecord_)。
          1. 若 ℝ(_index_) ≥ _length_，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraygetelement" oldids="sec-integerindexedelementget" type="abstract operation">
        <h1>
          TypedArrayGetElement (
            _O_: a TypedArray,
            _index_: a Number,
          ): a Number, a BigInt, 或 *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 IsValidIntegerIndex(_O_, _index_) 为 *false*，返回 *undefined*。
          1. 令 _offset_ 为 _O_.[[ByteOffset]]。
          1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
          1. 令 _byteIndexInBuffer_ 为 (ℝ(_index_) × _elementSize_) + _offset_。
          1. 令 _elementType_ 为 TypedArrayElementType(_O_)。
          1. 返回 GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarraysetelement" oldids="sec-integerindexedelementset" type="abstract operation">
        <h1>
          TypedArraySetElement (
            _O_: a TypedArray,
            _index_: a Number,
            _value_: an ECMAScript language value,
          ): 返回包含 ~unused~ 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _O_.[[ContentType]] 为 ~bigint~，令 _numValue_ 为 ? ToBigInt(_value_)；否则令 _numValue_ 为 ? ToNumber(_value_)。
          1. 若 IsValidIntegerIndex(_O_, _index_) 为 *true*，则
            1. 令 _offset_ 为 _O_.[[ByteOffset]]。
            1. 令 _elementSize_ 为 TypedArrayElementSize(_O_)。
            1. 令 _byteIndexInBuffer_ 为 (ℝ(_index_) × _elementSize_) + _offset_。
            1. 令 _elementType_ 为 TypedArrayElementType(_O_)。
            1. 执行 SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~)。
          1. 返回 ~unused~。
        </emu-alg>
        <emu-note>
          <p>此操作表面上总是成功；当写入越界或底层 ArrayBuffer 已分离时不产生效果。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-isarraybufferviewoutofbounds" type="abstract operation">
        <h1>
          IsArrayBufferViewOutOfBounds (
            _O_: a TypedArray or a DataView,
          ): 一个 Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>检查 TypedArray 的数值属性或 DataView 方法是否可能引用底层数据块范围之外的值；为上游规范提供便利。</dd>
        </dl>
        <emu-alg>
          1. 若 _O_ 具有 [[DataView]] 内部槽，则
            1. 令 _viewRecord_ 为 MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~)。
            1. 返回 IsViewOutOfBounds(_viewRecord_)。
          1. 令 _taRecord_ 为 MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~)。
          1. 返回 IsTypedArrayOutOfBounds(_taRecord_)。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-module-namespace-exotic-objects">
      <h1>模块命名空间特异对象 (Module Namespace Exotic Objects)</h1>
      <p>模块命名空间特异对象是一个暴露 ECMAScript |Module| 导出绑定的特异对象（见 <emu-xref href="#sec-exports"></emu-xref>）。其字符串键自身属性与该 |Module| 导出的绑定名一一对应，包括通过 `export *` 间接导出的绑定。每个字符串键属性的键即对应导出绑定名的 StringValue。这些是其全部字符串键属性。每个此类属性特性为 { [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }。模块命名空间特异对象不可扩展。</p>
      <p>若对象的 [[GetPrototypeOf]]、[[SetPrototypeOf]]、[[IsExtensible]]、[[PreventExtensions]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[HasProperty]]、[[Get]]、[[Set]]、[[Delete]]、[[OwnPropertyKeys]] 内部方法使用本节定义，且其它基本内部方法使用 <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref> 的定义，则其为 <dfn id="module-namespace-exotic-object" variants="module namespace exotic objects">模块命名空间特异对象</dfn>。这些方法由 ModuleNamespaceCreate 安装。</p>
      <p>模块命名空间特异对象具有 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref> 定义的内部槽。</p>
      <emu-table id="table-internal-slots-of-module-namespace-exotic-objects" caption="模块命名空间特异对象的内部槽 (Internal Slots of Module Namespace Exotic Objects)" oldids="table-29">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Module]]
            </td>
            <td>
              a Module Record
            </td>
            <td>
              此命名空间暴露其导出的 Module Record。
            </td>
          </tr>
          <tr>
            <td>
              [[Exports]]
            </td>
            <td>
              a List of Strings
            </td>
            <td>
              作为该对象自身属性暴露的导出名称字符串列表，按字典序代码单元顺序排序。
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-module-namespace-exotic-objects-getprototypeof" type="internal method">
        <h1>[[GetPrototypeOf]] ( ): 返回一个包含 *null* 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *null*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 返回 ! SetImmutablePrototype(_O_, _V_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-isextensible" type="internal method">
        <h1>[[IsExtensible]] ( ): 返回一个包含 *false* 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-preventextensions" type="internal method">
        <h1>[[PreventExtensions]] ( ): 返回一个包含 *true* 的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-getownproperty-p" type="internal method">
        <h1>
          [[GetOwnProperty]] (
            _P_: a property key,
          ): 返回一个包含 Property Descriptor 或 *undefined* 的正常完成，或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，返回 OrdinaryGetOwnProperty(_O_, _P_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 不含 _P_，返回 *undefined*。
          1. 令 _value_ 为 ? _O_.[[Get]](_P_, _O_)。
          1. 返回 PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-defineownproperty-p-desc" type="internal method">
        <h1>
          [[DefineOwnProperty]] (
            _P_: a property key,
            _Desc_: a Property Descriptor,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，返回 ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_)。
          1. 令 _current_ 为 ? _O_.[[GetOwnProperty]](_P_)。
          1. 若 _current_ 为 *undefined*，返回 *false*。
          1. 若 _Desc_ 有 [[Configurable]] 且为 *true*，返回 *false*。
          1. 若 _Desc_ 有 [[Enumerable]] 且为 *false*，返回 *false*。
          1. 若 IsAccessorDescriptor(_Desc_) 为 *true*，返回 *false*。
          1. 若 _Desc_ 有 [[Writable]] 且为 *false*，返回 *false*。
          1. 若 _Desc_ 有 [[Value]] 字段，返回 SameValue(_Desc_.[[Value]], _current_.[[Value]])。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-hasproperty-p" type="internal method">
        <h1>
          [[HasProperty]] (
            _P_: a property key,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，返回 ! OrdinaryHasProperty(_O_, _P_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 含 _P_，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，则
            1. 返回 ! OrdinaryGet(_O_, _P_, _Receiver_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 不含 _P_，返回 *undefined*。
          1. 令 _m_ 为 _O_.[[Module]]。
          1. 令 _binding_ 为 _m_.ResolveExport(_P_)。
          1. 断言：_binding_ 是 ResolvedBinding Record。
          1. 令 _targetModule_ 为 _binding_.[[Module]]。
          1. 断言：_targetModule_ 不为 *undefined*。
          1. 若 _binding_.[[BindingName]] 为 ~namespace~，则
            1. 返回 GetModuleNamespace(_targetModule_)。
          1. 令 _targetEnv_ 为 _targetModule_.[[Environment]]。
          1. 若 _targetEnv_ 为 ~empty~，抛出 *ReferenceError* 异常。
          1. 返回 ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*)。
        </emu-alg>
        <emu-note>
          <p>ResolveExport 无副作用；对相同参数组合多次调用结果必须一致。实现可预先计算或缓存每个命名空间对象 [[Exports]] 的 ResolveExport 结果。</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): 返回一个包含 *false* 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象</dd>
        </dl>
        <emu-alg>
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-delete-p" type="internal method">
        <h1>
          [[Delete]] (
            _P_: a property key,
          ): 返回一个包含 Boolean 的正常完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 若 _P_ 是 Symbol，则
            1. 返回 ! OrdinaryDelete(_O_, _P_)。
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 若 _exports_ 含 _P_，返回 *false*。
          1. 返回 *true*。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects-ownpropertykeys" type="internal method">
        <h1>[[OwnPropertyKeys]] ( ): 返回一个包含属性键列表的正常完成</h1>
        <dl class="header">
          <dt>for</dt>
          <dd>模块命名空间特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 令 _exports_ 为 _O_.[[Exports]]。
          1. 令 _symbolKeys_ 为 OrdinaryOwnPropertyKeys(_O_)。
          1. 返回 _exports_ 与 _symbolKeys_ 的列表连接结果。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulenamespacecreate" type="abstract operation">
        <h1>
          ModuleNamespaceCreate (
            _module_: a Module Record,
            _exports_: a List of Strings,
          ): 一个模块命名空间特异对象
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>用于指定创建新的模块命名空间特异对象。</dd>
        </dl>
        <emu-alg>
          1. 断言：_module_.[[Namespace]] 为 ~empty~。
          1. 令 _internalSlotsList_ 为 <emu-xref href="#table-internal-slots-of-module-namespace-exotic-objects"></emu-xref> 中列出的内部槽列表。
          1. 令 _M_ 为 MakeBasicObject(_internalSlotsList_)。
          1. 将 _M_ 的基本内部方法设为 <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> 中的定义。
          1. 将 _M_.[[Module]] 设为 _module_。
          1. 令 _sortedExports_ 为对 _exports_ 元素按字典序代码单元排序后的列表。
          1. 将 _M_.[[Exports]] 设为 _sortedExports_。
          1. 创建 _M_ 的自身属性以对应 <emu-xref href="#sec-module-namespace-objects"></emu-xref> 中的定义。
          1. 将 _module_.[[Namespace]] 设为 _M_。
          1. 返回 _M_。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-immutable-prototype-exotic-objects">
      <h1>不可变原型特异对象 (Immutable Prototype Exotic Objects)</h1>
      <p>不可变原型特异对象是其 [[Prototype]] 内部槽一旦初始化即不再改变的特异对象。</p>

      <p>若对象的 [[SetPrototypeOf]] 内部方法使用以下实现（其它基本内部方法可视具体对象采用任意实现），则该对象是 <dfn id="immutable-prototype-exotic-object" variants="immutable prototype exotic objects">不可变原型特异对象</dfn>。</p>

      <emu-note>
        <p>与其它特异对象不同，不可变原型特异对象没有专门的创建抽象操作；因它们仅用于 %Object.prototype% 与宿主环境，宿主环境中相关对象可能在其它方面也是特异的，需单独的创建过程。</p>
      </emu-note>

      <emu-clause id="sec-immutable-prototype-exotic-objects-setprototypeof-v" type="internal method">
        <h1>
          [[SetPrototypeOf]] (
            _V_: an Object or *null*,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>不可变原型特异对象 _O_</dd>
        </dl>
        <emu-alg>
          1. 返回 ? SetImmutablePrototype(_O_, _V_)。
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set-immutable-prototype" type="abstract operation">
        <h1>
          SetImmutablePrototype (
            _O_: an Object,
            _V_: an Object or *null*,
          ): 返回一个包含 Boolean 的正常完成或一个抛出完成
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 令 _current_ 为 ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>()。
          1. 若 SameValue(_V_, _current_) 为 *true*，返回 *true*。
          1. 返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
    <h1>Proxy 对象的内部方法与内部槽 (Proxy Object Internal Methods and Internal Slots)</h1>
    <p>Proxy 对象是一种特异对象，其关键内部方法部分由 ECMAScript 代码实现。每个 Proxy 对象都有名为 [[ProxyHandler]] 的内部槽。[[ProxyHandler]] 的值要么是一个对象（称为该 proxy 的 <em>handler 对象</em>），要么是 *null*。handler 对象的方法（见 <emu-xref href="#table-proxy-handler-methods"></emu-xref>）可用于增强一个或多个 Proxy 内部方法的实现。每个 Proxy 对象还具有名为 [[ProxyTarget]] 的内部槽，其值是一个对象或 *null*。该对象称为 proxy 的 <em>target 对象</em>。</p>

    <p>若一个对象的关键内部方法（若适用包括 [[Call]] 与 [[Construct]]）使用本节的定义，则该对象为 <dfn id="proxy-exotic-object" variants="Proxy exotic objects">Proxy 特异对象</dfn>。这些内部方法在 ProxyCreate 中安装。</p>

    <emu-table id="table-proxy-handler-methods" caption="Proxy 处理器方法 (Proxy Handler Methods)" oldids="table-30">
      <table>
        <thead>
          <tr>
            <th>
              内部方法 (Internal Method)
            </th>
            <th>
              处理器方法 (Handler Method)
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[GetPrototypeOf]]
          </td>
          <td>
            `getPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[SetPrototypeOf]]
          </td>
          <td>
            `setPrototypeOf`
          </td>
        </tr>
        <tr>
          <td>
            [[IsExtensible]]
          </td>
          <td>
            `isExtensible`
          </td>
        </tr>
        <tr>
          <td>
            [[PreventExtensions]]
          </td>
          <td>
            `preventExtensions`
          </td>
        </tr>
        <tr>
          <td>
            [[GetOwnProperty]]
          </td>
          <td>
            `getOwnPropertyDescriptor`
          </td>
        </tr>
        <tr>
          <td>
            [[DefineOwnProperty]]
          </td>
          <td>
            `defineProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[HasProperty]]
          </td>
          <td>
            `has`
          </td>
        </tr>
        <tr>
          <td>
            [[Get]]
          </td>
          <td>
            `get`
          </td>
        </tr>
        <tr>
          <td>
            [[Set]]
          </td>
          <td>
            `set`
          </td>
        </tr>
        <tr>
          <td>
            [[Delete]]
          </td>
          <td>
            `deleteProperty`
          </td>
        </tr>
        <tr>
          <td>
            [[OwnPropertyKeys]]
          </td>
          <td>
            `ownKeys`
          </td>
        </tr>
        <tr>
          <td>
            [[Call]]
          </td>
          <td>
            `apply`
          </td>
        </tr>
        <tr>
          <td>
            [[Construct]]
          </td>
          <td>
            `construct`
          </td>
        </tr>
      </table>
    </emu-table>
    <p>当调用某个 handler 方法以提供 Proxy 内部方法的实现时，会将该 proxy 的 target 对象作为参数传入。handler 对象不一定具备每个关键内部方法对应的 trap；如果缺少对应 trap，则在 proxy 上调用该内部方法会转发到 target 对象上的对应内部方法。</p>
    <p>Proxy 对象的 [[ProxyHandler]] 与 [[ProxyTarget]] 内部槽在创建时总被初始化，通常不可再修改。某些 Proxy 被创建为可随后被 <em>撤销（revoked）</em>。当一个 proxy 被撤销时，其 [[ProxyHandler]] 与 [[ProxyTarget]] 被设为 *null*，使得后续对该 Proxy 的内部方法调用抛出 *TypeError* 异常。</p>
    <p>由于 Proxy 允许内部方法实现由任意 ECMAScript 代码提供，可能定义出其 handler 方法违反 <emu-xref href="#sec-invariants-of-the-essential-internal-methods"></emu-xref> 中不变式的 Proxy。该处定义的一些内部方法不变式是关键完整性不变式；本节给出的 Proxy 内部方法会显式强制这些不变式。ECMAScript 实现必须在所有可能的不变式违例情况下保持健壮。</p>
    <p>以下算法中，假设 _O_ 为一个 ECMAScript Proxy 对象，_P_ 为属性键值，_V_ 为任意 ECMAScript 语言值，_Desc_ 为一个 Property Descriptor 记录。</p>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getprototypeof" type="internal method">
      <h1>[[GetPrototypeOf]] ( ): 返回一个包含 Object 或 *null* 的正常完成，或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"getPrototypeOf"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>()。
        1. 令 _handlerProto_ 为 ? Call(_trap_, _handler_, « _target_ »)。
        1. 若 _handlerProto_ 既不是 Object 且也不是 *null*，抛出 *TypeError* 异常。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _extensibleTarget_ 为 *true*，返回 _handlerProto_。
        1. 令 _targetProto_ 为 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>()。
        1. 若 SameValue(_handlerProto_, _targetProto_) 为 *false*，抛出 *TypeError* 异常。
        1. 返回 _handlerProto_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[GetPrototypeOf]] 强制以下不变式：</p>
        <ul>
          <li>
            结果必须是 Object 或 *null*。
          </li>
          <li>
            若 target 不可扩展，对 Proxy 调用 [[GetPrototypeOf]] 的结果须与对其 target 调用的结果相同。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-setprototypeof-v" type="internal method">
      <h1>
        [[SetPrototypeOf]] (
          _V_: an Object or *null*,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"setPrototypeOf"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_V_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _extensibleTarget_ 为 *true*，返回 *true*。
        1. 令 _targetProto_ 为 ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]</emu-meta>()。
        1. 若 SameValue(_V_, _targetProto_) 为 *false*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[SetPrototypeOf]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是一个 Boolean。
          </li>
          <li>
            若 target 不可扩展，参数值必须与对 target 调用 [[GetPrototypeOf]] 的结果相同。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-isextensible" type="internal method">
      <h1>[[IsExtensible]] ( ): 返回一个包含 Boolean 的正常完成或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"isExtensible"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? IsExtensible(_target_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_ »))。
        1. 令 _targetResult_ 为 ? IsExtensible(_target_)。
        1. 若 _booleanTrapResult_ 不等于 _targetResult_，抛出 *TypeError* 异常。
        1. 返回 _booleanTrapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[IsExtensible]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是 Boolean。
          </li>
          <li>
            对 Proxy 的调用结果必须与对其 target 的调用结果一致。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-preventextensions" type="internal method">
      <h1>[[PreventExtensions]] ( ): 返回一个包含 Boolean 的正常完成或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"preventExtensions"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta>。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_ »))。
        1. 若 _booleanTrapResult_ 为 *true*，则
          1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
          1. 若 _extensibleTarget_ 为 *true*，抛出 *TypeError* 异常。
        1. 返回 _booleanTrapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[PreventExtensions]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是 Boolean。
          </li>
          <li>
            仅当 target 的 [[IsExtensible]] 为 *false* 时才可返回 *true*。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-getownproperty-p" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): 返回一个包含 Property Descriptor 或 *undefined* 的正常完成，或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"getOwnPropertyDescriptor"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 令 _trapResultObj_ 为 ? Call(_trap_, _handler_, « _target_, _P_ »)。
        1. 若 _trapResultObj_ 不是 Object 且也不是 *undefined*，抛出 *TypeError* 异常。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _trapResultObj_ 为 *undefined*，则
          1. 若 _targetDesc_ 为 *undefined*，返回 *undefined*。
          1. 若 _targetDesc_.[[Configurable]] 为 *false*，抛出 *TypeError* 异常。
          1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
          1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
          1. 返回 *undefined*。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 令 _resultDesc_ 为 ? ToPropertyDescriptor(_trapResultObj_)。
        1. 执行 CompletePropertyDescriptor(_resultDesc_)。
        1. 令 _valid_ 为 IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_)。
        1. 若 _valid_ 为 *false*，抛出 *TypeError* 异常。
        1. 若 _resultDesc_.[[Configurable]] 为 *false*，则
          1. 若 _targetDesc_ 为 *undefined* 或 _targetDesc_.[[Configurable]] 为 *true*，则
            1. 抛出 *TypeError* 异常。
          1. 若 _resultDesc_ 含 [[Writable]] 且 _resultDesc_.[[Writable]] 为 *false*，则
            1. 断言：_targetDesc_ 含 [[Writable]]。
            1. 若 _targetDesc_.[[Writable]] 为 *true*，抛出 *TypeError* 异常。
        1. 返回 _resultDesc_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[GetOwnProperty]] 强制以下不变式：</p>
        <ul>
          <li>
            结果必须是 Object 或 *undefined*。
          </li>
          <li>
            若 target 上存在一个不可配置自身属性，不得报告其不存在。
          </li>
          <li>
            若 target 不可扩展且存在该自身属性，不得报告其不存在。
          </li>
          <li>
            若 target 不可扩展且不存在该自身属性，不得报告其存在。
          </li>
          <li>
            不得报告某属性为不可配置，除非它在 target 上为不可配置自身属性。
          </li>
          <li>
            不得同时报告某属性为不可配置且不可写，除非它在 target 上为不可配置且不可写自身属性。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-defineownproperty-p-desc" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"defineProperty"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_)。
        1. 令 _descObj_ 为 FromPropertyDescriptor(_Desc_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _Desc_ 含 [[Configurable]] 且 _Desc_.[[Configurable]] 为 *false*，则
          1. 令 _settingConfigFalse_ 为 *true*。
        1. 否则，
          1. 令 _settingConfigFalse_ 为 *false*。
        1. 若 _targetDesc_ 为 *undefined*，则
          1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
          1. 若 _settingConfigFalse_ 为 *true*，抛出 *TypeError* 异常。
        1. 否则，
          1. 若 IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) 为 *false*，抛出 *TypeError* 异常。
          1. 若 _settingConfigFalse_ 为 *true* 且 _targetDesc_.[[Configurable]] 为 *true*，抛出 *TypeError* 异常。
          1. 若 IsDataDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Configurable]] 为 *false* 且 _targetDesc_.[[Writable]] 为 *true*，则
            1. 若 _Desc_ 含 [[Writable]] 且 _Desc_.[[Writable]] 为 *false*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[DefineOwnProperty]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若 target 不可扩展，不得添加新属性。
          </li>
          <li>
            不得创建不可配置属性，除非 target 上已有对应不可配置自身属性。
          </li>
          <li>
            不得创建既不可配置又不可写属性，除非 target 上已有对应不可配置且不可写自身属性。
          </li>
          <li>
            若属性在 target 上已有对应属性，则用给定描述符通过 [[DefineOwnProperty]] 作用于 target 不会抛出异常。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-hasproperty-p" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"has"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_P_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，则
          1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
          1. 若 _targetDesc_ 不为 *undefined*，则
            1. 若 _targetDesc_.[[Configurable]] 为 *false*，抛出 *TypeError* 异常。
            1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
            1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
        1. 返回 _booleanTrapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[HasProperty]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若 target 上存在不可配置自身属性，不得报告其不存在。
          </li>
          <li>
            若 target 不可扩展且存在该自身属性，不得报告其不存在。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"get"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_P_, _Receiver_)。
        1. 令 _trapResult_ 为 ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »)。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _targetDesc_ 不为 *undefined* 且 _targetDesc_.[[Configurable]] 为 *false*，则
          1. 若 IsDataDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Writable]] 为 *false*，则
            1. 若 SameValue(_trapResult_, _targetDesc_.[[Value]]) 为 *false*，抛出 *TypeError* 异常。
          1. 若 IsAccessorDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Get]] 为 *undefined*，则
            1. 若 _trapResult_ 不为 *undefined*，抛出 *TypeError* 异常。
        1. 返回 _trapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[Get]] 强制以下不变式：</p>
        <ul>
          <li>
            若 target 上对应属性为不可写、不可配置的自身数据属性，则读取结果必须与其值相同。
          </li>
          <li>
            若 target 上对应属性为不可配置自身访问器属性且其 [[Get]] 为 *undefined*，则读取结果必须为 *undefined*。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"set"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _targetDesc_ 不为 *undefined* 且 _targetDesc_.[[Configurable]] 为 *false*，则
          1. 若 IsDataDescriptor(_targetDesc_) 为 *true* 且 _targetDesc_.[[Writable]] 为 *false*，则
            1. 若 SameValue(_V_, _targetDesc_.[[Value]]) 为 *false*，抛出 *TypeError* 异常。
          1. 若 IsAccessorDescriptor(_targetDesc_) 为 *true*，则
            1. 若 _targetDesc_.[[Set]] 为 *undefined*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[Set]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若 target 上对应属性为不可写且不可配置的数据属性，不得改为不同的值。
          </li>
          <li>
            若 target 上对应属性为不可配置自身访问器属性且其 [[Set]] 为 *undefined*，不得设置该属性值。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-delete-p" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): 返回一个包含 Boolean 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"deleteProperty"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_P_)。
        1. 令 _booleanTrapResult_ 为 ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »))。
        1. 若 _booleanTrapResult_ 为 *false*，返回 *false*。
        1. 令 _targetDesc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_)。
        1. 若 _targetDesc_ 为 *undefined*，返回 *true*。
        1. 若 _targetDesc_.[[Configurable]] 为 *false*，抛出 *TypeError* 异常。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 若 _extensibleTarget_ 为 *false*，抛出 *TypeError* 异常。
        1. 返回 *true*。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[Delete]] 强制以下不变式：</p>
        <ul>
          <li>
            结果为 Boolean。
          </li>
          <li>
            若属性在 target 上是不可配置自身属性，不得报告其已删除。
          </li>
          <li>
            若属性在 target 上是自身属性且 target 不可扩展，不得报告其已删除。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-ownpropertykeys" type="internal method">
      <h1>[[OwnPropertyKeys]] ( ): 返回一个包含属性键列表的正常完成或一个抛出完成</h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"ownKeys"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>。
        1. 令 _trapResultArray_ 为 ? Call(_trap_, _handler_, « _target_ »)。
        1. 令 _trapResult_ 为 ? CreateListFromArrayLike(_trapResultArray_, ~property-key~)。
        1. 若 _trapResult_ 含任何重复项，抛出 *TypeError* 异常。
        1. 令 _extensibleTarget_ 为 ? IsExtensible(_target_)。
        1. 令 _targetKeys_ 为 ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>。
        1. 断言：_targetKeys_ 是属性键列表。
        1. 断言：_targetKeys_ 不含重复项。
        1. 令 _targetConfigurableKeys_ 为新空列表。
        1. 令 _targetNonconfigurableKeys_ 为新空列表。
        1. 对 _targetKeys_ 中每个元素 _key_：
          1. 令 _desc_ 为 ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_)。
          1. 若 _desc_ 不为 *undefined* 且 _desc_.[[Configurable]] 为 *false*，则
            1. 将 _key_ 追加至 _targetNonconfigurableKeys_。
          1. 否则，
            1. 将 _key_ 追加至 _targetConfigurableKeys_。
        1. 若 _extensibleTarget_ 为 *true* 且 _targetNonconfigurableKeys_ 为空，则
          1. 返回 _trapResult_。
        1. 令 _uncheckedResultKeys_ 为包含 _trapResult_ 各元素的新列表。
        1. 对 _targetNonconfigurableKeys_ 中每个 _key_：
          1. 若 _uncheckedResultKeys_ 不含 _key_，抛出 *TypeError* 异常。
          1. 从 _uncheckedResultKeys_ 移除 _key_。
        1. 若 _extensibleTarget_ 为 *true*，返回 _trapResult_。
        1. 对 _targetConfigurableKeys_ 中每个 _key_：
          1. 若 _uncheckedResultKeys_ 不含 _key_，抛出 *TypeError* 异常。
          1. 从 _uncheckedResultKeys_ 移除 _key_。
        1. 若 _uncheckedResultKeys_ 非空，抛出 *TypeError* 异常。
        1. 返回 _trapResult_。
      </emu-alg>
      <emu-note>
        <p>Proxy 的 [[OwnPropertyKeys]] 强制以下不变式：</p>
        <ul>
          <li>
            结果是一个列表。
          </li>
          <li>
            返回列表不含重复项。
          </li>
          <li>
            列表中每个元素都是属性键。
          </li>
          <li>
            列表必须包含 target 所有不可配置自身属性的键。
          </li>
          <li>
            若 target 不可扩展，则列表必须精确包含其全部自身属性键且不含其他值。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): 返回一个包含 ECMAScript 语言值的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"apply"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? Call(_target_, _thisArgument_, _argumentsList_)。
        1. 令 _argArray_ 为 CreateArrayFromList(_argumentsList_)。
        1. 返回 ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ »)。
      </emu-alg>
      <emu-note>
        <p>仅当 [[ProxyTarget]] 初始值是一个具有 [[Call]] 内部方法的对象时，Proxy 特异对象才具有 [[Call]]。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        ): 返回一个包含 Object 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>Proxy 特异对象 _O_</dd>
      </dl>
      <emu-alg>
        1. 执行 ? ValidateNonRevokedProxy(_O_)。
        1. 令 _target_ 为 _O_.[[ProxyTarget]]。
        1. 断言：IsConstructor(_target_) 为 *true*。
        1. 令 _handler_ 为 _O_.[[ProxyHandler]]。
        1. 断言：_handler_ 是一个 Object。
        1. 令 _trap_ 为 ? GetMethod(_handler_, *"construct"*)。
        1. 若 _trap_ 为 *undefined*，则
          1. 返回 ? Construct(_target_, _argumentsList_, _newTarget_)。
        1. 令 _argArray_ 为 CreateArrayFromList(_argumentsList_)。
        1. 令 _newObj_ 为 ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ »)。
        1. 若 _newObj_ 不是 Object，抛出 *TypeError* 异常。
        1. 返回 _newObj_。
      </emu-alg>
      <emu-note>
        <p>仅当 [[ProxyTarget]] 初始值是一个具有 [[Construct]] 内部方法的对象时，Proxy 特异对象才具有 [[Construct]]。</p>
      </emu-note>
      <emu-note>
        <p>Proxy 的 [[Construct]] 强制以下不变式：</p>
        <ul>
          <li>
            结果必须是一个 Object。
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-validatenonrevokedproxy" type="abstract operation">
      <h1>
        ValidateNonRevokedProxy (
          _proxy_: a Proxy exotic object,
        ): 返回一个包含 ~unused~ 的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>若 _proxy_ 已被撤销则抛出 *TypeError* 异常。</dd>
      </dl>
      <emu-alg>
        1. 若 _proxy_.[[ProxyTarget]] 为 *null*，抛出 *TypeError* 异常。
        1. 断言：_proxy_.[[ProxyHandler]] 不为 *null*。
        1. 返回 ~unused~。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-proxycreate" type="abstract operation">
      <h1>
        ProxyCreate (
          _target_: an ECMAScript language value,
          _handler_: an ECMAScript language value,
        ): 返回一个包含 Proxy 特异对象的正常完成或一个抛出完成
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>用于指定创建新的 Proxy 对象。</dd>
      </dl>
      <emu-alg>
        1. 若 _target_ 不是 Object，抛出 *TypeError* 异常。
        1. 若 _handler_ 不是 Object，抛出 *TypeError* 异常。
        1. 令 _P_ 为 MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »)。
        1. 设置 _P_ 的关键内部方法（除 [[Call]] 与 [[Construct]]）为 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots"></emu-xref> 中的定义。
        1. 若 IsCallable(_target_) 为 *true*，则
          1. 按 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist"></emu-xref> 设置 _P_.[[Call]]。
          1. 若 IsConstructor(_target_) 为 *true*，则
            1. 按 <emu-xref href="#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget"></emu-xref> 设置 _P_.[[Construct]]。
        1. 将 _P_.[[ProxyTarget]] 设为 _target_。
        1. 将 _P_.[[ProxyHandler]] 设为 _handler_。
        1. 返回 _P_。
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-source-code">
  <h1>ECMAScript 语言：源码文本 (ECMAScript Language: Source Text)</h1>

  <emu-clause id="sec-source-text">
    <h1>源码文本 (Source Text)</h1>
    <h2>语法 (Syntax)</h2>
    <emu-grammar type="definition">
      SourceCharacter ::
        &gt; 任意 Unicode 码点 (any Unicode code point)
    </emu-grammar>
    <p><dfn>ECMAScript 源码文本 (ECMAScript source text)</dfn> 是一串 Unicode 码点。所有从 U+0000 到 U+10FFFF 的 Unicode 码点值（包括代理项码点 surrogate code points）在 ECMAScript 语法允许的地方都可以出现在 ECMAScript 源码文本中。用于存储与交换 ECMAScript 源码文本的实际编码方式与本规范无关。无论外部源码的字符编码为何，符合规范的 ECMAScript 实现都按其等价的 |SourceCharacter| 序列来处理源码文本，每个 |SourceCharacter| 即一个 Unicode 码点。符合规范的实现不需要对源码文本进行任何规范化，也不需要表现得仿佛进行了规范化。</p>
    <p>组合字符序列 (combining character sequence) 的各组成部分被分别当作单独的 Unicode 码点对待，即便用户可能把整个序列视为一个字符。</p>
    <emu-note>
      <p>在字符串字面量、正则表达式字面量、模板字面量与标识符中，任意 Unicode 码点也可以通过显式表示其数值的 Unicode 转义序列来书写。在注释中，这样的转义序列被视为注释的一部分而等效忽略。</p>
      <p>在 Unicode 转义序列的行为上，ECMAScript 与 Java 编程语言不同。在 Java 程序中，如果 Unicode 转义序列 `\\u000A`（例如）出现在单行注释内，它会被解释为行终止符（U+000A 是 LINE FEED (LF)），因此下一个码点不再属于该注释。同样地，如果 `\\u000A` 出现在 Java 的字符串字面量中，它也被视为行终止符；行终止符不允许出现在字符串字面量内部——必须写作 `\\n` 而不是 `\\u000A` 才能使 LF 成为字符串值的一部分。在 ECMAScript 程序中，注释里的 Unicode 转义序列从不被解释，因此不会导致注释终止。类似地，ECMAScript 程序中字符串字面量里的 Unicode 转义序列始终贡献其字面意义，绝不会被解释成行终止符或可能终止字符串字面量的码点。</p>
    </emu-note>

    <emu-clause id="sec-utf16encodecodepoint" type="abstract operation" oldids="sec-utf16encoding,sec-codepointtoutf16codeunits">
      <h1>
        静态语义：UTF16EncodeCodePoint (
          _cp_: a Unicode code point,
        ): a String
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 断言：0 ≤ _cp_ ≤ 0x10FFFF。
        1. 若 _cp_ ≤ 0xFFFF，返回由数值为 _cp_ 的代码单元组成的 String 值。
        1. 令 _cu1_ 为数值为 floor((_cp_ - 0x10000) / 0x400) + 0xD800 的代码单元。
        1. 令 _cu2_ 为数值为 ((_cp_ - 0x10000) modulo 0x400) + 0xDC00 的代码单元。
        1. 返回 _cu1_ 与 _cu2_ 的字符串连接。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointstostring" type="abstract operation" oldids="sec-utf16encode">
      <h1>
        静态语义：CodePointsToString (
          _text_: a sequence of Unicode code points,
        ): a String
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将 _text_ 按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 所述转换为一个 String 值。</dd>
      </dl>
      <emu-alg>
        1. 令 _result_ 为空字符串。
        1. 对 _text_ 的每个码点 _cp_，执行
          1. 将 _result_ 设为 _result_ 与 UTF16EncodeCodePoint(_cp_) 的字符串连接。
        1. 返回 _result_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-utf16decodesurrogatepair" type="abstract operation" oldids="sec-utf16decode,utf16decodesurrogatepair">
      <h1>
        静态语义：UTF16SurrogatePairToCodePoint (
          _lead_: a code unit,
          _trail_: a code unit,
        ): a code point
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>将组成 UTF-16 代理项对的两个代码单元转换为一个码点。</dd>
      </dl>
      <emu-alg>
        1. 断言：_lead_ 是前导代理项 (leading surrogate) 且 _trail_ 是尾随代理项 (trailing surrogate)。
        1. 令 _cp_ 为 (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000。
        1. 返回码点 _cp_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-codepointat" type="abstract operation">
      <h1>
        静态语义：CodePointAt (
          _string_: a String,
          _position_: a non-negative integer,
        ): a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 所述将 _string_ 解释为 UTF-16 编码的码点序列，并从索引 _position_ 的代码单元开始读取单个码点。</dd>
      </dl>
      <emu-alg>
        1. 令 _size_ 为 _string_ 的长度。
        1. 断言：_position_ ≥ 0 且 _position_ &lt; _size_。
        1. 令 _first_ 为 _string_ 中索引 _position_ 的代码单元。
        1. 令 _cp_ 为数值等于 _first_ 数值的码点。
        1. 若 _first_ 既不是前导代理项也不是尾随代理项，则
          1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }。
        1. 若 _first_ 是尾随代理项或 _position_ + 1 = _size_，则
          1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }。
        1. 令 _second_ 为 _string_ 中索引 _position_ + 1 的代码单元。
        1. 若 _second_ 不是尾随代理项，则
          1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }。
        1. 将 _cp_ 设为 UTF16SurrogatePairToCodePoint(_first_, _second_)。
        1. 返回 Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-stringtocodepoints" type="abstract operation" oldids="sec-utf16decodestring">
      <h1>
        静态语义：StringToCodePoints (
          _string_: a String,
        ): a List of code points
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>返回将 _string_ 按 <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref> 作为 UTF-16 编码 Unicode 文本解释后得到的 Unicode 码点序列。</dd>
      </dl>
      <emu-alg>
        1. 令 _codePoints_ 为一个新的空 List。
        1. 令 _size_ 为 _string_ 的长度。
        1. 令 _position_ 为 0。
        1. 当 _position_ &lt; _size_ 循环：
          1. 令 _cp_ 为 CodePointAt(_string_, _position_)。
          1. 将 _cp_.[[CodePoint]] 追加到 _codePoints_。
          1. 将 _position_ 设为 _position_ + _cp_.[[CodeUnitCount]]。
        1. 返回 _codePoints_。
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-parsetext" type="abstract operation">
      <h1>
        静态语义：ParseText (
          _sourceText_: a String or a sequence of Unicode code points,
          _goalSymbol_: a nonterminal in one of the ECMAScript grammars,
        ): a Parse Node or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. 若 _sourceText_ 是 String，则将 _sourceText_ 设为 StringToCodePoints(_sourceText_)。
        1. 试图以 _goalSymbol_ 为目标符号解析 _sourceText_，并分析解析结果中的任何提前错误 (early error) 条件。解析与提前错误检测可按实现自定义方式交错进行。
        1. 若解析成功且未发现提前错误，返回解析生成的 parse tree 根部的 Parse Node（_goalSymbol_ 的一个实例）。
        1. 否则，返回一个包含一个或多个 *SyntaxError* 对象的 List，表示语法错误和/或提前错误。若存在多个错误，其数量与顺序由实现定义，但至少要有一个。
      </emu-alg>
      <emu-note>
        <p>考虑某段文本在某处有一个提前错误，在其后又有语法错误。一个先解析后检测提前错误的实现可能只报告语法错误而未继续提前错误阶段。一个交错实现可能报告提前错误而不再寻找语法错误。第三种实现可能两者都报告。以上行为都符合规范。</p>
      </emu-note>
      <emu-note>
        <p>另见 <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref> 条款。</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-types-of-source-code">
    <h1>源码类型 (Types of Source Code)</h1>
    <p>ECMAScript 代码有四种类型：</p>
    <ul>
      <li>
        <dfn>全局代码 (Global code)</dfn> 是作为 ECMAScript |Script| 处理的源码文本。某个 |Script| 的全局代码不包含被解析为 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction|、|AsyncArrowFunction|、|ClassDeclaration| 或 |ClassExpression| 的任何源码。
      </li>
      <li>
        <dfn>Eval 代码 (Eval code)</dfn> 是传给内置 `eval` 函数的源码文本。更精确地说，如果传给内置 `eval` 的参数是 String，则其被视作 ECMAScript |Script|。一次特定 `eval` 调用的 eval 代码即该 |Script| 的全局代码部分。
      </li>
      <li>
        <p><dfn>函数代码 (Function code)</dfn> 是被解析以提供 ECMAScript 函数对象 [[ECMAScriptCode]] 与 [[FormalParameters]] 内部槽（见 <emu-xref href="#sec-ecmascript-function-objects"></emu-xref>）值的源码。某个函数的函数代码不包含被解析为内嵌 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction|、|AsyncArrowFunction|、|ClassDeclaration| 或 |ClassExpression| 的源码。</p>
        <p>此外，如果上述引用的源码被解析为：</p>
        <ul>
          <li>|FunctionDeclaration| 或 |FunctionExpression| 的 |FormalParameters| 与 |FunctionBody|，</li>
          <li>|GeneratorDeclaration| 或 |GeneratorExpression| 的 |FormalParameters| 与 |GeneratorBody|，</li>
          <li>|AsyncFunctionDeclaration| 或 |AsyncFunctionExpression| 的 |FormalParameters| 与 |AsyncFunctionBody|，或</li>
          <li>|AsyncGeneratorDeclaration| 或 |AsyncGeneratorExpression| 的 |FormalParameters| 与 |AsyncGeneratorBody|，</li>
        </ul>
        <p>则该声明或表达式的 |BindingIdentifier|（若存在）所匹配的源码文本也包含在对应函数的函数代码中。</p>
      </li>
      <li>
        <dfn>模块代码 (Module code)</dfn> 是作为 |ModuleBody| 提供的源码文本。它是在模块初始化时被直接求值的代码。某个模块的模块代码不包含被解析为内嵌 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction|、|AsyncArrowFunction|、|ClassDeclaration| 或 |ClassExpression| 的源码。
      </li>
    </ul>
    <emu-note>
      <p>函数代码通常以函数定义 (<emu-xref href="#sec-function-definitions"></emu-xref>)、箭头函数定义 (<emu-xref href="#sec-arrow-function-definitions"></emu-xref>)、方法定义 (<emu-xref href="#sec-method-definitions"></emu-xref>)、生成器函数定义 (<emu-xref href="#sec-generator-function-definitions"></emu-xref>)、异步函数定义 (<emu-xref href="#sec-async-function-definitions"></emu-xref>)、异步生成器函数定义 (<emu-xref href="#sec-async-generator-function-definitions"></emu-xref>) 以及异步箭头函数 (<emu-xref href="#sec-async-arrow-function-definitions"></emu-xref>) 的函数体形式提供。函数代码还来自 Function 构造器 (<emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>)、GeneratorFunction 构造器 (<emu-xref href="#sec-generatorfunction"></emu-xref>)、AsyncFunction 构造器 (<emu-xref href="#sec-async-function-constructor-arguments"></emu-xref>) 与 AsyncGeneratorFunction 构造器 (<emu-xref href="#sec-asyncgeneratorfunction"></emu-xref>) 的参数。</p>
    </emu-note>
    <emu-note>
      <p>将 |BindingIdentifier| 包含在函数代码中的实际作用是：即便外围代码不是严格模式，只要函数体内含有 "use strict" 指令，该函数名的 |BindingIdentifier| 也会应用严格模式早期错误规则。</p>
    </emu-note>

    <emu-clause id="sec-directive-prologues-and-the-use-strict-directive">
      <h1>指令序言与 Use Strict 指令 (Directive Prologues and the Use Strict Directive)</h1>
      <p><dfn id="directive-prologue" variants="Directive Prologues">指令序言 (Directive Prologue)</dfn> 是出现在 |FunctionBody|、|ScriptBody| 或 |ModuleBody| 起始位置处、作为初始 |StatementListItem| 或 |ModuleItem| 的最长 |ExpressionStatement| 序列，并且序列中每个 |ExpressionStatement| 完全由一个 |StringLiteral| 标记及其后紧随的分号组成。该分号可以显式出现，也可由自动分号插入 (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) 插入。指令序言可以是空序列。</p>
      <p><dfn id="use-strict-directive" variants="Use Strict Directives">Use Strict 指令 (Use Strict Directive)</dfn> 是指令序言中的一个 |ExpressionStatement|，其 |StringLiteral| 精确为代码点序列 `"use strict"` 或 `'use strict'`。Use Strict 指令不允许包含 |EscapeSequence| 或 |LineContinuation|。</p>
      <p>指令序言可包含多个 Use Strict 指令；实现可以在发生这种情况时发出警告。</p>
      <emu-note>
        <p>指令序言中的 |ExpressionStatement| 在包含它的产生式求值时会被正常求值。实现可以为指令序言中出现、且不是 Use Strict 指令的 |ExpressionStatement| 定义实现特定的含义。如果存在合适的通知机制，实现若在指令序言中遇到既不是 Use Strict 指令又没有实现定义语义的 |ExpressionStatement|，应发出警告。</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-strict-mode-code">
      <h1>严格模式代码 (Strict Mode Code)</h1>
      <p>一个 ECMAScript 语法单元可以用不受限模式或严格模式语法与语义处理 (<emu-xref href="#sec-strict-variant-of-ecmascript"></emu-xref>)。以下情况中代码被解释为 <dfn>严格模式代码 (strict mode code)</dfn>：</p>
      <ul>
        <li>
          若全局代码以包含 Use Strict 指令的指令序言开始，则该全局代码为严格模式代码。
        </li>
        <li>
          模块代码始终是严格模式代码。
        </li>
        <li>
          |ClassDeclaration| 或 |ClassExpression| 的所有部分都是严格模式代码。
        </li>
        <li>
          若 eval 代码以包含 Use Strict 指令的指令序言开始，或对 `eval` 的直接调用位于严格模式代码中，则该 eval 代码为严格模式代码。
        </li>
        <li>
          若关联的 |FunctionDeclaration|、|FunctionExpression|、|GeneratorDeclaration|、|GeneratorExpression|、|AsyncFunctionDeclaration|、|AsyncFunctionExpression|、|AsyncGeneratorDeclaration|、|AsyncGeneratorExpression|、|MethodDefinition|、|ArrowFunction| 或 |AsyncArrowFunction| 处于严格模式代码中，或其 [[ECMAScriptCode]] 内部槽值所来源的代码以包含 Use Strict 指令的指令序言开始，则函数代码为严格模式代码。
        </li>
        <li>
          若作为内置 Function、Generator、AsyncFunction、AsyncGenerator 构造器的参数提供的函数代码的最后一个参数是 String，且其作为 |FunctionBody| 处理后以包含 Use Strict 指令的指令序言开始，则该函数代码为严格模式代码。
        </li>
      </ul>
      <p>不是严格模式代码的 ECMAScript 代码称为 <dfn id="non-strict-code">非严格代码 (non-strict code)</dfn>。</p>

      <emu-clause id="sec-isstrict" type="abstract operation">
        <h1>
          静态语义：IsStrict (
            _node_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. 若 _node_ 匹配的源码文本是严格模式代码，返回 *true*；否则返回 *false*。
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-non-ecmascript-functions">
      <h1>非 ECMAScript 函数 (Non-ECMAScript Functions)</h1>
      <p>ECMAScript 实现可以支持求值其执行行为以宿主自定义的非 ECMAScript 可执行代码形式表达的函数特异对象。一个函数对象是否在 ECMAScript 代码中定义或是否是内置函数，对调用或被其调用的 ECMAScript 代码而言不可观察。</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-lexical-grammar">
  <h1>ECMAScript Language: Lexical Grammar</h1>
  <p>The source text of an ECMAScript |Script| or |Module| is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of code points as the next input element.</p>
  <p>There are several situations where the identification of lexical input elements is sensitive to the syntactic grammar context that is consuming the input elements. This requires multiple goal symbols for the lexical grammar. The |InputElementHashbangOrRegExp| goal is used at the start of a |Script| or |Module|. The |InputElementRegExpOrTemplateTail| goal is used in syntactic grammar contexts where a |RegularExpressionLiteral|, a |TemplateMiddle|, or a |TemplateTail| is permitted. The |InputElementRegExp| goal symbol is used in all syntactic grammar contexts where a |RegularExpressionLiteral| is permitted but neither a |TemplateMiddle|, nor a |TemplateTail| is permitted. The |InputElementTemplateTail| goal is used in all syntactic grammar contexts where a |TemplateMiddle| or a |TemplateTail| is permitted but a |RegularExpressionLiteral| is not permitted. In all other contexts, |InputElementDiv| is used as the lexical goal symbol.</p>
  <emu-note>
    <p>The use of multiple lexical goals ensures that there are no lexical ambiguities that would affect automatic semicolon insertion. For example, there are no syntactic grammar contexts where both a leading division or division-assignment, and a leading |RegularExpressionLiteral| are permitted. This is not affected by semicolon insertion (see <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>); in examples such as the following:</p>
    <pre><code class="javascript">
      a = b
      /hi/g.exec(c).map(d);
    </code></pre>
    <p>where the first non-whitespace, non-comment code point after a |LineTerminator| is U+002F (SOLIDUS) and the syntactic context allows division or division-assignment, no semicolon is inserted at the |LineTerminator|. That is, the above example is interpreted in the same way as:</p>
    <pre><code class="javascript">
      a = b / hi / g.exec(c).map(d);
    </code></pre>
  </emu-note>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    InputElementDiv ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      RightBracePunctuator

    InputElementRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RightBracePunctuator
      RegularExpressionLiteral

    InputElementRegExpOrTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      RegularExpressionLiteral
      TemplateSubstitutionTail

    InputElementTemplateTail ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      DivPunctuator
      TemplateSubstitutionTail

    InputElementHashbangOrRegExp ::
      WhiteSpace
      LineTerminator
      Comment
      CommonToken
      HashbangComment
      RegularExpressionLiteral
  </emu-grammar>

  <emu-clause id="sec-unicode-format-control-characters">
    <h1>Unicode Format-Control Characters</h1>
    <p>The Unicode format-control characters (i.e., the characters in category “Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or RIGHT-TO-LEFT MARK) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).</p>
    <p>It is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments, and within string literals, template literals, and regular expression literals.</p>
    <p>U+FEFF (ZERO WIDTH NO-BREAK SPACE) is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text's encoding and byte order. &lt;ZWNBSP> characters intended for this purpose can sometimes also appear after the start of a text, for example as a result of concatenating files. In ECMAScript source text &lt;ZWNBSP> code points are treated as white space characters (see <emu-xref href="#sec-white-space"></emu-xref>) outside of comments, string literals, template literals, and regular expression literals.</p>
  </emu-clause>

  <emu-clause id="sec-white-space">
    <h1>White Space</h1>
    <p>White space code points are used to improve source text readability and to separate tokens (indivisible lexical units) from each other, but are otherwise insignificant. White space code points may occur between any two tokens and at the start or end of input. White space code points may occur within a |StringLiteral|, a |RegularExpressionLiteral|, a |Template|, or a |TemplateSubstitutionTail| where they are considered significant code points forming part of a literal value. They may also occur within a |Comment|, but cannot appear within any other kind of token.</p>
    <p>The ECMAScript white space code points are listed in <emu-xref href="#table-white-space-code-points"></emu-xref>.</p>
    <emu-table id="table-white-space-code-points" caption="White Space Code Points" oldids="table-32">
      <table>
        <thead>
          <tr>
            <th>
              Code Points
            </th>
            <th>
              Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+0009`
          </td>
          <td>
            CHARACTER TABULATION
          </td>
          <td>
            &lt;TAB>
          </td>
        </tr>
        <tr>
          <td>
            `U+000B`
          </td>
          <td>
            LINE TABULATION
          </td>
          <td>
            &lt;VT>
          </td>
        </tr>
        <tr>
          <td>
            `U+000C`
          </td>
          <td>
            FORM FEED (FF)
          </td>
          <td>
            &lt;FF>
          </td>
        </tr>
        <tr>
          <td>
            `U+FEFF`
          </td>
          <td>
            ZERO WIDTH NO-BREAK SPACE
          </td>
          <td>
            &lt;ZWNBSP>
          </td>
        </tr>
        <tr>
          <td>
            any code point in general category “Space_Separator”
          </td>
          <td>
          </td>
          <td>
            &lt;USP>
          </td>
        </tr>
      </table>
    </emu-table>
    <emu-note>
      <p>U+0020 (SPACE) and U+00A0 (NO-BREAK SPACE) code points are part of &lt;USP>.</p>
    </emu-note>
    <emu-note>
      <p>Other than for the code points listed in <emu-xref href="#table-white-space-code-points"></emu-xref>, ECMAScript |WhiteSpace| intentionally excludes all code points that have the Unicode “White_Space” property but which are not classified in general category “Space_Separator” (“Zs”).</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WhiteSpace ::
        &lt;TAB&gt;
        &lt;VT&gt;
        &lt;FF&gt;
        &lt;ZWNBSP&gt;
        &lt;USP&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-line-terminators">
    <h1>Line Terminators</h1>
    <p>Like white space code points, line terminator code points are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However, unlike white space code points, line terminators have some influence over the behaviour of the syntactic grammar. In general, line terminators may occur between any two tokens, but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of automatic semicolon insertion (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>). A line terminator cannot occur within any token except a |StringLiteral|, |Template|, or |TemplateSubstitutionTail|. &lt;LF> and &lt;CR> line terminators cannot occur within a |StringLiteral| token except as part of a |LineContinuation|.</p>
    <p>A line terminator can occur within a |MultiLineComment| but cannot occur within a |SingleLineComment|.</p>
    <p>Line terminators are included in the set of white space code points that are matched by the `\\s` class in regular expressions.</p>
    <p>The ECMAScript line terminator code points are listed in <emu-xref href="#table-line-terminator-code-points"></emu-xref>.</p>
    <emu-table id="table-line-terminator-code-points" caption="Line Terminator Code Points" oldids="table-33">
      <table>
        <thead>
          <tr>
            <th>
              Code Point
            </th>
            <th>
              Unicode Name
            </th>
            <th>
              Abbreviation
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            `U+000A`
          </td>
          <td>
            LINE FEED (LF)
          </td>
          <td>
            &lt;LF>
          </td>
        </tr>
        <tr>
          <td>
            `U+000D`
          </td>
          <td>
            CARRIAGE RETURN (CR)
          </td>
          <td>
            &lt;CR>
          </td>
        </tr>
        <tr>
          <td>
            `U+2028`
          </td>
          <td>
            LINE SEPARATOR
          </td>
          <td>
            &lt;LS>
          </td>
        </tr>
        <tr>
          <td>
            `U+2029`
          </td>
          <td>
            PARAGRAPH SEPARATOR
          </td>
          <td>
            &lt;PS>
          </td>
        </tr>
      </table>
    </emu-table>
    <p>Only the Unicode code points in <emu-xref href="#table-line-terminator-code-points"></emu-xref> are treated as line terminators. Other new line or line breaking Unicode code points are not treated as line terminators but are treated as white space if they meet the requirements listed in <emu-xref href="#table-white-space-code-points"></emu-xref>. The sequence &lt;CR>&lt;LF> is commonly used as a line terminator. It should be considered a single |SourceCharacter| for the purpose of reporting line numbers.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LineTerminator ::
        &lt;LF&gt;
        &lt;CR&gt;
        &lt;LS&gt;
        &lt;PS&gt;

      LineTerminatorSequence ::
        &lt;LF&gt;
        &lt;CR&gt; [lookahead != &lt;LF&gt;]
        &lt;LS&gt;
        &lt;PS&gt;
        &lt;CR&gt; &lt;LF&gt;
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-comments">
    <h1>Comments</h1>
    <p>Comments can be either single or multi-line. Multi-line comments cannot nest.</p>
    <p>Because a single-line comment can contain any Unicode code point except a |LineTerminator| code point, and because of the general rule that a token is always as long as possible, a single-line comment always consists of all code points from the `//` marker to the end of the line. However, the |LineTerminator| at the end of the line is not considered to be part of the single-line comment; it is recognized separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important, because it implies that the presence or absence of single-line comments does not affect the process of automatic semicolon insertion (see <emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>).</p>
    <p>Comments behave like white space and are discarded except that, if a |MultiLineComment| contains a line terminator code point, then the entire comment is considered to be a |LineTerminator| for purposes of parsing by the syntactic grammar.</p>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Comment ::
        MultiLineComment
        SingleLineComment

      MultiLineComment ::
        `/*` MultiLineCommentChars? `*/`

      MultiLineCommentChars ::
        MultiLineNotAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      PostAsteriskCommentChars ::
        MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
        `*` PostAsteriskCommentChars?

      MultiLineNotAsteriskChar ::
        SourceCharacter but not `*`

      MultiLineNotForwardSlashOrAsteriskChar ::
        SourceCharacter but not one of `/` or `*`

      SingleLineComment ::
        `//` SingleLineCommentChars?

      SingleLineCommentChars ::
        SingleLineCommentChar SingleLineCommentChars?

      SingleLineCommentChar ::
        SourceCharacter but not LineTerminator
    </emu-grammar>
    <p>A number of productions in this section are given alternative definitions in section <emu-xref href="#sec-html-like-comments"></emu-xref></p>
  </emu-clause>

  <emu-clause id="sec-hashbang">
    <h1>Hashbang Comments</h1>

    <p>Hashbang Comments are location-sensitive and like other types of comments are discarded from the stream of input elements for the syntactic grammar.</p>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      HashbangComment ::
        `#!` SingleLineCommentChars?
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-tokens">
    <h1>Tokens</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CommonToken ::
        IdentifierName
        PrivateIdentifier
        Punctuator
        NumericLiteral
        StringLiteral
        Template
    </emu-grammar>
    <emu-note>
      <p>The |DivPunctuator|, |RegularExpressionLiteral|, |RightBracePunctuator|, and |TemplateSubstitutionTail| productions derive additional tokens that are not included in the |CommonToken| production.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-names-and-keywords">
    <h1>Names and Keywords</h1>
    <p>|IdentifierName| and |ReservedWord| are tokens that are interpreted according to the Default Identifier Syntax given in Unicode Standard Annex #31, Identifier and Pattern Syntax, with some small modifications. |ReservedWord| is an enumerated subset of |IdentifierName|. The syntactic grammar defines |Identifier| as an |IdentifierName| that is not a |ReservedWord|. The Unicode identifier grammar is based on character properties specified by the Unicode Standard. The Unicode code points in the specified categories in the latest version of the Unicode Standard must be treated as in those categories by all conforming ECMAScript implementations. ECMAScript implementations may recognize identifier code points defined in later editions of the Unicode Standard.</p>
    <emu-note>
      <p>This standard specifies specific code point additions: U+0024 (DOLLAR SIGN) and U+005F (LOW LINE) are permitted anywhere in an |IdentifierName|.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrivateIdentifier ::
        `#` IdentifierName

      IdentifierName ::
        IdentifierStart
        IdentifierName IdentifierPart

      IdentifierStart ::
        IdentifierStartChar
        `\` UnicodeEscapeSequence

      IdentifierPart ::
        IdentifierPartChar
        `\` UnicodeEscapeSequence

      IdentifierStartChar ::
        UnicodeIDStart
        `$`
        `_`

      IdentifierPartChar ::
        UnicodeIDContinue
        `$`

      // emu-format ignore
      AsciiLetter :: one of
        `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
        `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

      UnicodeIDStart ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Start&rdquo;

      UnicodeIDContinue ::
        &gt; any Unicode code point with the Unicode property &ldquo;ID_Continue&rdquo;
    </emu-grammar>
    <p>The definitions of the nonterminal |UnicodeEscapeSequence| is given in <emu-xref href="#sec-literals-string-literals"></emu-xref>.</p>
    <emu-note>
      <p>The nonterminal |IdentifierPart| derives `_` via |UnicodeIDContinue|.</p>
    </emu-note>
    <emu-note>
      <p>The sets of code points with Unicode properties “ID_Start” and “ID_Continue” include, respectively, the code points with Unicode properties “Other_ID_Start” and “Other_ID_Continue”.</p>
    </emu-note>

    <emu-clause id="sec-identifier-names">
      <h1>Identifier Names</h1>
      <p>Unicode escape sequences are permitted in an |IdentifierName|, where they contribute a single Unicode code point equal to the IdentifierCodePoint of the |UnicodeEscapeSequence|. The `\\` preceding the |UnicodeEscapeSequence| does not contribute any code points. A |UnicodeEscapeSequence| cannot be used to contribute a code point to an |IdentifierName| that would otherwise be invalid. In other words, if a `\\` |UnicodeEscapeSequence| sequence were replaced by the |SourceCharacter| it contributes, the result must still be a valid |IdentifierName| that has the exact same sequence of |SourceCharacter| elements as the original |IdentifierName|. All interpretations of |IdentifierName| within this specification are based upon their actual code points regardless of whether or not an escape sequence was used to contribute any particular code point.</p>
      <p>Two |IdentifierName|s that are canonically equivalent according to the Unicode Standard are <em>not</em> equal unless, after replacement of each |UnicodeEscapeSequence|, they are represented by the exact same sequence of code points.</p>

      <emu-clause id="sec-identifier-names-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>IdentifierStart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the IdentifierCodePoint of |UnicodeEscapeSequence| is not some Unicode code point matched by the |IdentifierStartChar| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>IdentifierPart :: `\` UnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the IdentifierCodePoint of |UnicodeEscapeSequence| is not some Unicode code point matched by the |IdentifierPartChar| lexical grammar production.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoints" type="sdo">
        <h1>Static Semantics: IdentifierCodePoints ( ): a List of code points</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierName :: IdentifierStart</emu-grammar>
        <emu-alg>
          1. Let _cp_ be the IdentifierCodePoint of |IdentifierStart|.
          1. Return « _cp_ ».
        </emu-alg>
        <emu-grammar>IdentifierName :: IdentifierName IdentifierPart</emu-grammar>
        <emu-alg>
          1. Let _cps_ be the IdentifierCodePoints of the derived |IdentifierName|.
          1. Let _cp_ be the IdentifierCodePoint of |IdentifierPart|.
          1. Return the list-concatenation of _cps_ and « _cp_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-identifiercodepoint" type="sdo">
        <h1>Static Semantics: IdentifierCodePoint ( ): a code point</h1>
        <dl class="header">
        </dl>
        <emu-grammar>IdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. Return the code point matched by |IdentifierStartChar|.
        </emu-alg>
        <emu-grammar>IdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. Return the code point matched by |IdentifierPartChar|.
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. Return the code point whose numeric value is the MV of |Hex4Digits|.
        </emu-alg>
        <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. Return the code point whose numeric value is the MV of |CodePoint|.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-keywords-and-reserved-words" oldids="sec-reserved-words,sec-keywords,sec-future-reserved-words">
      <h1>Keywords and Reserved Words</h1>
      <p>A <dfn variants="keywords">keyword</dfn> is a token that matches |IdentifierName|, but also has a syntactic use; that is, it appears literally, in a `fixed width` font, in some syntactic production. The keywords of ECMAScript include `if`, `while`, `async`, `await`, and many others.</p>
      <p>A <dfn variants="reserved words">reserved word</dfn> is an |IdentifierName| that cannot be used as an identifier. Many keywords are reserved words, but some are not, and some are reserved only in certain contexts. `if` and `while` are reserved words. `await` is reserved only inside async functions and modules. `async` is not reserved; it can be used as a variable name or statement label without restriction.</p>
      <p>This specification uses a combination of grammatical productions and early error rules to specify which names are valid identifiers and which are reserved words. All tokens in the |ReservedWord| list below, except for `await` and `yield`, are unconditionally reserved. Exceptions for `await` and `yield` are specified in <emu-xref href="#sec-identifiers"></emu-xref>, using parameterized syntactic productions. Lastly, several early error rules restrict the set of valid identifiers. See <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-let-and-const-declarations-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-for-in-and-for-of-statements-static-semantics-early-errors"></emu-xref>, and <emu-xref href="#sec-class-definitions-static-semantics-early-errors"></emu-xref>. In summary, there are five categories of identifier names:</p>
      <ul>
        <li>
          <p>Those that are always allowed as identifiers, and are not keywords, such as `Math`, `window`, `toString`, and `_`;</p>
        </li>
        <li>
          <p>Those that are never allowed as identifiers, namely the |ReservedWord|s listed below except `await` and `yield`;</p>
        </li>
        <li>
          <p>Those that are contextually allowed as identifiers, namely `await` and `yield`;</p>
        </li>
        <li>
          <p>Those that are contextually disallowed as identifiers, in strict mode code: `let`, `static`, `implements`, `interface`, `package`, `private`, `protected`, and `public`;</p>
        </li>
        <li>
          <p>Those that are always allowed as identifiers, but also appear as keywords within certain syntactic productions, at places where |Identifier| is not allowed: `as`, `async`, `from`, `get`, `meta`, `of`, `set`, and `target`.</p>
        </li>
      </ul>
      <p>The term <dfn variants="conditional keywords">conditional keyword</dfn>, or <dfn variants="contextual keywords">contextual keyword</dfn>, is sometimes used to refer to the keywords that fall in the last three categories, and thus can be used as identifiers in some contexts and as keywords in others.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        // emu-format ignore
        ReservedWord :: one of
          `await`
          `break`
          `case` `catch` `class` `const` `continue`
          `debugger` `default` `delete` `do`
          `else` `enum` `export` `extends`
          `false` `finally` `for` `function`
          `if` `import` `in` `instanceof`
          `new` `null`
          `return`
          `super` `switch`
          `this` `throw` `true` `try` `typeof`
          `var` `void`
          `while` `with`
          `yield`
      </emu-grammar>
      <emu-note>
        <p>Per <emu-xref href="#sec-grammar-notation"></emu-xref>, keywords in the grammar match literal sequences of specific |SourceCharacter| elements. A code point in a keyword cannot be expressed by a `\\` |UnicodeEscapeSequence|.</p>
        <p>An |IdentifierName| can contain `\\` |UnicodeEscapeSequence|s, but it is not possible to declare a variable named "else" by spelling it `els\u{65}`. The early error rules in <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref> rule out identifiers with the same StringValue as a reserved word.</p>
      </emu-note>
      <emu-note>
        <p>`enum` is not currently used as a keyword in this specification. It is a <em>future reserved word</em>, set aside for use as a keyword in future language extensions.</p>
        <p>Similarly, `implements`, `interface`, `package`, `private`, `protected`, and `public` are future reserved words in strict mode code.</p>
      </emu-note>
      <emu-note>
        <p>The names `arguments` and `eval` are not keywords, but they are subject to some restrictions in strict mode code. See <emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-static-semantics-assignmenttargettype"></emu-xref>, <emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-generator-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-async-generator-function-definitions-static-semantics-early-errors"></emu-xref>, and <emu-xref href="#sec-async-function-definitions-static-semantics-early-errors"></emu-xref>.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-punctuators">
    <h1>Punctuators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Punctuator ::
        OptionalChainingPunctuator
        OtherPunctuator

      OptionalChainingPunctuator ::
        `?.` [lookahead &notin; DecimalDigit]

      // emu-format ignore
      OtherPunctuator :: one of
        `{` `(` `)` `[` `]`
        `.` `...` `;` `,`
        `&lt;` `&gt;` `&lt;=` `&gt;=`
        `==` `!=` `===` `!==`
        `+` `-` `*` `%` `**`
        `++` `--`
        `&lt;&lt;` `&gt;&gt;` `&gt;&gt;&gt;`
        `&amp;` `|` `^`
        `!` `~`
        `&amp;&amp;` `||` `??`
        `?` `:`
        `=` `+=` `-=` `*=` `%=` `**=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `|=` `^=`
        `&amp;&amp;=` `||=` `??=`
        `=&gt;`

      DivPunctuator ::
        `/`
        `/=`

      RightBracePunctuator ::
        `}`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-ecmascript-language-lexical-grammar-literals">
    <h1>Literals</h1>

    <emu-clause id="sec-null-literals">
      <h1>Null Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NullLiteral ::
          `null`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-boolean-literals">
      <h1>Boolean Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BooleanLiteral ::
          `true`
          `false`
      </emu-grammar>
    </emu-clause>

    <emu-clause id="sec-literals-numeric-literals" oldids="sec-additional-syntax-numeric-literals">
      <h1>Numeric Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        NumericLiteralSeparator ::
          `_`

        NumericLiteral ::
          DecimalLiteral
          DecimalBigIntegerLiteral
          NonDecimalIntegerLiteral[+Sep]
          NonDecimalIntegerLiteral[+Sep] BigIntLiteralSuffix
          LegacyOctalIntegerLiteral

        DecimalBigIntegerLiteral ::
          `0` BigIntLiteralSuffix
          NonZeroDigit DecimalDigits[+Sep]? BigIntLiteralSuffix
          NonZeroDigit NumericLiteralSeparator DecimalDigits[+Sep] BigIntLiteralSuffix

        NonDecimalIntegerLiteral[Sep] ::
          BinaryIntegerLiteral[?Sep]
          OctalIntegerLiteral[?Sep]
          HexIntegerLiteral[?Sep]

        BigIntLiteralSuffix ::
          `n`

        DecimalLiteral ::
          DecimalIntegerLiteral `.` DecimalDigits[+Sep]? ExponentPart[+Sep]?
          `.` DecimalDigits[+Sep] ExponentPart[+Sep]?
          DecimalIntegerLiteral ExponentPart[+Sep]?

        DecimalIntegerLiteral ::
          `0`
          NonZeroDigit
          NonZeroDigit NumericLiteralSeparator? DecimalDigits[+Sep]
          NonOctalDecimalIntegerLiteral

        DecimalDigits[Sep] ::
          DecimalDigit
          DecimalDigits[?Sep] DecimalDigit
          [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

        DecimalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

        NonZeroDigit :: one of
          `1` `2` `3` `4` `5` `6` `7` `8` `9`

        ExponentPart[Sep] ::
          ExponentIndicator SignedInteger[?Sep]

        ExponentIndicator :: one of
          `e` `E`

        SignedInteger[Sep] ::
          DecimalDigits[?Sep]
          `+` DecimalDigits[?Sep]
          `-` DecimalDigits[?Sep]

        BinaryIntegerLiteral[Sep] ::
          `0b` BinaryDigits[?Sep]
          `0B` BinaryDigits[?Sep]

        BinaryDigits[Sep] ::
          BinaryDigit
          BinaryDigits[?Sep] BinaryDigit
          [+Sep] BinaryDigits[+Sep] NumericLiteralSeparator BinaryDigit

        BinaryDigit :: one of
          `0` `1`

        OctalIntegerLiteral[Sep] ::
          `0o` OctalDigits[?Sep]
          `0O` OctalDigits[?Sep]

        OctalDigits[Sep] ::
          OctalDigit
          OctalDigits[?Sep] OctalDigit
          [+Sep] OctalDigits[+Sep] NumericLiteralSeparator OctalDigit

        LegacyOctalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalIntegerLiteral OctalDigit

        NonOctalDecimalIntegerLiteral ::
          `0` NonOctalDigit
          LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
          NonOctalDecimalIntegerLiteral DecimalDigit

        LegacyOctalLikeDecimalIntegerLiteral ::
          `0` OctalDigit
          LegacyOctalLikeDecimalIntegerLiteral OctalDigit

        OctalDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7`

        NonOctalDigit :: one of
          `8` `9`

        HexIntegerLiteral[Sep] ::
          `0x` HexDigits[?Sep]
          `0X` HexDigits[?Sep]

        HexDigits[Sep] ::
          HexDigit
          HexDigits[?Sep] HexDigit
          [+Sep] HexDigits[+Sep] NumericLiteralSeparator HexDigit

        // emu-format ignore
        HexDigit :: one of
          `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`
      </emu-grammar>
      <p>The |SourceCharacter| immediately following a |NumericLiteral| must not be an |IdentifierStart| or |DecimalDigit|.</p>
      <emu-note>
        <p>For example: `3in` is an error and not the two input elements `3` and `in`.</p>
      </emu-note>

      <emu-clause id="sec-numeric-literals-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          NumericLiteral :: LegacyOctalIntegerLiteral

          DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral
        </emu-grammar>
        <ul>
          <li>It is a Syntax Error if IsStrict(this production) is *true*.</li>
        </ul>
        <emu-note>In non-strict code, this syntax is Legacy.</emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-mv" oldids="sec-additional-syntax-numeric-literals-status-semantics">
        <h1>Static Semantics: MV</h1>
        <p>A numeric literal stands for a value of the Number type or the BigInt type.</p>
        <ul>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits</emu-grammar> is the MV of |DecimalIntegerLiteral| plus (the MV of |DecimalDigits| × 10<sup>-_n_</sup>), where _n_ is the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart</emu-grammar> is the MV of |DecimalIntegerLiteral| × 10<sup>_e_</sup>, where _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart</emu-grammar> is (the MV of |DecimalIntegerLiteral| plus (the MV of |DecimalDigits| × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>, where _n_ is the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator| and _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: `.` DecimalDigits</emu-grammar> is the MV of |DecimalDigits| × 10<sup>-_n_</sup>, where _n_ is the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: `.` DecimalDigits ExponentPart</emu-grammar> is the MV of |DecimalDigits| × 10<sup>_e_ - _n_</sup>, where _n_ is the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|, and _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalLiteral :: DecimalIntegerLiteral ExponentPart</emu-grammar> is the MV of |DecimalIntegerLiteral| × 10<sup>_e_</sup>, where _e_ is the MV of |ExponentPart|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalIntegerLiteral :: `0`</emu-grammar> is 0.
          </li>
          <li>
            The MV of <emu-grammar>DecimalIntegerLiteral :: NonZeroDigit NumericLiteralSeparator? DecimalDigits</emu-grammar> is (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|, where _n_ is the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigits :: DecimalDigits DecimalDigit</emu-grammar> is (the MV of |DecimalDigits| × 10) plus the MV of |DecimalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigits :: DecimalDigits NumericLiteralSeparator DecimalDigit</emu-grammar> is (the MV of |DecimalDigits| × 10) plus the MV of |DecimalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>ExponentPart :: ExponentIndicator SignedInteger</emu-grammar> is the MV of |SignedInteger|.
          </li>
          <li>
            The MV of <emu-grammar>SignedInteger :: `-` DecimalDigits</emu-grammar> is the negative of the MV of |DecimalDigits|.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `0`</emu-grammar> or of <emu-grammar>HexDigit :: `0`</emu-grammar> or of <emu-grammar>OctalDigit :: `0`</emu-grammar> or of <emu-grammar>LegacyOctalEscapeSequence :: `0`</emu-grammar> or of <emu-grammar>BinaryDigit :: `0`</emu-grammar> is 0.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `1`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `1`</emu-grammar> or of <emu-grammar>HexDigit :: `1`</emu-grammar> or of <emu-grammar>OctalDigit :: `1`</emu-grammar> or of <emu-grammar>BinaryDigit :: `1`</emu-grammar> is 1.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `2`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `2`</emu-grammar> or of <emu-grammar>HexDigit :: `2`</emu-grammar> or of <emu-grammar>OctalDigit :: `2`</emu-grammar> is 2.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `3`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `3`</emu-grammar> or of <emu-grammar>HexDigit :: `3`</emu-grammar> or of <emu-grammar>OctalDigit :: `3`</emu-grammar> is 3.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `4`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `4`</emu-grammar> or of <emu-grammar>HexDigit :: `4`</emu-grammar> or of <emu-grammar>OctalDigit :: `4`</emu-grammar> is 4.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `5`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `5`</emu-grammar> or of <emu-grammar>HexDigit :: `5`</emu-grammar> or of <emu-grammar>OctalDigit :: `5`</emu-grammar> is 5.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `6`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `6`</emu-grammar> or of <emu-grammar>HexDigit :: `6`</emu-grammar> or of <emu-grammar>OctalDigit :: `6`</emu-grammar> is 6.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `7`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `7`</emu-grammar> or of <emu-grammar>HexDigit :: `7`</emu-grammar> or of <emu-grammar>OctalDigit :: `7`</emu-grammar> is 7.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `8`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `8`</emu-grammar> or of <emu-grammar>NonOctalDigit :: `8`</emu-grammar> or of <emu-grammar>HexDigit :: `8`</emu-grammar> is 8.
          </li>
          <li>
            The MV of <emu-grammar>DecimalDigit :: `9`</emu-grammar> or of <emu-grammar>NonZeroDigit :: `9`</emu-grammar> or of <emu-grammar>NonOctalDigit :: `9`</emu-grammar> or of <emu-grammar>HexDigit :: `9`</emu-grammar> is 9.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `a`</emu-grammar> or of <emu-grammar>HexDigit :: `A`</emu-grammar> is 10.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `b`</emu-grammar> or of <emu-grammar>HexDigit :: `B`</emu-grammar> is 11.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `c`</emu-grammar> or of <emu-grammar>HexDigit :: `C`</emu-grammar> is 12.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `d`</emu-grammar> or of <emu-grammar>HexDigit :: `D`</emu-grammar> is 13.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `e`</emu-grammar> or of <emu-grammar>HexDigit :: `E`</emu-grammar> is 14.
          </li>
          <li>
            The MV of <emu-grammar>HexDigit :: `f`</emu-grammar> or of <emu-grammar>HexDigit :: `F`</emu-grammar> is 15.
          </li>
          <li>
            The MV of <emu-grammar>BinaryDigits :: BinaryDigits BinaryDigit</emu-grammar> is (the MV of |BinaryDigits| × 2) plus the MV of |BinaryDigit|.
          </li>
          <li>
            The MV of <emu-grammar>BinaryDigits :: BinaryDigits NumericLiteralSeparator BinaryDigit</emu-grammar> is (the MV of |BinaryDigits| × 2) plus the MV of |BinaryDigit|.
          </li>
          <li>
            The MV of <emu-grammar>OctalDigits :: OctalDigits OctalDigit</emu-grammar> is (the MV of |OctalDigits| × 8) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>OctalDigits :: OctalDigits NumericLiteralSeparator OctalDigit</emu-grammar> is (the MV of |OctalDigits| × 8) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>LegacyOctalIntegerLiteral :: LegacyOctalIntegerLiteral OctalDigit</emu-grammar> is (the MV of |LegacyOctalIntegerLiteral| times 8) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>NonOctalDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit</emu-grammar> is (the MV of |LegacyOctalLikeDecimalIntegerLiteral| times 10) plus the MV of |NonOctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>NonOctalDecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral DecimalDigit</emu-grammar> is (the MV of |NonOctalDecimalIntegerLiteral| times 10) plus the MV of |DecimalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>LegacyOctalLikeDecimalIntegerLiteral :: LegacyOctalLikeDecimalIntegerLiteral OctalDigit</emu-grammar> is (the MV of |LegacyOctalLikeDecimalIntegerLiteral| times 10) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> is (the MV of |HexDigits| × 16) plus the MV of |HexDigit|.
          </li>
          <li>
            The MV of <emu-grammar>HexDigits :: HexDigits NumericLiteralSeparator HexDigit</emu-grammar> is (the MV of |HexDigits| × 16) plus the MV of |HexDigit|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-numericvalue" type="sdo">
        <h1>Static Semantics: NumericValue ( ): a Number or a BigInt</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NumericLiteral :: DecimalLiteral</emu-grammar>
        <emu-alg>
          1. Return RoundMVResult(MV of |DecimalLiteral|).
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).
        </emu-alg>
        <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar>
        <emu-alg>
          1. Return 𝔽(MV of |LegacyOctalIntegerLiteral|).
        </emu-alg>
        <emu-grammar>NumericLiteral :: NonDecimalIntegerLiteral BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. Return the BigInt value for the MV of |NonDecimalIntegerLiteral|.
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: `0` BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. Return *0*<sub>ℤ</sub>.
        </emu-alg>
        <emu-grammar>DecimalBigIntegerLiteral :: NonZeroDigit BigIntLiteralSuffix</emu-grammar>
        <emu-alg>
          1. Return the BigInt value for the MV of |NonZeroDigit|.
        </emu-alg>
        <emu-grammar>
          DecimalBigIntegerLiteral ::
            NonZeroDigit DecimalDigits BigIntLiteralSuffix
            NonZeroDigit NumericLiteralSeparator DecimalDigits BigIntLiteralSuffix
        </emu-grammar>
        <emu-alg>
          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.
          1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.
          1. Return ℤ(_mv_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-string-literals" oldids="sec-additional-syntax-string-literals">
      <h1>String Literals</h1>
      <emu-note>
        <p>A string literal is 0 or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for the closing quote code points, U+005C (REVERSE SOLIDUS), U+000D (CARRIAGE RETURN), and U+000A (LINE FEED). Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded as defined in <emu-xref href="#sec-utf16encodecodepoint"></emu-xref>. Code points belonging to the Basic Multilingual Plane are encoded as a single code unit element of the string. All other code points are encoded as two code unit elements of the string.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        StringLiteral ::
          `"` DoubleStringCharacters? `"`
          `'` SingleStringCharacters? `'`

        DoubleStringCharacters ::
          DoubleStringCharacter DoubleStringCharacters?

        SingleStringCharacters ::
          SingleStringCharacter SingleStringCharacters?

        DoubleStringCharacter ::
          SourceCharacter but not one of `"` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        SingleStringCharacter ::
          SourceCharacter but not one of `'` or `\` or LineTerminator
          &lt;LS&gt;
          &lt;PS&gt;
          `\` EscapeSequence
          LineContinuation

        LineContinuation ::
          `\` LineTerminatorSequence

        EscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          LegacyOctalEscapeSequence
          NonOctalDecimalEscapeSequence
          HexEscapeSequence
          UnicodeEscapeSequence

        CharacterEscapeSequence ::
          SingleEscapeCharacter
          NonEscapeCharacter

        SingleEscapeCharacter :: one of
          `'` `"` `\` `b` `f` `n` `r` `t` `v`

        NonEscapeCharacter ::
          SourceCharacter but not one of EscapeCharacter or LineTerminator

        EscapeCharacter ::
          SingleEscapeCharacter
          DecimalDigit
          `x`
          `u`

        LegacyOctalEscapeSequence ::
          `0` [lookahead &isin; { `8`, `9` }]
          NonZeroOctalDigit [lookahead &notin; OctalDigit]
          ZeroToThree OctalDigit [lookahead &notin; OctalDigit]
          FourToSeven OctalDigit
          ZeroToThree OctalDigit OctalDigit

        NonZeroOctalDigit ::
          OctalDigit but not `0`

        ZeroToThree :: one of
          `0` `1` `2` `3`

        FourToSeven :: one of
          `4` `5` `6` `7`

        NonOctalDecimalEscapeSequence :: one of
          `8` `9`

        HexEscapeSequence ::
          `x` HexDigit HexDigit

        UnicodeEscapeSequence ::
          `u` Hex4Digits
          `u{` CodePoint `}`

        Hex4Digits ::
          HexDigit HexDigit HexDigit HexDigit
      </emu-grammar>
      <p>The definition of the nonterminal |HexDigit| is given in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>. |SourceCharacter| is defined in <emu-xref href="#sec-source-text"></emu-xref>.</p>
      <emu-note>
        <p>&lt;LF> and &lt;CR> cannot appear in a string literal, except as part of a |LineContinuation| to produce the empty code points sequence. The proper way to include either in the String value of a string literal is to use an escape sequence such as `\\n` or `\\u000A`.</p>
      </emu-note>

      <emu-clause id="sec-string-literals-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          EscapeSequence ::
            LegacyOctalEscapeSequence
            NonOctalDecimalEscapeSequence
        </emu-grammar>
        <ul>
          <li>It is a Syntax Error if IsStrict(this production) is *true*.</li>
        </ul>
        <emu-note>In non-strict code, this syntax is Legacy.</emu-note>
        <emu-note>
          <p>It is possible for string literals to precede a Use Strict Directive that places the enclosing code in <emu-xref href="#sec-strict-mode-code">strict mode</emu-xref>, and implementations must take care to enforce the above rules for such literals. For example, the following source text contains a Syntax Error:</p>
          <pre><code class="javascript">
            function invalid() { "\7"; "use strict"; }
          </code></pre>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-sv" oldids="sec-string-literals-static-semantics-stringvalue,sec-additional-syntax-string-literals-static-semantics" type="sdo">
        <h1>Static Semantics: SV ( ): a String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            <p>A string literal stands for a value of the String type. SV produces String values for string literals through recursive application on the various parts of the string literal. As part of this process, some Unicode code points within the string literal are interpreted as having a mathematical value, as described below or in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.</p>
          </dd>
        </dl>
        <ul>
          <li>
            The SV of <emu-grammar>StringLiteral :: `"` `"`</emu-grammar> is the empty String.
          </li>
          <li>
            The SV of <emu-grammar>StringLiteral :: `'` `'`</emu-grammar> is the empty String.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters</emu-grammar> is the string-concatenation of the SV of |DoubleStringCharacter| and the SV of |DoubleStringCharacters|.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters</emu-grammar> is the string-concatenation of the SV of |SingleStringCharacter| and the SV of |SingleStringCharacters|.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: SourceCharacter but not one of `"` or `\` or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: &lt;LS&gt;</emu-grammar> is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: &lt;PS&gt;</emu-grammar> is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>DoubleStringCharacter :: LineContinuation</emu-grammar> is the empty String.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: SourceCharacter but not one of `'` or `\` or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: &lt;LS&gt;</emu-grammar> is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: &lt;PS&gt;</emu-grammar> is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The SV of <emu-grammar>SingleStringCharacter :: LineContinuation</emu-grammar> is the empty String.
          </li>
          <li>
            The SV of <emu-grammar>EscapeSequence :: `0`</emu-grammar> is the String value consisting of the code unit 0x0000 (NULL).
          </li>
          <li>
            The SV of <emu-grammar>CharacterEscapeSequence :: SingleEscapeCharacter</emu-grammar> is the String value consisting of the code unit whose numeric value is determined by the |SingleEscapeCharacter| according to <emu-xref href="#table-string-single-character-escape-sequences"></emu-xref>.
          </li>
        </ul>
        <emu-table id="table-string-single-character-escape-sequences" caption="String Single Character Escape Sequences" oldids="table-34">
          <table>
            <thead>
              <tr>
                <th>
                  Escape Sequence
                </th>
                <th>
                  Code Unit Value
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Symbol
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `\\b`
              </td>
              <td>
                `0x0008`
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                &lt;BS>
              </td>
            </tr>
            <tr>
              <td>
                `\\t`
              </td>
              <td>
                `0x0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `\\n`
              </td>
              <td>
                `0x000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `\\v`
              </td>
              <td>
                `0x000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `\\f`
              </td>
              <td>
                `0x000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `\\r`
              </td>
              <td>
                `0x000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
            <tr>
              <td>
                `\\"`
              </td>
              <td>
                `0x0022`
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `"`
              </td>
            </tr>
            <tr>
              <td>
                `\\'`
              </td>
              <td>
                `0x0027`
              </td>
              <td>
                APOSTROPHE
              </td>
              <td>
                `'`
              </td>
            </tr>
            <tr>
              <td>
                `\\\\`
              </td>
              <td>
                `0x005C`
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\`
              </td>
            </tr>
          </table>
        </emu-table>
        <ul>
          <li>
            The SV of <emu-grammar>NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The SV of <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> is the String value consisting of the code unit whose numeric value is the MV of |LegacyOctalEscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>NonOctalDecimalEscapeSequence :: `8`</emu-grammar> is the String value consisting of the code unit 0x0038 (DIGIT EIGHT).
          </li>
          <li>
            The SV of <emu-grammar>NonOctalDecimalEscapeSequence :: `9`</emu-grammar> is the String value consisting of the code unit 0x0039 (DIGIT NINE).
          </li>
          <li>
            The SV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is the String value consisting of the code unit whose numeric value is the MV of |HexEscapeSequence|.
          </li>
          <li>
            The SV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is the String value consisting of the code unit whose numeric value is the MV of |Hex4Digits|.
          </li>
          <li>
            The SV of <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the MV of |CodePoint|.
          </li>
          <li>
            The SV of <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> is the String value consisting of the code unit 0x0000 (NULL).
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-string-literals-static-semantics-mv">
        <h1>Static Semantics: MV</h1>
        <ul>
          <li>
            The MV of <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit</emu-grammar> is (8 times the MV of |ZeroToThree|) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>LegacyOctalEscapeSequence :: FourToSeven OctalDigit</emu-grammar> is (8 times the MV of |FourToSeven|) plus the MV of |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>LegacyOctalEscapeSequence :: ZeroToThree OctalDigit OctalDigit</emu-grammar> is (64 (that is, 8<sup>2</sup>) times the MV of |ZeroToThree|) plus (8 times the MV of the first |OctalDigit|) plus the MV of the second |OctalDigit|.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `0`</emu-grammar> is 0.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `1`</emu-grammar> is 1.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `2`</emu-grammar> is 2.
          </li>
          <li>
            The MV of <emu-grammar>ZeroToThree :: `3`</emu-grammar> is 3.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `4`</emu-grammar> is 4.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `5`</emu-grammar> is 5.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `6`</emu-grammar> is 6.
          </li>
          <li>
            The MV of <emu-grammar>FourToSeven :: `7`</emu-grammar> is 7.
          </li>
          <li>
            The MV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is (16 times the MV of the first |HexDigit|) plus the MV of the second |HexDigit|.
          </li>
          <li>
            The MV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is (0x1000 × the MV of the first |HexDigit|) plus (0x100 × the MV of the second |HexDigit|) plus (0x10 × the MV of the third |HexDigit|) plus the MV of the fourth |HexDigit|.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-literals-regular-expression-literals">
      <h1>Regular Expression Literals</h1>
      <emu-note>
        <p>A regular expression literal is an input element that is converted to a RegExp object (see <emu-xref href="#sec-regexp-regular-expression-objects"></emu-xref>) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as `===` to each other even if the two literals' contents are identical. A RegExp object may also be created at runtime by `new RegExp` or calling the RegExp constructor as a function (see <emu-xref href="#sec-regexp-constructor"></emu-xref>).</p>
      </emu-note>
      <p>The productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The source text comprising the |RegularExpressionBody| and the |RegularExpressionFlags| are subsequently parsed again using the more stringent ECMAScript Regular Expression grammar (<emu-xref href="#sec-patterns"></emu-xref>).</p>
      <p>An implementation may extend the ECMAScript Regular Expression grammar defined in <emu-xref href="#sec-patterns"></emu-xref>, but it must not extend the |RegularExpressionBody| and |RegularExpressionFlags| productions defined below or the productions used by these productions.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        RegularExpressionLiteral ::
          `/` RegularExpressionBody `/` RegularExpressionFlags

        RegularExpressionBody ::
          RegularExpressionFirstChar RegularExpressionChars

        RegularExpressionChars ::
          [empty]
          RegularExpressionChars RegularExpressionChar

        RegularExpressionFirstChar ::
          RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionChar ::
          RegularExpressionNonTerminator but not one of `\` or `/` or `[`
          RegularExpressionBackslashSequence
          RegularExpressionClass

        RegularExpressionBackslashSequence ::
          `\` RegularExpressionNonTerminator

        RegularExpressionNonTerminator ::
          SourceCharacter but not LineTerminator

        RegularExpressionClass ::
          `[` RegularExpressionClassChars `]`

        RegularExpressionClassChars ::
          [empty]
          RegularExpressionClassChars RegularExpressionClassChar

        RegularExpressionClassChar ::
          RegularExpressionNonTerminator but not one of `]` or `\`
          RegularExpressionBackslashSequence

        RegularExpressionFlags ::
          [empty]
          RegularExpressionFlags IdentifierPartChar
      </emu-grammar>
      <emu-note>
        <p>Regular expression literals may not be empty; instead of representing an empty regular expression literal, the code unit sequence `//` starts a single-line comment. To specify an empty regular expression, use: `/(?:)/`.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-bodytext" type="sdo">
        <h1>Static Semantics: BodyText ( ): source text</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. Return the source text that was recognized as |RegularExpressionBody|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-flagtext" type="sdo">
        <h1>Static Semantics: FlagText ( ): source text</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegularExpressionLiteral :: `/` RegularExpressionBody `/` RegularExpressionFlags</emu-grammar>
        <emu-alg>
          1. Return the source text that was recognized as |RegularExpressionFlags|.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literal-lexical-components">
      <h1>Template Literal Lexical Components</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Template ::
          NoSubstitutionTemplate
          TemplateHead

        NoSubstitutionTemplate ::
          ``` TemplateCharacters? ```

        TemplateHead ::
          ``` TemplateCharacters? `${`

        TemplateSubstitutionTail ::
          TemplateMiddle
          TemplateTail

        TemplateMiddle ::
          `}` TemplateCharacters? `${`

        TemplateTail ::
          `}` TemplateCharacters? ```

        TemplateCharacters ::
          TemplateCharacter TemplateCharacters?

        TemplateCharacter ::
          `$` [lookahead != `{`]
          `\` TemplateEscapeSequence
          `\` NotEscapeSequence
          LineContinuation
          LineTerminatorSequence
          SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

        TemplateEscapeSequence ::
          CharacterEscapeSequence
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          UnicodeEscapeSequence

        NotEscapeSequence ::
          `0` DecimalDigit
          DecimalDigit but not `0`
          `x` [lookahead &notin; HexDigit]
          `x` HexDigit [lookahead &notin; HexDigit]
          `u` [lookahead &notin; HexDigit] [lookahead != `{`]
          `u` HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]
          `u` `{` [lookahead &notin; HexDigit]
          `u` `{` NotCodePoint [lookahead &notin; HexDigit]
          `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]

        NotCodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| > 0x10FFFF]

        CodePoint ::
          HexDigits[~Sep] [> but only if the MV of |HexDigits| &le; 0x10FFFF]
      </emu-grammar>
      <emu-note>
        <p>|TemplateSubstitutionTail| is used by the |InputElementTemplateTail| alternative lexical goal.</p>
      </emu-note>

      <emu-clause id="sec-static-semantics-tv" type="sdo" oldids="sec-static-semantics-tv-and-trv">
        <h1>Static Semantics: TV ( ): a String or *undefined*</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>A template literal component is interpreted by TV as a value of the String type. TV is used to construct the indexed components of a template object (colloquially, the template values). In TV, escape sequences are replaced by the UTF-16 code unit(s) of the Unicode code point represented by the escape sequence.</dd>
        </dl>
        <ul>
          <li>
            The TV of <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TV of <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TV of <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TV of <emu-grammar>TemplateTail :: `}` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> is *undefined* if the TV of |TemplateCharacter| is *undefined* or the TV of |TemplateCharacters| is *undefined*. Otherwise, it is the string-concatenation of the TV of |TemplateCharacter| and the TV of |TemplateCharacters|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: `$`</emu-grammar> is the String value consisting of the code unit 0x0024 (DOLLAR SIGN).
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> is the SV of |TemplateEscapeSequence|.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> is *undefined*.
          </li>
          <li>
            The TV of <emu-grammar>TemplateCharacter :: LineTerminatorSequence</emu-grammar> is the TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TV of <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> is the empty String.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-trv" type="sdo">
        <h1>Static Semantics: TRV ( ): a String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>A template literal component is interpreted by TRV as a value of the String type. TRV is used to construct the raw components of a template object (colloquially, the template raw values). TRV is similar to TV with the difference being that in TRV, escape sequences are interpreted as they appear in the literal.</dd>
        </dl>
        <ul>
          <li>
            The TRV of <emu-grammar>NoSubstitutionTemplate :: ``` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateHead :: ``` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateMiddle :: `}` `${`</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateTail :: `}` ```</emu-grammar> is the empty String.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacters :: TemplateCharacter TemplateCharacters</emu-grammar> is the string-concatenation of the TRV of |TemplateCharacter| and the TRV of |TemplateCharacters|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: SourceCharacter but not one of ``` or `\` or `$` or LineTerminator</emu-grammar> is the result of performing UTF16EncodeCodePoint on the code point matched by |SourceCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `$`</emu-grammar> is the String value consisting of the code unit 0x0024 (DOLLAR SIGN).
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` TemplateEscapeSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |TemplateEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateCharacter :: `\` NotEscapeSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |NotEscapeSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>TemplateEscapeSequence :: `0`</emu-grammar> is the String value consisting of the code unit 0x0030 (DIGIT ZERO).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `0` DecimalDigit</emu-grammar> is the string-concatenation of the code unit 0x0030 (DIGIT ZERO) and the TRV of |DecimalDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` [lookahead &notin; HexDigit]</emu-grammar> is the String value consisting of the code unit 0x0078 (LATIN SMALL LETTER X).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `x` HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X) and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` [lookahead &notin; HexDigit] [lookahead != `{`]</emu-grammar> is the String value consisting of the code unit 0x0075 (LATIN SMALL LETTER U).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first |HexDigit|, and the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` HexDigit HexDigit HexDigit [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the TRV of the first |HexDigit|, the TRV of the second |HexDigit|, and the TRV of the third |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the code unit 0x007B (LEFT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` NotCodePoint [lookahead &notin; HexDigit]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of |NotCodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>NotEscapeSequence :: `u` `{` CodePoint [lookahead &notin; HexDigit] [lookahead != `}`]</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), and the TRV of |CodePoint|.
          </li>
          <li>
            The TRV of <emu-grammar>DecimalDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>CharacterEscapeSequence :: NonEscapeCharacter</emu-grammar> is the SV of |NonEscapeCharacter|.
          </li>
          <li>
            The TRV of <emu-grammar>SingleEscapeCharacter :: one of `'` `"` `\` `b` `f` `n` `r` `t` `v`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>HexEscapeSequence :: `x` HexDigit HexDigit</emu-grammar> is the string-concatenation of the code unit 0x0078 (LATIN SMALL LETTER X), the TRV of the first |HexDigit|, and the TRV of the second |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U) and the TRV of |Hex4Digits|.
          </li>
          <li>
            The TRV of <emu-grammar>UnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar> is the string-concatenation of the code unit 0x0075 (LATIN SMALL LETTER U), the code unit 0x007B (LEFT CURLY BRACKET), the TRV of |CodePoint|, and the code unit 0x007D (RIGHT CURLY BRACKET).
          </li>
          <li>
            The TRV of <emu-grammar>Hex4Digits :: HexDigit HexDigit HexDigit HexDigit</emu-grammar> is the string-concatenation of the TRV of the first |HexDigit|, the TRV of the second |HexDigit|, the TRV of the third |HexDigit|, and the TRV of the fourth |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigits :: HexDigits HexDigit</emu-grammar> is the string-concatenation of the TRV of |HexDigits| and the TRV of |HexDigit|.
          </li>
          <li>
            The TRV of <emu-grammar>HexDigit :: one of `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`</emu-grammar> is the result of performing UTF16EncodeCodePoint on the single code point matched by this production.
          </li>
          <li>
            The TRV of <emu-grammar>LineContinuation :: `\` LineTerminatorSequence</emu-grammar> is the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS) and the TRV of |LineTerminatorSequence|.
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LF&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;LS&gt;</emu-grammar> is the String value consisting of the code unit 0x2028 (LINE SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;PS&gt;</emu-grammar> is the String value consisting of the code unit 0x2029 (PARAGRAPH SEPARATOR).
          </li>
          <li>
            The TRV of <emu-grammar>LineTerminatorSequence :: &lt;CR&gt; &lt;LF&gt;</emu-grammar> is the String value consisting of the code unit 0x000A (LINE FEED).
          </li>
        </ul>
        <emu-note>
          <p>TV excludes the code units of |LineContinuation| while TRV includes them. &lt;CR>&lt;LF> and &lt;CR> |LineTerminatorSequence|s are normalized to &lt;LF> for both TV and TRV. An explicit |TemplateEscapeSequence| is needed to include a &lt;CR> or &lt;CR>&lt;LF> sequence.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-automatic-semicolon-insertion">
    <h1>Automatic Semicolon Insertion</h1>
    <p>Most ECMAScript statements and declarations must be terminated with a semicolon. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.</p>

    <emu-clause id="sec-rules-of-automatic-semicolon-insertion" namespace="asi-rules">
      <h1>Rules of Automatic Semicolon Insertion</h1>
      <p>In the following rules, “token” means the actual recognized lexical token determined using the current lexical goal symbol as described in clause <emu-xref href="#sec-ecmascript-language-lexical-grammar"></emu-xref>.</p>
      <p>There are three basic rules of semicolon insertion:</p>
      <ol>
        <li>
          <p>When, as the source text is parsed from left to right, a token (called the <em>offending token</em>) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:</p>
          <ul>
            <li>
              The offending token is separated from the previous token by at least one |LineTerminator|.
            </li>
            <li>
              The offending token is `}`.
            </li>
            <li>
              The previous token is `)` and the inserted semicolon would then be parsed as the terminating semicolon of a do-while statement (<emu-xref href="#sec-do-while-statement"></emu-xref>).
            </li>
          </ul>
        </li>
        <li>
          When, as the source text is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single instance of the goal nonterminal, then a semicolon is automatically inserted at the end of the input stream.
        </li>
        <li>
          When, as the source text is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a <em>restricted production</em> and the token would be the first token for a terminal or nonterminal immediately following the annotation “[no |LineTerminator| here]” within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one |LineTerminator|, then a semicolon is automatically inserted before the restricted token.
        </li>
      </ol>
      <p>However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a `for` statement (see <emu-xref href="#sec-for-statement"></emu-xref>).</p>
      <emu-note>
        <p>The following are the only restricted productions in the grammar:</p>
        <emu-grammar>
          UpdateExpression[Yield, Await] :
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
            LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`

          ContinueStatement[Yield, Await] :
            `continue` `;`
            `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          BreakStatement[Yield, Await] :
            `break` `;`
            `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`

          ReturnStatement[Yield, Await] :
            `return` `;`
            `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          ThrowStatement[Yield, Await] :
            `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`

          YieldExpression[In, Await] :
            `yield`
            `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
            `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]

          ArrowFunction[In, Yield, Await] :
            ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

          AsyncFunctionDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
            [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncFunctionExpression :
            `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncMethod[Yield, Await] :
            `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

          AsyncGeneratorDeclaration[Yield, Await, Default] :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
            [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorExpression :
            `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncGeneratorMethod[Yield, Await] :
            `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

          AsyncArrowFunction[In, Yield, Await] :
            `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
            CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

          AsyncArrowHead :
            `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
        </emu-grammar>
        <p>The practical effect of these restricted productions is as follows:</p>
        <ul>
          <li>
            When a `++` or `--` token is encountered where the parser would treat it as a postfix operator, and at least one |LineTerminator| occurred between the preceding token and the `++` or `--` token, then a semicolon is automatically inserted before the `++` or `--` token.
          </li>
          <li>
            When a `continue`, `break`, `return`, `throw`, or `yield` token is encountered and a |LineTerminator| is encountered before the next token, a semicolon is automatically inserted after the `continue`, `break`, `return`, `throw`, or `yield` token.
          </li>
          <li>
            When arrow function parameter(s) are followed by a |LineTerminator| before a `=>` token, a semicolon is automatically inserted and the punctuator causes a syntax error.
          </li>
          <li>
            When an `async` token is followed by a |LineTerminator| before a `function` or |IdentifierName| or `(` token, a semicolon is automatically inserted and the `async` token is not treated as part of the same expression or class element as the following tokens.
          </li>
          <li>
            When an `async` token is followed by a |LineTerminator| before a `*` token, a semicolon is automatically inserted and the punctuator causes a syntax error.
          </li>
        </ul>
        <p>The resulting practical advice to ECMAScript programmers is:</p>
        <ul>
          <li>
            A postfix `++` or `--` operator should be on the same line as its operand.
          </li>
          <li>
            An |Expression| in a `return` or `throw` statement or an |AssignmentExpression| in a `yield` expression should start on the same line as the `return`, `throw`, or `yield` token.
          </li>
          <li>
            A |LabelIdentifier| in a `break` or `continue` statement should be on the same line as the `break` or `continue` token.
          </li>
          <li>
            The end of an arrow function's parameter(s) and its `=>` should be on the same line.
          </li>
          <li>
            The `async` token preceding an asynchronous function or method should be on the same line as the immediately following token.
          </li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-examples-of-automatic-semicolon-insertion">
      <h1>Examples of Automatic Semicolon Insertion</h1>
      <em>This section is non-normative.</em>
      <p>The source</p>
      <pre><code class="javascript">{ 1 2 } 3</code></pre>
      <p>is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source</p>
      <pre><code class="javascript">
        { 1
        2 } 3
      </code></pre>
      <p>is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        { 1
        ;2 ;} 3;
      </code></pre>
      <p>which is a valid ECMAScript sentence.</p>
      <p>The source</p>
      <pre><code class="javascript">
        for (a; b
        )
      </code></pre>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a `for` statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a `for` statement.</p>
      <p>The source</p>
      <pre><code class="javascript">
        return
        a + b
      </code></pre>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        return;
        a + b;
      </code></pre>
      <emu-note>
        <p>The expression `a + b` is not treated as a value to be returned by the `return` statement, because a |LineTerminator| separates it from the token `return`.</p>
      </emu-note>
      <p>The source</p>
      <pre><code class="javascript">
        a = b
        ++c
      </code></pre>
      <p>is transformed by automatic semicolon insertion into the following:</p>
      <pre><code class="javascript">
        a = b;
        ++c;
      </code></pre>
      <emu-note>
        <p>The token `++` is not treated as a postfix operator applying to the variable `b`, because a |LineTerminator| occurs between `b` and `++`.</p>
      </emu-note>
      <p>The source</p>
      <pre><code class="javascript">
        if (a &gt; b)
        else c = d
      </code></pre>
      <p>is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the `else` token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.</p>
      <p>The source</p>
      <pre><code class="javascript">
        a = b + c
        (d + e).print()
      </code></pre>
      <p>is <em>not</em> transformed by automatic semicolon insertion, because the parenthesized expression that begins the second line can be interpreted as an argument list for a function call:</p>
      <pre><code class="javascript">a = b + c(d + e).print()</code></pre>
      <p>In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.</p>
    </emu-clause>

    <emu-clause id="sec-interesting-cases-of-automatic-semicolon-insertion">
      <h1>Interesting Cases of Automatic Semicolon Insertion</h1>
      <em>This section is non-normative.</em>
      <p>ECMAScript programs can be written in a style with very few semicolons by relying on automatic semicolon insertion. As described above, semicolons are not inserted at every newline, and automatic semicolon insertion can depend on multiple tokens across line terminators.</p>

      <p>As new syntactic features are added to ECMAScript, additional grammar productions could be added that cause lines relying on automatic semicolon insertion preceding them to change grammar productions when parsed.</p>

      <p>For the purposes of this section, a case of automatic semicolon insertion is considered interesting if it is a place where a semicolon may or may not be inserted, depending on the source text which precedes it. The rest of this section describes a number of interesting cases of automatic semicolon insertion in this version of ECMAScript.</p>

      <emu-clause id="sec-asi-interesting-cases-in-statement-lists">
        <h1>Interesting Cases of Automatic Semicolon Insertion in Statement Lists</h1>
        <p>In a |StatementList|, many |StatementListItem|s end in semicolons, which may be omitted using automatic semicolon insertion. As a consequence of the rules above, at the end of a line ending an expression, a semicolon is required if the following line begins with any of the following:</p>
        <ul>
          <li><strong>An opening parenthesis (<code>(</code>)</strong>. Without a semicolon, the two lines together are treated as a |CallExpression|.</li>
          <li><strong>An opening square bracket (<code>[</code>)</strong>. Without a semicolon, the two lines together are treated as property access, rather than an |ArrayLiteral| or |ArrayAssignmentPattern|.</li>
          <li><strong>A template literal (<code>`</code>)</strong>. Without a semicolon, the two lines together are interpreted as a tagged Template (<emu-xref href="#sec-tagged-templates"></emu-xref>), with the previous expression as the |MemberExpression|.</li>
          <li><strong>Unary <code>+</code> or <code>-</code></strong>. Without a semicolon, the two lines together are interpreted as a usage of the corresponding binary operator.</li>
          <li><strong>A RegExp literal</strong>. Without a semicolon, the two lines together may be parsed instead as the `/` |MultiplicativeOperator|, for example if the RegExp has flags.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-asi-cases-with-no-lineterminator-here">
        <h1>Cases of Automatic Semicolon Insertion and “[no |LineTerminator| here]”</h1>
        <em>This section is non-normative.</em>
        <p>ECMAScript contains grammar productions which include “[no |LineTerminator| here]”. These productions are sometimes a means to have optional operands in the grammar. Introducing a |LineTerminator| in these locations would change the grammar production of a source text by using the grammar production without the optional operand.</p>

        <p>The rest of this section describes a number of productions using “[no |LineTerminator| here]” in this version of ECMAScript.</p>

        <emu-clause id="sec-no-lineterminator-here-automatic-semicolon-insertion-list">
          <h1>List of Grammar Productions with Optional Operands and “[no |LineTerminator| here]”</h1>
          <ul>
            <li>|UpdateExpression|.</li>
            <li>|ContinueStatement|.</li>
            <li>|BreakStatement|.</li>
            <li>|ReturnStatement|.</li>
            <li>|YieldExpression|.</li>
            <li>Async Function Definitions (<emu-xref href="#sec-async-function-definitions"></emu-xref>) with relation to Function Definitions (<emu-xref href="#sec-function-definitions"></emu-xref>)</li>
          </ul>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-identifiers">
    <h1>Identifiers</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IdentifierReference[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      BindingIdentifier[Yield, Await] :
        Identifier
        `yield`
        `await`

      LabelIdentifier[Yield, Await] :
        Identifier
        [~Yield] `yield`
        [~Await] `await`

      Identifier :
        IdentifierName but not ReservedWord
    </emu-grammar>

    <emu-note>
      <p>`yield` and `await` are permitted as |BindingIdentifier| in the grammar, and prohibited with static semantics below, to prohibit automatic semicolon insertion in cases such as</p>
      <pre><code class="javascript">
        let
        await 0;
      </code></pre>
    </emu-note>

    <emu-clause id="sec-identifiers-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>BindingIdentifier : Identifier</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsStrict(this production) is *true* and the StringValue of |Identifier| is either *"arguments"* or *"eval"*.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsStrict(this production) is *true*.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module|.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `yield`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter.
        </li>
      </ul>
      <emu-grammar>
        BindingIdentifier[Yield, Await] : `await`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter.
        </li>
      </ul>
      <emu-grammar>
        IdentifierReference[Yield, Await] : Identifier

        BindingIdentifier[Yield, Await] : Identifier

        LabelIdentifier[Yield, Await] : Identifier
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this production has a <sub>[Yield]</sub> parameter and the StringValue of |Identifier| is *"yield"*.
        </li>
        <li>
          It is a Syntax Error if this production has an <sub>[Await]</sub> parameter and the StringValue of |Identifier| is *"await"*.
        </li>
      </ul>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsStrict(this phrase) is *true* and the StringValue of |IdentifierName| is one of *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, *"static"*, or *"yield"*.
        </li>
        <li>
          It is a Syntax Error if the goal symbol of the syntactic grammar is |Module| and the StringValue of |IdentifierName| is *"await"*.
        </li>
        <li>
          It is a Syntax Error if the StringValue of |IdentifierName| is the StringValue of any |ReservedWord| except for `yield` or `await`.
        </li>
      </ul>
      <emu-note>
        <p>The StringValue of |IdentifierName| normalizes any Unicode escape sequences in |IdentifierName| hence such escapes cannot be used to write an |Identifier| whose code point sequence is the same as a |ReservedWord|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-stringvalue" oldids="sec-identifiers-static-semantics-stringvalue,sec-identifier-names-static-semantics-stringvalue" type="sdo">
      <h1>Static Semantics: StringValue ( ): a String</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        IdentifierName ::
          IdentifierStart
          IdentifierName IdentifierPart
      </emu-grammar>
      <emu-alg>
        1. Let _idTextUnescaped_ be the IdentifierCodePoints of |IdentifierName|.
        1. Return CodePointsToString(_idTextUnescaped_).
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `yield`

        BindingIdentifier : `yield`

        LabelIdentifier : `yield`
      </emu-grammar>
      <emu-alg>
        1. Return *"yield"*.
      </emu-alg>
      <emu-grammar>
        IdentifierReference : `await`

        BindingIdentifier : `await`

        LabelIdentifier : `await`
      </emu-grammar>
      <emu-alg>
        1. Return *"await"*.
      </emu-alg>
      <emu-grammar>Identifier : IdentifierName but not ReservedWord</emu-grammar>
      <emu-alg>
        1. Return the StringValue of |IdentifierName|.
      </emu-alg>
      <emu-grammar>
        PrivateIdentifier ::
          `#` IdentifierName
      </emu-grammar>
      <emu-alg>
        1. Return the string-concatenation of 0x0023 (NUMBER SIGN) and the StringValue of |IdentifierName|.
      </emu-alg>
      <emu-grammar>
        ModuleExportName : StringLiteral
      </emu-grammar>
      <emu-alg>
        1. Return the SV of |StringLiteral|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-identifiers-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>IdentifierReference : Identifier</emu-grammar>
      <emu-alg>
        1. Return ? ResolveBinding(StringValue of |Identifier|).
      </emu-alg>
      <emu-grammar>IdentifierReference : `yield`</emu-grammar>
      <emu-alg>
        1. Return ? ResolveBinding(*"yield"*).
      </emu-alg>
      <emu-grammar>IdentifierReference : `await`</emu-grammar>
      <emu-alg>
        1. Return ? ResolveBinding(*"await"*).
      </emu-alg>
      <emu-note>
        <p>The result of evaluating an |IdentifierReference| is always a value of type Reference.</p>
      </emu-note>
      <emu-note>
        <p>In non-strict code, the keyword `yield` may be used as an identifier. Evaluating the |IdentifierReference| resolves the binding of `yield` as if it was an |Identifier|. Early Error restriction ensures that such an evaluation only can occur for non-strict code.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-primary-expression">
    <h1>Primary Expression</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      PrimaryExpression[Yield, Await] :
        `this`
        IdentifierReference[?Yield, ?Await]
        Literal
        ArrayLiteral[?Yield, ?Await]
        ObjectLiteral[?Yield, ?Await]
        FunctionExpression
        ClassExpression[?Yield, ?Await]
        GeneratorExpression
        AsyncFunctionExpression
        AsyncGeneratorExpression
        RegularExpressionLiteral
        TemplateLiteral[?Yield, ?Await, ~Tagged]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `)`
        `(` `)`
        `(` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` `...` BindingPattern[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
        `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>
      When processing an instance of the production<br>
      <emu-grammar>PrimaryExpression[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:
    </p>
    <emu-grammar type="definition">
      ParenthesizedExpression[Yield, Await] :
        `(` Expression[+In, ?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-this-keyword">
      <h1>The `this` Keyword</h1>

      <emu-clause id="sec-this-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. Return ? ResolveThisBinding().
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-identifier-reference">
      <h1>Identifier Reference</h1>
      <p>See <emu-xref href="#sec-identifiers"></emu-xref> for |IdentifierReference|.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-literals">
      <h1>Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Literal :
          NullLiteral
          BooleanLiteral
          NumericLiteral
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-literals-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>Literal : NullLiteral</emu-grammar>
        <emu-alg>
          1. Return *null*.
        </emu-alg>
        <emu-grammar>Literal : BooleanLiteral</emu-grammar>
        <emu-alg>
          1. If |BooleanLiteral| is the token `false`, return *false*.
          1. If |BooleanLiteral| is the token `true`, return *true*.
        </emu-alg>
        <emu-grammar>Literal : NumericLiteral</emu-grammar>
        <emu-alg>
          1. Return the NumericValue of |NumericLiteral| as defined in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.
        </emu-alg>
        <emu-grammar>Literal : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return the SV of |StringLiteral| as defined in <emu-xref href="#sec-static-semantics-sv"></emu-xref>.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-initializer">
      <h1>Array Initializer</h1>
      <emu-note>
        <p>An |ArrayLiteral| is an expression describing the initialization of an Array, using a list, of zero or more expressions each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initializer is evaluated.</p>
      </emu-note>
      <p>Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an |AssignmentExpression| (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ArrayLiteral[Yield, Await] :
          `[` Elision? `]`
          `[` ElementList[?Yield, ?Await] `]`
          `[` ElementList[?Yield, ?Await] `,` Elision? `]`

        ElementList[Yield, Await] :
          Elision? AssignmentExpression[+In, ?Yield, ?Await]
          Elision? SpreadElement[?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
          ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]

        Elision :
          `,`
          Elision `,`

        SpreadElement[Yield, Await] :
          `...` AssignmentExpression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-runtime-semantics-arrayaccumulation" oldids="sec-static-semantics-elisionwidth" type="sdo">
        <h1>
          Runtime Semantics: ArrayAccumulation (
            _array_: an Array,
            _nextIndex_: an integer,
          ): either a normal completion containing an integer or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. Let _len_ be _nextIndex_ + 1.
          1. Perform ? Set(_array_, *"length"*, 𝔽(_len_), *true*).
          1. NOTE: The above step throws if _len_ exceeds 2<sup>32</sup> - 1.
          1. Return _len_.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. Return ? ArrayAccumulation of |Elision| with arguments _array_ and (_nextIndex_ + 1).
        </emu-alg>
        <emu-grammar>ElementList : Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. If |Elision| is present, then
            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.
          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.
          1. Let _initValue_ be ? GetValue(_initResult_).
          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).
          1. Return _nextIndex_ + 1.
        </emu-alg>
        <emu-grammar>ElementList : Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. If |Elision| is present, then
            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.
          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.
          1. If |Elision| is present, then
            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.
          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.
          1. Let _initValue_ be ? GetValue(_initResult_).
          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).
          1. Return _nextIndex_ + 1.
        </emu-alg>
        <emu-grammar>ElementList : ElementList `,` Elision? SpreadElement</emu-grammar>
        <emu-alg>
          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.
          1. If |Elision| is present, then
            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.
          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.
        </emu-alg>
        <emu-grammar>SpreadElement : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.
          1. Let _spreadObj_ be ? GetValue(_spreadRef_).
          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _nextIndex_.
            1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_).
            1. Set _nextIndex_ to _nextIndex_ + 1.
        </emu-alg>
        <emu-note>
          <p>CreateDataPropertyOrThrow is used to ensure that own properties are defined for the array even if the standard built-in Array prototype object has been modified in a manner that would preclude the creation of new own properties using [[Set]].</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ArrayLiteral : `[` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Let _array_ be ! ArrayCreate(0).
          1. If |Elision| is present, then
            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.
          1. Return _array_.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `]`</emu-grammar>
        <emu-alg>
          1. Let _array_ be ! ArrayCreate(0).
          1. Perform ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.
          1. Return _array_.
        </emu-alg>
        <emu-grammar>ArrayLiteral : `[` ElementList `,` Elision? `]`</emu-grammar>
        <emu-alg>
          1. Let _array_ be ! ArrayCreate(0).
          1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.
          1. If |Elision| is present, then
            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.
          1. Return _array_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-object-initializer">
      <h1>Object Initializer</h1>
      <emu-note>
        <p>An object initializer is an expression describing the initialization of an Object, written in a form resembling a literal. It is a list of zero or more pairs of property keys and associated values, enclosed in curly brackets. The values need not be literals; they are evaluated each time the object initializer is evaluated.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ObjectLiteral[Yield, Await] :
          `{` `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `}`
          `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`

        PropertyDefinitionList[Yield, Await] :
          PropertyDefinition[?Yield, ?Await]
          PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]

        PropertyDefinition[Yield, Await] :
          IdentifierReference[?Yield, ?Await]
          CoverInitializedName[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
          MethodDefinition[?Yield, ?Await]
          `...` AssignmentExpression[+In, ?Yield, ?Await]

        PropertyName[Yield, Await] :
          LiteralPropertyName
          ComputedPropertyName[?Yield, ?Await]

        LiteralPropertyName :
          IdentifierName
          StringLiteral
          NumericLiteral

        ComputedPropertyName[Yield, Await] :
          `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

        CoverInitializedName[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

        Initializer[In, Yield, Await] :
          `=` AssignmentExpression[?In, ?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>|MethodDefinition| is defined in <emu-xref href="#sec-method-definitions"></emu-xref>.</p>
      </emu-note>
      <emu-note>
        <p>In certain contexts, |ObjectLiteral| is used as a cover grammar for a more restricted secondary grammar. The |CoverInitializedName| production is necessary to fully cover these secondary grammars. However, use of this production results in an early Syntax Error in normal contexts where an actual |ObjectLiteral| is expected.</p>
      </emu-note>

      <emu-clause id="sec-object-initializer-static-semantics-early-errors" oldids="sec-__proto__-property-names-in-object-initializers">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.
          </li>
          <li>
            It is a Syntax Error if the PrivateBoundIdentifiers of |MethodDefinition| is not empty.
          </li>
        </ul>
        <p>In addition to describing an actual object initializer the |ObjectLiteral| productions are also used as a cover grammar for |ObjectAssignmentPattern| and may be recognized as part of a |CoverParenthesizedExpressionAndArrowParameterList|. When |ObjectLiteral| appears in a context where |ObjectAssignmentPattern| is required the following Early Error rules are <b>not</b> applied. In addition, they are not applied when initially parsing a |CoverParenthesizedExpressionAndArrowParameterList| or |CoverCallExpressionAndAsyncArrowHead|.</p>
        <emu-grammar>PropertyDefinition : CoverInitializedName</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this production.
          </li>
        </ul>
        <emu-note>
          <p>This production exists so that |ObjectLiteral| can serve as a cover grammar for |ObjectAssignmentPattern|. It cannot occur in an actual object initializer.</p>
        </emu-note>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the PropertyNameList of |PropertyDefinitionList| contains any duplicate entries for *"__proto__"* and at least two of those entries were obtained from productions of the form <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>. This rule is not applied if this |ObjectLiteral| is contained within a |Script| that is being parsed for ParseJSON (see step <emu-xref href="#step-json-parse-parse"></emu-xref> of ParseJSON).
          </li>
        </ul>
        <emu-note>
          <p>The List returned by PropertyNameList does not include property names defined using a |ComputedPropertyName|.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-iscomputedpropertykey" type="sdo">
        <h1>Static Semantics: IsComputedPropertyKey ( ): a Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyName : LiteralPropertyName</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>PropertyName : ComputedPropertyName</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-propertynamelist" type="sdo">
        <h1>Static Semantics: PropertyNameList ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinition</emu-grammar>
        <emu-alg>
          1. Let _propName_ be the PropName of |PropertyDefinition|.
          1. If _propName_ is ~empty~, return a new empty List.
          1. Return « _propName_ ».
        </emu-alg>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. Let _list_ be the PropertyNameList of |PropertyDefinitionList|.
          1. Let _propName_ be the PropName of |PropertyDefinition|.
          1. If _propName_ is ~empty~, return _list_.
          1. Return the list-concatenation of _list_ and « _propName_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object-initializer-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ObjectLiteral : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return OrdinaryObjectCreate(%Object.prototype%).
        </emu-alg>
        <emu-grammar>
          ObjectLiteral :
            `{` PropertyDefinitionList `}`
            `{` PropertyDefinitionList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.
          1. Return _obj_.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return the StringValue of |IdentifierName|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return the SV of |StringLiteral|.
        </emu-alg>
        <emu-grammar>LiteralPropertyName : NumericLiteral</emu-grammar>
        <emu-alg>
          1. Let _nbr_ be the NumericValue of |NumericLiteral|.
          1. Return ! ToString(_nbr_).
        </emu-alg>
        <emu-grammar>ComputedPropertyName : `[` AssignmentExpression `]`</emu-grammar>
        <emu-alg>
          1. Let _exprValue_ be ? Evaluation of |AssignmentExpression|.
          1. Let _propName_ be ? GetValue(_exprValue_).
          1. Return ? ToPropertyKey(_propName_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydefinitionevaluation" oldids="sec-object-initializer-runtime-semantics-propertydefinitionevaluation" type="sdo">
        <h1>
          Runtime Semantics: PropertyDefinitionEvaluation (
            _object_: an Object,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _object_.
          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinition| with argument _object_.
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _exprValue_ be ? Evaluation of |AssignmentExpression|.
          1. Let _fromValue_ be ? GetValue(_exprValue_).
          1. Let _excludedNames_ be a new empty List.
          1. Perform ? CopyDataProperties(_object_, _fromValue_, _excludedNames_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. Let _propName_ be the StringValue of |IdentifierReference|.
          1. Let _exprValue_ be ? Evaluation of |IdentifierReference|.
          1. Let _propValue_ be ? GetValue(_exprValue_).
          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
          1. Perform ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _propKey_ be ? Evaluation of |PropertyName|.
          1. If this |PropertyDefinition| is contained within a |Script| that is being evaluated for ParseJSON (see step <emu-xref href="#step-json-parse-eval"></emu-xref> of ParseJSON), then
            1. Let _isProtoSetter_ be *false*.
          1. Else if _propKey_ is *"__proto__"* and IsComputedPropertyKey of |PropertyName| is *false*, then
            1. Let _isProtoSetter_ be *true*.
          1. Else,
            1. Let _isProtoSetter_ be *false*.
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and _isProtoSetter_ is *false*, then
            1. Let _propValue_ be ? NamedEvaluation of |AssignmentExpression| with argument _propKey_.
          1. Else,
            1. Let _exprValueRef_ be ? Evaluation of |AssignmentExpression|.
            1. Let _propValue_ be ? GetValue(_exprValueRef_).
          1. If _isProtoSetter_ is *true*, then
            1. If _propValue_ is an Object or _propValue_ is *null*, then
              1. Perform ! <emu-meta effects="user-code">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_).
            1. Return ~unused~.
          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
          1. Perform ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>PropertyDefinition : MethodDefinition</emu-grammar>
        <emu-alg>
          1. Perform ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *true*.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-defining-expressions">
      <h1>Function Defining Expressions</h1>
      <p>See <emu-xref href="#sec-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : FunctionExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-generator-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : GeneratorExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-class-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : ClassExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-async-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : AsyncFunctionExpression</emu-grammar>.</p>
      <p>See <emu-xref href="#sec-async-generator-function-definitions"></emu-xref> for <emu-grammar>PrimaryExpression : AsyncGeneratorExpression</emu-grammar>.</p>
    </emu-clause>

    <emu-clause id="sec-primary-expression-regular-expression-literals">
      <h1>Regular Expression Literals</h1>
      <h2>Syntax</h2>
      <p>See <emu-xref href="#sec-literals-regular-expression-literals"></emu-xref>.</p>

      <emu-clause id="sec-primary-expression-regular-expression-literals-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsValidRegularExpressionLiteral(|RegularExpressionLiteral|) is *false*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-isvalidregularexpressionliteral" type="abstract operation">
        <h1>
          Static Semantics: IsValidRegularExpressionLiteral (
            _literal_: a |RegularExpressionLiteral| Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It determines if its argument is a valid regular expression literal.</dd>
        </dl>
        <emu-alg>
          1. Let _flags_ be the FlagText of _literal_.
          1. If _flags_ contains any code points other than `d`, `g`, `i`, `m`, `s`, `u`, `v`, or `y`, or if _flags_ contains any code point more than once, return *false*.
          1. If _flags_ contains `u`, let _u_ be *true*; else let _u_ be *false*.
          1. If _flags_ contains `v`, let _v_ be *true*; else let _v_ be *false*.
          1. Let _patternText_ be the BodyText of _literal_.
          1. If _u_ is *false* and _v_ is *false*, then
            1. Let _stringValue_ be CodePointsToString(_patternText_).
            1. Set _patternText_ to the sequence of code points resulting from interpreting each of the 16-bit elements of _stringValue_ as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).
          1. If _parseResult_ is a Parse Node, return *true*; else return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regular-expression-literals-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : RegularExpressionLiteral</emu-grammar>
        <emu-alg>
          1. Let _pattern_ be CodePointsToString(BodyText of |RegularExpressionLiteral|).
          1. Let _flags_ be CodePointsToString(FlagText of |RegularExpressionLiteral|).
          1. Return ! RegExpCreate(_pattern_, _flags_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-template-literals">
      <h1>Template Literals</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        TemplateLiteral[Yield, Await, Tagged] :
          NoSubstitutionTemplate
          SubstitutionTemplate[?Yield, ?Await, ?Tagged]

        SubstitutionTemplate[Yield, Await, Tagged] :
          TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

        TemplateSpans[Yield, Await, Tagged] :
          TemplateTail
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

        TemplateMiddleList[Yield, Await, Tagged] :
          TemplateMiddle Expression[+In, ?Yield, ?Await]
          TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-static-semantics-template-early-errors" oldids="sec-primary-expression-template-literals-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : NoSubstitutionTemplate
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |NoSubstitutionTemplate| Contains |NotEscapeSequence|.
          </li>
        </ul>

        <emu-grammar>
          TemplateLiteral[Yield, Await, Tagged] : SubstitutionTemplate[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the number of elements in the TemplateStrings of |TemplateLiteral| with argument *false* is greater than or equal to 2<sup>32</sup>.
          </li>
        </ul>

        <emu-grammar>
          SubstitutionTemplate[Yield, Await, Tagged] : TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateHead| Contains |NotEscapeSequence|.
          </li>
        </ul>

        <emu-grammar>
          TemplateSpans[Yield, Await, Tagged] : TemplateTail
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateTail| Contains |NotEscapeSequence|.
          </li>
        </ul>

        <emu-grammar>
          TemplateMiddleList[Yield, Await, Tagged] :
            TemplateMiddle Expression[+In, ?Yield, ?Await]
            TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the <sub>[Tagged]</sub> parameter was not set and |TemplateMiddle| Contains |NotEscapeSequence|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-templatestrings" type="sdo">
        <h1>
          Static Semantics: TemplateStrings (
            _raw_: a Boolean,
          ): a List of either Strings or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. Return « TemplateString(|NoSubstitutionTemplate|, _raw_) ».
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. Let _head_ be « TemplateString(|TemplateHead|, _raw_) ».
          1. Let _tail_ be the TemplateStrings of |TemplateSpans| with argument _raw_.
          1. Return the list-concatenation of _head_ and _tail_.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. Return « TemplateString(|TemplateTail|, _raw_) ».
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. Let _middle_ be the TemplateStrings of |TemplateMiddleList| with argument _raw_.
          1. Let _tail_ be « TemplateString(|TemplateTail|, _raw_) ».
          1. Return the list-concatenation of _middle_ and _tail_.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Return « TemplateString(|TemplateMiddle|, _raw_) ».
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _front_ be the TemplateStrings of |TemplateMiddleList| with argument _raw_.
          1. Let _last_ be « TemplateString(|TemplateMiddle|, _raw_) ».
          1. Return the list-concatenation of _front_ and _last_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-templatestring" type="abstract operation">
        <h1>
          Static Semantics: TemplateString (
            _templateToken_: a |NoSubstitutionTemplate| Parse Node, a |TemplateHead| Parse Node, a |TemplateMiddle| Parse Node, or a |TemplateTail| Parse Node,
            _raw_: a Boolean,
          ): a String or *undefined*
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _raw_ is *true*, then
            1. Let _string_ be the TRV of _templateToken_.
          1. Else,
            1. Let _string_ be the TV of _templateToken_.
          1. Return _string_.
        </emu-alg>
        <emu-note>
          <p>This operation returns *undefined* if _raw_ is *false* and _templateToken_ contains a |NotEscapeSequence|. In all other cases, it returns a String.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-gettemplateobject" type="abstract operation">
        <h1>
          GetTemplateObject (
            _templateLiteral_: a Parse Node,
          ): an Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _realm_ be the current Realm Record.
          1. Let _templateRegistry_ be _realm_.[[TemplateMap]].
          1. For each element _e_ of _templateRegistry_, do
            1. If _e_.[[Site]] is the same Parse Node as _templateLiteral_, then
              1. Return _e_.[[Array]].
          1. Let _rawStrings_ be the TemplateStrings of _templateLiteral_ with argument *true*.
          1. Assert: _rawStrings_ is a List of Strings.
          1. Let _cookedStrings_ be the TemplateStrings of _templateLiteral_ with argument *false*.
          1. Let _count_ be the number of elements in the List _cookedStrings_.
          1. Assert: _count_ ≤ 2<sup>32</sup> - 1.
          1. Let _template_ be ! ArrayCreate(_count_).
          1. Let _rawObj_ be ! ArrayCreate(_count_).
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _count_,
            1. Let _prop_ be ! ToString(𝔽(_index_)).
            1. Let _cookedValue_ be _cookedStrings_[_index_].
            1. Perform ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).
            1. Let _rawValue_ be the String value _rawStrings_[_index_].
            1. Perform ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).
            1. Set _index_ to _index_ + 1.
          1. Perform ! SetIntegrityLevel(_rawObj_, ~frozen~).
          1. Perform ! DefinePropertyOrThrow(_template_, *"raw"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Perform ! SetIntegrityLevel(_template_, ~frozen~).
          1. Append the Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } to _realm_.[[TemplateMap]].
          1. Return _template_.
        </emu-alg>
        <emu-note>
          <p>The creation of a template object cannot result in an abrupt completion.</p>
        </emu-note>
        <emu-note>
          <p>Each |TemplateLiteral| in the program code of a realm is associated with a unique template object that is used in the evaluation of tagged Templates (<emu-xref href="#sec-template-literals-runtime-semantics-evaluation"></emu-xref>). The template objects are frozen and the same template object is used each time a specific tagged Template is evaluated. Whether template objects are created lazily upon first evaluation of the |TemplateLiteral| or eagerly prior to first evaluation is an implementation choice that is not observable to ECMAScript code.</p>
        </emu-note>
        <emu-note>
          <p>Future editions of this specification may define additional non-enumerable properties of template objects.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-substitutionevaluation" type="sdo">
        <h1>Runtime Semantics: SubstitutionEvaluation ( ): either a normal completion containing a List of ECMAScript language values or an abrupt completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. Return ? SubstitutionEvaluation of |TemplateMiddleList|.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _subRef_ be ? Evaluation of |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Return « _sub_ ».
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _preceding_ be ? SubstitutionEvaluation of |TemplateMiddleList|.
          1. Let _nextRef_ be ? Evaluation of |Expression|.
          1. Let _next_ be ? GetValue(_nextRef_).
          1. Return the list-concatenation of _preceding_ and « _next_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-template-literals-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. Return the TV of |NoSubstitutionTemplate| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. Let _head_ be the TV of |TemplateHead| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Let _subRef_ be ? Evaluation of |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Let _middle_ be ? ToString(_sub_).
          1. Let _tail_ be ? Evaluation of |TemplateSpans|.
          1. Return the string-concatenation of _head_, _middle_, and _tail_.
        </emu-alg>
        <emu-note>
          <p>The string conversion semantics applied to the |Expression| value are like `String.prototype.concat` rather than the `+` operator.</p>
        </emu-note>
        <emu-grammar>TemplateSpans : TemplateTail</emu-grammar>
        <emu-alg>
          1. Return the TV of |TemplateTail| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
        </emu-alg>
        <emu-grammar>TemplateSpans : TemplateMiddleList TemplateTail</emu-grammar>
        <emu-alg>
          1. Let _head_ be ? Evaluation of |TemplateMiddleList|.
          1. Let _tail_ be the TV of |TemplateTail| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Return the string-concatenation of _head_ and _tail_.
        </emu-alg>
        <emu-grammar>TemplateMiddleList : TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _head_ be the TV of |TemplateMiddle| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Let _subRef_ be ? Evaluation of |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Let _middle_ be ? ToString(_sub_).
          1. Return the string-concatenation of _head_ and _middle_.
        </emu-alg>
        <emu-note>
          <p>The string conversion semantics applied to the |Expression| value are like `String.prototype.concat` rather than the `+` operator.</p>
        </emu-note>
        <emu-grammar>TemplateMiddleList : TemplateMiddleList TemplateMiddle Expression</emu-grammar>
        <emu-alg>
          1. Let _rest_ be ? Evaluation of |TemplateMiddleList|.
          1. Let _middle_ be the TV of |TemplateMiddle| as defined in <emu-xref href="#sec-template-literal-lexical-components"></emu-xref>.
          1. Let _subRef_ be ? Evaluation of |Expression|.
          1. Let _sub_ be ? GetValue(_subRef_).
          1. Let _last_ be ? ToString(_sub_).
          1. Return the string-concatenation of _rest_, _middle_, and _last_.
        </emu-alg>
        <emu-note>
          <p>The string conversion semantics applied to the |Expression| value are like `String.prototype.concat` rather than the `+` operator.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-grouping-operator">
      <h1>The Grouping Operator</h1>

      <emu-clause id="sec-grouping-operator-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <ul>
          <li>
            |CoverParenthesizedExpressionAndArrowParameterList| must cover a |ParenthesizedExpression|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-grouping-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
          1. Return ? Evaluation of _expr_.
        </emu-alg>
        <emu-grammar>ParenthesizedExpression : `(` Expression `)`</emu-grammar>
        <emu-alg>
          1. Return ? Evaluation of |Expression|. This may be of type Reference.
        </emu-alg>
        <emu-note>
          <p>This algorithm does not apply GetValue to Evaluation of |Expression|. The principal motivation for this is so that operators such as `delete` and `typeof` may be applied to parenthesized expressions.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MemberExpression[Yield, Await] :
        PrimaryExpression[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        MemberExpression[?Yield, ?Await] `.` IdentifierName
        MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        SuperProperty[?Yield, ?Await]
        MetaProperty
        `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        MemberExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperProperty[Yield, Await] :
        `super` `[` Expression[+In, ?Yield, ?Await] `]`
        `super` `.` IdentifierName

      MetaProperty :
        NewTarget
        ImportMeta

      NewTarget :
        `new` `.` `target`

      ImportMeta :
        `import` `.` `meta`

      NewExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await]
        `new` NewExpression[?Yield, ?Await]

      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      SuperCall[Yield, Await] :
        `super` Arguments[?Yield, ?Await]

      ImportCall[Yield, Await] :
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
        `import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`

      Arguments[Yield, Await] :
        `(` `)`
        `(` ArgumentList[?Yield, ?Await] `)`
        `(` ArgumentList[?Yield, ?Await] `,` `)`

      ArgumentList[Yield, Await] :
        AssignmentExpression[+In, ?Yield, ?Await]
        `...` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
        ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]

      OptionalExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        CallExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await] OptionalChain[?Yield, ?Await]

      OptionalChain[Yield, Await] :
        `?.` Arguments[?Yield, ?Await]
        `?.` `[` Expression[+In, ?Yield, ?Await] `]`
        `?.` IdentifierName
        `?.` TemplateLiteral[?Yield, ?Await, +Tagged]
        `?.` PrivateIdentifier
        OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]
        OptionalChain[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        OptionalChain[?Yield, ?Await] `.` IdentifierName
        OptionalChain[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        OptionalChain[?Yield, ?Await] `.` PrivateIdentifier

      LeftHandSideExpression[Yield, Await] :
        NewExpression[?Yield, ?Await]
        CallExpression[?Yield, ?Await]
        OptionalExpression[?Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>
      When processing an instance of the production<br>
      <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar><br>
      the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:
    </p>
    <emu-grammar type="definition">
      CallMemberExpression[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-static-semantics">
      <h1>Static Semantics</h1>

      <emu-clause id="sec-left-hand-side-expressions-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          OptionalChain :
            `?.` TemplateLiteral
            OptionalChain TemplateLiteral
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this production.
          </li>
        </ul>
        <emu-note>
          <p>This production exists in order to prevent automatic semicolon insertion rules (<emu-xref href="#sec-automatic-semicolon-insertion"></emu-xref>) from being applied to the following code:</p>
          <pre><code class="javascript">
            a?.b
            `c`
          </code></pre>
          <p>so that it would be interpreted as two valid statements. The purpose is to maintain consistency with similar code without optional chaining:</p>
          <pre><code class="javascript">
            a.b
            `c`
          </code></pre>
          <p>which is a valid statement and where automatic semicolon insertion does not apply.</p>
        </emu-note>

        <emu-grammar>
          ImportMeta :
            `import` `.` `meta`
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the syntactic goal symbol is not |Module|.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-property-accessors">
      <h1>Property Accessors</h1>
      <emu-note>
        <p>Properties are accessed by name, using either the dot notation:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|<br>
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>or the bracket notation:</p>
        <div class="rhs">
          |MemberExpression| `[` |Expression| `]`<br>
          |CallExpression| `[` |Expression| `]`
        </div>
        <p>The dot notation is explained by the following syntactic conversion:</p>
        <div class="rhs">
          |MemberExpression| `.` |IdentifierName|
        </div>
        <p>is identical in its behaviour to</p>
        <div class="rhs">
          |MemberExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>and similarly</p>
        <div class="rhs">
          |CallExpression| `.` |IdentifierName|
        </div>
        <p>is identical in its behaviour to</p>
        <div class="rhs">
          |CallExpression| `[` &lt;<i>identifier-name-string</i>> `]`
        </div>
        <p>where &lt;<i>identifier-name-string</i>> is the StringValue of |IdentifierName|.</p>
      </emu-note>

      <emu-clause id="sec-property-accessors-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _strict_ be IsStrict(this |MemberExpression|).
          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _strict_ be IsStrict(this |MemberExpression|).
          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).
        </emu-alg>
        <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |CallExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _strict_ be IsStrict(this |CallExpression|).
          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |CallExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _strict_ be IsStrict(this |CallExpression|).
          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |CallExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-expression-key" type="abstract operation" oldids="sec-evaluate-expression-key-property-access">
      <h1>
        EvaluatePropertyAccessWithExpressionKey (
          _baseValue_: an ECMAScript language value,
          _expression_: an |Expression| Parse Node,
          _strict_: a Boolean,
        ): either a normal completion containing a Reference Record or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _propertyNameReference_ be ? Evaluation of _expression_.
        1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
        1. NOTE: In most cases, ToPropertyKey will be performed on _propertyNameValue_ immediately after this step. However, in the case of `a[b] = c`, it will not be performed until after evaluation of `c`.
        1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameValue_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-evaluate-property-access-with-identifier-key" type="abstract operation" oldids="sec-evaluate-identifier-key-property-access">
      <h1>
        EvaluatePropertyAccessWithIdentifierKey (
          _baseValue_: an ECMAScript language value,
          _identifierName_: an |IdentifierName| Parse Node,
          _strict_: a Boolean,
        ): a Reference Record
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _propertyNameString_ be the StringValue of _identifierName_.
        1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-new-operator">
      <h1>The `new` Operator</h1>

      <emu-clause id="sec-new-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>NewExpression : `new` NewExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|NewExpression|, ~empty~).
        </emu-alg>
        <emu-grammar>MemberExpression : `new` MemberExpression Arguments</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|).
        </emu-alg>

        <emu-clause id="sec-evaluatenew" type="abstract operation">
          <h1>
            EvaluateNew (
              _constructExpr_: a |NewExpression| Parse Node or a |MemberExpression| Parse Node,
              _arguments_: ~empty~ or an |Arguments| Parse Node,
            ): either a normal completion containing an ECMAScript language value or an abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _ref_ be ? Evaluation of _constructExpr_.
            1. Let _constructor_ be ? GetValue(_ref_).
            1. If _arguments_ is ~empty~, then
              1. Let _argList_ be a new empty List.
            1. Else,
              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.
            1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.
            1. Return ? Construct(_constructor_, _argList_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-calls">
      <h1>Function Calls</h1>

      <emu-clause id="sec-function-calls-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
          1. Let _memberExpr_ be the |MemberExpression| of _expr_.
          1. Let _arguments_ be the |Arguments| of _expr_.
          1. Let _ref_ be ? Evaluation of _memberExpr_.
          1. Let _func_ be ? GetValue(_ref_).
          1. If _ref_ is a Reference Record, IsPropertyReference(_ref_) is *false*, and _ref_.[[ReferencedName]] is *"eval"*, then
            1. If SameValue(_func_, %eval%) is *true*, then
              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.
              1. If _argList_ has no elements, return *undefined*.
              1. Let _evalArg_ be the first element of _argList_.
              1. If IsStrict(this |CallExpression|) is *true*, let _strictCaller_ be *true*; otherwise let _strictCaller_ be *false*.
              1. [id="step-callexpression-evaluation-direct-eval"] Return ? PerformEval(_evalArg_, _strictCaller_, *true*).
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_).
        </emu-alg>
        <p>A |CallExpression| evaluation that executes step <emu-xref href="#step-callexpression-evaluation-direct-eval"></emu-xref> is a <dfn variants="direct evals">direct eval</dfn>.</p>
        <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>
        <emu-alg>
          1. Let _ref_ be ? Evaluation of |CallExpression|.
          1. Let _func_ be ? GetValue(_ref_).
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluatecall" type="abstract operation" oldids="sec-evaluatedirectcall">
        <h1>
          EvaluateCall (
            _func_: an ECMAScript language value,
            _ref_: an ECMAScript language value or a Reference Record,
            _arguments_: a Parse Node,
            _tailPosition_: a Boolean,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _ref_ is a Reference Record, then
            1. If IsPropertyReference(_ref_) is *true*, then
              1. Let _thisValue_ be GetThisValue(_ref_).
            1. Else,
              1. Let _refEnv_ be _ref_.[[Base]].
              1. Assert: _refEnv_ is an Environment Record.
              1. Let _thisValue_ be _refEnv_.WithBaseObject().
          1. Else,
            1. Let _thisValue_ be *undefined*.
          1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.
          1. If _func_ is not an Object, throw a *TypeError* exception.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. If _tailPosition_ is *true*, perform PrepareForTailCall().
          1. Return ? Call(_func_, _thisValue_, _argList_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-super-keyword">
      <h1>The `super` Keyword</h1>

      <emu-clause id="sec-super-keyword-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>SuperProperty : `super` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _env_ be GetThisEnvironment().
          1. Let _actualThis_ be ? _env_.GetThisBinding().
          1. Let _propertyNameReference_ be ? Evaluation of |Expression|.
          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
          1. Let _strict_ be IsStrict(this |SuperProperty|).
          1. NOTE: In most cases, ToPropertyKey will be performed on _propertyNameValue_ immediately after this step. However, in the case of `super[b] = c`, it will not be performed until after evaluation of `c`.
          1. Return MakeSuperPropertyReference(_actualThis_, _propertyNameValue_, _strict_).
        </emu-alg>
        <emu-grammar>SuperProperty : `super` `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _env_ be GetThisEnvironment().
          1. Let _actualThis_ be ? _env_.GetThisBinding().
          1. Let _propertyKey_ be the StringValue of |IdentifierName|.
          1. Let _strict_ be IsStrict(this |SuperProperty|).
          1. Return MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).
        </emu-alg>
        <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. Let _newTarget_ be GetNewTarget().
          1. Assert: _newTarget_ is a constructor.
          1. Let _func_ be GetSuperConstructor().
          1. Let _argList_ be ? ArgumentListEvaluation of |Arguments|.
          1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
          1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).
          1. Let _thisER_ be GetThisEnvironment().
          1. Assert: _thisER_ is a Function Environment Record.
          1. Perform ? BindThisValue(_thisER_, _result_).
          1. Let _F_ be _thisER_.[[FunctionObject]].
          1. Assert: _F_ is an ECMAScript function object.
          1. Perform ? InitializeInstanceElements(_result_, _F_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getsuperconstructor" type="abstract operation">
        <h1>GetSuperConstructor ( ): an ECMAScript language value</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _envRec_ be GetThisEnvironment().
          1. Assert: _envRec_ is a Function Environment Record.
          1. Let _activeFunction_ be _envRec_.[[FunctionObject]].
          1. Assert: _activeFunction_ is an ECMAScript function object.
          1. Let _superConstructor_ be ! _activeFunction_.[[GetPrototypeOf]]().
          1. Return _superConstructor_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makesuperpropertyreference" type="abstract operation">
        <h1>
          MakeSuperPropertyReference (
            _actualThis_: an ECMAScript language value,
            _propertyKey_: an ECMAScript language value,
            _strict_: a Boolean,
          ): a Super Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _env_ be GetThisEnvironment().
          1. Assert: _env_.HasSuperBinding() is *true*.
          1. Assert: _env_ is a Function Environment Record.
          1. Let _baseValue_ be GetSuperBase(_env_).
          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ }.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-argument-lists">
      <h1>Argument Lists</h1>
      <emu-note>
        <p>The evaluation of an argument list produces a List of values.</p>
      </emu-note>

      <emu-clause id="sec-runtime-semantics-argumentlistevaluation" oldids="sec-template-literals-runtime-semantics-argumentlistevaluation,sec-argument-lists-runtime-semantics-argumentlistevaluation" type="sdo">
        <h1>Runtime Semantics: ArgumentListEvaluation ( ): either a normal completion containing a List of ECMAScript language values or an abrupt completion</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Arguments : `(` `)`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ArgumentList : AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _ref_ be ? Evaluation of |AssignmentExpression|.
          1. Let _arg_ be ? GetValue(_ref_).
          1. Return « _arg_ ».
        </emu-alg>
        <emu-grammar>ArgumentList : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _list_ be a new empty List.
          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.
          1. Let _spreadObj_ be ? GetValue(_spreadRef_).
          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _list_.
            1. Append _next_ to _list_.
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.
          1. Let _ref_ be ? Evaluation of |AssignmentExpression|.
          1. Let _arg_ be ? GetValue(_ref_).
          1. Return the list-concatenation of _precedingArgs_ and « _arg_ ».
        </emu-alg>
        <emu-grammar>ArgumentList : ArgumentList `,` `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.
          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.
          1. Let _iteratorRecord_ be ? GetIterator(? GetValue(_spreadRef_), ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _precedingArgs_.
            1. Append _next_ to _precedingArgs_.
        </emu-alg>
        <emu-grammar>TemplateLiteral : NoSubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. Let _templateLiteral_ be this |TemplateLiteral|.
          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).
          1. Return « _siteObj_ ».
        </emu-alg>
        <emu-grammar>TemplateLiteral : SubstitutionTemplate</emu-grammar>
        <emu-alg>
          1. Let _templateLiteral_ be this |TemplateLiteral|.
          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).
          1. Let _remaining_ be ? ArgumentListEvaluation of |SubstitutionTemplate|.
          1. Return the list-concatenation of « _siteObj_ » and _remaining_.
        </emu-alg>
        <emu-grammar>SubstitutionTemplate : TemplateHead Expression TemplateSpans</emu-grammar>
        <emu-alg>
          1. Let _firstSubRef_ be ? Evaluation of |Expression|.
          1. Let _firstSub_ be ? GetValue(_firstSubRef_).
          1. Let _restSub_ be ? SubstitutionEvaluation of |TemplateSpans|.
          1. Assert: _restSub_ is a possibly empty List.
          1. Return the list-concatenation of « _firstSub_ » and _restSub_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-optional-chains">
      <h1>Optional Chains</h1>
      <emu-note>An optional chain is a chain of one or more property accesses and function calls, the first of which begins with the token `?.`.</emu-note>

      <emu-clause id="sec-optional-chaining-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>
          OptionalExpression :
            MemberExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. If _baseValue_ is either *undefined* or *null*, then
            1. Return *undefined*.
          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            CallExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |CallExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. If _baseValue_ is either *undefined* or *null*, then
            1. Return *undefined*.
          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.
        </emu-alg>
        <emu-grammar>
          OptionalExpression :
            OptionalExpression OptionalChain
        </emu-grammar>
        <emu-alg>
          1. Let _baseReference_ be ? Evaluation of |OptionalExpression|.
          1. Let _baseValue_ be ? GetValue(_baseReference_).
          1. If _baseValue_ is either *undefined* or *null*, then
            1. Return *undefined*.
          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-optional-chaining-chain-evaluation" type="sdo">
        <h1>
          Runtime Semantics: ChainEvaluation (
            _baseValue_: an ECMAScript language value,
            _baseReference_: an ECMAScript language value or a Reference Record,
          ): either a normal completion containing either an ECMAScript language value or a Reference Record, or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>
        <emu-alg>
          1. Let _thisChain_ be this |OptionalChain|.
          1. Let _tailCall_ be IsInTailPosition(_thisChain_).
          1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_).
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _strict_ be IsStrict(this |OptionalChain|).
          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _strict_ be IsStrict(this |OptionalChain|).
          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).
        </emu-alg>
        <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>
        <emu-alg>
          1. Let _optionalChain_ be |OptionalChain|.
          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
          1. Let _newValue_ be ? GetValue(_newReference_).
          1. Let _thisChain_ be this |OptionalChain|.
          1. Let _tailCall_ be IsInTailPosition(_thisChain_).
          1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_).
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>
        <emu-alg>
          1. Let _optionalChain_ be |OptionalChain|.
          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
          1. Let _newValue_ be ? GetValue(_newReference_).
          1. Let _strict_ be IsStrict(this |OptionalChain|).
          1. Return ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_).
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
        <emu-alg>
          1. Let _optionalChain_ be |OptionalChain|.
          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
          1. Let _newValue_ be ? GetValue(_newReference_).
          1. Let _strict_ be IsStrict(this |OptionalChain|).
          1. Return EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_).
        </emu-alg>
        <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
        <emu-alg>
          1. Let _optionalChain_ be |OptionalChain|.
          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
          1. Let _newValue_ be ? GetValue(_newReference_).
          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
          1. Return MakePrivateReference(_newValue_, _fieldNameString_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateImportCall(|AssignmentExpression|).
        </emu-alg>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateImportCall(the first |AssignmentExpression|, the second |AssignmentExpression|).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1>
          EvaluateImportCall (
            _specifierExpression_: a Parse Node,
            optional _optionsExpression_: a Parse Node,
          ): either a normal completion containing a Promise or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _specifierRef_ be ? Evaluation of _specifierExpression_.
          1. Let _specifier_ be ? GetValue(_specifierRef_).
          1. If _optionsExpression_ is present, then
            1. Let _optionsRef_ be ? Evaluation of _optionsExpression_.
            1. Let _options_ be ? GetValue(_optionsRef_).
          1. Else,
            1. Let _options_ be *undefined*.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _attributes_ be a new empty List.
          1. If _options_ is not *undefined*, then
            1. If _options_ is not an Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _attributesObj_ be Completion(Get(_options_, *"with"*)).
            1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_).
            1. If _attributesObj_ is not *undefined*, then
              1. If _attributesObj_ is not an Object, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
                1. Return _promiseCapability_.[[Promise]].
              1. Let _entries_ be Completion(EnumerableOwnProperties(_attributesObj_, ~key+value~)).
              1. IfAbruptRejectPromise(_entries_, _promiseCapability_).
              1. For each element _entry_ of _entries_, do
                1. Let _key_ be ! Get(_entry_, *"0"*).
                1. Let _value_ be ! Get(_entry_, *"1"*).
                1. If _key_ is a String, then
                  1. If _value_ is not a String, then
                    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
                    1. Return _promiseCapability_.[[Promise]].
                  1. Append the ImportAttribute Record { [[Key]]: _key_, [[Value]]: _value_ } to _attributes_.
            1. If AllImportAttributesSupported(_attributes_) is *false*, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Sort _attributes_ according to the lexicographic order of their [[Key]] field, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that hosts are prohibited from changing behaviour based on the order in which attributes are enumerated.
          1. Let _moduleRequest_ be a new ModuleRequest Record { [[Specifier]]: _specifierString_, [[Attributes]]: _attributes_ }.
          1. Perform HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            _promiseCapability_: a PromiseCapability Record,
            _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate.</dd>
        </dl>
        <emu-alg>
          1. If _moduleCompletion_ is an abrupt completion, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).
            1. Return ~unused~.
          1. Let _module_ be _moduleCompletion_.[[Value]].
          1. Let _loadPromise_ be _module_.LoadRequestedModules().
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).
            1. Return NormalCompletion(*undefined*).
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »).
          1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:
            1. Let _link_ be Completion(_module_.Link()).
            1. If _link_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).
              1. Return NormalCompletion(*undefined*).
            1. Let _evaluatePromise_ be _module_.Evaluate().
            1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:
              1. Let _namespace_ be GetModuleNamespace(_module_).
              1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).
              1. Return NormalCompletion(*undefined*).
            1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »).
            1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
            1. Return ~unused~.
          1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *""*, « »).
          1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tagged-templates">
      <h1>Tagged Templates</h1>
      <emu-note>
        <p>A tagged template is a function call where the arguments of the call are derived from a |TemplateLiteral| (<emu-xref href="#sec-template-literals"></emu-xref>). The actual arguments include a template object (<emu-xref href="#sec-gettemplateobject"></emu-xref>) and the values produced by evaluating the expressions embedded within the |TemplateLiteral|.</p>
      </emu-note>

      <emu-clause id="sec-tagged-templates-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>MemberExpression : MemberExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. Let _tagRef_ be ? Evaluation of |MemberExpression|.
          1. Let _tagFunc_ be ? GetValue(_tagRef_).
          1. Let _thisCall_ be this |MemberExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).
        </emu-alg>
        <emu-grammar>CallExpression : CallExpression TemplateLiteral</emu-grammar>
        <emu-alg>
          1. Let _tagRef_ be ? Evaluation of |CallExpression|.
          1. Let _tagFunc_ be ? GetValue(_tagRef_).
          1. Let _thisCall_ be this |CallExpression|.
          1. Let _tailCall_ be IsInTailPosition(_thisCall_).
          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-meta-properties">
      <h1>Meta Properties</h1>

      <emu-clause id="sec-meta-properties-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>NewTarget : `new` `.` `target`</emu-grammar>
        <emu-alg>
          1. Return GetNewTarget().
        </emu-alg>

        <emu-grammar>ImportMeta : `import` `.` `meta`</emu-grammar>
        <emu-alg>
          1. Let _module_ be GetActiveScriptOrModule().
          1. Assert: _module_ is a Source Text Module Record.
          1. Let _importMeta_ be _module_.[[ImportMeta]].
          1. If _importMeta_ is ~empty~, then
            1. Set _importMeta_ to OrdinaryObjectCreate(*null*).
            1. Let _importMetaValues_ be HostGetImportMetaProperties(_module_).
            1. For each Record { [[Key]], [[Value]] } _p_ of _importMetaValues_, do
              1. Perform ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]).
            1. Perform HostFinalizeImportMeta(_importMeta_, _module_).
            1. Set _module_.[[ImportMeta]] to _importMeta_.
            1. Return _importMeta_.
          1. Else,
            1. Assert: _importMeta_ is an Object.
            1. Return _importMeta_.
        </emu-alg>

        <emu-clause id="sec-hostgetimportmetaproperties" type="host-defined abstract operation">
          <h1>
            HostGetImportMetaProperties (
              _moduleRecord_: a Module Record,
            ): a List of Records with fields [[Key]] (a property key) and [[Value]] (an ECMAScript language value)
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It allows hosts to provide property keys and values for the object returned from `import.meta`.</dd>
          </dl>

          <p>The default implementation of HostGetImportMetaProperties is to return a new empty List.</p>
        </emu-clause>

        <emu-clause id="sec-hostfinalizeimportmeta" type="host-defined abstract operation">
          <h1>
            HostFinalizeImportMeta (
              _importMeta_: an Object,
              _moduleRecord_: a Module Record,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It allows hosts to perform any extraordinary operations to prepare the object returned from `import.meta`.</dd>
          </dl>

          <p>Most hosts will be able to simply define HostGetImportMetaProperties, and leave HostFinalizeImportMeta with its default behaviour. However, HostFinalizeImportMeta provides an "escape hatch" for hosts which need to directly manipulate the object before it is exposed to ECMAScript code.</p>

          <p>The default implementation of HostFinalizeImportMeta is to return ~unused~.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-update-expressions">
    <h1>Update Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UpdateExpression[Yield, Await] :
        LeftHandSideExpression[?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `++`
        LeftHandSideExpression[?Yield, ?Await] [no LineTerminator here] `--`
        `++` UnaryExpression[?Yield, ?Await]
        `--` UnaryExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-update-expressions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
      </emu-grammar>
      <ul>
        <li>
          It is an early Syntax Error if the AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
        </li>
      </ul>

      <emu-grammar>
        UpdateExpression :
          `++` UnaryExpression
          `--` UnaryExpression
      </emu-grammar>
      <ul>
        <li>
          It is an early Syntax Error if the AssignmentTargetType of |UnaryExpression| is ~invalid~.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-postfix-increment-operator">
      <h1>Postfix Increment Operator</h1>

      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? Evaluation of |LeftHandSideExpression|.
          1. If the AssignmentTargetType of |LeftHandSideExpression| is ~web-compat~, throw a *ReferenceError* exception.
          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).
          1. If _oldValue_ is a Number, then
            1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).
          1. Else,
            1. Assert: _oldValue_ is a BigInt.
            1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-postfix-decrement-operator">
      <h1>Postfix Decrement Operator</h1>

      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? Evaluation of |LeftHandSideExpression|.
          1. If the AssignmentTargetType of |LeftHandSideExpression| is ~web-compat~, throw a *ReferenceError* exception.
          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).
          1. If _oldValue_ is a Number, then
            1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).
          1. Else,
            1. Assert: _oldValue_ is a BigInt.
            1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-increment-operator">
      <h1>Prefix Increment Operator</h1>

      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. If the AssignmentTargetType of |UnaryExpression| is ~web-compat~, throw a *ReferenceError* exception.
          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).
          1. If _oldValue_ is a Number, then
            1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).
          1. Else,
            1. Assert: _oldValue_ is a BigInt.
            1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-prefix-decrement-operator">
      <h1>Prefix Decrement Operator</h1>

      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. If the AssignmentTargetType of |UnaryExpression| is ~web-compat~, throw a *ReferenceError* exception.
          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).
          1. If _oldValue_ is a Number, then
            1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).
          1. Else,
            1. Assert: _oldValue_ is a BigInt.
            1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unary-operators">
    <h1>Unary Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UnaryExpression[Yield, Await] :
        UpdateExpression[?Yield, ?Await]
        `delete` UnaryExpression[?Yield, ?Await]
        `void` UnaryExpression[?Yield, ?Await]
        `typeof` UnaryExpression[?Yield, ?Await]
        `+` UnaryExpression[?Yield, ?Await]
        `-` UnaryExpression[?Yield, ?Await]
        `~` UnaryExpression[?Yield, ?Await]
        `!` UnaryExpression[?Yield, ?Await]
        [+Await] AwaitExpression[?Yield]
    </emu-grammar>

    <emu-clause id="sec-delete-operator">
      <h1>The `delete` Operator</h1>

      <emu-clause id="sec-delete-operator-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsStrict(the |UnaryExpression|) is *true* and the derived |UnaryExpression| is <emu-grammar>PrimaryExpression : IdentifierReference</emu-grammar>, <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>, <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>, or <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>.
          </li>
          <li>
            <p>
              It is a Syntax Error if the derived |UnaryExpression| is<br>
              <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar><br>
              and |CoverParenthesizedExpressionAndArrowParameterList| ultimately derives a phrase that, if used in place of |UnaryExpression|, would produce a Syntax Error according to these rules. This rule is recursively applied.
            </p>
          </li>
        </ul>
        <emu-note>
          <p>The last rule means that expressions such as `delete (((foo)))` produce early errors because of recursive application of the first rule.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-delete-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `delete` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _ref_ be ? Evaluation of |UnaryExpression|.
          1. If _ref_ is not a Reference Record, return *true*.
          1. If IsUnresolvableReference(_ref_) is *true*, then
            1. Assert: _ref_.[[Strict]] is *false*.
            1. Return *true*.
          1. If IsPropertyReference(_ref_) is *true*, then
            1. Assert: IsPrivateReference(_ref_) is *false*.
            1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.
            1. [id="step-delete-operator-toobject"] Let _baseObj_ be ? ToObject(_ref_.[[Base]]).
            1. If _ref_.[[ReferencedName]] is not a property key, then
              1. Set _ref_.[[ReferencedName]] to ? ToPropertyKey(_ref_.[[ReferencedName]]).
            1. Let _deleteStatus_ be ? <emu-meta effects="user-code">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]]).
            1. If _deleteStatus_ is *false* and _ref_.[[Strict]] is *true*, throw a *TypeError* exception.
            1. Return _deleteStatus_.
          1. Else,
            1. Let _base_ be _ref_.[[Base]].
            1. Assert: _base_ is an Environment Record.
            1. Return ? <emu-meta effects="user-code">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]]).
        </emu-alg>
        <emu-note>
          <p>When a `delete` operator occurs within strict mode code, a *SyntaxError* exception is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name. In addition, if a `delete` operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: *false* } (or otherwise cannot be deleted), a *TypeError* exception is thrown.</p>
        </emu-note>
        <emu-note>
          <p>The object that may be created in step <emu-xref href="#step-delete-operator-toobject"></emu-xref> is not accessible outside of the above abstract operation and the ordinary object [[Delete]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-void-operator">
      <h1>The `void` Operator</h1>

      <emu-clause id="sec-void-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `void` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. Perform ? GetValue(_expr_).
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>GetValue must be called even though its value is not used because it may have observable side-effects.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typeof-operator">
      <h1>The `typeof` Operator</h1>

      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation" oldids="table-typeof-operator-results,sec-IsHTMLDDA-internal-slot-typeof" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _val_ be ? Evaluation of |UnaryExpression|.
          1. If _val_ is a Reference Record, then
            1. If IsUnresolvableReference(_val_) is *true*, return *"undefined"*.
          1. Set _val_ to ? GetValue(_val_).
          1. If _val_ is *undefined*, return *"undefined"*.
          1. If _val_ is *null*, return *"object"*.
          1. If _val_ is a String, return *"string"*.
          1. If _val_ is a Symbol, return *"symbol"*.
          1. If _val_ is a Boolean, return *"boolean"*.
          1. If _val_ is a Number, return *"number"*.
          1. If _val_ is a BigInt, return *"bigint"*.
          1. Assert: _val_ is an Object.
          1. [id="step-typeof-web-compat-insertion-point", normative-optional] If the host is a web browser or otherwise supports <emu-xref href="#sec-IsHTMLDDA-internal-slot" title></emu-xref>, then
            1. If _val_ has an [[IsHTMLDDA]] internal slot, return *"undefined"*.
          1. If _val_ has a [[Call]] internal method, return *"function"*.
          1. Return *"object"*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-plus-operator">
      <h1>Unary `+` Operator</h1>
      <emu-note>
        <p>The unary + operator converts its operand to Number type.</p>
      </emu-note>

      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. Return ? ToNumber(? GetValue(_expr_)).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unary-minus-operator">
      <h1>Unary `-` Operator</h1>
      <emu-note>
        <p>The unary `-` operator converts its operand to a numeric value and then negates it. Negating *+0*<sub>𝔽</sub> produces *-0*<sub>𝔽</sub>, and negating *-0*<sub>𝔽</sub> produces *+0*<sub>𝔽</sub>.</p>
      </emu-note>

      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).
          1. If _oldValue_ is a Number, then
            1. Return Number::unaryMinus(_oldValue_).
          1. Else,
            1. Assert: _oldValue_ is a BigInt.
            1. Return BigInt::unaryMinus(_oldValue_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-bitwise-not-operator">
      <h1>Bitwise NOT Operator ( `~` )</h1>

      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).
          1. If _oldValue_ is a Number, then
            1. Return Number::bitwiseNOT(_oldValue_).
          1. Else,
            1. Assert: _oldValue_ is a BigInt.
            1. Return BigInt::bitwiseNOT(_oldValue_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-logical-not-operator">
      <h1>Logical NOT Operator ( `!` )</h1>

      <emu-clause id="sec-logical-not-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `!` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be ? Evaluation of |UnaryExpression|.
          1. Let _oldValue_ be ToBoolean(? GetValue(_expr_)).
          1. If _oldValue_ is *true*, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>Exponentiation Operator</h1>
    <h2>Syntax</h2>

    <emu-grammar type="definition">
      ExponentiationExpression[Yield, Await] :
        UnaryExpression[?Yield, ?Await]
        UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. Return ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-multiplicative-operators">
    <h1>Multiplicative Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MultiplicativeExpression[Yield, Await] :
        ExponentiationExpression[?Yield, ?Await]
        MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]

      MultiplicativeOperator : one of
        `*` `/` `%`
    </emu-grammar>
    <emu-note>
      <ul>
        <li>The `*` operator performs multiplication, producing the product of its operands.</li>
        <li>The `/` operator performs division, producing the quotient of its operands.</li>
        <li>The `%` operator yields the remainder of its operands from an implied division.</li>
      </ul>
    </emu-note>

    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. Let _opText_ be the source text matched by |MultiplicativeOperator|.
        1. Return ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-additive-operators">
    <h1>Additive Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AdditiveExpression[Yield, Await] :
        MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
        AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-addition-operator-plus">
      <h1>The Addition Operator ( `+` )</h1>
      <emu-note>
        <p>The addition operator either performs string concatenation or numeric addition.</p>
      </emu-note>

      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-subtraction-operator-minus">
      <h1>The Subtraction Operator ( `-` )</h1>
      <emu-note>
        <p>The `-` operator performs subtraction, producing the difference of its operands.</p>
      </emu-note>

      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bitwise-shift-operators">
    <h1>Bitwise Shift Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ShiftExpression[Yield, Await] :
        AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&lt;&lt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;` AdditiveExpression[?Yield, ?Await]
        ShiftExpression[?Yield, ?Await] `&gt;&gt;&gt;` AdditiveExpression[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-left-shift-operator">
      <h1>The Left Shift Operator ( `&lt;&lt;` )</h1>
      <emu-note>
        <p>Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `&lt;&lt;`, |AdditiveExpression|).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-signed-right-shift-operator">
      <h1>The Signed Right Shift Operator ( `>>` )</h1>
      <emu-note>
        <p>Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>The Unsigned Right Shift Operator ( `>>>` )</h1>
      <emu-note>
        <p>Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relational-operators">
    <h1>Relational Operators</h1>
    <emu-note>
      <p>The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      RelationalExpression[In, Yield, Await] :
        ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&lt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `&gt;=` ShiftExpression[?Yield, ?Await]
        RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
        [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
        [+In] PrivateIdentifier `in` ShiftExpression[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The <sub>[In]</sub> grammar parameter is needed to avoid confusing the `in` operator in a relational expression with the `in` operator in a `for` statement.</p>
    </emu-note>

    <emu-clause id="sec-relational-operators-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _r_ be ? IsLessThan(_lVal_, _rVal_, *true*).
        1. If _r_ is *undefined*, return *false*; otherwise return _r_.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _r_ be ? IsLessThan(_rVal_, _lVal_, *false*).
        1. If _r_ is *undefined*, return *false*; otherwise return _r_.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&lt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _r_ be ? IsLessThan(_rVal_, _lVal_, *false*).
        1. If _r_ is either *true* or *undefined*, return *false*; otherwise return *true*.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `&gt;=` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _r_ be ? IsLessThan(_lVal_, _rVal_, *true*).
        1. If _r_ is either *true* or *undefined*, return *false*; otherwise return *true*.
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `instanceof` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Return ? InstanceofOperator(_lVal_, _rVal_).
      </emu-alg>
      <emu-grammar>RelationalExpression : RelationalExpression `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. If _rVal_ is not an Object, throw a *TypeError* exception.
        1. Return ? HasProperty(_rVal_, ? ToPropertyKey(_lVal_)).
      </emu-alg>
      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. Let _privateIdentifier_ be the StringValue of |PrivateIdentifier|.
        1. Let _rRef_ be ? Evaluation of |ShiftExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. If _rVal_ is not an Object, throw a *TypeError* exception.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Assert: _privateEnv_ is not *null*.
        1. Let _privateName_ be ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_).
        1. If PrivateElementFind(_rVal_, _privateName_) is not ~empty~, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-instanceofoperator" type="abstract operation">
      <h1>
        InstanceofOperator (
          _V_: an ECMAScript language value,
          _target_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It implements the generic algorithm for determining if _V_ is an instance of _target_ either by consulting _target_'s %Symbol.hasInstance% method or, if absent, determining whether the value of _target_'s *"prototype"* property is present in _V_'s prototype chain.</dd>
      </dl>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _instOfHandler_ be ? GetMethod(_target_, %Symbol.hasInstance%).
        1. If _instOfHandler_ is not *undefined*, then
          1. Return ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)).
        1. [id="step-instanceof-check-function"] If IsCallable(_target_) is *false*, throw a *TypeError* exception.
        1. [id="step-instanceof-fallback"] Return ? OrdinaryHasInstance(_target_, _V_).
      </emu-alg>
      <emu-note>
        <p>Steps <emu-xref href="#step-instanceof-check-function"></emu-xref> and <emu-xref href="#step-instanceof-fallback"></emu-xref> provide compatibility with previous editions of ECMAScript that did not use a %Symbol.hasInstance% method to define the `instanceof` operator semantics. If an object does not define or inherit %Symbol.hasInstance% it uses the default `instanceof` semantics.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-equality-operators">
    <h1>Equality Operators</h1>
    <emu-note>
      <p>The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.</p>
    </emu-note>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EqualityExpression[In, Yield, Await] :
        RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
        EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-equality-operators-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>EqualityExpression : EqualityExpression `==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |EqualityExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Return ? IsLooselyEqual(_rVal_, _lVal_).
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!=` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |EqualityExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _r_ be ? IsLooselyEqual(_rVal_, _lVal_).
        1. If _r_ is *true*, return *false*; otherwise return *true*.
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `===` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |EqualityExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Return IsStrictlyEqual(_rVal_, _lVal_).
      </emu-alg>
      <emu-grammar>EqualityExpression : EqualityExpression `!==` RelationalExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |EqualityExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |RelationalExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _r_ be IsStrictlyEqual(_rVal_, _lVal_).
        1. If _r_ is *true*, return *false*; otherwise return *true*.
      </emu-alg>
      <emu-note>
        <p>Given the above definition of equality:</p>
        <ul>
          <li>
            String comparison can be forced by: `\`${a}\` == \`${b}\``.
          </li>
          <li>
            Numeric comparison can be forced by: `+a == +b`.
          </li>
          <li>
            Boolean comparison can be forced by: `!a == !b`.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>The equality operators maintain the following invariants:</p>
        <ul>
          <li>
            `A != B` is equivalent to `!(A == B)`.
          </li>
          <li>
            `A == B` is equivalent to `B == A`, except in the order of evaluation of `A` and `B`.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the `==` operator, but the two String objects would not be equal to each other. For example:</p>
        <ul>
          <li>
            `new String("a") == "a"` and `"a" == new String("a")` are both *true*.
          </li>
          <li>
            `new String("a") == new String("a")` is *false*.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode Standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-bitwise-operators">
    <h1>Binary Bitwise Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BitwiseANDExpression[In, Yield, Await] :
        EqualityExpression[?In, ?Yield, ?Await]
        BitwiseANDExpression[?In, ?Yield, ?Await] `&amp;` EqualityExpression[?In, ?Yield, ?Await]

      BitwiseXORExpression[In, Yield, Await] :
        BitwiseANDExpression[?In, ?Yield, ?Await]
        BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]

      BitwiseORExpression[In, Yield, Await] :
        BitwiseXORExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>BitwiseANDExpression : BitwiseANDExpression `&amp;` EqualityExpression</emu-grammar>
      <emu-alg>
        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&amp;`, |EqualityExpression|).
      </emu-alg>
      <emu-grammar>BitwiseXORExpression : BitwiseXORExpression `^` BitwiseANDExpression</emu-grammar>
      <emu-alg>
        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|).
      </emu-alg>
      <emu-grammar>BitwiseORExpression : BitwiseORExpression `|` BitwiseXORExpression</emu-grammar>
      <emu-alg>
        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-binary-logical-operators">
    <h1>Binary Logical Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LogicalANDExpression[In, Yield, Await] :
        BitwiseORExpression[?In, ?Yield, ?Await]
        LogicalANDExpression[?In, ?Yield, ?Await] `&amp;&amp;` BitwiseORExpression[?In, ?Yield, ?Await]

      LogicalORExpression[In, Yield, Await] :
        LogicalANDExpression[?In, ?Yield, ?Await]
        LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]

      CoalesceExpression[In, Yield, Await] :
        CoalesceExpressionHead[?In, ?Yield, ?Await] `??` BitwiseORExpression[?In, ?Yield, ?Await]

      CoalesceExpressionHead[In, Yield, Await] :
        CoalesceExpression[?In, ?Yield, ?Await]
        BitwiseORExpression[?In, ?Yield, ?Await]

      ShortCircuitExpression[In, Yield, Await] :
        LogicalORExpression[?In, ?Yield, ?Await]
        CoalesceExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The value produced by a `&amp;&amp;` or `||` operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.</p>
    </emu-note>

    <emu-clause id="sec-binary-logical-operators-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |LogicalANDExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. If ToBoolean(_lVal_) is *false*, return _lVal_.
        1. Let _rRef_ be ? Evaluation of |BitwiseORExpression|.
        1. Return ? GetValue(_rRef_).
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |LogicalORExpression|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. If ToBoolean(_lVal_) is *true*, return _lVal_.
        1. Let _rRef_ be ? Evaluation of |LogicalANDExpression|.
        1. Return ? GetValue(_rRef_).
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |CoalesceExpressionHead|.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. If _lVal_ is either *undefined* or *null*, then
          1. Let _rRef_ be ? Evaluation of |BitwiseORExpression|.
          1. Return ? GetValue(_rRef_).
        1. Else,
          1. Return _lVal_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-conditional-operator">
    <h1>Conditional Operator ( `? :` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ConditionalExpression[In, Yield, Await] :
        ShortCircuitExpression[?In, ?Yield, ?Await]
        ShortCircuitExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The grammar for a |ConditionalExpression| in ECMAScript is slightly different from that in C and Java, which each allow the second subexpression to be an |Expression| but restrict the third expression to be a |ConditionalExpression|. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.</p>
    </emu-note>

    <emu-clause id="sec-conditional-operator-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |ShortCircuitExpression|.
        1. Let _lVal_ be ToBoolean(? GetValue(_lRef_)).
        1. If _lVal_ is *true*, then
          1. Let _trueRef_ be ? Evaluation of the first |AssignmentExpression|.
          1. Return ? GetValue(_trueRef_).
        1. Else,
          1. Let _falseRef_ be ? Evaluation of the second |AssignmentExpression|.
          1. Return ? GetValue(_falseRef_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-assignment-operators">
    <h1>Assignment Operators</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AssignmentExpression[In, Yield, Await] :
        ConditionalExpression[?In, ?Yield, ?Await]
        [+Yield] YieldExpression[?In, ?Await]
        ArrowFunction[?In, ?Yield, ?Await]
        AsyncArrowFunction[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await] #assignment
        LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `&amp;&amp;=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `||=` AssignmentExpression[?In, ?Yield, ?Await]
        LeftHandSideExpression[?Yield, ?Await] `??=` AssignmentExpression[?In, ?Yield, ?Await]

      // emu-format ignore
      AssignmentOperator : one of
        `*=` `/=` `%=` `+=` `-=` `&lt;&lt;=` `&gt;&gt;=` `&gt;&gt;&gt;=` `&amp;=` `^=` `|=` `**=`
    </emu-grammar>

    <emu-clause id="sec-assignment-operators-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <ul>
        <li>
          If |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, |LeftHandSideExpression| must cover an |AssignmentPattern|.
        </li>
        <li>
          If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, it is a Syntax Error if the AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression AssignmentOperator AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
        </li>
      </ul>
      <emu-grammar>
        AssignmentExpression :
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-assignment-operators-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
          1. Let _lRef_ be ? Evaluation of |LeftHandSideExpression|.
          1. If the AssignmentTargetType of |LeftHandSideExpression| is ~web-compat~, throw a *ReferenceError* exception.
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then
            1. Let _lhs_ be the StringValue of |LeftHandSideExpression|.
            1. Let _rVal_ be ? NamedEvaluation of |AssignmentExpression| with argument _lhs_.
          1. Else,
            1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
            1. Let _rVal_ be ? GetValue(_rRef_).
          1. [id="step-assignmentexpression-evaluation-simple-putvalue"] Perform ? PutValue(_lRef_, _rVal_).
          1. Return _rVal_.
        1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |LeftHandSideExpression|.
        1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Perform ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rVal_.
        1. Return _rVal_.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |LeftHandSideExpression|.
        1. If the AssignmentTargetType of |LeftHandSideExpression| is ~web-compat~, throw a *ReferenceError* exception.
        1. [id="step-assignmentexpression-evaluation-compound-getvalue"] Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Let _assignmentOpText_ be the source text matched by |AssignmentOperator|.
        1. Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:
          <figure>
            <!-- emu-format ignore -->
            <table class="lightweight-table">
              <thead>
                <tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>
              </thead>
              <tr><td> `**=`              </td><td> `**`           </td></tr>
              <tr><td> `*=`               </td><td> `*`            </td></tr>
              <tr><td> `/=`               </td><td> `/`            </td></tr>
              <tr><td> `%=`               </td><td> `%`            </td></tr>
              <tr><td> `+=`               </td><td> `+`            </td></tr>
              <tr><td> `-=`               </td><td> `-`            </td></tr>
              <tr><td> `&lt;&lt;=`        </td><td> `&lt;&lt;`     </td></tr>
              <tr><td> `&gt;&gt;=`        </td><td> `&gt;&gt;`     </td></tr>
              <tr><td> `&gt;&gt;&gt;=`    </td><td> `&gt;&gt;&gt;` </td></tr>
              <tr><td> `&amp;=`           </td><td> `&amp;`        </td></tr>
              <tr><td> `^=`               </td><td> `^`            </td></tr>
              <tr><td> `|=`               </td><td> `|`            </td></tr>
            </table>
          </figure>
        1. Let _r_ be ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_).
        1. [id="step-assignmentexpression-evaluation-compound-putvalue"] Perform ? PutValue(_lRef_, _r_).
        1. Return _r_.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `&amp;&amp;=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |LeftHandSideExpression|.
        1. [id="step-assignmentexpression-evaluation-lgcl-and-getvalue"] Let _lVal_ be ? GetValue(_lRef_).
        1. If ToBoolean(_lVal_) is *false*, return _lVal_.
        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then
          1. Let _lhs_ be the StringValue of |LeftHandSideExpression|.
          1. Let _rVal_ be ? NamedEvaluation of |AssignmentExpression| with argument _lhs_.
        1. Else,
          1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
          1. Let _rVal_ be ? GetValue(_rRef_).
        1. [id="step-assignmentexpression-evaluation-lgcl-and-putvalue"] Perform ? PutValue(_lRef_, _rVal_).
        1. Return _rVal_.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `||=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |LeftHandSideExpression|.
        1. [id="step-assignmentexpression-evaluation-lgcl-or-getvalue"] Let _lVal_ be ? GetValue(_lRef_).
        1. If ToBoolean(_lVal_) is *true*, return _lVal_.
        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then
          1. Let _lhs_ be the StringValue of |LeftHandSideExpression|.
          1. Let _rVal_ be ? NamedEvaluation of |AssignmentExpression| with argument _lhs_.
        1. Else,
          1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
          1. Let _rVal_ be ? GetValue(_rRef_).
        1. [id="step-assignmentexpression-evaluation-lgcl-or-putvalue"] Perform ? PutValue(_lRef_, _rVal_).
        1. Return _rVal_.
      </emu-alg>
      <emu-grammar>AssignmentExpression : LeftHandSideExpression `??=` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |LeftHandSideExpression|.
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-getvalue"] Let _lVal_ be ? GetValue(_lRef_).
        1. If _lVal_ is neither *undefined* nor *null*, return _lVal_.
        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then
          1. Let _lhs_ be the StringValue of |LeftHandSideExpression|.
          1. Let _rVal_ be ? NamedEvaluation of |AssignmentExpression| with argument _lhs_.
        1. Else,
          1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
          1. Let _rVal_ be ? GetValue(_rRef_).
        1. [id="step-assignmentexpression-evaluation-lgcl-nullish-putvalue"] Perform ? PutValue(_lRef_, _rVal_).
        1. Return _rVal_.
      </emu-alg>
      <emu-note>
        <p>When this expression occurs within strict mode code, it is a runtime error if _lRef_ in step <emu-xref href="#step-assignmentexpression-evaluation-simple-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-compound-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-getvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-getvalue"></emu-xref> is an unresolvable reference. If it is, a *ReferenceError* exception is thrown. Additionally, it is a runtime error if the _lRef_ in step <emu-xref href="#step-assignmentexpression-evaluation-compound-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-and-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-or-putvalue"></emu-xref>, <emu-xref href="#step-assignmentexpression-evaluation-lgcl-nullish-putvalue"></emu-xref> is a reference to a data property with the attribute value { [[Writable]]: *false* }, to an accessor property with the attribute value { [[Set]]: *undefined* }, or to a non-existent property of an object for which the IsExtensible predicate returns the value *false*. In these cases a *TypeError* exception is thrown.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-applystringornumericbinaryoperator" type="abstract operation">
      <h1>
        ApplyStringOrNumericBinaryOperator (
          _lVal_: an ECMAScript language value,
          _opText_: `**`, `*`, `/`, `%`, `+`, `-`, `&lt;&lt;`, `&gt;&gt;`, `&gt;&gt;&gt;`, `&amp;`, `^`, or `|`,
          _rVal_: an ECMAScript language value,
        ): either a normal completion containing either a String, a BigInt, or a Number, or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _opText_ is `+`, then
          1. [id="step-binary-op-toprimitive-lval"] Let _lPrim_ be ? ToPrimitive(_lVal_).
          1. [id="step-binary-op-toprimitive-rval"] Let _rPrim_ be ? ToPrimitive(_rVal_).
          1. [id="step-binary-op-string-check"] If _lPrim_ is a String or _rPrim_ is a String, then
            1. Let _lStr_ be ? ToString(_lPrim_).
            1. Let _rStr_ be ? ToString(_rPrim_).
            1. Return the string-concatenation of _lStr_ and _rStr_.
          1. Set _lVal_ to _lPrim_.
          1. Set _rVal_ to _rPrim_.
        1. NOTE: At this point, it must be a numeric operation.
        1. Let _lNum_ be ? ToNumeric(_lVal_).
        1. Let _rNum_ be ? ToNumeric(_rVal_).
        1. If SameType(_lNum_, _rNum_) is *false*, throw a *TypeError* exception.
        1. If _lNum_ is a BigInt, then
          1. If _opText_ is `**`, return ? BigInt::exponentiate(_lNum_, _rNum_).
          1. If _opText_ is `/`, return ? BigInt::divide(_lNum_, _rNum_).
          1. If _opText_ is `%`, return ? BigInt::remainder(_lNum_, _rNum_).
          1. If _opText_ is `>>>`, return ? BigInt::unsignedRightShift(_lNum_, _rNum_).
          1. Let _operation_ be the abstract operation associated with _opText_ in the following table:
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_   </th><th> _operation_              </th></tr>
                </thead>
                <tbody>
                  <tr><td> `*`        </td><td> BigInt::multiply         </td></tr>
                  <tr><td> `+`        </td><td> BigInt::add              </td></tr>
                  <tr><td> `-`        </td><td> BigInt::subtract         </td></tr>
                  <tr><td> `&lt;&lt;` </td><td> BigInt::leftShift        </td></tr>
                  <tr><td> `&gt;&gt;` </td><td> BigInt::signedRightShift </td></tr>
                  <tr><td> `&amp;`    </td><td> BigInt::bitwiseAND       </td></tr>
                  <tr><td> `^`        </td><td> BigInt::bitwiseXOR       </td></tr>
                  <tr><td> `|`        </td><td> BigInt::bitwiseOR        </td></tr>
                </tbody>
              </table>
            </figure>
        1. Else,
          1. Assert: _lNum_ is a Number.
          1. Let _operation_ be the abstract operation associated with _opText_ in the following table:
            <figure>
              <!-- emu-format ignore -->
              <table class="lightweight-table">
                <thead>
                  <tr><th> _opText_       </th><th> _operation_                </th></tr>
                </thead>
                <tbody>
                  <tr><td> `**`           </td><td> Number::exponentiate       </td></tr>
                  <tr><td> `*`            </td><td> Number::multiply           </td></tr>
                  <tr><td> `/`            </td><td> Number::divide             </td></tr>
                  <tr><td> `%`            </td><td> Number::remainder          </td></tr>
                  <tr><td> `+`            </td><td> Number::add                </td></tr>
                  <tr><td> `-`            </td><td> Number::subtract           </td></tr>
                  <tr><td> `&lt;&lt;`     </td><td> Number::leftShift          </td></tr>
                  <tr><td> `&gt;&gt;`     </td><td> Number::signedRightShift   </td></tr>
                  <tr><td> `&gt;&gt;&gt;` </td><td> Number::unsignedRightShift </td></tr>
                  <tr><td> `&amp;`        </td><td> Number::bitwiseAND         </td></tr>
                  <tr><td> `^`            </td><td> Number::bitwiseXOR         </td></tr>
                  <tr><td> `|`            </td><td> Number::bitwiseOR          </td></tr>
                </tbody>
              </table>
            </figure>
        1. Return _operation_(_lNum_, _rNum_).
      </emu-alg>
      <emu-note>
        <p>No hint is provided in the calls to ToPrimitive in steps <emu-xref href="#step-binary-op-toprimitive-lval"></emu-xref> and <emu-xref href="#step-binary-op-toprimitive-rval"></emu-xref>. All standard objects except Dates handle the absence of a hint as if ~number~ were given; Dates handle the absence of a hint as if ~string~ were given. Exotic objects may handle the absence of a hint in some other manner.</p>
      </emu-note>
      <emu-note>
        <p>Step <emu-xref href="#step-binary-op-string-check"></emu-xref> differs from step <emu-xref href="#step-arc-string-check"></emu-xref> of the IsLessThan algorithm, by using the logical-or operation instead of the logical-and operation.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-evaluatestringornumericbinaryexpression" type="abstract operation">
      <h1>
        EvaluateStringOrNumericBinaryExpression (
          _leftOperand_: a Parse Node,
          _opText_: a sequence of Unicode code points,
          _rightOperand_: a Parse Node,
        ): either a normal completion containing either a String, a BigInt, or a Number, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of _leftOperand_.
        1. Let _lVal_ be ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of _rightOperand_.
        1. Let _rVal_ be ? GetValue(_rRef_).
        1. Return ? ApplyStringOrNumericBinaryOperator(_lVal_, _opText_, _rVal_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-destructuring-assignment">
      <h1>Destructuring Assignment</h1>
      <h2>Supplemental Syntax</h2>
      <p>
        In certain circumstances when processing an instance of the production<br>
        <emu-grammar>AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression</emu-grammar><br>
        the interpretation of |LeftHandSideExpression| is refined using the following grammar:
      </p>
      <emu-grammar type="definition">
        AssignmentPattern[Yield, Await] :
          ObjectAssignmentPattern[?Yield, ?Await]
          ArrayAssignmentPattern[?Yield, ?Await]

        ObjectAssignmentPattern[Yield, Await] :
          `{` `}`
          `{` AssignmentRestProperty[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `}`
          `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

        ArrayAssignmentPattern[Yield, Await] :
          `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
          `[` AssignmentElementList[?Yield, ?Await] `]`
          `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

        AssignmentRestProperty[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        AssignmentPropertyList[Yield, Await] :
          AssignmentProperty[?Yield, ?Await]
          AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

        AssignmentElementList[Yield, Await] :
          AssignmentElisionElement[?Yield, ?Await]
          AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

        AssignmentElisionElement[Yield, Await] :
          Elision? AssignmentElement[?Yield, ?Await]

        AssignmentProperty[Yield, Await] :
          IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
          PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

        AssignmentElement[Yield, Await] :
          DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        AssignmentRestElement[Yield, Await] :
          `...` DestructuringAssignmentTarget[?Yield, ?Await]

        DestructuringAssignmentTarget[Yield, Await] :
          LeftHandSideExpression[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-assignment-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the AssignmentTargetType of |IdentifierReference| is not ~simple~.
          </li>
        </ul>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |DestructuringAssignmentTarget| is either an |ArrayLiteral| or an |ObjectLiteral|.
          </li>
        </ul>
        <emu-grammar>DestructuringAssignmentTarget : LeftHandSideExpression</emu-grammar>
        <ul>
          <li>
            If |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, |LeftHandSideExpression| must cover an |AssignmentPattern|.
          </li>
          <li>
            If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, it is a Syntax Error if the AssignmentTargetType of |LeftHandSideExpression| is not ~simple~.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-destructuringassignmentevaluation" type="sdo">
        <h1>
          Runtime Semantics: DestructuringAssignmentEvaluation (
            _value_: an ECMAScript language value,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ObjectAssignmentPattern : `{` `}`</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>
          ObjectAssignmentPattern :
            `{` AssignmentPropertyList `}`
            `{` AssignmentPropertyList `,` `}`
        </emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Let _excludedNames_ be a new empty List.
          1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.
        </emu-alg>
        <emu-grammar>ObjectAssignmentPattern : `{` AssignmentPropertyList `,` AssignmentRestProperty `}`</emu-grammar>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_value_).
          1. Let _excludedNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.
          1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).
          1. Return ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)).
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).
          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` Elision? AssignmentRestElement `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).
          1. If |Elision| is present, then
            1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).
            1. If _status_ is an abrupt completion, then
              1. Assert: _iteratorRecord_.[[Done]] is *true*.
              1. Return ? _status_.
          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).
          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).
          1. Return _result_.
        </emu-alg>
        <emu-grammar>ArrayAssignmentPattern : `[` AssignmentElementList `,` Elision? AssignmentRestElement? `]`</emu-grammar>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).
          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).
          1. If _status_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).
            1. Return ? _status_.
          1. If |Elision| is present, then
            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).
            1. If _status_ is an abrupt completion, then
              1. Assert: _iteratorRecord_.[[Done]] is *true*.
              1. Return ? _status_.
          1. If |AssignmentRestElement| is present, then
            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).
          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).
          1. Return ? _status_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-propertydestructuringassignmentevaluation" type="sdo">
        <h1>
          Runtime Semantics: PropertyDestructuringAssignmentEvaluation (
            _value_: an ECMAScript language value,
          ): either a normal completion containing a List of property keys or an abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It collects a list of all destructured property keys.</dd>
        </dl>
        <emu-grammar>AssignmentPropertyList : AssignmentPropertyList `,` AssignmentProperty</emu-grammar>
        <emu-alg>
          1. Let _propertyNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.
          1. Let _nextNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentProperty| with argument _value_.
          1. Return the list-concatenation of _propertyNames_ and _nextNames_.
        </emu-alg>

        <emu-grammar>AssignmentProperty : IdentifierReference Initializer?</emu-grammar>
        <emu-alg>
          1. Let _P_ be the StringValue of |IdentifierReference|.
          1. Let _lRef_ be ? ResolveBinding(_P_).
          1. Let _v_ be ? GetV(_value_, _P_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. Perform ? PutValue(_lRef_, _v_).
          1. Return « _P_ ».
        </emu-alg>

        <emu-grammar>AssignmentProperty : PropertyName `:` AssignmentElement</emu-grammar>
        <emu-alg>
          1. Let _name_ be ? Evaluation of |PropertyName|.
          1. Perform ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement| with arguments _value_ and _name_.
          1. Return « _name_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-restdestructuringassignmentevaluation" type="sdo">
        <h1>
          Runtime Semantics: RestDestructuringAssignmentEvaluation (
            _value_: an ECMAScript language value,
            _excludedNames_: a List of property keys,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentRestProperty : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. Let _lRef_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).
          1. Return ? PutValue(_lRef_, _restObj_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-iteratordestructuringassignmentevaluation" type="sdo">
        <h1>
          Runtime Semantics: IteratorDestructuringAssignmentEvaluation (
            _iteratorRecord_: an Iterator Record,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElementList : AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>AssignmentElementList : AssignmentElementList `,` AssignmentElisionElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : AssignmentElement</emu-grammar>
        <emu-alg>
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>AssignmentElisionElement : Elision AssignmentElement</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.
        </emu-alg>
        <emu-grammar>Elision : `,`</emu-grammar>
        <emu-alg>
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Perform ? IteratorStep(_iteratorRecord_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>Elision : Elision `,`</emu-grammar>
        <emu-alg>
          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Perform ? IteratorStep(_iteratorRecord_).
          1. Return ~unused~.
        </emu-alg>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lRef_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _value_ be *undefined*.
          1. If _iteratorRecord_.[[Done]] is *false*, then
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is not ~done~, then
              1. Set _value_ to _next_.
          1. If |Initializer| is present and _value_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then
              1. Let _target_ be the StringValue of |DestructuringAssignmentTarget|.
              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _target_.
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Let _v_ be ? GetValue(_defaultValue_).
          1. Else,
            1. Let _v_ be _value_.
          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then
            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
            1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.
          1. Return ? PutValue(_lRef_, _v_).
        </emu-alg>
        <emu-note>
          <p>Left to right evaluation order is maintained by evaluating a |DestructuringAssignmentTarget| that is not a destructuring pattern prior to accessing the iterator or evaluating the |Initializer|.</p>
        </emu-note>
        <emu-grammar>AssignmentRestElement : `...` DestructuringAssignmentTarget</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lRef_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _n_ be 0.
          1. Repeat, while _iteratorRecord_.[[Done]] is *false*,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is not ~done~, then
              1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).
              1. Set _n_ to _n_ + 1.
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Return ? PutValue(_lRef_, _A_).
          1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
          1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyeddestructuringassignmentevaluation" type="sdo">
        <h1>
          Runtime Semantics: KeyedDestructuringAssignmentEvaluation (
            _value_: an ECMAScript language value,
            _propertyName_: a property key,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>AssignmentElement : DestructuringAssignmentTarget Initializer?</emu-grammar>
        <emu-alg>
          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then
            1. Let _lRef_ be ? Evaluation of |DestructuringAssignmentTarget|.
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then
              1. Let _target_ be the StringValue of |DestructuringAssignmentTarget|.
              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _target_.
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Let _rhsValue_ be ? GetValue(_defaultValue_).
          1. Else,
            1. Let _rhsValue_ be _v_.
          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.
            1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.
          1. Return ? PutValue(_lRef_, _rhsValue_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-comma-operator">
    <h1>Comma Operator ( `,` )</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Expression[In, Yield, Await] :
        AssignmentExpression[?In, ?Yield, ?Await]
        Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-comma-operator-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Expression : Expression `,` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _lRef_ be ? Evaluation of |Expression|.
        1. Perform ? GetValue(_lRef_).
        1. Let _rRef_ be ? Evaluation of |AssignmentExpression|.
        1. Return ? GetValue(_rRef_).
      </emu-alg>
      <emu-note>
        <p>GetValue must be called even though its value is not used because it may have observable side-effects.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-statements-and-declarations">
  <h1>ECMAScript Language: Statements and Declarations</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    Statement[Yield, Await, Return] :
      BlockStatement[?Yield, ?Await, ?Return]
      VariableStatement[?Yield, ?Await]
      EmptyStatement
      ExpressionStatement[?Yield, ?Await]
      IfStatement[?Yield, ?Await, ?Return]
      BreakableStatement[?Yield, ?Await, ?Return]
      ContinueStatement[?Yield, ?Await]
      BreakStatement[?Yield, ?Await]
      [+Return] ReturnStatement[?Yield, ?Await]
      WithStatement[?Yield, ?Await, ?Return]
      LabelledStatement[?Yield, ?Await, ?Return]
      ThrowStatement[?Yield, ?Await]
      TryStatement[?Yield, ?Await, ?Return]
      DebuggerStatement

    Declaration[Yield, Await] :
      HoistableDeclaration[?Yield, ?Await, ~Default]
      ClassDeclaration[?Yield, ?Await, ~Default]
      LexicalDeclaration[+In, ?Yield, ?Await]

    HoistableDeclaration[Yield, Await, Default] :
      FunctionDeclaration[?Yield, ?Await, ?Default]
      GeneratorDeclaration[?Yield, ?Await, ?Default]
      AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
      AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

    BreakableStatement[Yield, Await, Return] :
      IterationStatement[?Yield, ?Await, ?Return]
      SwitchStatement[?Yield, ?Await, ?Return]
  </emu-grammar>

  <emu-clause id="sec-statement-semantics">
    <h1>Statement Semantics</h1>

    <emu-clause id="sec-statement-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        HoistableDeclaration :
          GeneratorDeclaration
          AsyncFunctionDeclaration
          AsyncGeneratorDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>
        HoistableDeclaration : FunctionDeclaration
      </emu-grammar>
      <emu-alg>
        1. Return ? Evaluation of |FunctionDeclaration|.
      </emu-alg>
      <emu-grammar>
        BreakableStatement :
          IterationStatement
          SwitchStatement
      </emu-grammar>
      <emu-alg>
        1. Let _newLabelSet_ be a new empty List.
        1. Return ? LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-block">
    <h1>Block</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BlockStatement[Yield, Await, Return] :
        Block[?Yield, ?Await, ?Return]

      Block[Yield, Await, Return] :
        `{` StatementList[?Yield, ?Await, ?Return]? `}`

      StatementList[Yield, Await, Return] :
        StatementListItem[?Yield, ?Await, ?Return]
        StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

      StatementListItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        Declaration[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-block-static-semantics-early-errors" oldids="sec-block-duplicates-allowed-static-semantics">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <ul>
        <li>
          <p>It is a Syntax Error if the LexicallyDeclaredNames of |StatementList| contains any duplicate entries<span normative-optional>, unless the host is a web browser or otherwise supports <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>, and both of the following conditions are true:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) is *false*.</li>
            <li>The duplicate entries are only bound by FunctionDeclarations.</li>
          </ul>
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |StatementList| also occurs in the VarDeclaredNames of |StatementList|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-block-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Block : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _blockValue_ be Completion(Evaluation of |StatementList|).
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return ? _blockValue_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _sl_ be ? Evaluation of |StatementList|.
        1. Let _s_ be Completion(Evaluation of |StatementListItem|).
        1. Return ? UpdateEmpty(_s_, _sl_).
      </emu-alg>
      <emu-note>
        <p>The value of a |StatementList| is the value of the last value-producing item in the |StatementList|. For example, the following calls to the `eval` function all return the value 1:</p>
        <pre><code class="javascript">
          eval("1;;;;;")
          eval("1;{}")
          eval("1;var a;")
        </code></pre>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-blockdeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-blockdeclarationinstantiation">
      <h1>
        BlockDeclarationInstantiation (
          _code_: a Parse Node,
          _env_: a Declarative Environment Record,
        ): ~unused~
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_code_ is the Parse Node corresponding to the body of the block. _env_ is the Environment Record in which bindings are to be created.</dd>
      </dl>
      <emu-note>
        <p>When a |Block| or |CaseBlock| is evaluated a new Declarative Environment Record is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the Environment Record.</p>
      </emu-note>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. For each element _d_ of _declarations_, do
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. [id="step-blockdeclarationinstantiation-createmutablebinding", normative-optional] If the host is a web browser or otherwise supports <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>, then
                1. If ! _env_.HasBinding(_dn_) is *false*, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
              1. Else,
                1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
          1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
            1. [id="step-blockdeclarationinstantiation-initializebinding", normative-optional] If the host is a web browser or otherwise supports <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>, then
              1. If the binding for _fn_ in _env_ is an uninitialized binding, then
                1. Perform ! _env_.InitializeBinding(_fn_, _fo_).
              1. Else,
                1. Assert: _d_ is a |FunctionDeclaration|.
                1. Perform ! _env_.SetMutableBinding(_fn_, _fo_, *false*).
            1. Else,
              1. Perform ! _env_.InitializeBinding(_fn_, _fo_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-declarations-and-the-variable-statement">
    <h1>Declarations and the Variable Statement</h1>

    <emu-clause id="sec-let-and-const-declarations">
      <h1>Let and Const Declarations</h1>
      <emu-note>
        <p>`let` and `const` declarations define variables that are scoped to the running execution context's LexicalEnvironment. The variables are created when their containing Environment Record is instantiated but may not be accessed in any way until the variable's |LexicalBinding| is evaluated. A variable defined by a |LexicalBinding| with an |Initializer| is assigned the value of its |Initializer|'s |AssignmentExpression| when the |LexicalBinding| is evaluated, not when the variable is created. If a |LexicalBinding| in a `let` declaration does not have an |Initializer| the variable is assigned the value *undefined* when the |LexicalBinding| is evaluated.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        LexicalDeclaration[In, Yield, Await] :
          LetOrConst BindingList[?In, ?Yield, ?Await] `;`

        LetOrConst :
          `let`
          `const`

        BindingList[In, Yield, Await] :
          LexicalBinding[?In, ?Yield, ?Await]
          BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]

        LexicalBinding[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-let-and-const-declarations-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains *"let"*.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |BindingList| contains any duplicate entries.
          </li>
        </ul>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer?</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |Initializer| is not present and IsConstantDeclaration of the |LexicalDeclaration| containing this |LexicalBinding| is *true*.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-let-and-const-declarations-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>LexicalDeclaration : LetOrConst BindingList `;`</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |BindingList|.
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>BindingList : BindingList `,` LexicalBinding</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |BindingList|.
          1. Return ? Evaluation of |LexicalBinding|.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).
          1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*).
          1. Return ~empty~.
        </emu-alg>
        <emu-note>
          <p>A static semantics rule ensures that this form of |LexicalBinding| never occurs in a `const` declaration.</p>
        </emu-note>
        <emu-grammar>LexicalBinding : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ! ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be ? Evaluation of |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Perform ! InitializeReferencedBinding(_lhs_, _value_).
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>LexicalBinding : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-variable-statement">
      <h1>Variable Statement</h1>
      <emu-note>
        <p>A `var` statement declares variables that are scoped to the running execution context's VariableEnvironment. Var variables are created when their containing Environment Record is instantiated and are initialized to *undefined* when created. Within the scope of any VariableEnvironment a common |BindingIdentifier| may appear in more than one |VariableDeclaration| but those declarations collectively define only one variable. A variable defined by a |VariableDeclaration| with an |Initializer| is assigned the value of its |Initializer|'s |AssignmentExpression| when the |VariableDeclaration| is executed, not when the variable is created.</p>
      </emu-note>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        VariableStatement[Yield, Await] :
          `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`

        VariableDeclarationList[In, Yield, Await] :
          VariableDeclaration[?In, ?Yield, ?Await]
          VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]

        VariableDeclaration[In, Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
          BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-variable-statement-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>VariableStatement : `var` VariableDeclarationList `;`</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |VariableDeclarationList|.
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |VariableDeclarationList|.
          1. Return ? Evaluation of |VariableDeclaration|.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>VariableDeclaration : BindingIdentifier Initializer</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_).
          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
          1. Else,
            1. Let _rhs_ be ? Evaluation of |Initializer|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. [id="step-vardecllist-evaluation-putvalue"] Perform ? PutValue(_lhs_, _value_).
          1. Return ~empty~.
        </emu-alg>
        <emu-note>
          <p>If a |VariableDeclaration| is nested within a with statement and the |BindingIdentifier| in the |VariableDeclaration| is the same as a property name of the binding object of the with statement's Object Environment Record, then step <emu-xref href="#step-vardecllist-evaluation-putvalue"></emu-xref> will assign _value_ to the property instead of assigning to the VariableEnvironment binding of the |Identifier|.</p>
        </emu-note>
        <emu-grammar>VariableDeclaration : BindingPattern Initializer</emu-grammar>
        <emu-alg>
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _rVal_ be ? GetValue(_rhs_).
          1. Return ? BindingInitialization of |BindingPattern| with arguments _rVal_ and *undefined*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-destructuring-binding-patterns">
      <h1>Destructuring Binding Patterns</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        BindingPattern[Yield, Await] :
          ObjectBindingPattern[?Yield, ?Await]
          ArrayBindingPattern[?Yield, ?Await]

        ObjectBindingPattern[Yield, Await] :
          `{` `}`
          `{` BindingRestProperty[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `}`
          `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

        ArrayBindingPattern[Yield, Await] :
          `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
          `[` BindingElementList[?Yield, ?Await] `]`
          `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

        BindingRestProperty[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]

        BindingPropertyList[Yield, Await] :
          BindingProperty[?Yield, ?Await]
          BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

        BindingElementList[Yield, Await] :
          BindingElisionElement[?Yield, ?Await]
          BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

        BindingElisionElement[Yield, Await] :
          Elision? BindingElement[?Yield, ?Await]

        BindingProperty[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

        BindingElement[Yield, Await] :
          SingleNameBinding[?Yield, ?Await]
          BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        SingleNameBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

        BindingRestElement[Yield, Await] :
          `...` BindingIdentifier[?Yield, ?Await]
          `...` BindingPattern[?Yield, ?Await]
      </emu-grammar>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: PropertyBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
          ): either a normal completion containing a List of property keys or an abrupt completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It collects a list of all bound property names.</dd>
        </dl>
        <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
        <emu-alg>
          1. Let _boundNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.
          1. Let _nextNames_ be ? PropertyBindingInitialization of |BindingProperty| with arguments _value_ and _environment_.
          1. Return the list-concatenation of _boundNames_ and _nextNames_.
        </emu-alg>

        <emu-grammar>BindingProperty : SingleNameBinding</emu-grammar>
        <emu-alg>
          1. Let _name_ be the sole element of the BoundNames of |SingleNameBinding|.
          1. Perform ? KeyedBindingInitialization of |SingleNameBinding| with arguments _value_, _environment_, and _name_.
          1. Return « _name_ ».
        </emu-alg>

        <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
        <emu-alg>
          1. Let _P_ be ? Evaluation of |PropertyName|.
          1. Perform ? KeyedBindingInitialization of |BindingElement| with arguments _value_, _environment_, and _P_.
          1. Return « _P_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: RestBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
            _excludedNames_: a List of property keys,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>BindingRestProperty : `...` BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).
          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _restObj_).
          1. Return ? InitializeReferencedBinding(_lhs_, _restObj_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-keyedbindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: KeyedBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
            _propertyName_: a property key,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>When *undefined* is passed for _environment_ it indicates that a PutValue operation should be used to assign the initialization value. This is the case for formal parameter lists of non-strict functions. In that case the formal parameter bindings are preinitialized in order to deal with the possibility of multiple parameters with the same name.</p>
        </emu-note>
        <emu-grammar>BindingElement : BindingPattern Initializer?</emu-grammar>
        <emu-alg>
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. Let _defaultValue_ be ? Evaluation of |Initializer|.
            1. Set _v_ to ? GetValue(_defaultValue_).
          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.
        </emu-alg>
        <emu-grammar>SingleNameBinding : BindingIdentifier Initializer?</emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).
          1. Let _v_ be ? GetV(_value_, _propertyName_).
          1. If |Initializer| is present and _v_ is *undefined*, then
            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.
            1. Else,
              1. Let _defaultValue_ be ? Evaluation of |Initializer|.
              1. Set _v_ to ? GetValue(_defaultValue_).
          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).
          1. Return ? InitializeReferencedBinding(_lhs_, _v_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-empty-statement">
    <h1>Empty Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      EmptyStatement :
        `;`
    </emu-grammar>

    <emu-clause id="sec-empty-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>EmptyStatement : `;`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-expression-statement">
    <h1>Expression Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ExpressionStatement[Yield, Await] :
        [lookahead &notin; { `{`, `function`, `async` [no LineTerminator here] `function`, `class`, `let` `[` }] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>An |ExpressionStatement| cannot start with a U+007B (LEFT CURLY BRACKET) because that might make it ambiguous with a |Block|. An |ExpressionStatement| cannot start with the `function` or `class` keywords because that would make it ambiguous with a |FunctionDeclaration|, a |GeneratorDeclaration|, or a |ClassDeclaration|. An |ExpressionStatement| cannot start with `async function` because that would make it ambiguous with an |AsyncFunctionDeclaration| or a |AsyncGeneratorDeclaration|. An |ExpressionStatement| cannot start with the two token sequence `let [` because that would make it ambiguous with a `let` |LexicalDeclaration| whose first |LexicalBinding| was an |ArrayBindingPattern|.</p>
    </emu-note>

    <emu-clause id="sec-expression-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ExpressionStatement : Expression `;`</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Return ? GetValue(_exprRef_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-if-statement">
    <h1>The `if` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IfStatement[Yield, Await, Return] :
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
        `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] [lookahead != `else`]
    </emu-grammar>
    <emu-note>The lookahead-restriction [lookahead ≠ `else`] resolves the classic "dangling else" problem in the usual way. That is, when the choice of associated `if` is otherwise ambiguous, the `else` is associated with the nearest (innermost) of the candidate `if`s</emu-note>

    <emu-clause id="sec-if-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsLabelledFunction(the first |Statement|) is *true*.
        </li>
        <li>
          It is a Syntax Error if IsLabelledFunction(the second |Statement|) is *true*.
        </li>
      </ul>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
        </li>
      </ul>
      <emu-note>
        <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-if-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).
        1. If _exprValue_ is *true*, then
          1. Let _stmtCompletion_ be Completion(Evaluation of the first |Statement|).
        1. Else,
          1. Let _stmtCompletion_ be Completion(Evaluation of the second |Statement|).
        1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).
        1. If _exprValue_ is *false*, then
          1. Return *undefined*.
        1. Else,
          1. Let _stmtCompletion_ be Completion(Evaluation of |Statement|).
          1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-iteration-statements">
    <h1>Iteration Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      IterationStatement[Yield, Await, Return] :
        DoWhileStatement[?Yield, ?Await, ?Return]
        WhileStatement[?Yield, ?Await, ?Return]
        ForStatement[?Yield, ?Await, ?Return]
        ForInOfStatement[?Yield, ?Await, ?Return]
    </emu-grammar>

    <emu-clause id="sec-iteration-statements-semantics">
      <h1>Semantics</h1>

      <emu-clause id="sec-loopcontinues" type="abstract operation">
        <h1>
          LoopContinues (
            _completion_: a Completion Record,
            _labelSet_: a List of Strings,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _completion_ is a normal completion, return *true*.
          1. If _completion_ is not a continue completion, return *false*.
          1. If _completion_.[[Target]] is ~empty~, return *true*.
          1. If _labelSet_ contains _completion_.[[Target]], return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>Within the |Statement| part of an |IterationStatement| a |ContinueStatement| may be used to begin a new iteration.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-loopevaluation" type="sdo">
        <h1>
          Runtime Semantics: LoopEvaluation (
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>IterationStatement : DoWhileStatement</emu-grammar>
        <emu-alg>
          1. Return ? DoWhileLoopEvaluation of |DoWhileStatement| with argument _labelSet_.
        </emu-alg>
        <emu-grammar>IterationStatement : WhileStatement</emu-grammar>
        <emu-alg>
          1. Return ? WhileLoopEvaluation of |WhileStatement| with argument _labelSet_.
        </emu-alg>
        <emu-grammar>IterationStatement : ForStatement</emu-grammar>
        <emu-alg>
          1. Return ? ForLoopEvaluation of |ForStatement| with argument _labelSet_.
        </emu-alg>
        <emu-grammar>IterationStatement : ForInOfStatement</emu-grammar>
        <emu-alg>
          1. Return ? ForInOfLoopEvaluation of |ForInOfStatement| with argument _labelSet_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-do-while-statement">
      <h1>The `do`-`while` Statement</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        DoWhileStatement[Yield, Await, Return] :
          `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
      </emu-grammar>

      <emu-clause id="sec-do-while-statement-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
          </li>
        </ul>
        <emu-note>
          <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-dowhileloopevaluation" oldids="sec-do-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          Runtime Semantics: DoWhileLoopEvaluation (
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>DoWhileStatement : `do` Statement `while` `(` Expression `)` `;`</emu-grammar>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. Repeat,
            1. Let _stmtResult_ be Completion(Evaluation of |Statement|).
            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).
            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].
            1. Let _exprRef_ be ? Evaluation of |Expression|.
            1. Let _exprValue_ be ? GetValue(_exprRef_).
            1. If ToBoolean(_exprValue_) is *false*, return _V_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-while-statement">
      <h1>The `while` Statement</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        WhileStatement[Yield, Await, Return] :
          `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-while-statement-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
          </li>
        </ul>
        <emu-note>
          <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-whileloopevaluation" oldids="sec-while-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          Runtime Semantics: WhileLoopEvaluation (
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>WhileStatement : `while` `(` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. Repeat,
            1. Let _exprRef_ be ? Evaluation of |Expression|.
            1. Let _exprValue_ be ? GetValue(_exprRef_).
            1. If ToBoolean(_exprValue_) is *false*, return _V_.
            1. Let _stmtResult_ be Completion(Evaluation of |Statement|).
            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).
            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-statement">
      <h1>The `for` Statement</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` LexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>

      <emu-clause id="sec-for-statement-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          ForStatement :
            `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
            `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
            `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
          </li>
        </ul>
        <emu-note>
          <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
        </emu-note>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any element of the BoundNames of |LexicalDeclaration| also occurs in the VarDeclaredNames of |Statement|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forloopevaluation" oldids="sec-for-statement-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          Runtime Semantics: ForLoopEvaluation (
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForStatement : `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. If the first |Expression| is present, then
            1. Let _exprRef_ be ? Evaluation of the first |Expression|.
            1. Perform ? GetValue(_exprRef_).
          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise let _test_ be ~empty~.
          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise let _increment_ be ~empty~.
          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Perform ? Evaluation of |VariableDeclarationList|.
          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise let _test_ be ~empty~.
          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise let _increment_ be ~empty~.
          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).
        </emu-alg>
        <emu-grammar>ForStatement : `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).
          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.
          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.
          1. For each element _dn_ of _boundNames_, do
            1. If _isConst_ is *true*, then
              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).
            1. Else,
              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).
          1. Set the running execution context's LexicalEnvironment to _loopEnv_.
          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).
          1. If _forDcl_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. Return ? _forDcl_.
          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.
          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise let _test_ be ~empty~.
          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise let _increment_ be ~empty~.
          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return ? _bodyResult_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-forbodyevaluation" type="abstract operation">
        <h1>
          ForBodyEvaluation (
            _test_: an |Expression| Parse Node or ~empty~,
            _increment_: an |Expression| Parse Node or ~empty~,
            _stmt_: a |Statement| Parse Node,
            _perIterationBindings_: a List of Strings,
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _V_ be *undefined*.
          1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).
          1. Repeat,
            1. If _test_ is not ~empty~, then
              1. Let _testRef_ be ? Evaluation of _test_.
              1. Let _testValue_ be ? GetValue(_testRef_).
              1. If ToBoolean(_testValue_) is *false*, return _V_.
            1. Let _result_ be Completion(Evaluation of _stmt_).
            1. If LoopContinues(_result_, _labelSet_) is *false*, return ? UpdateEmpty(_result_, _V_).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
            1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).
            1. If _increment_ is not ~empty~, then
              1. Let _incRef_ be ? Evaluation of _increment_.
              1. Perform ? GetValue(_incRef_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createperiterationenvironment" type="abstract operation">
        <h1>
          CreatePerIterationEnvironment (
            _perIterationBindings_: a List of Strings,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _perIterationBindings_ has any elements, then
            1. Let _lastIterationEnv_ be the running execution context's LexicalEnvironment.
            1. Let _outer_ be _lastIterationEnv_.[[OuterEnv]].
            1. Assert: _outer_ is not *null*.
            1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).
            1. For each element _bn_ of _perIterationBindings_, do
              1. Perform ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*).
              1. Let _lastValue_ be ? _lastIterationEnv_.GetBindingValue(_bn_, *true*).
              1. Perform ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_).
            1. Set the running execution context's LexicalEnvironment to _thisIterationEnv_.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-for-in-and-for-of-statements">
      <h1>The `for`-`in`, `for`-`of`, and `for`-`await`-`of` Statements</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` [lookahead != `let` `[`] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` [lookahead &notin; { `let`, `async` `of` }] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` [lookahead != `let`] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
          [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]

        ForDeclaration[Yield, Await] :
          LetOrConst ForBinding[?Yield, ?Await]

        ForBinding[Yield, Await] :
          BindingIdentifier[?Yield, ?Await]
          BindingPattern[?Yield, ?Await]
      </emu-grammar>
      <emu-note>
        <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
      </emu-note>

      <emu-clause id="sec-for-in-and-for-of-statements-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` `var` ForBinding `in` Expression `)` Statement
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
          </li>
        </ul>
        <emu-note>
          <p>It is only necessary to apply this rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
        </emu-note>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` LeftHandSideExpression `in` Expression `)` Statement
            `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
            `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            If |LeftHandSideExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, |LeftHandSideExpression| must cover an |AssignmentPattern|.
          </li>
          <li>
            If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, it is a Syntax Error if the AssignmentTargetType of |LeftHandSideExpression| is ~invalid~.
          </li>
        </ul>
        <emu-grammar>
          ForInOfStatement :
            `for` `(` ForDeclaration `in` Expression `)` Statement
            `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
            `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |ForDeclaration| contains *"let"*.
          </li>
          <li>
            It is a Syntax Error if any element of the BoundNames of |ForDeclaration| also occurs in the VarDeclaredNames of |Statement|.
          </li>
          <li>
            It is a Syntax Error if the BoundNames of |ForDeclaration| contains any duplicate entries.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-isdestructuring" oldids="sec-static-semantics-static-semantics-isdestructuring,sec-for-in-and-for-of-statements-static-semantics-isdestructuring" type="sdo">
        <h1>Static Semantics: IsDestructuring ( ): a Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>MemberExpression : PrimaryExpression</emu-grammar>
        <emu-alg>
          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>
          MemberExpression :
            MemberExpression `[` Expression `]`
            MemberExpression `.` IdentifierName
            MemberExpression TemplateLiteral
            SuperProperty
            MetaProperty
            `new` MemberExpression Arguments
            MemberExpression `.` PrivateIdentifier

          NewExpression :
            `new` NewExpression

          LeftHandSideExpression :
            CallExpression
            OptionalExpression
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Return IsDestructuring of |ForBinding|.
        </emu-alg>
        <emu-grammar>ForBinding : BindingIdentifier</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ForBinding : BindingPattern</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginitialization" oldids="sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization" type="sdo">
        <h1>
          Runtime Semantics: ForDeclarationBindingInitialization (
            _value_: an ECMAScript language value,
            _environment_: an Environment Record or *undefined*,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>*undefined* is passed for _environment_ to indicate that a PutValue operation should be used to assign the initialization value. This is the case for `var` statements and the formal parameter lists of some non-strict functions (see <emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>). In those cases a lexical binding is hoisted and preinitialized prior to evaluation of its initializer.</p>
        </emu-note>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. Return ? BindingInitialization of |ForBinding| with arguments _value_ and _environment_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-fordeclarationbindinginstantiation" oldids="sec-runtime-semantics-bindinginstantiation" type="sdo">
        <h1>
          Runtime Semantics: ForDeclarationBindingInstantiation (
            _environment_: a Declarative Environment Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForDeclaration : LetOrConst ForBinding</emu-grammar>
        <emu-alg>
          1. For each element _name_ of the BoundNames of |ForBinding|, do
            1. If IsConstantDeclaration of |LetOrConst| is *true*, then
              1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).
            1. Else,
              1. Perform ! _environment_.CreateMutableBinding(_name_, *false*).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofloopevaluation" oldids="sec-for-in-and-for-of-statements-runtime-semantics-labelledevaluation" type="sdo">
        <h1>
          Runtime Semantics: ForInOfLoopEvaluation (
            _labelSet_: a List of Strings,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).
          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_).
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_).
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `in` Expression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_).
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_).
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_).
        </emu-alg>
        <emu-grammar>ForInOfStatement : `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement</emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_).
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~).
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~).
        </emu-alg>
        <emu-grammar>
          ForInOfStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
        </emu-grammar>
        <emu-alg>
          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).
          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~).
        </emu-alg>
        <emu-note>
          <p>This section is extended by Annex <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forinofheadevaluation" type="abstract operation" oldids="sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">
        <h1>
          ForIn/OfHeadEvaluation (
            _uninitializedBoundNames_: a List of Strings,
            _expr_: an |Expression| Parse Node or an |AssignmentExpression| Parse Node,
            _iterationKind_: ~enumerate~, ~iterate~, or ~async-iterate~,
          ): either a normal completion containing an Iterator Record or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. If _uninitializedBoundNames_ is not empty, then
            1. Assert: _uninitializedBoundNames_ has no duplicate entries.
            1. Let _newEnv_ be NewDeclarativeEnvironment(_oldEnv_).
            1. For each String _name_ of _uninitializedBoundNames_, do
              1. Perform ! _newEnv_.CreateMutableBinding(_name_, *false*).
            1. Set the running execution context's LexicalEnvironment to _newEnv_.
          1. Let _exprRef_ be Completion(Evaluation of _expr_).
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Let _exprValue_ be ? GetValue(? _exprRef_).
          1. If _iterationKind_ is ~enumerate~, then
            1. If _exprValue_ is either *undefined* or *null*, then
              1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
            1. Let _obj_ be ! ToObject(_exprValue_).
            1. Let _iterator_ be EnumerateObjectProperties(_obj_).
            1. Let _nextMethod_ be ! GetV(_iterator_, *"next"*).
            1. Return the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.
          1. Else,
            1. Assert: _iterationKind_ is either ~iterate~ or ~async-iterate~.
            1. If _iterationKind_ is ~async-iterate~, let _iteratorKind_ be ~async~.
            1. Else, let _iteratorKind_ be ~sync~.
            1. Return ? GetIterator(_exprValue_, _iteratorKind_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset" type="abstract operation">
        <h1>
          ForIn/OfBodyEvaluation (
            _lhs_: a Parse Node,
            _stmt_: a |Statement| Parse Node,
            _iteratorRecord_: an Iterator Record,
            _iterationKind_: ~enumerate~ or ~iterate~,
            _lhsKind_: ~assignment~, ~var-binding~, or ~lexical-binding~,
            _labelSet_: a List of Strings,
            optional _iteratorKind_: ~sync~ or ~async~,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.
          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
          1. Let _V_ be *undefined*.
          1. Let _destructuring_ be IsDestructuring of _lhs_.
          1. If _destructuring_ is *true* and _lhsKind_ is ~assignment~, then
            1. Assert: _lhs_ is a |LeftHandSideExpression|.
            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.
          1. Repeat,
            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
            1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).
            1. If _nextResult_ is not an Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_nextResult_).
            1. If _done_ is *true*, return _V_.
            1. Let _nextValue_ be ? IteratorValue(_nextResult_).
            1. If _lhsKind_ is either ~assignment~ or ~var-binding~, then
              1. If _destructuring_ is *true*, then
                1. If _lhsKind_ is ~assignment~, then
                  1. Let _status_ be Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_).
                1. Else,
                  1. Assert: _lhsKind_ is ~var-binding~.
                  1. Assert: _lhs_ is a |ForBinding|.
                  1. Let _status_ be Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*).
              1. Else,
                1. Let _lhsRef_ be Completion(Evaluation of _lhs_). (It may be evaluated repeatedly.)
                1. If _lhsKind_ is ~assignment~ and the AssignmentTargetType of _lhs_ is ~web-compat~, throw a *ReferenceError* exception.
                1. If _lhsRef_ is an abrupt completion, then
                  1. Let _status_ be _lhsRef_.
                1. Else,
                  1. Let _status_ be Completion(PutValue(_lhsRef_.[[Value]], _nextValue_)).
            1. Else,
              1. Assert: _lhsKind_ is ~lexical-binding~.
              1. Assert: _lhs_ is a |ForDeclaration|.
              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).
              1. Perform ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_.
              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.
              1. If _destructuring_ is *true*, then
                1. Let _status_ be Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_).
              1. Else,
                1. Assert: _lhs_ binds a single name.
                1. Let _lhsName_ be the sole element of the BoundNames of _lhs_.
                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).
                1. Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)).
            1. If _status_ is an abrupt completion, then
              1. Set the running execution context's LexicalEnvironment to _oldEnv_.
              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
              1. If _iterationKind_ is ~enumerate~, then
                1. Return ? _status_.
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. Let _result_ be Completion(Evaluation of _stmt_).
            1. Set the running execution context's LexicalEnvironment to _oldEnv_.
            1. If LoopContinues(_result_, _labelSet_) is *false*, then
              1. If _iterationKind_ is ~enumerate~, then
                1. Return ? UpdateEmpty(_result_, _V_).
              1. Else,
                1. Assert: _iterationKind_ is ~iterate~.
                1. Set _status_ to Completion(UpdateEmpty(_result_, _V_)).
                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).
                1. Return ? IteratorClose(_iteratorRecord_, _status_).
            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-for-in-and-for-of-statements-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>
          BindingIdentifier :
            Identifier
            `yield`
            `await`
        </emu-grammar>
        <emu-alg>
          1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
          1. Return ? ResolveBinding(_bindingId_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-enumerate-object-properties" type="abstract operation">
        <h1>
          EnumerateObjectProperties (
            _O_: an Object,
          ): an iterator object
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return an iterator object whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.
        </emu-alg>
        <p>The iterator's `throw` and `return` methods are *null* and are never invoked. The iterator's `next` method processes object properties to determine whether the property key should be returned as an iterator value. Returned property keys do not include keys that are Symbols. Properties of the target object may be deleted during enumeration. A property that is deleted before it is processed by the iterator's `next` method is ignored. If new properties are added to the target object during enumeration, the newly added properties are not guaranteed to be processed in the active enumeration. A property name will be returned by the iterator's `next` method at most once in any enumeration.</p>
        <p>Enumerating the properties of the target object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not processed if it has the same name as a property that has already been processed by the iterator's `next` method. The values of [[Enumerable]] attributes are not considered when determining if a property of a prototype object has already been processed. The enumerable property names of prototype objects must be obtained by invoking EnumerateObjectProperties passing the prototype object as the argument. EnumerateObjectProperties must obtain the own property keys of the target object by calling its [[OwnPropertyKeys]] internal method. Property attributes of the target object must be obtained by calling its [[GetOwnProperty]] internal method.</p>
        <p>In addition, if neither _O_ nor any object in its prototype chain is a Proxy exotic object, TypedArray, module namespace exotic object, or implementation provided exotic object, then the iterator must behave as would the iterator given by CreateForInIterator(_O_) until one of the following occurs:</p>
        <ul>
          <li>the value of the [[Prototype]] internal slot of _O_ or an object in its prototype chain changes,</li>
          <li>a property is removed from _O_ or an object in its prototype chain,</li>
          <li>a property is added to an object in _O_'s prototype chain, or</li>
          <li>the value of the [[Enumerable]] attribute of a property of _O_ or an object in its prototype chain changes.</li>
        </ul>

        <emu-note>
          <p>ECMAScript implementations are not required to implement the algorithm in <emu-xref href="#sec-%foriniteratorprototype%.next"></emu-xref> directly. They may choose any implementation whose behaviour will not deviate from that algorithm unless one of the constraints in the previous paragraph is violated.</p>
          <p>The following is an informative definition of an ECMAScript generator function that conforms to these rules:</p>
          <pre><code class="javascript">
            function* EnumerateObjectProperties(obj) {
              const visited = new Set();
              for (const key of Reflect.ownKeys(obj)) {
                if (typeof key === "symbol") continue;
                const desc = Reflect.getOwnPropertyDescriptor(obj, key);
                if (desc) {
                  visited.add(key);
                  if (desc.enumerable) yield key;
                }
              }
              const proto = Reflect.getPrototypeOf(obj);
              if (proto === null) return;
              for (const protoKey of EnumerateObjectProperties(proto)) {
                if (!visited.has(protoKey)) yield protoKey;
              }
            }
          </code></pre>
        </emu-note>
        <emu-note>
          The list of exotic objects for which implementations are not required to match CreateForInIterator was chosen because implementations historically differed in behaviour for those cases, and agreed in all others.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-for-in-iterator-objects">
        <h1>For-In Iterator Objects</h1>
        <p>A <dfn variants="For-In Iterator object,For-In Iterator objects">For-In Iterator</dfn> is an object that represents a specific iteration over some specific object. For-In Iterator objects are never directly accessible to ECMAScript code; they exist solely to illustrate the behaviour of EnumerateObjectProperties.</p>

        <emu-clause id="sec-createforiniterator" type="abstract operation">
          <h1>
            CreateForInIterator (
              _object_: an Object,
            ): a For-In Iterator
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It is used to create a For-In Iterator object which iterates over the own and inherited enumerable string properties of _object_ in a specific order.</dd>
          </dl>
          <emu-alg>
            1. Let _iterator_ be OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).
            1. Set _iterator_.[[Object]] to _object_.
            1. Set _iterator_.[[ObjectWasVisited]] to *false*.
            1. Set _iterator_.[[VisitedKeys]] to a new empty List.
            1. Set _iterator_.[[RemainingKeys]] to a new empty List.
            1. Return _iterator_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%foriniteratorprototype%-object">
          <h1>The %ForInIteratorPrototype% Object</h1>
          <p>The <dfn>%ForInIteratorPrototype%</dfn> object:</p>
          <ul>
            <li>has properties that are inherited by all For-In Iterator objects.</li>
            <li>is an ordinary object.</li>
            <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
            <li>is never directly accessible to ECMAScript code.</li>
            <li>has the following properties:</li>
          </ul>

          <emu-clause id="sec-%foriniteratorprototype%.next">
            <h1>%ForInIteratorPrototype%.next ( )</h1>
            <emu-alg>
              1. Let _O_ be the *this* value.
              1. Assert: _O_ is an Object.
              1. Assert: _O_ has all of the internal slots of a For-In Iterator instance (<emu-xref href="#sec-properties-of-for-in-iterator-instances"></emu-xref>).
              1. Let _object_ be _O_.[[Object]].
              1. Repeat,
                1. If _O_.[[ObjectWasVisited]] is *false*, then
                  1. Let _keys_ be ? <emu-meta effects="user-code">_object_.[[OwnPropertyKeys]]()</emu-meta>.
                  1. For each element _key_ of _keys_, do
                    1. If _key_ is a String, then
                      1. Append _key_ to _O_.[[RemainingKeys]].
                  1. Set _O_.[[ObjectWasVisited]] to *true*.
                1. Repeat, while _O_.[[RemainingKeys]] is not empty,
                  1. Let _r_ be the first element of _O_.[[RemainingKeys]].
                  1. Remove the first element from _O_.[[RemainingKeys]].
                  1. If _O_.[[VisitedKeys]] does not contain _r_, then
                    1. Let _desc_ be ? <emu-meta effects="user-code">_object_.[[GetOwnProperty]]</emu-meta>(_r_).
                    1. If _desc_ is not *undefined*, then
                      1. Append _r_ to _O_.[[VisitedKeys]].
                      1. If _desc_.[[Enumerable]] is *true*, return CreateIteratorResultObject(_r_, *false*).
                1. Set _object_ to ? <emu-meta effects="user-code">_object_.[[GetPrototypeOf]]()</emu-meta>.
                1. Set _O_.[[Object]] to _object_.
                1. Set _O_.[[ObjectWasVisited]] to *false*.
                1. If _object_ is *null*, return CreateIteratorResultObject(*undefined*, *true*).
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-properties-of-for-in-iterator-instances">
          <h1>Properties of For-In Iterator Instances</h1>
          <p>For-In Iterator instances are ordinary objects that inherit properties from the %ForInIteratorPrototype% intrinsic object. For-In Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-for-in-iterator-instance-slots"></emu-xref>.</p>
          <emu-table id="table-for-in-iterator-instance-slots" caption="Internal Slots of For-In Iterator Instances">
            <table>
              <thead>
                <tr>
                  <th>
                    Internal Slot
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  [[Object]]
                </td>
                <td>
                  an Object
                </td>
                <td>
                  The Object value whose properties are being iterated.
                </td>
              </tr>
              <tr>
                <td>
                  [[ObjectWasVisited]]
                </td>
                <td>
                  a Boolean
                </td>
                <td>
                  *true* if the iterator has invoked [[OwnPropertyKeys]] on [[Object]], *false* otherwise.
                </td>
              </tr>
              <tr>
                <td>
                  [[VisitedKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  The values that have been emitted by this iterator thus far.
                </td>
              </tr>
              <tr>
                <td>
                  [[RemainingKeys]]
                </td>
                <td>
                  a List of Strings
                </td>
                <td>
                  The values remaining to be emitted for the current object, before iterating the properties of its prototype (if its prototype is not *null*).
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-continue-statement">
    <h1>The `continue` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ContinueStatement[Yield, Await] :
        `continue` `;`
        `continue` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-continue-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        ContinueStatement :
          `continue` `;`
          `continue` LabelIdentifier `;`
      </emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this |ContinueStatement| is not nested, directly or indirectly (but not crossing function or `static` initialization block boundaries), within an |IterationStatement|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-continue-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ContinueStatement : `continue` `;`</emu-grammar>
      <emu-alg>
        1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
      </emu-alg>
      <emu-grammar>ContinueStatement : `continue` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-break-statement">
    <h1>The `break` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      BreakStatement[Yield, Await] :
        `break` `;`
        `break` [no LineTerminator here] LabelIdentifier[?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-break-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if this |BreakStatement| is not nested, directly or indirectly (but not crossing function or `static` initialization block boundaries), within an |IterationStatement| or a |SwitchStatement|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-break-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>BreakStatement : `break` `;`</emu-grammar>
      <emu-alg>
        1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.
      </emu-alg>
      <emu-grammar>BreakStatement : `break` LabelIdentifier `;`</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-return-statement">
    <h1>The `return` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ReturnStatement[Yield, Await] :
        `return` `;`
        `return` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>
    <emu-note>
      <p>A `return` statement causes a function to cease execution and, in most cases, returns a value to the caller. If |Expression| is omitted, the return value is *undefined*. Otherwise, the return value is the value of |Expression|. A `return` statement may not actually return a value to the caller depending on surrounding context. For example, in a `try` block, a `return` statement's Completion Record may be replaced with another Completion Record during evaluation of the `finally` block.</p>
    </emu-note>

    <emu-clause id="sec-return-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ReturnStatement : `return` `;`</emu-grammar>
      <emu-alg>
        1. Return ReturnCompletion(*undefined*).
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprValue_ be ? GetValue(_exprRef_).
        1. If GetGeneratorKind() is ~async~, set _exprValue_ to ? Await(_exprValue_).
        1. Return ReturnCompletion(_exprValue_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-with-statement" legacy>
    <h1>The `with` Statement</h1>
    <emu-note>
      <p>Use of the Legacy `with` statement is discouraged in new ECMAScript code. Consider alternatives that are permitted in both strict mode code and non-strict code, such as <emu-xref href="#sec-destructuring-assignment">destructuring assignment</emu-xref>.</p>
    </emu-note>

    <h2>Syntax</h2>
    <emu-grammar type="definition">
      WithStatement[Yield, Await, Return] :
        `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    </emu-grammar>
    <emu-note>
      <p>The `with` statement adds an Object Environment Record for a computed object to the lexical environment of the running execution context. It then executes a statement using this augmented lexical environment. Finally, it restores the original lexical environment.</p>
    </emu-note>

    <emu-clause id="sec-with-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsStrict(this production) is *true*.
        </li>
        <li>
          It is a Syntax Error if IsLabelledFunction(|Statement|) is *true*.
        </li>
      </ul>
      <emu-note>
        <p>It is only necessary to apply the second rule if the extension specified in <emu-xref href="#sec-labelled-function-declarations"></emu-xref> is implemented.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-with-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _val_ be ? Evaluation of |Expression|.
        1. Let _obj_ be ? ToObject(? GetValue(_val_)).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _newEnv_ be NewObjectEnvironment(_obj_, *true*, _oldEnv_).
        1. Set the running execution context's LexicalEnvironment to _newEnv_.
        1. Let _C_ be Completion(Evaluation of |Statement|).
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return ? UpdateEmpty(_C_, *undefined*).
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the embedded |Statement|, whether normally or by some form of abrupt completion or exception, the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-switch-statement">
    <h1>The `switch` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      SwitchStatement[Yield, Await, Return] :
        `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]

      CaseBlock[Yield, Await, Return] :
        `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
        `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`

      CaseClauses[Yield, Await, Return] :
        CaseClause[?Yield, ?Await, ?Return]
        CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]

      CaseClause[Yield, Await, Return] :
        `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?

      DefaultClause[Yield, Await, Return] :
        `default` `:` StatementList[?Yield, ?Await, ?Return]?
    </emu-grammar>

    <emu-clause id="sec-switch-statement-static-semantics-early-errors" oldids="sec-switch-duplicates-allowed-static-semantics">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <ul>
        <li>
          <p>It is a Syntax Error if the LexicallyDeclaredNames of |CaseBlock| contains any duplicate entries<span normative-optional>, unless the host is a web browser or otherwise supports <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>, and both of the following conditions are true:</span></p>
          <ul normative-optional>
            <li>IsStrict(this production) is *false*.</li>
            <li>The duplicate entries are only bound by FunctionDeclarations.</li>
          </ul>
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |CaseBlock| also occurs in the VarDeclaredNames of |CaseBlock|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseblockevaluation" type="sdo">
      <h1>
        Runtime Semantics: CaseBlockEvaluation (
          _input_: an ECMAScript language value,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>CaseBlock : `{` `}`</emu-grammar>
      <emu-alg>
        1. Return *undefined*.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses `}`</emu-grammar>
      <emu-alg>
        1. Let _V_ be *undefined*.
        1. Let _A_ be the List of |CaseClause| items in |CaseClauses|, in source text order.
        1. Let _found_ be *false*.
        1. For each |CaseClause| _C_ of _A_, do
          1. If _found_ is *false*, then
            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).
          1. If _found_ is *true*, then
            1. Let _R_ be Completion(Evaluation of _C_).
            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).
        1. Return _V_.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. Let _V_ be *undefined*.
        1. If the first |CaseClauses| is present, then
          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.
        1. Else,
          1. Let _A_ be a new empty List.
        1. Let _found_ be *false*.
        1. For each |CaseClause| _C_ of _A_, do
          1. If _found_ is *false*, then
            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).
          1. If _found_ is *true*, then
            1. Let _R_ be Completion(Evaluation of _C_).
            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).
        1. Let _foundInB_ be *false*.
        1. If the second |CaseClauses| is present, then
          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.
        1. Else,
          1. Let _B_ be a new empty List.
        1. If _found_ is *false*, then
          1. For each |CaseClause| _C_ of _B_, do
            1. If _foundInB_ is *false*, then
              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).
            1. If _foundInB_ is *true*, then
              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).
              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).
        1. If _foundInB_ is *true*, return _V_.
        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).
        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].
        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).
        1. NOTE: The following is another complete iteration of the second |CaseClauses|.
        1. For each |CaseClause| _C_ of _B_, do
          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).
          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].
          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).
        1. Return _V_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-caseclauseisselected" type="abstract operation" oldids="sec-runtime-semantics-caseselectorevaluation">
      <h1>
        CaseClauseIsSelected (
          _C_: a |CaseClause| Parse Node,
          _input_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or an abrupt completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It determines whether _C_ matches _input_.</dd>
      </dl>
      <emu-alg>
        1. Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.
        1. Let _exprRef_ be ? Evaluation of the |Expression| of _C_.
        1. Let _clauseSelector_ be ? GetValue(_exprRef_).
        1. Return IsStrictlyEqual(_input_, _clauseSelector_).
      </emu-alg>
      <emu-note>
        <p>This operation does not execute _C_'s |StatementList| (if any). The |CaseBlock| algorithm uses its return value to determine which |StatementList| to start executing.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-switch-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _switchValue_ be ? GetValue(_exprRef_).
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).
        1. Set the running execution context's LexicalEnvironment to _blockEnv_.
        1. Let _R_ be Completion(CaseBlockEvaluation of |CaseBlock| with argument _switchValue_).
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return _R_.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |SwitchStatement| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
      <emu-grammar>CaseClause : `case` Expression `:`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>CaseClause : `case` Expression `:` StatementList</emu-grammar>
      <emu-alg>
        1. Return ? Evaluation of |StatementList|.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>DefaultClause : `default` `:` StatementList</emu-grammar>
      <emu-alg>
        1. Return ? Evaluation of |StatementList|.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-labelled-statements">
    <h1>Labelled Statements</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      LabelledStatement[Yield, Await, Return] :
        LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]

      LabelledItem[Yield, Await, Return] :
        Statement[?Yield, ?Await, ?Return]
        FunctionDeclaration[?Yield, ?Await, ~Default]
    </emu-grammar>
    <emu-note>
      <p>A |Statement| may be prefixed by a label. Labelled statements are only used in conjunction with labelled `break` and `continue` statements. ECMAScript has no `goto` statement. A |Statement| can be part of a |LabelledStatement|, which itself can be part of a |LabelledStatement|, and so on. The labels introduced this way are collectively referred to as the “current label set” when describing the semantics of individual statements.</p>
    </emu-note>

    <emu-clause id="sec-labelled-statements-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if any source text is matched by this production<span normative-optional>, unless that source text is non-strict code and the host is a web browser or otherwise supports <emu-xref href="#sec-labelled-function-declarations" title></emu-xref></span>.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-islabelledfunction" type="abstract operation">
      <h1>
        Static Semantics: IsLabelledFunction (
          _stmt_: a |Statement| Parse Node,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _stmt_ is not a |LabelledStatement|, return *false*.
        1. Let _item_ be the |LabelledItem| of _stmt_.
        1. If _item_ is <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>, return *true*.
        1. Let _subStmt_ be the |Statement| of _item_.
        1. Return IsLabelledFunction(_subStmt_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-labelled-statements-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Return ? LabelledEvaluation of this |LabelledStatement| with argument « ».
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-labelledevaluation" oldids="sec-statement-semantics-runtime-semantics-labelledevaluation,sec-labelled-statements-runtime-semantics-labelledevaluation" type="sdo">
      <h1>
        Runtime Semantics: LabelledEvaluation (
          _labelSet_: a List of Strings,
        ): either a normal completion containing either an ECMAScript language value or ~empty~, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>BreakableStatement : IterationStatement</emu-grammar>
      <emu-alg>
        1. Let _stmtResult_ be Completion(LoopEvaluation of |IterationStatement| with argument _labelSet_).
        1. If _stmtResult_ is a break completion, then
          1. If _stmtResult_.[[Target]] is ~empty~, then
            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).
            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).
        1. Return ? _stmtResult_.
      </emu-alg>
      <emu-grammar>BreakableStatement : SwitchStatement</emu-grammar>
      <emu-alg>
        1. Let _stmtResult_ be Completion(Evaluation of |SwitchStatement|).
        1. If _stmtResult_ is a break completion, then
          1. If _stmtResult_.[[Target]] is ~empty~, then
            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).
            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).
        1. Return ? _stmtResult_.
      </emu-alg>
      <emu-note>
        <p>A |BreakableStatement| is one that can be exited via an unlabelled |BreakStatement|.</p>
      </emu-note>
      <emu-grammar>LabelledStatement : LabelIdentifier `:` LabelledItem</emu-grammar>
      <emu-alg>
        1. Let _label_ be the StringValue of |LabelIdentifier|.
        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».
        1. Let _stmtResult_ be Completion(LabelledEvaluation of |LabelledItem| with argument _newLabelSet_).
        1. If _stmtResult_ is a break completion and _stmtResult_.[[Target]] is _label_, then
          1. Set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).
        1. Return ? _stmtResult_.
      </emu-alg>
      <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>
      <emu-alg>
        1. Return ? Evaluation of |FunctionDeclaration|.
      </emu-alg>
      <emu-grammar>
        Statement :
          BlockStatement
          VariableStatement
          EmptyStatement
          ExpressionStatement
          IfStatement
          ContinueStatement
          BreakStatement
          ReturnStatement
          WithStatement
          ThrowStatement
          TryStatement
          DebuggerStatement
      </emu-grammar>
      <emu-alg>
        1. Return ? Evaluation of |Statement|.
      </emu-alg>
      <emu-note>
        <p>The only two productions of |Statement| which have special semantics for LabelledEvaluation are |BreakableStatement| and |LabelledStatement|.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-throw-statement">
    <h1>The `throw` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ThrowStatement[Yield, Await] :
        `throw` [no LineTerminator here] Expression[+In, ?Yield, ?Await] `;`
    </emu-grammar>

    <emu-clause id="sec-throw-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ThrowStatement : `throw` Expression `;`</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |Expression|.
        1. Let _exprValue_ be ? GetValue(_exprRef_).
        1. Return ThrowCompletion(_exprValue_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-try-statement">
    <h1>The `try` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      TryStatement[Yield, Await, Return] :
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
        `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]

      Catch[Yield, Await, Return] :
        `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
        `catch` Block[?Yield, ?Await, ?Return]

      Finally[Yield, Await, Return] :
        `finally` Block[?Yield, ?Await, ?Return]

      CatchParameter[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        BindingPattern[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The `try` statement encloses a block of code in which an exceptional condition can occur, such as a runtime error or a `throw` statement. The `catch` clause provides the exception-handling code. When a catch clause catches an exception, its |CatchParameter| is bound to that exception.</p>
    </emu-note>

    <emu-clause id="sec-try-statement-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the BoundNames of |CatchParameter| contains any duplicate elements.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the LexicallyDeclaredNames of |Block|.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |CatchParameter| also occurs in the VarDeclaredNames of |Block|<span normative-optional>, unless |CatchParameter| is <emu-grammar>CatchParameter : BindingIdentifier</emu-grammar> and the host is a web browser or otherwise supports <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref></span>.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-catchclauseevaluation" type="sdo">
      <h1>
        Runtime Semantics: CatchClauseEvaluation (
          _thrownValue_: an ECMAScript language value,
        ): either a normal completion containing either an ECMAScript language value or ~empty~, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
        1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. For each element _argName_ of the BoundNames of |CatchParameter|, do
          1. Perform ! _catchEnv_.CreateMutableBinding(_argName_, *false*).
        1. Set the running execution context's LexicalEnvironment to _catchEnv_.
        1. Let _status_ be Completion(BindingInitialization of |CatchParameter| with arguments _thrownValue_ and _catchEnv_).
        1. If _status_ is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _oldEnv_.
          1. Return ? _status_.
        1. Let _B_ be Completion(Evaluation of |Block|).
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return ? _B_.
      </emu-alg>
      <emu-grammar>Catch : `catch` Block</emu-grammar>
      <emu-alg>
        1. Return ? Evaluation of |Block|.
      </emu-alg>
      <emu-note>
        <p>No matter how control leaves the |Block| the LexicalEnvironment is always restored to its former state.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-try-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Let _B_ be Completion(Evaluation of |Block|).
        1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).
        1. Else, let _C_ be _B_.
        1. Return ? UpdateEmpty(_C_, *undefined*).
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Finally</emu-grammar>
      <emu-alg>
        1. Let _B_ be Completion(Evaluation of |Block|).
        1. Let _F_ be Completion(Evaluation of |Finally|).
        1. If _F_ is a normal completion, set _F_ to _B_.
        1. Return ? UpdateEmpty(_F_, *undefined*).
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch Finally</emu-grammar>
      <emu-alg>
        1. Let _B_ be Completion(Evaluation of |Block|).
        1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).
        1. Else, let _C_ be _B_.
        1. Let _F_ be Completion(Evaluation of |Finally|).
        1. If _F_ is a normal completion, set _F_ to _C_.
        1. Return ? UpdateEmpty(_F_, *undefined*).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-debugger-statement">
    <h1>The `debugger` Statement</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      DebuggerStatement :
        `debugger` `;`
    </emu-grammar>

    <emu-clause id="sec-debugger-statement-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-note>
        <p>Evaluating a |DebuggerStatement| may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.</p>
      </emu-note>
      <emu-grammar>DebuggerStatement : `debugger` `;`</emu-grammar>
      <emu-alg>
        1. If an implementation-defined debugging facility is available and enabled, then
          1. Perform an implementation-defined debugging action.
          1. Return a new implementation-defined Completion Record.
        1. Else,
          1. Return ~empty~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>
  <emu-note>
    <p>Various ECMAScript language elements cause the creation of ECMAScript function objects (<emu-xref href="#sec-ecmascript-function-objects"></emu-xref>). Evaluation of such functions starts with the execution of their [[Call]] internal method (<emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>).</p>
  </emu-note>

  <emu-clause id="sec-parameter-lists">
    <h1>Parameter Lists</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      UniqueFormalParameters[Yield, Await] :
        FormalParameters[?Yield, ?Await]

      FormalParameters[Yield, Await] :
        [empty]
        FunctionRestParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,`
        FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]

      FormalParameterList[Yield, Await] :
        FormalParameter[?Yield, ?Await]
        FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]

      FunctionRestParameter[Yield, Await] :
        BindingRestElement[?Yield, ?Await]

      FormalParameter[Yield, Await] :
        BindingElement[?Yield, ?Await]
    </emu-grammar>

    <emu-clause id="sec-parameter-lists-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the BoundNames of |FormalParameters| contains any duplicate elements.
        </li>
      </ul>
      <emu-grammar>FormalParameters : FormalParameterList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if IsSimpleParameterList of |FormalParameterList| is *false* and the BoundNames of |FormalParameterList| contains any duplicate elements.
        </li>
      </ul>
      <emu-note>
        <p>Multiple occurrences of the same |BindingIdentifier| in a |FormalParameterList| is only allowed for functions which have simple parameter lists and which are not defined in strict mode code.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsexpression" oldids="sec-destructuring-binding-patterns-static-semantics-containsexpression,sec-function-definitions-static-semantics-containsexpression,sec-arrow-function-definitions-static-semantics-containsexpression,sec-async-arrow-function-definitions-static-semantics-ContainsExpression" type="sdo">
      <h1>Static Semantics: ContainsExpression ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        ObjectBindingPattern :
          `{` `}`
          `{` BindingRestProperty `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ObjectBindingPattern : `{` BindingPropertyList `,` BindingRestProperty `}`</emu-grammar>
      <emu-alg>
        1. Return ContainsExpression of |BindingPropertyList|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Return ContainsExpression of |BindingRestElement|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? `]`</emu-grammar>
      <emu-alg>
        1. Return ContainsExpression of |BindingElementList|.
      </emu-alg>
      <emu-grammar>ArrayBindingPattern : `[` BindingElementList `,` Elision? BindingRestElement `]`</emu-grammar>
      <emu-alg>
        1. Let _has_ be ContainsExpression of |BindingElementList|.
        1. If _has_ is *true*, return *true*.
        1. Return ContainsExpression of |BindingRestElement|.
      </emu-alg>
      <emu-grammar>BindingPropertyList : BindingPropertyList `,` BindingProperty</emu-grammar>
      <emu-alg>
        1. Let _has_ be ContainsExpression of |BindingPropertyList|.
        1. If _has_ is *true*, return *true*.
        1. Return ContainsExpression of |BindingProperty|.
      </emu-alg>
      <emu-grammar>BindingElementList : BindingElementList `,` BindingElisionElement</emu-grammar>
      <emu-alg>
        1. Let _has_ be ContainsExpression of |BindingElementList|.
        1. If _has_ is *true*, return *true*.
        1. Return ContainsExpression of |BindingElisionElement|.
      </emu-alg>
      <emu-grammar>BindingElisionElement : Elision? BindingElement</emu-grammar>
      <emu-alg>
        1. Return ContainsExpression of |BindingElement|.
      </emu-alg>
      <emu-grammar>BindingProperty : PropertyName `:` BindingElement</emu-grammar>
      <emu-alg>
        1. Let _has_ be IsComputedPropertyKey of |PropertyName|.
        1. If _has_ is *true*, return *true*.
        1. Return ContainsExpression of |BindingElement|.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>BindingRestElement : `...` BindingPattern</emu-grammar>
      <emu-alg>
        1. Return ContainsExpression of |BindingPattern|.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.
        1. Return ContainsExpression of |FunctionRestParameter|.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.
        1. Return ContainsExpression of |FormalParameter|.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return ContainsExpression of _formals_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-issimpleparameterlist" oldids="sec-destructuring-binding-patterns-static-semantics-issimpleparameterlist,sec-function-definitions-static-semantics-issimpleparameterlist,sec-arrow-function-definitions-static-semantics-issimpleparameterlist,sec-async-arrow-function-definitions-static-semantics-IsSimpleParameterList" type="sdo">
      <h1>Static Semantics: IsSimpleParameterList ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FormalParameters : [empty]</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>FormalParameters : FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. If IsSimpleParameterList of |FormalParameterList| is *false*, return *false*.
        1. Return IsSimpleParameterList of |FormalParameter|.
      </emu-alg>
      <emu-grammar>FormalParameter : BindingElement</emu-grammar>
      <emu-alg>
        1. Return IsSimpleParameterList of |BindingElement|.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return IsSimpleParameterList of _formals_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>
        CoverCallExpressionAndAsyncArrowHead : MemberExpression Arguments
      </emu-grammar>
      <emu-alg>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. Return IsSimpleParameterList of _head_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasinitializer" oldids="sec-destructuring-binding-patterns-static-semantics-hasinitializer,sec-function-definitions-static-semantics-hasinitializer" type="sdo">
      <h1>Static Semantics: HasInitializer ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>BindingElement : BindingPattern</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>BindingElement : BindingPattern Initializer</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>SingleNameBinding : BindingIdentifier Initializer</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. If HasInitializer of |FormalParameterList| is *true*, return *true*.
        1. Return HasInitializer of |FormalParameter|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-expectedargumentcount" oldids="sec-function-definitions-static-semantics-expectedargumentcount,sec-arrow-function-definitions-static-semantics-expectedargumentcount,sec-method-definitions-static-semantics-expectedargumentcount,sec-async-arrow-function-definitions-static-semantics-ExpectedArgumentCount" type="sdo">
      <h1>Static Semantics: ExpectedArgumentCount ( ): a non-negative integer</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FormalParameters :
          [empty]
          FunctionRestParameter
      </emu-grammar>
      <emu-alg>
        1. Return 0.
      </emu-alg>
      <emu-grammar>FormalParameters : FormalParameterList `,` FunctionRestParameter</emu-grammar>
      <emu-alg>
        1. Return the ExpectedArgumentCount of |FormalParameterList|.
      </emu-alg>
      <emu-note>
        <p>The ExpectedArgumentCount of a |FormalParameterList| is the number of |FormalParameters| to the left of either the rest parameter or the first |FormalParameter| with an Initializer. A |FormalParameter| without an initializer is allowed after the first parameter with an initializer but such parameters are considered to be optional with *undefined* as their default value.</p>
      </emu-note>
      <emu-grammar>FormalParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. If HasInitializer of |FormalParameter| is *true*, return 0.
        1. Return 1.
      </emu-alg>
      <emu-grammar>FormalParameterList : FormalParameterList `,` FormalParameter</emu-grammar>
      <emu-alg>
        1. Let _count_ be the ExpectedArgumentCount of |FormalParameterList|.
        1. If HasInitializer of |FormalParameterList| is *true* or HasInitializer of |FormalParameter| is *true*, return _count_.
        1. Return _count_ + 1.
      </emu-alg>
      <emu-grammar>ArrowParameters : BindingIdentifier</emu-grammar>
      <emu-alg>
        1. Return 1.
      </emu-alg>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return the ExpectedArgumentCount of _formals_.
      </emu-alg>
      <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
      <emu-alg>
        1. If HasInitializer of |FormalParameter| is *true*, return 0.
        1. Return 1.
      </emu-alg>
      <emu-grammar>
        AsyncArrowBindingIdentifier : BindingIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return 1.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-definitions">
    <h1>Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      FunctionDeclaration[Yield, Await, Default] :
        `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionExpression :
        `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`

      FunctionBody[Yield, Await] :
        FunctionStatementList[?Yield, ?Await]

      FunctionStatementList[Yield, Await] :
        StatementList[?Yield, ?Await, +Return]?
    </emu-grammar>

    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          If IsStrict(|FormalParameters|) is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and IsStrict(|BindingIdentifier|) is *true*, it is a Syntax Error if the StringValue of |BindingIdentifier| is either *"eval"* or *"arguments"*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.
        </li>
      </ul>
      <emu-note>
        <p>The LexicallyDeclaredNames of a |FunctionBody| does not include identifiers bound using var or function declarations.</p>
      </emu-note>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |FunctionStatementList| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |FunctionStatementList| also occurs in the VarDeclaredNames of |FunctionStatementList|.
        </li>
        <li>
          It is a Syntax Error if ContainsDuplicateLabels of |FunctionStatementList| with argument « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedBreakTarget of |FunctionStatementList| with argument « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedContinueTarget of |FunctionStatementList| with arguments « » and « » is *true*.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-functionbodycontainsusestrict" oldids="sec-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>Static Semantics: FunctionBodyContainsUseStrict ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. If the Directive Prologue of |FunctionBody| contains a Use Strict Directive, return *true*; otherwise return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluatefunctionbody" oldids="sec-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateFunctionBody (
          _functionObject_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a return completion or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Perform ? Evaluation of |FunctionStatementList|.
        1. NOTE: If the previous step resulted in a normal completion, then evaluation finished by proceeding past the end of the |FunctionStatementList|.
        1. Return ReturnCompletion(*undefined*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionobject" oldids="sec-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        Runtime Semantics: InstantiateOrdinaryFunctionObject (
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _name_ be the StringValue of |BindingIdentifier|.
        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, _name_).
        1. Perform MakeConstructor(_F_).
        1. Return _F_.
      </emu-alg>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, *"default"*).
        1. Perform MakeConstructor(_F_).
        1. Return _F_.
      </emu-alg>
      <emu-note>
        <p>An anonymous |FunctionDeclaration| can only occur as part of an `export default` declaration, and its function code is therefore always strict mode code.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateordinaryfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateOrdinaryFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |FunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform MakeConstructor(_closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to the StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |FunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform MakeConstructor(_closure_).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |FunctionExpression| can be referenced from inside the |FunctionExpression|'s |FunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |FunctionExpression| cannot be referenced from and does not affect the scope enclosing the |FunctionExpression|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-note>
        <p>An alternative semantics is provided by <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref> at step <emu-xref href="#step-functiondeclarationinstantiation-alt-funcdecl-eval"></emu-xref> of FunctionDeclarationInstantiation, step <emu-xref href="#step-globaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> of GlobalDeclarationInstantiation, and step <emu-xref href="#step-evaldeclarationinstantiation-alt-funcdecl-eval"></emu-xref> of EvalDeclarationInstantiation.</p>
      </emu-note>
      <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>
        FunctionExpression : `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.
      </emu-alg>
      <emu-note>
        <p>A *"prototype"* property is automatically created for every function defined using a |FunctionDeclaration| or |FunctionExpression|, to allow for the possibility that the function will be used as a constructor.</p>
      </emu-note>
      <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>Arrow Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ArrowFunction[In, Yield, Await] :
        ArrowParameters[?Yield, ?Await] [no LineTerminator here] `=>` ConciseBody[?In]

      ArrowParameters[Yield, Await] :
        BindingIdentifier[?Yield, ?Await]
        CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

      ConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, ~Await]
        `{` FunctionBody[~Yield, ~Await] `}`

      ExpressionBody[In, Await] :
        AssignmentExpression[?In, ~Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>
      When processing an instance of the production<br>
      <emu-grammar>ArrowParameters[Yield, Await] : CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]</emu-grammar><br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:
    </p>
    <emu-grammar type="definition">
      ArrowFormalParameters[Yield, Await] :
        `(` UniqueFormalParameters[?Yield, ?Await] `)`
    </emu-grammar>

    <emu-clause id="sec-arrow-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |ArrowParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if |ArrowParameters| Contains |AwaitExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if ConciseBodyContainsUseStrict of |ConciseBody| is *true* and IsSimpleParameterList of |ArrowParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |ArrowParameters| also occurs in the LexicallyDeclaredNames of |ConciseBody|.
        </li>
      </ul>
      <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <ul>
        <li>
          |CoverParenthesizedExpressionAndArrowParameterList| must cover an |ArrowFormalParameters|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-concisebodycontainsusestrict" oldids="sec-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>Static Semantics: ConciseBodyContainsUseStrict ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ConciseBody : `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return FunctionBodyContainsUseStrict of |FunctionBody|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateconcisebody" oldids="sec-arrow-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateConciseBody (
          _functionObject_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a return completion or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Return ? Evaluation of |ExpressionBody|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiatearrowfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateArrowFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |ArrowFunction|.
        1. [id="step-arrowfunction-evaluation-functioncreate"] Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>An |ArrowFunction| does not define local bindings for `arguments`, `super`, `this`, or `new.target`. Any reference to `arguments`, `super`, `this`, or `new.target` within an |ArrowFunction| must resolve to a binding in a lexically enclosing environment. Typically this will be the Function Environment of an immediately enclosing function. Even though an |ArrowFunction| may contain references to `super`, the function object created in step <emu-xref href="#step-arrowfunction-evaluation-functioncreate"></emu-xref> is not made into a method by performing MakeMethod. An |ArrowFunction| that references `super` is always contained within a non-|ArrowFunction| and the necessary state to implement `super` is accessible via the _env_ that is captured by the function object of the |ArrowFunction|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. Return InstantiateArrowFunctionExpression of |ArrowFunction|.
      </emu-alg>
      <emu-grammar>ExpressionBody : AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.
        1. Let _exprValue_ be ? GetValue(_exprRef_).
        1. Return ReturnCompletion(_exprValue_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>Method Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      MethodDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
        GeneratorMethod[?Yield, ?Await]
        AsyncMethod[?Yield, ?Await]
        AsyncGeneratorMethod[?Yield, ?Await]
        `get` ClassElementName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
        `set` ClassElementName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

      PropertySetParameterList :
        FormalParameter[~Yield, ~Await]
    </emu-grammar>

    <emu-clause id="sec-method-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
      </ul>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the BoundNames of |PropertySetParameterList| contains any duplicate elements.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |PropertySetParameterList| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |PropertySetParameterList| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hasdirectsuper" oldids="sec-method-definitions-static-semantics-hasdirectsuper,sec-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-generator-function-definitions-static-semantics-hasdirectsuper,sec-async-function-definitions-static-semantics-HasDirectSuper" type="sdo">
      <h1>Static Semantics: HasDirectSuper ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return |FunctionBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |PropertySetParameterList| Contains |SuperCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |GeneratorBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |AsyncGeneratorBody| Contains |SuperCall|.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.
        1. Return |AsyncFunctionBody| Contains |SuperCall|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-specialmethod" type="sdo">
      <h1>Static Semantics: SpecialMethod ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        MethodDefinition :
          GeneratorMethod
          AsyncMethod
          AsyncGeneratorMethod
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-definemethod" type="sdo">
      <h1>
        Runtime Semantics: DefineMethod (
          _object_: an Object,
          optional _functionPrototype_: an Object,
        ): either a normal completion containing a Record with fields [[Key]] (a property key) and [[Closure]] (an ECMAScript function object) or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. If _functionPrototype_ is present, then
          1. Let _prototype_ be _functionPrototype_.
        1. Else,
          1. Let _prototype_ be %Function.prototype%.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-methoddefinitionevaluation" oldids="sec-method-definitions-runtime-semantics-propertydefinitionevaluation,sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation,sec-asyncgenerator-definitions-propertydefinitionevaluation,sec-async-function-definitions-PropertyDefinitionEvaluation" type="sdo">
      <h1>
        Runtime Semantics: MethodDefinitionEvaluation (
          _object_: an Object,
          _enumerable_: a Boolean,
        ): either a normal completion containing either a PrivateElement or ~unused~, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _methodDef_ be ? DefineMethod of |MethodDefinition| with argument _object_.
        1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).
        1. Return ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_).
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_, *"get"*).
        1. If _propKey_ is a Private Name, then
          1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* }.
        1. Else,
          1. Let _desc_ be the PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
          1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
          1. Return ~unused~.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_, *"set"*).
        1. If _propKey_ is a Private Name, then
          1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ }.
        1. Else,
          1. Let _desc_ be the PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
          1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
          1. Return ~unused~.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorMethod|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorMethod|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncMethod|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. Perform SetFunctionName(_closure_, _propKey_).
        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      GeneratorDeclaration[Yield, Await, Default] :
        `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
        [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorExpression :
        `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorMethod[Yield, Await] :
        `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

      GeneratorBody :
        FunctionBody[+Yield, ~Await]

      YieldExpression[In, Await] :
        `yield`
        `yield` [no LineTerminator here] AssignmentExpression[?In, +Yield, ?Await]
        `yield` [no LineTerminator here] `*` AssignmentExpression[?In, +Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>The syntactic context immediately following `yield` requires use of the |InputElementRegExpOrTemplateTail| lexical goal.</p>
    </emu-note>
    <emu-note>
      <p>|YieldExpression| cannot be used within the |FormalParameters| of a generator function because any expressions that are part of |FormalParameters| are evaluated before the resulting Generator is in a resumable state.</p>
    </emu-note>
    <emu-note>
      <p>Abstract operations relating to Generators are defined in <emu-xref href="#sec-generator-abstract-operations"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if HasDirectSuper of |GeneratorMethod| is *true*.
        </li>
        <li>
          It is a Syntax Error if |UniqueFormalParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.
        </li>
      </ul>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>
          If IsStrict(|FormalParameters|) is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and IsStrict(|BindingIdentifier|) is *true*, it is a Syntax Error if the StringValue of |BindingIdentifier| is either *"eval"* or *"arguments"*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateGeneratorBody (
          _functionObject_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a throw completion or a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorPrototype%"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »).
        1. Set _G_.[[GeneratorBrand]] to ~empty~.
        1. Set _G_.[[GeneratorState]] to ~suspended-start~.
        1. Perform GeneratorStart(_G_, |FunctionBody|).
        1. Return ReturnCompletion(_G_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionobject" oldids="sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject" type="sdo">
      <h1>
        Runtime Semantics: InstantiateGeneratorFunctionObject (
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _name_ be the StringValue of |BindingIdentifier|.
        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _F_.
      </emu-alg>
      <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, *"default"*).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _F_.
      </emu-alg>
      <emu-note>
        <p>An anonymous |GeneratorDeclaration| can only occur as part of an `export default` declaration, and its function code is therefore always strict mode code.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiategeneratorfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateGeneratorFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to the StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in a |GeneratorExpression| can be referenced from inside the |GeneratorExpression|'s |FunctionBody| to allow the generator code to call itself recursively. However, unlike in a |GeneratorDeclaration|, the |BindingIdentifier| in a |GeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |GeneratorExpression|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generator-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        GeneratorExpression : `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.
      </emu-alg>
      <emu-grammar>YieldExpression : `yield`</emu-grammar>
      <emu-alg>
        1. Return ? Yield(*undefined*).
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.
        1. Let _value_ be ? GetValue(_exprRef_).
        1. Return ? Yield(_value_).
      </emu-alg>
      <emu-grammar>YieldExpression : `yield` `*` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _generatorKind_ be GetGeneratorKind().
        1. Assert: _generatorKind_ is either ~sync~ or ~async~.
        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.
        1. Let _value_ be ? GetValue(_exprRef_).
        1. Let _iteratorRecord_ be ? GetIterator(_value_, _generatorKind_).
        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].
        1. Let _received_ be NormalCompletion(*undefined*).
        1. Repeat,
          1. If _received_ is a normal completion, then
            1. Let _innerResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »).
            1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).
            1. If _innerResult_ is not an Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_innerResult_).
            1. If _done_ is *true*, then
              1. Return ? IteratorValue(_innerResult_).
            1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).
            1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).
          1. Else if _received_ is a throw completion, then
            1. Let _throw_ be ? GetMethod(_iterator_, *"throw"*).
            1. If _throw_ is not *undefined*, then
              1. Let _innerResult_ be ? Call(_throw_, _iterator_, « _received_.[[Value]] »).
              1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).
              1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.
              1. If _innerResult_ is not an Object, throw a *TypeError* exception.
              1. Let _done_ be ? IteratorComplete(_innerResult_).
              1. If _done_ is *true*, then
                1. Return ? IteratorValue(_innerResult_).
              1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).
              1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).
            1. Else,
              1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.
              1. Let _closeCompletion_ be NormalCompletion(~empty~).
              1. If _generatorKind_ is ~async~, perform ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_).
              1. Else, perform ? IteratorClose(_iteratorRecord_, _closeCompletion_).
              1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.
              1. Throw a *TypeError* exception.
          1. Else,
            1. Assert: _received_ is a return completion.
            1. Let _return_ be ? GetMethod(_iterator_, *"return"*).
            1. If _return_ is *undefined*, then
              1. Set _value_ to _received_.[[Value]].
              1. If _generatorKind_ is ~async~, then
                1. Set _value_ to ? Await(_value_).
              1. Return ReturnCompletion(_value_).
            1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, « _received_.[[Value]] »).
            1. If _generatorKind_ is ~async~, set _innerReturnResult_ to ? Await(_innerReturnResult_).
            1. If _innerReturnResult_ is not an Object, throw a *TypeError* exception.
            1. Let _done_ be ? IteratorComplete(_innerReturnResult_).
            1. If _done_ is *true*, then
              1. Set _value_ to ? IteratorValue(_innerReturnResult_).
              1. Return ReturnCompletion(_value_).
            1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_))).
            1. Else, set _received_ to Completion(GeneratorYield(_innerReturnResult_)).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AsyncGeneratorDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
        [+Default] `async` [no LineTerminator here] `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorExpression :
        `async` [no LineTerminator here] `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorMethod[Yield, Await] :
        `async` [no LineTerminator here] `*` ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

      AsyncGeneratorBody :
        FunctionBody[+Yield, +Await]
    </emu-grammar>
    <emu-note>
      <p>|YieldExpression| and |AwaitExpression| cannot be used within the |FormalParameters| of an async generator function because any expressions that are part of |FormalParameters| are evaluated before the resulting AsyncGenerator is in a resumable state.</p>
    </emu-note>
    <emu-note>
      <p>Abstract operations relating to AsyncGenerators are defined in <emu-xref href="#sec-asyncgenerator-abstract-operations"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <ul>
        <li>It is a Syntax Error if HasDirectSuper of |AsyncGeneratorMethod| is *true*.</li>
        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>
      </ul>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>If IsStrict(|FormalParameters|) is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and IsStrict(|BindingIdentifier|) is *true*, it is a Syntax Error if the StringValue of |BindingIdentifier| is either *"eval"* or *"arguments"*.</li>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateAsyncGeneratorBody (
          _functionObject_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a throw completion or a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorPrototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »).
        1. Set _generator_.[[GeneratorBrand]] to ~empty~.
        1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.
        1. Perform AsyncGeneratorStart(_generator_, |FunctionBody|).
        1. Return ReturnCompletion(_generator_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionobject" oldids="sec-asyncgenerator-definitions-instantiatefunctionobject" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncGeneratorFunctionObject (
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _name_ be the StringValue of |BindingIdentifier|.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _F_.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorDeclaration : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, *"default"*).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _F_.
      </emu-alg>
      <emu-note>
        <p>An anonymous |AsyncGeneratorDeclaration| can only occur as part of an `export default` declaration.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncgeneratorfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncGeneratorFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to the StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncGeneratorExpression| can be referenced from inside the |AsyncGeneratorExpression|'s |AsyncGeneratorBody| to allow the generator code to call itself recursively. However, unlike in an |AsyncGeneratorDeclaration|, the |BindingIdentifier| in an |AsyncGeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncGeneratorExpression|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-definitions-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        AsyncGeneratorExpression : `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ClassDeclaration[Yield, Await, Default] :
        `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
        [+Default] `class` ClassTail[?Yield, ?Await]

      ClassExpression[Yield, Await] :
        `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

      ClassTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

      ClassHeritage[Yield, Await] :
        `extends` LeftHandSideExpression[?Yield, ?Await]

      ClassBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]

      ClassElementList[Yield, Await] :
        ClassElement[?Yield, ?Await]
        ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

      ClassElement[Yield, Await] :
        MethodDefinition[?Yield, ?Await]
        `static` MethodDefinition[?Yield, ?Await]
        FieldDefinition[?Yield, ?Await] `;`
        `static` FieldDefinition[?Yield, ?Await] `;`
        ClassStaticBlock
        `;`

      FieldDefinition[Yield, Await] :
        ClassElementName[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

      ClassElementName[Yield, Await] :
        PropertyName[?Yield, ?Await]
        PrivateIdentifier

      ClassStaticBlock :
        `static` `{` ClassStaticBlockBody `}`

      ClassStaticBlockBody :
        ClassStaticBlockStatementList

      ClassStaticBlockStatementList :
        StatementList[~Yield, +Await, ~Return]?
    </emu-grammar>
    <emu-note>
      <p>A class definition is always strict mode code.</p>
    </emu-note>

    <emu-clause id="sec-class-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody `}`</emu-grammar>
      <ul>
        <li>
          <p>It is a Syntax Error if |ClassHeritage| is not present and the following algorithm returns *true*:</p>
          <emu-alg>
            1. Let _constructor_ be the ConstructorMethod of |ClassBody|.
            1. If _constructor_ is ~empty~, return *false*.
            1. Return HasDirectSuper of _constructor_.
          </emu-alg>
        </li>
      </ul>
      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the PrototypePropertyNameList of |ClassElementList| contains more than one occurrence of *"constructor"*.
        </li>
        <li>
          It is a Syntax Error if the PrivateBoundIdentifiers of |ClassElementList| contains any duplicate entries, unless the name is used once for a getter and once for a setter and in no other entries, and the getter and setter are either both static or both non-static.
        </li>
      </ul>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the PropName of |MethodDefinition| is not *"constructor"* and HasDirectSuper of |MethodDefinition| is *true*.
        </li>
        <li>
          It is a Syntax Error if the PropName of |MethodDefinition| is *"constructor"* and SpecialMethod of |MethodDefinition| is *true*.
        </li>
      </ul>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if HasDirectSuper of |MethodDefinition| is *true*.
        </li>
        <li>
          It is a Syntax Error if the PropName of |MethodDefinition| is *"prototype"*.
        </li>
      </ul>

      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <ul>
        <li>It is a Syntax Error if the PropName of |FieldDefinition| is *"constructor"*.</li>
      </ul>

      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the PropName of |FieldDefinition| is either *"prototype"* or *"constructor"*.
        </li>
      </ul>

      <emu-grammar>
        FieldDefinition :
          ClassElementName Initializer?
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if |Initializer| is present and ContainsArguments of |Initializer| is *true*.</li>
        <li>It is a Syntax Error if |Initializer| is present and |Initializer| Contains |SuperCall| is *true*.</li>
      </ul>

      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <ul>
        <li>It is a Syntax Error if the StringValue of |PrivateIdentifier| is *"#constructor"*.</li>
      </ul>

      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |ClassStaticBlockStatementList| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |ClassStaticBlockStatementList| also occurs in the VarDeclaredNames of |ClassStaticBlockStatementList|.
        </li>
        <li>
          It is a Syntax Error if ContainsDuplicateLabels of |ClassStaticBlockStatementList| with argument « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedBreakTarget of |ClassStaticBlockStatementList| with argument « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedContinueTarget of |ClassStaticBlockStatementList| with arguments « » and « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsArguments of |ClassStaticBlockStatementList| is *true*.
        </li>
        <li>
          It is a Syntax Error if |ClassStaticBlockStatementList| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |ClassStaticBlockStatementList| Contains `await` is *true*.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementkind" type="sdo">
      <h1>Static Semantics: ClassElementKind ( ): ~constructor-method~, ~non-constructor-method~, or ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. If the PropName of |MethodDefinition| is *"constructor"*, return ~constructor-method~.
        1. Return ~non-constructor-method~.
      </emu-alg>
      <emu-grammar>
        ClassElement :
          `static` MethodDefinition
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. Return ~non-constructor-method~.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. Return ~non-constructor-method~.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. Return ~empty~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-constructormethod" type="sdo">
      <h1>Static Semantics: ConstructorMethod ( ): a |ClassElement| Parse Node or ~empty~</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. If the ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _head_ be the ConstructorMethod of |ClassElementList|.
        1. If _head_ is not ~empty~, return _head_.
        1. If the ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.
        1. Return ~empty~.
      </emu-alg>
      <emu-note>
        <p>Early Error rules ensure that there is only one method definition named *"constructor"* and that it is not an accessor property or generator definition.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-isstatic" type="sdo">
      <h1>Static Semantics: IsStatic ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ClassElement : `static` MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ClassElement : `static` FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
      <emu-grammar>ClassElement : `;`</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-nonconstructorelements" oldids="sec-static-semantics-nonconstructormethoddefinitions" type="sdo">
      <h1>Static Semantics: NonConstructorElements ( ): a List of |ClassElement| Parse Nodes</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. If the ClassElementKind of |ClassElement| is ~non-constructor-method~, then
          1. Return « |ClassElement| ».
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _list_ be the NonConstructorElements of |ClassElementList|.
        1. If the ClassElementKind of |ClassElement| is ~non-constructor-method~, then
          1. Append |ClassElement| to the end of _list_.
        1. Return _list_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-prototypepropertynamelist" type="sdo">
      <h1>Static Semantics: PrototypePropertyNameList ( ): a List of property keys</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. Let _propName_ be the PropName of |ClassElement|.
        1. If _propName_ is ~empty~, return a new empty List.
        1. If IsStatic of |ClassElement| is *true*, return a new empty List.
        1. Return « _propName_ ».
      </emu-alg>
      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. Let _list_ be the PrototypePropertyNameList of |ClassElementList|.
        1. Let _propName_ be the PropName of |ClassElement|.
        1. If _propName_ is ~empty~, return _list_.
        1. If IsStatic of |ClassElement| is *true*, return _list_.
        1. Return the list-concatenation of _list_ and « _propName_ ».
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-allprivateidentifiersvalid" type="sdo">
      <h1>
        Static Semantics: AllPrivateIdentifiersValid (
          _names_: a List of Strings,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <p>Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of AllPrivateIdentifiersValid:</p>
      <emu-alg>
        1. For each child node _child_ of this Parse Node, do
          1. If _child_ is an instance of a nonterminal, then
            1. If AllPrivateIdentifiersValid of _child_ with argument _names_ is *false*, return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. If _names_ contains the StringValue of |PrivateIdentifier|, then
          1. Return AllPrivateIdentifiersValid of |MemberExpression| with argument _names_.
        1. Return *false*.
      </emu-alg>

      <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. If _names_ contains the StringValue of |PrivateIdentifier|, then
          1. Return AllPrivateIdentifiersValid of |CallExpression| with argument _names_.
        1. Return *false*.
      </emu-alg>

      <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. If _names_ contains the StringValue of |PrivateIdentifier|, return *true*.
        1. Return *false*.
      </emu-alg>

      <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. If _names_ contains the StringValue of |PrivateIdentifier|, then
          1. Return AllPrivateIdentifiersValid of |OptionalChain| with argument _names_.
        1. Return *false*.
      </emu-alg>

      <emu-grammar>ClassBody : ClassElementList</emu-grammar>
      <emu-alg>
        1. Let _newNames_ be the list-concatenation of _names_ and the PrivateBoundIdentifiers of |ClassBody|.
        1. Return AllPrivateIdentifiersValid of |ClassElementList| with argument _newNames_.
      </emu-alg>

      <emu-grammar>RelationalExpression : PrivateIdentifier `in` ShiftExpression</emu-grammar>
      <emu-alg>
        1. If _names_ contains the StringValue of |PrivateIdentifier|, then
          1. Return AllPrivateIdentifiersValid of |ShiftExpression| with argument _names_.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-privateboundidentifiers" type="sdo">
      <h1>Static Semantics: PrivateBoundIdentifiers ( ): a List of Strings</h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. Return the PrivateBoundIdentifiers of |ClassElementName|.
      </emu-alg>

      <emu-grammar>
        ClassElementName : PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return a List whose sole element is the StringValue of |PrivateIdentifier|.
      </emu-alg>

      <emu-grammar>
        ClassElementName :
          PropertyName

        ClassElement :
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>

      <emu-grammar>
        ClassElementList : ClassElementList ClassElement
      </emu-grammar>
      <emu-alg>
        1. Let _names1_ be the PrivateBoundIdentifiers of |ClassElementList|.
        1. Let _names2_ be the PrivateBoundIdentifiers of |ClassElement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return the PrivateBoundIdentifiers of |ClassElementName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-containsarguments" type="sdo">
      <h1>Static Semantics: ContainsArguments ( ): a Boolean</h1>
      <dl class="header">
      </dl>

      <p>Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of ContainsArguments:</p>
      <emu-alg>
        1. For each child node _child_ of this Parse Node, do
          1. If _child_ is an instance of a nonterminal, then
            1. If ContainsArguments of _child_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>

      <emu-grammar>
        IdentifierReference : Identifier
      </emu-grammar>
      <emu-alg>
        1. If the StringValue of |Identifier| is *"arguments"*, return *true*.
        1. Return *false*.
      </emu-alg>

      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>

      <emu-grammar>
        MethodDefinition :
          ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
          `get` ClassElementName `(` `)` `{` FunctionBody `}`
          `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`

        GeneratorMethod :
          `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorMethod :
          `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncMethod :
          `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return ContainsArguments of |ClassElementName|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classfielddefinitionevaluation" type="sdo">
      <h1>
        Runtime Semantics: ClassFieldDefinitionEvaluation (
          _homeObject_: an Object,
        ): either a normal completion containing a ClassFieldDefinition Record or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. Let _name_ be ? Evaluation of |ClassElementName|.
        1. If |Initializer| is present, then
          1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
          1. Let _env_ be the LexicalEnvironment of the running execution context.
          1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
          1. Let _sourceText_ be the empty sequence of Unicode code points.
          1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).
          1. Perform MakeMethod(_initializer_, _homeObject_).
          1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.
        1. Else,
          1. Let _initializer_ be ~empty~.
        1. Return the ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.
      </emu-alg>
      <emu-note>
        The function created for _initializer_ is never directly accessible to ECMAScript code.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classstaticblockdefinitionevaluation" type="sdo">
      <h1>
        Runtime Semantics: ClassStaticBlockDefinitionEvaluation (
          _homeObject_: an Object,
        ): a ClassStaticBlockDefinition Record
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlock : `static` `{` ClassStaticBlockBody `}`</emu-grammar>
      <emu-alg>
        1. Let _lex_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the empty sequence of Unicode code points.
        1. Let _formalParameters_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
        1. [id="step-synthetic-class-static-block-fn"] Let _bodyFunction_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_).
        1. Perform MakeMethod(_bodyFunction_, _homeObject_).
        1. Return the ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ }.
      </emu-alg>
      <emu-note>The function _bodyFunction_ is never directly accessible to ECMAScript code.</emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateclassstaticblockbody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateClassStaticBlockBody (
          _functionObject_: an ECMAScript function object,
        ): a return completion or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassStaticBlockBody : ClassStaticBlockStatementList</emu-grammar>
      <emu-alg>
        1. Assert: _functionObject_ is a synthetic function created by ClassStaticBlockDefinitionEvaluation step <emu-xref href="#step-synthetic-class-static-block-fn"></emu-xref>.
        1. Perform ! FunctionDeclarationInstantiation(_functionObject_, « »).
        1. Perform ? Evaluation of |ClassStaticBlockStatementList|.
        1. Return ReturnCompletion(*undefined*).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-static-semantics-classelementevaluation" type="sdo">
      <h1>
        Runtime Semantics: ClassElementEvaluation (
          _object_: an Object,
        ): either a normal completion containing either a ClassFieldDefinition Record, a ClassStaticBlockDefinition Record, a PrivateElement, or ~unused~, or an abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-grammar>
        ClassElement :
          FieldDefinition `;`
          `static` FieldDefinition `;`
      </emu-grammar>
      <emu-alg>
        1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.
      </emu-alg>

      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.
      </emu-alg>

      <emu-grammar>ClassElement : ClassStaticBlock</emu-grammar>
      <emu-alg>
        1. Return the ClassStaticBlockDefinitionEvaluation of |ClassStaticBlock| with argument _object_.
      </emu-alg>

      <emu-grammar>
        ClassElement : `;`
      </emu-grammar>
      <emu-alg>
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        Runtime Semantics: ClassDefinitionEvaluation (
          _classBinding_: a String or *undefined*,
          _className_: a property key or a Private Name,
          _sourceText_: ECMAScript source text,
        ): either a normal completion containing a function object or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>For ease of specification, private methods and accessors are included alongside private fields in the [[PrivateElements]] slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.</p>
        <p>For example, an implementation could directly associate instance private methods with their corresponding Private Name and track, for each object, which class constructors have run with that object as their `this` value. Looking up an instance private method on an object then consists of checking that the class constructor which defines the method has been used to initialize the object, then returning the method associated with the Private Name.</p>
        <p>This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.</p>
      </emu-note>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).
        1. If _classBinding_ is not *undefined*, then
          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |ClassBody| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classEnv_.
          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.
          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(? _superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if IsConstructor(_superclass_) is *false*, then
            1. Throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).
        1. If |ClassBody| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be the ConstructorMethod of |ClassBody|.
        1. Set the running execution context's LexicalEnvironment to _classEnv_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If _constructor_ is ~empty~, then
          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
            1. If NewTarget is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be the active function object.
            1. If _F_.[[ConstructorKind]] is ~derived~, then
              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the %Symbol.iterator% method on `%Array.prototype%`, this function does not.
              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().
              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).
            1. Else,
              1. NOTE: This branch behaves similarly to `constructor() {}`.
              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*).
            1. Perform ? InitializeInstanceElements(_result_, _F_).
            1. Return NormalCompletion(_result_).
          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).
        1. Else,
          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.
          1. Let _F_ be _constructorInfo_.[[Closure]].
          1. Perform MakeClassConstructor(_F_).
          1. Perform SetFunctionName(_F_, _className_).
        1. Set _F_.[[SourceText]] to _sourceText_.
        1. Perform MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Perform ! DefineMethodProperty(_proto_, *"constructor"*, _F_, *false*).
        1. If |ClassBody| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be the NonConstructorElements of |ClassBody|.
        1. Let _instancePrivateMethods_ be a new empty List.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. For each |ClassElement| _e_ of _elements_, do
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).
          1. Else,
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _element_.
          1. Set _element_ to ! _element_.
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.
            1. Else, let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then
              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.
              1. Replace _pe_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).
        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingclassdeclarationevaluation" type="sdo">
      <h1>Runtime Semantics: BindingClassDeclarationEvaluation ( ): either a normal completion containing a function object or an abrupt completion</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Let _className_ be the StringValue of |BindingIdentifier|.
        1. Let _sourceText_ be the source text matched by |ClassDeclaration|.
        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_, _className_, and _sourceText_.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Perform ? InitializeBoundName(_className_, _value_, _env_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Let _sourceText_ be the source text matched by |ClassDeclaration|.
        1. Return ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined*, *"default"*, and _sourceText_.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and establishing its binding is handled as part of the evaluation action for that production. See <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-class-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Perform ? BindingClassDeclarationEvaluation of this |ClassDeclaration|.
        1. Return ~empty~.
      </emu-alg>
      <emu-note>
        <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and is never directly evaluated.</p>
      </emu-note>
      <emu-grammar>ClassExpression : `class` ClassTail</emu-grammar>
      <emu-alg>
        1. Let _sourceText_ be the source text matched by |ClassExpression|.
        1. Return ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined*, *""*, and _sourceText_.
      </emu-alg>
      <emu-grammar>ClassExpression : `class` BindingIdentifier ClassTail</emu-grammar>
      <emu-alg>
        1. Let _className_ be the StringValue of |BindingIdentifier|.
        1. Let _sourceText_ be the source text matched by |ClassExpression|.
        1. Return ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_, _className_, and _sourceText_.
      </emu-alg>
      <emu-grammar>ClassElementName : PrivateIdentifier</emu-grammar>
      <emu-alg>
        1. Let _privateIdentifier_ be the StringValue of |PrivateIdentifier|.
        1. Let _privateEnvRec_ be the running execution context's PrivateEnvironment.
        1. Let _names_ be _privateEnvRec_.[[Names]].
        1. Assert: Exactly one element of _names_ is a Private Name whose [[Description]] is _privateIdentifier_.
        1. Let _privateName_ be the Private Name in _names_ whose [[Description]] is _privateIdentifier_.
        1. Return _privateName_.
      </emu-alg>
      <emu-grammar>ClassStaticBlockStatementList : [empty]</emu-grammar>
      <emu-alg>
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AsyncFunctionDeclaration[Yield, Await, Default] :
        `async` [no LineTerminator here] `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
        [+Default] `async` [no LineTerminator here] `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionExpression :
        `async` [no LineTerminator here] `function` BindingIdentifier[~Yield, +Await]? `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncMethod[Yield, Await] :
        `async` [no LineTerminator here] ClassElementName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

      AsyncFunctionBody :
        FunctionBody[~Yield, +Await]

      AwaitExpression[Yield] :
        `await` UnaryExpression[?Yield, +Await]
    </emu-grammar>

    <emu-note>
      <p>`await` is parsed as a keyword of an |AwaitExpression| when the <sub>[Await]</sub> parameter is present. The <sub>[Await]</sub> parameter is present in the top level of the following contexts, although the parameter may be absent in some contexts depending on the nonterminals, such as |FunctionBody|:</p>
      <ul>
        <li>In an |AsyncFunctionBody|.</li>
        <li>In the |FormalParameters| of an |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, or |AsyncGeneratorExpression|. |AwaitExpression| in this position is a Syntax error via static semantics.</li>
        <li>In a |Module|.</li>
      </ul>
      <p>When |Script| is the syntactic goal symbol, `await` may be parsed as an identifier when the <sub>[Await]</sub> parameter is absent. This includes the following contexts:</p>
      <ul>
        <li>Anywhere outside of an |AsyncFunctionBody| or |FormalParameters| of an |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |AsyncGeneratorDeclaration|, or |AsyncGeneratorExpression|.</li>
        <li>In the |BindingIdentifier| of a |FunctionExpression|, |GeneratorExpression|, or |AsyncGeneratorExpression|.</li>
      </ul>
    </emu-note>

    <emu-note>
      <p>Unlike |YieldExpression|, it is a Syntax Error to omit the operand of an |AwaitExpression|. You must await something.</p>
    </emu-note>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |UniqueFormalParameters| is *false*.</li>
        <li>It is a Syntax Error if HasDirectSuper of |AsyncMethod| is *true*.</li>
        <li>It is a Syntax Error if |UniqueFormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |UniqueFormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>
      </ul>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>If IsStrict(|FormalParameters|) is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and IsStrict(|BindingIdentifier|) is *true*, it is a Syntax Error if the StringValue of |BindingIdentifier| is either *"eval"* or *"arguments"*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionobject" oldids="sec-async-function-definitions-InstantiateFunctionObject" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncFunctionObject (
          _env_: an Environment Record,
          _privateEnv_: a PrivateEnvironment Record or *null*,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _name_ be the StringValue of |BindingIdentifier|.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, _name_).
        1. Return _F_.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionDeclaration : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.
        1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_F_, *"default"*).
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncFunctionExpression : `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Assert: _name_ is not present.
        1. Set _name_ to the StringValue of |BindingIdentifier|.
        1. Let _outerEnv_ be the LexicalEnvironment of the running execution context.
        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).
        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).
        1. Return _closure_.
      </emu-alg>
      <emu-note>
        <p>The |BindingIdentifier| in an |AsyncFunctionExpression| can be referenced from inside the |AsyncFunctionExpression|'s |AsyncFunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |AsyncFunctionExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncFunctionExpression|.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncfunctionbody" oldids="sec-async-function-definitions-EvaluateBody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateAsyncFunctionBody (
          _functionObject_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncFunctionBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. Let _completion_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).
        1. If _completion_ is an abrupt completion, then
          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »).
        1. Else,
          1. Perform AsyncFunctionStart(_promiseCapability_, |FunctionBody|).
        1. Return ReturnCompletion(_promiseCapability_.[[Promise]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.
      </emu-alg>
      <emu-grammar>
        AwaitExpression : `await` UnaryExpression
      </emu-grammar>
      <emu-alg>
        1. Let _exprRef_ be ? Evaluation of |UnaryExpression|.
        1. Let _value_ be ? GetValue(_exprRef_).
        1. Return ? Await(_value_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-arrow-function-definitions">
    <h1>Async Arrow Function Definitions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      AsyncArrowFunction[In, Yield, Await] :
        `async` [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] `=>` AsyncConciseBody[?In]
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] [no LineTerminator here] `=>` AsyncConciseBody[?In] #callcover

      AsyncConciseBody[In] :
        [lookahead != `{`] ExpressionBody[?In, +Await]
        `{` AsyncFunctionBody `}`

      AsyncArrowBindingIdentifier[Yield] :
        BindingIdentifier[?Yield, +Await]

      CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
        MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    </emu-grammar>
    <h2>Supplemental Syntax</h2>
    <p>
      When processing an instance of the production<br>
      <emu-grammar>AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody</emu-grammar><br>
      the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:
    </p>

    <emu-grammar type="definition">
      AsyncArrowHead :
        `async` [no LineTerminator here] ArrowFormalParameters[~Yield, +Await]
    </emu-grammar>

    <emu-clause id="sec-async-arrow-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if any element of the BoundNames of |AsyncArrowBindingIdentifier| also occurs in the LexicallyDeclaredNames of |AsyncConciseBody|.</li>
      </ul>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <ul>
        <li>|CoverCallExpressionAndAsyncArrowHead| must cover an |AsyncArrowHead|.</li>
        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |CoverCallExpressionAndAsyncArrowHead| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |CoverCallExpressionAndAsyncArrowHead| also occurs in the LexicallyDeclaredNames of |AsyncConciseBody|.</li>
        <li>It is a Syntax Error if AsyncConciseBodyContainsUseStrict of |AsyncConciseBody| is *true* and IsSimpleParameterList of |CoverCallExpressionAndAsyncArrowHead| is *false*.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-static-semantics-asyncconcisebodycontainsusestrict" oldids="sec-async-arrow-function-definitions-static-semantics-containsusestrict" type="sdo">
      <h1>Static Semantics: AsyncConciseBodyContainsUseStrict ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>AsyncConciseBody : ExpressionBody</emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>AsyncConciseBody : `{` AsyncFunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return FunctionBodyContainsUseStrict of |AsyncFunctionBody|.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-evaluateasyncconcisebody" oldids="sec-async-arrow-function-definitions-EvaluateBody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateAsyncConciseBody (
          _functionObject_: an ECMAScript function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncConciseBody : ExpressionBody
      </emu-grammar>
      <emu-alg>
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. Let _completion_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).
        1. If _completion_ is an abrupt completion, then
          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _completion_.[[Value]] »).
        1. Else,
          1. Perform AsyncFunctionStart(_promiseCapability_, |ExpressionBody|).
        1. Return ReturnCompletion(_promiseCapability_.[[Promise]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-instantiateasyncarrowfunctionexpression" type="sdo">
      <h1>
        Runtime Semantics: InstantiateAsyncArrowFunctionExpression (
          optional _name_: a property key or a Private Name,
        ): an ECMAScript function object
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.
        1. Let _parameters_ be |AsyncArrowBindingIdentifier|.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. If _name_ is not present, set _name_ to *""*.
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. Let _parameters_ be the |ArrowFormalParameters| of _head_.
        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).
        1. Perform SetFunctionName(_closure_, _name_).
        1. Return _closure_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-async-arrow-function-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        AsyncArrowFunction :
          `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
          CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-tail-position-calls">
    <h1>Tail Position Calls</h1>

    <emu-clause id="sec-isintailposition" type="abstract operation">
      <h1>
        Static Semantics: IsInTailPosition (
          _call_: a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If IsStrict(_call_) is *false*, return *false*.
        1. If _call_ is not contained within a |FunctionBody|, a |ConciseBody|, or an |AsyncConciseBody|, return *false*.
        1. Let _body_ be the |FunctionBody|, |ConciseBody|, or |AsyncConciseBody| that most closely contains _call_.
        1. If _body_ is the |FunctionBody| of a |GeneratorBody|, return *false*.
        1. If _body_ is the |FunctionBody| of an |AsyncFunctionBody|, return *false*.
        1. If _body_ is the |FunctionBody| of an |AsyncGeneratorBody|, return *false*.
        1. If _body_ is an |AsyncConciseBody|, return *false*.
        1. Return the result of HasCallInTailPosition of _body_ with argument _call_.
      </emu-alg>
      <emu-note>
        <p>Tail Position calls are only defined in strict mode code because of a common non-standard language extension (see <emu-xref href="#sec-addrestrictedfunctionproperties"></emu-xref>) that enables observation of the chain of caller contexts.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-static-semantics-hascallintailposition" type="sdo" oldids="sec-statement-rules,sec-expression-rules">
      <h1>
        Static Semantics: HasCallInTailPosition (
          _call_: a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-note>
        <p>_call_ is a Parse Node that represents a specific range of source text. When the following algorithms compare _call_ to another Parse Node, it is a test of whether they represent the same source text.</p>
      </emu-note>
      <emu-note>
        <p>A potential tail position call that is immediately followed by return GetValue of the call result is also a possible tail position call. A function call cannot return a Reference Record, so such a GetValue operation will always return the same value as the actual function call result.</p>
      </emu-note>

      <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.
      </emu-alg>
      <emu-grammar>
        FunctionStatementList :
          [empty]

        StatementListItem :
          Declaration

        Statement :
          VariableStatement
          EmptyStatement
          ExpressionStatement
          ContinueStatement
          BreakStatement
          ThrowStatement
          DebuggerStatement

        Block :
          `{` `}`

        ReturnStatement :
          `return` `;`

        LabelledItem :
          FunctionDeclaration

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
          `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
          `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement

        CaseBlock :
          `{` `}`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>IfStatement : `if` `(` Expression `)` Statement `else` Statement</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Return HasCallInTailPosition of the second |Statement| with argument _call_.
      </emu-alg>
      <emu-grammar>
        IfStatement :
          `if` `(` Expression `)` Statement

        DoWhileStatement :
          `do` Statement `while` `(` Expression `)` `;`

        WhileStatement :
          `while` `(` Expression `)` Statement

        ForStatement :
          `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
          `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
          `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement

        ForInOfStatement :
          `for` `(` LeftHandSideExpression `in` Expression `)` Statement
          `for` `(` `var` ForBinding `in` Expression `)` Statement
          `for` `(` ForDeclaration `in` Expression `)` Statement

        WithStatement :
          `with` `(` Expression `)` Statement
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Statement| with argument _call_.
      </emu-alg>
      <emu-grammar>
        LabelledStatement :
          LabelIdentifier `:` LabelledItem
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.
      </emu-alg>
      <emu-grammar>ReturnStatement : `return` Expression `;`</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Expression| with argument _call_.
      </emu-alg>
      <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.
      </emu-alg>
      <emu-grammar>CaseBlock : `{` CaseClauses? DefaultClause CaseClauses? `}`</emu-grammar>
      <emu-alg>
        1. Let _has_ be *false*.
        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.
        1. Return _has_.
      </emu-alg>
      <emu-grammar>CaseClauses : CaseClauses CaseClause</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Return HasCallInTailPosition of |CaseClause| with argument _call_.
      </emu-alg>
      <emu-grammar>
        CaseClause : `case` Expression `:` StatementList?

        DefaultClause : `default` `:` StatementList?
      </emu-grammar>
      <emu-alg>
        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>TryStatement : `try` Block Catch</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Catch| with argument _call_.
      </emu-alg>
      <emu-grammar>
        TryStatement :
          `try` Block Finally
          `try` Block Catch Finally
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Finally| with argument _call_.
      </emu-alg>
      <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Block| with argument _call_.
      </emu-alg>

      <emu-grammar>
        AssignmentExpression :
          YieldExpression
          ArrowFunction
          AsyncArrowFunction
          LeftHandSideExpression `=` AssignmentExpression
          LeftHandSideExpression AssignmentOperator AssignmentExpression
          LeftHandSideExpression `&amp;&amp;=` AssignmentExpression
          LeftHandSideExpression `||=` AssignmentExpression
          LeftHandSideExpression `??=` AssignmentExpression

        BitwiseANDExpression :
          BitwiseANDExpression `&amp;` EqualityExpression

        BitwiseXORExpression :
          BitwiseXORExpression `^` BitwiseANDExpression

        BitwiseORExpression :
          BitwiseORExpression `|` BitwiseXORExpression

        EqualityExpression :
          EqualityExpression `==` RelationalExpression
          EqualityExpression `!=` RelationalExpression
          EqualityExpression `===` RelationalExpression
          EqualityExpression `!==` RelationalExpression

        RelationalExpression :
          RelationalExpression `&lt;` ShiftExpression
          RelationalExpression `&gt;` ShiftExpression
          RelationalExpression `&lt;=` ShiftExpression
          RelationalExpression `&gt;=` ShiftExpression
          RelationalExpression `instanceof` ShiftExpression
          RelationalExpression `in` ShiftExpression
          PrivateIdentifier `in` ShiftExpression

        ShiftExpression :
          ShiftExpression `&lt;&lt;` AdditiveExpression
          ShiftExpression `&gt;&gt;` AdditiveExpression
          ShiftExpression `&gt;&gt;&gt;` AdditiveExpression

        AdditiveExpression :
          AdditiveExpression `+` MultiplicativeExpression
          AdditiveExpression `-` MultiplicativeExpression

        MultiplicativeExpression :
          MultiplicativeExpression MultiplicativeOperator ExponentiationExpression

        ExponentiationExpression :
          UpdateExpression `**` ExponentiationExpression

        UpdateExpression :
          LeftHandSideExpression `++`
          LeftHandSideExpression `--`
          `++` UnaryExpression
          `--` UnaryExpression

        UnaryExpression :
          `delete` UnaryExpression
          `void` UnaryExpression
          `typeof` UnaryExpression
          `+` UnaryExpression
          `-` UnaryExpression
          `~` UnaryExpression
          `!` UnaryExpression
          AwaitExpression

        CallExpression :
          SuperCall
          ImportCall
          CallExpression `[` Expression `]`
          CallExpression `.` IdentifierName
          CallExpression `.` PrivateIdentifier

        NewExpression :
          `new` NewExpression

        MemberExpression :
          MemberExpression `[` Expression `]`
          MemberExpression `.` IdentifierName
          SuperProperty
          MetaProperty
          `new` MemberExpression Arguments
          MemberExpression `.` PrivateIdentifier

        PrimaryExpression :
          `this`
          IdentifierReference
          Literal
          ArrayLiteral
          ObjectLiteral
          FunctionExpression
          ClassExpression
          GeneratorExpression
          AsyncFunctionExpression
          AsyncGeneratorExpression
          RegularExpressionLiteral
          TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        Expression :
          AssignmentExpression
          Expression `,` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>ConditionalExpression : ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression</emu-grammar>
      <emu-alg>
        1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.
        1. If _has_ is *true*, return *true*.
        1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>LogicalANDExpression : LogicalANDExpression `&amp;&amp;` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>LogicalORExpression : LogicalORExpression `||` LogicalANDExpression</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>CoalesceExpression : CoalesceExpressionHead `??` BitwiseORExpression</emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.
      </emu-alg>
      <emu-grammar>
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          CallExpression Arguments
          CallExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. If this |CallExpression| is _call_, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        OptionalExpression :
          MemberExpression OptionalChain
          CallExpression OptionalChain
          OptionalExpression OptionalChain
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` `[` Expression `]`
          `?.` IdentifierName
          `?.` PrivateIdentifier
          OptionalChain `[` Expression `]`
          OptionalChain `.` IdentifierName
          OptionalChain `.` PrivateIdentifier
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        OptionalChain :
          `?.` Arguments
          OptionalChain Arguments
      </emu-grammar>
      <emu-alg>
        1. If this |OptionalChain| is _call_, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        MemberExpression :
          MemberExpression TemplateLiteral
      </emu-grammar>
      <emu-alg>
        1. If this |MemberExpression| is _call_, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>PrimaryExpression : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
      <emu-alg>
        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.
        1. Return HasCallInTailPosition of _expr_ with argument _call_.
      </emu-alg>
      <emu-grammar>
        ParenthesizedExpression :
          `(` Expression `)`
      </emu-grammar>
      <emu-alg>
        1. Return HasCallInTailPosition of |Expression| with argument _call_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-preparefortailcall" type="abstract operation">
      <h1>PrepareForTailCall ( ): ~unused~</h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: The current execution context will not subsequently be used for the evaluation of any ECMAScript code or built-in functions. The invocation of Call subsequent to the invocation of this abstract operation will create and push a new execution context before performing any such evaluation.
        1. Discard all resources associated with the current execution context.
        1. Return ~unused~.
      </emu-alg>
      <p>A tail position call must either release any transient internal resources associated with the currently executing function execution context before invoking the target function or reuse those resources in support of the target function.</p>
      <emu-note>
        <p>For example, a tail position call should only grow an implementation's activation record stack by the amount that the size of the target function's activation record exceeds the size of the calling function's activation record. If the target function's activation record is smaller, then the total size of the stack should decrease.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Script :
        ScriptBody?

      ScriptBody :
        StatementList[~Yield, ~Await, ~Return]
    </emu-grammar>

    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>Script : ScriptBody</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if the LexicallyDeclaredNames of |ScriptBody| contains any duplicate entries.
        </li>
        <li>
          It is a Syntax Error if any element of the LexicallyDeclaredNames of |ScriptBody| also occurs in the VarDeclaredNames of |ScriptBody|.
        </li>
      </ul>
      <emu-grammar>ScriptBody : StatementList</emu-grammar>
      <ul>
        <li>
          It is a Syntax Error if |StatementList| Contains `super` unless the source text containing `super` is eval code that is being processed by a direct eval. Additional early error rules for `super` within direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
        </li>
        <li>
          It is a Syntax Error if |StatementList| Contains |NewTarget| unless the source text containing |NewTarget| is eval code that is being processed by a direct eval. Additional early error rules for |NewTarget| in direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
        </li>
        <li>
          It is a Syntax Error if ContainsDuplicateLabels of |StatementList| with argument « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedBreakTarget of |StatementList| with argument « » is *true*.
        </li>
        <li>
          It is a Syntax Error if ContainsUndefinedContinueTarget of |StatementList| with arguments « » and « » is *true*.
        </li>
        <li>
          It is a Syntax Error if AllPrivateIdentifiersValid of |StatementList| with argument « » is *false* unless the source text containing |ScriptBody| is eval code that is being processed by a direct eval.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-scriptisstrict" oldids="sec-static-semantics-isstrict" type="sdo">
      <h1>Static Semantics: ScriptIsStrict ( ): a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Script : ScriptBody?</emu-grammar>
      <emu-alg>
        1. If |ScriptBody| is present and the Directive Prologue of |ScriptBody| contains a Use Strict Directive, return *true*; otherwise return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-semantics-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>Script : [empty]</emu-grammar>
      <emu-alg>
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-script-records">
      <h1>Script Records</h1>

      <p>A <dfn id="script-record" variants="Script Records">Script Record</dfn> encapsulates information about a script being evaluated. Each script record contains the fields listed in <emu-xref href="#table-script-records"></emu-xref>.</p>

      <emu-table id="table-script-records" caption="Script Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              a Realm Record
            </td>
            <td>
              The realm within which this script was created.
            </td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              a |Script| Parse Node
            </td>
            <td>
              The result of parsing the source text of this script.
            </td>
          </tr>
          <tr>
            <td>
              [[LoadedModules]]
            </td>
            <td>
              a List of LoadedModuleRequest Records
            </td>
            <td>
              A map from the specifier strings imported by this script to the resolved Module Record. The list does not contain two different Records _r1_ and _r2_ such that ModuleRequestsEqual(_r1_, _r2_) is *true*.
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td>
              Field reserved for use by host environments that need to associate additional information with a script.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript source text,
          _realm_: a Realm Record,
          _hostDefined_: anything,
        ): a Script Record or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Script Record based upon the result of parsing _sourceText_ as a |Script|.</dd>
      </dl>

      <emu-alg>
        1. Let _script_ be ParseText(_sourceText_, |Script|).
        1. If _script_ is a List of errors, return _script_.
        1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }.
      </emu-alg>
      <emu-note>
        <p>An implementation may parse script source text and analyse it for Early Error conditions prior to evaluation of ParseScript for that script source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseScript upon that source text.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-scriptevaluation" type="abstract operation">
      <h1>
        ScriptEvaluation (
          _scriptRecord_: a Script Record,
        ): either a normal completion containing an ECMAScript language value or an abrupt completion
      </h1>
      <dl class="header">
      </dl>

      <emu-alg>
        1. Let _globalEnv_ be _scriptRecord_.[[Realm]].[[GlobalEnv]].
        1. Let _scriptContext_ be a new ECMAScript code execution context.
        1. Set the Function of _scriptContext_ to *null*.
        1. Set the Realm of _scriptContext_ to _scriptRecord_.[[Realm]].
        1. Set the ScriptOrModule of _scriptContext_ to _scriptRecord_.
        1. Set the VariableEnvironment of _scriptContext_ to _globalEnv_.
        1. Set the LexicalEnvironment of _scriptContext_ to _globalEnv_.
        1. Set the PrivateEnvironment of _scriptContext_ to *null*.
        1. Suspend the running execution context.
        1. Push _scriptContext_ onto the execution context stack; _scriptContext_ is now the running execution context.
        1. Let _script_ be _scriptRecord_.[[ECMAScriptCode]].
        1. Let _result_ be Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_)).
        1. If _result_ is a normal completion, then
          1. Set _result_ to Completion(Evaluation of _script_).
          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then
            1. Set _result_ to NormalCompletion(*undefined*).
        1. Suspend _scriptContext_ and remove it from the execution context stack.
        1. Assert: The execution context stack is not empty.
        1. Resume the context that is now on the top of the execution context stack as the running execution context.
        1. Return ? _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-globaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-globaldeclarationinstantiation">
      <h1>
        GlobalDeclarationInstantiation (
          _script_: a |Script| Parse Node,
          _env_: a Global Environment Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>_script_ is the |Script| for which the execution context is being established. _env_ is the global environment in which bindings are to be created.</dd>
      </dl>
      <emu-note>
        <p>When an execution context is established for evaluating scripts, declarations are instantiated in the current global environment. Each global binding declared in the code is instantiated.</p>
      </emu-note>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.
        1. Let _varNames_ be the VarDeclaredNames of _script_.
        1. For each element _name_ of _lexNames_, do
          1. If HasLexicalDeclaration(_env_, _name_) is *true*, throw a *SyntaxError* exception.
          1. Let _hasRestrictedGlobal_ be ? HasRestrictedGlobalProperty(_env_, _name_).
          1. NOTE: Global `var` and `function` bindings (except those that are introduced by non-strict direct eval) are non-configurable and are therefore restricted global properties.
          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.
        1. For each element _name_ of _varNames_, do
          1. If HasLexicalDeclaration(_env_, _name_) is *true*, throw a *SyntaxError* exception.
        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.
        1. Let _functionsToInitialize_ be a new empty List.
        1. Let _declaredFunctionNames_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, in reverse List order, do
          1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
            1. Let _fn_ be the sole element of the BoundNames of _d_.
            1. If _declaredFunctionNames_ does not contain _fn_, then
              1. Let _fnDefinable_ be ? CanDeclareGlobalFunction(_env_, _fn_).
              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
              1. Append _fn_ to _declaredFunctionNames_.
              1. Insert _d_ as the first element of _functionsToInitialize_.
        1. Let _declaredVarNames_ be a new empty List.
        1. For each element _d_ of _varDeclarations_, do
          1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
            1. For each String _vn_ of the BoundNames of _d_, do
              1. If _declaredFunctionNames_ does not contain _vn_, then
                1. Let _vnDefinable_ be ? CanDeclareGlobalVar(_env_, _vn_).
                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                1. If _declaredVarNames_ does not contain _vn_, then
                  1. Append _vn_ to _declaredVarNames_.
        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.
        1. [id="step-globaldeclarationinstantiation-web-compat-insertion-point", normative-optional] If the host is a web browser or otherwise supports <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>, then
          1. Let _strict_ be ScriptIsStrict of _script_.
          1. If _strict_ is *false*, then
            1. Let _declaredFunctionOrVarNames_ be the list-concatenation of _declaredFunctionNames_ and _declaredVarNames_.
            1. For each |FunctionDeclaration| _f_ that is directly contained in the |StatementList| of any |Block|, |CaseClause|, or |DefaultClause| _x_ such that _script_ Contains _x_ is *true*, do
              1. Let _F_ be the StringValue of the |BindingIdentifier| of _f_.
              1. If replacing the |FunctionDeclaration| _f_ with a |VariableStatement| that has _F_ as a |BindingIdentifier| would not produce any Early Errors for _script_, then
                1. If HasLexicalDeclaration(_env_, _F_) is *false*, then
                  1. Let _fnDefinable_ be ? CanDeclareGlobalVar(_env_, _F_).
                  1. If _fnDefinable_ is *true*, then
                    1. NOTE: A var binding for _F_ is only instantiated here if it is neither a VarDeclaredName nor the name of another |FunctionDeclaration|.
                    1. If _declaredFunctionOrVarNames_ does not contain _F_, then
                      1. Perform ? CreateGlobalVarBinding(_env_, _F_, *false*).
                      1. Append _F_ to _declaredFunctionOrVarNames_.
                    1. [id="step-globaldeclarationinstantiation-alt-funcdecl-eval"] When the |FunctionDeclaration| _f_ is evaluated, perform the following steps in place of the |FunctionDeclaration| Evaluation algorithm provided in <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>:
                      1. Let _gEnv_ be the running execution context's VariableEnvironment.
                      1. Let _bEnv_ be the running execution context's LexicalEnvironment.
                      1. Let _fObj_ be ! _bEnv_.GetBindingValue(_F_, *false*).
                      1. Perform ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*).
                      1. Return ~unused~.
        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.
        1. Let _privateEnv_ be *null*.
        1. For each element _d_ of _lexDeclarations_, do
          1. NOTE: Lexically declared names are only instantiated here but not initialized.
          1. For each element _dn_ of the BoundNames of _d_, do
            1. If IsConstantDeclaration of _d_ is *true*, then
              1. Perform ? <emu-meta effects="user-code">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*).
            1. Else,
              1. Perform ? <emu-meta effects="user-code">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*).
        1. For each Parse Node _f_ of _functionsToInitialize_, do
          1. Let _fn_ be the sole element of the BoundNames of _f_.
          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _env_ and _privateEnv_.
          1. Perform ? <emu-meta effects="user-code">CreateGlobalFunctionBinding</emu-meta>(_env_, _fn_, _fo_, *false*).
        1. For each String _vn_ of _declaredVarNames_, do
          1. Perform ? <emu-meta effects="user-code">CreateGlobalVarBinding</emu-meta>(_env_, _vn_, *false*).
        1. Return ~unused~.
      </emu-alg>
      <emu-note>
        <p>Early errors specified in <emu-xref href="#sec-scripts-static-semantics-early-errors"></emu-xref> prevent name conflicts between function/var declarations and let/const/class declarations as well as redeclaration of let/const/class bindings for declaration contained within a single |Script|. However, such conflicts and redeclarations that span more than one |Script| are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the global object is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an abrupt completion and some global declarations not being instantiated. If this occurs, the code for the |Script| is not evaluated.</p>
        <p>Unlike explicit var or function declarations, properties that are directly created on the global object result in global bindings that may be shadowed by let/const/class declarations.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      Module :
        ModuleBody?

      ModuleBody :
        ModuleItemList

      ModuleItemList :
        ModuleItem
        ModuleItemList ModuleItem

      ModuleItem :
        ImportDeclaration
        ExportDeclaration
        StatementListItem[~Yield, +Await, ~Return]

      ModuleExportName :
        IdentifierName
        StringLiteral
    </emu-grammar>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the LexicallyDeclaredNames of |ModuleItemList| also occurs in the VarDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if the ExportedNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the ExportedBindings of |ModuleItemList| does not also occur in either the VarDeclaredNames of |ModuleItemList|, or the LexicallyDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains `super`.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains |NewTarget|.
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |ModuleItemList| with argument « » is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |ModuleItemList| with argument « » is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |ModuleItemList| with arguments « » and « » is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |ModuleItemList| with argument « » is *false*.
          </li>
        </ul>
        <emu-note>
          <p>The duplicate ExportedNames rule implies that multiple `export default` |ExportDeclaration| items within a |ModuleBody| is a Syntax Error. Additional error conditions relating to conflicting or duplicate declarations are checked during module linking prior to evaluation of a |Module|. If any such errors are detected the |Module| is not evaluated.</p>
        </emu-note>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <ul>
          <li>It is a Syntax Error if IsStringWellFormedUnicode(SV of |StringLiteral|) is *false*.</li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-importedlocalnames" type="abstract operation">
        <h1>
          Static Semantics: ImportedLocalNames (
            _importEntries_: a List of ImportEntry Records,
          ): a List of Strings
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It creates a List of all of the local name bindings defined by _importEntries_.</dd>
        </dl>
        <emu-alg>
          1. Let _localNames_ be a new empty List.
          1. For each ImportEntry Record _i_ of _importEntries_, do
            1. Append _i_.[[LocalName]] to _localNames_.
          1. Return _localNames_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-modulerequest-record">
        <h1>ModuleRequest Records</h1>

        <p>A <dfn id="modulerequest-record" variants="ModuleRequest Records">ModuleRequest Record</dfn> represents the request to import a module with given import attributes. It consists of the following fields:</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                a String
              </td>
              <td>
                The module specifier
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                a List of ImportAttribute Records
              </td>
              <td>
                The import attributes
              </td>
            </tr>
          </table>
        </emu-table>

        <p>A <dfn id="loadedmodulerequest-record" variants="LoadedModuleRequest Records">LoadedModuleRequest Record</dfn> represents the request to import a module together with the resulting Module Record. It consists of the same fields defined in table <emu-xref href="#table-modulerequest-fields"></emu-xref>, with the addition of [[Module]]:</p>
        <emu-table id="table-loadedmodulerequest-fields" caption="LoadedModuleRequest Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Specifier]]
              </td>
              <td>
                a String
              </td>
              <td>
                The module specifier
              </td>
            </tr>
            <tr>
              <td>
                [[Attributes]]
              </td>
              <td>
                a List of ImportAttribute Records
              </td>
              <td>
                The import attributes
              </td>
            </tr>
            <tr>
              <td>
                [[Module]]
              </td>
              <td>
                a Module Record
              </td>
              <td>
                The loaded module corresponding to this module request
              </td>
            </tr>
          </table>
        </emu-table>

        <p>An <dfn id="importattribute-record" variants="ImportAttribute Records">ImportAttribute Record</dfn> consists of the following fields:</p>
        <emu-table id="table-importattribute-fields" caption="ImportAttribute Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                a String
              </td>
              <td>
                The attribute key
              </td>
            </tr>
            <tr>
              <td>
                [[Value]]
              </td>
              <td>
                a String
              </td>
              <td>
                The attribute value
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ModuleRequestsEqual" type="abstract operation">
          <h1>
            ModuleRequestsEqual (
              _left_: a ModuleRequest Record or a LoadedModuleRequest Record,
              _right_: a ModuleRequest Record or a LoadedModuleRequest Record,
            ): a Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. If _left_.[[Specifier]] is not _right_.[[Specifier]], return *false*.
            1. Let _leftAttrs_ be _left_.[[Attributes]].
            1. Let _rightAttrs_ be _right_.[[Attributes]].
            1. Let _leftAttrsCount_ be the number of elements in _leftAttrs_.
            1. Let _rightAttrsCount_ be the number of elements in _rightAttrs_.
            1. If _leftAttrsCount_ ≠ _rightAttrsCount_, return *false*.
            1. For each ImportAttribute Record _l_ of _leftAttrs_, do
              1. If _rightAttrs_ does not contain an ImportAttribute Record _r_ such that _l_.[[Key]] is _r_.[[Key]] and _l_.[[Value]] is _r_.[[Value]], return *false*.
            1. Return *true*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-static-semantics-modulerequests" oldids="sec-module-semantics-static-semantics-modulerequests,sec-imports-static-semantics-modulerequests,sec-exports-static-semantics-modulerequests" type="sdo">
        <h1>Static Semantics: ModuleRequests ( ): a List of ModuleRequest Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return the ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _requests_ be the ModuleRequests of |ModuleItemList|.
          1. Let _additionalRequests_ be the ModuleRequests of |ModuleItem|.
          1. For each ModuleRequest Record _mr_ of _additionalRequests_, do
            1. If _requests_ does not contain a ModuleRequest Record _mr2_ such that ModuleRequestsEqual(_mr_, _mr2_) is *true*, then
              1. Append _mr_ to _requests_.
          1. Return _requests_.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. Let _specifier_ be the SV of |FromClause|.
          1. Return a List whose sole element is the ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause `;`</emu-grammar>
        <emu-alg>
          1. Let _specifier_ be the SV of |FromClause|.
          1. Let _attributes_ be WithClauseToAttributes of |WithClause|.
          1. Return a List whose sole element is the ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
        <emu-alg>
          1. Let _specifier_ be the SV of |ModuleSpecifier|.
          1. Return a List whose sole element is the ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause `;`</emu-grammar>
        <emu-alg>
          1. Let _specifier_ be the SV of |ModuleSpecifier|.
          1. Let _attributes_ be WithClauseToAttributes of |WithClause|.
          1. Return a List whose sole element is the ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. Let _specifier_ be the SV of |FromClause|.
          1. Return a List whose sole element is the ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: « » }.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause WithClause `;`
        </emu-grammar>
        <emu-alg>
          1. Let _specifier_ be the SV of |FromClause|.
          1. Let _attributes_ be WithClauseToAttributes of |WithClause|.
          1. Return a List whose sole element is the ModuleRequest Record { [[Specifier]]: _specifier_, [[Attributes]]: _attributes_ }.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>
        <p>A <dfn variants="Module Records">Module Record</dfn> encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.</p>
        <p>For specification purposes Module Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named Cyclic Module Record and its concrete subclass named Source Text Module Record. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.</p>
        <p>Module Record defines the fields listed in <emu-xref href="#table-module-record-fields"></emu-xref>. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>. All Module definition subclasses must provide concrete implementations of these abstract methods.</p>
        <emu-table id="table-module-record-fields" caption="Module Record Fields" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                a Realm Record
              </td>
              <td>
                The Realm within which this module was created.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                a Module Environment Record or ~empty~
              </td>
              <td>
                The Environment Record containing the top level bindings for this module. This field is set when the module is linked.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                an Object or ~empty~
              </td>
              <td>
                The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>) if one has been created for this module.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is *undefined*)
              </td>
              <td>
                Field reserved for use by host environments that need to associate additional information with a module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-table id="table-abstract-methods-of-module-records" caption="Abstract Methods of Module Records" oldids="table-37">
          <table>
            <thead>
              <tr>
                <th>
                  Method
                </th>
                <th>
                  Purpose
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                LoadRequestedModules([_hostDefined_])
              </td>
              <td>
                <p>Prepares the module for linking by recursively loading all its dependencies, and returns a promise.</p>
              </td>
            </tr>
            <tr>
              <td>
                GetExportedNames([_exportStarSet_])
              </td>
              <td>
                <p>Return a list of all names that are either directly or indirectly exported from this module.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                ResolveExport(_exportName_ [, _resolveSet_])
              </td>
              <td>
                <p>Return the binding of a name exported by this module. Bindings are represented by a <dfn id="resolvedbinding-record" variants="ResolvedBinding Records">ResolvedBinding Record</dfn>, of the form { [[Module]]: Module Record, [[BindingName]]: String | ~namespace~ }. If the export is a Module Namespace Object without a direct binding in any module, [[BindingName]] will be set to ~namespace~. Return *null* if the name cannot be resolved, or ~ambiguous~ if multiple bindings were found.</p>
                <p>Each time this operation is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                Link()
              </td>
              <td>
                <p>Prepare the module for evaluation by transitively resolving all module dependencies and creating a Module Environment Record.</p>
                <p>LoadRequestedModules must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
            <tr>
              <td>
                Evaluate()
              </td>
              <td>
                <p>Returns a promise for the evaluation of this module and its dependencies, resolving on successful evaluation or if it has already been evaluated successfully, and rejecting for an evaluation error or if it has already been evaluated unsuccessfully. If the promise is rejected, hosts are expected to handle the promise rejection and rethrow the evaluation error.</p>
                <p>Link must have completed successfully prior to invoking this method.</p>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-EvaluateModuleSync" type="abstract operation">
          <h1>
            EvaluateModuleSync (
              _module_: a Module Record,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It synchronously evaluates _module_, provided that the caller guarantees that _module_'s evaluation will return an already settled promise.</dd>
          </dl>

          <emu-alg>
            1. Assert: _module_ is not a Cyclic Module Record.
            1. Let _promise_ be _module_.Evaluate().
            1. Assert: _promise_.[[PromiseState]] is either ~fulfilled~ or ~rejected~.
            1. If _promise_.[[PromiseState]] is ~rejected~, then
              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *"handle"*).
              1. Set _promise_.[[PromiseIsHandled]] to *true*.
              1. Return ThrowCompletion(_promise_.[[PromiseResult]]).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~new~, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~new~. Transitions to ~unlinked~, ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is either ~linking~ or ~evaluating~, this is either the module's depth-first traversal index or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of ModuleRequest Records
              </td>
              <td>
                A List of the ModuleRequest Records associated with the imports in this module. The List is in source text occurrence order of the imports.
              </td>
            </tr>
            <tr>
              <td>
                [[LoadedModules]]
              </td>
              <td>
                a List of LoadedModuleRequest Records
              </td>
              <td>
                A map from the specifier strings used by the module represented by this record to request the importation of a module with the relative import attributes to the resolved Module Record. The list does not contain two different Records _r1_ and _r2_ such that ModuleRequestsEqual(_r1_, _r2_) is *true*.
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle, this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is the depth-first traversal index of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluationOrder]]
              </td>
              <td>
                ~unset~, an integer, or ~done~
              </td>
              <td>
                This field is initially set to ~unset~, and remains ~unset~ for fully synchronous modules. For modules that are either themselves asynchronous or have an asynchronous dependency, it is set to an integer that determines the order in which execution of pending modules is queued by <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>. Once the pending module is executed, the field is set to ~done~.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <thead>
              <tr>
                <th>
                  Method
                </th>
                <th>
                  Purpose
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td>
                Initialize the Environment Record of the module, including resolving all imported bindings, and create the module's execution context.
              </td>
            </tr>
            <tr>
              <td>
                ExecuteModule([_promiseCapability_])
              </td>
              <td>
                Evaluate the module's code within its execution context. If this module has *true* in [[HasTLA]], then a PromiseCapability Record is passed as an argument, and the method is expected to resolve or reject the given capability. In this case, the method must not throw an exception, but instead reject the PromiseCapability Record if necessary.
              </td>
            </tr>
          </table>
        </emu-table>

        <p>A <dfn id="graphloadingstate-record" variants="GraphLoadingState Records">GraphLoadingState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each GraphLoadingState Record has the fields defined in <emu-xref href="#table-graphloadingstate-record-fields"></emu-xref>:</p>
        <emu-table id="table-graphloadingstate-record-fields" caption="GraphLoadingState Record Fields">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[PromiseCapability]]
              </td>
              <td>
                a PromiseCapability Record
              </td>
              <td>
                The promise to resolve when the loading process finishes.
              </td>
            </tr>
            <tr>
              <td>
                [[IsLoading]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                It is true if the loading process has not finished yet, neither successfully nor with an error.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingModulesCount]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                It tracks the number of pending HostLoadImportedModule calls.
              </td>
            </tr>
            <tr>
              <td>
                [[Visited]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                It is a list of the Cyclic Module Records that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is ~empty~)
              </td>
              <td>
                It contains host-defined data to pass from the LoadRequestedModules caller to HostLoadImportedModule.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-cyclic-module-record-module-record-methods">
          <h1>Implementation of Module Record Abstract Methods</h1>

          <p>The following are the concrete methods for Cyclic Module Record that implement the corresponding Module Record abstract methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>.</p>

          <emu-clause id="sec-LoadRequestedModules" type="concrete method">
            <h1>
              LoadRequestedModules (
                optional _hostDefined_: anything,
              ): a Promise
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>It populates the [[LoadedModules]] of all the Module Records in the dependency graph of _module_ (most of the work is done by the auxiliary function InnerModuleLoading). It takes an optional _hostDefined_ parameter that is passed to the HostLoadImportedModule hook.</dd>
            </dl>

            <emu-alg>
              1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.
              1. Let _pc_ be ! NewPromiseCapability(%Promise%).
              1. Let _state_ be the GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.
              1. Perform InnerModuleLoading(_state_, _module_).
              1. Return _pc_.[[Promise]].
            </emu-alg>

            <emu-note>
              The _hostDefined_ parameter can be used to pass additional information necessary to fetch the imported modules. It is used, for example, by HTML to set the correct fetch destination for <code>&lt;link rel="preload" as="..."&gt;</code> tags.
              <code>import()</code> expressions never set the _hostDefined_ parameter.
            </emu-note>

            <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
              <h1>
                InnerModuleLoading (
                  _state_: a GraphLoadingState Record,
                  _module_: a Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
              </dl>

              <emu-alg>
                1. Assert: _state_.[[IsLoading]] is *true*.
                1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                  1. Append _module_ to _state_.[[Visited]].
                  1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].
                  1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                  1. For each ModuleRequest Record _request_ of _module_.[[RequestedModules]], do
                    1. If AllImportAttributesSupported(_request_.[[Attributes]]) is *false*, then
                      1. Let _error_ be ThrowCompletion(a newly created *SyntaxError* object).
                      1. Perform ContinueModuleLoading(_state_, _error_).
                    1. Else if _module_.[[LoadedModules]] contains a LoadedModuleRequest Record _record_ such that ModuleRequestsEqual(_record_, _request_) is *true*, then
                      1. Perform InnerModuleLoading(_state_, _record_.[[Module]]).
                    1. Else,
                      1. Perform HostLoadImportedModule(_module_, _request_, _state_.[[HostDefined]], _state_).
                      1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                    1. If _state_.[[IsLoading]] is *false*, return ~unused~.
                1. Assert: _state_.[[PendingModulesCount]] ≥ 1.
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
                1. If _state_.[[PendingModulesCount]] = 0, then
                  1. Set _state_.[[IsLoading]] to *false*.
                  1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do
                    1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                  1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »).
                1. Return ~unused~.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
              <h1>
                ContinueModuleLoading (
                  _state_: a GraphLoadingState Record,
                  _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
                ): ~unused~
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
              </dl>

              <emu-alg>
                1. If _state_.[[IsLoading]] is *false*, return ~unused~.
                1. If _moduleCompletion_ is a normal completion, then
                  1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]).
                1. Else,
                  1. Set _state_.[[IsLoading]] to *false*.
                  1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).
                1. Return ~unused~.
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
            <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>On success, Link transitions this module's [[Status]] from ~unlinked~ to ~linked~. On failure, an exception is thrown and this module's [[Status]] remains ~unlinked~. (Most of the work is done by the auxiliary function InnerModuleLinking.)</dd>
            </dl>

            <emu-alg>
              1. Assert: _module_.[[Status]] is one of ~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~.
              1. Let _stack_ be a new empty List.
              1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).
              1. If _result_ is an abrupt completion, then
                1. For each Cyclic Module Record _m_ of _stack_, do
                  1. Assert: _m_.[[Status]] is ~linking~.
                  1. Set _m_.[[Status]] to ~unlinked~.
                1. Assert: _module_.[[Status]] is ~unlinked~.
                1. Return ? _result_.
              1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.
              1. Assert: _stack_ is empty.
              1. Return ~unused~.
            </emu-alg>

            <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
              <h1>
                InnerModuleLinking (
                  _module_: a Module Record,
                  _stack_: a List of Cyclic Module Records,
                  _index_: a non-negative integer,
                ): either a normal completion containing a non-negative integer or a throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSAncestorIndex]] field, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
              </dl>

              <emu-alg>
                1. If _module_ is not a Cyclic Module Record, then
                  1. Perform ? _module_.Link().
                  1. Return _index_.
                1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                  1. Return _index_.
                1. Assert: _module_.[[Status]] is ~unlinked~.
                1. Set _module_.[[Status]] to ~linking~.
                1. Let _moduleIndex_ be _index_.
                1. Set _module_.[[DFSAncestorIndex]] to _index_.
                1. Set _index_ to _index_ + 1.
                1. Append _module_ to _stack_.
                1. For each ModuleRequest Record _request_ of _module_.[[RequestedModules]], do
                  1. Let _requiredModule_ be GetImportedModule(_module_, _request_).
                  1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~linking~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                1. Perform ? _module_.InitializeEnvironment().
                1. Assert: _module_ occurs exactly once in _stack_.
                1. Assert: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
                1. If _module_.[[DFSAncestorIndex]] = _moduleIndex_, then
                  1. Let _done_ be *false*.
                  1. Repeat, while _done_ is *false*,
                    1. Let _requiredModule_ be the last element of _stack_.
                    1. Remove the last element of _stack_.
                    1. Assert: _requiredModule_ is a Cyclic Module Record.
                    1. Set _requiredModule_.[[Status]] to ~linked~.
                    1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                1. Return _index_.
              </emu-alg>
            </emu-clause>
          </emu-clause>

          <emu-clause id="sec-moduleevaluation" type="concrete method">
            <h1>Evaluate ( ): a Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Cyclic Module Record _module_</dd>

              <dt>description</dt>
              <dd>Evaluate transitions this module's [[Status]] from ~linked~ to either ~evaluating-async~ or ~evaluated~. The first time it is called on a module in a given strongly connected component, Evaluate creates and returns a Promise which resolves when the module has finished evaluating. This Promise is stored in the [[TopLevelCapability]] field of the [[CycleRoot]] for the component. Future invocations of Evaluate on any module in the component return the same Promise. (Most of the work is done by the auxiliary function InnerModuleEvaluation.)</dd>
            </dl>

            <emu-alg>
              1. Assert: This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent.
              1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.
              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, set _module_ to _module_.[[CycleRoot]].
              1. If _module_.[[TopLevelCapability]] is not ~empty~, then
                1. Return _module_.[[TopLevelCapability]].[[Promise]].
              1. Let _stack_ be a new empty List.
              1. Let _capability_ be ! NewPromiseCapability(%Promise%).
              1. Set _module_.[[TopLevelCapability]] to _capability_.
              1. Let _result_ be Completion(InnerModuleEvaluation(_module_, _stack_, 0)).
              1. If _result_ is an abrupt completion, then
                1. For each Cyclic Module Record _m_ of _stack_, do
                  1. Assert: _m_.[[Status]] is ~evaluating~.
                  1. Assert: _m_.[[AsyncEvaluationOrder]] is ~unset~.
                  1. Set _m_.[[Status]] to ~evaluated~.
                  1. Set _m_.[[EvaluationError]] to _result_.
                1. Assert: _module_.[[Status]] is ~evaluated~.
                1. Assert: _module_.[[EvaluationError]] and _result_ are the same Completion Record.
                1. Perform ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »).
              1. Else,
                1. Assert: _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                1. Assert: _module_.[[EvaluationError]] is ~empty~.
                1. If _module_.[[Status]] is ~evaluated~, then
                  1. NOTE: This implies that evaluation of _module_ completed synchronously.
                  1. Assert: _module_.[[AsyncEvaluationOrder]] is ~unset~.
                  1. Perform ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »).
                1. Assert: _stack_ is empty.
              1. Return _capability_.[[Promise]].
            </emu-alg>

            <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
              <h1>
                InnerModuleEvaluation (
                  _module_: a Module Record,
                  _stack_: a List of Cyclic Module Records,
                  _index_: a non-negative integer,
                ): either a normal completion containing a non-negative integer or a throw completion
              </h1>
              <dl class="header">
                <dt>description</dt>
                <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSAncestorIndex]] field, are used the same way as in InnerModuleLinking.</dd>
              </dl>

              <emu-alg>
                1. If _module_ is not a Cyclic Module Record, then
                  1. Perform ? EvaluateModuleSync(_module_).
                  1. Return _index_.
                1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then
                  1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                  1. Otherwise, return ? _module_.[[EvaluationError]].
                1. If _module_.[[Status]] is ~evaluating~, return _index_.
                1. Assert: _module_.[[Status]] is ~linked~.
                1. Set _module_.[[Status]] to ~evaluating~.
                1. Let _moduleIndex_ be _index_.
                1. Set _module_.[[DFSAncestorIndex]] to _index_.
                1. Set _module_.[[PendingAsyncDependencies]] to 0.
                1. Set _index_ to _index_ + 1.
                1. Append _module_ to _stack_.
                1. For each ModuleRequest Record _request_ of _module_.[[RequestedModules]], do
                  1. Let _requiredModule_ be GetImportedModule(_module_, _request_).
                  1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                  1. If _requiredModule_ is a Cyclic Module Record, then
                    1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.
                    1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.
                    1. If _requiredModule_.[[Status]] is ~evaluating~, then
                      1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                    1. Else,
                      1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                      1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.
                      1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                    1. If _requiredModule_.[[AsyncEvaluationOrder]] is an integer, then
                      1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.
                      1. Append _module_ to _requiredModule_.[[AsyncParentModules]].
                1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then
                  1. Assert: _module_.[[AsyncEvaluationOrder]] is ~unset~.
                  1. Set _module_.[[AsyncEvaluationOrder]] to IncrementModuleAsyncEvaluationCount().
                  1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).
                1. Else,
                  1. Perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
                1. Assert: _module_ occurs exactly once in _stack_.
                1. Assert: _module_.[[DFSAncestorIndex]] ≤ _moduleIndex_.
                1. If _module_.[[DFSAncestorIndex]] = _moduleIndex_, then
                  1. Let _done_ be *false*.
                  1. Repeat, while _done_ is *false*,
                    1. Let _requiredModule_ be the last element of _stack_.
                    1. Remove the last element of _stack_.
                    1. Assert: _requiredModule_ is a Cyclic Module Record.
                    1. Assert: _requiredModule_.[[AsyncEvaluationOrder]] is either an integer or ~unset~.
                    1. If _requiredModule_.[[AsyncEvaluationOrder]] is ~unset~, set _requiredModule_.[[Status]] to ~evaluated~.
                    1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.
                    1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                    1. Set _requiredModule_.[[CycleRoot]] to _module_.
                1. Return _index_.
              </emu-alg>
              <emu-note>
                <p>A module is ~evaluating~ while it is being traversed by InnerModuleEvaluation. A module is ~evaluated~ on execution completion or ~evaluating-async~ during execution if its [[HasTLA]] field is *true* or if it has asynchronous dependencies.</p>
              </emu-note>
              <emu-note>
                <p>Any modules depending on a module of an asynchronous cycle when that cycle is not ~evaluating~ will instead depend on the execution of the root of the cycle via [[CycleRoot]]. This ensures that the cycle state can be treated as a single strongly connected component through its root module state.</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-execute-async-module" type="abstract operation">
              <h1>
                ExecuteAsyncModule (
                  _module_: a Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>

              <emu-alg>
                1. Assert: _module_.[[Status]] is either ~evaluating~ or ~evaluating-async~.
                1. Assert: _module_.[[HasTLA]] is *true*.
                1. Let _capability_ be ! NewPromiseCapability(%Promise%).
                1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and performs the following steps when called:
                  1. Perform AsyncModuleExecutionFulfilled(_module_).
                  1. Return NormalCompletion(*undefined*).
                1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, « »).
                1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _module_ and performs the following steps when called:
                  1. Perform AsyncModuleExecutionRejected(_module_, _error_).
                  1. Return NormalCompletion(*undefined*).
                1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *""*, « »).
                1. Perform PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_).
                1. Perform ! <emu-meta effects="user-code">_module_.ExecuteModule</emu-meta>(_capability_).
                1. Return ~unused~.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-gather-available-ancestors" type="abstract operation">
              <h1>
                GatherAvailableAncestors (
                  _module_: a Cyclic Module Record,
                  _execList_: a List of Cyclic Module Records,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. For each Cyclic Module Record _m_ of _module_.[[AsyncParentModules]], do
                  1. If _execList_ does not contain _m_ and _m_.[[CycleRoot]].[[EvaluationError]] is ~empty~, then
                    1. Assert: _m_.[[Status]] is ~evaluating-async~.
                    1. Assert: _m_.[[EvaluationError]] is ~empty~.
                    1. Assert: _m_.[[AsyncEvaluationOrder]] is an integer.
                    1. Assert: _m_.[[PendingAsyncDependencies]] > 0.
                    1. Set _m_.[[PendingAsyncDependencies]] to _m_.[[PendingAsyncDependencies]] - 1.
                    1. If _m_.[[PendingAsyncDependencies]] = 0, then
                      1. Append _m_ to _execList_.
                      1. If _m_.[[HasTLA]] is *false*, perform GatherAvailableAncestors(_m_, _execList_).
                1. Return ~unused~.
              </emu-alg>
              <emu-note>
                <p>When an asynchronous execution for a root _module_ is fulfilled, this function determines the list of modules which are able to synchronously execute together on this completion, populating them in _execList_.</p>
              </emu-note>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-fulfilled" type="abstract operation">
              <h1>
                AsyncModuleExecutionFulfilled (
                  _module_: a Cyclic Module Record,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. If _module_.[[Status]] is ~evaluated~, then
                  1. Assert: _module_.[[EvaluationError]] is not ~empty~.
                  1. Return ~unused~.
                1. Assert: _module_.[[Status]] is ~evaluating-async~.
                1. Assert: _module_.[[AsyncEvaluationOrder]] is an integer.
                1. Assert: _module_.[[EvaluationError]] is ~empty~.
                1. Set _module_.[[AsyncEvaluationOrder]] to ~done~.
                1. Set _module_.[[Status]] to ~evaluated~.
                1. If _module_.[[TopLevelCapability]] is not ~empty~, then
                  1. Assert: _module_.[[CycleRoot]] and _module_ are the same Module Record.
                  1. Perform ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).
                1. Let _execList_ be a new empty List.
                1. Perform GatherAvailableAncestors(_module_, _execList_).
                1. Assert: All elements of _execList_ have their [[AsyncEvaluationOrder]] field set to an integer, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to ~empty~.
                1. Let _sortedExecList_ be a List whose elements are the elements of _execList_, sorted by their [[AsyncEvaluationOrder]] field in ascending order.
                1. For each Cyclic Module Record _m_ of _sortedExecList_, do
                  1. If _m_.[[Status]] is ~evaluated~, then
                    1. Assert: _m_.[[EvaluationError]] is not ~empty~.
                  1. Else if _m_.[[HasTLA]] is *true*, then
                    1. Perform ExecuteAsyncModule(_m_).
                  1. Else,
                    1. Let _result_ be <emu-meta effects="user-code">_m_.ExecuteModule()</emu-meta>.
                    1. If _result_ is an abrupt completion, then
                      1. Perform AsyncModuleExecutionRejected(_m_, _result_.[[Value]]).
                    1. Else,
                      1. Set _m_.[[AsyncEvaluationOrder]] to ~done~.
                      1. Set _m_.[[Status]] to ~evaluated~.
                      1. If _m_.[[TopLevelCapability]] is not ~empty~, then
                        1. Assert: _m_.[[CycleRoot]] and _m_ are the same Module Record.
                        1. Perform ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).
                1. Return ~unused~.
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-async-module-execution-rejected" type="abstract operation">
              <h1>
                AsyncModuleExecutionRejected (
                  _module_: a Cyclic Module Record,
                  _error_: an ECMAScript language value,
                ): ~unused~
              </h1>
              <dl class="header">
              </dl>
              <emu-alg>
                1. If _module_.[[Status]] is ~evaluated~, then
                  1. Assert: _module_.[[EvaluationError]] is not ~empty~.
                  1. Return ~unused~.
                1. Assert: _module_.[[Status]] is ~evaluating-async~.
                1. Assert: _module_.[[AsyncEvaluationOrder]] is an integer.
                1. Assert: _module_.[[EvaluationError]] is ~empty~.
                1. Set _module_.[[EvaluationError]] to ThrowCompletion(_error_).
                1. Set _module_.[[Status]] to ~evaluated~.
                1. Set _module_.[[AsyncEvaluationOrder]] to ~done~.
                1. NOTE: _module_.[[AsyncEvaluationOrder]] is set to ~done~ for symmetry with AsyncModuleExecutionFulfilled. In InnerModuleEvaluation, the value of a module's [[AsyncEvaluationOrder]] internal slot is unused when its [[EvaluationError]] internal slot is not ~empty~.
                1. For each Cyclic Module Record _m_ of _module_.[[AsyncParentModules]], do
                  1. Perform AsyncModuleExecutionRejected(_m_, _error_).
                1. If _module_.[[TopLevelCapability]] is not ~empty~, then
                  1. Assert: _module_.[[CycleRoot]] and _module_ are the same Module Record.
                  1. Perform ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ »).
                1. Return ~unused~.
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-example-cyclic-module-record-graphs">
          <h1>Example Cyclic Module Record Graphs</h1>

          <p>This non-normative section gives a series of examples of the linking and evaluation of a few common module graphs, with a specific focus on how errors can occur.</p>

          <p>First consider the following simple module graph:</p>

          <emu-figure id="figure-module-graph-simple" caption="A simple module graph">
            <img alt="A module graph in which module A depends on module B, and module B depends on module C" width="60" height="198" src="img/module-graph-simple.svg">
          </emu-figure>

          <p>Let's first assume that there are no error conditions. When a host first calls _A_.LoadRequestedModules(), this will complete successfully by assumption, and recursively load the dependencies of _B_ and _C_ as well (respectively, _C_ and none), and then set _A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = ~unlinked~. Then, when the host calls _A_.Link(), it will complete successfully (again by assumption) such that _A_.[[Status]] = _B_.[[Status]] = _C_.[[Status]] = ~linked~. These preparatory steps can be performed at any time. Later, when the host is ready to incur any possible side effects of the modules, it can call _A_.Evaluate(), which will complete successfully, returning a Promise resolving to *undefined* (again by assumption), recursively having evaluated first _C_ and then _B_. Each module's [[Status]] at this point will be ~evaluated~.</p>

          <p>Consider then cases involving linking errors, after a successful call to _A_.LoadRequestedModules(). If InnerModuleLinking of _C_ succeeds but, thereafter, fails for _B_, for example because it imports something that _C_ does not provide, then the original _A_.Link() will fail, and both _A_ and _B_'s [[Status]] remain ~unlinked~. _C_'s [[Status]] has become ~linked~, though.</p>

          <p>Finally, consider a case involving evaluation errors after a successful call to Link(). If InnerModuleEvaluation of _C_ succeeds but, thereafter, fails for _B_, for example because _B_ contains code that throws an exception, then the original _A_.Evaluate() will fail, returning a rejected Promise. The resulting exception will be recorded in both _A_ and _B_'s [[EvaluationError]] fields, and their [[Status]] will become ~evaluated~. _C_ will also become ~evaluated~ but, in contrast to _A_ and _B_, will remain without an [[EvaluationError]], as it successfully completed evaluation. Storing the exception ensures that any time a host tries to reuse _A_ or _B_ by calling their Evaluate() method, it will encounter the same exception. (Hosts are not required to reuse Cyclic Module Records; similarly, hosts are not required to expose the exception objects thrown by these methods. However, the specification enables such uses.)</p>

          <p>Now consider a different type of error condition:</p>

          <emu-figure id="figure-module-graph-missing" caption="A module graph with an unresolvable module">
            <img alt="A module graph in which module A depends on a missing (unresolvable) module, represented by ???" width="60" height="121" src="img/module-graph-missing.svg">
          </emu-figure>

          <p>In this scenario, module _A_ declares a dependency on some other module, but no Module Record exists for that module, i.e. HostLoadImportedModule calls FinishLoadingImportedModule with an exception when asked for it. This could occur for a variety of reasons, such as the corresponding resource not existing, or the resource existing but ParseModule returning some errors when trying to parse the resulting source text. Hosts can choose to expose the cause of failure via the completion they pass to FinishLoadingImportedModule. In any case, this exception causes a loading failure, which results in _A_'s [[Status]] remaining ~new~.</p>

          <p>The difference here between loading, linking and evaluation errors is due to the following characteristic:</p>
          <ul>
            <li>Evaluation must be only performed once, as it can cause side effects; it is thus important to remember whether evaluation has already been performed, even if unsuccessfully. (In the error case, it makes sense to also remember the exception because otherwise subsequent Evaluate() calls would have to synthesize a new one.)</li>
            <li>Linking, on the other hand, is side-effect-free, and thus even if it fails, it can be retried at a later time with no issues.</li>
            <li>Loading closely interacts with the host, and it may be desirable for some of them to allow users to retry failed loads (for example, if the failure is caused by temporarily bad network conditions).</li>
          </ul>

          <p>Now, consider a module graph with a cycle:</p>

          <emu-figure id="figure-module-graph-cycle" caption="A cyclic module graph">
            <img alt="A module graph in which module A depends on module B and C, but module B also depends on module A" width="181" height="121" src="img/module-graph-cycle.svg">
          </emu-figure>

          <p>Here we assume that the entry point is module _A_, so that the host proceeds by calling _A_.LoadRequestedModules(), which performs InnerModuleLoading on _A_. This in turn calls InnerModuleLoading on _B_ and _C_. Because of the cycle, this again triggers InnerModuleLoading on _A_, but at this point it is a no-op since _A_'s dependencies loading has already been triggered during this LoadRequestedModules process. When all the modules in the graph have been successfully loaded, their [[Status]] transitions from ~new~ to ~unlinked~ at the same time.</p>

          <p>Then the host proceeds by calling _A_.Link(), which performs InnerModuleLinking on _A_. This in turn calls InnerModuleLinking on _B_. Because of the cycle, this again triggers InnerModuleLinking on _A_, but at this point it is a no-op since _A_.[[Status]] is already ~linking~. _B_.[[Status]] itself remains ~linking~ when control gets back to _A_ and InnerModuleLinking is triggered on _C_. After this returns with _C_.[[Status]] being ~linked~, both _A_ and _B_ transition from ~linking~ to ~linked~ together; this is by design, since they form a strongly connected component. It's possible to transition the status of modules in the same SCC at the same time because during this phase the module graph is traversed with a depth-first search.</p>

          <p>An analogous story occurs for the evaluation phase of a cyclic module graph, in the success case.</p>

          <p>Now consider a case where _A_ has a linking error; for example, it tries to import a binding from _C_ that does not exist. In that case, the above steps still occur, including the early return from the second call to InnerModuleLinking on _A_. However, once we unwind back to the original InnerModuleLinking on _A_, it fails during InitializeEnvironment, namely right after _C_.ResolveExport(). The thrown *SyntaxError* exception propagates up to _A_.Link, which resets all modules that are currently on its _stack_ (these are always exactly the modules that are still ~linking~). Hence both _A_ and _B_ become ~unlinked~. Note that _C_ is left as ~linked~.</p>

          <p>Alternatively, consider a case where _A_ has an evaluation error; for example, its source code throws an exception. In that case, the evaluation-time analogue of the above steps still occurs, including the early return from the second call to InnerModuleEvaluation on _A_. However, once we unwind back to the original InnerModuleEvaluation on _A_, it fails by assumption. The exception thrown propagates up to _A_.Evaluate(), which records the error in all modules that are currently on its _stack_ (i.e., the modules that are still ~evaluating~) as well as via [[AsyncParentModules]], which form a chain for modules which contain or depend on top-level `await` through the whole dependency graph through the AsyncModuleExecutionRejected algorithm. Hence both _A_ and _B_ become ~evaluated~ and the exception is recorded in both _A_ and _B_'s [[EvaluationError]] fields, while _C_ is left as ~evaluated~ with no [[EvaluationError]].</p>

          <p>Lastly, consider a module graph with a cycle, where all modules complete asynchronously:</p>
          <emu-figure id="figure-module-graph-cycle-async" caption="An asynchronous cyclic module graph">
            <img alt="A module graph in which module A depends on module B and C, module B depends on module D, module C depends on module D and E, and module D depends on module A" width="241" height="211" src="img/module-graph-cycle-async.svg">
          </emu-figure>
          <p>Loading and linking happen as before, and all modules end up with [[Status]] set to ~linked~.</p>

          <p>Calling _A_.Evaluate() calls InnerModuleEvaluation on _A_, _B_, and _D_, which all transition to ~evaluating~. Then InnerModuleEvaluation is called on _A_ again, which is a no-op because it is already ~evaluating~. At this point, _D_.[[PendingAsyncDependencies]] is 0, so ExecuteAsyncModule(_D_) is called and we call _D_.ExecuteModule with a new PromiseCapability tracking the asynchronous execution of _D_. We unwind back to the InnerModuleEvaluation on _B_, setting _B_.[[PendingAsyncDependencies]] to 1 and _B_.[[AsyncEvaluationOrder]] to 1. We unwind back to the original InnerModuleEvaluation on _A_, setting _A_.[[PendingAsyncDependencies]] to 1. In the next iteration of the loop over _A_'s dependencies, we call InnerModuleEvaluation on _C_ and thus on _D_ (again a no-op) and _E_. As _E_ has no dependencies and is not part of a cycle, we call ExecuteAsyncModule(_E_) in the same manner as _D_ and _E_ is immediately removed from the stack. We unwind once more to the InnerModuleEvaluation on _C_, setting _C_.[[AsyncEvaluationOrder]] to 3. Now we finish the loop over _A_'s dependencies, set _A_.[[AsyncEvaluationOrder]] to 4, and remove the entire strongly connected component from the stack, transitioning all of the modules to ~evaluating-async~ at once. At this point, the fields of the modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-1"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-1" caption="Module fields after the initial Evaluate() call">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
                <td>3</td>
                <td>0</td>
                <td>2</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>2 (_B_ and _C_)</td>
                <td>1 (_D_)</td>
                <td>2 (_D_ and _E_)</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>Let us assume that _E_ finishes executing first. When that happens, AsyncModuleExecutionFulfilled is called, _E_.[[Status]] is set to ~evaluated~ and _C_.[[PendingAsyncDependencies]] is decremented to become 1. The fields of the updated modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-2"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-2" caption="Module fields after module _E_ finishes executing">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_C_</th>
                  <th>_E_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>4</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_D_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>_D_ is next to finish (as it was the only module that was still executing). When that happens, AsyncModuleExecutionFulfilled is called again and _D_.[[Status]] is set to ~evaluated~. Its ancestors available for execution are _B_ (whose [[AsyncEvaluationOrder]] is 1) and _C_ (whose [[AsyncEvaluationOrder]] is 3), thus _B_ will be handled first: _B_.[[PendingAsyncDependencies]] is decremented to become 0, ExecuteAsyncModule is called on _B_, and it starts executing. _C_.[[PendingAsyncDependencies]] is also decremented to become 0, and _C_ starts executing (potentially in parallel to _B_ if _B_ contains an `await`). The fields of the updated modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-3"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-3" caption="Module fields after module _D_ finishes executing">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_B_</th>
                  <th>_C_</th>
                  <th>_D_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>1</td>
                <td>3</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« _A_ »</td>
                <td>« _A_ »</td>
                <td>« _B_, _C_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>Let us assume that _C_ finishes executing next. When that happens, AsyncModuleExecutionFulfilled is called again, _C_.[[Status]] is set to ~evaluated~ and _A_.[[PendingAsyncDependencies]] is decremented to become 1. The fields of the updated modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-4"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-4" caption="Module fields after module _C_ finishes executing">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>Then, _B_ finishes executing. When that happens, AsyncModuleExecutionFulfilled is called again and _B_.[[Status]] is set to ~evaluated~. _A_.[[PendingAsyncDependencies]] is decremented to become 0, so ExecuteAsyncModule is called and it starts executing. The fields of the updated modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-5"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-5" caption="Module fields after module _B_ finishes executing">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluating-async~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>Finally, _A_ finishes executing. When that happens, AsyncModuleExecutionFulfilled is called again and _A_.[[Status]] is set to ~evaluated~. At this point, the Promise in _A_.[[TopLevelCapability]] (which was returned from _A_.Evaluate()) is resolved, and this concludes the handling of this module graph. The fields of the updated module are as given in <emu-xref href="#table-module-graph-cycle-async-fields-6"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-6" caption="Module fields after module _A_ finishes executing">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
            </table>
          </emu-table>

          <p>Alternatively, consider a failure case where _C_ fails execution and returns an error before _B_ has finished executing. When that happens, AsyncModuleExecutionRejected is called, which sets _C_.[[Status]] to ~evaluated~ and _C_.[[EvaluationError]] to the error. It then propagates this error to all of the AsyncParentModules by performing AsyncModuleExecutionRejected on each of them. The fields of the updated modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-7"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-7" caption="Module fields after module _C_ finishes with an error">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_C_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>1 (_B_)</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>~empty~</td>
                <td>_C_'s evaluation error</td>
              </tr>
            </table>
          </emu-table>

          <p>_A_ will be rejected with the same error as _C_ since _C_ will call AsyncModuleExecutionRejected on _A_ with _C_'s error. _A_.[[Status]] is set to ~evaluated~. At this point the Promise in _A_.[[TopLevelCapability]] (which was returned from _A_.Evaluate()) is rejected. The fields of the updated module are as given in <emu-xref href="#table-module-graph-cycle-async-fields-8"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-8" caption="Module fields after module _A_ is rejected">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>~done~</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>

                <td>_C_'s Evaluation Error</td>
              </tr>
            </table>
          </emu-table>

          <p>Then, _B_ finishes executing without an error. When that happens, AsyncModuleExecutionFulfilled is called again and _B_.[[Status]] is set to ~evaluated~. GatherAvailableAncestors is called on _B_. However, _A_.[[CycleRoot]] is _A_ which has an evaluation error, so it will not be added to the returned _sortedExecList_ and AsyncModuleExecutionFulfilled will return without further processing. Any future importer of _B_ will resolve the rejection of _B_.[[CycleRoot]].[[EvaluationError]] from the evaluation error from _C_ that was set on the cycle root _A_. The fields of the updated modules are as given in <emu-xref href="#table-module-graph-cycle-async-fields-9"></emu-xref>.</p>

          <emu-table id="table-module-graph-cycle-async-fields-9" caption="Module fields after module _B_ finishes executing in an erroring graph">
            <table>
              <thead>
                <tr>
                  <th class="corner-cell">
                    <span class="column">Field</span>
                    <div class="slash">
                    </div>
                    <span class="row">Module</span>
                  </th>
                  <th>_A_</th>
                  <th>_B_</th>
                </tr>
              </thead>
              <tr>
                <th>[[DFSAncestorIndex]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[Status]]</th>
                <td>~evaluated~</td>
                <td>~evaluated~</td>
              </tr>
              <tr>
                <th>[[AsyncEvaluationOrder]]</th>
                <td>4</td>
                <td>1</td>
              </tr>
              <tr>
                <th>[[AsyncParentModules]]</th>
                <td>« »</td>
                <td>« _A_ »</td>
              </tr>
              <tr>
                <th>[[PendingAsyncDependencies]]</th>
                <td>0</td>
                <td>0</td>
              </tr>
              <tr>
                <th>[[EvaluationError]]</th>
                <td>_C_'s Evaluation Error</td>
                <td>~empty~</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <p>A <dfn id="sourctextmodule-record" variants="Source Text Module Records">Source Text Module Record</dfn> is used to represent information about a module that was defined from ECMAScript source text (<emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>) that was parsed using the goal symbol |Module|. Its fields contain digested information about the names that are imported and exported by the module, and its concrete methods use these digests to link and evaluate the module.</p>

        <p>A Source Text Module Record can exist in a module graph with other subclasses of the abstract Module Record type, and can participate in cycles with other subclasses of the Cyclic Module Record type.</p>

        <p>In addition to the fields defined in <emu-xref href="#table-cyclic-module-fields"></emu-xref>, Source Text Module Records have the additional fields listed in <emu-xref href="#table-additional-fields-of-source-text-module-records"></emu-xref>. Each of these fields is initially set in ParseModule.</p>
        <emu-table id="table-additional-fields-of-source-text-module-records" caption="Additional Fields of Source Text Module Records" oldids="table-38">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ECMAScriptCode]]
              </td>
              <td>
                a Parse Node
              </td>
              <td>
                The result of parsing the source text of this module using |Module| as the goal symbol.
              </td>
            </tr>
            <tr>
              <td>
                [[Context]]
              </td>
              <td>
                an ECMAScript code execution context or ~empty~
              </td>
              <td>
                The execution context associated with this module. It is ~empty~ until the module's environment has been initialized.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportMeta]]
              </td>
              <td>
                an Object or ~empty~
              </td>
              <td>
                An object exposed through the `import.meta` meta property. It is ~empty~ until it is accessed by ECMAScript code.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportEntries]]
              </td>
              <td>
                a List of ImportEntry Records
              </td>
              <td>
                A List of ImportEntry records derived from the code of this module.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td>
                A List of ExportEntry records derived from the code of this module that correspond to declarations that occur within the module.
              </td>
            </tr>
            <tr>
              <td>
                [[IndirectExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td>
                A List of ExportEntry records derived from the code of this module that correspond to reexported imports that occur within the module or exports from `export * as namespace` declarations.
              </td>
            </tr>
            <tr>
              <td>
                [[StarExportEntries]]
              </td>
              <td>
                a List of ExportEntry Records
              </td>
              <td>
                A List of ExportEntry records derived from the code of this module that correspond to `export *` declarations that occur within the module, not including `export * as namespace` declarations.
              </td>
            </tr>
          </table>
        </emu-table>
        <p>An <dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-importentry-record-fields"></emu-xref>:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record Fields" oldids="table-39">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                a ModuleRequest Record
              </td>
              <td>
                ModuleRequest Record representing the |ModuleSpecifier| and import attributes of the |ImportDeclaration|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                a String or ~namespace-object~
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. The value ~namespace-object~ indicates that the import request is for the target module's namespace object.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                a String
              </td>
              <td>
                The name that is used to locally access the imported value from within the importing module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-import-forms-mapping-to-importentry-records"></emu-xref> gives examples of ImportEntry records fields used to represent the syntactic import forms:</p>
          <emu-table id="table-import-forms-mapping-to-importentry-records" caption="Import Forms Mappings to ImportEntry Records" informative oldids="table-40">
            <table>
              <thead>
                <tr>
                  <th>
                    Import Statement Form
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `import v from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import * as ns from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~namespace-object~
                </td>
                <td>
                  *"ns"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `import {x as v} from "mod";`
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `import "mod";`
                </td>
                <td colspan="3">
                  An ImportEntry Record is not created.
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>An <dfn id="exportentry-record" variants="ExportEntry Records">ExportEntry Record</dfn> is a Record that digests information about a single declarative export. Each ExportEntry Record has the fields defined in <emu-xref href="#table-exportentry-records"></emu-xref>:</p>
        <emu-table id="table-exportentry-records" caption="ExportEntry Record Fields" oldids="table-41">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[ExportName]]
              </td>
              <td>
                a String or *null*
              </td>
              <td>
                The name used to export this binding by this module.
              </td>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                a ModuleRequest Record or *null*
              </td>
              <td>
                The ModuleRequest Record representing the |ModuleSpecifier| and import attributes of the |ExportDeclaration|. *null* if the |ExportDeclaration| does not have a |ModuleSpecifier|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                a String, *null*, ~all~, or ~all-but-default~
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. *null* if the |ExportDeclaration| does not have a |ModuleSpecifier|. ~all~ is used for `export * as ns from "mod"` declarations. ~all-but-default~ is used for `export * from "mod"` declarations.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                a String or *null*
              </td>
              <td>
                The name that is used to locally access the exported value from within the importing module. *null* if the exported value is not locally accessible from within the module.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p><emu-xref href="#table-export-forms-mapping-to-exportentry-records"></emu-xref> gives examples of the ExportEntry record fields used to represent the syntactic export forms:</p>
          <emu-table id="table-export-forms-mapping-to-exportentry-records" caption="Export Forms Mappings to ExportEntry Records" informative oldids="table-42">
            <table>
              <thead>
                <tr>
                  <th>
                    Export Statement Form
                  </th>
                  <th>
                    [[ExportName]]
                  </th>
                  <th>
                    [[ModuleRequest]]
                  </th>
                  <th>
                    [[ImportName]]
                  </th>
                  <th>
                    [[LocalName]]
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  `export var v;`
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function f() {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"f"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default function () {}`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export default 42;`
                </td>
                <td>
                  *"default"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"\*default\*"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"x"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x};`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"v"*
                </td>
              </tr>
              <tr>
                <td>
                  `export {x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export {v as x} from "mod";`
                </td>
                <td>
                  *"x"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  *"v"*
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * from "mod";`
                </td>
                <td>
                  *null*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all-but-default~
                </td>
                <td>
                  *null*
                </td>
              </tr>
              <tr>
                <td>
                  `export * as ns from "mod";`
                </td>
                <td>
                  *"ns"*
                </td>
                <td>
                  *"mod"*
                </td>
                <td>
                  ~all~
                </td>
                <td>
                  *null*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-note>
        <p>The following definitions specify the required concrete methods and other abstract operations for Source Text Module Records</p>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: a Realm Record,
              _hostDefined_: anything,
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. Let _importEntries_ be the ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be the ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ of _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _importedBoundNames_ does not contain _ee_.[[LocalName]], then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is ~namespace-object~, then
                    1. NOTE: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. NOTE: This is a re-export of a single name.
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                1. Assert: _ee_.[[ExportName]] is *null*.
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. Let _async_ be _body_ Contains `await`.
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluationOrder]]: ~unset~, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSAncestorIndex]]: ~empty~ }.
          </emu-alg>
          <emu-note>
            <p>An implementation may parse module source text and analyse it for Early Error conditions prior to the evaluation of ParseModule for that module source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseModule upon that source text.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-module-record-methods">
          <h1>Implementation of Module Record Abstract Methods</h1>

          <p>The following are the concrete methods for Source Text Module Record that implement the corresponding Module Record abstract methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>.</p>

          <emu-clause id="sec-getexportednames" type="concrete method">
            <h1>
              GetExportedNames (
                optional _exportStarSet_: a List of Source Text Module Records,
              ): a List of Strings
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Source Text Module Record _module_</dd>
            </dl>
            <emu-alg>
              1. Assert: _module_.[[Status]] is not ~new~.
              1. If _exportStarSet_ is not present, set _exportStarSet_ to a new empty List.
              1. If _exportStarSet_ contains _module_, then
                1. Assert: We've reached the starting point of an `export *` circularity.
                1. Return a new empty List.
              1. Append _module_ to _exportStarSet_.
              1. Let _exportedNames_ be a new empty List.
              1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do
                1. Assert: _module_ provides the direct binding for this export.
                1. Assert: _e_.[[ExportName]] is not *null*.
                1. Append _e_.[[ExportName]] to _exportedNames_.
              1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
                1. Assert: _module_ imports a specific binding for this export.
                1. Assert: _e_.[[ExportName]] is not *null*.
                1. Append _e_.[[ExportName]] to _exportedNames_.
              1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do
                1. Assert: _e_.[[ModuleRequest]] is not *null*.
                1. Let _requestedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. Let _starNames_ be _requestedModule_.GetExportedNames(_exportStarSet_).
                1. For each element _n_ of _starNames_, do
                  1. If _n_ is not *"default"*, then
                    1. If _exportedNames_ does not contain _n_, then
                      1. Append _n_ to _exportedNames_.
              1. Return _exportedNames_.
            </emu-alg>
            <emu-note>
              <p>GetExportedNames does not filter out or throw an exception for names that have ambiguous star export bindings.</p>
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: a String,
                optional _resolveSet_: a List of Records with fields [[Module]] (a Module Record) and [[ExportName]] (a String),
              ): a ResolvedBinding Record, *null*, or ~ambiguous~
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Source Text Module Record _module_</dd>

              <dt>description</dt>
              <dd>
                <p>ResolveExport attempts to resolve an imported binding to the actual defining module and local binding name. The defining module may be the module represented by the Module Record this method was invoked on or some other module that is imported by that module. The parameter _resolveSet_ is used to detect unresolved circular import/export paths. If a pair consisting of specific Module Record and _exportName_ is reached that is already in _resolveSet_, an import circularity has been encountered. Before recursively calling ResolveExport, a pair consisting of _module_ and _exportName_ is added to _resolveSet_.</p>
                <p>If a defining module is found, a ResolvedBinding Record { [[Module]], [[BindingName]] } is returned. This record identifies the resolved binding of the originally requested export, unless this is the export of a namespace with no local binding. In this case, [[BindingName]] will be set to ~namespace~. If no definition was found or the request is found to be circular, *null* is returned. If the request is found to be ambiguous, ~ambiguous~ is returned.</p>
              </dd>
            </dl>

            <emu-alg>
              1. Assert: _module_.[[Status]] is not ~new~.
              1. If _resolveSet_ is not present, set _resolveSet_ to a new empty List.
              1. For each Record { [[Module]], [[ExportName]] } _r_ of _resolveSet_, do
                1. If _module_ and _r_.[[Module]] are the same Module Record and _exportName_ is _r_.[[ExportName]], then
                  1. Assert: This is a circular import request.
                  1. Return *null*.
              1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.
              1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do
                1. If _e_.[[ExportName]] is _exportName_, then
                  1. Assert: _module_ provides the direct binding for this export.
                  1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.
              1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
                1. If _e_.[[ExportName]] is _exportName_, then
                  1. Assert: _e_.[[ModuleRequest]] is not *null*.
                  1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                  1. If _e_.[[ImportName]] is ~all~, then
                    1. Assert: _module_ does not provide the direct binding for this export.
                    1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }.
                  1. Else,
                    1. Assert: _module_ imports a specific binding for this export.
                    1. Assert: _e_.[[ImportName]] is a String.
                    1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).
              1. If _exportName_ is *"default"*, then
                1. Assert: A `default` export was not explicitly defined by this module.
                1. Return *null*.
                1. NOTE: A `default` export cannot be provided by an `export * from "mod"` declaration.
              1. Let _starResolution_ be *null*.
              1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do
                1. Assert: _e_.[[ModuleRequest]] is not *null*.
                1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).
                1. Let _resolution_ be _importedModule_.ResolveExport(_exportName_, _resolveSet_).
                1. If _resolution_ is ~ambiguous~, return ~ambiguous~.
                1. If _resolution_ is not *null*, then
                  1. Assert: _resolution_ is a ResolvedBinding Record.
                  1. If _starResolution_ is *null*, then
                    1. Set _starResolution_ to _resolution_.
                  1. Else,
                    1. Assert: There is more than one `*` import that includes the requested name.
                    1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record, return ~ambiguous~.
                    1. If _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]] and either _resolution_.[[BindingName]] or _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.
                    1. If _resolution_.[[BindingName]] is a String, _starResolution_.[[BindingName]] is a String, and _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]], return ~ambiguous~.
              1. Return _starResolution_.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-cyclic-module-record-methods">
          <h1>Implementation of Cyclic Module Record Abstract Methods</h1>

          <p>The following are the concrete methods for Source Text Module Record that implement the corresponding Cyclic Module Record abstract methods defined in <emu-xref href="#table-cyclic-module-methods"></emu-xref>.</p>

          <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
            <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
                1. Assert: _e_.[[ExportName]] is not *null*.
                1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).
                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. Assert: _resolution_ is a ResolvedBinding Record.
              1. Assert: All named exports from _module_ are resolvable.
              1. Let _realm_ be _module_.[[Realm]].
              1. Assert: _realm_ is not *undefined*.
              1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
              1. Set _module_.[[Environment]] to _env_.
              1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
                1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).
                1. If _in_.[[ImportName]] is ~namespace-object~, then
                  1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).
                  1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.
                  1. If _resolution_.[[BindingName]] is ~namespace~, then
                    1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                    1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                    1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                  1. Else,
                    1. Perform CreateImportBinding(_env_, _in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
              1. Let _moduleContext_ be a new ECMAScript code execution context.
              1. Set the Function of _moduleContext_ to *null*.
              1. Assert: _module_.[[Realm]] is not *undefined*.
              1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
              1. Set the ScriptOrModule of _moduleContext_ to _module_.
              1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
              1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
              1. Set the PrivateEnvironment of _moduleContext_ to *null*.
              1. Set _module_.[[Context]] to _moduleContext_.
              1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
              1. Let _code_ be _module_.[[ECMAScriptCode]].
              1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
              1. Let _declaredVarNames_ be a new empty List.
              1. For each element _d_ of _varDeclarations_, do
                1. For each element _dn_ of the BoundNames of _d_, do
                  1. If _declaredVarNames_ does not contain _dn_, then
                    1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                    1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                    1. Append _dn_ to _declaredVarNames_.
              1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
              1. Let _privateEnv_ be *null*.
              1. For each element _d_ of _lexDeclarations_, do
                1. For each element _dn_ of the BoundNames of _d_, do
                  1. If IsConstantDeclaration of _d_ is *true*, then
                    1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                  1. Else,
                    1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                    1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                    1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
              1. Remove _moduleContext_ from the execution context stack.
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-source-text-module-record-execute-module" type="concrete method">
            <h1>
              ExecuteModule (
                optional _capability_: a PromiseCapability Record,
              ): either a normal completion containing ~unused~ or a throw completion
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Source Text Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. Let _moduleContext_ be a new ECMAScript code execution context.
              1. Set the Function of _moduleContext_ to *null*.
              1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
              1. Set the ScriptOrModule of _moduleContext_ to _module_.
              1. Assert: _module_ has been linked and declarations in its module environment have been instantiated.
              1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
              1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
              1. Suspend the running execution context.
              1. If _module_.[[HasTLA]] is *false*, then
                1. Assert: _capability_ is not present.
                1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
                1. Let _result_ be Completion(Evaluation of _module_.[[ECMAScriptCode]]).
                1. Suspend _moduleContext_ and remove it from the execution context stack.
                1. Resume the context that is now on the top of the execution context stack as the running execution context.
                1. If _result_ is an abrupt completion, then
                  1. Return ? _result_.
              1. Else,
                1. Assert: _capability_ is a PromiseCapability Record.
                1. Perform AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-synthetic-module-records">
        <h1>Synthetic Module Records</h1>

        <p>A <dfn variants="Synthetic Module Records">Synthetic Module Record</dfn> is used to represent information about a module that is defined by specifications. Its exported names are statically defined at creation, while their corresponding values can change over time using SetSyntheticModuleExport. It has no imports or dependencies.</p>

        <emu-note>A Synthetic Module Record could be used for defining a variety of module types: for example, JSON modules or CSS modules.</emu-note>

        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Synthetic Module Records have the additional fields listed in <emu-xref href="#table-synthetic-module-record-fields"></emu-xref>.</p>

        <emu-table id="table-synthetic-module-record-fields" caption="Additional Fields of Synthetic Module Records">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value Type</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[ExportNames]]</td>
              <td>a List of Strings</td>
              <td>The names of the exports of the module. This list does not contain duplicates.</td>
            </tr>
            <tr>
              <td>[[EvaluationSteps]]</td>
              <td>an Abstract Closure</td>
              <td>The initialization logic to perform upon evaluation of the module, taking the Synthetic Module Record as its sole argument. It must not modify [[ExportNames]]. It may return an abrupt completion.</td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-create-default-export-synthetic-module" type="abstract operation">
          <h1>
            CreateDefaultExportSyntheticModule (
              _defaultExport_: an ECMAScript language value,
            ): a Synthetic Module Record
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Synthetic Module Record whose default export is _defaultExport_.</dd>
          </dl>
          <emu-alg>
            1. Let _realm_ be the current Realm Record.
            1. Let _setDefaultExport_ be a new Abstract Closure with parameters (_module_) that captures _defaultExport_ and performs the following steps when called:
              1. Perform SetSyntheticModuleExport(_module_, *"default"*, _defaultExport_).
              1. Return NormalCompletion(~unused~).
            1. Return the Synthetic Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[HostDefined]]: *undefined*, [[ExportNames]]: « *"default"* », [[EvaluationSteps]]: _setDefaultExport_ }.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parse-json-module" type="abstract operation">
          <h1>
            ParseJSONModule (
              _source_: a String,
            ): either a normal completion containing a Synthetic Module Record, or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-alg>
            1. Let _json_ be ? ParseJSON(_source_).
            1. Return CreateDefaultExportSyntheticModule(_json_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-setsyntheticmoduleexport" type="abstract operation">
          <h1>
            SetSyntheticModuleExport (
              _module_: a Synthetic Module Record,
              _exportName_: a String,
              _exportValue_: an ECMAScript language value,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It can be used to set or change the exported value for an existing export of a Synthetic Module Record.</dd>
          </dl>

          <emu-alg>
            1. Assert: _module_.[[ExportNames]] contains _exportName_.
            1. Let _envRec_ be _module_.[[Environment]].
            1. Assert: _envRec_ is not ~empty~.
            1. Perform _envRec_.SetMutableBinding(_exportName_, _exportValue_, *true*).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-smr-module-record-methods">
          <h1>Implementation of Module Record Abstract Methods</h1>

          <p>The following are the concrete methods for Synthetic Module Record that implement the corresponding Module Record abstract methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>.</p>

          <emu-clause id="sec-smr-LoadRequestedModules" type="concrete method">
            <h1>LoadRequestedModules ( ): a Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. Return ! PromiseResolve(%Promise%, *undefined*).
            </emu-alg>

            <emu-note>
              Synthetic Module Records have no dependencies.
            </emu-note>
          </emu-clause>

          <emu-clause id="sec-smr-getexportednames" type="concrete method">
            <h1>GetExportedNames ( ): a List of Strings</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. Return _module_.[[ExportNames]].
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-resolveexport" type="concrete method">
            <h1>
              ResolveExport (
                _exportName_: a String,
              ): a ResolvedBinding Record or *null*
            </h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. If _module_.[[ExportNames]] does not contain _exportName_, return *null*.
              1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _exportName_ }.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Link" type="concrete method">
            <h1>Link ( ): a normal completion containing ~unused~</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. Let _realm_ be _module_.[[Realm]].
              1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
              1. Set _module_.[[Environment]] to _env_.
              1. For each String _exportName_ of _module_.[[ExportNames]], do
                1. Perform ! _env_.CreateMutableBinding(_exportName_, *false*).
                1. Perform ! _env_.InitializeBinding(_exportName_, *undefined*).
              1. Return NormalCompletion(~unused~).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-smr-Evaluate" type="concrete method">
            <h1>Evaluate ( ): a Promise</h1>
            <dl class="header">
              <dt>for</dt>
              <dd>a Synthetic Module Record _module_</dd>
            </dl>

            <emu-alg>
              1. Let _moduleContext_ be a new ECMAScript code execution context.
              1. Set the Function of _moduleContext_ to *null*.
              1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
              1. Set the ScriptOrModule of _moduleContext_ to _module_.
              1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
              1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
              1. Suspend the running execution context.
              1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
              1. Let _steps_ be _module_.[[EvaluationSteps]].
              1. Let _result_ be Completion(_steps_(_module_)).
              1. Suspend _moduleContext_ and remove it from the execution context stack.
              1. Resume the context that is now on the top of the execution context stack as the running execution context.
              1. Let _pc_ be ! NewPromiseCapability(%Promise%).
              1. IfAbruptRejectPromise(_result_, _pc_).
              1. Perform ! Call(_pc_.[[Resolve]], *undefined*, « *undefined* »).
              1. Return _pc_.[[Promise]].
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-GetImportedModule" type="abstract operation">
        <h1>
          GetImportedModule (
            _referrer_: a Cyclic Module Record,
            _request_: a ModuleRequest Record,
          ): a Module Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. [declared="r"] Let _records_ be a List consisting of each LoadedModuleRequest Record _r_ of _referrer_.[[LoadedModules]] such that ModuleRequestsEqual(_r_, _request_) is *true*.
          1. Assert: _records_ has exactly one element, since LoadRequestedModules has completed successfully on _referrer_ prior to invoking this abstract operation.
          1. Let _record_ be the sole element of _records_.
          1. Return _record_.[[Module]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation" oldids="sec-hostresolveimportedmodule,sec-hostimportmoduledynamically">
        <h1>
          HostLoadImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _moduleRequest_: a ModuleRequest Record,
            _hostDefined_: anything,
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-note id="note-HostLoadImportedModule-referrer-Realm-Record">
          <p>An example of when _referrer_ can be a Realm Record is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The host environment must perform FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
          </li>
          <li>
            <p>If this operation is called multiple times with two (_referrer_, _moduleRequest_) pairs such that:</p>
            <ul>
              <li>the first _referrer_ is the same as the second _referrer_;</li>
              <li>ModuleRequestsEqual(the first _moduleRequest_, the second _moduleRequest_) is *true*;</li>
            </ul>
            <p>and it performs FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_) where _result_ is a normal completion, then it must perform FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_) with the same _result_ each time.</p>
          </li>
          <li>
            <p>If _moduleRequest_.[[Attributes]] has an entry _entry_ such that _entry_.[[Key]] is *"type"* and _entry_.[[Value]] is *"json"*, when the host environment performs FinishLoadingImportedModule(_referrer_, _moduleRequest_, _payload_, _result_), _result_ must either be the Completion Record returned by an invocation of ParseJSONModule or a throw completion.</p>
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadingImportedModule.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to load the appropriate Module Record. Multiple different (_referrer_, _moduleRequest_.[[Specifier]], _moduleRequest_.[[Attributes]]) triples may map to the same Module Record instance. The actual mapping semantics is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as expansion of relative and abbreviated path specifiers.</p>

        <emu-note>
          <p>The above text requires that hosts support JSON modules when imported with `type: "json"` (and HostLoadImportedModule completes normally), but it does not prohibit hosts from supporting JSON modules when imported without `type: "json"`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" oldids="sec-finishdynamicimport">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _moduleRequest_: a ModuleRequest Record,
            _payload_: a GraphLoadingState Record or a PromiseCapability Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a LoadedModuleRequest Record _record_ such that ModuleRequestsEqual(_record_, _moduleRequest_) is *true*, then
              1. Assert: _record_.[[Module]] and _result_.[[Value]] are the same Module Record.
            1. Else,
              1. Append the LoadedModuleRequest Record { [[Specifier]]: _moduleRequest_.[[Specifier]], [[Attributes]]: _moduleRequest_.[[Attributes]], [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _payload_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_payload_, _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, _result_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-AllImportAttributesSupported" type="abstract operation">
        <h1>
          AllImportAttributesSupported (
            _attributes_: a List of ImportAttribute Records,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. Let _supported_ be HostGetSupportedImportAttributes().
          1. For each ImportAttribute Record _attribute_ of _attributes_, do
            1. If _supported_ does not contain _attribute_.[[Key]], return *false*.
          1. Return *true*.
        </emu-alg>

        <emu-clause id="sec-hostgetsupportedimportattributes" type="host-defined abstract operation">
          <h1>HostGetSupportedImportAttributes ( ): a List of Strings</h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It allows host environments to specify which import attributes they support. Only attributes with supported keys will be provided to the host.</dd>
          </dl>

          <p>An implementation of HostGetSupportedImportAttributes must conform to the following requirements:</p>

          <ul>
            <li>It must return a List of Strings, each indicating a supported attribute.</li>

            <li>Each time this operation is called, it must return the same List with the same contents in the same order.</li>
          </ul>

          <p>The default implementation of HostGetSupportedImportAttributes is to return a new empty List.</p>

          <emu-note>The purpose of requiring the host to specify its supported import attributes, rather than passing all attributes to the host and letting it then choose which ones it wants to handle, is to ensure that unsupported attributes are handled in a consistent way across different hosts.</emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-getmodulenamespace" type="abstract operation">
        <h1>
          GetModuleNamespace (
            _module_: an instance of a concrete subclass of Module Record,
          ): a Module Namespace Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It retrieves the Module Namespace Object representing _module_'s exports, lazily creating it the first time it was requested, and storing it in _module_.[[Namespace]] for future retrieval.</dd>
        </dl>

        <emu-alg>
          1. Assert: If _module_ is a Cyclic Module Record, then _module_.[[Status]] is not ~new~ or ~unlinked~.
          1. Let _namespace_ be _module_.[[Namespace]].
          1. If _namespace_ is ~empty~, then
            1. Let _exportedNames_ be _module_.GetExportedNames().
            1. Let _unambiguousNames_ be a new empty List.
            1. For each element _name_ of _exportedNames_, do
              1. Let _resolution_ be _module_.ResolveExport(_name_).
              1. If _resolution_ is a ResolvedBinding Record, append _name_ to _unambiguousNames_.
            1. Set _namespace_ to ModuleNamespaceCreate(_module_, _unambiguousNames_).
          1. Return _namespace_.
        </emu-alg>
        <emu-note>
          <p>GetModuleNamespace never throws. Instead, unresolvable names are simply excluded from the namespace at this point. They will lead to a real linking error later unless they are all ambiguous star exports that are not explicitly requested anywhere.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-module-semantics-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return *undefined*.
        </emu-alg>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <emu-alg>
          1. Let _result_ be Completion(Evaluation of |ModuleItemList|).
          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then
            1. Return *undefined*.
          1. Return ? _result_.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _sl_ be ? Evaluation of |ModuleItemList|.
          1. Let _s_ be Completion(Evaluation of |ModuleItem|).
          1. Return ? UpdateEmpty(_s_, _sl_).
        </emu-alg>
        <emu-note>
          <p>The value of a |ModuleItemList| is the value of the last value-producing item in the |ModuleItemList|.</p>
        </emu-note>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <emu-alg>
          1. Return ~empty~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-imports">
      <h1>Imports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ImportDeclaration :
          `import` ImportClause FromClause WithClause? `;`
          `import` ModuleSpecifier WithClause? `;`

        ImportClause :
          ImportedDefaultBinding
          NameSpaceImport
          NamedImports
          ImportedDefaultBinding `,` NameSpaceImport
          ImportedDefaultBinding `,` NamedImports

        ImportedDefaultBinding :
          ImportedBinding

        NameSpaceImport :
          `*` `as` ImportedBinding

        NamedImports :
          `{` `}`
          `{` ImportsList `}`
          `{` ImportsList `,` `}`

        FromClause :
          `from` ModuleSpecifier

        ImportsList :
          ImportSpecifier
          ImportsList `,` ImportSpecifier

        ImportSpecifier :
          ImportedBinding
          ModuleExportName `as` ImportedBinding

        ModuleSpecifier :
          StringLiteral

        ImportedBinding :
          BindingIdentifier[~Yield, +Await]

        WithClause :
          `with` `{` `}`
          `with` `{` WithEntries `,`? `}`

        WithEntries :
          AttributeKey `:` StringLiteral
          AttributeKey `:` StringLiteral `,` WithEntries

        AttributeKey :
          IdentifierName
          StringLiteral
      </emu-grammar>

      <emu-clause id="sec-imports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleItem : ImportDeclaration</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the BoundNames of |ImportDeclaration| contains any duplicate entries.
          </li>
        </ul>

        <emu-grammar>WithClause : `with` `{` WithEntries `,`? `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if WithClauseToAttributes of |WithClause| has two different entries _a_ and _b_ such that _a_.[[Key]] is _b_.[[Key]].
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="sdo">
        <h1>Static Semantics: ImportEntries ( ): a List of ImportEntry Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be the ImportEntries of |ModuleItemList|.
          1. Let _entries2_ be the ImportEntries of |ModuleItem|.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ExportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of the ModuleRequests of |ImportDeclaration|.
          1. Return the ImportEntriesForModule of |ImportClause| with argument _module_.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ModuleSpecifier WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-importentriesformodule" type="sdo">
        <h1>
          Static Semantics: ImportEntriesForModule (
            _module_: a ModuleRequest Record,
          ): a List of ImportEntry Records
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NameSpaceImport</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be the ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.
          1. Let _entries2_ be the ImportEntriesForModule of |NameSpaceImport| with argument _module_.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>ImportClause : ImportedDefaultBinding `,` NamedImports</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be the ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.
          1. Let _entries2_ be the ImportEntriesForModule of |NamedImports| with argument _module_.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>ImportedDefaultBinding : ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _localName_ be the sole element of the BoundNames of |ImportedBinding|.
          1. Let _defaultEntry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *"default"*, [[LocalName]]: _localName_ }.
          1. Return « _defaultEntry_ ».
        </emu-alg>
        <emu-grammar>NameSpaceImport : `*` `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _localName_ be the StringValue of |ImportedBinding|.
          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-grammar>NamedImports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportsList : ImportsList `,` ImportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _specs1_ be the ImportEntriesForModule of |ImportsList| with argument _module_.
          1. Let _specs2_ be the ImportEntriesForModule of |ImportSpecifier| with argument _module_.
          1. Return the list-concatenation of _specs1_ and _specs2_.
        </emu-alg>
        <emu-grammar>ImportSpecifier : ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _localName_ be the sole element of the BoundNames of |ImportedBinding|.
          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-grammar>ImportSpecifier : ModuleExportName `as` ImportedBinding</emu-grammar>
        <emu-alg>
          1. Let _importName_ be the StringValue of |ModuleExportName|.
          1. Let _localName_ be the StringValue of |ImportedBinding|.
          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.
          1. Return « _entry_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-withclausetoattributes" type="sdo">
        <h1>Static Semantics: WithClauseToAttributes ( ): a List of ImportAttribute Records</h1>
        <dl class="header">
        </dl>

        <emu-grammar>
          WithClause : `with` `{` `}`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>

        <emu-grammar>
          WithClause : `with` `{` WithEntries `,`? `}`
        </emu-grammar>
        <emu-alg>
          1. Let _attributes_ be WithClauseToAttributes of |WithEntries|.
          1. Sort _attributes_ according to the lexicographic order of their [[Key]] field, treating the value of each such field as a sequence of UTF-16 code unit values. NOTE: This sorting is observable only in that hosts are prohibited from changing behaviour based on the order in which attributes are enumerated.
          1. Return _attributes_.
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral</emu-grammar>
        <emu-alg>
          1. Let _key_ be the PropName of |AttributeKey|.
          1. Let _entry_ be the ImportAttribute Record { [[Key]]: _key_, [[Value]]: the SV of |StringLiteral| }.
          1. Return « _entry_ ».
        </emu-alg>

        <emu-grammar>WithEntries : AttributeKey `:` StringLiteral `,` WithEntries</emu-grammar>
        <emu-alg>
          1. Let _key_ be the PropName of |AttributeKey|.
          1. Let _entry_ be the ImportAttribute Record { [[Key]]: _key_, [[Value]]: the SV of |StringLiteral| }.
          1. Let _rest_ be WithClauseToAttributes of |WithEntries|.
          1. Return the list-concatenation of « _entry_ » and _rest_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-exports">
      <h1>Exports</h1>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        ExportDeclaration :
          `export` ExportFromClause FromClause WithClause? `;`
          `export` NamedExports `;`
          `export` VariableStatement[~Yield, +Await]
          `export` Declaration[~Yield, +Await]
          `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
          `export` `default` ClassDeclaration[~Yield, +Await, +Default]
          `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`

        ExportFromClause :
          `*`
          `*` `as` ModuleExportName
          NamedExports

        NamedExports :
          `{` `}`
          `{` ExportsList `}`
          `{` ExportsList `,` `}`

        ExportsList :
          ExportSpecifier
          ExportsList `,` ExportSpecifier

        ExportSpecifier :
          ModuleExportName
          ModuleExportName `as` ModuleExportName
      </emu-grammar>

      <emu-clause id="sec-exports-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the ReferencedBindings of |NamedExports| contains any |StringLiteral|s.
          </li>
          <li>
            For each |IdentifierName| _n_ in the ReferencedBindings of |NamedExports|: It is a Syntax Error if the StringValue of _n_ is a |ReservedWord| or the StringValue of _n_ is one of *"implements"*, *"interface"*, *"let"*, *"package"*, *"private"*, *"protected"*, *"public"*, or *"static"*.
          </li>
        </ul>
        <emu-note>
          <p>The above rule means that each ReferencedBindings of |NamedExports| is treated as an |IdentifierReference|.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportedbindings" oldids="sec-module-semantics-static-semantics-exportedbindings,sec-exports-static-semantics-exportedbindings" type="sdo">
        <h1>Static Semantics: ExportedBindings ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedBindings are the locally bound names that are explicitly associated with a |Module|'s ExportedNames.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ExportedBindings of |ModuleItemList|.
          1. Let _names2_ be the ExportedBindings of |ModuleItem|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. Return the ExportedBindings of |NamedExports|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return the BoundNames of this |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ExportedBindings of |ExportsList|.
          1. Let _names2_ be the ExportedBindings of |ExportSpecifier|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of the first |ModuleExportName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportednames" oldids="sec-module-semantics-static-semantics-exportednames,sec-exports-static-semantics-exportednames" type="sdo">
        <h1>Static Semantics: ExportedNames ( ): a List of Strings</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>ExportedNames are the externally visible names that a |Module| explicitly maps to one of its local name bindings.</p>
        </emu-note>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ExportedNames of |ModuleItemList|.
          1. Let _names2_ be the ExportedNames of |ModuleItem|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ModuleItem : ExportDeclaration</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportDeclaration|.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |ExportFromClause|.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportFromClause : NamedExports</emu-grammar>
        <emu-alg>
          1. Return the ExportedNames of |NamedExports|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return the BoundNames of |Declaration|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return « *"default"* ».
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ExportedNames of |ExportsList|.
          1. Let _names2_ be the ExportedNames of |ExportSpecifier|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the StringValue of the second |ModuleExportName|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentries" oldids="sec-module-semantics-static-semantics-exportentries,sec-exports-static-semantics-exportentries" type="sdo">
        <h1>Static Semantics: ExportEntries ( ): a List of ExportEntry Records</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _entries1_ be the ExportEntries of |ModuleItemList|.
          1. Let _entries2_ be the ExportEntries of |ModuleItem|.
          1. Return the list-concatenation of _entries1_ and _entries2_.
        </emu-alg>
        <emu-grammar>
          ModuleItem :
            ImportDeclaration
            StatementListItem
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` ExportFromClause FromClause WithClause? `;`</emu-grammar>
        <emu-alg>
          1. Let _module_ be the sole element of the ModuleRequests of |ExportDeclaration|.
          1. Return the ExportEntriesForModule of |ExportFromClause| with argument _module_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` NamedExports `;`</emu-grammar>
        <emu-alg>
          1. Return the ExportEntriesForModule of |NamedExports| with argument *null*.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |VariableStatement|.
          1. For each element _name_ of _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Let _entries_ be a new empty List.
          1. Let _names_ be the BoundNames of |Declaration|.
          1. For each element _name_ of _names_, do
            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.
          1. Return _entries_.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |HoistableDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _names_ be the BoundNames of |ClassDeclaration|.
          1. Let _localName_ be the sole element of _names_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *"default"* }.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *"\*default\*"*, [[ExportName]]: *"default"* }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-note>
          <p>*"\*default\*"* is used within this specification as a synthetic name for anonymous default export values. See <emu-xref href="#note-star-default-star">this note</emu-xref> for more details.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-static-semantics-exportentriesformodule" type="sdo">
        <h1>
          Static Semantics: ExportEntriesForModule (
            _module_: a ModuleRequest Record or *null*,
          ): a List of ExportEntry Records
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>ExportFromClause : `*`</emu-grammar>
        <emu-alg>
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-grammar>ExportFromClause : `*` `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Let _exportName_ be the StringValue of |ModuleExportName|.
          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ }.
          1. Return « _entry_ ».
        </emu-alg>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _specs1_ be the ExportEntriesForModule of |ExportsList| with argument _module_.
          1. Let _specs2_ be the ExportEntriesForModule of |ExportSpecifier| with argument _module_.
          1. Return the list-concatenation of _specs1_ and _specs2_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName</emu-grammar>
        <emu-alg>
          1. Let _sourceName_ be the StringValue of |ModuleExportName|.
          1. If _module_ is *null*, then
            1. Let _localName_ be _sourceName_.
            1. Let _importName_ be *null*.
          1. Else,
            1. Let _localName_ be *null*.
            1. Let _importName_ be _sourceName_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Let _sourceName_ be the StringValue of the first |ModuleExportName|.
          1. Let _exportName_ be the StringValue of the second |ModuleExportName|.
          1. If _module_ is *null*, then
            1. Let _localName_ be _sourceName_.
            1. Let _importName_ be *null*.
          1. Else,
            1. Let _localName_ be *null*.
            1. Let _importName_ be _sourceName_.
          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-referencedbindings" type="sdo">
        <h1>Static Semantics: ReferencedBindings ( ): a List of Parse Nodes</h1>
        <dl class="header">
        </dl>
        <emu-grammar>NamedExports : `{` `}`</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ExportsList : ExportsList `,` ExportSpecifier</emu-grammar>
        <emu-alg>
          1. Let _names1_ be the ReferencedBindings of |ExportsList|.
          1. Let _names2_ be the ReferencedBindings of |ExportSpecifier|.
          1. Return the list-concatenation of _names1_ and _names2_.
        </emu-alg>
        <emu-grammar>ExportSpecifier : ModuleExportName `as` ModuleExportName</emu-grammar>
        <emu-alg>
          1. Return the ReferencedBindings of the first |ModuleExportName|.
        </emu-alg>
        <emu-grammar>ModuleExportName : IdentifierName</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the |IdentifierName|.
        </emu-alg>
        <emu-grammar>ModuleExportName : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the |StringLiteral|.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>
          ExportDeclaration :
            `export` ExportFromClause FromClause WithClause? `;`
            `export` NamedExports `;`
        </emu-grammar>
        <emu-alg>
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` VariableStatement</emu-grammar>
        <emu-alg>
          1. Return ? Evaluation of |VariableStatement|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` Declaration</emu-grammar>
        <emu-alg>
          1. Return ? Evaluation of |Declaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Return ? Evaluation of |HoistableDeclaration|.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` ClassDeclaration</emu-grammar>
        <emu-alg>
          1. Let _value_ be ? BindingClassDeclarationEvaluation of |ClassDeclaration|.
          1. Let _className_ be the sole element of the BoundNames of |ClassDeclaration|.
          1. If _className_ is *"\*default\*"*, then
            1. Let _env_ be the running execution context's LexicalEnvironment.
            1. Perform ? InitializeBoundName(*"\*default\*"*, _value_, _env_).
          1. Return ~empty~.
        </emu-alg>
        <emu-grammar>ExportDeclaration : `export` `default` AssignmentExpression `;`</emu-grammar>
        <emu-alg>
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then
            1. Let _value_ be ? NamedEvaluation of |AssignmentExpression| with argument *"default"*.
          1. Else,
            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.
            1. Let _value_ be ? GetValue(_rhs_).
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Perform ? InitializeBoundName(*"\*default\*"*, _value_, _env_).
          1. Return ~empty~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-error-handling-and-language-extensions">
  <h1>Error Handling and Language Extensions</h1>
  <p>An implementation must report most errors at the time the relevant ECMAScript language construct is evaluated. An <dfn id="early-error" variants="early errors">early error</dfn> is an error that can be detected and reported prior to the evaluation of any construct in the |Script| containing the error. The presence of an early error prevents the evaluation of the construct. An implementation must report early errors in a |Script| as part of parsing that |Script| in ParseScript. Early errors in a |Module| are reported at the point when the |Module| would be evaluated and the |Module| is never initialized. Early errors in <b>eval</b> code are reported at the time `eval` is called and prevent evaluation of the <b>eval</b> code. All errors that are not early errors are runtime errors.</p>
  <p>An implementation must report as an early error any occurrence of a condition that is listed in a “Static Semantics: Early Errors” subclause of this specification.</p>
  <p>An implementation shall not treat other kinds of errors as early errors even if the compiler can prove that a construct cannot execute without error under any circumstances. An implementation may issue an early warning in such a case, but it should not report the error until the relevant construct is actually executed.</p>
  <p>An implementation shall report all errors as specified, except for the following:</p>
  <ul>
    <li>
      Except as restricted in <emu-xref href="#sec-forbidden-extensions"></emu-xref>, a host or implementation may extend |Script| syntax, |Module| syntax, and regular expression pattern or flag syntax. To permit this, all operations (such as calling `eval`, using a regular expression literal, or using the Function or RegExp constructor) that are allowed to throw *SyntaxError* are permitted to exhibit host-defined behaviour instead of throwing *SyntaxError* when they encounter a host-defined extension to the script syntax or regular expression pattern or flag syntax.
    </li>
    <li>
      Except as restricted in <emu-xref href="#sec-forbidden-extensions"></emu-xref>, a host or implementation may provide additional types, values, objects, properties, and functions beyond those described in this specification. This may cause constructs (such as looking up a variable in the global scope) to have host-defined behaviour instead of throwing an error (such as *ReferenceError*).
    </li>
  </ul>

  <emu-clause id="sec-forbidden-extensions">
    <h1>Forbidden Extensions</h1>
    <p>An implementation must not extend this specification in the following ways:</p>
    <ul>
      <li>
        ECMAScript function objects defined using syntactic constructors in strict mode code must not be created with own properties named *"caller"* or *"arguments"*. Such own properties also must not be created for function objects defined using an |ArrowFunction|, |MethodDefinition|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, |ClassDeclaration|, |ClassExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, or |AsyncArrowFunction| regardless of whether the definition is contained in strict mode code. Built-in functions, strict functions created using the Function constructor, generator functions created using the Generator constructor, async functions created using the AsyncFunction constructor, and functions created using the `bind` method also must not be created with such own properties.
      </li>
      <li>
        If an implementation extends any function object with an own property named *"caller"* the value of that property, as observed using [[Get]] or [[GetOwnProperty]], must not be a strict function object. If it is an accessor property, the function that is the value of the property's [[Get]] attribute must never return a strict function when called.
      </li>
      <li>
        Neither mapped nor unmapped arguments objects may be created with an own property named *"caller"*.
      </li>
      <li>
        The behaviour of built-in methods which are specified in ECMA-402, such as those named `toLocaleString`, must not be extended except as specified in ECMA-402.
      </li>
      <li>
        The RegExp pattern grammars in <emu-xref href="#sec-patterns"></emu-xref> and <emu-xref href="#sec-regular-expressions-patterns"></emu-xref> must not be extended to recognize any of the source characters A-Z or a-z as |IdentityEscape[+UnicodeMode]| when the <sub>[UnicodeMode]</sub> grammar parameter is present.
      </li>
      <li>
        The Syntactic Grammar must not be extended in any manner that allows the token `:` to immediately follow source text that is matched by the |BindingIdentifier| nonterminal symbol.
      </li>
      <li>
        When processing strict mode code, an implementation must not relax the early error rules of <emu-xref href="#sec-numeric-literals-early-errors"></emu-xref>.
      </li>
      <li>
        |TemplateEscapeSequence| must not be extended to include |LegacyOctalEscapeSequence| or |NonOctalDecimalEscapeSequence| as defined in <emu-xref href="#sec-literals-string-literals"></emu-xref>.
      </li>
      <li>
        When processing strict mode code, the extensions defined in <emu-xref href="#sec-labelled-function-declarations"></emu-xref>, <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>, <emu-xref href="#sec-functiondeclarations-in-ifstatement-statement-clauses"></emu-xref>, and <emu-xref href="#sec-initializers-in-forin-statement-heads"></emu-xref> must not be supported.
      </li>
      <li>
        When parsing for the |Module| goal symbol, the lexical grammar extensions defined in <emu-xref href="#sec-html-like-comments"></emu-xref> must not be supported.
      </li>
      <!-- The following is so that in the future we can potentially add new arguments or support ArgumentList. -->
      <li>
        |ImportCall| must not be extended.
      </li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-standard-built-in-objects">
  <h1>ECMAScript Standard Built-in Objects</h1>
  <p>There are certain built-in objects available whenever an ECMAScript |Script| or |Module| begins execution. One, the global object, is part of the global environment of the executing program. Others are accessible as initial properties of the global object or indirectly as properties of accessible built-in objects.</p>
  <p>Unless specified otherwise, a built-in object that is callable as a function is a built-in function object with the characteristics described in <emu-xref href="#sec-built-in-function-objects"></emu-xref>. Unless specified otherwise, the [[Extensible]] internal slot of a built-in object initially has the value *true*. Every built-in function object has a [[Realm]] internal slot whose value is the Realm Record of the realm for which the object was initially created.</p>
  <p>Many built-in objects are functions: they can be invoked with arguments. Some of them furthermore are constructors: they are functions intended for use with the `new` operator. For each built-in function, this specification describes the arguments required by that function and the properties of that function object. For each built-in constructor, this specification furthermore describes properties of the prototype object of that constructor and properties of specific object instances returned by a `new` expression that invokes that constructor.</p>
  <p>Unless otherwise specified in the description of a particular function, if a built-in function or constructor is given fewer arguments than the function is specified to require, the function or constructor shall behave exactly as if it had been given sufficient additional arguments, each such argument being the *undefined* value. Such missing arguments are considered to be “not present” and may be identified in that manner by specification algorithms. In the description of a particular function, the terms “*this* value” and “NewTarget” have the meanings given in <emu-xref href="#sec-built-in-function-objects"></emu-xref>.</p>
  <p>Unless otherwise specified in the description of a particular function, if a built-in function or constructor described is given more arguments than the function is specified to allow, the extra arguments are evaluated by the call and then ignored by the function. However, an implementation may define implementation specific behaviour relating to such arguments as long as the behaviour is not the throwing of a *TypeError* exception that is predicated simply on the presence of an extra argument.</p>
  <emu-note>
    <p>Implementations that add additional capabilities to the set of built-in functions are encouraged to do so by adding new functions rather than adding new parameters to existing functions.</p>
  </emu-note>
  <p>Unless otherwise specified every built-in function and every built-in constructor has the Function prototype object, which is the initial value of the expression `Function.prototype` (<emu-xref href="#sec-properties-of-the-function-prototype-object"></emu-xref>), as the value of its [[Prototype]] internal slot.</p>
  <p>Unless otherwise specified every built-in prototype object has the Object prototype object, which is the initial value of the expression `Object.prototype` (<emu-xref href="#sec-properties-of-the-object-prototype-object"></emu-xref>), as the value of its [[Prototype]] internal slot, except the Object prototype object itself.</p>
  <p>If this specification defines a built-in constructor's behaviour via algorithm steps, then that is its behaviour for the purposes of both [[Call]] and [[Construct]]. If such an algorithm needs to distinguish the two cases, it checks whether NewTarget is *undefined*, which indicates a [[Call]] invocation.</p>
  <p>Built-in function objects that are not identified as constructors do not implement the [[Construct]] internal method unless otherwise specified in the description of a particular function.</p>
  <p>Built-in function objects that are not constructors do not have a *"prototype"* property unless otherwise specified in the description of a particular function.</p>
  <p>Each built-in function defined in this specification is created by calling the CreateBuiltinFunction abstract operation (<emu-xref href="#sec-createbuiltinfunction"></emu-xref>). The values of the _length_ and _name_ parameters are the initial values of the *"length"* and *"name"* properties as discussed below. The values of the _prefix_ parameter are similarly discussed below.</p>
  <p>Every built-in function object, including constructors, has a *"length"* property whose value is a non-negative integral Number. Unless otherwise specified, this value is the number of required parameters shown in the subclause heading for the function description. Optional parameters and rest parameters are not included in the parameter count.</p>
  <emu-note>
    <p>For example, the function object that is the initial value of the *"map"* property of the Array prototype object is described under the subclause heading «Array.prototype.map (callback [ , thisArg])» which shows the two named arguments callback and thisArg, the latter being optional; therefore the value of the *"length"* property of that function object is *1*<sub>𝔽</sub>.</p>
  </emu-note>
  <p>Unless otherwise specified, the *"length"* property of a built-in function object has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
  <p>Every built-in function object, including constructors, has a *"name"* property whose value is a String. Unless otherwise specified, this value is the name that is given to the function in this specification. Functions that are identified as anonymous functions use the empty String as the value of the *"name"* property. For functions that are specified as properties of objects, the name value is the property name string used to access the function. Functions that are specified as get or set accessor functions of built-in properties have *"get"* or *"set"* (respectively) passed to the _prefix_ parameter when calling CreateBuiltinFunction.</p>
  <p>The value of the *"name"* property is explicitly specified for each built-in functions whose property key is a Symbol value. If such an explicitly specified value starts with the prefix *"get "* or *"set "* and the function for which it is specified is a get or set accessor function of a built-in property, the value without the prefix is passed to the _name_ parameter, and the value *"get"* or *"set"* (respectively) is passed to the _prefix_ parameter when calling CreateBuiltinFunction.</p>
  <p>Unless otherwise specified, the *"name"* property of a built-in function object has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
  <p>Every other data property described in clauses <emu-xref href="#sec-global-object"></emu-xref> through <emu-xref href="#sec-reflection"></emu-xref> and in Annex <emu-xref href="#sec-additional-built-in-properties"></emu-xref> has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* } unless otherwise specified.</p>
  <p>Every accessor property described in clauses <emu-xref href="#sec-global-object"></emu-xref> through <emu-xref href="#sec-reflection"></emu-xref> and in Annex <emu-xref href="#sec-additional-built-in-properties"></emu-xref> has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* } unless otherwise specified. If only a get accessor function is described, the set accessor function is the default value, *undefined*. If only a set accessor is described the get accessor is the default value, *undefined*.</p>
</emu-clause>

<emu-clause id="sec-global-object">
  <h1>The Global Object</h1>
  <p>The <dfn variants="global objects">global object</dfn>:</p>
  <ul>
    <li>is created before control enters any execution context.</li>
    <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
    <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    <li>has a [[Prototype]] internal slot whose value is host-defined.</li>
    <li>may have host-defined properties in addition to the properties defined in this specification. This may include a property whose value is the global object itself.</li>
  </ul>

  <emu-clause id="sec-value-properties-of-the-global-object">
    <h1>Value Properties of the Global Object</h1>

    <emu-clause id="sec-globalthis">
      <h1>globalThis</h1>
      <p>The initial value of the *"globalThis"* property of the global object in a Realm Record _realm_ is _realm_.[[GlobalEnv]].[[GlobalThisValue]].</p>
      <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-infinity">
      <h1>Infinity</h1>
      <p>The value of `Infinity` is *+∞*<sub>𝔽</sub> (see <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>). This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-global-object-nan">
      <h1>NaN</h1>
      <p>The value of `NaN` is *NaN* (see <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>). This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-undefined">
      <h1>undefined</h1>
      <p>The value of `undefined` is *undefined* (see <emu-xref href="#sec-ecmascript-language-types-undefined-type"></emu-xref>). This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-properties-of-the-global-object">
    <h1>Function Properties of the Global Object</h1>

    <emu-clause id="sec-eval-x">
      <h1>eval ( _x_ )</h1>
      <p>This function is the <dfn>%eval%</dfn> intrinsic object.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return ? PerformEval(_x_, *false*, *false*).
      </emu-alg>

      <emu-clause id="sec-performeval" type="abstract operation" oldids="sec-performeval-rules-outside-functions,sec-performeval-rules-outside-methods,sec-performeval-rules-outside-constructors">
        <h1>
          PerformEval (
            _x_: an ECMAScript language value,
            _strictCaller_: a Boolean,
            _direct_: a Boolean,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.
          1. If _x_ is not a String, return _x_.
          1. Let _evalRealm_ be the current Realm Record.
          1. NOTE: In the case of a direct eval, _evalRealm_ is the realm of both the caller of `eval` and of the `eval` function itself.
          1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_).
          1. Let _inFunction_ be *false*.
          1. Let _inMethod_ be *false*.
          1. Let _inDerivedConstructor_ be *false*.
          1. Let _inClassFieldInitializer_ be *false*.
          1. If _direct_ is *true*, then
            1. Let _thisEnvRec_ be GetThisEnvironment().
            1. If _thisEnvRec_ is a Function Environment Record, then
              1. Let _F_ be _thisEnvRec_.[[FunctionObject]].
              1. Set _inFunction_ to *true*.
              1. Set _inMethod_ to _thisEnvRec_.HasSuperBinding().
              1. If _F_.[[ConstructorKind]] is ~derived~, set _inDerivedConstructor_ to *true*.
              1. Let _classFieldInitializerName_ be _F_.[[ClassFieldInitializerName]].
              1. If _classFieldInitializerName_ is not ~empty~, set _inClassFieldInitializer_ to *true*.
          1. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:
            1. Let _script_ be ParseText(_x_, |Script|).
            1. If _script_ is a List of errors, throw a *SyntaxError* exception.
            1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.
            1. Let _body_ be the |ScriptBody| of _script_.
            1. If _inFunction_ is *false* and _body_ Contains |NewTarget|, throw a *SyntaxError* exception.
            1. If _inMethod_ is *false* and _body_ Contains |SuperProperty|, throw a *SyntaxError* exception.
            1. If _inDerivedConstructor_ is *false* and _body_ Contains |SuperCall|, throw a *SyntaxError* exception.
            1. If _inClassFieldInitializer_ is *true* and ContainsArguments of _body_ is *true*, throw a *SyntaxError* exception.
          1. If _strictCaller_ is *true*, let _strictEval_ be *true*.
          1. Else, let _strictEval_ be ScriptIsStrict of _script_.
          1. Let _runningContext_ be the running execution context.
          1. NOTE: If _direct_ is *true*, _runningContext_ will be the execution context that performed the direct eval. If _direct_ is *false*, _runningContext_ will be the execution context for the invocation of the `eval` function.
          1. If _direct_ is *true*, then
            1. Let _lexEnv_ be NewDeclarativeEnvironment(_runningContext_'s LexicalEnvironment).
            1. Let _varEnv_ be _runningContext_'s VariableEnvironment.
            1. Let _privateEnv_ be _runningContext_'s PrivateEnvironment.
          1. Else,
            1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).
            1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].
            1. Let _privateEnv_ be *null*.
          1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.
          1. If _runningContext_ is not already suspended, suspend _runningContext_.
          1. Let _evalContext_ be a new ECMAScript code execution context.
          1. Set _evalContext_'s Function to *null*.
          1. Set _evalContext_'s Realm to _evalRealm_.
          1. Set _evalContext_'s ScriptOrModule to _runningContext_'s ScriptOrModule.
          1. Set _evalContext_'s VariableEnvironment to _varEnv_.
          1. Set _evalContext_'s LexicalEnvironment to _lexEnv_.
          1. Set _evalContext_'s PrivateEnvironment to _privateEnv_.
          1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.
          1. Let _result_ be Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)).
          1. If _result_ is a normal completion, then
            1. Set _result_ to Completion(Evaluation of _body_).
          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then
            1. Set _result_ to NormalCompletion(*undefined*).
          1. Suspend _evalContext_ and remove it from the execution context stack.
          1. Resume the context that is now on the top of the execution context stack as the running execution context.
          1. Return ? _result_.
        </emu-alg>
        <emu-note>
          <p>The eval code cannot instantiate variable or function bindings in the variable environment of the calling context that invoked the eval if either the code of the calling context or the eval code is strict mode code. Instead such bindings are instantiated in a new VariableEnvironment that is only accessible to the eval code. Bindings introduced by `let`, `const`, or `class` declarations are always instantiated in a new LexicalEnvironment.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostensurecancompilestrings" type="host-defined abstract operation">
        <h1>
          HostEnsureCanCompileStrings (
            _calleeRealm_: a Realm Record,
            _parameterStrings_: a List of Strings,
            _bodyString_: a String,
            _direct_: a Boolean,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It allows host environments to block certain ECMAScript functions which allow developers to interpret and evaluate strings as ECMAScript code.</dd>
        </dl>
        <p>
          _parameterStrings_ represents the strings that, when using one of the function constructors, will be concatenated together to build the parameters list. _bodyString_ represents the function body or the string passed to an `eval` call.
          _direct_ signifies whether the evaluation is a direct eval.
        </p>
        <p>The default implementation of HostEnsureCanCompileStrings is to return NormalCompletion(~unused~).</p>
      </emu-clause>

      <emu-clause id="sec-evaldeclarationinstantiation" type="abstract operation" oldids="sec-web-compat-evaldeclarationinstantiation">
        <h1>
          EvalDeclarationInstantiation (
            _body_: a |ScriptBody| Parse Node,
            _varEnv_: an Environment Record,
            _lexEnv_: a Declarative Environment Record,
            _privateEnv_: a PrivateEnvironment Record or *null*,
            _strict_: a Boolean,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _varNames_ be the VarDeclaredNames of _body_.
          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.
          1. If _strict_ is *false*, then
            1. If _varEnv_ is a Global Environment Record, then
              1. For each element _name_ of _varNames_, do
                1. If HasLexicalDeclaration(_varEnv_, _name_) is *true*, throw a *SyntaxError* exception.
                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.
            1. Let _thisEnv_ be _lexEnv_.
            1. Assert: The following loop will terminate.
            1. Repeat, while _thisEnv_ and _varEnv_ are not the same Environment Record,
              1. If _thisEnv_ is not an Object Environment Record, then
                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.
                1. For each element _name_ of _varNames_, do
                  1. If ! _thisEnv_.HasBinding(_name_) is *true*, then
                    1. [id="step-evaldeclarationinstantiation-throw-duplicate-binding", normative-optional] If the host is a web browser or otherwise supports <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref>, then
                      1. If _thisEnv_ is not the Environment Record for a |Catch| clause, throw a *SyntaxError* exception.
                    1. Else,
                      1. Throw a *SyntaxError* exception.
                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.
              1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].
          1. Let _privateIdentifiers_ be a new empty List.
          1. Let _pointer_ be _privateEnv_.
          1. Repeat, while _pointer_ is not *null*,
            1. For each Private Name _binding_ of _pointer_.[[Names]], do
              1. If _privateIdentifiers_ does not contain _binding_.[[Description]], append _binding_.[[Description]] to _privateIdentifiers_.
            1. Set _pointer_ to _pointer_.[[OuterPrivateEnvironment]].
          1. If AllPrivateIdentifiersValid of _body_ with argument _privateIdentifiers_ is *false*, throw a *SyntaxError* exception.
          1. Let _functionsToInitialize_ be a new empty List.
          1. Let _declaredFunctionNames_ be a new empty List.
          1. For each element _d_ of _varDeclarations_, in reverse List order, do
            1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.
              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.
              1. Let _fn_ be the sole element of the BoundNames of _d_.
              1. If _declaredFunctionNames_ does not contain _fn_, then
                1. If _varEnv_ is a Global Environment Record, then
                  1. Let _fnDefinable_ be ? CanDeclareGlobalFunction(_varEnv_, _fn_).
                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.
                1. Append _fn_ to _declaredFunctionNames_.
                1. Insert _d_ as the first element of _functionsToInitialize_.
          1. Let _declaredVarNames_ be a new empty List.
          1. For each element _d_ of _varDeclarations_, do
            1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then
              1. For each String _vn_ of the BoundNames of _d_, do
                1. If _declaredFunctionNames_ does not contain _vn_, then
                  1. If _varEnv_ is a Global Environment Record, then
                    1. Let _vnDefinable_ be ? CanDeclareGlobalVar(_varEnv_, _vn_).
                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.
                  1. If _declaredVarNames_ does not contain _vn_, then
                    1. Append _vn_ to _declaredVarNames_.
          1. [id="step-evaldeclarationinstantiation-web-compat-insertion-point", normative-optional] If _strict_ is *false* and the host is a web browser or otherwise supports <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics" title></emu-xref>, then
            1. Let _declaredFunctionOrVarNames_ be the list-concatenation of _declaredFunctionNames_ and _declaredVarNames_.
            1. For each |FunctionDeclaration| _f_ that is directly contained in the |StatementList| of any |Block|, |CaseClause|, or |DefaultClause| _x_ such that _body_ Contains _x_ is *true*, do
              1. Let _F_ be the StringValue of the |BindingIdentifier| of _f_.
              1. If replacing the |FunctionDeclaration| _f_ with a |VariableStatement| that has _F_ as a |BindingIdentifier| would not produce any Early Errors for _body_, then
                1. Let _bindingExists_ be *false*.
                1. Set _thisEnv_ to _lexEnv_.
                1. Assert: The following loop will terminate.
                1. Repeat, while _thisEnv_ is not _varEnv_,
                  1. If _thisEnv_ is not an Object Environment Record, then
                    1. If ! _thisEnv_.HasBinding(_F_) is *true*, then
                      1. [id="step-evaldeclarationinstantiation-web-compat-bindingexists", normative-optional] If the host is a web browser or otherwise supports <emu-xref href="#sec-variablestatements-in-catch-blocks" title></emu-xref>, then
                        1. If _thisEnv_ is not the Environment Record for a |Catch| clause, set _bindingExists_ to *true*.
                      1. Else,
                        1. Set _bindingExists_ to *true*.
                  1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].
                1. If _bindingExists_ is *false* and _varEnv_ is a Global Environment Record, then
                  1. If HasLexicalDeclaration(_varEnv_, _F_) is *false*, then
                    1. Let _fnDefinable_ be ? CanDeclareGlobalVar(_varEnv_, _F_).
                  1. Else,
                    1. Let _fnDefinable_ be *false*.
                1. Else,
                  1. Let _fnDefinable_ be *true*.
                1. If _bindingExists_ is *false* and _fnDefinable_ is *true*, then
                  1. If _declaredFunctionOrVarNames_ does not contain _F_, then
                    1. If _varEnv_ is a Global Environment Record, then
                      1. Perform ? CreateGlobalVarBinding(_varEnv_, _F_, *true*).
                    1. Else,
                      1. Set _bindingExists_ to ! _varEnv_.HasBinding(_F_).
                      1. If _bindingExists_ is *false*, then
                        1. Perform ! _varEnv_.CreateMutableBinding(_F_, *true*).
                        1. Perform ! _varEnv_.InitializeBinding(_F_, *undefined*).
                    1. Append _F_ to _declaredFunctionOrVarNames_.
                  1. [id="step-evaldeclarationinstantiation-alt-funcdecl-eval"] When the |FunctionDeclaration| _f_ is evaluated, perform the following steps in place of the |FunctionDeclaration| Evaluation algorithm provided in <emu-xref href="#sec-function-definitions-runtime-semantics-evaluation"></emu-xref>:
                    1. Let _gEnv_ be the running execution context's VariableEnvironment.
                    1. Let _bEnv_ be the running execution context's LexicalEnvironment.
                    1. Let _fObj_ be ! _bEnv_.GetBindingValue(_F_, *false*).
                    1. Perform ? <emu-meta effects="user-code">_gEnv_.SetMutableBinding</emu-meta>(_F_, _fObj_, *false*).
                    1. Return ~unused~.
          1. [id="step-evaldeclarationinstantiation-post-validation"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a Global Environment Record and the global object is a Proxy exotic object.
          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.
          1. For each element _d_ of _lexDeclarations_, do
            1. NOTE: Lexically declared names are only instantiated here but not initialized.
            1. For each element _dn_ of the BoundNames of _d_, do
              1. If IsConstantDeclaration of _d_ is *true*, then
                1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).
              1. Else,
                1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).
          1. For each Parse Node _f_ of _functionsToInitialize_, do
            1. Let _fn_ be the sole element of the BoundNames of _f_.
            1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.
            1. If _varEnv_ is a Global Environment Record, then
              1. Perform ? CreateGlobalFunctionBinding(_varEnv_, _fn_, _fo_, *true*).
            1. Else,
              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_fn_).
              1. If _bindingExists_ is *false*, then
                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href="#step-evaldeclarationinstantiation-post-validation"></emu-xref>.
                1. Perform ! _varEnv_.CreateMutableBinding(_fn_, *true*).
                1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_).
              1. Else,
                1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).
          1. For each String _vn_ of _declaredVarNames_, do
            1. If _varEnv_ is a Global Environment Record, then
              1. Perform ? CreateGlobalVarBinding(_varEnv_, _vn_, *true*).
            1. Else,
              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_vn_).
              1. If _bindingExists_ is *false*, then
                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href="#step-evaldeclarationinstantiation-post-validation"></emu-xref>.
                1. Perform ! _varEnv_.CreateMutableBinding(_vn_, *true*).
                1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-isfinite-number">
      <h1>isFinite ( _number_ )</h1>
      <p>This function is the <dfn>%isFinite%</dfn> intrinsic object.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _num_ be ? ToNumber(_number_).
        1. If _num_ is not finite, return *false*.
        1. Otherwise, return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-isnan-number">
      <h1>isNaN ( _number_ )</h1>
      <p>This function is the <dfn>%isNaN%</dfn> intrinsic object.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _num_ be ? ToNumber(_number_).
        1. If _num_ is *NaN*, return *true*.
        1. Otherwise, return *false*.
      </emu-alg>
      <emu-note>
        <p>A reliable way for ECMAScript code to test if a value `X` is *NaN* is an expression of the form `X !== X`. The result will be *true* if and only if `X` is *NaN*.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parsefloat-string">
      <h1>parseFloat ( _string_ )</h1>
      <p>This function produces a Number value dictated by interpretation of the contents of the _string_ argument as a decimal literal.</p>
      <p>It is the <dfn>%parseFloat%</dfn> intrinsic object.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _inputString_ be ? ToString(_string_).
        1. Let _trimmedString_ be ! TrimString(_inputString_, ~start~).
        1. Let _trimmed_ be StringToCodePoints(_trimmedString_).
        1. Let _trimmedPrefix_ be the longest prefix of _trimmed_ that satisfies the syntax of a |StrDecimalLiteral|, which might be _trimmed_ itself. If there is no such prefix, return *NaN*.
        1. Let _parsedNumber_ be ParseText(_trimmedPrefix_, |StrDecimalLiteral|).
        1. Assert: _parsedNumber_ is a Parse Node.
        1. Return the StringNumericValue of _parsedNumber_.
      </emu-alg>
      <emu-note>
        <p>This function may interpret only a leading portion of _string_ as a Number value; it ignores any code units that cannot be interpreted as part of the notation of a decimal literal, and no indication is given that any such code units were ignored.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-parseint-string-radix">
      <h1>parseInt ( _string_, _radix_ )</h1>
      <p>This function produces an integral Number dictated by interpretation of the contents of _string_ according to the specified _radix_. Leading white space in _string_ is ignored. If _radix_ coerces to 0 (such as when it is *undefined*), it is assumed to be 10 except when the number representation begins with *"0x"* or *"0X"*, in which case it is assumed to be 16. If _radix_ is 16, the number representation may optionally begin with *"0x"* or *"0X"*.</p>
      <p>It is the <dfn>%parseInt%</dfn> intrinsic object.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _inputString_ be ? ToString(_string_).
        1. Let _S_ be ! TrimString(_inputString_, ~start~).
        1. Let _sign_ be 1.
        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.
        1. If _S_ is not empty and the first code unit of _S_ is either the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), set _S_ to the substring of _S_ from index 1.
        1. Let _R_ be ℝ(? ToInt32(_radix_)).
        1. Let _stripPrefix_ be *true*.
        1. If _R_ ≠ 0, then
          1. If _R_ &lt; 2 or _R_ > 36, return *NaN*.
          1. If _R_ ≠ 16, set _stripPrefix_ to *false*.
        1. Else,
          1. Set _R_ to 10.
        1. If _stripPrefix_ is *true*, then
          1. If the length of _S_ is at least 2 and the first two code units of _S_ are either *"0x"* or *"0X"*, then
            1. Set _S_ to the substring of _S_ from index 2.
            1. Set _R_ to 16.
        1. If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise let _end_ be the length of _S_.
        1. Let _Z_ be the substring of _S_ from 0 to _end_.
        1. If _Z_ is empty, return *NaN*.
        1. Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b> through <b>Z</b> and <b>a</b> through <b>z</b> for digits with values 10 through 35. (However, if _R_ = 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not one of 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated integer representing the integer value denoted by _Z_ in radix-_R_ notation.)
        1. If _mathInt_ = 0, then
          1. If _sign_ = -1, return *-0*<sub>𝔽</sub>.
          1. Return *+0*<sub>𝔽</sub>.
        1. Return 𝔽(_sign_ × _mathInt_).
      </emu-alg>
      <emu-note>
        <p>This function may interpret only a leading portion of _string_ as an integer value; it ignores any code units that cannot be interpreted as part of the notation of an integer, and no indication is given that any such code units were ignored.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-uri-handling-functions" oldids="sec-uri-syntax-and-semantics">
      <h1>URI Handling Functions</h1>
      <p>Uniform Resource Identifiers, or URIs, are Strings that identify resources (e.g. web pages or files) and transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language itself does not provide any support for using URIs except for functions that encode and decode URIs as described in this section. `encodeURI` and `decodeURI` are intended to work with complete URIs; they assume that any reserved characters are intended to have special meaning (e.g., as delimiters) and so are not encoded. `encodeURIComponent` and `decodeURIComponent` are intended to work with the individual components of a URI; they assume that any reserved characters represent text and must be encoded to avoid special meaning when the component is part of a complete URI.</p>
      <emu-note>
        <p>The set of reserved characters is based upon RFC 2396 and does not reflect changes introduced by the more recent RFC 3986.</p>
      </emu-note>
      <emu-note>
        <p>Many implementations of ECMAScript provide additional functions and methods that manipulate web pages; these functions are beyond the scope of this standard.</p>
      </emu-note>

      <emu-clause id="sec-decodeuri-encodeduri">
        <h1>decodeURI ( _encodedURI_ )</h1>
        <p>This function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the `encodeURI` function is replaced with the UTF-16 encoding of the code point that it represents. Escape sequences that could not have been introduced by `encodeURI` are not replaced.</p>
        <p>It is the <dfn>%decodeURI%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _uriString_ be ? ToString(_encodedURI_).
          1. Let _preserveEscapeSet_ be *";/?:@&=+$,#"*.
          1. Return ? Decode(_uriString_, _preserveEscapeSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-decodeuricomponent-encodeduricomponent">
        <h1>decodeURIComponent ( _encodedURIComponent_ )</h1>
        <p>This function computes a new version of a URI in which each escape sequence and UTF-8 encoding of the sort that might be introduced by the `encodeURIComponent` function is replaced with the UTF-16 encoding of the code point that it represents.</p>
        <p>It is the <dfn>%decodeURIComponent%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _componentString_ be ? ToString(_encodedURIComponent_).
          1. Let _preserveEscapeSet_ be the empty String.
          1. Return ? Decode(_componentString_, _preserveEscapeSet_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuri-uri">
        <h1>encodeURI ( _uri_ )</h1>
        <p>This function computes a new version of a UTF-16 encoded (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code point.</p>
        <p>It is the <dfn>%encodeURI%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _uriString_ be ? ToString(_uri_).
          1. Let _extraUnescaped_ be *";/?:@&=+$,#"*.
          1. Return ? Encode(_uriString_, _extraUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encodeuricomponent-uricomponent">
        <h1>encodeURIComponent ( _uriComponent_ )</h1>
        <p>This function computes a new version of a UTF-16 encoded (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) URI in which each instance of certain code points is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the code point.</p>
        <p>It is the <dfn>%encodeURIComponent%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _componentString_ be ? ToString(_uriComponent_).
          1. Let _extraUnescaped_ be the empty String.
          1. Return ? Encode(_componentString_, _extraUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-encode" type="abstract operation">
        <h1>
          Encode (
            _string_: a String,
            _extraUnescaped_: a String,
          ): either a normal completion containing a String or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It performs URI encoding and escaping, interpreting _string_ as a sequence of UTF-16 encoded code points as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>. If a character is identified as unreserved in RFC 2396 or appears in _extraUnescaped_, it is not escaped.</dd>
        </dl>
        <emu-alg>
          1. Let _len_ be the length of _string_.
          1. Let _R_ be the empty String.
          1. Let _alwaysUnescaped_ be the string-concatenation of the ASCII word characters and *"-.!~\*'()"*.
          1. Let _unescapedSet_ be the string-concatenation of _alwaysUnescaped_ and _extraUnescaped_.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _C_ be the code unit at index _k_ within _string_.
            1. If _unescapedSet_ contains _C_, then
              1. Set _k_ to _k_ + 1.
              1. Set _R_ to the string-concatenation of _R_ and _C_.
            1. Else,
              1. Let _cp_ be CodePointAt(_string_, _k_).
              1. If _cp_.[[IsUnpairedSurrogate]] is *true*, throw a *URIError* exception.
              1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].
              1. Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _cp_.[[CodePoint]].
              1. For each element _octet_ of _Octets_, do
                1. Let _hex_ be the String representation of _octet_, formatted as an uppercase hexadecimal number.
                1. Set _R_ to the string-concatenation of _R_, *"%"*, and StringPad(_hex_, 2, *"0"*, ~start~).
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>Because percent-encoding is used to represent individual octets, a single code point may be expressed as multiple consecutive escape sequences (one for each of its 8-bit UTF-8 code units).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-decode" type="abstract operation">
        <h1>
          Decode (
            _string_: a String,
            _preserveEscapeSet_: a String,
          ): either a normal completion containing a String or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It performs URI unescaping and decoding, preserving any escape sequences that correspond to Basic Latin characters in _preserveEscapeSet_.</dd>
        </dl>
        <emu-alg>
          1. Let _len_ be the length of _string_.
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _C_ be the code unit at index _k_ within _string_.
            1. Let _S_ be _C_.
            1. If _C_ is the code unit 0x0025 (PERCENT SIGN), then
              1. If _k_ + 3 > _len_, throw a *URIError* exception.
              1. Let _escape_ be the substring of _string_ from _k_ to _k_ + 3.
              1. Let _B_ be ParseHexOctet(_string_, _k_ + 1).
              1. If _B_ is not an integer, throw a *URIError* exception.
              1. Set _k_ to _k_ + 2.
              1. Let _n_ be the number of leading 1 bits in _B_.
              1. If _n_ = 0, then
                1. Let _asciiChar_ be the code unit whose numeric value is _B_.
                1. If _preserveEscapeSet_ contains _asciiChar_, set _S_ to _escape_; otherwise set _S_ to _asciiChar_.
              1. Else,
                1. If _n_ = 1 or _n_ > 4, throw a *URIError* exception.
                1. Let _Octets_ be « _B_ ».
                1. Let _j_ be 1.
                1. Repeat, while _j_ &lt; _n_,
                  1. Set _k_ to _k_ + 1.
                  1. If _k_ + 3 > _len_, throw a *URIError* exception.
                  1. If the code unit at index _k_ within _string_ is not the code unit 0x0025 (PERCENT SIGN), throw a *URIError* exception.
                  1. Let _continuationByte_ be ParseHexOctet(_string_, _k_ + 1).
                  1. If _continuationByte_ is not an integer, throw a *URIError* exception.
                  1. Append _continuationByte_ to _Octets_.
                  1. Set _k_ to _k_ + 2.
                  1. Set _j_ to _j_ + 1.
                1. Assert: The length of _Octets_ is _n_.
                1. If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.
                1. Let _V_ be the code point obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.
                1. Set _S_ to UTF16EncodeCodePoint(_V_).
            1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example, the invalid sequence 0xC0 0x80 must not decode into the code unit 0x0000. Implementations of the Decode algorithm are required to throw a *URIError* when encountering such invalid sequences.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-parsehexoctet" type="abstract operation">
        <h1>
          ParseHexOctet (
            _string_: a String,
            _position_: a non-negative integer,
          ): either a non-negative integer or a non-empty List of *SyntaxError* objects
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It parses a sequence of two hexadecimal characters at the specified _position_ in _string_ into an unsigned 8-bit integer.</dd>
        </dl>
        <emu-alg>
          1. Let _len_ be the length of _string_.
          1. Assert: _position_ + 2 ≤ _len_.
          1. Let _hexDigits_ be the substring of _string_ from _position_ to _position_ + 2.
          1. Let _parseResult_ be ParseText(_hexDigits_, |HexDigits[~Sep]|).
          1. If _parseResult_ is not a Parse Node, return _parseResult_.
          1. Let _n_ be the MV of _parseResult_.
          1. Assert: _n_ is in the inclusive interval from 0 to 255.
          1. Return _n_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-constructor-properties-of-the-global-object">
    <h1>Constructor Properties of the Global Object</h1>

    <emu-clause id="sec-constructor-properties-of-the-global-object-aggregate-error">
      <h1>AggregateError ( . . . )</h1>
      <p>See <emu-xref href="#sec-aggregate-error-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-array">
      <h1>Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-array-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-arraybuffer">
      <h1>ArrayBuffer ( . . . )</h1>
      <p>See <emu-xref href="#sec-arraybuffer-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint">
      <h1>BigInt ( . . . )</h1>
      <p>See <emu-xref href="#sec-bigint-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-bigint64array">
      <h1>BigInt64Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-biguint64array">
      <h1>BigUint64Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-boolean">
      <h1>Boolean ( . . . )</h1>
      <p>See <emu-xref href="#sec-boolean-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-dataview">
      <h1>DataView ( . . . )</h1>
      <p>See <emu-xref href="#sec-dataview-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-date">
      <h1>Date ( . . . )</h1>
      <p>See <emu-xref href="#sec-date-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-error">
      <h1>Error ( . . . )</h1>
      <p>See <emu-xref href="#sec-error-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-evalerror">
      <h1>EvalError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-evalerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-finalization-registry" oldids="sec-constructor-properties-of-the-global-object-finnalization-registry">
      <h1>FinalizationRegistry ( . . . )</h1>
      <p>See <emu-xref href="#sec-finalization-registry-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-float16array">
      <h1>Float16Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-float32array">
      <h1>Float32Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-float64array">
      <h1>Float64Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-function">
      <h1>Function ( . . . )</h1>
      <p>See <emu-xref href="#sec-function-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-int8array">
      <h1>Int8Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-int16array">
      <h1>Int16Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-int32array">
      <h1>Int32Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-iterator">
      <h1>Iterator ( . . . )</h1>
      <p>See <emu-xref href="#sec-iterator-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-map">
      <h1>Map ( . . . )</h1>
      <p>See <emu-xref href="#sec-map-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-number">
      <h1>Number ( . . . )</h1>
      <p>See <emu-xref href="#sec-number-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-object">
      <h1>Object ( . . . )</h1>
      <p>See <emu-xref href="#sec-object-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-promise">
      <h1>Promise ( . . . )</h1>
      <p>See <emu-xref href="#sec-promise-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-proxy">
      <h1>Proxy ( . . . )</h1>
      <p>See <emu-xref href="#sec-proxy-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-rangeerror">
      <h1>RangeError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-rangeerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-referenceerror">
      <h1>ReferenceError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-referenceerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-regexp">
      <h1>RegExp ( . . . )</h1>
      <p>See <emu-xref href="#sec-regexp-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-set">
      <h1>Set ( . . . )</h1>
      <p>See <emu-xref href="#sec-set-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-sharedarraybuffer">
      <h1>SharedArrayBuffer ( . . . )</h1>
      <p>See <emu-xref href="#sec-sharedarraybuffer-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-string">
      <h1>String ( . . . )</h1>
      <p>See <emu-xref href="#sec-string-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-symbol">
      <h1>Symbol ( . . . )</h1>
      <p>See <emu-xref href="#sec-symbol-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-syntaxerror">
      <h1>SyntaxError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-syntaxerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-typeerror">
      <h1>TypeError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-typeerror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint8array">
      <h1>Uint8Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint8clampedarray">
      <h1>Uint8ClampedArray ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint16array">
      <h1>Uint16Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-uint32array">
      <h1>Uint32Array ( . . . )</h1>
      <p>See <emu-xref href="#sec-typedarray-constructors"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-urierror">
      <h1>URIError ( . . . )</h1>
      <p>See <emu-xref href="#sec-native-error-types-used-in-this-standard-urierror"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakmap">
      <h1>WeakMap ( . . . )</h1>
      <p>See <emu-xref href="#sec-weakmap-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakref">
      <h1>WeakRef ( . . . )</h1>
      <p>See <emu-xref href="#sec-weak-ref-constructor"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-global-object-weakset">
      <h1>WeakSet ( . . . )</h1>
      <p>See <emu-xref href="#sec-weakset-objects"></emu-xref>.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-other-properties-of-the-global-object">
    <h1>Other Properties of the Global Object</h1>

    <emu-clause id="sec-atomics">
      <h1>Atomics</h1>
      <p>See <emu-xref href="#sec-atomics-object"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-json">
      <h1>JSON</h1>
      <p>See <emu-xref href="#sec-json-object"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-math">
      <h1>Math</h1>
      <p>See <emu-xref href="#sec-math-object"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-reflect">
      <h1>Reflect</h1>
      <p>See <emu-xref href="#sec-reflect-object"></emu-xref>.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-fundamental-objects">
  <h1>Fundamental Objects</h1>

  <emu-clause id="sec-object-objects">
    <h1>Object Objects</h1>

    <emu-clause id="sec-object-constructor">
      <h1>The Object Constructor</h1>
      <p>The Object constructor:</p>
      <ul>
        <li>is <dfn>%Object%</dfn>.</li>
        <li>is the initial value of the *"Object"* property of the global object.</li>
        <li>creates a new ordinary object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>may be used as the value of an `extends` clause of a class definition.</li>
      </ul>

      <emu-clause id="sec-object-value">
        <h1>Object ( [ _value_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is neither *undefined* nor the active function object, then
            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*).
          1. If _value_ is either *undefined* or *null*, return OrdinaryObjectCreate(%Object.prototype%).
          1. Return ! ToObject(_value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-constructor">
      <h1>Properties of the Object Constructor</h1>
      <p>The Object constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has the following additional properties:</li>
      </ul>

      <emu-clause id="sec-object.assign">
        <h1>Object.assign ( _target_, ..._sources_ )</h1>
        <p>This function copies the values of all of the enumerable own properties from one or more source objects to a _target_ object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _to_ be ? ToObject(_target_).
          1. If only one argument was passed, return _to_.
          1. For each element _nextSource_ of _sources_, do
            1. If _nextSource_ is neither *undefined* nor *null*, then
              1. Let _from_ be ! ToObject(_nextSource_).
              1. Let _keys_ be ? <emu-meta effects="user-code">_from_.[[OwnPropertyKeys]]()</emu-meta>.
              1. For each element _nextKey_ of _keys_, do
                1. Let _desc_ be ? <emu-meta effects="user-code">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_).
                1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then
                  1. Let _propValue_ be ? Get(_from_, _nextKey_).
                  1. Perform ? Set(_to_, _nextKey_, _propValue_, *true*).
          1. Return _to_.
        </emu-alg>
        <p>The *"length"* property of this function is *2*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-object.create">
        <h1>Object.create ( _O_, _Properties_ )</h1>
        <p>This function creates a new object with a specified prototype.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object and _O_ is not *null*, throw a *TypeError* exception.
          1. Let _obj_ be OrdinaryObjectCreate(_O_).
          1. If _Properties_ is not *undefined*, then
            1. Return ? ObjectDefineProperties(_obj_, _Properties_).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.defineproperties">
        <h1>Object.defineProperties ( _O_, _Properties_ )</h1>
        <p>This function adds own properties and/or updates the attributes of existing own properties of an object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Return ? ObjectDefineProperties(_O_, _Properties_).
        </emu-alg>

        <emu-clause id="sec-objectdefineproperties" type="abstract operation">
          <h1>
            ObjectDefineProperties (
              _O_: an Object,
              _Properties_: an ECMAScript language value,
            ): either a normal completion containing an Object or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _props_ be ? ToObject(_Properties_).
            1. Let _keys_ be ? <emu-meta effects="user-code">_props_.[[OwnPropertyKeys]]()</emu-meta>.
            1. Let _descriptors_ be a new empty List.
            1. For each element _nextKey_ of _keys_, do
              1. Let _propDesc_ be ? <emu-meta effects="user-code">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_).
              1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then
                1. Let _descObj_ be ? Get(_props_, _nextKey_).
                1. Let _desc_ be ? ToPropertyDescriptor(_descObj_).
                1. Append the Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } to _descriptors_.
            1. For each element _property_ of _descriptors_, do
              1. Perform ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.defineproperty">
        <h1>Object.defineProperty ( _O_, _P_, _Attributes_ )</h1>
        <p>This function adds an own property and/or updates the attributes of an existing own property of an object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Let _desc_ be ? ToPropertyDescriptor(_Attributes_).
          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.entries">
        <h1>Object.entries ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _entryList_ be ? EnumerableOwnProperties(_obj_, ~key+value~).
          1. Return CreateArrayFromList(_entryList_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.freeze">
        <h1>Object.freeze ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, return _O_.
          1. Let _status_ be ? SetIntegrityLevel(_O_, ~frozen~).
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.fromentries" oldids="sec-create-data-property-on-object-functions">
        <h1>Object.fromEntries ( _iterable_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_iterable_).
          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Assert: _obj_ is an extensible ordinary object with no own properties.
          1. Let _closure_ be a new Abstract Closure with parameters (_key_, _value_) that captures _obj_ and performs the following steps when called:
            1. Let _propertyKey_ be ? ToPropertyKey(_key_).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_).
            1. Return NormalCompletion(*undefined*).
          1. Let _adder_ be CreateBuiltinFunction(_closure_, 2, *""*, « »).
          1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          The function created for _adder_ is never directly accessible to ECMAScript code.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptor">
        <h1>Object.getOwnPropertyDescriptor ( _O_, _P_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Let _desc_ be ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_).
          1. Return FromPropertyDescriptor(_desc_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertydescriptors">
        <h1>Object.getOwnPropertyDescriptors ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _ownKeys_ be ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta>.
          1. Let _descriptors_ be OrdinaryObjectCreate(%Object.prototype%).
          1. For each element _key_ of _ownKeys_, do
            1. Let _desc_ be ? <emu-meta effects="user-code">_obj_.[[GetOwnProperty]]</emu-meta>(_key_).
            1. Let _descriptor_ be FromPropertyDescriptor(_desc_).
            1. If _descriptor_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_).
          1. Return _descriptors_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertynames">
        <h1>Object.getOwnPropertyNames ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.getownpropertysymbols">
        <h1>Object.getOwnPropertySymbols ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)).
        </emu-alg>

        <emu-clause id="sec-getownpropertykeys" type="abstract operation">
          <h1>
            GetOwnPropertyKeys (
              _O_: an ECMAScript language value,
              _type_: ~string~ or ~symbol~,
            ): either a normal completion containing a List of property keys or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _obj_ be ? ToObject(_O_).
            1. Let _keys_ be ? <emu-meta effects="user-code">_obj_.[[OwnPropertyKeys]]()</emu-meta>.
            1. Let _nameList_ be a new empty List.
            1. For each element _nextKey_ of _keys_, do
              1. If _nextKey_ is a Symbol and _type_ is ~symbol~, or if _nextKey_ is a String and _type_ is ~string~, then
                1. Append _nextKey_ to _nameList_.
            1. Return _nameList_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.getprototypeof">
        <h1>Object.getPrototypeOf ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Return ? <emu-meta effects="user-code">_obj_.[[GetPrototypeOf]]()</emu-meta>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.groupby">
        <h1>Object.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts two arguments. `groupBy` calls _callback_ once for each element in _items_, in ascending order, and constructs a new object. Each value returned by _callback_ is coerced to a property key. For each such property key, the result object has a property whose key is that property key and whose value is an array containing all the elements for which the _callback_ return value coerced to that key.</p>
          <p>_callback_ is called with two arguments: the value of the element and the index of the element.</p>
          <p>The return value of `groupBy` is an object that does not inherit from %Object.prototype%.</p>
        </emu-note>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _groups_ be ? GroupBy(_items_, _callback_, ~property~).
          1. Let _obj_ be OrdinaryObjectCreate(*null*).
          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do
            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.hasown">
        <h1>Object.hasOwn ( _O_, _P_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _key_ be ? ToPropertyKey(_P_).
          1. Return ? HasOwnProperty(_obj_, _key_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.is">
        <h1>Object.is ( _value1_, _value2_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return SameValue(_value1_, _value2_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isextensible">
        <h1>Object.isExtensible ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, return *false*.
          1. Return ? IsExtensible(_O_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.isfrozen">
        <h1>Object.isFrozen ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, return *true*.
          1. Return ? TestIntegrityLevel(_O_, ~frozen~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.issealed">
        <h1>Object.isSealed ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, return *true*.
          1. Return ? TestIntegrityLevel(_O_, ~sealed~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.keys">
        <h1>Object.keys ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _keyList_ be ? EnumerableOwnProperties(_obj_, ~key~).
          1. Return CreateArrayFromList(_keyList_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.preventextensions">
        <h1>Object.preventExtensions ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, return _O_.
          1. Let _status_ be ? <emu-meta effects="user-code">_O_.[[PreventExtensions]]()</emu-meta>.
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype">
        <h1>Object.prototype</h1>
        <p>The initial value of `Object.prototype` is the Object prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-object.seal">
        <h1>Object.seal ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _O_ is not an Object, return _O_.
          1. Let _status_ be ? SetIntegrityLevel(_O_, ~sealed~).
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.setprototypeof">
        <h1>Object.setPrototypeOf ( _O_, _proto_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.
          1. If _O_ is not an Object, return _O_.
          1. Let _status_ be ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_).
          1. If _status_ is *false*, throw a *TypeError* exception.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.values">
        <h1>Object.values ( _O_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _obj_ be ? ToObject(_O_).
          1. Let _valueList_ be ? EnumerableOwnProperties(_obj_, ~value~).
          1. Return CreateArrayFromList(_valueList_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-object-prototype-object" oldids="sec-additional-properties-of-the-object.prototype-object">
      <h1>Properties of the Object Prototype Object</h1>
      <p>The <dfn>Object prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Object.prototype%</dfn>.</li>
        <li>has an [[Extensible]] internal slot whose value is *true*.</li>
        <li>has the internal methods defined for ordinary objects, except for the [[SetPrototypeOf]] method, which is as defined in <emu-xref href="#sec-immutable-prototype-exotic-objects-setprototypeof-v"></emu-xref>. (Thus, it is an immutable prototype exotic object.)</li>
        <li>has a [[Prototype]] internal slot whose value is *null*.</li>
      </ul>

      <emu-clause id="sec-object.prototype.constructor">
        <h1>Object.prototype.constructor</h1>
        <p>The initial value of `Object.prototype.constructor` is %Object%.</p>
      </emu-clause>

      <emu-clause id="sec-object.prototype.hasownproperty">
        <h1>Object.prototype.hasOwnProperty ( _V_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. [id="step-hasownproperty-topropertykey"] Let _P_ be ? ToPropertyKey(_V_).
          1. [id="step-hasownproperty-toobject"] Let _O_ be ? ToObject(*this* value).
          1. Return ? HasOwnProperty(_O_, _P_).
        </emu-alg>
        <emu-note>
          <p>The ordering of steps <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> and <emu-xref href="#step-hasownproperty-toobject"></emu-xref> is chosen to ensure that any exception that would have been thrown by step <emu-xref href="#step-hasownproperty-topropertykey"></emu-xref> in previous editions of this specification will continue to be thrown even if the *this* value is *undefined* or *null*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.isprototypeof">
        <h1>Object.prototype.isPrototypeOf ( _V_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. [id="step-isprototypeof-check-object"] If _V_ is not an Object, return *false*.
          1. [id="step-isprototypeof-toobject"] Let _O_ be ? ToObject(*this* value).
          1. Repeat,
            1. Set _V_ to ? <emu-meta effects="user-code">_V_.[[GetPrototypeOf]]()</emu-meta>.
            1. If _V_ is *null*, return *false*.
            1. If SameValue(_O_, _V_) is *true*, return *true*.
        </emu-alg>
        <emu-note>
          <p>The ordering of steps <emu-xref href="#step-isprototypeof-check-object"></emu-xref> and <emu-xref href="#step-isprototypeof-toobject"></emu-xref> preserves the behaviour specified by previous editions of this specification for the case where _V_ is not an object and the *this* value is *undefined* or *null*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.propertyisenumerable">
        <h1>Object.prototype.propertyIsEnumerable ( _V_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. [id="step-propertyisenumerable-topropertykey"] Let _P_ be ? ToPropertyKey(_V_).
          1. [id="step-propertyisenumerable-toobject"] Let _O_ be ? ToObject(*this* value).
          1. Let _desc_ be ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_).
          1. If _desc_ is *undefined*, return *false*.
          1. Return _desc_.[[Enumerable]].
        </emu-alg>
        <emu-note>
          <p>This method does not consider objects in the prototype chain.</p>
        </emu-note>
        <emu-note>
          <p>The ordering of steps <emu-xref href="#step-propertyisenumerable-topropertykey"></emu-xref> and <emu-xref href="#step-propertyisenumerable-toobject"></emu-xref> is chosen to ensure that any exception that would have been thrown by step <emu-xref href="#step-propertyisenumerable-topropertykey"></emu-xref> in previous editions of this specification will continue to be thrown even if the *this* value is *undefined* or *null*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tolocalestring">
        <h1>Object.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Return ? Invoke(_O_, *"toString"*).
        </emu-alg>
        <p>The optional parameters to this method are not used but are intended to correspond to the parameter pattern used by ECMA-402 `toLocaleString` methods. Implementations that do not include ECMA-402 support must not use those parameter positions for other purposes.</p>
        <emu-note>
          <p>This method provides a generic `toLocaleString` implementation for objects that have no locale-sensitive `toString` behaviour. `Array`, `Number`, `Date`, and %TypedArray% provide their own locale-sensitive `toLocaleString` methods.</p>
        </emu-note>
        <emu-note>
          <p>ECMA-402 intentionally does not provide an alternative to this default implementation.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.tostring">
        <h1>Object.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If the *this* value is *undefined*, return *"[object Undefined]"*.
          1. If the *this* value is *null*, return *"[object Null]"*.
          1. Let _O_ be ! ToObject(*this* value).
          1. Let _isArray_ be ? IsArray(_O_).
          1. If _isArray_ is *true*, let _builtinTag_ be *"Array"*.
          1. Else if _O_ has a [[ParameterMap]] internal slot, let _builtinTag_ be *"Arguments"*.
          1. Else if _O_ has a [[Call]] internal method, let _builtinTag_ be *"Function"*.
          1. Else if _O_ has an [[ErrorData]] internal slot, let _builtinTag_ be *"Error"*.
          1. Else if _O_ has a [[BooleanData]] internal slot, let _builtinTag_ be *"Boolean"*.
          1. Else if _O_ has a [[NumberData]] internal slot, let _builtinTag_ be *"Number"*.
          1. Else if _O_ has a [[StringData]] internal slot, let _builtinTag_ be *"String"*.
          1. Else if _O_ has a [[DateValue]] internal slot, let _builtinTag_ be *"Date"*.
          1. Else if _O_ has a [[RegExpMatcher]] internal slot, let _builtinTag_ be *"RegExp"*.
          1. Else, let _builtinTag_ be *"Object"*.
          1. Let _tag_ be ? Get(_O_, %Symbol.toStringTag%).
          1. If _tag_ is not a String, set _tag_ to _builtinTag_.
          1. Return the string-concatenation of *"[object "*, _tag_, and *"]"*.
        </emu-alg>
        <emu-note>
          <p>Historically, this method was occasionally used to access the String value of the [[Class]] internal slot that was used in previous editions of this specification as a nominal type tag for various built-in objects. The above definition of `toString` preserves compatibility for legacy code that uses `toString` as a test for those specific kinds of built-in objects. It does not provide a reliable type testing mechanism for other kinds of built-in or program defined objects. In addition, programs can use %Symbol.toStringTag% in ways that will invalidate the reliability of such legacy type tests.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-object.prototype.valueof">
        <h1>Object.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ToObject(*this* value).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-object.prototype.__proto__" legacy normative-optional>
        <h1>Object.prototype.__proto__</h1>
        <p>`Object.prototype.__proto__` is an accessor property with attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }. The [[Get]] and [[Set]] attributes are defined as follows:</p>

        <emu-clause id="sec-get-object.prototype.__proto__">
          <h1>get Object.prototype.__proto__</h1>
          <p>The value of the [[Get]] attribute is a built-in function that requires no arguments. It performs the following steps when called:</p>
          <emu-alg>
            1. Let _O_ be ? ToObject(*this* value).
            1. Return ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-object.prototype.__proto__">
          <h1>set Object.prototype.__proto__</h1>
          <p>The value of the [[Set]] attribute is a built-in function that takes an argument _proto_. It performs the following steps when called:</p>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Perform ? RequireObjectCoercible(_O_).
            1. If _proto_ is not an Object and _proto_ is not *null*, return *undefined*.
            1. If _O_ is not an Object, return *undefined*.
            1. Let _status_ be ? <emu-meta effects="user-code">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_).
            1. If _status_ is *false*, throw a *TypeError* exception.
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object.prototype-legacy-accessor-methods" legacy normative-optional>
        <h1>Legacy Object.prototype Accessor Methods</h1>

        <emu-clause id="sec-object.prototype.__defineGetter__">
          <h1>Object.prototype.__defineGetter__ ( _P_, _getter_ )</h1>
          <p>This method performs the following steps when called:</p>
          <emu-alg>
            1. Let _O_ be ? ToObject(*this* value).
            1. If IsCallable(_getter_) is *false*, throw a *TypeError* exception.
            1. Let _desc_ be PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
            1. Let _key_ be ? ToPropertyKey(_P_).
            1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__defineSetter__">
          <h1>Object.prototype.__defineSetter__ ( _P_, _setter_ )</h1>
          <p>This method performs the following steps when called:</p>
          <emu-alg>
            1. Let _O_ be ? ToObject(*this* value).
            1. If IsCallable(_setter_) is *false*, throw a *TypeError* exception.
            1. Let _desc_ be PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
            1. Let _key_ be ? ToPropertyKey(_P_).
            1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupGetter__">
          <h1>Object.prototype.__lookupGetter__ ( _P_ )</h1>
          <p>This method performs the following steps when called:</p>
          <emu-alg>
            1. Let _O_ be ? ToObject(*this* value).
            1. Let _key_ be ? ToPropertyKey(_P_).
            1. Repeat,
              1. Let _desc_ be ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_).
              1. If _desc_ is not *undefined*, then
                1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Get]].
                1. Return *undefined*.
              1. Set _O_ to ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>.
              1. If _O_ is *null*, return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-object.prototype.__lookupSetter__">
          <h1>Object.prototype.__lookupSetter__ ( _P_ )</h1>
          <p>This method performs the following steps when called:</p>
          <emu-alg>
            1. Let _O_ be ? ToObject(*this* value).
            1. Let _key_ be ? ToPropertyKey(_P_).
            1. Repeat,
              1. Let _desc_ be ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_key_).
              1. If _desc_ is not *undefined*, then
                1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Set]].
                1. Return *undefined*.
              1. Set _O_ to ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>.
              1. If _O_ is *null*, return *undefined*.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-object-instances">
      <h1>Properties of Object Instances</h1>
      <p>Object instances have no special properties beyond those inherited from the Object prototype object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-function-objects">
    <h1>Function Objects</h1>

    <emu-clause id="sec-function-constructor">
      <h1>The Function Constructor</h1>
      <p>The Function constructor:</p>
      <ul>
        <li>is <dfn>%Function%</dfn>.</li>
        <li>is the initial value of the *"Function"* property of the global object.</li>
        <li>creates and initializes a new function object when called as a function rather than as a constructor. Thus the function call `Function(…)` is equivalent to the object creation expression `new Function(…)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Function behaviour must include a `super` call to the Function constructor to create and initialize a subclass instance with the internal slots necessary for built-in function behaviour. All ECMAScript syntactic forms for defining function objects create instances of Function. There is no syntactic means to create instances of Function subclasses except for the built-in GeneratorFunction, AsyncFunction, and AsyncGeneratorFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-function-p1-p2-pn-body">
        <h1>Function ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of a function; any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_).
        </emu-alg>
        <emu-note>
          <p>It is permissible but not necessary to have one argument for each formal parameter to be specified. For example, all three of the following expressions produce the same result:</p>
          <pre><code class="javascript">
            new Function("a", "b", "c", "return a+b+c")
            new Function("a, b, c", "return a+b+c")
            new Function("a,b", "c", "return a+b+c")
          </code></pre>
        </emu-note>

        <emu-clause id="sec-createdynamicfunction" type="abstract operation" oldids="table-dynamic-function-sourcetext-prefixes">
          <h1>
            CreateDynamicFunction (
              _constructor_: a constructor,
              _newTarget_: a constructor or *undefined*,
              _kind_: ~normal~, ~generator~, ~async~, or ~async-generator~,
              _parameterArgs_: a List of ECMAScript language values,
              _bodyArg_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript function object or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>_constructor_ is the constructor function that is performing this action. _newTarget_ is the constructor that `new` was initially applied to. _parameterArgs_ and _bodyArg_ reflect the argument values that were passed to _constructor_.</dd>
          </dl>
          <emu-alg>
            1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.
            1. If _kind_ is ~normal~, then
              1. Let _prefix_ be *"function"*.
              1. Let _exprSym_ be the grammar symbol |FunctionExpression|.
              1. Let _bodySym_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.
              1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.
              1. Let _fallbackProto_ be *"%Function.prototype%"*.
            1. Else if _kind_ is ~generator~, then
              1. Let _prefix_ be *"function\*"*.
              1. Let _exprSym_ be the grammar symbol |GeneratorExpression|.
              1. Let _bodySym_ be the grammar symbol |GeneratorBody|.
              1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.
              1. Let _fallbackProto_ be *"%GeneratorFunction.prototype%"*.
            1. Else if _kind_ is ~async~, then
              1. Let _prefix_ be *"async function"*.
              1. Let _exprSym_ be the grammar symbol |AsyncFunctionExpression|.
              1. Let _bodySym_ be the grammar symbol |AsyncFunctionBody|.
              1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, +Await]|.
              1. Let _fallbackProto_ be *"%AsyncFunction.prototype%"*.
            1. Else,
              1. Assert: _kind_ is ~async-generator~.
              1. Let _prefix_ be *"async function\*"*.
              1. Let _exprSym_ be the grammar symbol |AsyncGeneratorExpression|.
              1. Let _bodySym_ be the grammar symbol |AsyncGeneratorBody|.
              1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, +Await]|.
              1. Let _fallbackProto_ be *"%AsyncGeneratorFunction.prototype%"*.
            1. Let _argCount_ be the number of elements in _parameterArgs_.
            1. Let _parameterStrings_ be a new empty List.
            1. For each element _arg_ of _parameterArgs_, do
              1. Append ? ToString(_arg_) to _parameterStrings_.
            1. Let _bodyString_ be ? ToString(_bodyArg_).
            1. Let _currentRealm_ be the current Realm Record.
            1. Perform ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*).
            1. Let _P_ be the empty String.
            1. If _argCount_ > 0, then
              1. Set _P_ to _parameterStrings_[0].
              1. Let _k_ be 1.
              1. Repeat, while _k_ &lt; _argCount_,
                1. Let _nextArgString_ be _parameterStrings_[_k_].
                1. Set _P_ to the string-concatenation of _P_, *","* (a comma), and _nextArgString_.
                1. Set _k_ to _k_ + 1.
            1. Let _bodyParseString_ be the string-concatenation of 0x000A (LINE FEED), _bodyString_, and 0x000A (LINE FEED).
            1. Let _sourceString_ be the string-concatenation of _prefix_, *" anonymous("*, _P_, 0x000A (LINE FEED), *") {"*, _bodyParseString_, and *"}"*.
            1. Let _sourceText_ be StringToCodePoints(_sourceString_).
            1. Let _parameters_ be ParseText(_P_, _parameterSym_).
            1. If _parameters_ is a List of errors, throw a *SyntaxError* exception.
            1. Let _body_ be ParseText(_bodyParseString_, _bodySym_).
            1. If _body_ is a List of errors, throw a *SyntaxError* exception.
            1. NOTE: The parameters and body are parsed separately to ensure that each is valid alone. For example, `new Function("/*", "*/ ) {")` does not evaluate to a function.
            1. NOTE: If this step is reached, _sourceText_ must have the syntax of _exprSym_ (although the reverse implication does not hold). The purpose of the next two steps is to enforce any Early Error rules which apply to _exprSym_ directly.
            1. Let _expr_ be ParseText(_sourceText_, _exprSym_).
            1. If _expr_ is a List of errors, throw a *SyntaxError* exception.
            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).
            1. Let _env_ be _currentRealm_.[[GlobalEnv]].
            1. Let _privateEnv_ be *null*.
            1. Let _F_ be OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_).
            1. Perform SetFunctionName(_F_, *"anonymous"*).
            1. If _kind_ is ~generator~, then
              1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorPrototype%).
              1. Perform ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ is ~async-generator~, then
              1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorPrototype%).
              1. Perform ! DefinePropertyOrThrow(_F_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
            1. Else if _kind_ is ~normal~, then
              1. Perform MakeConstructor(_F_).
            1. NOTE: Functions whose _kind_ is ~async~ are not constructable and do not have a [[Construct]] internal method or a *"prototype"* property.
            1. Return _F_.
          </emu-alg>
          <emu-note>
            <p>CreateDynamicFunction defines a *"prototype"* property on any function it creates whose _kind_ is not ~async~ to provide for the possibility that the function will be used as a constructor.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-constructor">
      <h1>Properties of the Function Constructor</h1>
      <p>The Function constructor:</p>
      <ul>
        <li>is itself a built-in function object.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li oldids="sec-function.length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-function.prototype">
        <h1>Function.prototype</h1>
        <p>The value of `Function.prototype` is the Function prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-function-prototype-object">
      <h1>Properties of the Function Prototype Object</h1>
      <p>The <dfn>Function prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Function.prototype%</dfn>.</li>
        <li>is itself a built-in function object.</li>
        <li>accepts any arguments and returns *undefined* when invoked.</li>
        <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>does not have a *"prototype"* property.</li>
        <li>has a *"length"* property whose value is *+0*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is the empty String.</li>
      </ul>
      <emu-note>
        <p>The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p>
      </emu-note>

      <emu-clause id="sec-function.prototype.apply">
        <h1>Function.prototype.apply ( _thisArg_, _argArray_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _func_ be the *this* value.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. If _argArray_ is either *undefined* or *null*, then
            1. Perform PrepareForTailCall().
            1. Return ? Call(_func_, _thisArg_).
          1. Let _argList_ be ? CreateListFromArrayLike(_argArray_).
          1. Perform PrepareForTailCall().
          1. [id="step-function-proto-apply-call"] Return ? Call(_func_, _thisArg_, _argList_).
        </emu-alg>
        <emu-note>
          <p>The _thisArg_ value is passed without modification as the *this* value. This is a change from Edition 3, where an *undefined* or *null* _thisArg_ is replaced with the global object and ToObject is applied to all other values and that result is passed as the *this* value. Even though the _thisArg_ is passed without modification, non-strict functions still perform these transformations upon entry to the function.</p>
        </emu-note>
        <emu-note>
          <p>If _func_ is either an arrow function or a bound function exotic object, then the _thisArg_ will be ignored by the function [[Call]] in step <emu-xref href="#step-function-proto-apply-call"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.bind">
        <h1>Function.prototype.bind ( _thisArg_, ..._args_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _Target_ be the *this* value.
          1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.
          1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).
          1. Let _L_ be 0.
          1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, *"length"*).
          1. If _targetHasLength_ is *true*, then
            1. Let _targetLen_ be ? Get(_Target_, *"length"*).
            1. If _targetLen_ is a Number, then
              1. If _targetLen_ is *+∞*<sub>𝔽</sub>, then
                1. Set _L_ to +∞.
              1. Else if _targetLen_ is *-∞*<sub>𝔽</sub>, then
                1. Set _L_ to 0.
              1. Else,
                1. Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).
                1. Assert: _targetLenAsInt_ is finite.
                1. Let _argCount_ be the number of elements in _args_.
                1. Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).
          1. Perform SetFunctionLength(_F_, _L_).
          1. Let _targetName_ be ? Get(_Target_, *"name"*).
          1. If _targetName_ is not a String, set _targetName_ to the empty String.
          1. Perform SetFunctionName(_F_, _targetName_, *"bound"*).
          1. Return _F_.
        </emu-alg>
        <emu-note>
          <p>Function objects created using `Function.prototype.bind` are exotic objects. They also do not have a *"prototype"* property.</p>
        </emu-note>
        <emu-note>
          <p>If _Target_ is either an arrow function or a bound function exotic object, then the _thisArg_ passed to this method will not be used by subsequent calls to _F_.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.call">
        <h1>Function.prototype.call ( _thisArg_, ..._args_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _func_ be the *this* value.
          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.
          1. Perform PrepareForTailCall().
          1. [id="step-function-proto-call-call"] Return ? Call(_func_, _thisArg_, _args_).
        </emu-alg>
        <emu-note>
          <p>The _thisArg_ value is passed without modification as the *this* value. This is a change from Edition 3, where an *undefined* or *null* _thisArg_ is replaced with the global object and ToObject is applied to all other values and that result is passed as the *this* value. Even though the _thisArg_ is passed without modification, non-strict functions still perform these transformations upon entry to the function.</p>
        </emu-note>
        <emu-note>
          <p>If _func_ is either an arrow function or a bound function exotic object, then the _thisArg_ will be ignored by the function [[Call]] in step <emu-xref href="#step-function-proto-call-call"></emu-xref>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-function.prototype.constructor">
        <h1>Function.prototype.constructor</h1>
        <p>The initial value of `Function.prototype.constructor` is %Function%.</p>
      </emu-clause>

      <emu-clause id="sec-function.prototype.tostring">
        <h1>Function.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _func_ be the *this* value.
          1. If _func_ is an Object, _func_ has a [[SourceText]] internal slot, _func_.[[SourceText]] is a sequence of Unicode code points, and HostHasSourceTextAvailable(_func_) is *true*, then
            1. Return CodePointsToString(_func_.[[SourceText]]).
          1. If _func_ is a <emu-xref href="#sec-built-in-function-objects">built-in function object</emu-xref>, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ has an [[InitialName]] internal slot and _func_.[[InitialName]] is a String, the portion of the returned String that would be matched by |NativeFunctionAccessor?| |PropertyName| must be _func_.[[InitialName]].
          1. If _func_ is an Object and IsCallable(_func_) is *true*, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.
          1. Throw a *TypeError* exception.
        </emu-alg>

        <emu-grammar type="definition">
          NativeFunction :
            `function` NativeFunctionAccessor? PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`

          NativeFunctionAccessor :
            `get`
            `set`
        </emu-grammar>
      </emu-clause>

      <emu-clause oldids="sec-function.prototype-@@hasinstance" id="sec-function.prototype-%symbol.hasinstance%">
        <h1>Function.prototype [ %Symbol.hasInstance% ] ( _V_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _F_ be the *this* value.
          1. Return ? OrdinaryHasInstance(_F_, _V_).
        </emu-alg>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>This is the default implementation of `%Symbol.hasInstance%` that most functions inherit. `%Symbol.hasInstance%` is called by the `instanceof` operator to determine whether a value is an instance of a specific constructor. An expression such as</p>
          <pre><code class="javascript">
            v instanceof F
          </code></pre>
          <p>evaluates as</p>
          <pre><code class="javascript">
            F[%Symbol.hasInstance%](v)
          </code></pre>
          <p>A constructor function can control which objects are recognized as its instances by `instanceof` by exposing a different `%Symbol.hasInstance%` method on the function.</p>
        </emu-note>
        <p>This property is non-writable and non-configurable to prevent tampering that could be used to globally expose the target function of a bound function.</p>
        <p>The value of the *"name"* property of this method is *"[Symbol.hasInstance]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-instances">
      <h1>Function Instances</h1>
      <p>Every Function instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. Function objects created using the `Function.prototype.bind` method (<emu-xref href="#sec-function.prototype.bind"></emu-xref>) have the internal slots listed in <emu-xref href="#table-internal-slots-of-bound-function-exotic-objects"></emu-xref>.</p>
      <p>Function instances have the following properties:</p>

      <emu-clause id="sec-function-instances-length">
        <h1>length</h1>
        <p>The value of the *"length"* property is an integral Number that indicates the typical number of arguments expected by the function. However, the language permits the function to be invoked with some other number of arguments. The behaviour of a function when invoked on a number of arguments other than the number specified by its *"length"* property depends on the function. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-name">
        <h1>name</h1>
        <p>The value of the *"name"* property is a String that is descriptive of the function. The name has no semantic significance but is typically a variable or property name that is used to refer to the function at its point of definition in ECMAScript source text. This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>Anonymous function objects that do not have a contextual name associated with them by this specification use the empty String as the value of the *"name"* property.</p>
      </emu-clause>

      <emu-clause id="sec-function-instances-prototype">
        <h1>prototype</h1>
        <p>Function instances that can be used as a constructor have a *"prototype"* property. Whenever such a Function instance is created another ordinary object is also created and is the initial value of the function's *"prototype"* property. Unless otherwise specified, the value of the *"prototype"* property is used to initialize the [[Prototype]] internal slot of the object created when that function is invoked as a constructor.</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Function objects created using `Function.prototype.bind`, or by evaluating a |MethodDefinition| (that is not a |GeneratorMethod| or |AsyncGeneratorMethod|) or an |ArrowFunction| do not have a *"prototype"* property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-hosthassourcetextavailable" type="host-defined abstract operation">
      <h1>
        HostHasSourceTextAvailable (
          _func_: a function object,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It allows host environments to prevent the source text from being provided for _func_.</dd>
      </dl>
      <p>An implementation of HostHasSourceTextAvailable must conform to the following requirements:</p>
      <ul>
        <li>It must be deterministic with respect to its parameters. Each time it is called with a specific _func_ as its argument, it must return the same result.</li>
      </ul>
      <p>The default implementation of HostHasSourceTextAvailable is to return *true*.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-boolean-objects">
    <h1>Boolean Objects</h1>

    <emu-clause id="sec-boolean-constructor">
      <h1>The Boolean Constructor</h1>
      <p>The Boolean constructor:</p>
      <ul>
        <li>is <dfn>%Boolean%</dfn>.</li>
        <li>is the initial value of the *"Boolean"* property of the global object.</li>
        <li>creates and initializes a new Boolean object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Boolean behaviour must include a `super` call to the Boolean constructor to create and initialize the subclass instance with a [[BooleanData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-boolean-constructor-boolean-value">
        <h1>Boolean ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _b_ be ToBoolean(_value_).
          1. If NewTarget is *undefined*, return _b_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Boolean.prototype%"*, « [[BooleanData]] »).
          1. Set _O_.[[BooleanData]] to _b_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-constructor">
      <h1>Properties of the Boolean Constructor</h1>
      <p>The Boolean constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-boolean.prototype">
        <h1>Boolean.prototype</h1>
        <p>The initial value of `Boolean.prototype` is the Boolean prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-boolean-prototype-object">
      <h1>Properties of the Boolean Prototype Object</h1>
      <p>The <dfn>Boolean prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Boolean.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is itself a Boolean object; it has a [[BooleanData]] internal slot with the value *false*.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>

      <emu-clause id="sec-boolean.prototype.constructor">
        <h1>Boolean.prototype.constructor</h1>
        <p>The initial value of `Boolean.prototype.constructor` is %Boolean%.</p>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.tostring">
        <h1>Boolean.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _b_ be ? ThisBooleanValue(*this* value).
          1. If _b_ is *true*, return *"true"*; else return *"false"*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-boolean.prototype.valueof">
        <h1>Boolean.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisBooleanValue(*this* value).
        </emu-alg>

        <emu-clause id="sec-thisbooleanvalue" type="abstract operation" oldids="thisbooleanvalue">
          <h1>
            ThisBooleanValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _value_ is a Boolean, return _value_.
            1. If _value_ is an Object and _value_ has a [[BooleanData]] internal slot, then
              1. Let _b_ be _value_.[[BooleanData]].
              1. Assert: _b_ is a Boolean.
              1. Return _b_.
            1. Throw a *TypeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-boolean-instances">
      <h1>Properties of Boolean Instances</h1>
      <p>Boolean instances are ordinary objects that inherit properties from the Boolean prototype object. Boolean instances have a [[BooleanData]] internal slot. The [[BooleanData]] internal slot is the Boolean value represented by this Boolean object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-symbol-objects">
    <h1>Symbol Objects</h1>

    <emu-clause id="sec-symbol-constructor">
      <h1>The Symbol Constructor</h1>
      <p>The Symbol constructor:</p>
      <ul>
        <li>is <dfn>%Symbol%</dfn>.</li>
        <li>is the initial value of the *"Symbol"* property of the global object.</li>
        <li>returns a new Symbol value when called as a function.</li>
        <li>is not intended to be used with the `new` operator.</li>
        <li>is not intended to be subclassed.</li>
        <li>may be used as the value of an `extends` clause of a class definition but a `super` call to it will cause an exception.</li>
      </ul>

      <emu-clause id="sec-symbol-description">
        <h1>Symbol ( [ _description_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. If _description_ is *undefined*, let _descString_ be *undefined*.
          1. Else, let _descString_ be ? ToString(_description_).
          1. Return a new Symbol whose [[Description]] is _descString_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-constructor">
      <h1>Properties of the Symbol Constructor</h1>
      <p>The Symbol constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-symbol.asynciterator">
        <h1>Symbol.asyncIterator</h1>
        <p>The initial value of `Symbol.asyncIterator` is the well-known symbol %Symbol.asyncIterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.for">
        <h1>Symbol.for ( _key_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _stringKey_ be ? ToString(_key_).
          1. For each element _e_ of the GlobalSymbolRegistry List, do
            1. If _e_.[[Key]] is _stringKey_, return _e_.[[Symbol]].
          1. Assert: The GlobalSymbolRegistry List does not currently contain an entry for _stringKey_.
          1. Let _newSymbol_ be a new Symbol whose [[Description]] is _stringKey_.
          1. Append the GlobalSymbolRegistry Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.
          1. Return _newSymbol_.
        </emu-alg>
        <p>The <dfn>GlobalSymbolRegistry List</dfn> is an append-only List that is globally available. It is shared by all realms. Prior to the evaluation of any ECMAScript code, it is initialized as a new empty List. Elements of the GlobalSymbolRegistry List are Records with the structure defined in <emu-xref href="#table-globalsymbolregistry-record-fields"></emu-xref>.</p>
        <emu-table id="table-globalsymbolregistry-record-fields" caption="GlobalSymbolRegistry Record Fields" oldids="table-44">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Usage
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Key]]
              </td>
              <td>
                a String
              </td>
              <td>
                A string key used to globally identify a Symbol.
              </td>
            </tr>
            <tr>
              <td>
                [[Symbol]]
              </td>
              <td>
                a Symbol
              </td>
              <td>
                A symbol that can be retrieved from any realm.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-symbol.hasinstance">
        <h1>Symbol.hasInstance</h1>
        <p>The initial value of `Symbol.hasInstance` is the well-known symbol %Symbol.hasInstance% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.isconcatspreadable">
        <h1>Symbol.isConcatSpreadable</h1>
        <p>The initial value of `Symbol.isConcatSpreadable` is the well-known symbol %Symbol.isConcatSpreadable% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.iterator">
        <h1>Symbol.iterator</h1>
        <p>The initial value of `Symbol.iterator` is the well-known symbol %Symbol.iterator% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.keyfor">
        <h1>Symbol.keyFor ( _sym_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _sym_ is not a Symbol, throw a *TypeError* exception.
          1. Return KeyForSymbol(_sym_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.match">
        <h1>Symbol.match</h1>
        <p>The initial value of `Symbol.match` is the well-known symbol %Symbol.match% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.matchall">
        <h1>Symbol.matchAll</h1>
        <p>The initial value of `Symbol.matchAll` is the well-known symbol %Symbol.matchAll% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype">
        <h1>Symbol.prototype</h1>
        <p>The initial value of `Symbol.prototype` is the Symbol prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.replace">
        <h1>Symbol.replace</h1>
        <p>The initial value of `Symbol.replace` is the well-known symbol %Symbol.replace% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.search">
        <h1>Symbol.search</h1>
        <p>The initial value of `Symbol.search` is the well-known symbol %Symbol.search% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.species">
        <h1>Symbol.species</h1>
        <p>The initial value of `Symbol.species` is the well-known symbol %Symbol.species% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.split">
        <h1>Symbol.split</h1>
        <p>The initial value of `Symbol.split` is the well-known symbol %Symbol.split% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.toprimitive">
        <h1>Symbol.toPrimitive</h1>
        <p>The initial value of `Symbol.toPrimitive` is the well-known symbol %Symbol.toPrimitive% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.tostringtag">
        <h1>Symbol.toStringTag</h1>
        <p>The initial value of `Symbol.toStringTag` is the well-known symbol %Symbol.toStringTag% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.unscopables">
        <h1>Symbol.unscopables</h1>
        <p>The initial value of `Symbol.unscopables` is the well-known symbol %Symbol.unscopables% (<emu-xref href="#table-well-known-symbols"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-symbol-prototype-object">
      <h1>Properties of the Symbol Prototype Object</h1>
      <p>The <dfn>Symbol prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Symbol.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a Symbol instance and does not have a [[SymbolData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>

      <emu-clause id="sec-symbol.prototype.constructor">
        <h1>Symbol.prototype.constructor</h1>
        <p>The initial value of `Symbol.prototype.constructor` is %Symbol%.</p>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.description">
        <h1>get Symbol.prototype.description</h1>
        <p>`Symbol.prototype.description` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _s_ be the *this* value.
          1. Let _sym_ be ? ThisSymbolValue(_s_).
          1. Return _sym_.[[Description]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.tostring">
        <h1>Symbol.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _sym_ be ? ThisSymbolValue(*this* value).
          1. Return SymbolDescriptiveString(_sym_).
        </emu-alg>

        <emu-clause id="sec-symboldescriptivestring" type="abstract operation">
          <h1>
            SymbolDescriptiveString (
              _sym_: a Symbol,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _desc_ be _sym_.[[Description]].
            1. If _desc_ is *undefined*, set _desc_ to the empty String.
            1. Assert: _desc_ is a String.
            1. Return the string-concatenation of *"Symbol("*, _desc_, and *")"*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-symbol.prototype.valueof">
        <h1>Symbol.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisSymbolValue(*this* value).
        </emu-alg>

        <emu-clause id="sec-thissymbolvalue" type="abstract operation" oldids="thissymbolvalue">
          <h1>
            ThisSymbolValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a Symbol or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _value_ is a Symbol, return _value_.
            1. If _value_ is an Object and _value_ has a [[SymbolData]] internal slot, then
              1. Let _s_ be _value_.[[SymbolData]].
              1. Assert: _s_ is a Symbol.
              1. Return _s_.
            1. Throw a *TypeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@toprimitive" id="sec-symbol.prototype-%symbol.toprimitive%">
        <h1>Symbol.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>This method is called by ECMAScript language operators to convert a Symbol object to a primitive value.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisSymbolValue(*this* value).
        </emu-alg>
        <emu-note>
          <p>The argument is ignored.</p>
        </emu-note>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The value of the *"name"* property of this method is *"[Symbol.toPrimitive]"*.</p>
      </emu-clause>

      <emu-clause oldids="sec-symbol.prototype-@@tostringtag" id="sec-symbol.prototype-%symbol.tostringtag%">
        <h1>Symbol.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Symbol"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-symbol-instances">
      <h1>Properties of Symbol Instances</h1>
      <p>Symbol instances are ordinary objects that inherit properties from the Symbol prototype object. Symbol instances have a [[SymbolData]] internal slot. The [[SymbolData]] internal slot is the Symbol value represented by this Symbol object.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-symbols">
      <h1>Abstract Operations for Symbols</h1>

      <emu-clause id="sec-keyforsymbol" type="abstract operation">
        <h1>
          KeyForSymbol (
            _sym_: a Symbol,
          ): a String or *undefined*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>If _sym_ is in the GlobalSymbolRegistry List, the String used to register _sym_ will be returned.</dd>
        </dl>
        <emu-alg>
          1. For each element _e_ of the GlobalSymbolRegistry List, do
            1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].
          1. Assert: The GlobalSymbolRegistry List does not currently contain an entry for _sym_.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-error-objects">
    <h1>Error Objects</h1>
    <p>Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.</p>
    <p>When an ECMAScript implementation detects a runtime error, it throws a new instance of one of the _NativeError_ objects defined in <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref> or a new instance of the AggregateError object defined in <emu-xref href="#sec-aggregate-error-objects"></emu-xref>.</p>

    <emu-clause id="sec-error-constructor">
      <h1>The Error Constructor</h1>
      <p>The Error constructor:</p>
      <ul>
        <li>is <dfn>%Error%</dfn>.</li>
        <li>is the initial value of the *"Error"* property of the global object.</li>
        <li>creates and initializes a new Error object when called as a function rather than as a constructor. Thus the function call `Error(…)` is equivalent to the object creation expression `new Error(…)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Error behaviour must include a `super` call to the Error constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-error-message">
        <h1>Error ( _message_ [ , _options_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Error.prototype%"*, « [[ErrorData]] »).
          1. If _message_ is not *undefined*, then
            1. Let _msg_ be ? ToString(_message_).
            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
          1. Perform ? InstallErrorCause(_O_, _options_).
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-constructor">
      <h1>Properties of the Error Constructor</h1>
      <p>The Error constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-error.iserror">
        <h1>Error.isError ( _arg_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _arg_ is not an Object, return *false*.
          1. If _arg_ does not have an [[ErrorData]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-error.prototype">
        <h1>Error.prototype</h1>
        <p>The initial value of `Error.prototype` is the Error prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-error-prototype-object">
      <h1>Properties of the Error Prototype Object</h1>
      <p>The <dfn>Error prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Error.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not an Error instance and does not have an [[ErrorData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>

      <emu-clause id="sec-error.prototype.constructor">
        <h1>Error.prototype.constructor</h1>
        <p>The initial value of `Error.prototype.constructor` is %Error%.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.message">
        <h1>Error.prototype.message</h1>
        <p>The initial value of `Error.prototype.message` is the empty String.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.name">
        <h1>Error.prototype.name</h1>
        <p>The initial value of `Error.prototype.name` is *"Error"*.</p>
      </emu-clause>

      <emu-clause id="sec-error.prototype.tostring">
        <h1>Error.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _name_ be ? Get(_O_, *"name"*).
          1. If _name_ is *undefined*, set _name_ to *"Error"*; otherwise set _name_ to ? ToString(_name_).
          1. Let _msg_ be ? Get(_O_, *"message"*).
          1. If _msg_ is *undefined*, set _msg_ to the empty String; otherwise set _msg_ to ? ToString(_msg_).
          1. If _name_ is the empty String, return _msg_.
          1. If _msg_ is the empty String, return _name_.
          1. Return the string-concatenation of _name_, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and _msg_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-error-instances">
      <h1>Properties of Error Instances</h1>
      <p>Error instances are ordinary objects that inherit properties from the Error prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is to identify Error, AggregateError, and _NativeError_ instances as Error objects within `Object.prototype.toString` and `Error.isError`.</p>
    </emu-clause>

    <emu-clause id="sec-native-error-types-used-in-this-standard">
      <h1>Native Error Types Used in This Standard</h1>
      <p>A new instance of one of the _NativeError_ objects below or of the AggregateError object is thrown when a runtime error is detected. All _NativeError_ objects share the same structure, as described in <emu-xref href="#sec-nativeerror-object-structure"></emu-xref>.</p>

      <emu-clause id="sec-native-error-types-used-in-this-standard-evalerror">
        <h1>EvalError</h1>
        <p>The EvalError constructor is <dfn>%EvalError%</dfn>.</p>
        <p>This exception is not currently used within this specification. This object remains for compatibility with previous editions of this specification.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-rangeerror">
        <h1>RangeError</h1>
        <p>The RangeError constructor is <dfn>%RangeError%</dfn>.</p>
        <p>Indicates a value that is not in the set or range of allowable values.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-referenceerror">
        <h1>ReferenceError</h1>
        <p>The ReferenceError constructor is <dfn>%ReferenceError%</dfn>.</p>
        <p>Indicate that an invalid reference has been detected.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-syntaxerror">
        <h1>SyntaxError</h1>
        <p>The SyntaxError constructor is <dfn>%SyntaxError%</dfn>.</p>
        <p>Indicates that a parsing error has occurred.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-typeerror">
        <h1>TypeError</h1>
        <p>The TypeError constructor is <dfn>%TypeError%</dfn>.</p>
        <p>TypeError is used to indicate an unsuccessful operation when none of the other _NativeError_ objects are an appropriate indication of the failure cause.</p>
      </emu-clause>

      <emu-clause id="sec-native-error-types-used-in-this-standard-urierror">
        <h1>URIError</h1>
        <p>The URIError constructor is <dfn>%URIError%</dfn>.</p>
        <p>Indicates that one of the global URI handling functions was used in a way that is incompatible with its definition.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-nativeerror-object-structure">
      <h1>_NativeError_ Object Structure</h1>
      <p>Each of these objects has the structure described below, differing only in the name used as the constructor name and in the *"name"* property of the prototype object.</p>
      <p>For each error object, references to _NativeError_ in the definition should be replaced with the appropriate error object name from <emu-xref href="#sec-native-error-types-used-in-this-standard"></emu-xref>.</p>

      <emu-clause id="sec-nativeerror-constructors">
        <h1>The _NativeError_ Constructors</h1>
        <p>Each _NativeError_ constructor:</p>
        <ul>
          <li>creates and initializes a new _NativeError_ object when called as a function rather than as a constructor. A call of the object as a function is equivalent to calling it as a constructor with the same arguments. Thus the function call <code><var>NativeError</var>(&hellip;)</code> is equivalent to the object creation expression <code>new <var>NativeError</var>(&hellip;)</code> with the same arguments.</li>
          <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified _NativeError_ behaviour must include a `super` call to the _NativeError_ constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.</li>
        </ul>

        <emu-clause id="sec-nativeerror">
          <h1>_NativeError_ ( _message_ [ , _options_ ] )</h1>
          <p>Each _NativeError_ function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
            1. [id="step-nativeerror-ordinarycreatefromconstructor"] Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>"%<var>NativeError</var>.prototype%"</code>, « [[ErrorData]] »).
            1. If _message_ is not *undefined*, then
              1. Let _msg_ be ? ToString(_message_).
              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
            1. Perform ? InstallErrorCause(_O_, _options_).
            1. Return _O_.
          </emu-alg>
          <p>The actual value of the string passed in step <emu-xref href="#step-nativeerror-ordinarycreatefromconstructor"></emu-xref> is either *"%EvalError.prototype%"*, *"%RangeError.prototype%"*, *"%ReferenceError.prototype%"*, *"%SyntaxError.prototype%"*, *"%TypeError.prototype%"*, or *"%URIError.prototype%"* corresponding to which _NativeError_ constructor is being defined.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-constructors">
        <h1>Properties of the _NativeError_ Constructors</h1>
        <p>Each _NativeError_ constructor:</p>
        <ul>
          <li>has a [[Prototype]] internal slot whose value is %Error%.</li>
          <li>has a *"name"* property whose value is the String value <emu-val>"<var>NativeError</var>"</emu-val>.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype">
          <h1>_NativeError_.prototype</h1>
          <p>The initial value of <code><var>NativeError</var>.prototype</code> is a _NativeError_ prototype object (<emu-xref href="#sec-properties-of-the-nativeerror-prototype-objects"></emu-xref>). Each _NativeError_ constructor has a distinct prototype object.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-nativeerror-prototype-objects">
        <h1>Properties of the _NativeError_ Prototype Objects</h1>
        <p>Each <dfn>_NativeError_ prototype object</dfn>:</p>
        <ul>
          <li>is an ordinary object.</li>
          <li>is not an Error instance and does not have an [[ErrorData]] internal slot.</li>
          <li>has a [[Prototype]] internal slot whose value is %Error.prototype%.</li>
        </ul>

        <emu-clause id="sec-nativeerror.prototype.constructor">
          <h1>_NativeError_.prototype.constructor</h1>
          <p>The initial value of the *"constructor"* property of the prototype for a given _NativeError_ constructor is the constructor itself.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.message">
          <h1>_NativeError_.prototype.message</h1>
          <p>The initial value of the *"message"* property of the prototype for a given _NativeError_ constructor is the empty String.</p>
        </emu-clause>

        <emu-clause id="sec-nativeerror.prototype.name">
          <h1>_NativeError_.prototype.name</h1>
          <p>The initial value of the *"name"* property of the prototype for a given _NativeError_ constructor is the String value consisting of the name of the constructor (the name used instead of _NativeError_).</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-nativeerror-instances">
        <h1>Properties of _NativeError_ Instances</h1>
        <p>_NativeError_ instances are ordinary objects that inherit properties from their _NativeError_ prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) and `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) to identify Error, AggregateError, or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-aggregate-error-objects">
      <h1>AggregateError Objects</h1>

      <emu-clause id="sec-aggregate-error-constructor">
        <h1>The AggregateError Constructor</h1>
        <p>The AggregateError constructor:</p>
        <ul>
          <li>is <dfn>%AggregateError%</dfn>.</li>
          <li>is the initial value of the *"AggregateError"* property of the global object.</li>
          <li>creates and initializes a new AggregateError object when called as a function rather than as a constructor. Thus the function call `AggregateError(…)` is equivalent to the object creation expression `new AggregateError(…)` with the same arguments.</li>
          <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AggregateError behaviour must include a `super` call to the AggregateError constructor to create and initialize subclass instances with an [[ErrorData]] internal slot.</li>
        </ul>

        <emu-clause id="sec-aggregate-error">
          <h1>AggregateError ( _errors_, _message_ [ , _options_ ] )</h1>
          <p>This function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%AggregateError.prototype%"*, « [[ErrorData]] »).
            1. If _message_ is not *undefined*, then
              1. Let _msg_ be ? ToString(_message_).
              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"message"*, _msg_).
            1. Perform ? InstallErrorCause(_O_, _options_).
            1. Let _errorsList_ be ? IteratorToList(? GetIterator(_errors_, ~sync~)).
            1. Perform ! DefinePropertyOrThrow(_O_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }).
            1. Return _O_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-constructors">
        <h1>Properties of the AggregateError Constructor</h1>
        <p>The AggregateError constructor:</p>
        <ul>
          <li>has a [[Prototype]] internal slot whose value is %Error%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype">
          <h1>AggregateError.prototype</h1>
          <p>The initial value of `AggregateError.prototype` is %AggregateError.prototype%.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-aggregate-error-prototype-objects">
        <h1>Properties of the AggregateError Prototype Object</h1>
        <p>The <dfn>AggregateError prototype object</dfn>:</p>
        <ul>
          <li>is <dfn>%AggregateError.prototype%</dfn>.</li>
          <li>is an ordinary object.</li>
          <li>is not an Error instance or an AggregateError instance and does not have an [[ErrorData]] internal slot.</li>
          <li>has a [[Prototype]] internal slot whose value is %Error.prototype%.</li>
        </ul>

        <emu-clause id="sec-aggregate-error.prototype.constructor">
          <h1>AggregateError.prototype.constructor</h1>
          <p>The initial value of `AggregateError.prototype.constructor` is %AggregateError%.</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.message">
          <h1>AggregateError.prototype.message</h1>
          <p>The initial value of `AggregateError.prototype.message` is the empty String.</p>
        </emu-clause>

        <emu-clause id="sec-aggregate-error.prototype.name">
          <h1>AggregateError.prototype.name</h1>
          <p>The initial value of `AggregateError.prototype.name` is *"AggregateError"*.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-aggregate-error-instances">
        <h1>Properties of AggregateError Instances</h1>
        <p>AggregateError instances are ordinary objects that inherit properties from their AggregateError prototype object and have an [[ErrorData]] internal slot whose value is *undefined*. The only specified use of [[ErrorData]] is by `Object.prototype.toString` (<emu-xref href="#sec-object.prototype.tostring"></emu-xref>) and `Error.isError` (<emu-xref href="#sec-error.iserror"></emu-xref>) to identify Error, AggregateError, or _NativeError_ instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-error-objects">
      <h1>Abstract Operations for Error Objects</h1>

      <emu-clause id="sec-installerrorcause" type="abstract operation">
        <h1>
          InstallErrorCause (
            _O_: an Object,
            _options_: an ECMAScript language value,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create a *"cause"* property on _O_ when a *"cause"* property is present on _options_.</dd>
        </dl>
        <emu-alg>
          1. If _options_ is an Object and ? HasProperty(_options_, *"cause"*) is *true*, then
            1. Let _cause_ be ? Get(_options_, *"cause"*).
            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *"cause"*, _cause_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-numbers-and-dates">
  <h1>Numbers and Dates</h1>

  <emu-clause id="sec-number-objects">
    <h1>Number Objects</h1>

    <emu-clause id="sec-number-constructor">
      <h1>The Number Constructor</h1>
      <p>The Number constructor:</p>
      <ul>
        <li>is <dfn>%Number%</dfn>.</li>
        <li>is the initial value of the *"Number"* property of the global object.</li>
        <li>creates and initializes a new Number object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Number behaviour must include a `super` call to the Number constructor to create and initialize the subclass instance with a [[NumberData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is present, then
            1. Let _prim_ be ? ToNumeric(_value_).
            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).
            1. Otherwise, let _n_ be _prim_.
          1. Else,
            1. Let _n_ be *+0*<sub>𝔽</sub>.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Number.prototype%"*, « [[NumberData]] »).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-constructor">
      <h1>Properties of the Number Constructor</h1>
      <p>The Number constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-number.epsilon">
        <h1>Number.EPSILON</h1>
        <p>The value of `Number.EPSILON` is the Number value for the magnitude of the difference between 1 and the smallest value greater than 1 that is representable as a Number value, which is approximately 2.2204460492503130808472633361816 × 10<sup>-16</sup>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.isfinite">
        <h1>Number.isFinite ( _number_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _number_ is not a Number, return *false*.
          1. If _number_ is not finite, return *false*.
          1. Otherwise, return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isinteger">
        <h1>Number.isInteger ( _number_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _number_ is an integral Number, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.isnan">
        <h1>Number.isNaN ( _number_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _number_ is not a Number, return *false*.
          1. If _number_ is *NaN*, return *true*.
          1. Otherwise, return *false*.
        </emu-alg>
        <emu-note>
          <p>This function differs from the global isNaN function (<emu-xref href="#sec-isnan-number"></emu-xref>) in that it does not convert its argument to a Number before determining whether it is *NaN*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.issafeinteger">
        <h1>Number.isSafeInteger ( _number_ )</h1>
        <emu-note>
          <p>An integer _n_ is a "<dfn id="safe-integer">safe integer</dfn>" if and only if the Number value for _n_ is not the Number value for any other integer.</p>
        </emu-note>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _number_ is an integral Number, then
            1. If abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.max_safe_integer">
        <h1>Number.MAX_SAFE_INTEGER</h1>
        <emu-note>
          <p>Due to rounding behaviour necessitated by precision limitations of IEEE 754-2019, the Number value for every integer greater than `Number.MAX_SAFE_INTEGER` is shared with at least one other integer. Such large-magnitude integers are therefore not <emu-xref href="#safe-integer">safe</emu-xref>, and are not guaranteed to be exactly representable as Number values or even to be distinguishable from each other. For example, both `9007199254740992` and `9007199254740993` evaluate to the Number value *9007199254740992*<sub>𝔽</sub>.</p>
        </emu-note>
        <p>The value of `Number.MAX_SAFE_INTEGER` is *9007199254740991*<sub>𝔽</sub> (𝔽(2<sup>53</sup> - 1)).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.max_value">
        <h1>Number.MAX_VALUE</h1>
        <p>The value of `Number.MAX_VALUE` is the largest positive finite value of the Number type, which is approximately <emu-eqn>1.7976931348623157 × 10<sup>308</sup></emu-eqn>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_safe_integer">
        <h1>Number.MIN_SAFE_INTEGER</h1>
        <emu-note>
          <p>Due to rounding behaviour necessitated by precision limitations of IEEE 754-2019, the Number value for every integer less than `Number.MIN_SAFE_INTEGER` is shared with at least one other integer. Such large-magnitude integers are therefore not <emu-xref href="#safe-integer">safe</emu-xref>, and are not guaranteed to be exactly representable as Number values or even to be distinguishable from each other. For example, both `-9007199254740992` and `-9007199254740993` evaluate to the Number value *-9007199254740992*<sub>𝔽</sub>.</p>
        </emu-note>
        <p>The value of `Number.MIN_SAFE_INTEGER` is *-9007199254740991*<sub>𝔽</sub> (𝔽(-(2<sup>53</sup> - 1))).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.min_value">
        <h1>Number.MIN_VALUE</h1>
        <p>The value of `Number.MIN_VALUE` is the smallest positive value of the Number type, which is approximately <emu-eqn>5 × 10<sup>-324</sup></emu-eqn>.</p>
        <p>In the IEEE 754-2019 double precision binary representation, the smallest possible value is a denormalized number. If an implementation does not support denormalized values, the value of `Number.MIN_VALUE` must be the smallest non-zero positive value that can actually be represented by the implementation.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.nan">
        <h1>Number.NaN</h1>
        <p>The value of `Number.NaN` is *NaN*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.negative_infinity">
        <h1>Number.NEGATIVE_INFINITY</h1>
        <p>The value of `Number.NEGATIVE_INFINITY` is *-∞*<sub>𝔽</sub>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.parsefloat">
        <h1>Number.parseFloat ( _string_ )</h1>
        <p>The initial value of the *"parseFloat"* property is %parseFloat%.</p>
      </emu-clause>

      <emu-clause id="sec-number.parseint">
        <h1>Number.parseInt ( _string_, _radix_ )</h1>
        <p>The initial value of the *"parseInt"* property is %parseInt%.</p>
      </emu-clause>

      <emu-clause id="sec-number.positive_infinity">
        <h1>Number.POSITIVE_INFINITY</h1>
        <p>The value of `Number.POSITIVE_INFINITY` is *+∞*<sub>𝔽</sub>.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype">
        <h1>Number.prototype</h1>
        <p>The initial value of `Number.prototype` is the Number prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-number-prototype-object">
      <h1>Properties of the Number Prototype Object</h1>
      <p>The <dfn>Number prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Number.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is itself a Number object; it has a [[NumberData]] internal slot with the value *+0*<sub>𝔽</sub>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <p>Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic and the *this* value passed to them must be either a Number value or an object that has a [[NumberData]] internal slot that has been initialized to a Number value.</p>
      <p>The phrase “this Number value” within the specification of a method refers to the result returned by calling the abstract operation ThisNumberValue with the *this* value of the method invocation passed as the argument.</p>

      <emu-clause id="sec-number.prototype.constructor">
        <h1>Number.prototype.constructor</h1>
        <p>The initial value of `Number.prototype.constructor` is %Number%.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toexponential">
        <h1>Number.prototype.toExponential ( _fractionDigits_ )</h1>
        <p>This method returns a String containing this Number value represented in decimal exponential notation with one digit before the significand's decimal point and _fractionDigits_ digits after the significand's decimal point. If _fractionDigits_ is *undefined*, it includes as many significand digits as necessary to uniquely specify the Number (just like in ToString except that in this case the Number is always output in exponential notation).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _x_ be ? ThisNumberValue(*this* value).
          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).
          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.
          1. If _x_ is not finite, return Number::toString(_x_, 10).
          1. If _f_ &lt; 0 or _f_ > 100, throw a *RangeError* exception.
          1. Set _x_ to ℝ(_x_).
          1. Let _s_ be the empty String.
          1. If _x_ &lt; 0, then
            1. Set _s_ to *"-"*.
            1. Set _x_ to -_x_.
          1. If _x_ = 0, then
            1. Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).
            1. Let _e_ be 0.
          1. Else,
            1. If _fractionDigits_ is not *undefined*, then
              1. Let _e_ and _n_ be integers such that 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup> and for which _n_ × 10<sup>_e_ - _f_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _f_</sup> is larger.
            1. Else,
              1. [id="step-number-proto-toexponential-intermediate-values"] Let _e_, _n_, and _ff_ be integers such that _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ &lt; 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) is 𝔽(_x_), and _ff_ is as small as possible. Note that the decimal representation of _n_ has _ff_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.
              1. Set _f_ to _ff_.
            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).
          1. If _f_ ≠ 0, then
            1. Let _a_ be the first code unit of _m_.
            1. Let _b_ be the other _f_ code units of _m_.
            1. Set _m_ to the string-concatenation of _a_, *"."*, and _b_.
          1. If _e_ = 0, then
            1. Let _c_ be *"+"*.
            1. Let _d_ be *"0"*.
          1. Else,
            1. If _e_ > 0, then
              1. Let _c_ be *"+"*.
            1. Else,
              1. Assert: _e_ &lt; 0.
              1. Let _c_ be *"-"*.
              1. Set _e_ to -_e_.
            1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).
          1. Set _m_ to the string-concatenation of _m_, *"e"*, _c_, and _d_.
          1. Return the string-concatenation of _s_ and _m_.
        </emu-alg>
        <emu-note>
          <p>For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step <emu-xref href="#step-number-proto-toexponential-intermediate-values"></emu-xref> be used as a guideline:</p>
          <emu-alg replaces-step="step-number-proto-toexponential-intermediate-values">
            1. Let _e_, _n_, and _f_ be integers such that _f_ ≥ 0, 10<sup>_f_</sup> ≤ _n_ &lt; 10<sup>_f_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _f_</sup>) is 𝔽(_x_), and _f_ is as small as possible. If there are multiple possibilities for _n_, choose the value of _n_ for which 𝔽(_n_ × 10<sup>_e_ - _f_</sup>) is closest in value to 𝔽(_x_). If there are two such possible values of _n_, choose the one that is even.
          </emu-alg>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tofixed">
        <h1>Number.prototype.toFixed ( _fractionDigits_ )</h1>
        <emu-note>
          <p>This method returns a String containing this Number value represented in decimal fixed-point notation with _fractionDigits_ digits after the decimal point. If _fractionDigits_ is *undefined*, 0 is assumed.</p>
        </emu-note>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _x_ be ? ThisNumberValue(*this* value).
          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).
          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.
          1. If _f_ is not finite, throw a *RangeError* exception.
          1. If _f_ &lt; 0 or _f_ > 100, throw a *RangeError* exception.
          1. If _x_ is not finite, return Number::toString(_x_, 10).
          1. Set _x_ to ℝ(_x_).
          1. Let _s_ be the empty String.
          1. If _x_ &lt; 0, then
            1. Set _s_ to *"-"*.
            1. Set _x_ to -_x_.
          1. If _x_ ≥ 10<sup>21</sup>, then
            1. Let _m_ be ! ToString(𝔽(_x_)).
          1. Else,
            1. Let _n_ be an integer for which _n_ / 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.
            1. If _n_ = 0, let _m_ be *"0"*; otherwise let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).
            1. If _f_ ≠ 0, then
              1. Let _k_ be the length of _m_.
              1. If _k_ ≤ _f_, then
                1. Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).
                1. Set _m_ to the string-concatenation of _z_ and _m_.
                1. Set _k_ to _f_ + 1.
              1. Let _a_ be the first _k_ - _f_ code units of _m_.
              1. Let _b_ be the other _f_ code units of _m_.
              1. Set _m_ to the string-concatenation of _a_, *"."*, and _b_.
          1. Return the string-concatenation of _s_ and _m_.
        </emu-alg>
        <emu-note>
          <p>The output of `toFixed` may be more precise than `toString` for some values because toString only prints enough significant digits to distinguish the number from adjacent Number values. For example,</p>
          <p>
            `(1000000000000000128).toString()` returns *"1000000000000000100"*, while<br>
            `(1000000000000000128).toFixed(0)` returns *"1000000000000000128"*.
          </p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tolocalestring">
        <h1>Number.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method produces a String value that represents this Number value formatted according to the conventions of the host environment's current locale. This method is implementation-defined, and it is permissible, but not encouraged, for it to return the same thing as `toString`.</p>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.toprecision">
        <h1>Number.prototype.toPrecision ( _precision_ )</h1>
        <p>This method returns a String containing this Number value represented either in decimal exponential notation with one digit before the significand's decimal point and <emu-eqn>_precision_ - 1</emu-eqn> digits after the significand's decimal point or in decimal fixed notation with _precision_ significant digits. If _precision_ is *undefined*, it calls ToString instead.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _x_ be ? ThisNumberValue(*this* value).
          1. If _precision_ is *undefined*, return ! ToString(_x_).
          1. Let _p_ be ? ToIntegerOrInfinity(_precision_).
          1. If _x_ is not finite, return Number::toString(_x_, 10).
          1. If _p_ &lt; 1 or _p_ > 100, throw a *RangeError* exception.
          1. Set _x_ to ℝ(_x_).
          1. Let _s_ be the empty String.
          1. If _x_ &lt; 0, then
            1. Set _s_ to the code unit 0x002D (HYPHEN-MINUS).
            1. Set _x_ to -_x_.
          1. If _x_ = 0, then
            1. Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).
            1. Let _e_ be 0.
          1. Else,
            1. Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> ≤ _n_ &lt; 10<sup>_p_</sup> and for which _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _p_ + 1</sup> is larger.
            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).
            1. If _e_ &lt; -6 or _e_ ≥ _p_, then
              1. Assert: _e_ ≠ 0.
              1. If _p_ ≠ 1, then
                1. Let _a_ be the first code unit of _m_.
                1. Let _b_ be the other _p_ - 1 code units of _m_.
                1. Set _m_ to the string-concatenation of _a_, *"."*, and _b_.
              1. If _e_ > 0, then
                1. Let _c_ be the code unit 0x002B (PLUS SIGN).
              1. Else,
                1. Assert: _e_ &lt; 0.
                1. Let _c_ be the code unit 0x002D (HYPHEN-MINUS).
                1. Set _e_ to -_e_.
              1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).
              1. Return the string-concatenation of _s_, _m_, the code unit 0x0065 (LATIN SMALL LETTER E), _c_, and _d_.
          1. If _e_ = _p_ - 1, return the string-concatenation of _s_ and _m_.
          1. If _e_ ≥ 0, then
            1. Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.
          1. Else,
            1. Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.
          1. Return the string-concatenation of _s_ and _m_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number.prototype.tostring">
        <h1>Number.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>The optional _radix_ should be an integral Number value in the inclusive interval from *2*<sub>𝔽</sub> to *36*<sub>𝔽</sub>. If _radix_ is *undefined* then *10*<sub>𝔽</sub> is used as the value of _radix_.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _x_ be ? ThisNumberValue(*this* value).
          1. If _radix_ is *undefined*, let _radixMV_ be 10.
          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).
          1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.
          1. Return Number::toString(_x_, _radixMV_).
        </emu-alg>
        <p>This method is not generic; it throws a *TypeError* exception if its *this* value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-number.prototype.valueof">
        <h1>Number.prototype.valueOf ( )</h1>
        <emu-alg>
          1. Return ? ThisNumberValue(*this* value).
        </emu-alg>

        <emu-clause id="sec-thisnumbervalue" type="abstract operation" oldids="thisnumbervalue">
          <h1>
            ThisNumberValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a Number or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _value_ is a Number, return _value_.
            1. If _value_ is an Object and _value_ has a [[NumberData]] internal slot, then
              1. Let _n_ be _value_.[[NumberData]].
              1. Assert: _n_ is a Number.
              1. Return _n_.
            1. Throw a *TypeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-number-instances">
      <h1>Properties of Number Instances</h1>
      <p>Number instances are ordinary objects that inherit properties from the Number prototype object. Number instances also have a [[NumberData]] internal slot. The [[NumberData]] internal slot is the Number value represented by this Number object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-bigint-objects">
    <h1>BigInt Objects</h1>

    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <p>The BigInt constructor:</p>
      <ul>
        <li>is <dfn>%BigInt%</dfn>.</li>
        <li>is the initial value of the *"BigInt"* property of the global object.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>is not intended to be used with the `new` operator or to be subclassed. It may be used as the value of an `extends` clause of a class definition but a `super` call to the BigInt constructor will cause an exception.</li>
      </ul>

      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).
          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? <emu-meta suppress-effects="user-code">ToBigInt(_prim_)</emu-meta>.
        </emu-alg>

        <emu-clause id="sec-numbertobigint" type="abstract operation">
          <h1>
            NumberToBigInt (
              _number_: a Number,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _number_ is not an integral Number, throw a *RangeError* exception.
            1. Return ℤ(ℝ(_number_)).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>Properties of the BigInt Constructor</h1>
      <p>The BigInt constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-bigint.asintn">
        <h1>BigInt.asIntN ( _bits_, _bigint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Set _bits_ to ? ToIndex(_bits_).
          1. Set _bigint_ to ? ToBigInt(_bigint_).
          1. Let _mod_ be ℝ(_bigint_) modulo 2<sup>_bits_</sup>.
          1. If _mod_ ≥ 2<sup>_bits_ - 1</sup>, return ℤ(_mod_ - 2<sup>_bits_</sup>); otherwise return ℤ(_mod_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.asuintn">
        <h1>BigInt.asUintN ( _bits_, _bigint_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Set _bits_ to ? ToIndex(_bits_).
          1. Set _bigint_ to ? ToBigInt(_bigint_).
          1. Return ℤ(ℝ(_bigint_) modulo 2<sup>_bits_</sup>).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype">
        <h1>BigInt.prototype</h1>
        <p>The initial value of `BigInt.prototype` is the BigInt prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>Properties of the BigInt Prototype Object</h1>
      <p>The <dfn>BigInt prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%BigInt.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a BigInt object; it does not have a [[BigIntData]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <p>The phrase “this BigInt value” within the specification of a method refers to the result returned by calling the abstract operation ThisBigIntValue with the *this* value of the method invocation passed as the argument.</p>

      <emu-clause id="sec-bigint.prototype.constructor">
        <h1>BigInt.prototype.constructor</h1>
        <p>The initial value of `BigInt.prototype.constructor` is %BigInt%.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tolocalestring">
        <h1>BigInt.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method produces a String value that represents this BigInt value formatted according to the conventions of the host environment's current locale. This method is implementation-defined, and it is permissible, but not encouraged, for it to return the same thing as `toString`.</p>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.tostring">
        <h1>BigInt.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>The optional _radix_ should be an integral Number value in the inclusive interval from *2*<sub>𝔽</sub> to *36*<sub>𝔽</sub>. If _radix_ is *undefined* then *10*<sub>𝔽</sub> is used as the value of _radix_.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _x_ be ? ThisBigIntValue(*this* value).
          1. If _radix_ is *undefined*, let _radixMV_ be 10.
          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).
          1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.
          1. Return BigInt::toString(_x_, _radixMV_).
        </emu-alg>
        <p>This method is not generic; it throws a *TypeError* exception if its *this* value is not a BigInt or a BigInt object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype.valueof">
        <h1>BigInt.prototype.valueOf ( )</h1>
        <emu-alg>
          1. Return ? ThisBigIntValue(*this* value).
        </emu-alg>

        <emu-clause id="sec-thisbigintvalue" type="abstract operation" oldids="thisbigintvalue">
          <h1>
            ThisBigIntValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a BigInt or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _value_ is a BigInt, return _value_.
            1. If _value_ is an Object and _value_ has a [[BigIntData]] internal slot, then
              1. Assert: _value_.[[BigIntData]] is a BigInt.
              1. Return _value_.[[BigIntData]].
            1. Throw a *TypeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-bigint.prototype-@@tostringtag" id="sec-bigint.prototype-%symbol.tostringtag%">
        <h1>BigInt.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"BigInt"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-bigint-instances">
      <h1>Properties of BigInt Instances</h1>
      <p>BigInt instances are ordinary objects that inherit properties from the BigInt prototype object. BigInt instances also have a [[BigIntData]] internal slot. The [[BigIntData]] internal slot is the BigInt value represented by this BigInt object.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-math-object">
    <h1>The Math Object</h1>
    <p>The Math object:</p>
    <ul>
      <li>is <dfn>%Math%</dfn>.</li>
      <li>is the initial value of the *"Math"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <emu-note>
      <p>In this specification, the phrase “the Number value for _x_” has a technical meaning defined in <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-value-properties-of-the-math-object">
      <h1>Value Properties of the Math Object</h1>

      <emu-clause id="sec-math.e">
        <h1>Math.E</h1>
        <p>The Number value for <i>e</i>, the base of the natural logarithms, which is approximately 2.7182818284590452354.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln10">
        <h1>Math.LN10</h1>
        <p>The Number value for the natural logarithm of 10, which is approximately 2.302585092994046.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.ln2">
        <h1>Math.LN2</h1>
        <p>The Number value for the natural logarithm of 2, which is approximately 0.6931471805599453.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.log10e">
        <h1>Math.LOG10E</h1>
        <p>The Number value for the base-10 logarithm of <i>e</i>, the base of the natural logarithms; this value is approximately 0.4342944819032518.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>The value of `Math.LOG10E` is approximately the reciprocal of the value of `Math.LN10`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.log2e">
        <h1>Math.LOG2E</h1>
        <p>The Number value for the base-2 logarithm of <i>e</i>, the base of the natural logarithms; this value is approximately 1.4426950408889634.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>The value of `Math.LOG2E` is approximately the reciprocal of the value of `Math.LN2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.pi">
        <h1>Math.PI</h1>
        <p>The Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 3.1415926535897932.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-math.sqrt1_2">
        <h1>Math.SQRT1_2</h1>
        <p>The Number value for the square root of ½, which is approximately 0.7071067811865476.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>The value of `Math.SQRT1_2` is approximately the reciprocal of the value of `Math.SQRT2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt2">
        <h1>Math.SQRT2</h1>
        <p>The Number value for the square root of 2, which is approximately 1.4142135623730951.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-math-@@tostringtag" id="sec-math-%symbol.tostringtag%">
        <h1>Math [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Math"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-function-properties-of-the-math-object">
      <h1>Function Properties of the Math Object</h1>
      <emu-note>
        <p>The behaviour of the functions `acos`, `acosh`, `asin`, `asinh`, `atan`, `atanh`, `atan2`, `cbrt`, `cos`, `cosh`, `exp`, `expm1`, `hypot`, `log`, `log1p`, `log2`, `log10`, `pow`, `random`, `sin`, `sinh`, `tan`, and `tanh` is not precisely specified here except to require specific results for certain argument values that represent boundary cases of interest. For other argument values, these functions are intended to compute approximations to the results of familiar mathematical functions, but some latitude is allowed in the choice of approximation algorithms. The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform.</p>
        <p>Although the choice of algorithms is left to the implementation, it is recommended (but not specified by this standard) that implementations use the approximation algorithms for IEEE 754-2019 arithmetic contained in `fdlibm`, the freely distributable mathematical library from Sun Microsystems (<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>).</p>
      </emu-note>

      <emu-clause id="sec-math.abs">
        <h1>Math.abs ( _x_ )</h1>
        <p>This function returns the absolute value of _x_; the result has the same magnitude as _x_ but has positive sign.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, return *NaN*.
          1. If _n_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.
          1. If _n_ &lt; *-0*<sub>𝔽</sub>, return -_n_.
          1. Return _n_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acos">
        <h1>Math.acos ( _x_ )</h1>
        <p>This function returns the inverse cosine of _x_. The result is expressed in radians and is in the inclusive interval from *+0*<sub>𝔽</sub> to 𝔽(π).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, _n_ > *1*<sub>𝔽</sub>, or _n_ &lt; *-1*<sub>𝔽</sub>, return *NaN*.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the inverse cosine of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.acosh">
        <h1>Math.acosh ( _x_ )</h1>
        <p>This function returns the inverse hyperbolic cosine of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ &lt; *1*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the inverse hyperbolic cosine of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asin">
        <h1>Math.asin ( _x_ )</h1>
        <p>This function returns the inverse sine of _x_. The result is expressed in radians and is in the inclusive interval from 𝔽(-π / 2) to 𝔽(π / 2).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ > *1*<sub>𝔽</sub> or _n_ &lt; *-1*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the inverse sine of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.asinh">
        <h1>Math.asinh ( _x_ )</h1>
        <p>This function returns the inverse hyperbolic sine of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.
          1. Return an implementation-approximated Number value representing the inverse hyperbolic sine of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan">
        <h1>Math.atan ( _x_ )</h1>
        <p>This function returns the inverse tangent of _x_. The result is expressed in radians and is in the inclusive interval from 𝔽(-π / 2) to 𝔽(π / 2).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.
          1. If _n_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.
          1. Return an implementation-approximated Number value representing the inverse tangent of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atanh">
        <h1>Math.atanh ( _x_ )</h1>
        <p>This function returns the inverse hyperbolic tangent of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ > *1*<sub>𝔽</sub> or _n_ &lt; *-1*<sub>𝔽</sub>, return *NaN*.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.
          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the inverse hyperbolic tangent of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.atan2">
        <h1>Math.atan2 ( _y_, _x_ )</h1>
        <p>This function returns the inverse tangent of the quotient <emu-eqn>_y_ / _x_</emu-eqn> of the arguments _y_ and _x_, where the signs of _y_ and _x_ are used to determine the quadrant of the result. Note that it is intentional and traditional for the two-argument inverse tangent function that the argument named _y_ be first and the argument named _x_ be second. The result is expressed in radians and is in the inclusive interval from -π to +π.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _ny_ be ? ToNumber(_y_).
          1. Let _nx_ be ? ToNumber(_x_).
          1. If _ny_ is *NaN* or _nx_ is *NaN*, return *NaN*.
          1. If _ny_ is *+∞*<sub>𝔽</sub>, then
            1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 4.
            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing 3π / 4.
            1. Return an implementation-approximated Number value representing π / 2.
          1. If _ny_ is *-∞*<sub>𝔽</sub>, then
            1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 4.
            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -3π / 4.
            1. Return an implementation-approximated Number value representing -π / 2.
          1. If _ny_ is *+0*<sub>𝔽</sub>, then
            1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
            1. Return an implementation-approximated Number value representing π.
          1. If _ny_ is *-0*<sub>𝔽</sub>, then
            1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
            1. Return an implementation-approximated Number value representing -π.
          1. Assert: _ny_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.
          1. If _ny_ > *+0*<sub>𝔽</sub>, then
            1. If _nx_ is *+∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π.
            1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.
          1. If _ny_ &lt; *-0*<sub>𝔽</sub>, then
            1. If _nx_ is *+∞*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π.
            1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.
          1. Assert: _nx_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.
          1. Let _r_ be the inverse tangent of abs(ℝ(_ny_) / ℝ(_nx_)).
          1. If _nx_ &lt; *-0*<sub>𝔽</sub>, then
            1. If _ny_ > *+0*<sub>𝔽</sub>, set _r_ to π - _r_.
            1. Else, set _r_ to -π + _r_.
          1. Else,
            1. If _ny_ &lt; *-0*<sub>𝔽</sub>, set _r_ to -_r_.
          1. Return an implementation-approximated Number value representing _r_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cbrt">
        <h1>Math.cbrt ( _x_ )</h1>
        <p>This function returns the cube root of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.
          1. Return an implementation-approximated Number value representing the cube root of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.ceil">
        <h1>Math.ceil ( _x_ )</h1>
        <p>This function returns the smallest (closest to -∞) integral Number value that is not less than _x_. If _x_ is already an integral Number, the result is _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. If _n_ is an integral Number, return _n_.
          1. Return the smallest (closest to -∞) integral Number value that is not less than _n_.
        </emu-alg>
        <emu-note>
          <p>The value of `Math.ceil(x)` is the same as the value of `-Math.floor(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.clz32">
        <h1>Math.clz32 ( _x_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToUint32(_x_).
          1. Let _p_ be the number of leading zero bits in the unsigned 32-bit binary representation of _n_.
          1. Return 𝔽(_p_).
        </emu-alg>
        <emu-note>
          <p>If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, this method returns *32*<sub>𝔽</sub>. If the most significant bit of the 32-bit binary encoding of _n_ is 1, this method returns *+0*<sub>𝔽</sub>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.cos">
        <h1>Math.cos ( _x_ )</h1>
        <p>This function returns the cosine of _x_. The argument is expressed in radians.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite, return *NaN*.
          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the cosine of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.cosh">
        <h1>Math.cosh ( _x_ )</h1>
        <p>This function returns the hyperbolic cosine of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, return *NaN*.
          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.
          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the hyperbolic cosine of ℝ(_n_).
        </emu-alg>
        <emu-note>
          <p>The value of `Math.cosh(x)` is the same as the value of `(Math.exp(x) + Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.exp">
        <h1>Math.exp ( _x_ )</h1>
        <p>This function returns the exponential function of _x_ (_e_ raised to the power of _x_, where _e_ is the base of the natural logarithms).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.
          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the exponential function of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.expm1">
        <h1>Math.expm1 ( _x_ )</h1>
        <p>This function returns the result of subtracting 1 from the exponential function of _x_ (_e_ raised to the power of _x_, where _e_ is the base of the natural logarithms). The result is computed in a way that is accurate even when the value of _x_ is close to 0.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.
          1. Let _exp_ be the exponential function of ℝ(_n_).
          1. Return an implementation-approximated Number value representing _exp_ - 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.floor">
        <h1>Math.floor ( _x_ )</h1>
        <p>This function returns the greatest (closest to +∞) integral Number value that is not greater than _x_. If _x_ is already an integral Number, the result is _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is an integral Number, return _n_.
          1. Return the greatest (closest to +∞) integral Number value that is not greater than _n_.
        </emu-alg>
        <emu-note>
          <p>The value of `Math.floor(x)` is the same as the value of `-Math.ceil(-x)`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.fround">
        <h1>Math.fround ( _x_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, return *NaN*.
          1. If _n_ is one of *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return _n_.
          1. Let _n32_ be the result of converting _n_ to IEEE 754-2019 binary32 format using roundTiesToEven mode.
          1. Let _n64_ be the result of converting _n32_ to IEEE 754-2019 binary64 format.
          1. Return the ECMAScript Number value corresponding to _n64_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.f16round">
        <h1>Math.f16round ( _x_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is *NaN*, return *NaN*.
          1. If _n_ is one of *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return _n_.
          1. Let _n16_ be the result of converting _n_ to IEEE 754-2019 binary16 format using roundTiesToEven mode.
          1. Let _n64_ be the result of converting _n16_ to IEEE 754-2019 binary64 format.
          1. Return the ECMAScript Number value corresponding to _n64_.
        </emu-alg>
        <emu-note>
          <p>This operation is not the same as casting to binary32 and then to binary16 because of the possibility of double-rounding: consider the number _k_ = *1.00048828125000022204*<sub>𝔽</sub>, for example, for which Math.f16round(_k_) is *1.0009765625*<sub>𝔽</sub>, but Math.f16round(Math.fround(_k_)) is *1*<sub>𝔽</sub>.</p>
          <p>Not all platforms provide native support for casting from binary64 to binary16. There are various libraries which can provide this, including the MIT-licensed <a href="https://half.sourceforge.net/">half</a> library. Alternatively, it is possible to first cast from binary64 to binary32 under roundTiesToEven and then check whether the result could lead to incorrect double-rounding. The cases which could can be handled explicitly by adjusting the mantissa of the binary32 value so that it is the value which would be produced by performing the initial cast under roundTiesToOdd. Casting the adjusted value to binary16 under roundTiesToEven then produces the correct value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.hypot">
        <h1>Math.hypot ( ..._args_ )</h1>
        <p>Given zero or more arguments, this function returns the square root of the sum of squares of its arguments.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToNumber(_arg_).
            1. Append _n_ to _coerced_.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.
          1. Let _onlyZero_ be *true*.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>, set _onlyZero_ to *false*.
          1. If _onlyZero_ is *true*, return *+0*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.
        </emu-alg>
        <p>The *"length"* property of this function is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>Implementations should take care to avoid the loss of precision from overflows and underflows that are prone to occur in naive implementations when this function is called with two or more arguments.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.imul">
        <h1>Math.imul ( _x_, _y_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _a_ be ℝ(? ToUint32(_x_)).
          1. Let _b_ be ℝ(? ToUint32(_y_)).
          1. Let _product_ be (_a_ × _b_) modulo 2<sup>32</sup>.
          1. If _product_ ≥ 2<sup>31</sup>, return 𝔽(_product_ - 2<sup>32</sup>); otherwise return 𝔽(_product_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log">
        <h1>Math.log ( _x_ )</h1>
        <p>This function returns the natural logarithm of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.
          1. If _n_ &lt; *-0*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the natural logarithm of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log1p">
        <h1>Math.log1p ( _x_ )</h1>
        <p>This function returns the natural logarithm of 1 + _x_. The result is computed in a way that is accurate even when the value of x is close to zero.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.
          1. If _n_ &lt; *-1*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the natural logarithm of 1 + ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log10">
        <h1>Math.log10 ( _x_ )</h1>
        <p>This function returns the base 10 logarithm of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.
          1. If _n_ &lt; *-0*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the base 10 logarithm of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.log2">
        <h1>Math.log2 ( _x_ )</h1>
        <p>This function returns the base 2 logarithm of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.
          1. If _n_ &lt; *-0*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the base 2 logarithm of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.max">
        <h1>Math.max ( ..._args_ )</h1>
        <p>Given zero or more arguments, this function calls ToNumber on each of the arguments and returns the largest of the resulting values.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToNumber(_arg_).
            1. Append _n_ to _coerced_.
          1. Let _highest_ be *-∞*<sub>𝔽</sub>.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is *+0*<sub>𝔽</sub> and _highest_ is *-0*<sub>𝔽</sub>, set _highest_ to *+0*<sub>𝔽</sub>.
            1. If _number_ > _highest_, set _highest_ to _number_.
          1. Return _highest_.
        </emu-alg>
        <emu-note>
          <p>The comparison of values to determine the largest value is done using the IsLessThan algorithm except that *+0*<sub>𝔽</sub> is considered to be larger than *-0*<sub>𝔽</sub>.</p>
        </emu-note>
        <p>The *"length"* property of this function is *2*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-math.min">
        <h1>Math.min ( ..._args_ )</h1>
        <p>Given zero or more arguments, this function calls ToNumber on each of the arguments and returns the smallest of the resulting values.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _coerced_ be a new empty List.
          1. For each element _arg_ of _args_, do
            1. Let _n_ be ? ToNumber(_arg_).
            1. Append _n_ to _coerced_.
          1. Let _lowest_ be *+∞*<sub>𝔽</sub>.
          1. For each element _number_ of _coerced_, do
            1. If _number_ is *NaN*, return *NaN*.
            1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.
            1. If _number_ &lt; _lowest_, set _lowest_ to _number_.
          1. Return _lowest_.
        </emu-alg>
        <emu-note>
          <p>The comparison of values to determine the largest value is done using the IsLessThan algorithm except that *+0*<sub>𝔽</sub> is considered to be larger than *-0*<sub>𝔽</sub>.</p>
        </emu-note>
        <p>The *"length"* property of this function is *2*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Set _base_ to ? ToNumber(_base_).
          1. Set _exponent_ to ? ToNumber(_exponent_).
          1. Return Number::exponentiate(_base_, _exponent_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.random">
        <h1>Math.random ( )</h1>
        <p>This function returns a Number value with positive sign, greater than or equal to *+0*<sub>𝔽</sub> but strictly less than *1*<sub>𝔽</sub>, chosen randomly or pseudo randomly with approximately uniform distribution over that range, using an implementation-defined algorithm or strategy.</p>
        <p>Each `Math.random` function created for distinct realms must produce a distinct sequence of values from successive calls.</p>
      </emu-clause>

      <emu-clause id="sec-math.round">
        <h1>Math.round ( _x_ )</h1>
        <p>This function returns the Number value that is closest to _x_ and is integral. If two integral Numbers are equally close to _x_, then the result is the Number value that is closer to +∞. If _x_ is already integral, the result is _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is an integral Number, return _n_.
          1. If _n_ &lt; *0.5*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ &lt; *-0*<sub>𝔽</sub> and _n_ ≥ *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. Return the integral Number closest to _n_, preferring the Number closer to +∞ in the case of a tie.
        </emu-alg>
        <emu-note>
          <p>`Math.round(3.5)` returns 4, but `Math.round(-3.5)` returns -3.</p>
        </emu-note>
        <emu-note>
          <p>The value of `Math.round(x)` is not always the same as the value of `Math.floor(x + 0.5)`. When `x` is *-0*<sub>𝔽</sub> or `x` is less than *-0*<sub>𝔽</sub> but greater than or equal to *-0.5*<sub>𝔽</sub>, `Math.round(x)` returns *-0*<sub>𝔽</sub>, but `Math.floor(x + 0.5)` returns *+0*<sub>𝔽</sub>. `Math.round(x)` may also differ from the value of `Math.floor(x + 0.5)`because of internal rounding when computing `x + 0.5`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sign">
        <h1>Math.sign ( _x_ )</h1>
        <p>This function returns the sign of _x_, indicating whether _x_ is positive, negative, or zero.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *-0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.
          1. Return *1*<sub>𝔽</sub>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sin">
        <h1>Math.sin ( _x_ )</h1>
        <p>This function returns the sine of _x_. The argument is expressed in radians.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the sine of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sinh">
        <h1>Math.sinh ( _x_ )</h1>
        <p>This function returns the hyperbolic sine of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.
          1. Return an implementation-approximated Number value representing the hyperbolic sine of ℝ(_n_).
        </emu-alg>
        <emu-note>
          <p>The value of `Math.sinh(x)` is the same as the value of `(Math.exp(x) - Math.exp(-x)) / 2`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.sqrt">
        <h1>Math.sqrt ( _x_ )</h1>
        <p>This function returns the square root of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *-0*<sub>𝔽</sub>, return *NaN*.
          1. Return 𝔽(the square root of ℝ(_n_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.sumprecise">
        <h1>Math.sumPrecise ( _items_ )</h1>
        <p>Given an iterable of Numbers, this function sums each value in the iterable and returns their sum. If any value is not a Number it throws a *TypeError* exception.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Perform ? RequireObjectCoercible(_items_).
          1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).
          1. Let _state_ be ~minus-zero~.
          1. Let _sum_ be 0.
          1. Let _count_ be 0.
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is not ~done~, then
              1. If _count_ ≥ 2<sup>53</sup> - 1, then
                1. NOTE: This step is not expected to be reached in practice and is included only so that implementations may rely on inputs being "reasonably sized" without violating this specification.
                1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _error_).
              1. If _next_ is not a Number, then
                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _error_).
              1. Let _n_ be _next_.
              1. If _state_ is not ~not-a-number~, then
                1. If _n_ is *NaN*, then
                  1. Set _state_ to ~not-a-number~.
                1. Else if _n_ is *+∞*<sub>𝔽</sub>, then
                  1. If _state_ is ~minus-infinity~, set _state_ to ~not-a-number~.
                  1. Else, set _state_ to ~plus-infinity~.
                1. Else if _n_ is *-∞*<sub>𝔽</sub>, then
                  1. If _state_ is ~plus-infinity~, set _state_ to ~not-a-number~.
                  1. Else, set _state_ to ~minus-infinity~.
                1. Else if _n_ is not *-0*<sub>𝔽</sub> and _state_ is either ~minus-zero~ or ~finite~, then
                  1. Set _state_ to ~finite~.
                  1. Set _sum_ to _sum_ + ℝ(_n_).
              1. Set _count_ to _count_ + 1.
          1. If _state_ is ~not-a-number~, return *NaN*.
          1. If _state_ is ~plus-infinity~, return *+∞*<sub>𝔽</sub>.
          1. If _state_ is ~minus-infinity~, return *-∞*<sub>𝔽</sub>.
          1. If _state_ is ~minus-zero~, return *-0*<sub>𝔽</sub>.
          1. Return 𝔽(_sum_).
        </emu-alg>
        <emu-note>
          <p>The value of _sum_ can be computed without arbitrary-precision arithmetic by a variety of algorithms. One such is the "Grow-Expansion" algorithm given in <i>Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates</i> by Jonathan Richard Shewchuk. A more recent algorithm is given in "<a href="https://arxiv.org/abs/1505.05571">Fast exact summation using small and large superaccumulators</a>", code for which is available at <a href="https://gitlab.com/radfordneal/xsum">https://gitlab.com/radfordneal/xsum</a>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.tan">
        <h1>Math.tan ( _x_ )</h1>
        <p>This function returns the tangent of _x_. The argument is expressed in radians.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.
          1. Return an implementation-approximated Number value representing the tangent of ℝ(_n_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-math.tanh">
        <h1>Math.tanh ( _x_ )</h1>
        <p>This function returns the hyperbolic tangent of _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ is *+∞*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.
          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.
          1. Return an implementation-approximated Number value representing the hyperbolic tangent of ℝ(_n_).
        </emu-alg>
        <emu-note>
          <p>The value of `Math.tanh(x)` is the same as the value of `(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-math.trunc">
        <h1>Math.trunc ( _x_ )</h1>
        <p>This function returns the integral part of the number _x_, removing any fractional digits. If _x_ is already integral, the result is _x_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _n_ be ? ToNumber(_x_).
          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.
          1. If _n_ &lt; *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _n_ &lt; *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.
          1. Return the integral Number nearest _n_ in the direction of *+0*<sub>𝔽</sub>.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-date-objects">
    <h1>Date Objects</h1>

    <emu-clause id="sec-overview-of-date-objects-and-definitions-of-abstract-operations">
      <h1>Overview of Date Objects and Definitions of Abstract Operations</h1>
      <p>The following abstract operations operate on time values (defined in <emu-xref href="#sec-time-values-and-time-range"></emu-xref>). Note that, in every case, if any argument to one of these functions is *NaN*, the result will be *NaN*.</p>

      <emu-clause id="sec-time-values-and-time-range">
        <h1>Time Values and Time Range</h1>
        <p>Time measurement in ECMAScript is analogous to time measurement in POSIX, in particular sharing definition in terms of the proleptic Gregorian calendar, an <dfn id="epoch">epoch</dfn> of midnight at the beginning of 1 January 1970 UTC, and an accounting of every day as comprising exactly 86,400 seconds (each of which is 1000 milliseconds long).</p>
        <p>An ECMAScript <dfn variants="time values">time value</dfn> is a Number, either a finite integral Number representing an instant in time to millisecond precision or *NaN* representing no specific instant. A time value that is a multiple of <emu-eqn>24 × 60 × 60 × 1000 = 86,400,000</emu-eqn> (i.e., is 86,400,000 × _d_ for some integer _d_) represents the instant at the start of the UTC day that follows the epoch by _d_ whole UTC days (preceding the epoch for negative _d_). Every other finite time value _t_ is defined relative to the greatest preceding time value _s_ that is such a multiple, and represents the instant that occurs within the same UTC day as _s_ but follows it by (_t_ - _s_) milliseconds.</p>
        <p>Time values do not account for UTC leap seconds—there are no time values representing instants within positive leap seconds, and there are time values representing instants removed from the UTC timeline by negative leap seconds. However, the definition of time values nonetheless yields piecewise alignment with UTC, with discontinuities only at leap second boundaries and zero difference outside of leap seconds.</p>
        <p>A Number can exactly represent all integers from -9,007,199,254,740,992 to 9,007,199,254,740,992 (<emu-xref href="#sec-number.min_safe_integer"></emu-xref> and <emu-xref href="#sec-number.max_safe_integer"></emu-xref>). A time value supports a slightly smaller range of -8,640,000,000,000,000 to 8,640,000,000,000,000 milliseconds. This yields a supported time value range of exactly -100,000,000 days to 100,000,000 days relative to midnight at the beginning of 1 January 1970 UTC.</p>
        <p>The exact moment of midnight at the beginning of 1 January 1970 UTC is represented by the time value *+0*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>In the proleptic Gregorian calendar, leap years are precisely those which are both divisible by 4 and either divisible by 400 or not divisible by 100.</p>
          <p>The 400 year cycle of the proleptic Gregorian calendar contains 97 leap years. This yields an average of 365.2425 days per year, which is 31,556,952,000 milliseconds. Therefore, the maximum range a Number could represent exactly with millisecond precision is approximately -285,426 to 285,426 years relative to 1970. The smaller range supported by a time value as specified in this section is approximately -273,790 to 273,790 years relative to 1970.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-related-constants">
        <h1>Time-related Constants</h1>
        <p>These constants are referenced by algorithms in the following sections.</p>
        <emu-eqn id="eqn-HoursPerDay" aoid="HoursPerDay">HoursPerDay = 24</emu-eqn>
        <emu-eqn id="eqn-MinutesPerHour" aoid="MinutesPerHour">MinutesPerHour = 60</emu-eqn>
        <emu-eqn id="eqn-SecondsPerMinute" aoid="SecondsPerMinute">SecondsPerMinute = 60</emu-eqn>
        <emu-eqn id="eqn-msPerSecond" aoid="msPerSecond">msPerSecond = *1000*<sub>𝔽</sub></emu-eqn>
        <emu-eqn id="eqn-msPerMinute" aoid="msPerMinute">msPerMinute = *60000*<sub>𝔽</sub> = msPerSecond × 𝔽(SecondsPerMinute)</emu-eqn>
        <emu-eqn id="eqn-msPerHour" aoid="msPerHour">msPerHour = *3600000*<sub>𝔽</sub> = msPerMinute × 𝔽(MinutesPerHour)</emu-eqn>
        <emu-eqn id="eqn-msPerDay" aoid="msPerDay">msPerDay = *86400000*<sub>𝔽</sub> = msPerHour × 𝔽(HoursPerDay)</emu-eqn>
      </emu-clause>

      <emu-clause id="sec-day" type="abstract operation" oldids="eqn-Day,sec-day-number-and-time-within-day">
        <h1>
          Day (
            _t_: a finite time value,
          ): an integral Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the day number of the day in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(floor(ℝ(_t_ / msPerDay))).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timewithinday" type="abstract operation" oldids="eqn-TimeWithinDay">
        <h1>
          TimeWithinDay (
            _t_: a finite time value,
          ): an integral Number in the interval from *+0*<sub>𝔽</sub> (inclusive) to msPerDay (exclusive)
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the number of milliseconds since the start of the day in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerDay)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daysinyear" type="abstract operation" oldids="eqn-DaysInYear,sec-year-number">
        <h1>
          DaysInYear (
            _y_: an integral Number,
          ): *365*<sub>𝔽</sub> or *366*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the number of days in year _y_. Leap years have 366 days; all other years have 365.</dd>
        </dl>
        <emu-alg>
          1. Let _ry_ be ℝ(_y_).
          1. If (_ry_ modulo 400) = 0, return *366*<sub>𝔽</sub>.
          1. If (_ry_ modulo 100) = 0, return *365*<sub>𝔽</sub>.
          1. If (_ry_ modulo 4) = 0, return *366*<sub>𝔽</sub>.
          1. Return *365*<sub>𝔽</sub>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dayfromyear" type="abstract operation" oldids="eqn-DaysFromYear">
        <h1>
          DayFromYear (
            _y_: an integral Number,
          ): an integral Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the day number of the first day of year _y_.</dd>
        </dl>
        <emu-alg>
          1. Let _ry_ be ℝ(_y_).
          1. [declared="numYears1,numYears4,numYears100,numYears400"] NOTE: In the following steps, _numYears1_, _numYears4_, _numYears100_, and _numYears400_ represent the number of years divisible by 1, 4, 100, and 400, respectively, that occur between the epoch and the start of year _y_. The number is negative if _y_ is before the epoch.
          1. Let _numYears1_ be (_ry_ - 1970).
          1. Let _numYears4_ be floor((_ry_ - 1969) / 4).
          1. Let _numYears100_ be floor((_ry_ - 1901) / 100).
          1. Let _numYears400_ be floor((_ry_ - 1601) / 400).
          1. Return 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timefromyear" type="abstract operation" oldids="eqn-TimeFromYear">
        <h1>
          TimeFromYear (
            _y_: an integral Number,
          ): a time value
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the time value of the start of year _y_.</dd>
        </dl>
        <emu-alg>
          1. Return msPerDay × DayFromYear(_y_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yearfromtime" type="abstract operation" oldids="eqn-YearFromTime">
        <h1>
          YearFromTime (
            _t_: a finite time value,
          ): an integral Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the year in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. [declared="y"] Return the largest integral Number _y_ (closest to +∞) such that TimeFromYear(_y_) ≤ _t_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-daywithinyear" type="abstract operation" oldids="eqn-DayWithinYear">
        <h1>
          DayWithinYear (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *365*<sub>𝔽</sub>
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return Day(_t_) - DayFromYear(YearFromTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-inleapyear" type="abstract operation" oldids="eqn-InLeapYear">
        <h1>
          InLeapYear (
            _t_: a finite time value,
          ): *+0*<sub>𝔽</sub> or *1*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns *1*<sub>𝔽</sub> if _t_ is within a leap year and *+0*<sub>𝔽</sub> otherwise.</dd>
        </dl>
        <emu-alg>
          1. If DaysInYear(YearFromTime(_t_)) is *366*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>; else return *+0*<sub>𝔽</sub>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-monthfromtime" type="abstract operation" oldids="eqn-MonthFromTime,sec-month-number">
        <h1>
          MonthFromTime (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *11*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns a Number identifying the month in which _t_ falls. A month value of *+0*<sub>𝔽</sub> specifies January; *1*<sub>𝔽</sub> specifies February; *2*<sub>𝔽</sub> specifies March; *3*<sub>𝔽</sub> specifies April; *4*<sub>𝔽</sub> specifies May; *5*<sub>𝔽</sub> specifies June; *6*<sub>𝔽</sub> specifies July; *7*<sub>𝔽</sub> specifies August; *8*<sub>𝔽</sub> specifies September; *9*<sub>𝔽</sub> specifies October; *10*<sub>𝔽</sub> specifies November; and *11*<sub>𝔽</sub> specifies December. Note that <emu-eqn>MonthFromTime(*+0*<sub>𝔽</sub>) = *+0*<sub>𝔽</sub></emu-eqn>, corresponding to Thursday, 1 January 1970.</dd>
        </dl>
        <emu-alg>
          1. Let _inLeapYear_ be InLeapYear(_t_).
          1. Let _dayWithinYear_ be DayWithinYear(_t_).
          1. If _dayWithinYear_ &lt; *31*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *59*<sub>𝔽</sub> + _inLeapYear_, return *1*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *90*<sub>𝔽</sub> + _inLeapYear_, return *2*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *120*<sub>𝔽</sub> + _inLeapYear_, return *3*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *151*<sub>𝔽</sub> + _inLeapYear_, return *4*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *181*<sub>𝔽</sub> + _inLeapYear_, return *5*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *212*<sub>𝔽</sub> + _inLeapYear_, return *6*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *243*<sub>𝔽</sub> + _inLeapYear_, return *7*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *273*<sub>𝔽</sub> + _inLeapYear_, return *8*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *304*<sub>𝔽</sub> + _inLeapYear_, return *9*<sub>𝔽</sub>.
          1. If _dayWithinYear_ &lt; *334*<sub>𝔽</sub> + _inLeapYear_, return *10*<sub>𝔽</sub>.
          1. Assert: _dayWithinYear_ &lt; *365*<sub>𝔽</sub> + _inLeapYear_.
          1. Return *11*<sub>𝔽</sub>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-datefromtime" type="abstract operation" oldids="sec-date-number">
        <h1>
          DateFromTime (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *1*<sub>𝔽</sub> to *31*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the day of the month in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Let _inLeapYear_ be InLeapYear(_t_).
          1. Let _dayWithinYear_ be DayWithinYear(_t_).
          1. Let _month_ be MonthFromTime(_t_).
          1. If _month_ is *+0*<sub>𝔽</sub>, return _dayWithinYear_ + *1*<sub>𝔽</sub>.
          1. If _month_ is *1*<sub>𝔽</sub>, return _dayWithinYear_ - *30*<sub>𝔽</sub>.
          1. If _month_ is *2*<sub>𝔽</sub>, return _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *3*<sub>𝔽</sub>, return _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *4*<sub>𝔽</sub>, return _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *5*<sub>𝔽</sub>, return _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *6*<sub>𝔽</sub>, return _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *7*<sub>𝔽</sub>, return _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *8*<sub>𝔽</sub>, return _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *9*<sub>𝔽</sub>, return _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_.
          1. If _month_ is *10*<sub>𝔽</sub>, return _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_.
          1. Assert: _month_ is *11*<sub>𝔽</sub>.
          1. Return _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weekday" type="abstract operation" oldids="sec-week-day">
        <h1>
          WeekDay (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *6*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns a Number identifying the day of the week in which _t_ falls. A weekday value of *+0*<sub>𝔽</sub> specifies Sunday; *1*<sub>𝔽</sub> specifies Monday; *2*<sub>𝔽</sub> specifies Tuesday; *3*<sub>𝔽</sub> specifies Wednesday; *4*<sub>𝔽</sub> specifies Thursday; *5*<sub>𝔽</sub> specifies Friday; and *6*<sub>𝔽</sub> specifies Saturday. Note that <emu-eqn>WeekDay(*+0*<sub>𝔽</sub>) = *4*<sub>𝔽</sub></emu-eqn>, corresponding to Thursday, 1 January 1970.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hourfromtime" type="abstract operation" oldids="eqn-HourFromTime,sec-hours-minutes-second-and-milliseconds">
        <h1>
          HourFromTime (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *23*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the hour of the day in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-minfromtime" type="abstract operation" oldids="eqn-MinFromTime">
        <h1>
          MinFromTime (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *59*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the minute of the hour in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-secfromtime" type="abstract operation" oldids="eqn-SecFromTime">
        <h1>
          SecFromTime (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *59*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the second of the minute in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-msfromtime" type="abstract operation" oldids="eqn-msFromTime">
        <h1>
          msFromTime (
            _t_: a finite time value,
          ): an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *999*<sub>𝔽</sub>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the millisecond of the second in which _t_ falls.</dd>
        </dl>
        <emu-alg>
          1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerSecond)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getutcepochnanoseconds" type="abstract operation">
        <h1>
          GetUTCEpochNanoseconds (
            _year_: an integer,
            _month_: an integer in the inclusive interval from 1 to 12,
            _day_: an integer in the inclusive interval from 1 to 31,
            _hour_: an integer in the inclusive interval from 0 to 23,
            _minute_: an integer in the inclusive interval from 0 to 59,
            _second_: an integer in the inclusive interval from 0 to 59,
            _millisecond_: an integer in the inclusive interval from 0 to 999,
            _microsecond_: an integer in the inclusive interval from 0 to 999,
            _nanosecond_: an integer in the inclusive interval from 0 to 999,
          ): a BigInt
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>The returned value represents a number of nanoseconds since the epoch that corresponds to the given ISO 8601 calendar date and wall-clock time in UTC.</dd>
        </dl>
        <emu-alg>
          1. Let _date_ be MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_)).
          1. Let _time_ be MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_)).
          1. Let _ms_ be MakeDate(_date_, _time_).
          1. Assert: _ms_ is an integral Number.
          1. Return ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifiers">
        <h1>Time Zone Identifiers</h1>

        <p>
          Time zones in ECMAScript are represented by <dfn variants="time zone identifier">time zone identifiers</dfn>, which are Strings composed entirely of code units in the inclusive interval from 0x0000 to 0x007F.
          Time zones supported by an ECMAScript implementation may be <dfn variants="available named time zone">available named time zones</dfn>, represented by the [[Identifier]] field of the Time Zone Identifier Records returned by AvailableNamedTimeZoneIdentifiers, or <dfn variants="offset time zone">offset time zones</dfn>, represented by Strings for which IsTimeZoneOffsetString returns *true*.
        </p>
        <p>
          A <dfn variants="primary time zone identifiers">primary time zone identifier</dfn> is the preferred identifier for an available named time zone.
          A <dfn variants="non-primary time zone identifiers">non-primary time zone identifier</dfn> is an identifier for an available named time zone that is not a primary time zone identifier.
          An <dfn variants="available named time zone identifiers">available named time zone identifier</dfn> is either a primary time zone identifier or a non-primary time zone identifier.
          Each available named time zone identifier is associated with exactly one available named time zone.
          Each available named time zone is associated with exactly one primary time zone identifier and zero or more non-primary time zone identifiers.
        </p>
        <p>
          ECMAScript implementations must support an available named time zone with the identifier *"UTC"*, which must be the primary time zone identifier for the UTC time zone.
          In addition, implementations may support any number of other available named time zones.
        </p>
        <p>
          Implementations that follow the requirements for time zones as described in the ECMA-402 Internationalization API specification are called <dfn>time zone aware</dfn>.
          Time zone aware implementations must support available named time zones corresponding to the Zone and Link names of the IANA Time Zone Database, and only such names.
          In time zone aware implementations, a primary time zone identifier is a Zone name, and a non-primary time zone identifier is a Link name, respectively, in the IANA Time Zone Database except as specifically overridden by AvailableNamedTimeZoneIdentifiers as specified in the ECMA-402 specification.
          Implementations that do not support the entire IANA Time Zone Database are still recommended to use IANA Time Zone Database names as identifiers to represent time zones.
        </p>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneepochnanoseconds" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneEpochNanoseconds (
            _timeZoneIdentifier_: a String,
            _year_: an integer,
            _month_: an integer in the inclusive interval from 1 to 12,
            _day_: an integer in the inclusive interval from 1 to 31,
            _hour_: an integer in the inclusive interval from 0 to 23,
            _minute_: an integer in the inclusive interval from 0 to 59,
            _second_: an integer in the inclusive interval from 0 to 59,
            _millisecond_: an integer in the inclusive interval from 0 to 999,
            _microsecond_: an integer in the inclusive interval from 0 to 999,
            _nanosecond_: an integer in the inclusive interval from 0 to 999,
          ): a List of BigInts
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            Each value in the returned List represents a number of nanoseconds since the epoch that corresponds to the given ISO 8601 calendar date and wall-clock time in the named time zone identified by _timeZoneIdentifier_.
          </dd>
        </dl>
        <p>
          When the input represents a local time occurring more than once because of a negative time zone transition (e.g. when daylight saving time ends or the time zone offset is decreased due to a time zone rule change), the returned List will have more than one element and will be sorted by ascending numerical value.
          When the input represents a local time skipped because of a positive time zone transition (e.g. when daylight saving time begins or the time zone offset is increased due to a time zone rule change), the returned List will be empty.
          Otherwise, the returned List will have one element.
        </p>
        <p>The default implementation of GetNamedTimeZoneEpochNanoseconds, to be used for ECMAScript implementations that do not include local political rules for any time zones, performs the following steps when called:</p>
        <emu-alg>
          1. Assert: _timeZoneIdentifier_ is *"UTC"*.
          1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
          1. Return « _epochNanoseconds_ ».
        </emu-alg>
        <emu-note>
          <p>It is required for time zone aware implementations (and recommended for all others) to use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>1:30 AM on 5 November 2017 in America/New_York is repeated twice, so GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 11, 5, 1, 30, 0, 0, 0, 0) would return a List of length 2 in which the first element represents 05:30 UTC (corresponding with 01:30 US Eastern Daylight Time at UTC offset -04:00) and the second element represents 06:30 UTC (corresponding with 01:30 US Eastern Standard Time at UTC offset -05:00).</p>
          <p>2:30 AM on 12 March 2017 in America/New_York does not exist, so GetNamedTimeZoneEpochNanoseconds(*"America/New_York"*, 2017, 3, 12, 2, 30, 0, 0, 0, 0) would return an empty List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-getnamedtimezoneoffsetnanoseconds" oldids="sec-local-time-zone-adjustment" type="implementation-defined abstract operation">
        <h1>
          GetNamedTimeZoneOffsetNanoseconds (
            _timeZoneIdentifier_: a String,
            _epochNanoseconds_: a BigInt,
          ): an integer
        </h1>
        <dl class="header">
        </dl>
        <p>The returned integer represents the offset from UTC of the named time zone identified by _timeZoneIdentifier_, at the instant corresponding with _epochNanoseconds_ relative to the epoch, both in nanoseconds.</p>
        <p>The default implementation of GetNamedTimeZoneOffsetNanoseconds, to be used for ECMAScript implementations that do not include local political rules for any time zones, performs the following steps when called:</p>
        <emu-alg>
          1. Assert: _timeZoneIdentifier_ is *"UTC"*.
          1. Return 0.
        </emu-alg>
        <emu-note>
          <p>Time zone offset values may be positive or negative.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-time-zone-identifier-record">
        <h1>Time Zone Identifier Record</h1>
        <p>A <dfn variants="Time Zone Identifier Records">Time Zone Identifier Record</dfn> is a Record used to describe an available named time zone identifier and its corresponding primary time zone identifier.</p>
        <p>Time Zone Identifier Records have the fields listed in <emu-xref href="#table-time-zone-identifier-record-fields"></emu-xref>.</p>
        <emu-table id="table-time-zone-identifier-record-fields" caption="Time Zone Identifier Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Identifier]]</td>
              <td>a String</td>
              <td>An available named time zone identifier that is supported by the implementation.</td>
            </tr>
            <tr>
              <td>[[PrimaryIdentifier]]</td>
              <td>a String</td>
              <td>The primary time zone identifier that [[Identifier]] resolves to.</td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>If [[Identifier]] is a primary time zone identifier, then [[Identifier]] is [[PrimaryIdentifier]].</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-availablenamedtimezoneidentifiers" type="implementation-defined abstract operation">
        <h1>AvailableNamedTimeZoneIdentifiers ( ): a List of Time Zone Identifier Records</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            Its result describes all available named time zone identifiers in this implementation, as well as the primary time zone identifier corresponding to each available named time zone identifier.
            The List is ordered according to the [[Identifier]] field of each Time Zone Identifier Record.
          </dd>
        </dl>
        <p>
          Time zone aware implementations, including all implementations that implement the ECMA-402 Internationalization API, must implement the AvailableNamedTimeZoneIdentifiers abstract operation as specified in the ECMA-402 specification.
          For implementations that are not time zone aware, AvailableNamedTimeZoneIdentifiers performs the following steps when called:
        </p>
        <emu-alg>
          1. If the implementation does not include local political rules for any time zones, then
            1. Return « the Time Zone Identifier Record { [[Identifier]]: *"UTC"*, [[PrimaryIdentifier]]: *"UTC"* } ».
          1. Let _identifiers_ be the List of unique available named time zone identifiers, sorted according to lexicographic code unit order.
          1. Let _result_ be a new empty List.
          1. For each element _identifier_ of _identifiers_, do
            1. Let _primary_ be _identifier_.
            1. If _identifier_ is a non-primary time zone identifier in this implementation and _identifier_ is not *"UTC"*, then
              1. Set _primary_ to the primary time zone identifier associated with _identifier_.
              1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.
            1. Let _record_ be the Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }.
            1. Append _record_ to _result_.
          1. Assert: _result_ contains a Time Zone Identifier Record _r_ such that _r_.[[Identifier]] is *"UTC"* and _r_.[[PrimaryIdentifier]] is *"UTC"*.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-systemtimezoneidentifier" oldids="sec-defaulttimezone" type="implementation-defined abstract operation">
        <h1>SystemTimeZoneIdentifier ( ): a String</h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            It returns a String representing the host environment's current time zone, which is either a String representing a UTC offset for which IsTimeZoneOffsetString returns *true*, or a primary time zone identifier.
          </dd>
        </dl>

        <emu-alg>
          1. If the implementation only supports the UTC time zone, return *"UTC"*.
          1. Let _systemTimeZoneString_ be the String representing the host environment's current time zone, either a primary time zone identifier or an offset time zone identifier.
          1. Return _systemTimeZoneString_.
        </emu-alg>

        <emu-note>
          <p>
            To ensure the level of functionality that implementations commonly provide in the methods of the Date object, it is recommended that SystemTimeZoneIdentifier return an IANA time zone name corresponding to the host environment's time zone setting, if such a thing exists.
            GetNamedTimeZoneEpochNanoseconds and GetNamedTimeZoneOffsetNanoseconds must reflect the local political rules for standard time and daylight saving time in that time zone, if such rules exist.
          </p>
          <p>For example, if the host environment is a browser on a system where the user has chosen US Eastern Time as their time zone, SystemTimeZoneIdentifier returns *"America/New_York"*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-localtime" type="abstract operation">
        <h1>
          LocalTime (
            _t_: a finite time value,
          ): an integral Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            It converts _t_ from UTC to local time.
            The local political rules for standard time and daylight saving time in effect at _t_ should be used to determine the result in the way specified in this section.
          </dd>
        </dl>
        <emu-alg>
          1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().
          1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then
            1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).
          1. Else,
            1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>)).
          1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).
          1. Return _t_ + 𝔽(_offsetMs_).
        </emu-alg>
        <emu-note>
          <p>If political rules for the local time _t_ are not available within the implementation, the result is _t_ because SystemTimeZoneIdentifier returns *"UTC"* and GetNamedTimeZoneOffsetNanoseconds returns 0.</p>
        </emu-note>
        <emu-note>
          <p>It is required for time zone aware implementations (and recommended for all others) to use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
        </emu-note>
        <emu-note>
          <p>Two different input time values <emu-eqn>_t_<sub>UTC</sub></emu-eqn> are converted to the same local time <emu-eqn>t<sub>local</sub></emu-eqn> at a negative time zone transition when there are repeated times (e.g. the daylight saving time ends or the time zone adjustment is decreased.).</p>
          <p><emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>local</sub></emu-eqn>. Correspondingly, <emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>UTC</sub></emu-eqn>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" type="abstract operation">
        <h1>
          UTC (
            _t_: a Number,
          ): a time value
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            It converts _t_ from local time to a UTC time value.
            The local political rules for standard time and daylight saving time in effect at _t_ should be used to determine the result in the way specified in this section.
          </dd>
        </dl>
        <emu-alg>
          1. If _t_ is not finite, return *NaN*.
          1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().
          1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then
            1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).
          1. Else,
            1. Let _possibleInstants_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0).
            1. NOTE: The following steps ensure that when _t_ represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transition (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change), _t_ is interpreted using the time zone offset before the transition.
            1. If _possibleInstants_ is not empty, then
              1. Let _disambiguatedInstant_ be _possibleInstants_[0].
            1. Else,
              1. NOTE: _t_ represents a local time skipped at a positive time zone transition (e.g. due to daylight saving time starting or a time zone rule change increasing the UTC offset).
              1. [declared="tBefore"] Let _possibleInstantsBefore_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0), where _tBefore_ is the largest integral Number &lt; _t_ for which _possibleInstantsBefore_ is not empty (i.e., _tBefore_ represents the last local time before the transition).
              1. Let _disambiguatedInstant_ be the last element of _possibleInstantsBefore_.
            1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_).
          1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).
          1. Return _t_ - 𝔽(_offsetMs_).
        </emu-alg>
        <p>
          Input _t_ is nominally a time value but may be any Number value.
          The algorithm must not limit _t_ to the time value range, so that inputs corresponding with a boundary of the time value range can be supported regardless of local UTC offset.
          For example, the maximum time value is 8.64 × 10<sup>15</sup>, corresponding with *"+275760-09-13T00:00:00Z"*.
          In an environment where the local time zone offset is ahead of UTC by 1 hour at that instant, it is represented by the larger input of 8.64 × 10<sup>15</sup> + 3.6 × 10<sup>6</sup>, corresponding with *"+275760-09-13T01:00:00+01:00"*.
        </p>
        <p>If political rules for the local time _t_ are not available within the implementation, the result is _t_ because SystemTimeZoneIdentifier returns *"UTC"* and GetNamedTimeZoneOffsetNanoseconds returns 0.</p>
        <emu-note>
          <p>It is required for time zone aware implementations (and recommended for all others) to use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
          <p>
            1:30 AM on 5 November 2017 in America/New_York is repeated twice (fall backward), but it must be interpreted as 1:30 AM UTC-04 instead of 1:30 AM UTC-05.
            In UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0)))), the value of _offsetMs_ is <emu-eqn>-4 × msPerHour</emu-eqn>.
          </p>
          <p>
            2:30 AM on 12 March 2017 in America/New_York does not exist, but it must be interpreted as 2:30 AM UTC-05 (equivalent to 3:30 AM UTC-04).
            In UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0)))), the value of _offsetMs_ is <emu-eqn>-5 × msPerHour</emu-eqn>.
          </p>
        </emu-note>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>UTC</sub></emu-eqn>. Correspondingly, <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>local</sub></emu-eqn>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-maketime" type="abstract operation">
        <h1>
          MakeTime (
            _hour_: a Number,
            _min_: a Number,
            _sec_: a Number,
            _ms_: a Number,
          ): a Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It calculates a number of milliseconds.</dd>
        </dl>
        <emu-alg>
          1. If _hour_ is not finite, _min_ is not finite, _sec_ is not finite, or _ms_ is not finite, return *NaN*.
          1. Let _h_ be 𝔽(! ToIntegerOrInfinity(_hour_)).
          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_min_)).
          1. Let _s_ be 𝔽(! ToIntegerOrInfinity(_sec_)).
          1. Let _milli_ be 𝔽(! ToIntegerOrInfinity(_ms_)).
          1. Return ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_.
        </emu-alg>
        <emu-note>
          <p>The arithmetic in MakeTime is floating-point arithmetic, which is not associative, so the operations must be performed in the correct order.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-makeday" type="abstract operation">
        <h1>
          MakeDay (
            _year_: a Number,
            _month_: a Number,
            _date_: a Number,
          ): a Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It calculates a number of days.</dd>
        </dl>
        <emu-alg>
          1. If _year_ is not finite, _month_ is not finite, or _date_ is not finite, return *NaN*.
          1. Let _y_ be 𝔽(! ToIntegerOrInfinity(_year_)).
          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_month_)).
          1. Let _dt_ be 𝔽(! ToIntegerOrInfinity(_date_)).
          1. Let _ym_ be _y_ + 𝔽(floor(ℝ(_m_) / 12)).
          1. If _ym_ is not finite, return *NaN*.
          1. Let _mn_ be 𝔽(ℝ(_m_) modulo 12).
          1. Find a finite time value _t_ such that YearFromTime(_t_) is _ym_, MonthFromTime(_t_) is _mn_, and DateFromTime(_t_) is *1*<sub>𝔽</sub>; but if this is not possible (because some argument is out of range), return *NaN*.
          1. Return Day(_t_) + _dt_ - *1*<sub>𝔽</sub>.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makedate" type="abstract operation">
        <h1>
          MakeDate (
            _day_: a Number,
            _time_: a Number,
          ): a Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It calculates a number of milliseconds.</dd>
        </dl>
        <emu-alg>
          1. If _day_ is not finite or _time_ is not finite, return *NaN*.
          1. Let _tv_ be _day_ × msPerDay + _time_.
          1. If _tv_ is not finite, return *NaN*.
          1. Return _tv_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makefullyear" type="abstract operation">
        <h1>
          MakeFullYear (
            _year_: a Number,
          ): an integral Number or *NaN*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the full year associated with the integer part of _year_, interpreting any value in the inclusive interval from 0 to 99 as a count of years since the start of 1900. For alignment with the proleptic Gregorian calendar, "full year" is defined as the signed count of complete years since the start of year 0 (1 B.C.).</dd>
        </dl>
        <emu-alg>
          1. If _year_ is *NaN*, return *NaN*.
          1. Let _truncated_ be ! ToIntegerOrInfinity(_year_).
          1. If _truncated_ is in the inclusive interval from 0 to 99, return *1900*<sub>𝔽</sub> + 𝔽(_truncated_).
          1. Return 𝔽(_truncated_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-timeclip" type="abstract operation">
        <h1>
          TimeClip (
            _time_: a Number,
          ): a Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It calculates a number of milliseconds.</dd>
        </dl>
        <emu-alg>
          1. If _time_ is not finite, return *NaN*.
          1. If abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>, return *NaN*.
          1. Return 𝔽(! ToIntegerOrInfinity(_time_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date-time-string-format">
        <h1>Date Time String Format</h1>
        <p>ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 calendar date extended format. The format is as follows: `YYYY-MM-DDTHH:mm:ss.sssZ`</p>
        <p>Where the elements are as follows:</p>
        <figure>
          <table class="lightweight-table">
            <tr>
              <td>
                `YYYY`
              </td>
              <td>
                is the year in the proleptic Gregorian calendar as four decimal digits from 0000 to 9999, or as an <emu-xref href="#sec-expanded-years">expanded year</emu-xref> of *"+"* or *"-"* followed by six decimal digits.
              </td>
            </tr>
            <tr>
              <td>
                `-`
              </td>
              <td>
                *"-"* (hyphen) appears literally twice in the string.
              </td>
            </tr>
            <tr>
              <td>
                `MM`
              </td>
              <td>
                is the month of the year as two decimal digits from 01 (January) to 12 (December).
              </td>
            </tr>
            <tr>
              <td>
                `DD`
              </td>
              <td>
                is the day of the month as two decimal digits from 01 to 31.
              </td>
            </tr>
            <tr>
              <td>
                `T`
              </td>
              <td>
                *"T"* appears literally in the string, to indicate the beginning of the time element.
              </td>
            </tr>
            <tr>
              <td>
                `HH`
              </td>
              <td>
                is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.
              </td>
            </tr>
            <tr>
              <td>
                `:`
              </td>
              <td>
                *":"* (colon) appears literally twice in the string.
              </td>
            </tr>
            <tr>
              <td>
                `mm`
              </td>
              <td>
                is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.
              </td>
            </tr>
            <tr>
              <td>
                `ss`
              </td>
              <td>
                is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.
              </td>
            </tr>
            <tr>
              <td>
                `.`
              </td>
              <td>
                *"."* (dot) appears literally in the string.
              </td>
            </tr>
            <tr>
              <td>
                `sss`
              </td>
              <td>
                is the number of complete milliseconds since the start of the second as three decimal digits.
              </td>
            </tr>
            <tr>
              <td>
                `Z`
              </td>
              <td>
                is the UTC offset representation specified as *"Z"* (for UTC with no offset) or as either *"+"* or *"-"* followed by a time expression `HH:mm` (a subset of the <emu-xref href="#sec-time-zone-offset-strings">time zone offset string format</emu-xref> for indicating local time ahead of or behind UTC, respectively)
              </td>
            </tr>
          </table>
        </figure>
        <p>This format includes date-only forms:</p>
        <pre>
YYYY
YYYY-MM
YYYY-MM-DD
        </pre>
        <p>It also includes “date-time” forms that consist of one of the above date-only forms immediately followed by one of the following time forms with an optional UTC offset representation appended:</p>
        <pre>
THH:mm
THH:mm:ss
THH:mm:ss.sss
        </pre>
        <p>A string containing out-of-bounds or nonconforming elements is not a valid instance of this format.</p>
        <emu-note>
          <p>As every day both starts and ends with midnight, the two notations `00:00` and `24:00` are available to distinguish the two midnights that can be associated with one date. This means that the following two notations refer to exactly the same point in time: `1995-02-04T24:00` and `1995-02-05T00:00`. This interpretation of the latter form as "end of a calendar day" is consistent with ISO 8601, even though that specification reserves it for describing time intervals and does not permit it within representations of single points in time.</p>
        </emu-note>
        <emu-note>
          <p>There exists no international standard that specifies abbreviations for civil time zones like CET, EST, etc. and sometimes the same abbreviation is even used for two very different time zones. For this reason, both ISO 8601 and this format specify numeric representations of time zone offsets.</p>
        </emu-note>

        <emu-clause id="sec-expanded-years" oldids="sec-extended-years">
          <h1>Expanded Years</h1>
          <p>Covering the full time value range of approximately 273,790 years forward or backward from 1 January 1970 (<emu-xref href="#sec-time-values-and-time-range"></emu-xref>) requires representing years before 0 or after 9999. ISO 8601 permits expansion of the year representation, but only by mutual agreement of the partners in information interchange. In the simplified ECMAScript format, such an expanded year representation shall have 6 digits and is always prefixed with a + or - sign. The year 0 is considered positive and must be prefixed with a + sign. The representation of the year 0 as -000000 is invalid. Strings matching the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> with expanded years representing instants in time outside the range of a time value are treated as unrecognizable by <emu-xref href="#sec-date.parse">`Date.parse`</emu-xref> and cause that function to return *NaN* without falling back to implementation-specific behaviour or heuristics.</p>
          <emu-note>
            <p>Examples of date-<emu-not-ref>time values</emu-not-ref> with expanded years:</p>
            <figure>
              <table class="lightweight-table">
                <tr>
                  <td>-271821-04-20T00:00:00Z</td>
                  <td>271822 B.C.</td>
                </tr>
                <tr>
                  <td>-000001-01-01T00:00:00Z</td>
                  <td>2 B.C.</td>
                </tr>
                <tr>
                  <td>+000000-01-01T00:00:00Z</td>
                  <td>1 B.C.</td>
                </tr>
                <tr>
                  <td>+000001-01-01T00:00:00Z</td>
                  <td>1 A.D.</td>
                </tr>
                <tr>
                  <td>+001970-01-01T00:00:00Z</td>
                  <td>1970 A.D.</td>
                </tr>
                <tr>
                  <td>+002009-12-15T00:00:00Z</td>
                  <td>2009 A.D.</td>
                </tr>
                <tr>
                  <td>+275760-09-13T00:00:00Z</td>
                  <td>275760 A.D.</td>
                </tr>
              </table>
            </figure>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-time-zone-offset-strings">
        <h1>Time Zone Offset String Format</h1>

        <p>
          ECMAScript defines a string interchange format for UTC offsets, derived from ISO 8601.
          The format is described by the following grammar.
        </p>

        <h2>Syntax</h2>
        <emu-grammar type="definition">
          UTCOffset :::
            ASCIISign Hour
            ASCIISign Hour HourSubcomponents[+Extended]
            ASCIISign Hour HourSubcomponents[~Extended]

          ASCIISign ::: one of
            `+` `-`

          Hour :::
            `0` DecimalDigit
            `1` DecimalDigit
            `20`
            `21`
            `22`
            `23`

          HourSubcomponents[Extended] :::
            TimeSeparator[?Extended] MinuteSecond
            TimeSeparator[?Extended] MinuteSecond TimeSeparator[?Extended] MinuteSecond TemporalDecimalFraction?

          TimeSeparator[Extended] :::
            [+Extended] `:`
            [~Extended] [empty]

          MinuteSecond :::
            `0` DecimalDigit
            `1` DecimalDigit
            `2` DecimalDigit
            `3` DecimalDigit
            `4` DecimalDigit
            `5` DecimalDigit

          TemporalDecimalFraction :::
            TemporalDecimalSeparator DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit
            TemporalDecimalSeparator DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit DecimalDigit

          TemporalDecimalSeparator ::: one of
            `.` `,`
        </emu-grammar>

        <emu-clause id="sec-istimezoneoffsetstring" type="abstract operation">
          <h1>
            IsTimeZoneOffsetString (
              _offsetString_: a String,
            ): a Boolean
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>The return value indicates whether _offsetString_ conforms to the grammar given by |UTCOffset|.</dd>
          </dl>
          <emu-alg>
            1. Let _parseResult_ be ParseText(_offsetString_, |UTCOffset|).
            1. If _parseResult_ is a List of errors, return *false*.
            1. Return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-parsetimezoneoffsetstring" type="abstract operation">
          <h1>
            ParseTimeZoneOffsetString (
              _offsetString_: a String,
            ): an integer
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>The return value is the UTC offset, as a number of nanoseconds, that corresponds to the String _offsetString_.</dd>
          </dl>
          <emu-alg>
            1. Let _parseResult_ be ParseText(_offsetString_, |UTCOffset|).
            1. Assert: _parseResult_ is not a List of errors.
            1. Assert: _parseResult_ contains a |ASCIISign| Parse Node.
            1. Let _parsedSign_ be the source text matched by the |ASCIISign| Parse Node contained within _parseResult_.
            1. If _parsedSign_ is the single code point U+002D (HYPHEN-MINUS), then
              1. Let _sign_ be -1.
            1. Else,
              1. Let _sign_ be 1.
            1. NOTE: Applications of StringToNumber below do not lose precision, since each of the parsed values is guaranteed to be a sufficiently short string of decimal digits.
            1. Assert: _parseResult_ contains an |Hour| Parse Node.
            1. Let _parsedHours_ be the source text matched by the |Hour| Parse Node contained within _parseResult_.
            1. Let _hours_ be ℝ(StringToNumber(CodePointsToString(_parsedHours_))).
            1. If _parseResult_ does not contain a |MinuteSecond| Parse Node, then
              1. Let _minutes_ be 0.
            1. Else,
              1. Let _parsedMinutes_ be the source text matched by the first |MinuteSecond| Parse Node contained within _parseResult_.
              1. Let _minutes_ be ℝ(StringToNumber(CodePointsToString(_parsedMinutes_))).
            1. If _parseResult_ does not contain two |MinuteSecond| Parse Nodes, then
              1. Let _seconds_ be 0.
            1. Else,
              1. Let _parsedSeconds_ be the source text matched by the second |MinuteSecond| Parse Node contained within _parseResult_.
              1. Let _seconds_ be ℝ(StringToNumber(CodePointsToString(_parsedSeconds_))).
            1. If _parseResult_ does not contain a |TemporalDecimalFraction| Parse Node, then
              1. Let _nanoseconds_ be 0.
            1. Else,
              1. Let _parsedFraction_ be the source text matched by the |TemporalDecimalFraction| Parse Node contained within _parseResult_.
              1. Let _fraction_ be the string-concatenation of CodePointsToString(_parsedFraction_) and *"000000000"*.
              1. Let _nanosecondsString_ be the substring of _fraction_ from 1 to 10.
              1. Let _nanoseconds_ be ℝ(StringToNumber(_nanosecondsString_)).
            1. Return _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-date-constructor" oldids="this-time-value,sec-thistimevalue,thistimevalue,this-Date-object">
      <h1>The Date Constructor</h1>
      <p>The Date constructor:</p>
      <ul>
        <li>is <dfn>%Date%</dfn>.</li>
        <li>is the initial value of the *"Date"* property of the global object.</li>
        <li>creates and initializes a new Date when called as a constructor.</li>
        <li>returns a String representing the current time (UTC) when called as a function rather than as a constructor.</li>
        <li>is a function whose behaviour differs based upon the number and types of its arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Date behaviour must include a `super` call to the Date constructor to create and initialize the subclass instance with a [[DateValue]] internal slot.</li>
      </ul>

      <emu-clause id="sec-date" oldids="sec-date-constructor-date,sec-date-value,sec-date-year-month-date-hours-minutes-seconds-ms">
        <h1>Date ( ..._values_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, then
            1. Let _now_ be the time value (UTC) identifying the current time.
            1. Return ToDateString(_now_).
          1. Let _numberOfArgs_ be the number of elements in _values_.
          1. If _numberOfArgs_ = 0, then
            1. Let _dv_ be the time value (UTC) identifying the current time.
          1. Else if _numberOfArgs_ = 1, then
            1. Let _value_ be _values_[0].
            1. If _value_ is an Object and _value_ has a [[DateValue]] internal slot, then
              1. Let _tv_ be _value_.[[DateValue]].
            1. Else,
              1. Let _v_ be ? ToPrimitive(_value_).
              1. If _v_ is a String, then
                1. Assert: The next step never returns an abrupt completion because _v_ is a String.
                1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href="#sec-date.parse"></emu-xref>).
              1. Else,
                1. Let _tv_ be ? ToNumber(_v_).
            1. Let _dv_ be TimeClip(_tv_).
          1. Else,
            1. Assert: _numberOfArgs_ ≥ 2.
            1. Let _y_ be ? ToNumber(_values_[0]).
            1. Let _m_ be ? ToNumber(_values_[1]).
            1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]); else let _dt_ be *1*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]); else let _h_ be *+0*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]); else let _min_ be *+0*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]); else let _s_ be *+0*<sub>𝔽</sub>.
            1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]); else let _milli_ be *+0*<sub>𝔽</sub>.
            1. Let _yr_ be MakeFullYear(_y_).
            1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).
            1. Let _dv_ be TimeClip(UTC(_finalDate_)).
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Date.prototype%"*, « [[DateValue]] »).
          1. Set _O_.[[DateValue]] to _dv_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-constructor">
      <h1>Properties of the Date Constructor</h1>
      <p>The Date constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"length"* property whose value is *7*<sub>𝔽</sub>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-date.now">
        <h1>Date.now ( )</h1>
        <p>This function returns the time value designating the UTC date and time of the occurrence of the call to it.</p>
      </emu-clause>

      <emu-clause id="sec-date.parse">
        <h1>Date.parse ( _string_ )</h1>
        <p>This function applies the ToString operator to its argument. If ToString results in an abrupt completion the Completion Record is immediately returned. Otherwise, this function interprets the resulting String as a date and time; it returns a Number, the UTC time value corresponding to the date and time. The String may be interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the String. The function first attempts to parse the String according to the format described in Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>), including expanded years. If the String does not conform to that format the function may fall back to any implementation-specific heuristics or implementation-specific date formats. Strings that are unrecognizable or contain out-of-bounds format element values shall cause this function to return *NaN*.</p>
        <p>If the String conforms to the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>, substitute values take the place of absent format elements. When the `MM` or `DD` elements are absent, *"01"* is used. When the `HH`, `mm`, or `ss` elements are absent, *"00"* is used. When the `sss` element is absent, *"000"* is used. When the UTC offset representation is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time.</p>
        <p>If `x` is any Date whose milliseconds amount is zero within a particular implementation of ECMAScript, then all of the following expressions should produce the same numeric value in that implementation, if all the properties referenced have their initial values:</p>
        <pre><code class="javascript">
          x.valueOf()
          Date.parse(x.toString())
          Date.parse(x.toUTCString())
          Date.parse(x.toISOString())
        </code></pre>
        <p>However, the expression</p>
        <pre><code class="javascript">
          Date.parse(x.toLocaleString())
        </code></pre>
        <p>is not required to produce the same Number value as the preceding three expressions and, in general, the value produced by this function is implementation-defined when given any String value that does not conform to the Date Time String Format (<emu-xref href="#sec-date-time-string-format"></emu-xref>) and that could not be produced in that implementation by the `toString` or `toUTCString` method.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype">
        <h1>Date.prototype</h1>
        <p>The initial value of `Date.prototype` is the Date prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-date.utc">
        <h1>Date.UTC ( _year_ [ , _month_ [ , _date_ [ , _hours_ [ , _minutes_ [ , _seconds_ [ , _ms_ ] ] ] ] ] ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is present, let _m_ be ? ToNumber(_month_); else let _m_ be *+0*<sub>𝔽</sub>.
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be *1*<sub>𝔽</sub>.
          1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be *+0*<sub>𝔽</sub>.
          1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be *+0*<sub>𝔽</sub>.
          1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be *+0*<sub>𝔽</sub>.
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be *+0*<sub>𝔽</sub>.
          1. Let _yr_ be MakeFullYear(_y_).
          1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))).
        </emu-alg>
        <p>The *"length"* property of this function is *7*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This function differs from the Date constructor in two ways: it returns a time value as a Number, rather than creating a Date, and it interprets the arguments in UTC rather than as local time.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-date-prototype-object">
      <h1>Properties of the Date Prototype Object</h1>
      <p>The <dfn>Date prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Date.prototype%</dfn>.</li>
        <li>is itself an ordinary object.</li>
        <li>is not a Date instance and does not have a [[DateValue]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <p>Unless explicitly defined otherwise, the methods of the Date prototype object defined below are not generic and the *this* value passed to them must be an object that has a [[DateValue]] internal slot that has been initialized to a time value.</p>

      <emu-clause id="sec-date.prototype.constructor">
        <h1>Date.prototype.constructor</h1>
        <p>The initial value of `Date.prototype.constructor` is %Date%.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getdate">
        <h1>Date.prototype.getDate ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return DateFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getday">
        <h1>Date.prototype.getDay ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return WeekDay(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getfullyear">
        <h1>Date.prototype.getFullYear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gethours">
        <h1>Date.prototype.getHours ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return HourFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmilliseconds">
        <h1>Date.prototype.getMilliseconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return msFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getminutes">
        <h1>Date.prototype.getMinutes ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MinFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getmonth">
        <h1>Date.prototype.getMonth ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MonthFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getseconds">
        <h1>Date.prototype.getSeconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return SecFromTime(LocalTime(_t_)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettime">
        <h1>Date.prototype.getTime ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Return _dateObject_.[[DateValue]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.gettimezoneoffset">
        <h1>Date.prototype.getTimezoneOffset ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return (_t_ - LocalTime(_t_)) / msPerMinute.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcdate">
        <h1>Date.prototype.getUTCDate ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return DateFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcday">
        <h1>Date.prototype.getUTCDay ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return WeekDay(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcfullyear">
        <h1>Date.prototype.getUTCFullYear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutchours">
        <h1>Date.prototype.getUTCHours ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return HourFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmilliseconds">
        <h1>Date.prototype.getUTCMilliseconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return msFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcminutes">
        <h1>Date.prototype.getUTCMinutes ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MinFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcmonth">
        <h1>Date.prototype.getUTCMonth ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return MonthFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.getutcseconds">
        <h1>Date.prototype.getUTCSeconds ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return SecFromTime(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setdate">
        <h1>Date.prototype.setDate ( _date_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setfullyear">
        <h1>Date.prototype.setFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _y_ be ? ToNumber(_year_).
          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise set _t_ to LocalTime(_t_).
          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _month_ is not present, this method behaves as if _month_ was present with the value `getMonth()`. If _date_ is not present, it behaves as if _date_ was present with the value `getDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.sethours">
        <h1>Date.prototype.setHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _h_ be ? ToNumber(_hour_).
          1. If _min_ is present, let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _min_ is not present, let _m_ be MinFromTime(_t_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *4*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _min_ is not present, this method behaves as if _min_ was present with the value `getMinutes()`. If _sec_ is not present, it behaves as if _sec_ was present with the value `getSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmilliseconds">
        <h1>Date.prototype.setMilliseconds ( _ms_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Set _ms_ to ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).
          1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setminutes">
        <h1>Date.prototype.setMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _sec_ is not present, this method behaves as if _sec_ was present with the value `getSeconds()`. If _ms_ is not present, this behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setmonth">
        <h1>Date.prototype.setMonth ( _month_ [ , _date_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_month_).
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_newDate_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _date_ is not present, this method behaves as if _date_ was present with the value `getDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setseconds">
        <h1>Date.prototype.setSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Set _t_ to LocalTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _ms_ is not present, this method behaves as if _ms_ was present with the value `getMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.settime">
        <h1>Date.prototype.setTime ( _time_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be ? ToNumber(_time_).
          1. Let _v_ be TimeClip(_t_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcdate">
        <h1>Date.prototype.setUTCDate ( _date_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcfullyear">
        <h1>Date.prototype.setUTCFullYear ( _year_ [ , _month_ [ , _date_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.
          1. Let _y_ be ? ToNumber(_year_).
          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise let _m_ be ? ToNumber(_month_).
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise let _dt_ be ? ToNumber(_date_).
          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _month_ is not present, this method behaves as if _month_ was present with the value `getUTCMonth()`. If _date_ is not present, it behaves as if _date_ was present with the value `getUTCDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutchours">
        <h1>Date.prototype.setUTCHours ( _hour_ [ , _min_ [ , _sec_ [ , _ms_ ] ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _h_ be ? ToNumber(_hour_).
          1. If _min_ is present, let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _min_ is not present, let _m_ be MinFromTime(_t_).
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *4*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _min_ is not present, this method behaves as if _min_ was present with the value `getUTCMinutes()`. If _sec_ is not present, it behaves as if _sec_ was present with the value `getUTCSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmilliseconds">
        <h1>Date.prototype.setUTCMilliseconds ( _ms_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Set _ms_ to ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).
          1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcminutes">
        <h1>Date.prototype.setUTCMinutes ( _min_ [ , _sec_ [ , _ms_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_min_).
          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *3*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _sec_ is not present, this method behaves as if _sec_ was present with the value `getUTCSeconds()`. If _ms_ is not present, it behaves as if _ms_ was present with the value return by `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcmonth">
        <h1>Date.prototype.setUTCMonth ( _month_ [ , _date_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _m_ be ? ToNumber(_month_).
          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).
          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).
          1. Let _v_ be TimeClip(_newDate_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _date_ is not present, this method behaves as if _date_ was present with the value `getUTCDate()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.setutcseconds">
        <h1>Date.prototype.setUTCSeconds ( _sec_ [ , _ms_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _s_ be ? ToNumber(_sec_).
          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).
          1. If _t_ is *NaN*, return *NaN*.
          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).
          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).
          1. Let _v_ be TimeClip(_date_).
          1. Set _dateObject_.[[DateValue]] to _v_.
          1. Return _v_.
        </emu-alg>
        <p>The *"length"* property of this method is *2*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>If _ms_ is not present, this method behaves as if _ms_ was present with the value `getUTCMilliseconds()`.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.todatestring">
        <h1>Date.prototype.toDateString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, return *"Invalid Date"*.
          1. Let _t_ be LocalTime(_tv_).
          1. Return DateString(_t_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toisostring">
        <h1>Date.prototype.toISOString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, throw a *RangeError* exception.
          1. Assert: _tv_ is an integral Number.
          1. If _tv_ corresponds with a year that cannot be represented in the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref>, throw a *RangeError* exception.
          1. Return a String representation of _tv_ in the <emu-xref href="#sec-date-time-string-format">Date Time String Format</emu-xref> on the UTC time scale, including all format elements and the UTC offset representation *"Z"*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tojson">
        <h1>Date.prototype.toJSON ( _key_ )</h1>
        <p>This method provides a String representation of a Date for use by `JSON.stringify` (<emu-xref href="#sec-json.stringify"></emu-xref>).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _tv_ be ? ToPrimitive(_O_, ~number~).
          1. If _tv_ is a Number and _tv_ is not finite, return *null*.
          1. Return ? Invoke(_O_, *"toISOString"*).
        </emu-alg>
        <emu-note>
          <p>The argument is ignored.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a Date. Therefore, it can be transferred to other kinds of objects for use as a method. However, it does require that any such object have a `toISOString` method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaledatestring">
        <h1>Date.prototype.toLocaleDateString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a String value. The contents of the String are implementation-defined, but are intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocalestring">
        <h1>Date.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a String value. The contents of the String are implementation-defined, but are intended to represent the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tolocaletimestring">
        <h1>Date.prototype.toLocaleTimeString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a String value. The contents of the String are implementation-defined, but are intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable form that corresponds to the conventions of the host environment's current locale.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. Return ToDateString(_tv_).
        </emu-alg>
        <emu-note>
          <p>For any Date `d` such that `d.[[DateValue]]` is evenly divisible by 1000, the result of `Date.parse(d.toString())` = `d.valueOf()`. See <emu-xref href="#sec-date.parse"></emu-xref>.</p>
        </emu-note>
        <emu-note>
          <p>This method is not generic; it throws a *TypeError* exception if its *this* value is not a Date. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-timestring" type="abstract operation">
          <h1>
            TimeString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _hour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2).
            1. Let _minute_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2).
            1. Let _second_ be ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2).
            1. Return the string-concatenation of _hour_, *":"*, _minute_, *":"*, _second_, the code unit 0x0020 (SPACE), and *"GMT"*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-datestring" type="abstract operation">
          <h1>
            DateString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _weekday_ be the Name of the entry in <emu-xref href="#sec-todatestring-day-names"></emu-xref> with the Number WeekDay(_tv_).
            1. Let _month_ be the Name of the entry in <emu-xref href="#sec-todatestring-month-names"></emu-xref> with the Number MonthFromTime(_tv_).
            1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).
            1. Let _yv_ be YearFromTime(_tv_).
            1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise let _yearSign_ be *"-"*.
            1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).
            1. Return the string-concatenation of _weekday_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _yearSign_, and _paddedYear_.
          </emu-alg>
          <emu-table id="sec-todatestring-day-names" caption="Names of days of the week">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sun"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mon"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Tue"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Wed"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"Thu"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Fri"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sat"*
                </td>
              </tr>
            </table>
          </emu-table>
          <emu-table id="sec-todatestring-month-names" caption="Names of months of the year">
            <table>
              <thead>
                <tr>
                  <th>
                    Number
                  </th>
                  <th>
                    Name
                  </th>
                </tr>
              </thead>
              <tr>
                <td>
                  *+0*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jan"*
                </td>
              </tr>
              <tr>
                <td>
                  *1*<sub>𝔽</sub>
                </td>
                <td>
                  *"Feb"*
                </td>
              </tr>
              <tr>
                <td>
                  *2*<sub>𝔽</sub>
                </td>
                <td>
                  *"Mar"*
                </td>
              </tr>
              <tr>
                <td>
                  *3*<sub>𝔽</sub>
                </td>
                <td>
                  *"Apr"*
                </td>
              </tr>
              <tr>
                <td>
                  *4*<sub>𝔽</sub>
                </td>
                <td>
                  *"May"*
                </td>
              </tr>
              <tr>
                <td>
                  *5*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jun"*
                </td>
              </tr>
              <tr>
                <td>
                  *6*<sub>𝔽</sub>
                </td>
                <td>
                  *"Jul"*
                </td>
              </tr>
              <tr>
                <td>
                  *7*<sub>𝔽</sub>
                </td>
                <td>
                  *"Aug"*
                </td>
              </tr>
              <tr>
                <td>
                  *8*<sub>𝔽</sub>
                </td>
                <td>
                  *"Sep"*
                </td>
              </tr>
              <tr>
                <td>
                  *9*<sub>𝔽</sub>
                </td>
                <td>
                  *"Oct"*
                </td>
              </tr>
              <tr>
                <td>
                  *10*<sub>𝔽</sub>
                </td>
                <td>
                  *"Nov"*
                </td>
              </tr>
              <tr>
                <td>
                  *11*<sub>𝔽</sub>
                </td>
                <td>
                  *"Dec"*
                </td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>

        <emu-clause id="sec-timezoneestring" type="abstract operation">
          <h1>
            TimeZoneString (
              _tv_: an integral Number,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().
            1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then
              1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).
            1. Else,
              1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>)).
            1. Let _offset_ be 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>)).
            1. If _offset_ is *+0*<sub>𝔽</sub> or _offset_ > *+0*<sub>𝔽</sub>, then
              1. Let _offsetSign_ be *"+"*.
              1. Let _absOffset_ be _offset_.
            1. Else,
              1. Let _offsetSign_ be *"-"*.
              1. Let _absOffset_ be -_offset_.
            1. Let _offsetMin_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2).
            1. Let _offsetHour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2).
            1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-todatestring" type="abstract operation">
          <h1>
            ToDateString (
              _tv_: an integral Number or *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _tv_ is *NaN*, return *"Invalid Date"*.
            1. Let _t_ be LocalTime(_tv_).
            1. Return the string-concatenation of DateString(_t_), the code unit 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-date.prototype.totimestring">
        <h1>Date.prototype.toTimeString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, return *"Invalid Date"*.
          1. Let _t_ be LocalTime(_tv_).
          1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.toutcstring">
        <h1>Date.prototype.toUTCString ( )</h1>
        <p>This method returns a String value representing the instant in time corresponding to the *this* value. The format of the String is based upon "HTTP-date" from RFC 7231, generalized to support the full range of times supported by ECMAScript Dates.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _tv_ be _dateObject_.[[DateValue]].
          1. If _tv_ is *NaN*, return *"Invalid Date"*.
          1. Let _weekday_ be the Name of the entry in <emu-xref href="#sec-todatestring-day-names"></emu-xref> with the Number WeekDay(_tv_).
          1. Let _month_ be the Name of the entry in <emu-xref href="#sec-todatestring-month-names"></emu-xref> with the Number MonthFromTime(_tv_).
          1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).
          1. Let _yv_ be YearFromTime(_tv_).
          1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise let _yearSign_ be *"-"*.
          1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).
          1. Return the string-concatenation of _weekday_, *","*, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _yearSign_, _paddedYear_, the code unit 0x0020 (SPACE), and TimeString(_tv_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-date.prototype.valueof">
        <h1>Date.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Return _dateObject_.[[DateValue]].
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-date.prototype-@@toprimitive" id="sec-date.prototype-%symbol.toprimitive%">
        <h1>Date.prototype [ %Symbol.toPrimitive% ] ( _hint_ )</h1>
        <p>This method is called by ECMAScript language operators to convert a Date to a primitive value. The allowed values for _hint_ are *"default"*, *"number"*, and *"string"*. Dates are unique among built-in ECMAScript object in that they treat *"default"* as being equivalent to *"string"*, All other built-in ECMAScript objects treat *"default"* as being equivalent to *"number"*.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. If _hint_ is either *"string"* or *"default"*, then
            1. Let _tryFirst_ be ~string~.
          1. Else if _hint_ is *"number"*, then
            1. Let _tryFirst_ be ~number~.
          1. Else,
            1. Throw a *TypeError* exception.
          1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_).
        </emu-alg>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The value of the *"name"* property of this method is *"[Symbol.toPrimitive]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-date-instances">
      <h1>Properties of Date Instances</h1>
      <p>Date instances are ordinary objects that inherit properties from the Date prototype object. Date instances also have a [[DateValue]] internal slot. The [[DateValue]] internal slot is the time value represented by this Date.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-text-processing">
  <h1>Text Processing</h1>

  <emu-clause id="sec-string-objects">
    <h1>String Objects</h1>

    <emu-clause id="sec-string-constructor">
      <h1>The String Constructor</h1>
      <p>The String constructor:</p>
      <ul>
        <li>is <dfn>%String%</dfn>.</li>
        <li>is the initial value of the *"String"* property of the global object.</li>
        <li>creates and initializes a new String object when called as a constructor.</li>
        <li>performs a type conversion when called as a function rather than as a constructor.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified String behaviour must include a `super` call to the String constructor to create and initialize the subclass instance with a [[StringData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-string-constructor-string-value">
        <h1>String ( _value_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _value_ is not present, then
            1. Let _s_ be the empty String.
          1. Else,
            1. If NewTarget is *undefined* and _value_ is a Symbol, return SymbolDescriptiveString(_value_).
            1. Let _s_ be ? ToString(_value_).
          1. If NewTarget is *undefined*, return _s_.
          1. Return StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *"%String.prototype%"*)).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-constructor">
      <h1>Properties of the String Constructor</h1>
      <p>The String constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-string.fromcharcode">
        <h1>String.fromCharCode ( ..._codeUnits_ )</h1>
        <p>This function may be called with any number of arguments which form the rest parameter _codeUnits_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _result_ be the empty String.
          1. For each element _next_ of _codeUnits_, do
            1. Let _nextCU_ be the code unit whose numeric value is ℝ(? ToUint16(_next_)).
            1. Set _result_ to the string-concatenation of _result_ and _nextCU_.
          1. Return _result_.
        </emu-alg>
        <p>The *"length"* property of this function is *1*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-string.fromcodepoint">
        <h1>String.fromCodePoint ( ..._codePoints_ )</h1>
        <p>This function may be called with any number of arguments which form the rest parameter _codePoints_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _result_ be the empty String.
          1. For each element _next_ of _codePoints_, do
            1. Let _nextCP_ be ? ToNumber(_next_).
            1. If _nextCP_ is not an integral Number, throw a *RangeError* exception.
            1. If ℝ(_nextCP_) &lt; 0 or ℝ(_nextCP_) > 0x10FFFF, throw a *RangeError* exception.
            1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(ℝ(_nextCP_)).
          1. Assert: If _codePoints_ is empty, then _result_ is the empty String.
          1. Return _result_.
        </emu-alg>
        <p>The *"length"* property of this function is *1*<sub>𝔽</sub>.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype">
        <h1>String.prototype</h1>
        <p>The initial value of `String.prototype` is the String prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-string.raw">
        <h1>String.raw ( _template_, ..._substitutions_ )</h1>
        <p>This function may be called with a variable number of arguments. The first argument is _template_ and the remainder of the arguments form the List _substitutions_.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _substitutionCount_ be the number of elements in _substitutions_.
          1. Let _cooked_ be ? ToObject(_template_).
          1. Let _literals_ be ? ToObject(? Get(_cooked_, *"raw"*)).
          1. Let _literalCount_ be ? LengthOfArrayLike(_literals_).
          1. If _literalCount_ ≤ 0, return the empty String.
          1. Let _R_ be the empty String.
          1. Let _nextIndex_ be 0.
          1. Repeat,
            1. Let _nextLiteralVal_ be ? Get(_literals_, ! ToString(𝔽(_nextIndex_))).
            1. Let _nextLiteral_ be ? ToString(_nextLiteralVal_).
            1. Set _R_ to the string-concatenation of _R_ and _nextLiteral_.
            1. If _nextIndex_ + 1 = _literalCount_, return _R_.
            1. If _nextIndex_ &lt; _substitutionCount_, then
              1. Let _nextSubVal_ be _substitutions_[_nextIndex_].
              1. Let _nextSub_ be ? ToString(_nextSubVal_).
              1. Set _R_ to the string-concatenation of _R_ and _nextSub_.
            1. Set _nextIndex_ to _nextIndex_ + 1.
        </emu-alg>
        <emu-note>
          <p>This function is intended for use as a tag function of a Tagged Template (<emu-xref href="#sec-tagged-templates"></emu-xref>). When called as such, the first argument will be a well formed template object and the rest parameter will contain the substitution values.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-string-prototype-object">
      <h1>Properties of the String Prototype Object</h1>
      <p>The <dfn>String prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%String.prototype%</dfn>.</li>
        <li>is a String exotic object and has the internal methods specified for such objects.</li>
        <li>has a [[StringData]] internal slot whose value is the empty String.</li>
        <li>has a *"length"* property whose initial value is *+0*<sub>𝔽</sub> and whose attributes are { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <p>Unless explicitly stated otherwise, the methods of the String prototype object defined below are not generic and the *this* value passed to them must be either a String value or an object that has a [[StringData]] internal slot that has been initialized to a String value.</p>

      <emu-clause id="sec-string.prototype.at">
        <h1>String.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ ≥ _len_, return *undefined*.
          1. Return the substring of _S_ from _k_ to _k_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charat">
        <h1>String.prototype.charAt ( _pos_ )</h1>
        <emu-note>
          <p>This method returns a single element String containing the code unit at index _pos_ within the String value resulting from converting this object to a String. If there is no element at that index, the result is the empty String. The result is a String value, not a String object.</p>
          <p>If `pos` is an integral Number, then the result of `x.charAt(pos)` is equivalent to the result of `x.substring(pos, pos + 1)`.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ ≥ _size_, return the empty String.
          1. Return the substring of _S_ from _position_ to _position_ + 1.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.charcodeat">
        <h1>String.prototype.charCodeAt ( _pos_ )</h1>
        <emu-note>
          <p>This method returns a Number (a non-negative integral Number less than 2<sup>16</sup>) that is the numeric value of the code unit at index _pos_ within the String resulting from converting this object to a String. If there is no element at that index, the result is *NaN*.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ ≥ _size_, return *NaN*.
          1. Return the Number value for the numeric value of the code unit at index _position_ within the String _S_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.codepointat">
        <h1>String.prototype.codePointAt ( _pos_ )</h1>
        <emu-note>
          <p>This method returns a non-negative integral Number less than or equal to *0x10FFFF*<sub>𝔽</sub> that is the numeric value of the UTF-16 encoded code point (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>) starting at the string element at index _pos_ within the String resulting from converting this object to a String. If there is no element at that index, the result is *undefined*. If a valid UTF-16 surrogate pair does not begin at _pos_, the result is the code unit at _pos_.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).
          1. Let _size_ be the length of _S_.
          1. If _position_ &lt; 0 or _position_ ≥ _size_, return *undefined*.
          1. Let _cp_ be CodePointAt(_S_, _position_).
          1. Return 𝔽(_cp_.[[CodePoint]]).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.concat">
        <h1>String.prototype.concat ( ..._args_ )</h1>
        <emu-note>
          <p>When this method is called it returns the String value consisting of the code units of the *this* value (converted to a String) followed by the code units of each of the arguments converted to a String. The result is a String value, not a String object.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _R_ be _S_.
          1. For each element _next_ of _args_, do
            1. Let _nextString_ be ? ToString(_next_).
            1. Set _R_ to the string-concatenation of _R_ and _nextString_.
          1. Return _R_.
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.constructor">
        <h1>String.prototype.constructor</h1>
        <p>The initial value of `String.prototype.constructor` is %String%.</p>
      </emu-clause>

      <emu-clause id="sec-string.prototype.endswith">
        <h1>String.prototype.endsWith ( _searchString_ [ , _endPosition_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _len_ be the length of _S_.
          1. If _endPosition_ is *undefined*, let _pos_ be _len_; else let _pos_ be ? ToIntegerOrInfinity(_endPosition_).
          1. Let _end_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _searchLength_ be the length of _searchStr_.
          1. If _searchLength_ = 0, return *true*.
          1. Let _start_ be _end_ - _searchLength_.
          1. If _start_ &lt; 0, return *false*.
          1. Let _substring_ be the substring of _S_ from _start_ to _end_.
          1. If _substring_ is _searchStr_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method returns *true* if the sequence of code units of _searchString_ converted to a String is the same as the corresponding code units of this object (converted to a String) starting at _endPosition_ - length(this). Otherwise it returns *false*.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.includes">
        <h1>String.prototype.includes ( _searchString_ [ , _position_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _index_ be StringIndexOf(_S_, _searchStr_, _start_).
          1. If _index_ is ~not-found~, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>If _searchString_ appears as a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, at one or more indices that are greater than or equal to _position_, this function returns *true*; otherwise, it returns *false*. If _position_ is *undefined*, 0 is assumed, so as to search all of the String.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.indexof">
        <h1>String.prototype.indexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>If _searchString_ appears as a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, at one or more indices that are greater than or equal to _position_, then the smallest such index is returned; otherwise, *-1*<sub>𝔽</sub> is returned. If _position_ is *undefined*, *+0*<sub>𝔽</sub> is assumed, so as to search all of the String.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).
          1. Assert: If _position_ is *undefined*, then _pos_ is 0.
          1. Let _len_ be the length of _S_.
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _result_ be StringIndexOf(_S_, _searchStr_, _start_).
          1. If _result_ is ~not-found~, return *-1*<sub>𝔽</sub>.
          1. Return 𝔽(_result_).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.iswellformed">
        <h1>String.prototype.isWellFormed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Return IsStringWellFormedUnicode(_S_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.lastindexof">
        <h1>String.prototype.lastIndexOf ( _searchString_ [ , _position_ ] )</h1>
        <emu-note>
          <p>If _searchString_ appears as a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String at one or more indices that are smaller than or equal to _position_, then the greatest such index is returned; otherwise, *-1*<sub>𝔽</sub> is returned. If _position_ is *undefined*, the length of the String value is assumed, so as to search all of the String.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _numPos_ be ? ToNumber(_position_).
          1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.
          1. If _numPos_ is *NaN*, let _pos_ be +∞; otherwise let _pos_ be ! ToIntegerOrInfinity(_numPos_).
          1. Let _len_ be the length of _S_.
          1. Let _searchLen_ be the length of _searchStr_.
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_ - _searchLen_.
          1. Let _result_ be StringLastIndexOf(_S_, _searchStr_, _start_).
          1. If _result_ is ~not-found~, return *-1*<sub>𝔽</sub>.
          1. Return 𝔽(_result_).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.localecompare">
        <h1>String.prototype.localeCompare ( _that_ [ , _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method returns a Number other than *NaN* representing the result of an implementation-defined locale-sensitive String comparison of the *this* value (converted to a String _S_) with _that_ (converted to a String _thatValue_). The result is intended to correspond with a sort order of String values according to conventions of the host environment's current locale, and will be negative when _S_ is ordered before _thatValue_, positive when _S_ is ordered after _thatValue_, and zero in all other cases (representing no relative ordering between _S_ and _thatValue_).</p>
        <p>Before performing the comparisons, this method performs the following steps to prepare the Strings:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _thatValue_ be ? ToString(_that_).
        </emu-alg>
        <p>The meaning of the optional second and third parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not assign any other interpretation to those parameter positions.</p>
        <p>The actual return values are implementation-defined to permit encoding additional information in them, but this method, when considered as a method of two arguments, is required to be a consistent comparator defining a total ordering on the set of all Strings. This method is also required to recognize and honour canonical equivalence according to the Unicode Standard, including returning *+0*<sub>𝔽</sub> when comparing distinguishable Strings that are canonically equivalent.</p>
        <emu-note>
          <p>This method itself is not directly suitable as an argument to `Array.prototype.sort` because the latter requires a function of two arguments.</p>
        </emu-note>
        <emu-note>
          <p>This method may rely on whatever language- and/or locale-sensitive comparison functionality is available to the ECMAScript environment from the host environment, and is intended to compare according to the conventions of the host environment's current locale. However, regardless of comparison capabilities, this method must recognize and honour canonical equivalence according to the Unicode Standard—for example, the following comparisons must all return *+0*<sub>𝔽</sub>:</p>
          <pre><code class="javascript">
            // &#x212B; ANGSTROM SIGN vs.
            // A&#x030A; LATIN CAPITAL LETTER A + COMBINING RING ABOVE
            "\u212B".localeCompare("A\u030A")

            // &#x2126; OHM SIGN vs.
            // &#x03A9; GREEK CAPITAL LETTER OMEGA
            "\u2126".localeCompare("\u03A9")

            // &#x1E69; LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE vs.
            // s&#x0307;&#x0323; LATIN SMALL LETTER S + COMBINING DOT ABOVE + COMBINING DOT BELOW
            "\u1E69".localeCompare("s\u0307\u0323")

            // &#x1E0B;&#x0323; LATIN SMALL LETTER D WITH DOT ABOVE + COMBINING DOT BELOW vs.
            // &#x1E0D;&#x0307; LATIN SMALL LETTER D WITH DOT BELOW + COMBINING DOT ABOVE
            "\u1E0B\u0323".localeCompare("\u1E0D\u0307")

            // &#x1100;&#x1161; HANGUL CHOSEONG KIYEOK + HANGUL JUNGSEONG A vs.
            // &#xAC00; HANGUL SYLLABLE GA
            "\u1100\u1161".localeCompare("\uAC00")
          </code></pre>
          <p>For a definition and discussion of canonical equivalence see the Unicode Standard, chapters 2 and 3, as well as <a href="https://unicode.org/reports/tr15/">Unicode Standard Annex #15, Unicode Normalization Forms</a> and <a href="https://unicode.org/notes/tn5/">Unicode Technical Note #5, Canonical Equivalence in Applications</a>. Also see <a href="https://unicode.org/reports/tr10/">Unicode Technical Standard #10, Unicode Collation Algorithm</a>.</p>
          <p>It is recommended that this method should not honour Unicode compatibility equivalents or compatibility decompositions as defined in the Unicode Standard, chapter 3, section 3.7.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.match">
        <h1>String.prototype.match ( _regexp_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _matcher_ be ? GetMethod(_regexp_, %Symbol.match%).
            1. If _matcher_ is not *undefined*, then
              1. Return ? Call(_matcher_, _regexp_, « _O_ »).
          1. Let _S_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).
          1. Return ? Invoke(_rx_, %Symbol.match%, « _S_ »).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.matchall">
        <h1>String.prototype.matchAll ( _regexp_ )</h1>
        <p>This method performs a regular expression match of the String representing the *this* value against _regexp_ and returns an iterator that yields match results. Each match result is an Array containing the matched portion of the String as the first element, followed by the portions matched by any capturing groups. If the regular expression never matches, the returned iterator does not yield any match results.</p>
        <p>It performs the following steps when called:</p>

        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _isRegExp_ be ? IsRegExp(_regexp_).
            1. If _isRegExp_ is *true*, then
              1. Let _flags_ be ? Get(_regexp_, *"flags"*).
              1. Perform ? RequireObjectCoercible(_flags_).
              1. If ? ToString(_flags_) does not contain *"g"*, throw a *TypeError* exception.
            1. Let _matcher_ be ? GetMethod(_regexp_, %Symbol.matchAll%).
            1. If _matcher_ is not *undefined*, then
              1. Return ? Call(_matcher_, _regexp_, « _O_ »).
          1. Let _S_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *"g"*).
          1. Return ? Invoke(_rx_, %Symbol.matchAll%, « _S_ »).
        </emu-alg>
        <emu-note>This method is intentionally generic, it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</emu-note>
        <emu-note>Similarly to `String.prototype.split`, `String.prototype.matchAll` is designed to typically act without mutating its inputs.</emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.normalize">
        <h1>String.prototype.normalize ( [ _form_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. If _form_ is *undefined*, let _f_ be *"NFC"*.
          1. Else, let _f_ be ? ToString(_form_).
          1. If _f_ is not one of *"NFC"*, *"NFD"*, *"NFKC"*, or *"NFKD"*, throw a *RangeError* exception.
          1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href="https://www.unicode.org/versions/latest/ch03.pdf">the latest Unicode Standard, Normalization Forms</a>.
          1. Return _ns_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padend">
        <h1>String.prototype.padEnd ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.padstart">
        <h1>String.prototype.padStart ( _maxLength_ [ , _fillString_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~).
        </emu-alg>

        <emu-clause id="sec-stringpaddingbuiltinsimpl" type="abstract operation">
          <h1>
            StringPaddingBuiltinsImpl (
              _O_: an ECMAScript language value,
              _maxLength_: an ECMAScript language value,
              _fillString_: an ECMAScript language value,
              _placement_: ~start~ or ~end~,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _S_ be ? ToString(_O_).
            1. Let _intMaxLength_ be ℝ(? ToLength(_maxLength_)).
            1. Let _stringLength_ be the length of _S_.
            1. If _intMaxLength_ ≤ _stringLength_, return _S_.
            1. If _fillString_ is *undefined*, set _fillString_ to the String value consisting solely of the code unit 0x0020 (SPACE).
            1. Else, set _fillString_ to ? ToString(_fillString_).
            1. Return StringPad(_S_, _intMaxLength_, _fillString_, _placement_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-stringpad" type="abstract operation">
          <h1>
            StringPad (
              _S_: a String,
              _maxLength_: a non-negative integer,
              _fillString_: a String,
              _placement_: ~start~ or ~end~,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _stringLength_ be the length of _S_.
            1. If _maxLength_ ≤ _stringLength_, return _S_.
            1. If _fillString_ is the empty String, return _S_.
            1. Let _fillLen_ be _maxLength_ - _stringLength_.
            1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.
            1. If _placement_ is ~start~, return the string-concatenation of _truncatedStringFiller_ and _S_.
            1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_.
          </emu-alg>
          <emu-note>
            <p>The argument _maxLength_ will be clamped such that it can be no smaller than the length of _S_.</p>
          </emu-note>
          <emu-note>
            <p>The argument _fillString_ defaults to *" "* (the String value consisting of the code unit 0x0020 SPACE).</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-tozeropaddeddecimalstring" type="abstract operation">
          <h1>
            ToZeroPaddedDecimalString (
              _n_: a non-negative integer,
              _minLength_: a non-negative integer,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _S_ be the String representation of _n_, formatted as a decimal number.
            1. Return StringPad(_S_, _minLength_, *"0"*, ~start~).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.repeat">
        <h1>String.prototype.repeat ( _count_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _n_ be ? ToIntegerOrInfinity(_count_).
          1. If _n_ &lt; 0 or _n_ = +∞, throw a *RangeError* exception.
          1. If _n_ = 0, return the empty String.
          1. Return the String value that is made from _n_ copies of _S_ appended together.
        </emu-alg>
        <emu-note>
          <p>This method creates the String value consisting of the code units of the *this* value (converted to String) repeated _count_ times.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replace">
        <h1>String.prototype.replace ( _searchValue_, _replaceValue_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _searchValue_ is neither *undefined* nor *null*, then
            1. Let _replacer_ be ? GetMethod(_searchValue_, %Symbol.replace%).
            1. If _replacer_ is not *undefined*, then
              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).
          1. Let _string_ be ? ToString(_O_).
          1. Let _searchString_ be ? ToString(_searchValue_).
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _searchLength_ be the length of _searchString_.
          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).
          1. If _position_ is ~not-found~, return _string_.
          1. Let _preceding_ be the substring of _string_ from 0 to _position_.
          1. Let _following_ be the substring of _string_ from _position_ + _searchLength_.
          1. If _functionalReplace_ is *true*, then
            1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »)).
          1. Else,
            1. Assert: _replaceValue_ is a String.
            1. Let _captures_ be a new empty List.
            1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_).
          1. Return the string-concatenation of _preceding_, _replacement_, and _following_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-getsubstitution" type="abstract operation" oldids="table-replacement-text-symbol-substitutions,table-45">
          <h1>
            GetSubstitution (
              _matched_: a String,
              _str_: a String,
              _position_: a non-negative integer,
              _captures_: a List of either Strings or *undefined*,
              _namedCaptures_: an Object or *undefined*,
              _replacementTemplate_: a String,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>For the purposes of this abstract operation, a <em>decimal digit</em> is a code unit in the inclusive interval from 0x0030 (DIGIT ZERO) to 0x0039 (DIGIT NINE).</dd>
          </dl>
          <emu-alg>
            1. Let _stringLength_ be the length of _str_.
            1. Assert: _position_ ≤ _stringLength_.
            1. Let _result_ be the empty String.
            1. Let _templateRemainder_ be _replacementTemplate_.
            1. Repeat, while _templateRemainder_ is not the empty String,
              1. [declared="ref,refReplacement"] NOTE: The following steps isolate _ref_ (a prefix of _templateRemainder_), determine _refReplacement_ (its replacement), and then append that replacement to _result_.
              1. If _templateRemainder_ starts with *"$$"*, then
                1. Let _ref_ be *"$$"*.
                1. Let _refReplacement_ be *"$"*.
              1. Else if _templateRemainder_ starts with *"$`"*, then
                1. Let _ref_ be *"$`"*.
                1. Let _refReplacement_ be the substring of _str_ from 0 to _position_.
              1. Else if _templateRemainder_ starts with *"$&amp;"*, then
                1. Let _ref_ be *"$&amp;"*.
                1. Let _refReplacement_ be _matched_.
              1. Else if _templateRemainder_ starts with *"$'"* (0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then
                1. Let _ref_ be *"$'"*.
                1. Let _matchLength_ be the length of _matched_.
                1. Let _tailPos_ be _position_ + _matchLength_.
                1. Let _refReplacement_ be the substring of _str_ from min(_tailPos_, _stringLength_).
                1. NOTE: _tailPos_ can exceed _stringLength_ only if this abstract operation was invoked by a call to the intrinsic %Symbol.replace% method of %RegExp.prototype% on an object whose *"exec"* property is not the intrinsic %RegExp.prototype.exec%.
              1. Else if _templateRemainder_ starts with *"$"* followed by 1 or more decimal digits, then
                1. If _templateRemainder_ starts with *"$"* followed by 2 or more decimal digits, let _digitCount_ be 2; otherwise let _digitCount_ be 1.
                1. Let _digits_ be the substring of _templateRemainder_ from 1 to 1 + _digitCount_.
                1. Let _index_ be ℝ(StringToNumber(_digits_)).
                1. Assert: 0 ≤ _index_ ≤ 99.
                1. Let _captureLen_ be the number of elements in _captures_.
                1. If _index_ > _captureLen_ and _digitCount_ = 2, then
                  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.
                  1. Set _digitCount_ to 1.
                  1. Set _digits_ to the substring of _digits_ from 0 to 1.
                  1. Set _index_ to ℝ(StringToNumber(_digits_)).
                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1 + _digitCount_.
                1. If 1 ≤ _index_ ≤ _captureLen_, then
                  1. Let _capture_ be _captures_[_index_ - 1].
                  1. If _capture_ is *undefined*, then
                    1. Let _refReplacement_ be the empty String.
                  1. Else,
                    1. Let _refReplacement_ be _capture_.
                1. Else,
                  1. Let _refReplacement_ be _ref_.
              1. Else if _templateRemainder_ starts with *"$&lt;"*, then
                1. Let _gtPos_ be StringIndexOf(_templateRemainder_, *">"*, 0).
                1. If _gtPos_ is ~not-found~ or _namedCaptures_ is *undefined*, then
                  1. Let _ref_ be *"$&lt;"*.
                  1. Let _refReplacement_ be _ref_.
                1. Else,
                  1. Let _ref_ be the substring of _templateRemainder_ from 0 to _gtPos_ + 1.
                  1. Let _groupName_ be the substring of _templateRemainder_ from 2 to _gtPos_.
                  1. Assert: _namedCaptures_ is an Object.
                  1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).
                  1. If _capture_ is *undefined*, then
                    1. Let _refReplacement_ be the empty String.
                  1. Else,
                    1. Let _refReplacement_ be ? ToString(_capture_).
              1. Else,
                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1.
                1. Let _refReplacement_ be _ref_.
              1. Let _refLength_ be the length of _ref_.
              1. Set _templateRemainder_ to the substring of _templateRemainder_ from _refLength_.
              1. Set _result_ to the string-concatenation of _result_ and _refReplacement_.
            1. Return _result_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.replaceall">
        <h1>String.prototype.replaceAll ( _searchValue_, _replaceValue_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _searchValue_ is neither *undefined* nor *null*, then
            1. Let _isRegExp_ be ? IsRegExp(_searchValue_).
            1. If _isRegExp_ is *true*, then
              1. Let _flags_ be ? Get(_searchValue_, *"flags"*).
              1. Perform ? RequireObjectCoercible(_flags_).
              1. If ? ToString(_flags_) does not contain *"g"*, throw a *TypeError* exception.
            1. Let _replacer_ be ? GetMethod(_searchValue_, %Symbol.replace%).
            1. If _replacer_ is not *undefined*, then
              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).
          1. Let _string_ be ? ToString(_O_).
          1. Let _searchString_ be ? ToString(_searchValue_).
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _searchLength_ be the length of _searchString_.
          1. Let _advanceBy_ be max(1, _searchLength_).
          1. Let _matchPositions_ be a new empty List.
          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).
          1. Repeat, while _position_ is not ~not-found~,
            1. Append _position_ to _matchPositions_.
            1. Set _position_ to StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_).
          1. Let _endOfLastMatch_ be 0.
          1. Let _result_ be the empty String.
          1. For each element _p_ of _matchPositions_, do
            1. Let _preserved_ be the substring of _string_ from _endOfLastMatch_ to _p_.
            1. If _functionalReplace_ is *true*, then
              1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »)).
            1. Else,
              1. Assert: _replaceValue_ is a String.
              1. Let _captures_ be a new empty List.
              1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_).
            1. Set _result_ to the string-concatenation of _result_, _preserved_, and _replacement_.
            1. Set _endOfLastMatch_ to _p_ + _searchLength_.
          1. If _endOfLastMatch_ &lt; the length of _string_, then
            1. Set _result_ to the string-concatenation of _result_ and the substring of _string_ from _endOfLastMatch_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.search">
        <h1>String.prototype.search ( _regexp_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _regexp_ is neither *undefined* nor *null*, then
            1. Let _searcher_ be ? GetMethod(_regexp_, %Symbol.search%).
            1. If _searcher_ is not *undefined*, then
              1. Return ? Call(_searcher_, _regexp_, « _O_ »).
          1. Let _string_ be ? ToString(_O_).
          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).
          1. Return ? Invoke(_rx_, %Symbol.search%, « _string_ »).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.slice">
        <h1>String.prototype.slice ( _start_, _end_ )</h1>
        <p>This method returns a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, starting from index _start_ and running to, but not including, index _end_ (or through the end of the String if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_sourceLength_ + _start_</emu-eqn> where _sourceLength_ is the length of the String. If _end_ is negative, it is treated as <emu-eqn>_sourceLength_ + _end_</emu-eqn> where _sourceLength_ is the length of the String. The result is a String value, not a String object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _intStart_ = -∞, let _from_ be 0.
          1. Else if _intStart_ &lt; 0, let _from_ be max(_len_ + _intStart_, 0).
          1. Else, let _from_ be min(_intStart_, _len_).
          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _intEnd_ = -∞, let _to_ be 0.
          1. Else if _intEnd_ &lt; 0, let _to_ be max(_len_ + _intEnd_, 0).
          1. Else, let _to_ be min(_intEnd_, _len_).
          1. If _from_ ≥ _to_, return the empty String.
          1. Return the substring of _S_ from _from_ to _to_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.split">
        <h1>String.prototype.split ( _separator_, _limit_ )</h1>
        <p>This method returns an Array into which substrings of the result of converting this object to a String have been stored. The substrings are determined by searching from left to right for occurrences of _separator_; these occurrences are not part of any String in the returned array, but serve to divide up the String value. The value of _separator_ may be a String of any length or it may be an object, such as a RegExp, that has a %Symbol.split% method.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. If _separator_ is neither *undefined* nor *null*, then
            1. Let _splitter_ be ? GetMethod(_separator_, %Symbol.split%).
            1. If _splitter_ is not *undefined*, then
              1. Return ? Call(_splitter_, _separator_, « _O_, _limit_ »).
          1. Let _S_ be ? ToString(_O_).
          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).
          1. Let _R_ be ? ToString(_separator_).
          1. If _lim_ = 0, then
            1. Return CreateArrayFromList(« »).
          1. If _separator_ is *undefined*, then
            1. Return CreateArrayFromList(« _S_ »).
          1. Let _separatorLength_ be the length of _R_.
          1. If _separatorLength_ = 0, then
            1. Let _strLen_ be the length of _S_.
            1. Let _outLen_ be the result of clamping _lim_ between 0 and _strLen_.
            1. Let _head_ be the substring of _S_ from 0 to _outLen_.
            1. Let _codeUnits_ be a List consisting of the sequence of code units that are the elements of _head_.
            1. Return CreateArrayFromList(_codeUnits_).
          1. If _S_ is the empty String, return CreateArrayFromList(« _S_ »).
          1. Let _substrings_ be a new empty List.
          1. Let _i_ be 0.
          1. Let _j_ be StringIndexOf(_S_, _R_, 0).
          1. Repeat, while _j_ is not ~not-found~,
            1. Let _T_ be the substring of _S_ from _i_ to _j_.
            1. Append _T_ to _substrings_.
            1. If the number of elements in _substrings_ is _lim_, return CreateArrayFromList(_substrings_).
            1. Set _i_ to _j_ + _separatorLength_.
            1. Set _j_ to StringIndexOf(_S_, _R_, _i_).
          1. Let _T_ be the substring of _S_ from _i_.
          1. Append _T_ to _substrings_.
          1. Return CreateArrayFromList(_substrings_).
        </emu-alg>
        <emu-note>
          <p>The value of _separator_ may be an empty String. In this case, _separator_ does not match the empty <emu-not-ref>substring</emu-not-ref> at the beginning or end of the input String, nor does it match the empty <emu-not-ref>substring</emu-not-ref> at the end of the previous separator match. If _separator_ is the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each <emu-not-ref>substring</emu-not-ref> contains one code unit.</p>
          <p>If the *this* value is (or converts to) the empty String, the result depends on whether _separator_ can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
          <p>If _separator_ is *undefined*, then the result array contains just one String, which is the *this* value (converted to a String). If _limit_ is not *undefined*, then the output array is truncated so that it contains no more than _limit_ elements.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.startswith">
        <h1>String.prototype.startsWith ( _searchString_ [ , _position_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _isRegExp_ be ? IsRegExp(_searchString_).
          1. If _isRegExp_ is *true*, throw a *TypeError* exception.
          1. Let _searchStr_ be ? ToString(_searchString_).
          1. Let _len_ be the length of _S_.
          1. If _position_ is *undefined*, let _pos_ be 0; else let _pos_ be ? ToIntegerOrInfinity(_position_).
          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.
          1. Let _searchLength_ be the length of _searchStr_.
          1. If _searchLength_ = 0, return *true*.
          1. Let _end_ be _start_ + _searchLength_.
          1. If _end_ > _len_, return *false*.
          1. Let _substring_ be the substring of _S_ from _start_ to _end_.
          1. If _substring_ is _searchStr_, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method returns *true* if the sequence of code units of _searchString_ converted to a String is the same as the corresponding code units of this object (converted to a String) starting at index _position_. Otherwise it returns *false*.</p>
        </emu-note>
        <emu-note>
          <p>Throwing an exception if the first argument is a RegExp is specified in order to allow future editions to define extensions that allow such argument values.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.substring">
        <h1>String.prototype.substring ( _start_, _end_ )</h1>
        <p>This method returns a <emu-not-ref>substring</emu-not-ref> of the result of converting this object to a String, starting from index _start_ and running to, but not including, index _end_ of the String (or through the end of the String if _end_ is *undefined*). The result is a String value, not a String object.</p>
        <p>If either argument is *NaN* or negative, it is replaced with zero; if either argument is strictly greater than the length of the String, it is replaced with the length of the String.</p>
        <p>If _start_ is strictly greater than _end_, they are swapped.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _len_ be the length of _S_.
          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).
          1. Let _finalStart_ be the result of clamping _intStart_ between 0 and _len_.
          1. Let _finalEnd_ be the result of clamping _intEnd_ between 0 and _len_.
          1. Let _from_ be min(_finalStart_, _finalEnd_).
          1. Let _to_ be max(_finalStart_, _finalEnd_).
          1. Return the substring of _S_ from _from_ to _to_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocalelowercase">
        <h1>String.prototype.toLocaleLowerCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It works exactly the same as `toLowerCase` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolocaleuppercase">
        <h1>String.prototype.toLocaleUpperCase ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used:</p>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It works exactly the same as `toUpperCase` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale. There will only be a difference in the few cases (such as Turkish) where the rules for that language conflict with the regular Unicode case mappings.</p>
        <p>The meaning of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tolowercase">
        <h1>String.prototype.toLowerCase ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _sText_ be StringToCodePoints(_S_).
          1. Let _lowerText_ be toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.
          1. Let _L_ be CodePointsToString(_lowerText_).
          1. Return _L_.
        </emu-alg>
        <p>The result must be derived according to the locale-insensitive case mappings in the Unicode Character Database (this explicitly includes not only the file <a href="https://unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"><code>UnicodeData.txt</code></a>, but also all locale-insensitive mappings in the file <a href="https://unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt"><code>SpecialCasing.txt</code></a> that accompanies it).</p>
        <emu-note>
          <p>The case mapping of some code points may produce multiple code points. In this case the result String may not be the same length as the source String. Because both `toUpperCase` and `toLowerCase` have context-sensitive behaviour, the methods are not symmetrical. In other words, `s.toUpperCase().toLowerCase()` is not necessarily equal to `s.toLowerCase()`.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.tostring">
        <h1>String.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisStringValue(*this* value).
        </emu-alg>
        <emu-note>
          <p>For a String object, this method happens to return the same thing as the `valueOf` method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.touppercase">
        <h1>String.prototype.toUpperCase ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It behaves in exactly the same way as `String.prototype.toLowerCase`, except that the String is mapped using the toUppercase algorithm of the Unicode Default Case Conversion.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.towellformed">
        <h1>String.prototype.toWellFormed ( )</h1>
        <p>This method returns a String representation of this object with all leading surrogates and trailing surrogates that are not part of a surrogate pair replaced with U+FFFD (REPLACEMENT CHARACTER).</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _strLen_ be the length of _S_.
          1. Let _k_ be 0.
          1. Let _result_ be the empty String.
          1. Repeat, while _k_ &lt; _strLen_,
            1. Let _cp_ be CodePointAt(_S_, _k_).
            1. If _cp_.[[IsUnpairedSurrogate]] is *true*, then
              1. Set _result_ to the string-concatenation of _result_ and 0xFFFD (REPLACEMENT CHARACTER).
            1. Else,
              1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_.[[CodePoint]]).
            1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trim">
        <h1>String.prototype.trim ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? TrimString(_S_, ~start+end~).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-trimstring" type="abstract operation">
          <h1>
            TrimString (
              _string_: an ECMAScript language value,
              _where_: ~start~, ~end~, or ~start+end~,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It interprets _string_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</dd>
          </dl>
          <emu-alg>
            1. Perform ? RequireObjectCoercible(_string_).
            1. Let _S_ be ? ToString(_string_).
            1. If _where_ is ~start~, then
              1. Let _T_ be the String value that is a copy of _S_ with leading white space removed.
            1. Else if _where_ is ~end~, then
              1. Let _T_ be the String value that is a copy of _S_ with trailing white space removed.
            1. Else,
              1. Assert: _where_ is ~start+end~.
              1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.
            1. Return _T_.
          </emu-alg>
          <p>The definition of white space is the union of |WhiteSpace| and |LineTerminator|. When determining whether a Unicode code point is in Unicode general category “Space_Separator” (“Zs”), code unit sequences are interpreted as UTF-16 encoded code point sequences as specified in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimend">
        <h1>String.prototype.trimEnd ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? TrimString(_S_, ~end~).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.trimstart">
        <h1>String.prototype.trimStart ( )</h1>
        <p>This method interprets a String value as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? TrimString(_S_, ~start~).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-string.prototype.valueof">
        <h1>String.prototype.valueOf ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Return ? ThisStringValue(*this* value).
        </emu-alg>

        <emu-clause id="sec-thisstringvalue" type="abstract operation" oldids="thisstringvalue">
          <h1>
            ThisStringValue (
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _value_ is a String, return _value_.
            1. If _value_ is an Object and _value_ has a [[StringData]] internal slot, then
              1. Let _s_ be _value_.[[StringData]].
              1. Assert: _s_ is a String.
              1. Return _s_.
            1. Throw a *TypeError* exception.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-string.prototype-%symbol.iterator%" oldids="sec-string.prototype-@@iterator,sec-createstringiterator,sec-properties-of-string-iterator-instances,table-46,table-internal-slots-of-string-iterator-instances">
        <h1>String.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>This method returns an iterator object that iterates over the code points of a String value, returning each code point as a String value.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _s_ be ? ToString(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:
            1. Let _len_ be the length of _s_.
            1. Let _position_ be 0.
            1. Repeat, while _position_ &lt; _len_,
              1. Let _cp_ be CodePointAt(_s_, _position_).
              1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].
              1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.
              1. Set _position_ to _nextIndex_.
              1. Perform ? GeneratorYield(CreateIteratorResultObject(_resultString_, *false*)).
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%StringIteratorPrototype%"*, %StringIteratorPrototype%).
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.iterator]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-string-instances">
      <h1>Properties of String Instances</h1>
      <p>String instances are String exotic objects and have the internal methods specified for such objects. String instances inherit properties from the String prototype object. String instances also have a [[StringData]] internal slot. The [[StringData]] internal slot is the String value represented by this String object.</p>
      <p>String instances have a *"length"* property, and a set of enumerable properties with integer-indexed names.</p>

      <emu-clause id="sec-properties-of-string-instances-length">
        <h1>length</h1>
        <p>The number of elements in the String value represented by this String object.</p>
        <p>Once a String object is initialized, this property is unchanging. It has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-string-iterator-objects">
      <h1>String Iterator Objects</h1>
      <p>A <dfn variants="String Iterators,String Iterator object,String Iterator objects">String Iterator</dfn> is an object that represents a specific iteration over some specific String instance object. There is not a named constructor for String Iterator objects. Instead, String Iterator objects are created by calling certain methods of String instance objects.</p>

      <emu-clause id="sec-%stringiteratorprototype%-object">
        <h1>The %StringIteratorPrototype% Object</h1>
        <p>The <dfn>%StringIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all String Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%stringiteratorprototype%.next">
          <h1>%StringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%StringIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%stringiteratorprototype%-@@tostringtag" id="sec-%stringiteratorprototype%-%symbol.tostringtag%">
          <h1>%StringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"String Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-regexp-regular-expression-objects">
    <h1>RegExp (Regular Expression) Objects</h1>
    <p>A RegExp object contains a regular expression and the associated flags.</p>
    <emu-note>
      <p>The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 programming language.</p>
    </emu-note>

    <emu-clause id="sec-patterns">
      <h1>Patterns</h1>
      <p>The RegExp constructor applies the following grammar to the input pattern String. An error occurs if the grammar cannot interpret the String as an expansion of |Pattern|.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Pattern[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Disjunction[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `|` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Alternative[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [empty]
          Alternative[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Term[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]

        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          Assertion[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          Atom[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          `(?=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        Quantifier ::
          QuantifierPrefix
          QuantifierPrefix `?`

        QuantifierPrefix ::
          `*`
          `+`
          `?`
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        Atom[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          PatternCharacter
          `.`
          `\` AtomEscape[?UnicodeMode, ?NamedCaptureGroups]
          CharacterClass[?UnicodeMode, ?UnicodeSetsMode]
          `(` GroupSpecifier[?UnicodeMode]? Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        RegularExpressionModifiers ::
          [empty]
          RegularExpressionModifiers RegularExpressionModifier

        RegularExpressionModifier :: one of
          `i` `m` `s`

        SyntaxCharacter :: one of
          `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

        PatternCharacter ::
          SourceCharacter but not SyntaxCharacter

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          DecimalEscape
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          IdentityEscape[?UnicodeMode]

        ControlEscape :: one of
          `f` `n` `r` `t` `v`

        GroupSpecifier[UnicodeMode] ::
          `?` GroupName[?UnicodeMode]

        GroupName[UnicodeMode] ::
          `&lt;` RegExpIdentifierName[?UnicodeMode] `&gt;`

        RegExpIdentifierName[UnicodeMode] ::
          RegExpIdentifierStart[?UnicodeMode]
          RegExpIdentifierName[?UnicodeMode] RegExpIdentifierPart[?UnicodeMode]

        RegExpIdentifierStart[UnicodeMode] ::
          IdentifierStartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpIdentifierPart[UnicodeMode] ::
          IdentifierPartChar
          `\` RegExpUnicodeEscapeSequence[+UnicodeMode]
          [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate

        RegExpUnicodeEscapeSequence[UnicodeMode] ::
          [+UnicodeMode] `u` HexLeadSurrogate `\u` HexTrailSurrogate
          [+UnicodeMode] `u` HexLeadSurrogate
          [+UnicodeMode] `u` HexTrailSurrogate
          [+UnicodeMode] `u` HexNonSurrogate
          [~UnicodeMode] `u` Hex4Digits
          [+UnicodeMode] `u{` CodePoint `}`

        UnicodeLeadSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+D800 to U+DBFF

        UnicodeTrailSurrogate ::
          &gt; any Unicode code point in the inclusive interval from U+DC00 to U+DFFF
      </emu-grammar>
      <p>Each `\\u` |HexTrailSurrogate| for which the choice of associated `u` |HexLeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |HexLeadSurrogate| that would otherwise have no corresponding `\\u` |HexTrailSurrogate|.</p>
      <emu-grammar type="definition">
        HexLeadSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xD800 to 0xDBFF]

        HexTrailSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is in the inclusive interval from 0xDC00 to 0xDFFF]

        HexNonSurrogate ::
          Hex4Digits [> but only if the MV of |Hex4Digits| is not in the inclusive interval from 0xD800 to 0xDFFF]

        IdentityEscape[UnicodeMode] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacter but not UnicodeIDContinue

        DecimalEscape ::
          NonZeroDigit DecimalDigits[~Sep]? [lookahead &notin; DecimalDigit]

        CharacterClassEscape[UnicodeMode] ::
          `d`
          `D`
          `s`
          `S`
          `w`
          `W`
          [+UnicodeMode] `p{` UnicodePropertyValueExpression `}`
          [+UnicodeMode] `P{` UnicodePropertyValueExpression `}`

        UnicodePropertyValueExpression ::
          UnicodePropertyName `=` UnicodePropertyValue
          LoneUnicodePropertyNameOrValue

        UnicodePropertyName ::
          UnicodePropertyNameCharacters

        UnicodePropertyNameCharacters ::
          UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

        UnicodePropertyValue ::
          UnicodePropertyValueCharacters

        LoneUnicodePropertyNameOrValue ::
          UnicodePropertyValueCharacters

        UnicodePropertyValueCharacters ::
          UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

        UnicodePropertyValueCharacter ::
          UnicodePropertyNameCharacter
          DecimalDigit

        UnicodePropertyNameCharacter ::
          AsciiLetter
          `_`

        CharacterClass[UnicodeMode, UnicodeSetsMode] ::
          `[` [lookahead != `^`] ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`
          `[^` ClassContents[?UnicodeMode, ?UnicodeSetsMode] `]`

        ClassContents[UnicodeMode, UnicodeSetsMode] ::
          [empty]
          [~UnicodeSetsMode] NonemptyClassRanges[?UnicodeMode]
          [+UnicodeSetsMode] ClassSetExpression

        NonemptyClassRanges[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtom[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtom[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        NonemptyClassRangesNoDash[UnicodeMode] ::
          ClassAtom[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] NonemptyClassRangesNoDash[?UnicodeMode]
          ClassAtomNoDash[?UnicodeMode] `-` ClassAtom[?UnicodeMode] ClassContents[?UnicodeMode, ~UnicodeSetsMode]

        ClassAtom[UnicodeMode] ::
          `-`
          ClassAtomNoDash[?UnicodeMode]

        ClassAtomNoDash[UnicodeMode] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode]

        ClassEscape[UnicodeMode] ::
          `b`
          [+UnicodeMode] `-`
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode]

        ClassSetExpression ::
          ClassUnion
          ClassIntersection
          ClassSubtraction

        ClassUnion ::
          ClassSetRange ClassUnion?
          ClassSetOperand ClassUnion?

        ClassIntersection ::
          ClassSetOperand `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand
          ClassIntersection `&amp;&amp;` [lookahead != `&amp;`] ClassSetOperand

        ClassSubtraction ::
          ClassSetOperand `--` ClassSetOperand
          ClassSubtraction `--` ClassSetOperand

        ClassSetRange ::
          ClassSetCharacter `-` ClassSetCharacter

        ClassSetOperand ::
          NestedClass
          ClassStringDisjunction
          ClassSetCharacter

        NestedClass ::
          `[` [lookahead != `^`] ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `[^` ClassContents[+UnicodeMode, +UnicodeSetsMode] `]`
          `\` CharacterClassEscape[+UnicodeMode]
      </emu-grammar>
      <emu-note>
        <p>The first two lines here are equivalent to CharacterClass.</p>
      </emu-note>
      <emu-grammar type="definition">
        ClassStringDisjunction ::
          `\q{` ClassStringDisjunctionContents `}`

        ClassStringDisjunctionContents ::
          ClassString
          ClassString `|` ClassStringDisjunctionContents

        ClassString ::
          [empty]
          NonEmptyClassString

        NonEmptyClassString ::
          ClassSetCharacter NonEmptyClassString?

        ClassSetCharacter ::
          [lookahead &notin; ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
          `\` CharacterEscape[+UnicodeMode]
          `\` ClassSetReservedPunctuator
          `\b`

        ClassSetReservedDoublePunctuator :: one of
          `&amp;&amp;` `!!` `##`
          `$$` `%%` `**`
          `++` `,,` `..`
          `::` `;;` `&lt;&lt;`
          `==` `&gt;&gt;` `??`
          `@@` `^^` `&grave;&grave;`
          `~~`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetSyntaxCharacter :: one of
          `(` `)` `[` `]` `{` `}` `/` `-` `\` `|`
      </emu-grammar>
      <emu-grammar type="definition">
        ClassSetReservedPunctuator :: one of
          `&amp;` `-` `!` `#` `%` `,`
          `:` `;` `&lt;` `=` `&gt;` `@`
          `&grave;` `~`
      </emu-grammar>
      <emu-note>
        <p>A number of productions in this section are given alternative definitions in section <emu-xref href="#sec-regular-expressions-patterns"></emu-xref>.</p>
      </emu-note>

      <emu-clause id="sec-patterns-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if CountLeftCapturingParensWithin(|Pattern|) ≥ 2<sup>32</sup> - 1.
          </li>
          <li>
            It is a Syntax Error if |Pattern| contains two distinct |GroupSpecifier|s _x_ and _y_ such that the CapturingGroupName of _x_ is the CapturingGroupName of _y_ and such that MightBothParticipate(_x_, _y_) is *true*.
          </li>
        </ul>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the MV of the first |DecimalDigits| is strictly greater than the MV of the second |DecimalDigits|.
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by |RegularExpressionModifiers| contains the same code point more than once.
          </li>
        </ul>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by the first |RegularExpressionModifiers| and the source text matched by the second |RegularExpressionModifiers| are both empty.
          </li>
          <li>
            It is a Syntax Error if the source text matched by the first |RegularExpressionModifiers| contains the same code point more than once.
          </li>
          <li>
            It is a Syntax Error if the source text matched by the second |RegularExpressionModifiers| contains the same code point more than once.
          </li>
          <li>
            It is a Syntax Error if any code point in the source text matched by the first |RegularExpressionModifiers| is also contained in the source text matched by the second |RegularExpressionModifiers|.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if GroupSpecifiersThatMatch(|GroupName|) is empty.
          </li>
        </ul>
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CapturingGroupNumber of |DecimalEscape| is strictly greater than CountLeftCapturingParensWithin(the |Pattern| containing |AtomEscape|).
          </li>
        </ul>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true*.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *false*, IsCharacterClass of the second |ClassAtom| is *false*, and the CharacterValue of the first |ClassAtom| is strictly greater than the CharacterValue of the second |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true*.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *false*, IsCharacterClass of |ClassAtom| is *false*, and the CharacterValue of |ClassAtomNoDash| is strictly greater than the CharacterValue of |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CharacterValue of |RegExpUnicodeEscapeSequence| is not the numeric value of some code point matched by the |IdentifierStartChar| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the RegExpIdentifierCodePoint of |RegExpIdentifierStart| is not matched by the |UnicodeIDStart| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CharacterValue of |RegExpUnicodeEscapeSequence| is not the numeric value of some code point matched by the |IdentifierPartChar| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the RegExpIdentifierCodePoint of |RegExpIdentifierPart| is not matched by the |UnicodeIDContinue| lexical grammar production.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by |UnicodePropertyName| is not a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if the source text matched by |UnicodePropertyValue| is not a property value or property value alias for the Unicode property or property alias given by the source text matched by |UnicodePropertyName| listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>.
          </li>
        </ul>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the source text matched by |LoneUnicodePropertyNameOrValue| is not a Unicode property value or property value alias for the General_Category (gc) property listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>, nor a binary property or binary property alias listed in the “Property name and aliases” column of <emu-xref href="#table-binary-unicode-properties"></emu-xref>, nor a binary property of strings listed in the “Property name” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if the enclosing |Pattern| does not have a <sub>[UnicodeSetsMode]</sub> parameter and the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>.
          </li>
        </ul>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if MayContainStrings of the |UnicodePropertyValueExpression| is *true*.
          </li>
        </ul>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if MayContainStrings of the |ClassContents| is *true*.
          </li>
        </ul>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if MayContainStrings of the |ClassContents| is *true*.
          </li>
        </ul>
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the CharacterValue of the first |ClassSetCharacter| is strictly greater than the CharacterValue of the second |ClassSetCharacter|.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparenswithin" type="abstract operation">
        <h1>
          Static Semantics: CountLeftCapturingParensWithin (
            _node_: a Parse Node,
          ): a non-negative integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the number of left-capturing parentheses in _node_. A <dfn variants="left-capturing parentheses">left-capturing parenthesis</dfn> is any `(` pattern character that is matched by the `(` terminal of the <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> production.</dd>
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-alg>
          1. Assert: _node_ is an instance of a production in <emu-xref href="#sec-patterns">the RegExp Pattern grammar</emu-xref>.
          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _node_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-countleftcapturingparensbefore" type="abstract operation">
        <h1>
          Static Semantics: CountLeftCapturingParensBefore (
            _node_: a Parse Node,
          ): a non-negative integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns the number of left-capturing parentheses within the enclosing pattern that occur to the left of _node_.</dd>
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-countleftcapturingparens-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-alg>
          1. Assert: _node_ is an instance of a production in <emu-xref href="#sec-patterns">the RegExp Pattern grammar</emu-xref>.
          1. Let _pattern_ be the |Pattern| containing _node_.
          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _pattern_ that either occur before _node_ or contain _node_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-mightbothparticipate" type="abstract operation">
        <h1>
          Static Semantics: MightBothParticipate (
            _x_: a Parse Node,
            _y_: a Parse Node,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _x_ and _y_ have the same enclosing |Pattern|.
          1. If the enclosing |Pattern| contains a <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar> Parse Node such that either _x_ is contained within the |Alternative| and _y_ is contained within the derived |Disjunction|, or _x_ is contained within the derived |Disjunction| and _y_ is contained within the |Alternative|, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-capturing-group-number" type="sdo">
        <h1>Static Semantics: CapturingGroupNumber ( ): a positive integer</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-early-errors-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>DecimalEscape :: NonZeroDigit</emu-grammar>
        <emu-alg>
          1. Return the MV of |NonZeroDigit|.
        </emu-alg>
        <emu-grammar>DecimalEscape :: NonZeroDigit DecimalDigits</emu-grammar>
        <emu-alg>
          1. Let _n_ be the number of code points in |DecimalDigits|.
          1. Return (the MV of |NonZeroDigit| × 10<sup>_n_</sup> plus the MV of |DecimalDigits|).
        </emu-alg>
        <p>The definitions of “the MV of |NonZeroDigit|” and “the MV of |DecimalDigits|” are in <emu-xref href="#sec-literals-numeric-literals"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-is-character-class" type="sdo">
        <h1>Static Semantics: IsCharacterClass ( ): a Boolean</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-is-character-class-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>
          ClassAtom ::
            `-`

          ClassAtomNoDash ::
            SourceCharacter but not one of `\` or `]` or `-`

          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-patterns-static-semantics-character-value" type="sdo">
        <h1>Static Semantics: CharacterValue ( ): a non-negative integer</h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-patterns-static-semantics-character-value-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>
          ClassAtom :: `-`
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+002D (HYPHEN-MINUS).
        </emu-alg>
        <emu-grammar>
          ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`
        </emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |SourceCharacter|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `b`
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+0008 (BACKSPACE).
        </emu-alg>
        <emu-grammar>
          ClassEscape :: `-`
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+002D (HYPHEN-MINUS).
        </emu-alg>
        <emu-grammar>CharacterEscape :: ControlEscape</emu-grammar>
        <emu-alg>
          1. Return the numeric value according to <emu-xref href="#table-controlescape-code-point-values"></emu-xref>.
        </emu-alg>
        <emu-table id="table-controlescape-code-point-values" caption="ControlEscape Code Point Values" oldids="table-47">
          <table>
            <thead>
              <tr>
                <th>
                  ControlEscape
                </th>
                <th>
                  Numeric Value
                </th>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode Name
                </th>
                <th>
                  Symbol
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `t`
              </td>
              <td>
                9
              </td>
              <td>
                `U+0009`
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                &lt;HT>
              </td>
            </tr>
            <tr>
              <td>
                `n`
              </td>
              <td>
                10
              </td>
              <td>
                `U+000A`
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                &lt;LF>
              </td>
            </tr>
            <tr>
              <td>
                `v`
              </td>
              <td>
                11
              </td>
              <td>
                `U+000B`
              </td>
              <td>
                LINE TABULATION
              </td>
              <td>
                &lt;VT>
              </td>
            </tr>
            <tr>
              <td>
                `f`
              </td>
              <td>
                12
              </td>
              <td>
                `U+000C`
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                &lt;FF>
              </td>
            </tr>
            <tr>
              <td>
                `r`
              </td>
              <td>
                13
              </td>
              <td>
                `U+000D`
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                &lt;CR>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-grammar>CharacterEscape :: `c` AsciiLetter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |AsciiLetter|.
          1. Let _i_ be the numeric value of _ch_.
          1. Return the remainder of dividing _i_ by 32.
        </emu-alg>
        <emu-grammar>CharacterEscape :: `0` [lookahead &notin; DecimalDigit]</emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+0000 (NULL).
        </emu-alg>
        <emu-note>
          <p>`\\0` represents the &lt;NUL> character and cannot be followed by a decimal digit.</p>
        </emu-note>
        <emu-grammar>CharacterEscape :: HexEscapeSequence</emu-grammar>
        <emu-alg>
          1. Return the MV of |HexEscapeSequence|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` HexLeadSurrogate `\u` HexTrailSurrogate</emu-grammar>
        <emu-alg>
          1. Let _lead_ be the CharacterValue of |HexLeadSurrogate|.
          1. Let _trail_ be the CharacterValue of |HexTrailSurrogate|.
          1. Let _cp_ be UTF16SurrogatePairToCodePoint(_lead_, _trail_).
          1. Return the numeric value of _cp_.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u` Hex4Digits</emu-grammar>
        <emu-alg>
          1. Return the MV of |Hex4Digits|.
        </emu-alg>
        <emu-grammar>RegExpUnicodeEscapeSequence :: `u{` CodePoint `}`</emu-grammar>
        <emu-alg>
          1. Return the MV of |CodePoint|.
        </emu-alg>
        <emu-grammar>
          HexLeadSurrogate :: Hex4Digits

          HexTrailSurrogate :: Hex4Digits

          HexNonSurrogate :: Hex4Digits
        </emu-grammar>
        <emu-alg>
          1. Return the MV of |Hex4Digits|.
        </emu-alg>
        <emu-grammar>CharacterEscape :: IdentityEscape</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |IdentityEscape|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: SourceCharacter but not ClassSetSyntaxCharacter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |SourceCharacter|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\` ClassSetReservedPunctuator</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |ClassSetReservedPunctuator|.
          1. Return the numeric value of _ch_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+0008 (BACKSPACE).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-maycontainstrings" type="sdo">
        <h1>Static Semantics: MayContainStrings ( ): a Boolean</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          CharacterClassEscape ::
            `d`
            `D`
            `s`
            `S`
            `w`
            `W`
            `P{` UnicodePropertyValueExpression `}`

          UnicodePropertyValueExpression ::
            UnicodePropertyName `=` UnicodePropertyValue

          NestedClass ::
            `[^` ClassContents `]`

          ClassContents ::
            [empty]
            NonemptyClassRanges

          ClassSetOperand ::
            ClassSetCharacter
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. If the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>, return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. If the |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the |ClassSetOperand| is *true*, return *true*.
          1. If |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.
          1. Return *false*.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the first |ClassSetOperand| is *false*, return *false*.
          1. If MayContainStrings of the second |ClassSetOperand| is *false*, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the |ClassIntersection| is *false*, return *false*.
          1. If MayContainStrings of the |ClassSetOperand| is *false*, return *false*.
          1. Return *true*.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Return MayContainStrings of the first |ClassSetOperand|.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Return MayContainStrings of the |ClassSubtraction|.
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. If MayContainStrings of the |ClassString| is *true*, return *true*.
          1. Return MayContainStrings of the |ClassStringDisjunctionContents|.
        </emu-alg>
        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. Return MayContainStrings of the |NonEmptyClassString|.
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. If |NonEmptyClassString| is present, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-groupspecifiersthatmatch" type="abstract operation">
        <h1>
          Static Semantics: GroupSpecifiersThatMatch (
            _thisGroupName_: a |GroupName| Parse Node,
          ): a List of |GroupSpecifier| Parse Nodes
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _name_ be the CapturingGroupName of _thisGroupName_.
          1. Let _pattern_ be the |Pattern| containing _thisGroupName_.
          1. Let _result_ be a new empty List.
          1. For each |GroupSpecifier| _gs_ that _pattern_ contains, do
            1. If the CapturingGroupName of _gs_ is _name_, then
              1. Append _gs_ to _result_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-static-semantics-capturinggroupname" oldids="sec-regexp-identifier-names-static-semantics-stringvalue" type="sdo">
        <h1>Static Semantics: CapturingGroupName ( ): a String</h1>
        <dl class="header">
        </dl>
        <emu-grammar>
          GroupName :: `&lt;` RegExpIdentifierName `&gt;`
        </emu-grammar>
        <emu-alg>
          1. Let _idTextUnescaped_ be the RegExpIdentifierCodePoints of |RegExpIdentifierName|.
          1. Return CodePointsToString(_idTextUnescaped_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoints" type="sdo">
        <h1>Static Semantics: RegExpIdentifierCodePoints ( ): a List of code points</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierStart</emu-grammar>
        <emu-alg>
          1. Let _cp_ be the RegExpIdentifierCodePoint of |RegExpIdentifierStart|.
          1. Return « _cp_ ».
        </emu-alg>
        <emu-grammar>RegExpIdentifierName :: RegExpIdentifierName RegExpIdentifierPart</emu-grammar>
        <emu-alg>
          1. Let _cps_ be the RegExpIdentifierCodePoints of the derived |RegExpIdentifierName|.
          1. Let _cp_ be the RegExpIdentifierCodePoint of |RegExpIdentifierPart|.
          1. Return the list-concatenation of _cps_ and « _cp_ ».
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpidentifiercodepoint" type="sdo">
        <h1>Static Semantics: RegExpIdentifierCodePoint ( ): a code point</h1>
        <dl class="header">
        </dl>
        <emu-grammar>RegExpIdentifierStart :: IdentifierStartChar</emu-grammar>
        <emu-alg>
          1. Return the code point matched by |IdentifierStartChar|.
        </emu-alg>
        <emu-grammar>RegExpIdentifierPart :: IdentifierPartChar</emu-grammar>
        <emu-alg>
          1. Return the code point matched by |IdentifierPartChar|.
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: `\` RegExpUnicodeEscapeSequence

          RegExpIdentifierPart :: `\` RegExpUnicodeEscapeSequence
        </emu-grammar>
        <emu-alg>
          1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.
        </emu-alg>
        <emu-grammar>
          RegExpIdentifierStart :: UnicodeLeadSurrogate UnicodeTrailSurrogate

          RegExpIdentifierPart :: UnicodeLeadSurrogate UnicodeTrailSurrogate
        </emu-grammar>
        <emu-alg>
          1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.
          1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.
          1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-pattern-semantics">
      <h1>Pattern Semantics</h1>
      <p>A regular expression pattern is converted into an Abstract Closure using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The Abstract Closure is used as the value of a RegExp object's [[RegExpMatcher]] internal slot.</p>
      <p>A |Pattern| is a BMP pattern if its associated flags contain neither a `u` nor a `v`. Otherwise, it is a Unicode pattern. A BMP pattern matches against a String interpreted as consisting of a sequence of 16-bit values that are Unicode code points in the range of the Basic Multilingual Plane. A Unicode pattern matches against a String interpreted as consisting of Unicode code points encoded using UTF-16. In the context of describing the behaviour of a BMP pattern “character” means a single 16-bit Unicode BMP code point. In the context of describing the behaviour of a Unicode pattern “character” means a UTF-16 encoded code point (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>). In either context, “character value” means the numeric value of the corresponding non-encoded code point.</p>
      <p>The syntax and semantics of |Pattern| is defined as if the source text for the |Pattern| was a List of |SourceCharacter| values where each |SourceCharacter| corresponds to a Unicode code point. If a BMP pattern contains a non-BMP |SourceCharacter| the entire pattern is encoded using UTF-16 and the individual code units of that encoding are used as the elements of the List.</p>
      <emu-note>
        <p>For example, consider a pattern expressed in source text as the single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a Unicode pattern, it would be a single element (character) List consisting of the single code point U+1D11E. However, interpreted as a BMP pattern, it is first UTF-16 encoded to produce a two element List consisting of the code units 0xD834 and 0xDD1E.</p>
        <p>Patterns are passed to the RegExp constructor as ECMAScript String values in which non-BMP characters are UTF-16 encoded. For example, the single character MUSICAL SYMBOL G CLEF pattern, expressed as a String value, is a String of length 2 whose elements were the code units 0xD834 and 0xDD1E. So no further translation of the string would be necessary to process it as a BMP pattern consisting of two pattern characters. However, to process it as a Unicode pattern UTF16SurrogatePairToCodePoint must be used in producing a List whose sole element is a single pattern character, the code point U+1D11E.</p>
        <p>An implementation may not actually perform such translations to or from UTF-16, but the semantics of this specification requires that the result of pattern matching be as if such translations were performed.</p>
      </emu-note>

      <emu-clause id="sec-pattern-notation" oldids="sec-notation">
        <h1>Notation</h1>
        <p>The descriptions below use the following internal data structures:</p>
        <ul>
          <li>
            A <dfn>CharSetElement</dfn> is one of the two following entities:
            <ul>
              <li>
                If _rer_.[[UnicodeSets]] is *false*, then a CharSetElement is a character in the sense of the Pattern Semantics above.
              </li>
              <li>
                If _rer_.[[UnicodeSets]] is *true*, then a CharSetElement is a sequence whose elements are characters in the sense of the Pattern Semantics above. This includes the empty sequence, sequences of one character, and sequences of more than one character. For convenience, when working with CharSetElements of this kind, an individual character is treated interchangeably with a sequence of one character.
              </li>
            </ul>
          </li>
          <li>
            A <dfn id="pattern-charset" variants="CharSets">CharSet</dfn> is a mathematical set of CharSetElements.
          </li>
          <li>
            A <dfn id="pattern-capturerange" variants="CaptureRanges">CaptureRange</dfn> is a Record { [[StartIndex]], [[EndIndex]] } that represents the range of characters included in a capture, where [[StartIndex]] is an integer representing the start index (inclusive) of the range within _Input_, and [[EndIndex]] is an integer representing the end index (exclusive) of the range within _Input_. For any CaptureRange, these indices must satisfy the invariant that [[StartIndex]] ≤ [[EndIndex]].
          </li>
          <li>
            A <dfn id="pattern-matchstate" variants="MatchStates" oldids="pattern-matchresult">MatchState</dfn> is a Record { [[Input]], [[EndIndex]], [[Captures]] } where [[Input]] is a List of characters representing the String being matched, [[EndIndex]] is an integer, and [[Captures]] is a List of values, one for each left-capturing parenthesis in the pattern. MatchStates are used to represent partial match states in the regular expression matching algorithms. The [[EndIndex]] is one plus the index of the last input character matched so far by the pattern, while [[Captures]] holds the results of capturing parentheses. The _n_<sup>th</sup> element of [[Captures]] is either a CaptureRange representing the range of characters captured by the _n_<sup>th</sup> set of capturing parentheses, or *undefined* if the _n_<sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many MatchStates may be in use at any time during the matching process.
          </li>
          <li>
            A <dfn id="pattern-matchercontinuation" variants="MatcherContinuations">MatcherContinuation</dfn> is an Abstract Closure that takes one MatchState argument and returns either a MatchState or ~failure~. The MatcherContinuation attempts to match the remaining portion (specified by the closure's captured values) of the pattern against _Input_, starting at the intermediate state given by its MatchState argument. If the match succeeds, the MatcherContinuation returns the final MatchState that it reached; if the match fails, the MatcherContinuation returns ~failure~.
          </li>
          <li>
            A <dfn id="pattern-matcher" variants="Matchers">Matcher</dfn> is an Abstract Closure that takes two arguments—a MatchState and a MatcherContinuation—and returns either a MatchState or ~failure~. A Matcher attempts to match a middle subpattern (specified by the closure's captured values) of the pattern against the MatchState's [[Input]], starting at the intermediate state given by its MatchState argument. The MatcherContinuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new MatchState, the Matcher then calls MatcherContinuation on that new MatchState to test if the rest of the pattern can match as well. If it can, the Matcher returns the MatchState returned by MatcherContinuation; if not, the Matcher may try different choices at its choice points, repeatedly calling MatcherContinuation until it either succeeds or all possibilities have been exhausted.
          </li>
        </ul>

        <emu-clause id="sec-regexp-records">
          <h1>RegExp Records</h1>
          <p>A <dfn variants="RegExp Records">RegExp Record</dfn> is a Record value used to store information about a RegExp that is needed during compilation and possibly during matching.</p>
          <p>It has the following fields:</p>
          <emu-table id="table-regexp-record-fields" caption="RegExp Record Fields">
            <table>
              <thead>
                <tr>
                  <th>Field Name</th>
                  <th>Value</th>
                  <th>Meaning</th>
                </tr>
              </thead>
              <tr>
                <td>[[IgnoreCase]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"i"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[Multiline]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"m"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[DotAll]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"s"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[Unicode]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"u"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[UnicodeSets]]</td>
                <td>a Boolean</td>
                <td>indicates whether *"v"* appears in the RegExp's flags</td>
              </tr>
              <tr>
                <td>[[CapturingGroupsCount]]</td>
                <td>a non-negative integer</td>
                <td>the number of left-capturing parentheses in the RegExp's pattern</td>
              </tr>
            </table>
          </emu-table>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilepattern" type="sdo" oldids="sec-pattern">
        <h1>
          Runtime Semantics: CompilePattern (
            _rer_: a RegExp Record,
          ): an Abstract Closure that takes a List of characters and a non-negative integer and returns either a MatchState or ~failure~
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Pattern :: Disjunction</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.
          1. Return a new Abstract Closure with parameters (_Input_, _index_) that captures _rer_ and _m_ and performs the following steps when called:
            1. Assert: _Input_ is a List of characters.
            1. Assert: 0 ≤ _index_ ≤ the number of elements in _Input_.
            1. Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].
            1. Let _x_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }.
            1. Return _m_(_x_, _c_).
        </emu-alg>
        <emu-note>
          <p>A Pattern compiles to an Abstract Closure value. RegExpBuiltinExec can then apply this procedure to a List of characters and an offset within that List to determine whether the pattern would match starting at exactly that offset within the List, and, if it does match, what the values of the capturing parentheses would be. The algorithms in <emu-xref href="#sec-pattern-semantics"></emu-xref> are designed so that compiling a pattern may throw a *SyntaxError* exception; on the other hand, once the pattern is successfully compiled, applying the resulting Abstract Closure to find a match in a List of characters cannot throw an exception (except for any implementation-defined exceptions that can occur anywhere such as out-of-memory).</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-compilesubpattern" type="sdo" oldids="sec-disjunction,sec-alternative,sec-term">
        <h1>
          Runtime Semantics: CompileSubpattern (
            _rer_: a RegExp Record,
            _direction_: ~forward~ or ~backward~,
          ): a Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compilesubpattern-annexb"></emu-xref>.</p>
        </emu-note>

        <!-- Disjunction -->
        <emu-grammar>Disjunction :: Alternative `|` Disjunction</emu-grammar>
        <emu-alg>
          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.
          1. Let _m2_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.
          1. Return MatchTwoAlternatives(_m1_, _m2_).
        </emu-alg>
        <emu-note>
          <p>The `|` regular expression operator separates two alternatives. The pattern first tries to match the left |Alternative| (followed by the sequel of the regular expression); if it fails, it tries to match the right |Disjunction| (followed by the sequel of the regular expression). If the left |Alternative|, the right |Disjunction|, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left |Alternative|. If choices in the left |Alternative| are exhausted, the right |Disjunction| is tried instead of the left |Alternative|. Any capturing parentheses inside a portion of the pattern skipped by `|` produce *undefined* values instead of Strings. Thus, for example,</p>
          <pre><code class="javascript">/a|ab/.exec("abc")</code></pre>
          <p>returns the result *"a"* and not *"ab"*. Moreover,</p>
          <pre><code class="javascript">/((a)|(ab))((c)|(bc))/.exec("abc")</code></pre>
          <p>returns the array</p>
          <pre><code class="javascript">["abc", "a", "a", undefined, "bc", undefined, "bc"]</code></pre>
          <p>and not</p>
          <pre><code class="javascript">["abc", "ab", undefined, "ab", "c", "c", undefined]</code></pre>
          <p>The order in which the two alternatives are tried is independent of the value of _direction_.</p>
        </emu-note>

        <!-- Alternative -->
        <emu-grammar>Alternative :: [empty]</emu-grammar>
        <emu-alg>
          1. Return EmptyMatcher().
        </emu-alg>
        <emu-grammar>Alternative :: Alternative Term</emu-grammar>
        <emu-alg>
          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.
          1. Let _m2_ be CompileSubpattern of |Term| with arguments _rer_ and _direction_.
          1. Return MatchSequence(_m1_, _m2_, _direction_).
        </emu-alg>
        <emu-note>
          <p>Consecutive |Term|s try to simultaneously match consecutive portions of _Input_. When _direction_ is ~forward~, if the left |Alternative|, the right |Term|, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right |Term|, and all choices in the right |Term| are tried before moving on to the next choice in the left |Alternative|. When _direction_ is ~backward~, the evaluation order of |Alternative| and |Term| are reversed.</p>
        </emu-note>

        <!-- Term -->
        <emu-grammar>Term :: Assertion</emu-grammar>
        <emu-alg>
          1. Return CompileAssertion of |Assertion| with argument _rer_.
        </emu-alg>
        <emu-note>
          <p>The resulting Matcher is independent of _direction_.</p>
        </emu-note>
        <emu-grammar>Term :: Atom</emu-grammar>
        <emu-alg>
          1. Return CompileAtom of |Atom| with arguments _rer_ and _direction_.
        </emu-alg>
        <emu-grammar>Term :: Atom Quantifier</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileAtom of |Atom| with arguments _rer_ and _direction_.
          1. Let _q_ be CompileQuantifier of |Quantifier|.
          1. Assert: _q_.[[Min]] ≤ _q_.[[Max]].
          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Term|).
          1. Let _parenCount_ be CountLeftCapturingParensWithin(|Atom|).
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_, _q_, _parenIndex_, and _parenCount_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Return RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-repeatmatcher-abstract-operation" type="abstract operation">
          <h1>
            RepeatMatcher (
              _m_: a Matcher,
              _min_: a non-negative integer,
              _max_: a non-negative integer or +&infin;,
              _greedy_: a Boolean,
              _x_: a MatchState,
              _c_: a MatcherContinuation,
              _parenIndex_: a non-negative integer,
              _parenCount_: a non-negative integer,
            ): either a MatchState or ~failure~
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _max_ = 0, return _c_(_x_).
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. [id="step-repeatmatcher-done"] If _min_ = 0 and _y_.[[EndIndex]] = _x_.[[EndIndex]], return ~failure~.
              1. If _min_ = 0, let _min2_ be 0; otherwise let _min2_ be _min_ - 1.
              1. If _max_ = +∞, let _max2_ be +∞; otherwise let _max2_ be _max_ - 1.
              1. Return RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).
            1. Let _cap_ be a copy of _x_.[[Captures]].
            1. [id="step-repeatmatcher-clear-captures"] For each integer _k_ in the inclusive interval from _parenIndex_ + 1 to _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _xr_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ }.
            1. If _min_ ≠ 0, return _m_(_xr_, _d_).
            1. If _greedy_ is *false*, then
              1. Let _z_ be _c_(_x_).
              1. If _z_ is not ~failure~, return _z_.
              1. Return _m_(_xr_, _d_).
            1. Let _z_ be _m_(_xr_, _d_).
            1. If _z_ is not ~failure~, return _z_.
            1. Return _c_(_x_).
          </emu-alg>
          <emu-note>
            <p>An |Atom| followed by a |Quantifier| is repeated the number of times specified by the |Quantifier|. A |Quantifier| can be non-greedy, in which case the |Atom| pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the |Atom| pattern is repeated as many times as possible while still matching the sequel. The |Atom| pattern is repeated rather than the input character sequence that it matches, so different repetitions of the |Atom| can match different input substrings.</p>
          </emu-note>
          <emu-note>
            <p>If the |Atom| and the sequel of the regular expression all have choice points, the |Atom| is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of |Atom|. All choices in the last (n<sup>th</sup>) repetition of |Atom| are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of |Atom|; at which point it may turn out that more or fewer repetitions of |Atom| are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of |Atom| and so on.</p>
            <p>Compare</p>
            <pre><code class="javascript">/a[a-z]{2,4}/.exec("abcdefghi")</code></pre>
            <p>which returns *"abcde"* with</p>
            <pre><code class="javascript">/a[a-z]{2,4}?/.exec("abcdefghi")</code></pre>
            <p>which returns *"abc"*.</p>
            <p>Consider also</p>
            <pre><code class="javascript">/(aa|aabaac|ba|b|c)*/.exec("aabaac")</code></pre>
            <p>which, by the choice point ordering above, returns the array</p>
            <pre><code class="javascript">["aaba", "ba"]</code></pre>
            <p>and not any of:</p>
            <pre><code class="javascript">
              ["aabaac", "aabaac"]
              ["aabaac", "c"]
            </code></pre>
            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>
            <pre><code class="javascript">"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/, "$1")</code></pre>
            <p>which returns the gcd in unary notation *"aaaaa"*.</p>
          </emu-note>
          <emu-note>
            <p>Step <emu-xref href="#step-repeatmatcher-clear-captures"></emu-xref> of the RepeatMatcher clears |Atom|'s captures each time |Atom| is repeated. We can see its behaviour in the regular expression</p>
            <pre><code class="javascript">/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")</code></pre>
            <p>which returns the array</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", undefined, "c"]</code></pre>
            <p>and not</p>
            <pre><code class="javascript">["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</code></pre>
            <p>because each iteration of the outermost `*` clears all captured Strings contained in the quantified |Atom|, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>
          </emu-note>
          <emu-note>
            <p>Step <emu-xref href="#step-repeatmatcher-done"></emu-xref> of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of |Atom| that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>
            <pre><code class="javascript">/(a*)*/.exec("b")</code></pre>
            <p>or the slightly more complicated:</p>
            <pre><code class="javascript">/(a*)b\1+/.exec("baaaac")</code></pre>
            <p>which returns the array</p>
            <pre><code class="javascript">["b", ""]</code></pre>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-emptymatcher" type="abstract operation">
          <h1>EmptyMatcher ( ): a Matcher</h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Return _c_(_x_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchtwoalternatives" type="abstract operation">
          <h1>
            MatchTwoAlternatives (
              _m1_: a Matcher,
              _m2_: a Matcher,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Let _r_ be _m1_(_x_, _c_).
              1. If _r_ is not ~failure~, return _r_.
              1. Return _m2_(_x_, _c_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-matchsequence" type="abstract operation">
          <h1>
            MatchSequence (
              _m1_: a Matcher,
              _m2_: a Matcher,
              _direction_: ~forward~ or ~backward~,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _direction_ is ~forward~, then
              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:
                1. Assert: _x_ is a MatchState.
                1. Assert: _c_ is a MatcherContinuation.
                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:
                  1. Assert: _y_ is a MatchState.
                  1. Return _m2_(_y_, _c_).
                1. Return _m1_(_x_, _d_).
            1. Else,
              1. Assert: _direction_ is ~backward~.
              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:
                1. Assert: _x_ is a MatchState.
                1. Assert: _c_ is a MatcherContinuation.
                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:
                  1. Assert: _y_ is a MatchState.
                  1. Return _m1_(_y_, _c_).
                1. Return _m2_(_x_, _d_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileassertion" type="sdo" oldids="sec-assertion">
        <h1>
          Runtime Semantics: CompileAssertion (
            _rer_: a RegExp Record,
          ): a Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compileassertion-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>Assertion :: `^`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. If _e_ = 0, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_ - 1] is matched by |LineTerminator|, then
              1. Return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-note>
          <p>Even when the `y` flag is used with a pattern, `^` always matches only at the beginning of _Input_, or (if _rer_.[[Multiline]] is *true*) at the beginning of a line.</p>
        </emu-note>
        <emu-grammar>Assertion :: `$`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _InputLength_ be the number of elements in _Input_.
            1. If _e_ = _InputLength_, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_] is matched by |LineTerminator|, then
              1. Return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-grammar>Assertion :: `\b`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).
            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).
            1. If _a_ is *true* and _b_ is *false*, or if _a_ is *false* and _b_ is *true*, return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-grammar>Assertion :: `\B`</emu-grammar>
        <emu-alg>
          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _Input_ be _x_.[[Input]].
            1. Let _e_ be _x_.[[EndIndex]].
            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).
            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).
            1. If _a_ is *true* and _b_ is *true*, or if _a_ is *false* and _b_ is *false*, return _c_(_x_).
            1. Return ~failure~.
        </emu-alg>
        <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is ~failure~, return ~failure~.
            1. Assert: _r_ is a MatchState.
            1. Let _cap_ be _r_.[[Captures]].
            1. Let _Input_ be _x_.[[Input]].
            1. Let _xe_ be _x_.[[EndIndex]].
            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.
            1. Return _c_(_z_).
        </emu-alg>
        <emu-note>
          <p>The form `(?=` |Disjunction| `)` specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside |Disjunction| must match at the current position, but the current position is not advanced before matching the sequel. If |Disjunction| can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a `(?=` form (this unusual behaviour is inherited from Perl). This only matters when the |Disjunction| contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.</p>
          <p>For example,</p>
          <pre><code class="javascript">/(?=(a+))/.exec("baaabac")</code></pre>
          <p>matches the empty String immediately after the first `b` and therefore returns the array:</p>
          <pre><code class="javascript">["", "aaa"]</code></pre>
          <p>To illustrate the lack of backtracking into the lookahead, consider:</p>
          <pre><code class="javascript">/(?=(a+))a*b\1/.exec("baaabac")</code></pre>
          <p>This expression returns</p>
          <pre><code class="javascript">["aba", "a"]</code></pre>
          <p>and not:</p>
          <pre><code class="javascript">["aaaba", "a"]</code></pre>
        </emu-note>
        <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is not ~failure~, return ~failure~.
            1. Return _c_(_x_).
        </emu-alg>
        <emu-note>
          <p>The form `(?!` |Disjunction| `)` specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside |Disjunction| must fail to match at the current position. The current position is not advanced before matching the sequel. |Disjunction| can contain capturing parentheses, but backreferences to them only make sense from within |Disjunction| itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return *undefined* because the negative lookahead must fail for the pattern to succeed. For example,</p>
          <pre><code class="javascript">/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")</code></pre>
          <p>looks for an `a` not immediately followed by some positive number n of `a`'s, a `b`, another n `a`'s (specified by the first `\\2`) and a `c`. The second `\\2` is outside the negative lookahead, so it matches against *undefined* and therefore always succeeds. The whole expression returns the array:</p>
          <pre><code class="javascript">["baaabaac", "ba", undefined, "abaac"]</code></pre>
        </emu-note>
        <emu-grammar>Assertion :: `(?&lt;=` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is ~failure~, return ~failure~.
            1. Assert: _r_ is a MatchState.
            1. Let _cap_ be _r_.[[Captures]].
            1. Let _Input_ be _x_.[[Input]].
            1. Let _xe_ be _x_.[[EndIndex]].
            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.
            1. Return _c_(_z_).
        </emu-alg>
        <emu-grammar>Assertion :: `(?&lt;!` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.
          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Return _y_.
            1. Let _r_ be _m_(_x_, _d_).
            1. If _r_ is not ~failure~, return ~failure~.
            1. Return _c_(_x_).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-iswordchar-abstract-operation" type="abstract operation">
          <h1>
            IsWordChar (
              _rer_: a RegExp Record,
              _Input_: a List of characters,
              _e_: an integer,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _InputLength_ be the number of elements in _Input_.
            1. If _e_ = -1 or _e_ = _InputLength_, return *false*.
            1. Let _c_ be the character _Input_[_e_].
            1. If WordCharacters(_rer_) contains _c_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilequantifier" type="sdo" oldids="sec-quantifier">
        <h1>Runtime Semantics: CompileQuantifier ( ): a Record with fields [[Min]] (a non-negative integer), [[Max]] (a non-negative integer or +&infin;), and [[Greedy]] (a Boolean)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>Quantifier :: QuantifierPrefix</emu-grammar>
        <emu-alg>
          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.
          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* }.
        </emu-alg>
        <emu-grammar>Quantifier :: QuantifierPrefix `?`</emu-grammar>
        <emu-alg>
          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.
          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compilequantifierprefix" type="sdo">
        <h1>Runtime Semantics: CompileQuantifierPrefix ( ): a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +&infin;)</h1>
        <dl class="header">
        </dl>
        <emu-grammar>QuantifierPrefix :: `*`</emu-grammar>
        <emu-alg>
          1. Return the Record { [[Min]]: 0, [[Max]]: +∞ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `+`</emu-grammar>
        <emu-alg>
          1. Return the Record { [[Min]]: 1, [[Max]]: +∞ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `?`</emu-grammar>
        <emu-alg>
          1. Return the Record { [[Min]]: 0, [[Max]]: 1 }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. Let _i_ be the MV of |DecimalDigits| (see <emu-xref href="#sec-literals-numeric-literals"></emu-xref>).
          1. Return the Record { [[Min]]: _i_, [[Max]]: _i_ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,}`</emu-grammar>
        <emu-alg>
          1. Let _i_ be the MV of |DecimalDigits|.
          1. Return the Record { [[Min]]: _i_, [[Max]]: +∞ }.
        </emu-alg>
        <emu-grammar>QuantifierPrefix :: `{` DecimalDigits `,` DecimalDigits `}`</emu-grammar>
        <emu-alg>
          1. Let _i_ be the MV of the first |DecimalDigits|.
          1. Let _j_ be the MV of the second |DecimalDigits|.
          1. Return the Record { [[Min]]: _i_, [[Max]]: _j_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compileatom" type="sdo" oldids="sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape">
        <h1>
          Runtime Semantics: CompileAtom (
            _rer_: a RegExp Record,
            _direction_: ~forward~ or ~backward~,
          ): a Matcher
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compileatom-annexb"></emu-xref>.</p>
        </emu-note>

        <!-- Atom -->
        <emu-grammar>Atom :: PatternCharacter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the character matched by |PatternCharacter|.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>Atom :: `.`</emu-grammar>
        <emu-alg>
          1. Let _A_ be AllCharacters(_rer_).
          1. If _rer_.[[DotAll]] is not *true*, then
            1. Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>Atom :: CharacterClass</emu-grammar>
        <emu-alg>
          1. Let _cc_ be CompileCharacterClass of |CharacterClass| with argument _rer_.
          1. Let _cs_ be _cc_.[[CharSet]].
          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_).
          1. Assert: _cc_.[[Invert]] is *false*.
          1. Let _lm_ be an empty List of Matchers.
          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do
            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.
            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).
            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do
              1. Let _cs1_ be a one-element CharSet containing _c1_.
              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).
              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).
            1. Append _m2_ to _lm_.
          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.
          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.
          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.
          1. Let _m2_ be the last Matcher in _lm_.
          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do
            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).
          1. Return _m2_.
        </emu-alg>
        <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.
          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).
          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:
            1. Assert: _x_ is a MatchState.
            1. Assert: _c_ is a MatcherContinuation.
            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:
              1. Assert: _y_ is a MatchState.
              1. Let _cap_ be a copy of _y_.[[Captures]].
              1. Let _Input_ be _x_.[[Input]].
              1. Let _xe_ be _x_.[[EndIndex]].
              1. Let _ye_ be _y_.[[EndIndex]].
              1. If _direction_ is ~forward~, then
                1. Assert: _xe_ ≤ _ye_.
                1. Let _r_ be the CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.
              1. Else,
                1. Assert: _direction_ is ~backward~.
                1. Assert: _ye_ ≤ _xe_.
                1. Let _r_ be the CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.
              1. Set _cap_[_parenIndex_ + 1] to _r_.
              1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.
              1. Return _c_(_z_).
            1. Return _m_(_x_, _d_).
        </emu-alg>
        <emu-note>
          <p>Parentheses of the form `(` |Disjunction| `)` serve both to group the components of the |Disjunction| pattern together and to save the result of the match. The result can be used either in a backreference (`\\` followed by a non-zero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching Abstract Closure. To inhibit the capturing behaviour of parentheses, use the form `(?:` |Disjunction| `)` instead.</p>
        </emu-note>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _addModifiers_ be the source text matched by |RegularExpressionModifiers|.
          1. Let _removeModifiers_ be the empty String.
          1. Let _modifiedRer_ be UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), _removeModifiers_).
          1. Return CompileSubpattern of |Disjunction| with arguments _modifiedRer_ and _direction_.
        </emu-alg>
        <emu-grammar>Atom :: `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction `)`</emu-grammar>
        <emu-alg>
          1. Let _addModifiers_ be the source text matched by the first |RegularExpressionModifiers|.
          1. Let _removeModifiers_ be the source text matched by the second |RegularExpressionModifiers|.
          1. Let _modifiedRer_ be UpdateModifiers(_rer_, CodePointsToString(_addModifiers_), CodePointsToString(_removeModifiers_)).
          1. Return CompileSubpattern of |Disjunction| with arguments _modifiedRer_ and _direction_.
        </emu-alg>

        <!-- AtomEscape -->
        <emu-grammar>AtomEscape :: DecimalEscape</emu-grammar>
        <emu-alg>
          1. Let _n_ be the CapturingGroupNumber of |DecimalEscape|.
          1. Assert: _n_ ≤ _rer_.[[CapturingGroupsCount]].
          1. Return BackreferenceMatcher(_rer_, « _n_ », _direction_).
        </emu-alg>
        <emu-note>
          <p>An escape sequence of the form `\\` followed by a non-zero decimal number _n_ matches the result of the _n_<sup>th</sup> set of capturing parentheses (<emu-xref href="#sec-pattern-notation"></emu-xref>). It is an error if the regular expression has fewer than _n_ capturing parentheses. If the regular expression has _n_ or more capturing parentheses but the _n_<sup>th</sup> one is *undefined* because it has not captured anything, then the backreference always succeeds.</p>
        </emu-note>
        <emu-grammar>AtomEscape :: CharacterEscape</emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of |CharacterEscape|.
          1. Let _ch_ be the character whose character value is _cv_.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>AtomEscape :: CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Let _cs_ be CompileToCharSet of |CharacterClassEscape| with argument _rer_.
          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, *false*, _direction_).
          1. Let _lm_ be an empty List of Matchers.
          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do
            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.
            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).
            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do
              1. Let _cs1_ be a one-element CharSet containing _c1_.
              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).
              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).
            1. Append _m2_ to _lm_.
          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.
          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.
          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.
          1. Let _m2_ be the last Matcher in _lm_.
          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do
            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).
          1. Return _m2_.
        </emu-alg>
        <emu-grammar>AtomEscape :: `k` GroupName</emu-grammar>
        <emu-alg>
          1. Let _matchingGroupSpecifiers_ be GroupSpecifiersThatMatch(|GroupName|).
          1. Let _parenIndices_ be a new empty List.
          1. For each |GroupSpecifier| _groupSpecifier_ of _matchingGroupSpecifiers_, do
            1. Let _parenIndex_ be CountLeftCapturingParensBefore(_groupSpecifier_).
            1. Append _parenIndex_ to _parenIndices_.
          1. Return BackreferenceMatcher(_rer_, _parenIndices_, _direction_).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-charactersetmatcher-abstract-operation" type="abstract operation">
          <h1>
            CharacterSetMatcher (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _invert_: a Boolean,
              _direction_: ~forward~ or ~backward~,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *true*, then
              1. Assert: _invert_ is *false*.
              1. Assert: Every CharSetElement of _A_ consists of a single character.
            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _A_, _invert_, and _direction_ and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Let _Input_ be _x_.[[Input]].
              1. Let _e_ be _x_.[[EndIndex]].
              1. If _direction_ is ~forward~, let _f_ be _e_ + 1.
              1. Else, let _f_ be _e_ - 1.
              1. Let _InputLength_ be the number of elements in _Input_.
              1. If _f_ &lt; 0 or _f_ > _InputLength_, return ~failure~.
              1. Let _index_ be min(_e_, _f_).
              1. Let _ch_ be the character _Input_[_index_].
              1. Let _cc_ be Canonicalize(_rer_, _ch_).
              1. If there exists a CharSetElement in _A_ containing exactly one character _a_ such that Canonicalize(_rer_, _a_) is _cc_, let _found_ be *true*; otherwise let _found_ be *false*.
              1. If _invert_ is *false* and _found_ is *false*, return ~failure~.
              1. If _invert_ is *true* and _found_ is *true*, return ~failure~.
              1. Let _cap_ be _x_.[[Captures]].
              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.
              1. Return _c_(_y_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-backreference-matcher" type="abstract operation">
          <h1>
            BackreferenceMatcher (
              _rer_: a RegExp Record,
              _ns_: a List of positive integers,
              _direction_: ~forward~ or ~backward~,
            ): a Matcher
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _ns_, and _direction_ and performs the following steps when called:
              1. Assert: _x_ is a MatchState.
              1. Assert: _c_ is a MatcherContinuation.
              1. Let _Input_ be _x_.[[Input]].
              1. Let _cap_ be _x_.[[Captures]].
              1. Let _r_ be *undefined*.
              1. For each integer _n_ of _ns_, do
                1. If _cap_[_n_] is not *undefined*, then
                  1. Assert: _r_ is *undefined*.
                  1. Set _r_ to _cap_[_n_].
              1. If _r_ is *undefined*, return _c_(_x_).
              1. Let _e_ be _x_.[[EndIndex]].
              1. Let _rs_ be _r_.[[StartIndex]].
              1. Let _re_ be _r_.[[EndIndex]].
              1. Let _len_ be _re_ - _rs_.
              1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.
              1. Else, let _f_ be _e_ - _len_.
              1. Let _InputLength_ be the number of elements in _Input_.
              1. If _f_ &lt; 0 or _f_ > _InputLength_, return ~failure~.
              1. Let _g_ be min(_e_, _f_).
              1. If there exists an integer _i_ in the interval from 0 (inclusive) to _len_ (exclusive) such that Canonicalize(_rer_, _Input_[_rs_ + _i_]) is not Canonicalize(_rer_, _Input_[_g_ + _i_]), return ~failure~.
              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.
              1. Return _c_(_y_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-canonicalize-ch" type="abstract operation">
          <h1>
            Canonicalize (
              _rer_: a RegExp Record,
              _ch_: a character,
            ): a character
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*, then
              1. If the file <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.
              1. Return _ch_.
            1. If _rer_.[[IgnoreCase]] is *false*, return _ch_.
            1. Assert: _ch_ is a UTF-16 code unit.
            1. Let _cp_ be the code point whose numeric value is the numeric value of _ch_.
            1. Let _u_ be toUppercase(« _cp_ »), according to the Unicode Default Case Conversion algorithm.
            1. Let _uStr_ be CodePointsToString(_u_).
            1. If the length of _uStr_ ≠ 1, return _ch_.
            1. Let _cu_ be _uStr_'s single code unit element.
            1. If the numeric value of _ch_ ≥ 128 and the numeric value of _cu_ &lt; 128, return _ch_.
            1. Return _cu_.
          </emu-alg>
          <emu-note>
            <p>In case-insignificant matches when HasEitherUnicodeFlag(_rer_) is *true*, all characters are implicitly case-folded using the simple mapping provided by the Unicode Standard immediately before they are compared. The simple mapping always maps to a single code point, so it does not map, for example, `ß` (U+00DF LATIN SMALL LETTER SHARP S) to `ss` or `SS`. It may however map code points outside the Basic Latin block to code points within it—for example, `ſ` (U+017F LATIN SMALL LETTER LONG S) case-folds to `s` (U+0073 LATIN SMALL LETTER S) and `K` (U+212A KELVIN SIGN) case-folds to `k` (U+006B LATIN SMALL LETTER K). Strings containing those code points are matched by regular expressions such as `/[a-z]/ui`.</p>
            <p>In case-insignificant matches when HasEitherUnicodeFlag(_rer_) is *false*, the mapping is based on Unicode Default Case Conversion algorithm toUppercase rather than toCasefold, which results in some subtle differences. For example, `Ω` (U+2126 OHM SIGN) is mapped by toUppercase to itself but by toCasefold to `ω` (U+03C9 GREEK SMALL LETTER OMEGA) along with `Ω` (U+03A9 GREEK CAPITAL LETTER OMEGA), so *"\u2126"* is matched by `/[ω]/ui` and `/[\u03A9]/ui` but not by `/[ω]/i` or `/[\u03A9]/i`. Also, no code point outside the Basic Latin block is mapped to a code point within it, so strings such as *"\u017F ſ"* and *"\u212A K"* are not matched by `/[a-z]/i`.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-updatemodifiers" type="abstract operation">
          <h1>
            UpdateModifiers (
              _rer_: a RegExp Record,
              _add_: a String,
              _remove_: a String,
            ): a RegExp Record
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _add_ and _remove_ have no elements in common.
            1. Let _ignoreCase_ be _rer_.[[IgnoreCase]].
            1. Let _multiline_ be _rer_.[[Multiline]].
            1. Let _dotAll_ be _rer_.[[DotAll]].
            1. Let _unicode_ be _rer_.[[Unicode]].
            1. Let _unicodeSets_ be _rer_.[[UnicodeSets]].
            1. Let _capturingGroupsCount_ be _rer_.[[CapturingGroupsCount]].
            1. If _remove_ contains *"i"*, set _ignoreCase_ to *false*.
            1. Else if _add_ contains *"i"*, set _ignoreCase_ to *true*.
            1. If _remove_ contains *"m"*, set _multiline_ to *false*.
            1. Else if _add_ contains *"m"*, set _multiline_ to *true*.
            1. If _remove_ contains *"s"*, set _dotAll_ to *false*.
            1. Else if _add_ contains *"s"*, set _dotAll_ to *true*.
            1. Return the RegExp Record { [[IgnoreCase]]: _ignoreCase_, [[Multiline]]: _multiline_, [[DotAll]]: _dotAll_, [[Unicode]]: _unicode_, [[UnicodeSets]]: _unicodeSets_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compilecharacterclass" type="sdo" oldids="sec-characterclass">
        <h1>
          Runtime Semantics: CompileCharacterClass (
            _rer_: a RegExp Record,
          ): a Record with fields [[CharSet]] (a CharSet) and [[Invert]] (a Boolean)
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>CharacterClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *false* }.
        </emu-alg>
        <emu-grammar>CharacterClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. If _rer_.[[UnicodeSets]] is *true*, then
            1. Return the Record { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* }.
          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *true* }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-compiletocharset" type="sdo" oldids="sec-classranges,sec-nonemptyclassranges,sec-nonemptyclassrangesnodash,sec-classatom,sec-classatomnodash,sec-classescape,sec-characterclassescape">
        <h1>
          Runtime Semantics: CompileToCharSet (
            _rer_: a RegExp Record,
          ): a CharSet
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-compiletocharset-annexb"></emu-xref>.</p>
        </emu-note>

        <!-- ClassContents -->
        <emu-grammar>ClassContents :: [empty]</emu-grammar>
        <emu-alg>
          1. Return the empty CharSet.
        </emu-alg>

        <!-- NonemptyClassRanges -->
        <emu-grammar>NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtom| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRange(_A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>

        <!-- NonemptyClassRangesNoDash -->
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRange(_A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>
        <emu-note>
          <p>|ClassContents| can expand into a single |ClassAtom| and/or ranges of two |ClassAtom| separated by dashes. In the latter case the |ClassContents| includes all characters between the first |ClassAtom| and the second |ClassAtom|, inclusive; an error occurs if either |ClassAtom| does not represent a single character (for example, if one is \w) or if the first |ClassAtom|'s character value is strictly greater than the second |ClassAtom|'s character value.</p>
        </emu-note>
        <emu-note>
          <p>Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. Thus, for example, the pattern `/[E-F]/i` matches only the letters `E`, `F`, `e`, and `f`, while the pattern `/[E-f]/i` matches all uppercase and lowercase letters in the Unicode Basic Latin block as well as the symbols `[`, `\\`, `]`, `^`, `_`, and <code>`</code>.</p>
        </emu-note>
        <emu-note>
          <p>A `-` character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of |ClassContents|, the beginning or end limit of a range specification, or immediately follows a range specification.</p>
        </emu-note>

        <!-- ClassAtom -->
        <emu-grammar>ClassAtom :: `-`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).
        </emu-alg>

        <!-- ClassAtomNoDash -->
        <emu-grammar>ClassAtomNoDash :: SourceCharacter but not one of `\` or `]` or `-`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the character matched by |SourceCharacter|.
        </emu-alg>

        <!-- ClassEscape -->
        <emu-grammar>
          ClassEscape ::
            `b`
            `-`
            CharacterEscape
        </emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassEscape|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-note>
          <p>A |ClassAtom| can use any of the escape sequences that are allowed in the rest of the regular expression except for `\\b`, `\\B`, and backreferences. Inside a |CharacterClass|, `\\b` means the backspace character, while `\\B` and backreferences raise errors. Using a backreference inside a |ClassAtom| causes an error.</p>
        </emu-note>

        <!-- CharacterClassEscape -->
        <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>
        <emu-alg>
          1. Return the ten-element CharSet containing the characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, and `9`.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `D`</emu-grammar>
        <emu-alg>
          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `S`</emu-grammar>
        <emu-alg>
          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>
        <emu-alg>
          1. Return MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `W`</emu-grammar>
        <emu-alg>
          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `p{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.
        </emu-alg>
        <emu-grammar>CharacterClassEscape :: `P{` UnicodePropertyValueExpression `}`</emu-grammar>
        <emu-alg>
          1. Let _S_ be CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.
          1. Assert: _S_ contains only single code points.
          1. Return CharacterComplement(_rer_, _S_).
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: UnicodePropertyName `=` UnicodePropertyValue</emu-grammar>
        <emu-alg>
          1. Let _ps_ be the source text matched by |UnicodePropertyName|.
          1. Let _p_ be UnicodeMatchProperty(_rer_, _ps_).
          1. Assert: _p_ is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
          1. Let _vs_ be the source text matched by |UnicodePropertyValue|.
          1. Let _v_ be UnicodeMatchPropertyValue(_p_, _vs_).
          1. Let _A_ be the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>
        <emu-grammar>UnicodePropertyValueExpression :: LoneUnicodePropertyNameOrValue</emu-grammar>
        <emu-alg>
          1. Let _s_ be the source text matched by |LoneUnicodePropertyNameOrValue|.
          1. If UnicodeMatchPropertyValue(`General_Category`, _s_) is a Unicode property value or property value alias for the General_Category (gc) property listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>, then
            1. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value _s_.
          1. Let _p_ be UnicodeMatchProperty(_rer_, _s_).
          1. Assert: _p_ is a binary Unicode property or binary property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href="#table-binary-unicode-properties"></emu-xref>, or a binary Unicode property of strings listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>.
          1. Let _A_ be the CharSet containing all CharSetElements whose character database definition includes the property _p_ with value “True”.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>

        <!-- ClassUnion -->
        <emu-grammar>ClassUnion :: ClassSetRange ClassUnion?</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.
          1. If |ClassUnion| is present, then
            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.
            1. Return the union of CharSets _A_ and _B_.
          1. Return _A_.
        </emu-alg>
        <emu-grammar>ClassUnion :: ClassSetOperand ClassUnion?</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.
          1. If |ClassUnion| is present, then
            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.
            1. Return the union of CharSets _A_ and _B_.
          1. Return _A_.
        </emu-alg>

        <!-- ClassIntersection -->
        <emu-grammar>ClassIntersection :: ClassSetOperand `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.
          1. Return the intersection of CharSets _A_ and _B_.
        </emu-alg>
        <emu-grammar>ClassIntersection :: ClassIntersection `&amp;&amp;` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the |ClassIntersection| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.
          1. Return the intersection of CharSets _A_ and _B_.
        </emu-alg>

        <!-- ClassSubtraction -->
        <emu-grammar>ClassSubtraction :: ClassSetOperand `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.
          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.
        </emu-alg>
        <emu-grammar>ClassSubtraction :: ClassSubtraction `--` ClassSetOperand</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the |ClassSubtraction| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.
          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.
        </emu-alg>

        <!-- ClassSetRange -->
        <emu-grammar>ClassSetRange :: ClassSetCharacter `-` ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassSetCharacter| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassSetCharacter| with argument _rer_.
          1. Return MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)).
        </emu-alg>
        <emu-note>
          <p>The result will often consist of two or more ranges. When UnicodeSets is *true* and IgnoreCase is *true*, then MaybeSimpleCaseFolding(_rer_, [Ā-č]) will include only the odd-numbered code points of that range.</p>
        </emu-note>

        <!-- ClassSetOperand -->
        <emu-grammar>ClassSetOperand :: ClassSetCharacter</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>
        <emu-grammar>ClassSetOperand :: ClassStringDisjunction</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassStringDisjunction| with argument _rer_.
          1. Return MaybeSimpleCaseFolding(_rer_, _A_).
        </emu-alg>
        <emu-grammar>ClassSetOperand :: NestedClass</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |NestedClass| with argument _rer_.
        </emu-alg>

        <!-- NestedClass -->
        <emu-grammar>NestedClass :: `[` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |ClassContents| with argument _rer_.
        </emu-alg>
        <emu-grammar>NestedClass :: `[^` ClassContents `]`</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Return CharacterComplement(_rer_, _A_).
        </emu-alg>
        <emu-grammar>NestedClass :: `\` CharacterClassEscape</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |CharacterClassEscape| with argument _rer_.
        </emu-alg>

        <!-- ClassStringDisjunction -->
        <emu-grammar>ClassStringDisjunction :: `\q{` ClassStringDisjunctionContents `}`</emu-grammar>
        <emu-alg>
          1. Return CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.
        </emu-alg>

        <!-- ClassStringDisjunctionContents -->
        <emu-grammar>ClassStringDisjunctionContents :: ClassString</emu-grammar>
        <emu-alg>
          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.
          1. Return the CharSet containing the one string _s_.
        </emu-alg>
        <emu-grammar>ClassStringDisjunctionContents :: ClassString `|` ClassStringDisjunctionContents</emu-grammar>
        <emu-alg>
          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.
          1. Let _A_ be the CharSet containing the one string _s_.
          1. Let _B_ be CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.
          1. Return the union of CharSets _A_ and _B_.
        </emu-alg>

        <!-- ClassSetCharacter -->
        <emu-grammar>
          ClassSetCharacter ::
            SourceCharacter but not ClassSetSyntaxCharacter
            `\` CharacterEscape
            `\` ClassSetReservedPunctuator
        </emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-grammar>ClassSetCharacter :: `\b`</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the single character U+0008 (BACKSPACE).
        </emu-alg>

        <emu-clause id="sec-runtime-semantics-characterrange-abstract-operation" type="abstract operation">
          <h1>
            CharacterRange (
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _A_ and _B_ each contain exactly one character.
            1. Let _a_ be the one character in CharSet _A_.
            1. Let _b_ be the one character in CharSet _B_.
            1. Let _i_ be the character value of character _a_.
            1. Let _j_ be the character value of character _b_.
            1. Assert: _i_ ≤ _j_.
            1. Return the CharSet containing all characters with a character value in the inclusive interval from _i_ to _j_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-haseitherunicodeflag-abstract-operation" type="abstract operation">
          <h1>
            HasEitherUnicodeFlag (
              _rer_: a RegExp Record,
            ): a Boolean
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _rer_.[[Unicode]] is *true* or _rer_.[[UnicodeSets]] is *true*, then
              1. Return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-wordcharacters" type="abstract operation" oldids="sec-runtime-semantics-wordcharacters-abstract-operation">
          <h1>
            WordCharacters (
              _rer_: a RegExp Record,
            ): a CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Returns a CharSet containing the characters considered "word characters" for the purposes of `\\b`, `\\B`, `\\w`, and `\\W`</dd>
          </dl>
          <emu-alg>
            1. Let _basicWordChars_ be the CharSet containing every character in the ASCII word characters.
            1. Let _extraWordChars_ be the CharSet containing all characters _c_ such that _c_ is not in _basicWordChars_ but Canonicalize(_rer_, _c_) is in _basicWordChars_.
            1. Assert: _extraWordChars_ is empty unless HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*.
            1. Return the union of _basicWordChars_ and _extraWordChars_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allcharacters" type="abstract operation">
          <h1>
            AllCharacters (
              _rer_: a RegExp Record,
            ): a CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Returns the set of “all characters” according to the regular expression flags.</dd>
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *true* and _rer_.[[IgnoreCase]] is *true*, then
              1. [declared="c"] Return the CharSet containing all Unicode code points _c_ that do not have a <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).
            1. Else if HasEitherUnicodeFlag(_rer_) is *true*, then
              1. Return the CharSet containing all code point values.
            1. Else,
              1. Return the CharSet containing all code unit values.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-maybesimplecasefolding" type="abstract operation">
          <h1>
            MaybeSimpleCaseFolding (
              _rer_: a RegExp Record,
              _A_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, it returns _A_. Otherwise, it uses the <a href="https://www.unicode.org/reports/tr44/#Simple_Case_Folding">Simple Case Folding</a> (<emu-eqn id="eqn-scf" aoid="scf">scf(_cp_)</emu-eqn>) definitions in the file <a href="https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"><code>CaseFolding.txt</code></a> of the Unicode Character Database (each of which maps a single code point to another single code point) to map each CharSetElement of _A_ character-by-character into a canonical form and returns the resulting CharSet.</dd>
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, return _A_.
            1. Let _B_ be a new empty CharSet.
            1. For each CharSetElement _s_ of _A_, do
              1. Let _t_ be an empty sequence of characters.
              1. For each single code point _cp_ in _s_, do
                1. Append scf(_cp_) to _t_.
              1. Add _t_ to _B_.
            1. Return _B_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-charactercomplement" type="abstract operation">
          <h1>
            CharacterComplement (
              _rer_: a RegExp Record,
              _S_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _A_ be AllCharacters(_rer_).
            1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _S_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchproperty-p" type="abstract operation">
          <h1>
            UnicodeMatchProperty (
              _rer_: a RegExp Record,
              _p_: ECMAScript source text,
            ): a Unicode property name
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _rer_.[[UnicodeSets]] is *true* and _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>, then
              1. Return the List of Unicode code points _p_.
            1. Assert: _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref> or <emu-xref href="#table-binary-unicode-properties"></emu-xref>.
            1. Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the “Canonical <emu-not-ref>property name</emu-not-ref>” column of the corresponding row.
            1. Return the List of Unicode code points _c_.
          </emu-alg>
          <p>Implementations must support the Unicode property names and aliases listed in <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>, <emu-xref href="#table-binary-unicode-properties"></emu-xref>, and <emu-xref href="#table-binary-unicode-properties-of-strings"></emu-xref>. To ensure interoperability, implementations must not support any other property names or aliases.</p>
          <emu-note>
            <p>For example, `Script_Extensions` (property name) and `scx` (property alias) are valid, but `script_extensions` or `Scx` aren't.</p>
          </emu-note>
          <emu-note>
            <p>The listed properties form a superset of what <a href="https://unicode.org/reports/tr18/#RL1.2">UTS18 RL1.2</a> requires.</p>
          </emu-note>
          <emu-note>
            <p>The spellings of entries in these tables (including casing) match the spellings used in the file <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyAliases.txt"><code>PropertyAliases.txt</code></a> in the Unicode Character Database. The precise spellings in that file are <a href="https://www.unicode.org/policies/stability_policy.html#Alias_Stability">guaranteed to be stable</a>.</p>
          </emu-note>
          <emu-import href="table-nonbinary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties.html"></emu-import>
          <emu-import href="table-binary-unicode-properties-of-strings.html"></emu-import>
        </emu-clause>

        <emu-clause id="sec-runtime-semantics-unicodematchpropertyvalue-p-v" type="abstract operation">
          <h1>
            UnicodeMatchPropertyValue (
              _p_: ECMAScript source text,
              _v_: ECMAScript source text,
            ): a Unicode property value
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: _p_ is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>.
            1. Assert: _v_ is a property value or property value alias for the Unicode property _p_ listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a>.
            1. Let _value_ be the canonical property value of _v_ as given in the “Canonical property value” column of the corresponding row.
            1. Return the List of Unicode code points _value_.
          </emu-alg>
          <p>Implementations must support the Unicode property values and property value aliases listed in <a href="https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt"><code>PropertyValueAliases.txt</code></a> for the properties listed in <emu-xref href="#table-nonbinary-unicode-properties"></emu-xref>. To ensure interoperability, implementations must not support any other property values or property value aliases.</p>
          <emu-note>
            <p>For example, `Xpeo` and `Old_Persian` are valid `Script_Extensions` values, but `xpeo` and `Old Persian` aren't.</p>
          </emu-note>
          <emu-note>
            <p>This algorithm differs from <a href="https://unicode.org/reports/tr44/#Matching_Symbolic">the matching rules for symbolic values listed in UAX44</a>: case, <emu-xref href="#sec-white-space">white space</emu-xref>, U+002D (HYPHEN-MINUS), and U+005F (LOW LINE) are not ignored, and the `Is` prefix is not supported.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-compileclasssetstring" type="sdo">
        <h1>
          Runtime Semantics: CompileClassSetString (
            _rer_: a RegExp Record,
          ): a sequence of characters
        </h1>
        <dl class="header">
        </dl>

        <emu-grammar>ClassString :: [empty]</emu-grammar>
        <emu-alg>
          1. Return an empty sequence of characters.
        </emu-alg>
        <emu-grammar>ClassString :: NonEmptyClassString</emu-grammar>
        <emu-alg>
          1. Return CompileClassSetString of |NonEmptyClassString| with argument _rer_.
        </emu-alg>
        <emu-grammar>NonEmptyClassString :: ClassSetCharacter NonEmptyClassString?</emu-grammar>
        <emu-alg>
          1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.
          1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.
          1. If |NonEmptyClassString| is present, then
            1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.
            1. Return the concatenation of _s1_ and _s2_.
          1. Return _s1_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-creation" oldids="sec-abstract-operations-for-the-regexp-constructor">
      <h1>Abstract Operations for RegExp Creation</h1>

      <emu-clause id="sec-regexpcreate" type="abstract operation">
        <h1>
          RegExpCreate (
            _P_: an ECMAScript language value,
            _F_: a String or *undefined*,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _obj_ be ! RegExpAlloc(%RegExp%).
          1. Return ? RegExpInitialize(_obj_, _P_, _F_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpalloc" type="abstract operation">
        <h1>
          RegExpAlloc (
            _newTarget_: a constructor,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%RegExp.prototype%"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »).
          1. Perform ! DefinePropertyOrThrow(_obj_, *"lastIndex"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexpinitialize" type="abstract operation">
        <h1>
          RegExpInitialize (
            _obj_: an Object,
            _pattern_: an ECMAScript language value,
            _flags_: an ECMAScript language value,
          ): either a normal completion containing an Object or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _pattern_ is *undefined*, let _P_ be the empty String.
          1. Else, let _P_ be ? ToString(_pattern_).
          1. If _flags_ is *undefined*, let _F_ be the empty String.
          1. Else, let _F_ be ? ToString(_flags_).
          1. If _F_ contains any code unit other than *"d"*, *"g"*, *"i"*, *"m"*, *"s"*, *"u"*, *"v"*, or *"y"*, or if _F_ contains any code unit more than once, throw a *SyntaxError* exception.
          1. If _F_ contains *"i"*, let _i_ be *true*; else let _i_ be *false*.
          1. If _F_ contains *"m"*, let _m_ be *true*; else let _m_ be *false*.
          1. If _F_ contains *"s"*, let _s_ be *true*; else let _s_ be *false*.
          1. If _F_ contains *"u"*, let _u_ be *true*; else let _u_ be *false*.
          1. If _F_ contains *"v"*, let _v_ be *true*; else let _v_ be *false*.
          1. If _u_ is *true* or _v_ is *true*, then
            1. Let _patternText_ be StringToCodePoints(_P_).
          1. Else,
            1. Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.
          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).
          1. If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.
          1. Assert: _parseResult_ is a |Pattern| Parse Node.
          1. Set _obj_.[[OriginalSource]] to _P_.
          1. Set _obj_.[[OriginalFlags]] to _F_.
          1. Let _capturingGroupsCount_ be CountLeftCapturingParensWithin(_parseResult_).
          1. Let _rer_ be the RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.
          1. Set _obj_.[[RegExpRecord]] to _rer_.
          1. Set _obj_.[[RegExpMatcher]] to CompilePattern of _parseResult_ with argument _rer_.
          1. Perform ? <emu-meta suppress-effects="user-code">Set(_obj_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-parsepattern" type="abstract operation">
        <h1>
          Static Semantics: ParsePattern (
            _patternText_: a sequence of Unicode code points,
            _u_: a Boolean,
            _v_: a Boolean,
          ): a Parse Node or a non-empty List of *SyntaxError* objects
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This section is amended in <emu-xref href="#sec-parsepattern-annexb"></emu-xref>.</p>
        </emu-note>
        <emu-alg>
          1. If _v_ is *true* and _u_ is *true*, then
            1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.
          1. Else if _v_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else if _u_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else,
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Return _parseResult_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-constructor">
      <h1>The RegExp Constructor</h1>
      <p>The RegExp constructor:</p>
      <ul>
        <li>is <dfn>%RegExp%</dfn>.</li>
        <li>is the initial value of the *"RegExp"* property of the global object.</li>
        <li>creates and initializes a new RegExp object when called as a constructor.</li>
        <li>when called as a function rather than as a constructor, returns either a new RegExp object, or the argument itself if the only argument is a RegExp object.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified RegExp behaviour must include a `super` call to the RegExp constructor to create and initialize subclass instances with the necessary internal slots.</li>
      </ul>

      <emu-clause id="sec-regexp-pattern-flags">
        <h1>RegExp ( _pattern_, _flags_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).
          1. If NewTarget is *undefined*, then
            1. Let _newTarget_ be the active function object.
            1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then
              1. Let _patternConstructor_ be ? Get(_pattern_, *"constructor"*).
              1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.
          1. Else,
            1. Let _newTarget_ be NewTarget.
          1. If _pattern_ is an Object and _pattern_ has a [[RegExpMatcher]] internal slot, then
            1. Let _P_ be _pattern_.[[OriginalSource]].
            1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].
            1. Else, let _F_ be _flags_.
          1. Else if _patternIsRegExp_ is *true*, then
            1. Let _P_ be ? Get(_pattern_, *"source"*).
            1. If _flags_ is *undefined*, then
              1. Let _F_ be ? Get(_pattern_, *"flags"*).
            1. Else,
              1. Let _F_ be _flags_.
          1. Else,
            1. Let _P_ be _pattern_.
            1. Let _F_ be _flags_.
          1. Let _O_ be ? RegExpAlloc(_newTarget_).
          1. Return ? RegExpInitialize(_O_, _P_, _F_).
        </emu-alg>
        <emu-note>
          <p>If pattern is supplied using a |StringLiteral|, the usual escape sequence substitutions are performed before the String is processed by this function. If pattern must contain an escape sequence to be recognized by this function, any U+005C (REVERSE SOLIDUS) code points must be escaped within the |StringLiteral| to prevent them being removed when the contents of the |StringLiteral| are formed.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-constructor">
      <h1>Properties of the RegExp Constructor</h1>
      <p>The RegExp constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-regexp.escape">
        <h1>RegExp.escape ( _S_ )</h1>
        <p>This function returns a copy of _S_ in which characters that are potentially special in a regular expression |Pattern| have been replaced by equivalent escape sequences.</p>
        <p>It performs the following steps when called:</p>

        <emu-alg>
          1. If _S_ is not a String, throw a *TypeError* exception.
          1. Let _escaped_ be the empty String.
          1. Let _cpList_ be StringToCodePoints(_S_).
          1. For each code point _cp_ of _cpList_, do
            1. If _escaped_ is the empty String and _cp_ is matched by either |DecimalDigit| or |AsciiLetter|, then
              1. NOTE: Escaping a leading digit ensures that output corresponds with pattern text which may be used after a `\0` character escape or a |DecimalEscape| such as `\1` and still match _S_ rather than be interpreted as an extension of the preceding escape sequence. Escaping a leading ASCII letter does the same for the context after `\c`.
              1. Let _numericValue_ be the numeric value of _cp_.
              1. Let _hex_ be Number::toString(𝔽(_numericValue_), 16).
              1. Assert: The length of _hex_ is 2.
              1. Set _escaped_ to the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *"x"*, and _hex_.
            1. Else,
              1. Set _escaped_ to the string-concatenation of _escaped_ and EncodeForRegExpEscape(_cp_).
          1. Return _escaped_.
        </emu-alg>

        <emu-note>
          <p>Despite having similar names, EscapeRegExpPattern and `RegExp.escape` do not perform similar actions. The former escapes a pattern for representation as a string, while this function escapes a string for representation inside a pattern.</p>
        </emu-note>

        <emu-clause id="sec-encodeforregexpescape" type="abstract operation">
          <h1>
            EncodeForRegExpEscape (
              _cp_: a code point,
            ): a String
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It returns a String representing a |Pattern| for matching _cp_. If _cp_ is white space or an ASCII punctuator, the returned value is an escape sequence. Otherwise, the returned value is a String representation of _cp_ itself.</dd>
          </dl>

          <emu-alg>
            1. If _cp_ is matched by |SyntaxCharacter| or _cp_ is U+002F (SOLIDUS), then
              1. Return the string-concatenation of 0x005C (REVERSE SOLIDUS) and UTF16EncodeCodePoint(_cp_).
            1. Else if _cp_ is a code point listed in the “Code Point” column of <emu-xref href="#table-controlescape-code-point-values"></emu-xref>, then
              1. Return the string-concatenation of 0x005C (REVERSE SOLIDUS) and the string in the “ControlEscape” column of the row whose “Code Point” column contains _cp_.
            1. Let _otherPunctuators_ be the string-concatenation of *",-=&lt;>#&amp;!%:;@~'`"* and the code unit 0x0022 (QUOTATION MARK).
            1. Let _toEscape_ be StringToCodePoints(_otherPunctuators_).
            1. If _toEscape_ contains _cp_, _cp_ is matched by either |WhiteSpace| or |LineTerminator|, or _cp_ has the same numeric value as a leading surrogate or trailing surrogate, then
              1. Let _cpNum_ be the numeric value of _cp_.
              1. If _cpNum_ ≤ 0xFF, then
                1. Let _hex_ be Number::toString(𝔽(_cpNum_), 16).
                1. Return the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *"x"*, and StringPad(_hex_, 2, *"0"*, ~start~).
              1. Let _escaped_ be the empty String.
              1. Let _codeUnits_ be UTF16EncodeCodePoint(_cp_).
              1. For each code unit _cu_ of _codeUnits_, do
                1. Set _escaped_ to the string-concatenation of _escaped_ and UnicodeEscape(_cu_).
              1. Return _escaped_.
            1. Return UTF16EncodeCodePoint(_cp_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype">
        <h1>RegExp.prototype</h1>
        <p>The initial value of `RegExp.prototype` is the RegExp prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-regexp-@@species" id="sec-get-regexp-%symbol.species%">
        <h1>get RegExp [ %Symbol.species% ]</h1>
        <p>`RegExp[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>RegExp prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-regexp-prototype-object">
      <h1>Properties of the RegExp Prototype Object</h1>
      <p>The <dfn>RegExp prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%RegExp.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a RegExp instance and does not have a [[RegExpMatcher]] internal slot or any of the other internal slots of RegExp instance objects.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <emu-note>
        <p>The RegExp prototype object does not have a *"valueOf"* property of its own; however, it inherits the *"valueOf"* property from the Object prototype object.</p>
      </emu-note>

      <emu-clause id="sec-regexp.prototype.constructor">
        <h1>RegExp.prototype.constructor</h1>
        <p>The initial value of `RegExp.prototype.constructor` is %RegExp%.</p>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.exec">
        <h1>RegExp.prototype.exec ( _string_ )</h1>
        <p>This method searches _string_ for an occurrence of the regular expression pattern and returns an Array containing the results of the match, or *null* if _string_ did not match.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Let _S_ be ? ToString(_string_).
          1. Return ? RegExpBuiltinExec(_R_, _S_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.dotAll">
        <h1>get RegExp.prototype.dotAll</h1>
        <p>`RegExp.prototype.dotAll` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0073 (LATIN SMALL LETTER S).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.flags">
        <h1>get RegExp.prototype.flags</h1>
        <p>`RegExp.prototype.flags` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _codeUnits_ be a new empty List.
          1. Let _hasIndices_ be ToBoolean(? Get(_R_, *"hasIndices"*)).
          1. If _hasIndices_ is *true*, append the code unit 0x0064 (LATIN SMALL LETTER D) to _codeUnits_.
          1. Let _global_ be ToBoolean(? Get(_R_, *"global"*)).
          1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) to _codeUnits_.
          1. Let _ignoreCase_ be ToBoolean(? Get(_R_, *"ignoreCase"*)).
          1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) to _codeUnits_.
          1. Let _multiline_ be ToBoolean(? Get(_R_, *"multiline"*)).
          1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) to _codeUnits_.
          1. Let _dotAll_ be ToBoolean(? Get(_R_, *"dotAll"*)).
          1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) to _codeUnits_.
          1. Let _unicode_ be ToBoolean(? Get(_R_, *"unicode"*)).
          1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) to _codeUnits_.
          1. Let _unicodeSets_ be ToBoolean(? Get(_R_, *"unicodeSets"*)).
          1. If _unicodeSets_ is *true*, append the code unit 0x0076 (LATIN SMALL LETTER V) to _codeUnits_.
          1. Let _sticky_ be ToBoolean(? Get(_R_, *"sticky"*)).
          1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) to _codeUnits_.
          1. Return the String value whose code units are the elements of the List _codeUnits_. If _codeUnits_ has no elements, the empty String is returned.
        </emu-alg>

        <emu-clause id="sec-regexphasflag" type="abstract operation">
          <h1>
            RegExpHasFlag (
              _R_: an ECMAScript language value,
              _codeUnit_: a code unit,
            ): either a normal completion containing either a Boolean or *undefined*, or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _R_ is not an Object, throw a *TypeError* exception.
            1. If _R_ does not have an [[OriginalFlags]] internal slot, then
              1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.
              1. Otherwise, throw a *TypeError* exception.
            1. Let _flags_ be _R_.[[OriginalFlags]].
            1. If _flags_ contains _codeUnit_, return *true*.
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.global">
        <h1>get RegExp.prototype.global</h1>
        <p>`RegExp.prototype.global` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0067 (LATIN SMALL LETTER G).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.hasIndices">
        <h1>get RegExp.prototype.hasIndices</h1>
        <p>`RegExp.prototype.hasIndices` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0064 (LATIN SMALL LETTER D).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.ignorecase">
        <h1>get RegExp.prototype.ignoreCase</h1>
        <p>`RegExp.prototype.ignoreCase` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0069 (LATIN SMALL LETTER I).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@match" id="sec-regexp.prototype-%symbol.match%">
        <h1>RegExp.prototype [ %Symbol.match% ] ( _string_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _flags_ be ? ToString(? Get(_rx_, *"flags"*)).
          1. If _flags_ does not contain *"g"*, then
            1. Return ? RegExpExec(_rx_, _S_).
          1. Else,
            1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*; otherwise let _fullUnicode_ be *false*.
            1. Perform ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
            1. Let _A_ be ! ArrayCreate(0).
            1. Let _n_ be 0.
            1. Repeat,
              1. Let _result_ be ? RegExpExec(_rx_, _S_).
              1. If _result_ is *null*, then
                1. If _n_ = 0, return *null*.
                1. Return _A_.
              1. Else,
                1. Let _matchStr_ be ? ToString(? Get(_result_, *"0"*)).
                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).
                1. If _matchStr_ is the empty String, then
                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))).
                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
                1. Set _n_ to _n_ + 1.
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.match]"*.</p>
        <emu-note>
          <p>The %Symbol.match% property is used by the IsRegExp abstract operation to identify objects that have the basic behaviour of regular expressions. The absence of a %Symbol.match% property or the existence of such a property whose value does not Boolean coerce to *true* indicates that the object is not intended to be used as a regular expression object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-regexp-prototype-matchall" id="sec-regexp-prototype-%symbol.matchall%">
        <h1>RegExp.prototype [ %Symbol.matchAll% ] ( _string_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).
          1. Let _flags_ be ? ToString(? Get(_R_, *"flags"*)).
          1. Let _matcher_ be ? Construct(_C_, « _R_, _flags_ »).
          1. Let _lastIndex_ be ? ToLength(? Get(_R_, *"lastIndex"*)).
          1. Perform ? Set(_matcher_, *"lastIndex"*, _lastIndex_, *true*).
          1. If _flags_ contains *"g"*, let _global_ be *true*.
          1. Else, let _global_ be *false*.
          1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*.
          1. Else, let _fullUnicode_ be *false*.
          1. Return CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_).
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.matchAll]"*.</p>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.multiline">
        <h1>get RegExp.prototype.multiline</h1>
        <p>`RegExp.prototype.multiline` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x006D (LATIN SMALL LETTER M).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@replace" id="sec-regexp.prototype-%symbol.replace%">
        <h1>RegExp.prototype [ %Symbol.replace% ] ( _string_, _replaceValue_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _lengthS_ be the length of _S_.
          1. Let _functionalReplace_ be IsCallable(_replaceValue_).
          1. If _functionalReplace_ is *false*, then
            1. Set _replaceValue_ to ? ToString(_replaceValue_).
          1. Let _flags_ be ? ToString(? Get(_rx_, *"flags"*)).
          1. If _flags_ contains *"g"*, let _global_ be *true*; otherwise let _global_ be *false*.
          1. If _global_ is *true*, then
            1. Perform ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
          1. Let _results_ be a new empty List.
          1. Let _done_ be *false*.
          1. Repeat, while _done_ is *false*,
            1. Let _result_ be ? RegExpExec(_rx_, _S_).
            1. If _result_ is *null*, then
              1. Set _done_ to *true*.
            1. Else,
              1. Append _result_ to _results_.
              1. If _global_ is *false*, then
                1. Set _done_ to *true*.
              1. Else,
                1. Let _matchStr_ be ? ToString(? Get(_result_, *"0"*)).
                1. If _matchStr_ is the empty String, then
                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *"lastIndex"*))).
                  1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*; otherwise let _fullUnicode_ be *false*.
                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
                  1. Perform ? Set(_rx_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
          1. Let _accumulatedResult_ be the empty String.
          1. Let _nextSourcePosition_ be 0.
          1. For each element _result_ of _results_, do
            1. Let _resultLength_ be ? LengthOfArrayLike(_result_).
            1. Let _nCaptures_ be max(_resultLength_ - 1, 0).
            1. Let _matched_ be ? ToString(? Get(_result_, *"0"*)).
            1. Let _matchLength_ be the length of _matched_.
            1. Let _position_ be ? ToIntegerOrInfinity(? Get(_result_, *"index"*)).
            1. Set _position_ to the result of clamping _position_ between 0 and _lengthS_.
            1. Let _captures_ be a new empty List.
            1. Let _n_ be 1.
            1. Repeat, while _n_ ≤ _nCaptures_,
              1. Let _capN_ be ? Get(_result_, ! ToString(𝔽(_n_))).
              1. If _capN_ is not *undefined*, then
                1. Set _capN_ to ? ToString(_capN_).
              1. Append _capN_ to _captures_.
              1. NOTE: When _n_ = 1, the preceding step puts the first element into _captures_ (at index 0). More generally, the _n_<sup>th</sup> capture (the characters captured by the _n_<sup>th</sup> set of capturing parentheses) is at _captures_[_n_ - 1].
              1. Set _n_ to _n_ + 1.
            1. Let _namedCaptures_ be ? Get(_result_, *"groups"*).
            1. If _functionalReplace_ is *true*, then
              1. Let _replacerArgs_ be the list-concatenation of « _matched_ », _captures_, and « 𝔽(_position_), _S_ ».
              1. If _namedCaptures_ is not *undefined*, then
                1. Append _namedCaptures_ to _replacerArgs_.
              1. Let _replacementValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).
              1. Let _replacementString_ be ? ToString(_replacementValue_).
            1. Else,
              1. If _namedCaptures_ is not *undefined*, then
                1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).
              1. Let _replacementString_ be ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).
            1. If _position_ ≥ _nextSourcePosition_, then
              1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.
              1. Set _accumulatedResult_ to the string-concatenation of _accumulatedResult_, the substring of _S_ from _nextSourcePosition_ to _position_, and _replacementString_.
              1. Set _nextSourcePosition_ to _position_ + _matchLength_.
          1. If _nextSourcePosition_ ≥ _lengthS_, return _accumulatedResult_.
          1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ from _nextSourcePosition_.
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.replace]"*.</p>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@search" id="sec-regexp.prototype-%symbol.search%">
        <h1>RegExp.prototype [ %Symbol.search% ] ( _string_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _previousLastIndex_ be ? Get(_rx_, *"lastIndex"*).
          1. If _previousLastIndex_ is not *+0*<sub>𝔽</sub>, then
            1. Perform ? Set(_rx_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*).
          1. Let _result_ be ? RegExpExec(_rx_, _S_).
          1. Let _currentLastIndex_ be ? Get(_rx_, *"lastIndex"*).
          1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then
            1. Perform ? Set(_rx_, *"lastIndex"*, _previousLastIndex_, *true*).
          1. If _result_ is *null*, return *-1*<sub>𝔽</sub>.
          1. Return ? Get(_result_, *"index"*).
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.search]"*.</p>
        <emu-note>
          <p>The *"lastIndex"* and *"global"* properties of this RegExp object are ignored when performing the search. The *"lastIndex"* property is left unchanged.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.source">
        <h1>get RegExp.prototype.source</h1>
        <p>`RegExp.prototype.source` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. If _R_ does not have an [[OriginalSource]] internal slot, then
            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *"(?:)"*.
            1. Otherwise, throw a *TypeError* exception.
          1. Assert: _R_ has an [[OriginalFlags]] internal slot.
          1. Let _src_ be _R_.[[OriginalSource]].
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. Return EscapeRegExpPattern(_src_, _flags_).
        </emu-alg>

        <emu-clause id="sec-escaperegexppattern" type="abstract operation">
          <h1>
            EscapeRegExpPattern (
              _P_: a String,
              _F_: a String,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _F_ contains *"v"*, then
              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, +UnicodeSetsMode]|.
            1. Else if _F_ contains *"u"*, then
              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.
            1. Else,
              1. Let _patternSymbol_ be |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.
            1. Let _S_ be a String in the form of a _patternSymbol_ equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not differ from _P_; however, the Abstract Closure that would result from evaluating _S_ as a _patternSymbol_ must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.
            1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *"/"*, _S_, *"/"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *"/"*, then _S_ could be *"\\/"* or *"\\u002F"*, among other possibilities, but not *"/"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *"(?:)"*.
            1. Return _S_.
          </emu-alg>

          <emu-note>
            <p>Despite having similar names, `RegExp.escape` and EscapeRegExpPattern do not perform similar actions. The former escapes a string for representation inside a pattern, while this function escapes a pattern for representation as a string.</p>
          </emu-note>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-regexp.prototype-@@split" id="sec-regexp.prototype-%symbol.split%">
        <h1>RegExp.prototype [ %Symbol.split% ] ( _string_, _limit_ )</h1>
        <emu-note>
          <p>This method returns an Array into which substrings of the result of converting _string_ to a String have been stored. The substrings are determined by searching from left to right for matches of the *this* value regular expression; these occurrences are not part of any String in the returned array, but serve to divide up the String value.</p>
          <p>The *this* value may be an empty regular expression or a regular expression that can match an empty String. In this case, the regular expression does not match the empty <emu-not-ref>substring</emu-not-ref> at the beginning or end of the input String, nor does it match the empty <emu-not-ref>substring</emu-not-ref> at the end of the previous separator match. (For example, if the regular expression matches the empty String, the String is split up into individual code unit elements; the length of the result array equals the length of the String, and each <emu-not-ref>substring</emu-not-ref> contains one code unit.) Only the first match at a given index of the String is considered, even if backtracking could yield a non-empty <emu-not-ref>substring</emu-not-ref> match at that index. (For example, `/a*?/[Symbol.split]("ab")` evaluates to the array `["a", "b"]`, while `/a*/[Symbol.split]("ab")` evaluates to the array `["","b"]`.)</p>
          <p>If _string_ is (or converts to) the empty String, the result depends on whether the regular expression can match the empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, which is the empty String.</p>
          <p>If the regular expression contains capturing parentheses, then each time _separator_ is matched the results (including any *undefined* results) of the capturing parentheses are spliced into the output array. For example,</p>
          <pre><code class="javascript">/&lt;(\/)?([^&lt;&gt;]+)&gt;/[Symbol.split]("A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;")</code></pre>
          <p>evaluates to the array</p>
          <pre><code class="javascript">["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""]</code></pre>
          <p>If _limit_ is not *undefined*, then the output array is truncated so that it contains no more than _limit_ elements.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _rx_ be the *this* value.
          1. If _rx_ is not an Object, throw a *TypeError* exception.
          1. Let _S_ be ? ToString(_string_).
          1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).
          1. Let _flags_ be ? ToString(? Get(_rx_, *"flags"*)).
          1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _unicodeMatching_ be *true*.
          1. Else, let _unicodeMatching_ be *false*.
          1. If _flags_ contains *"y"*, let _newFlags_ be _flags_.
          1. Else, let _newFlags_ be the string-concatenation of _flags_ and *"y"*.
          1. Let _splitter_ be ? Construct(_C_, « _rx_, _newFlags_ »).
          1. Let _A_ be ! ArrayCreate(0).
          1. Let _lengthA_ be 0.
          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).
          1. If _lim_ = 0, return _A_.
          1. If _S_ is the empty String, then
            1. Let _z_ be ? RegExpExec(_splitter_, _S_).
            1. If _z_ is not *null*, return _A_.
            1. Perform ! CreateDataPropertyOrThrow(_A_, *"0"*, _S_).
            1. Return _A_.
          1. Let _size_ be the length of _S_.
          1. Let _p_ be 0.
          1. Let _q_ be _p_.
          1. Repeat, while _q_ &lt; _size_,
            1. Perform ? Set(_splitter_, *"lastIndex"*, 𝔽(_q_), *true*).
            1. Let _z_ be ? RegExpExec(_splitter_, _S_).
            1. If _z_ is *null*, then
              1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
            1. Else,
              1. Let _e_ be ℝ(? ToLength(? Get(_splitter_, *"lastIndex"*))).
              1. Set _e_ to min(_e_, _size_).
              1. If _e_ = _p_, then
                1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).
              1. Else,
                1. Let _T_ be the substring of _S_ from _p_ to _q_.
                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).
                1. Set _lengthA_ to _lengthA_ + 1.
                1. If _lengthA_ = _lim_, return _A_.
                1. Set _p_ to _e_.
                1. Let _numberOfCaptures_ be ? LengthOfArrayLike(_z_).
                1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).
                1. Let _i_ be 1.
                1. Repeat, while _i_ ≤ _numberOfCaptures_,
                  1. Let _nextCapture_ be ? Get(_z_, ! ToString(𝔽(_i_))).
                  1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).
                  1. Set _i_ to _i_ + 1.
                  1. Set _lengthA_ to _lengthA_ + 1.
                  1. If _lengthA_ = _lim_, return _A_.
                1. Set _q_ to _p_.
          1. Let _T_ be the substring of _S_ from _p_ to _size_.
          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).
          1. Return _A_.
        </emu-alg>
        <p>The value of the *"name"* property of this method is *"[Symbol.split]"*.</p>
        <emu-note>
          <p>This method ignores the value of the *"global"* and *"sticky"* properties of this RegExp object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.sticky">
        <h1>get RegExp.prototype.sticky</h1>
        <p>`RegExp.prototype.sticky` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0079 (LATIN SMALL LETTER Y).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.test">
        <h1>RegExp.prototype.test ( _S_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _string_ be ? ToString(_S_).
          1. Let _match_ be ? RegExpExec(_R_, _string_).
          1. If _match_ is not *null*, return *true*; else return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-regexp.prototype.tostring">
        <h1>RegExp.prototype.toString ( )</h1>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. If _R_ is not an Object, throw a *TypeError* exception.
          1. Let _pattern_ be ? ToString(? Get(_R_, *"source"*)).
          1. Let _flags_ be ? ToString(? Get(_R_, *"flags"*)).
          1. Let _result_ be the string-concatenation of *"/"*, _pattern_, *"/"*, and _flags_.
          1. Return _result_.
        </emu-alg>
        <emu-note>
          <p>The returned String has the form of a |RegularExpressionLiteral| that evaluates to another RegExp object with the same behaviour as this object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicode">
        <h1>get RegExp.prototype.unicode</h1>
        <p>`RegExp.prototype.unicode` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0075 (LATIN SMALL LETTER U).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-regexp.prototype.unicodesets">
        <h1>get RegExp.prototype.unicodeSets</h1>
        <p>`RegExp.prototype.unicodeSets` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _R_ be the *this* value.
          1. Let _cu_ be the code unit 0x0076 (LATIN SMALL LETTER V).
          1. Return ? RegExpHasFlag(_R_, _cu_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-regexp-matching">
      <h1>Abstract Operations for RegExp Matching</h1>

      <emu-clause id="sec-regexpexec" type="abstract operation">
        <h1>
          RegExpExec (
            _R_: an Object,
            _S_: a String,
          ): either a normal completion containing either an Object or *null*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _exec_ be ? Get(_R_, *"exec"*).
          1. If IsCallable(_exec_) is *true*, then
            1. Let _result_ be ? Call(_exec_, _R_, « _S_ »).
            1. If _result_ is not an Object and _result_ is not *null*, throw a *TypeError* exception.
            1. Return _result_.
          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).
          1. Return ? RegExpBuiltinExec(_R_, _S_).
        </emu-alg>
        <emu-note>
          <p>If a callable *"exec"* property is not found this algorithm falls back to attempting to use the built-in RegExp matching algorithm. This provides compatible behaviour for code written for prior editions where most built-in algorithms that use regular expressions did not perform a dynamic property lookup of *"exec"*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-regexpbuiltinexec" type="abstract operation">
        <h1>
          RegExpBuiltinExec (
            _R_: an initialized RegExp instance,
            _S_: a String,
          ): either a normal completion containing either an Array exotic object or *null*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _length_ be the length of _S_.
          1. Let _lastIndex_ be ℝ(? ToLength(! Get(_R_, *"lastIndex"*))).
          1. Let _flags_ be _R_.[[OriginalFlags]].
          1. If _flags_ contains *"g"*, let _global_ be *true*; else let _global_ be *false*.
          1. If _flags_ contains *"y"*, let _sticky_ be *true*; else let _sticky_ be *false*.
          1. If _flags_ contains *"d"*, let _hasIndices_ be *true*; else let _hasIndices_ be *false*.
          1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.
          1. Let _matcher_ be _R_.[[RegExpMatcher]].
          1. If _flags_ contains *"u"* or _flags_ contains *"v"*, let _fullUnicode_ be *true*; else let _fullUnicode_ be *false*.
          1. Let _matchSucceeded_ be *false*.
          1. If _fullUnicode_ is *true*, let _input_ be StringToCodePoints(_S_); otherwise let _input_ be a List whose elements are the code units that are the elements of _S_.
          1. NOTE: Each element of _input_ is considered to be a character.
          1. Repeat, while _matchSucceeded_ is *false*,
            1. If _lastIndex_ > _length_, then
              1. If _global_ is *true* or _sticky_ is *true*, then
                1. Perform ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
              1. Return *null*.
            1. Let _inputIndex_ be the index into _input_ of the character that was obtained from element _lastIndex_ of _S_.
            1. Let _r_ be _matcher_(_input_, _inputIndex_).
            1. If _r_ is ~failure~, then
              1. If _sticky_ is *true*, then
                1. Perform ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, *+0*<sub>𝔽</sub>, *true*)</emu-meta>.
                1. Return *null*.
              1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).
            1. Else,
              1. Assert: _r_ is a MatchState.
              1. Set _matchSucceeded_ to *true*.
          1. Let _e_ be _r_.[[EndIndex]].
          1. If _fullUnicode_ is *true*, set _e_ to GetStringIndex(_S_, _e_).
          1. If _global_ is *true* or _sticky_ is *true*, then
            1. Perform ? <emu-meta suppress-effects="user-code">Set(_R_, *"lastIndex"*, 𝔽(_e_), *true*)</emu-meta>.
          1. Let _n_ be the number of elements in _r_.[[Captures]].
          1. Assert: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]].
          1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
          1. Let _A_ be ! ArrayCreate(_n_ + 1).
          1. Assert: The mathematical value of _A_'s *"length"* property is _n_ + 1.
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"index"*, 𝔽(_lastIndex_)).
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"input"*, _S_).
          1. Let _match_ be the Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }.
          1. Let _indices_ be a new empty List.
          1. Let _groupNames_ be a new empty List.
          1. Append _match_ to _indices_.
          1. Let _matchedSubstr_ be GetMatchString(_S_, _match_).
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"0"*, _matchedSubstr_).
          1. If _R_ contains any |GroupName|, then
            1. Let _groups_ be OrdinaryObjectCreate(*null*).
            1. Let _hasGroups_ be *true*.
          1. Else,
            1. Let _groups_ be *undefined*.
            1. Let _hasGroups_ be *false*.
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_).
          1. Let _matchedGroupNames_ be a new empty List.
          1. For each integer _i_ such that 1 ≤ _i_ ≤ _n_, in ascending order, do
            1. Let _captureI_ be _i_<sup>th</sup> element of _r_.[[Captures]].
            1. If _captureI_ is *undefined*, then
              1. Let _capturedValue_ be *undefined*.
              1. Append *undefined* to _indices_.
            1. Else,
              1. Let _captureStart_ be _captureI_.[[StartIndex]].
              1. Let _captureEnd_ be _captureI_.[[EndIndex]].
              1. If _fullUnicode_ is *true*, then
                1. Set _captureStart_ to GetStringIndex(_S_, _captureStart_).
                1. Set _captureEnd_ to GetStringIndex(_S_, _captureEnd_).
              1. Let _capture_ be the Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }.
              1. Let _capturedValue_ be GetMatchString(_S_, _capture_).
              1. Append _capture_ to _indices_.
            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).
            1. If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then
              1. Let _s_ be the CapturingGroupName of that |GroupName|.
              1. If _matchedGroupNames_ contains _s_, then
                1. Assert: _capturedValue_ is *undefined*.
                1. Append *undefined* to _groupNames_.
              1. Else,
                1. If _capturedValue_ is not *undefined*, append _s_ to _matchedGroupNames_.
                1. NOTE: If there are multiple groups named _s_, _groups_ may already have an _s_ property at this point. However, because _groups_ is an ordinary object whose properties are all writable data properties, the call to CreateDataPropertyOrThrow is nevertheless guaranteed to succeed.
                1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).
                1. Append _s_ to _groupNames_.
            1. Else,
              1. Append *undefined* to _groupNames_.
          1. If _hasIndices_ is *true*, then
            1. Let _indicesArray_ be MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, *"indices"*, _indicesArray_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-advancestringindex" type="abstract operation">
        <h1>
          AdvanceStringIndex (
            _S_: a String,
            _index_: a non-negative integer,
            _unicode_: a Boolean,
          ): an integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _index_ ≤ 2<sup>53</sup> - 1.
          1. If _unicode_ is *false*, return _index_ + 1.
          1. Let _length_ be the length of _S_.
          1. If _index_ + 1 ≥ _length_, return _index_ + 1.
          1. Let _cp_ be CodePointAt(_S_, _index_).
          1. Return _index_ + _cp_.[[CodeUnitCount]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getstringindex" type="abstract operation">
        <h1>
          GetStringIndex (
            _S_: a String,
            _codePointIndex_: a non-negative integer,
          ): a non-negative integer
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It interprets _S_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, and returns the code unit index corresponding to code point index _codePointIndex_ when such an index exists. Otherwise, it returns the length of _S_.</dd>
        </dl>
        <emu-alg>
          1. If _S_ is the empty String, return 0.
          1. Let _len_ be the length of _S_.
          1. Let _codeUnitCount_ be 0.
          1. Let _codePointCount_ be 0.
          1. Repeat, while _codeUnitCount_ &lt; _len_,
            1. If _codePointCount_ = _codePointIndex_, return _codeUnitCount_.
            1. Let _cp_ be CodePointAt(_S_, _codeUnitCount_).
            1. Set _codeUnitCount_ to _codeUnitCount_ + _cp_.[[CodeUnitCount]].
            1. Set _codePointCount_ to _codePointCount_ + 1.
          1. Return _len_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-match-records">
        <h1>Match Records</h1>
        <p>A <dfn variants="Match Records">Match Record</dfn> is a Record value used to encapsulate the start and end indices of a regular expression match or capture.</p>
        <p>Match Records have the fields listed in <emu-xref href="#table-match-record"></emu-xref>.</p>
        <emu-table id="table-match-record" caption="Match Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[StartIndex]]</td>
              <td>a non-negative integer</td>
              <td>The number of code units from the start of a string at which the match begins (inclusive).</td>
            </tr>
            <tr>
              <td>[[EndIndex]]</td>
              <td>an integer ≥ [[StartIndex]]</td>
              <td>The number of code units from the start of a string at which the match ends (exclusive).</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getmatchstring" type="abstract operation">
        <h1>
          GetMatchString (
            _S_: a String,
            _match_: a Match Record,
          ): a String
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.
          1. Return the substring of _S_ from _match_.[[StartIndex]] to _match_.[[EndIndex]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmatchindexpair" type="abstract operation">
        <h1>
          GetMatchIndexPair (
            _S_: a String,
            _match_: a Match Record,
          ): an Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.
          1. Return CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-makematchindicesindexpairarray" type="abstract operation">
        <h1>
          MakeMatchIndicesIndexPairArray (
            _S_: a String,
            _indices_: a List of either Match Records or *undefined*,
            _groupNames_: a List of either Strings or *undefined*,
            _hasGroups_: a Boolean,
          ): an Array
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _n_ be the number of elements in _indices_.
          1. Assert: _n_ &lt; 2<sup>32</sup> - 1.
          1. Assert: _groupNames_ has _n_ - 1 elements.
          1. NOTE: The _groupNames_ List contains elements aligned with the _indices_ List starting at _indices_[1].
          1. Let _A_ be ! ArrayCreate(_n_).
          1. If _hasGroups_ is *true*, then
            1. Let _groups_ be OrdinaryObjectCreate(*null*).
          1. Else,
            1. Let _groups_ be *undefined*.
          1. Perform ! CreateDataPropertyOrThrow(_A_, *"groups"*, _groups_).
          1. For each integer _i_ such that 0 ≤ _i_ &lt; _n_, in ascending order, do
            1. Let _matchIndices_ be _indices_[_i_].
            1. If _matchIndices_ is not *undefined*, then
              1. Let _matchIndexPair_ be GetMatchIndexPair(_S_, _matchIndices_).
            1. Else,
              1. Let _matchIndexPair_ be *undefined*.
            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_).
            1. If _i_ > 0, then
              1. Let _s_ be _groupNames_[_i_ - 1].
              1. If _s_ is not *undefined*, then
                1. Assert: _groups_ is not *undefined*.
                1. NOTE: If there are multiple groups named _s_, _groups_ may already have an _s_ property at this point. However, because _groups_ is an ordinary object whose properties are all writable data properties, the call to CreateDataPropertyOrThrow is nevertheless guaranteed to succeed.
                1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _matchIndexPair_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-regexp-instances">
      <h1>Properties of RegExp Instances</h1>
      <p>RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp instances have internal slots [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], and [[RegExpMatcher]]. The value of the [[RegExpMatcher]] internal slot is an Abstract Closure representation of the |Pattern| of the RegExp object.</p>
      <emu-note>
        <p>Prior to ECMAScript 2015, RegExp instances were specified as having the own data properties *"source"*, *"global"*, *"ignoreCase"*, and *"multiline"*. Those properties are now specified as accessor properties of `RegExp.prototype`.</p>
      </emu-note>
      <p>RegExp instances also have the following property:</p>

      <emu-clause id="sec-lastindex">
        <h1>lastIndex</h1>
        <p>The value of the *"lastIndex"* property specifies the String index at which to start the next match. It is coerced to an integral Number when used (see <emu-xref href="#sec-regexpbuiltinexec"></emu-xref>). This property shall have the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-regexp-string-iterator-objects">
      <h1>RegExp String Iterator Objects</h1>
      <p>A <dfn variants="RegExp String Iterators,RegExp String Iterator object,RegExp String Iterator objects">RegExp String Iterator</dfn> is an object that represents a specific iteration over some specific String instance object, matching against some specific RegExp instance object. There is not a named constructor for RegExp String Iterator objects. Instead, RegExp String Iterator objects are created by calling certain methods of RegExp instance objects.</p>

      <emu-clause id="sec-createregexpstringiterator" type="abstract operation">
        <h1>
          CreateRegExpStringIterator (
            _R_: an Object,
            _S_: a String,
            _global_: a Boolean,
            _fullUnicode_: a Boolean,
          ): an Object
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _iterator_ be OrdinaryObjectCreate(%RegExpStringIteratorPrototype%, « [[IteratingRegExp]], [[IteratedString]], [[Global]], [[Unicode]], [[Done]] »).
          1. Set _iterator_.[[IteratingRegExp]] to _R_.
          1. Set _iterator_.[[IteratedString]] to _S_.
          1. Set _iterator_.[[Global]] to _global_.
          1. Set _iterator_.[[Unicode]] to _fullUnicode_.
          1. Set _iterator_.[[Done]] to *false*.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%regexpstringiteratorprototype%-object">
        <h1>The %RegExpStringIteratorPrototype% Object</h1>
        <p>The <dfn>%RegExpStringIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all RegExp String Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%regexpstringiteratorprototype%.next">
          <h1>%RegExpStringIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If _O_ is not an Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of a RegExp String Iterator Object Instance (see <emu-xref href="#sec-properties-of-regexp-string-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. If _O_.[[Done]] is *true*, then
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. Let _R_ be _O_.[[IteratingRegExp]].
            1. Let _S_ be _O_.[[IteratedString]].
            1. Let _global_ be _O_.[[Global]].
            1. Let _fullUnicode_ be _O_.[[Unicode]].
            1. Let _match_ be ? RegExpExec(_R_, _S_).
            1. If _match_ is *null*, then
              1. Set _O_.[[Done]] to *true*.
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. If _global_ is *false*, then
              1. Set _O_.[[Done]] to *true*.
              1. Return CreateIteratorResultObject(_match_, *false*).
            1. Let _matchStr_ be ? ToString(? Get(_match_, *"0"*)).
            1. If _matchStr_ is the empty String, then
              1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *"lastIndex"*))).
              1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).
              1. Perform ? Set(_R_, *"lastIndex"*, 𝔽(_nextIndex_), *true*).
            1. Return CreateIteratorResultObject(_match_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%regexpstringiteratorprototype%-@@tostringtag" id="sec-%regexpstringiteratorprototype%-%symbol.tostringtag%">
          <h1>%RegExpStringIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"RegExp String Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-regexp-string-iterator-instances">
        <h1>Properties of RegExp String Iterator Instances</h1>
        <p>RegExp String Iterator instances are ordinary objects that inherit properties from the %RegExpStringIteratorPrototype% intrinsic object. RegExp String Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-regexp-string-iterator-instance-slots"></emu-xref>.</p>
        <emu-table id="table-regexp-string-iterator-instance-slots" caption="Internal Slots of RegExp String Iterator Instances">
          <table>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>[[IteratingRegExp]]</td>
              <td>an Object</td>
              <td>The regular expression used for iteration. IsRegExp([[IteratingRegExp]]) is initially *true*.</td>
            </tr>
            <tr>
              <td>[[IteratedString]]</td>
              <td>a String</td>
              <td>The String value being iterated upon.</td>
            </tr>
            <tr>
              <td>[[Global]]</td>
              <td>a Boolean</td>
              <td>Indicates whether the [[IteratingRegExp]] is global or not.</td>
            </tr>
            <tr>
              <td>[[Unicode]]</td>
              <td>a Boolean</td>
              <td>Indicates whether the [[IteratingRegExp]] is in Unicode mode or not.</td>
            </tr>
            <tr>
              <td>[[Done]]</td>
              <td>a Boolean</td>
              <td>Indicates whether the iteration is complete or not.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-indexed-collections">
  <h1>Indexed Collections</h1>

  <emu-clause id="sec-array-objects">
    <h1>Array Objects</h1>
    <p>Arrays are exotic objects that give special treatment to a certain class of property names. See <emu-xref href="#sec-array-exotic-objects"></emu-xref> for a definition of this special treatment.</p>

    <emu-clause id="sec-array-constructor">
      <h1>The Array Constructor</h1>
      <p>The Array constructor:</p>
      <ul>
        <li>is <dfn>%Array%</dfn>.</li>
        <li>is the initial value of the *"Array"* property of the global object.</li>
        <li>creates and initializes a new Array when called as a constructor.</li>
        <li>also creates and initializes a new Array when called as a function rather than as a constructor. Thus the function call `Array(…)` is equivalent to the object creation expression `new Array(…)` with the same arguments.</li>
        <li>is a function whose behaviour differs based upon the number and types of its arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the exotic Array behaviour must include a `super` call to the Array constructor to initialize subclass instances that are Array exotic objects. However, most of the `Array.prototype` methods are generic methods that are not dependent upon their *this* value being an Array exotic object.</li>
      </ul>

      <emu-clause id="sec-array" oldids="sec-array-constructor-array,sec-array-len,sec-array-items">
        <h1>Array ( ..._values_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.
          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, *"%Array.prototype%"*).
          1. Let _numberOfArgs_ be the number of elements in _values_.
          1. If _numberOfArgs_ = 0, then
            1. Return ! ArrayCreate(0, _proto_).
          1. Else if _numberOfArgs_ = 1, then
            1. Let _len_ be _values_[0].
            1. Let _array_ be ! ArrayCreate(0, _proto_).
            1. If _len_ is not a Number, then
              1. Perform ! CreateDataPropertyOrThrow(_array_, *"0"*, _len_).
              1. Let _intLen_ be *1*<sub>𝔽</sub>.
            1. Else,
              1. Let _intLen_ be ! ToUint32(_len_).
              1. If SameValueZero(_intLen_, _len_) is *false*, throw a *RangeError* exception.
            1. Perform ! Set(_array_, *"length"*, _intLen_, *true*).
            1. Return _array_.
          1. Else,
            1. Assert: _numberOfArgs_ ≥ 2.
            1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _numberOfArgs_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _itemK_ be _values_[_k_].
              1. Perform ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_).
              1. Set _k_ to _k_ + 1.
            1. Assert: The mathematical value of _array_'s *"length"* property is _numberOfArgs_.
            1. Return _array_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-constructor">
      <h1>Properties of the Array Constructor</h1>
      <p>The Array constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-array.from">
        <h1>Array.from ( _items_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _mapper_ is *undefined*, then
            1. Let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Let _usingIterator_ be ? GetMethod(_items_, %Symbol.iterator%).
          1. If _usingIterator_ is not *undefined*, then
            1. If IsConstructor(_C_) is *true*, then
              1. Let _A_ be ? Construct(_C_).
            1. Else,
              1. Let _A_ be ! ArrayCreate(0).
            1. Let _iteratorRecord_ be ? GetIteratorFromMethod(_items_, _usingIterator_).
            1. Let _k_ be 0.
            1. Repeat,
              1. If _k_ ≥ 2<sup>53</sup> - 1, then
                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
                1. Return ? IteratorClose(_iteratorRecord_, _error_).
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Perform ? Set(_A_, *"length"*, 𝔽(_k_), *true*).
                1. Return _A_.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be Completion(Call(_mapper_, _thisArg_, « _next_, 𝔽(_k_) »)).
                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_).
              1. Else,
                1. Let _mappedValue_ be _next_.
              1. Let _defineStatus_ be Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)).
              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_).
              1. Set _k_ to _k_ + 1.
          1. NOTE: _items_ is not iterable so assume it is an array-like object.
          1. Let _arrayLike_ be ! ToObject(_items_).
          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_, « 𝔽(_len_) »).
          1. Else,
            1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
            1. Else,
              1. Let _mappedValue_ be _kValue_.
            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. Set _k_ to _k_ + 1.
          1. Perform ? Set(_A_, *"length"*, 𝔽(_len_), *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is an intentionally generic factory method; it does not require that its *this* value be the Array constructor. Therefore it can be transferred to or inherited by any other constructors that may be called with a single numeric argument.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.isarray">
        <h1>Array.isArray ( _arg_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return ? IsArray(_arg_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.of">
        <h1>Array.of ( ..._items_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _len_ be the number of elements in _items_.
          1. Let _lenNumber_ be 𝔽(_len_).
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *true*, then
            1. Let _A_ be ? Construct(_C_, « _lenNumber_ »).
          1. Else,
            1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _items_[_k_].
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).
            1. Set _k_ to _k_ + 1.
          1. Perform ? Set(_A_, *"length"*, _lenNumber_, *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is an intentionally generic factory method; it does not require that its *this* value be the Array constructor. Therefore it can be transferred to or inherited by other constructors that may be called with a single numeric argument.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype">
        <h1>Array.prototype</h1>
        <p>The value of `Array.prototype` is the Array prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-array-@@species" id="sec-get-array-%symbol.species%">
        <h1>get Array [ %Symbol.species% ]</h1>
        <p>`Array[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Array prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-array-prototype-object">
      <h1>Properties of the Array Prototype Object</h1>
      <p>The <dfn>Array prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Array.prototype%</dfn>.</li>
        <li>is an Array exotic object and has the internal methods specified for such objects.</li>
        <li>has a *"length"* property whose initial value is *+0*<sub>𝔽</sub> and whose attributes are { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      </ul>
      <emu-note>
        <p>The Array prototype object is specified to be an Array exotic object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p>
      </emu-note>

      <emu-clause id="sec-array.prototype.at">
        <h1>Array.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ ≥ _len_, return *undefined*.
          1. Return ? Get(_O_, ! ToString(𝔽(_k_))).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.concat">
        <h1>Array.prototype.concat ( ..._items_ )</h1>
        <p>This method returns an array containing the array elements of the object followed by the array elements of each argument.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Let _n_ be 0.
          1. Prepend _O_ to _items_.
          1. For each element _E_ of _items_, do
            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).
            1. If _spreadable_ is *true*, then
              1. Let _len_ be ? LengthOfArrayLike(_E_).
              1. If _n_ + _len_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Let _k_ be 0.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _Pk_ be ! ToString(𝔽(_k_)).
                1. Let _exists_ be ? HasProperty(_E_, _Pk_).
                1. If _exists_ is *true*, then
                  1. Let _subElement_ be ? Get(_E_, _Pk_).
                  1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_).
                1. Set _n_ to _n_ + 1.
                1. Set _k_ to _k_ + 1.
            1. Else,
              1. NOTE: _E_ is added as a single item rather than spread.
              1. If _n_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_).
              1. Set _n_ to _n_ + 1.
          1. [id="step-array-proto-concat-set-length"] Perform ? Set(_A_, *"length"*, 𝔽(_n_), *true*).
          1. Return _A_.
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>The explicit setting of the *"length"* property in step <emu-xref href="#step-array-proto-concat-set-length"></emu-xref> is intended to ensure the length is correct when the final non-empty element of _items_ has trailing holes or when _A_ is not a built-in Array.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-isconcatspreadable" type="abstract operation">
          <h1>
            IsConcatSpreadable (
              _O_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _O_ is not an Object, return *false*.
            1. Let _spreadable_ be ? Get(_O_, %Symbol.isConcatSpreadable%).
            1. If _spreadable_ is not *undefined*, return ToBoolean(_spreadable_).
            1. Return ? IsArray(_O_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.constructor">
        <h1>Array.prototype.constructor</h1>
        <p>The initial value of `Array.prototype.constructor` is %Array%.</p>
      </emu-clause>

      <emu-clause id="sec-array.prototype.copywithin">
        <h1>Array.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <emu-note>
          <p>The _end_ argument is optional. If it is not provided, the length of the *this* value is used.</p>
        </emu-note>
        <emu-note>
          <p>If _target_ is negative, it is treated as <emu-eqn>_length_ + _target_</emu-eqn> where _length_ is the length of the array. If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn>. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
          1. If _relativeTarget_ = -∞, let _to_ be 0.
          1. Else if _relativeTarget_ &lt; 0, let _to_ be max(_len_ + _relativeTarget_, 0).
          1. Else, let _to_ be min(_relativeTarget_, _len_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _from_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _from_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _from_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).
          1. If _from_ &lt; _to_ and _to_ &lt; _from_ + _count_, then
            1. Let _direction_ be -1.
            1. Set _from_ to _from_ + _count_ - 1.
            1. Set _to_ to _to_ + _count_ - 1.
          1. Else,
            1. Let _direction_ be 1.
          1. Repeat, while _count_ > 0,
            1. Let _fromKey_ be ! ToString(𝔽(_from_)).
            1. Let _toKey_ be ! ToString(𝔽(_to_)).
            1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _fromKey_).
              1. Perform ? Set(_O_, _toKey_, _fromValue_, *true*).
            1. Else,
              1. Assert: _fromPresent_ is *false*.
              1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).
            1. Set _from_ to _from_ + _direction_.
            1. Set _to_ to _to_ + _direction_.
            1. Set _count_ to _count_ - 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.entries">
        <h1>Array.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.every">
        <h1>Array.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `every` calls _callback_ once for each element present in the array, in ascending order, until it finds one where _callback_ returns *false*. If such an element is found, `every` immediately returns *false*. Otherwise, `every` returns *true*. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`every` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `every` is set before the first call to _callback_. Elements which are appended to the array after the call to `every` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `every` visits them; elements that are deleted after the call to `every` begins and before being visited are not visited. `every` acts like the "for all" quantifier in mathematics. In particular, for an empty array, it returns *true*.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. If _testResult_ is *false*, return *false*.
            1. Set _k_ to _k_ + 1.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.fill">
        <h1>Array.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <emu-note>
          <p>The _start_ argument is optional. If it is not provided, *+0*<sub>𝔽</sub> is used.</p>
          <p>The _end_ argument is optional. If it is not provided, the length of the *this* value is used.</p>
        </emu-note>
        <emu-note>
          <p>If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the array. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn>.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _k_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _k_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Repeat, while _k_ &lt; _final_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ? Set(_O_, _Pk_, _value_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.filter">
        <h1>Array.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `filter` calls _callback_ once for each element in the array, in ascending order, and constructs a new array of all the values for which _callback_ returns *true*. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`filter` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `filter` is set before the first call to _callback_. Elements which are appended to the array after the call to `filter` begins will not be visited by _callback_. If existing elements of the array are changed their value as passed to _callback_ will be the value at the time `filter` visits them; elements that are deleted after the call to `filter` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Let _k_ be 0.
          1. Let _to_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _selected_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. If _selected_ is *true*, then
                1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_).
                1. Set _to_ to _to_ + 1.
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.find">
        <h1>Array.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in ascending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `find` immediately returns that element value. Otherwise, `find` returns *undefined*.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findindex">
        <h1>Array.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in ascending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `findIndex` immediately returns the index of that element value. Otherwise, `findIndex` returns -1.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlast">
        <h1>Array.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in descending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `findLast` immediately returns that element value. Otherwise, `findLast` returns *undefined*.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.findlastindex">
        <h1>Array.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>This method calls _predicate_ once for each element of the array, in descending index order, until it finds one where _predicate_ returns a value that coerces to *true*. If such an element is found, `findLastIndex` immediately returns the index of that element value. Otherwise, `findLastIndex` returns -1.</p>
          <p>See FindViaPredicate for additional information.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-findviapredicate" type="abstract operation">
          <h1>
            FindViaPredicate (
              _O_: an Object,
              _len_: a non-negative integer,
              _direction_: ~ascending~ or ~descending~,
              _predicate_: an ECMAScript language value,
              _thisArg_: an ECMAScript language value,
            ): either a normal completion containing a Record with fields [[Index]] (an integral Number) and [[Value]] (an ECMAScript language value) or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>
              <p>_O_ should be an array-like object or a TypedArray. This operation calls _predicate_ once for each element of _O_, in either ascending index order or descending index order (as indicated by _direction_), until it finds one where _predicate_ returns a value that coerces to *true*. At that point, this operation returns a Record that gives the index and value of the element found. If no such element is found, this operation returns a Record that specifies *-1*<sub>𝔽</sub> for the index and *undefined* for the value.</p>
              <p>_predicate_ should be a function. When called for an element of the array, it is passed three arguments: the value of the element, the index of the element, and the object being traversed. Its return value will be coerced to a Boolean value.</p>
              <p>_thisArg_ will be used as the *this* value for each invocation of _predicate_.</p>
              <p>This operation does not directly mutate the object on which it is called, but the object may be mutated by the calls to _predicate_.</p>
              <p>The range of elements processed is set before the first call to _predicate_, just before the traversal begins. Elements that are appended to the array after this will not be visited by _predicate_. If existing elements of the array are changed, their value as passed to _predicate_ will be the value at the time that this operation visits them. Elements that are deleted after traversal begins and before being visited are still visited and are either looked up from the prototype or are *undefined*.</p>
            </dd>
          </dl>
          <emu-alg>
            1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.
            1. If _direction_ is ~ascending~, then
              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in ascending order.
            1. Else,
              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in descending order.
            1. For each integer _k_ of _indices_, do
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. NOTE: If _O_ is a TypedArray, the following invocation of Get will return a normal completion.
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
              1. If ToBoolean(_testResult_) is *true*, return the Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ }.
            1. Return the Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* }.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flat">
        <h1>Array.prototype.flat ( [ _depth_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).
          1. Let _depthNum_ be 1.
          1. If _depth_ is not *undefined*, then
            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).
            1. If _depthNum_ &lt; 0, set _depthNum_ to 0.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).
          1. Return _A_.
        </emu-alg>

        <emu-clause id="sec-flattenintoarray" type="abstract operation">
          <h1>
            FlattenIntoArray (
              _target_: an Object,
              _source_: an Object,
              _sourceLen_: a non-negative integer,
              _start_: a non-negative integer,
              _depth_: a non-negative integer or +&infin;,
              optional _mapperFunction_: a function object,
              optional _thisArg_: an ECMAScript language value,
            ): either a normal completion containing a non-negative integer or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.
            1. Let _targetIndex_ be _start_.
            1. Let _sourceIndex_ be *+0*<sub>𝔽</sub>.
            1. Repeat, while ℝ(_sourceIndex_) &lt; _sourceLen_,
              1. Let _P_ be ! ToString(_sourceIndex_).
              1. Let _exists_ be ? HasProperty(_source_, _P_).
              1. If _exists_ is *true*, then
                1. Let _element_ be ? Get(_source_, _P_).
                1. If _mapperFunction_ is present, then
                  1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).
                1. Let _shouldFlatten_ be *false*.
                1. If _depth_ > 0, then
                  1. Set _shouldFlatten_ to ? IsArray(_element_).
                1. If _shouldFlatten_ is *true*, then
                  1. If _depth_ = +∞, let _newDepth_ be +∞.
                  1. Else, let _newDepth_ be _depth_ - 1.
                  1. Let _elementLen_ be ? LengthOfArrayLike(_element_).
                  1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).
                1. Else,
                  1. If _targetIndex_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.
                  1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_).
                  1. Set _targetIndex_ to _targetIndex_ + 1.
              1. Set _sourceIndex_ to _sourceIndex_ + *1*<sub>𝔽</sub>.
            1. Return _targetIndex_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.flatmap">
        <h1>Array.prototype.flatMap ( _mapperFunction_ [ , _thisArg_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).
          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_).
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.foreach">
        <h1>Array.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `forEach` calls _callback_ once for each element present in the array, in ascending order. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `forEach` is set before the first call to _callback_. Elements which are appended to the array after the call to `forEach` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `forEach` visits them; elements that are deleted after the call to `forEach` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.includes">
        <h1>Array.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>This method compares _searchElement_ to the elements of the array, in ascending order, using the SameValueZero algorithm, and if found at any position, returns *true*; otherwise, it returns *false*.</p>
          <p>The optional second argument _fromIndex_ defaults to *+0*<sub>𝔽</sub> (i.e. the whole array is searched). If it is greater than or equal to the length of the array, *false* is returned, i.e. the array will not be searched. If it is less than *-0*<sub>𝔽</sub>, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than or equal to *+0*<sub>𝔽</sub>, the whole array will be searched.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, return *false*.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *false*.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).
            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
        <emu-note>
          <p>This method intentionally differs from the similar `indexOf` method in two ways. First, it uses the SameValueZero algorithm, instead of IsStrictlyEqual, allowing it to detect *NaN* array elements. Second, it does not skip missing array elements, instead treating them as *undefined*.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.indexof">
        <h1>Array.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>This method compares _searchElement_ to the elements of the array, in ascending order, using the IsStrictlyEqual algorithm, and if found at one or more indices, returns the smallest such index; otherwise, it returns *-1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>The optional second argument _fromIndex_ defaults to *+0*<sub>𝔽</sub> (i.e. the whole array is searched). If it is greater than or equal to the length of the array, *-1*<sub>𝔽</sub> is returned, i.e. the array will not be searched. If it is less than *-0*<sub>𝔽</sub>, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than or equal to *+0*<sub>𝔽</sub>, the whole array will be searched.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ? Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ + 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.join">
        <h1>Array.prototype.join ( _separator_ )</h1>
        <p>This method converts the elements of the array to Strings, and then concatenates these Strings, separated by occurrences of the _separator_. If no separator is provided, a single comma is used as the separator.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _separator_ is *undefined*, let _sep_ be *","*.
          1. Else, let _sep_ be ? ToString(_separator_).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.
            1. Let _element_ be ? Get(_O_, ! ToString(𝔽(_k_))).
            1. If _element_ is neither *undefined* nor *null*, then
              1. Let _S_ be ? ToString(_element_).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.keys">
        <h1>Array.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.lastindexof">
        <h1>Array.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <emu-note>
          <p>This method compares _searchElement_ to the elements of the array in descending order using the IsStrictlyEqual algorithm, and if found at one or more indices, returns the largest such index; otherwise, it returns *-1*<sub>𝔽</sub>.</p>
          <p>The optional second argument _fromIndex_ defaults to the array's length minus one (i.e. the whole array is searched). If it is greater than or equal to the length of the array, the whole array will be searched. If it is less than *-0*<sub>𝔽</sub>, it is used as the offset from the end of the array to compute _fromIndex_. If the computed index is less than or equal to *+0*<sub>𝔽</sub>, *-1*<sub>𝔽</sub> is returned.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.
          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.
          1. If _n_ ≥ 0, then
            1. Let _k_ be min(_n_, _len_ - 1).
          1. Else,
            1. Let _k_ be _len_ + _n_.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ? Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ - 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.map">
        <h1>Array.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `map` calls _callback_ once for each element in the array, in ascending order, and constructs a new Array from the results. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`map` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `map` is set before the first call to _callback_. Elements which are appended to the array after the call to `map` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `map` visits them; elements that are deleted after the call to `map` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _mappedValue_ be ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
              1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.pop">
        <h1>Array.prototype.pop ( )</h1>
        <emu-note>
          <p>This method removes the last element of the array and returns it.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, then
            1. Perform ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*).
            1. Return *undefined*.
          1. Else,
            1. Assert: _len_ > 0.
            1. Let _newLen_ be 𝔽(_len_ - 1).
            1. Let _index_ be ! ToString(_newLen_).
            1. Let _element_ be ? Get(_O_, _index_).
            1. Perform ? DeletePropertyOrThrow(_O_, _index_).
            1. Perform ? Set(_O_, *"length"*, _newLen_, *true*).
            1. Return _element_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.push">
        <h1>Array.prototype.push ( ..._items_ )</h1>
        <emu-note>
          <p>This method appends the arguments to the end of the array, in the order in which they appear. It returns the new length of the array.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _argCount_ be the number of elements in _items_.
          1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. For each element _E_ of _items_, do
            1. Perform ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*).
            1. Set _len_ to _len_ + 1.
          1. Perform ? Set(_O_, *"length"*, 𝔽(_len_), *true*).
          1. Return 𝔽(_len_).
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduce">
        <h1>Array.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that takes four arguments. `reduce` calls the callback, as a function, once for each element after the first element present in the array, in ascending order.</p>
          <p>_callback_ is called with four arguments: the _previousValue_ (value from the previous call to _callback_), the _currentValue_ (value of the current element), the _currentIndex_, and the object being traversed. The first time that callback is called, the _previousValue_ and _currentValue_ can be one of two values. If an _initialValue_ was supplied in the call to `reduce`, then _previousValue_ will be _initialValue_ and _currentValue_ will be the first value in the array. If no _initialValue_ was supplied, then _previousValue_ will be the first value in the array and _currentValue_ will be the second. It is a *TypeError* if the array contains no elements and _initialValue_ is not provided.</p>
          <p>`reduce` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `reduce` is set before the first call to _callback_. Elements that are appended to the array after the call to `reduce` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time `reduce` visits them; elements that are deleted after the call to `reduce` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _kPresent_ be *false*.
            1. Repeat, while _kPresent_ is *false* and _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).
              1. If _kPresent_ is *true*, then
                1. Set _accumulator_ to ? Get(_O_, _Pk_).
              1. Set _k_ to _k_ + 1.
            1. If _kPresent_ is *false*, throw a *TypeError* exception.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return _accumulator_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reduceright">
        <h1>Array.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that takes four arguments. `reduceRight` calls the callback, as a function, once for each element after the first element present in the array, in descending order.</p>
          <p>_callback_ is called with four arguments: the _previousValue_ (value from the previous call to _callback_), the _currentValue_ (value of the current element), the _currentIndex_, and the object being traversed. The first time the function is called, the _previousValue_ and _currentValue_ can be one of two values. If an _initialValue_ was supplied in the call to `reduceRight`, then _previousValue_ will be _initialValue_ and _currentValue_ will be the last value in the array. If no _initialValue_ was supplied, then _previousValue_ will be the last value in the array and _currentValue_ will be the second-to-last value. It is a *TypeError* if the array contains no elements and _initialValue_ is not provided.</p>
          <p>`reduceRight` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `reduceRight` is set before the first call to _callback_. Elements that are appended to the array after the call to `reduceRight` begins will not be visited by _callback_. If existing elements of the array are changed by _callback_, their value as passed to _callback_ will be the value at the time `reduceRight` visits them; elements that are deleted after the call to `reduceRight` begins and before being visited are not visited.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _kPresent_ be *false*.
            1. Repeat, while _kPresent_ is *false* and _k_ ≥ 0,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).
              1. If _kPresent_ is *true*, then
                1. Set _accumulator_ to ? Get(_O_, _Pk_).
              1. Set _k_ to _k_ - 1.
            1. If _kPresent_ is *false*, throw a *TypeError* exception.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ - 1.
          1. Return _accumulator_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.reverse">
        <h1>Array.prototype.reverse ( )</h1>
        <emu-note>
          <p>This method rearranges the elements of the array so as to reverse their order. It returns the reversed array.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _middle_ be floor(_len_ / 2).
          1. Let _lower_ be 0.
          1. Repeat, while _lower_ ≠ _middle_,
            1. Let _upper_ be _len_ - _lower_ - 1.
            1. Let _upperP_ be ! ToString(𝔽(_upper_)).
            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).
            1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).
            1. If _lowerExists_ is *true*, then
              1. Let _lowerValue_ be ? Get(_O_, _lowerP_).
            1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).
            1. If _upperExists_ is *true*, then
              1. Let _upperValue_ be ? Get(_O_, _upperP_).
            1. If _lowerExists_ is *true* and _upperExists_ is *true*, then
              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then
              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).
              1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).
            1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then
              1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).
              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Else,
              1. Assert: _lowerExists_ and _upperExists_ are both *false*.
              1. NOTE: No action is required.
            1. Set _lower_ to _lower_ + 1.
          1. Return _O_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.shift">
        <h1>Array.prototype.shift ( )</h1>
        <p>This method removes the first element of the array and returns it.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If _len_ = 0, then
            1. Perform ? Set(_O_, *"length"*, *+0*<sub>𝔽</sub>, *true*).
            1. Return *undefined*.
          1. Let _first_ be ? Get(_O_, *"0"*).
          1. Let _k_ be 1.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _from_ be ! ToString(𝔽(_k_)).
            1. Let _to_ be ! ToString(𝔽(_k_ - 1)).
            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
            1. If _fromPresent_ is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _from_).
              1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
            1. Else,
              1. Assert: _fromPresent_ is *false*.
              1. Perform ? DeletePropertyOrThrow(_O_, _to_).
            1. Set _k_ to _k_ + 1.
          1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).
          1. Perform ? Set(_O_, *"length"*, 𝔽(_len_ - 1), *true*).
          1. Return _first_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.slice">
        <h1>Array.prototype.slice ( _start_, _end_ )</h1>
        <p>This method returns an array containing the elements of the array from element _start_ up to, but not including, element _end_ (or through the end of the array if _end_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_length_ + _start_</emu-eqn> where _length_ is the length of the array. If _end_ is negative, it is treated as <emu-eqn>_length_ + _end_</emu-eqn> where _length_ is the length of the array.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _k_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _k_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _count_ be max(_final_ - _k_, 0).
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).
          1. Let _n_ be 0.
          1. Repeat, while _k_ &lt; _final_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_).
            1. Set _k_ to _k_ + 1.
            1. Set _n_ to _n_ + 1.
          1. [id="step-array-proto-slice-set-length"] Perform ? Set(_A_, *"length"*, 𝔽(_n_), *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The explicit setting of the *"length"* property in step <emu-xref href="#step-array-proto-slice-set-length"></emu-xref> is intended to ensure the length is correct even when _A_ is not a built-in Array.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.some">
        <h1>Array.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments and returns a value that is coercible to a Boolean value. `some` calls _callback_ once for each element present in the array, in ascending order, until it finds one where _callback_ returns *true*. If such an element is found, `some` immediately returns *true*. Otherwise, `some` returns *false*. _callback_ is called only for elements of the array which actually exist; it is not called for missing elements of the array.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the element, the index of the element, and the object being traversed.</p>
          <p>`some` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>The range of elements processed by `some` is set before the first call to _callback_. Elements that are appended to the array after the call to `some` begins will not be visited by _callback_. If existing elements of the array are changed, their value as passed to _callback_ will be the value at the time that `some` visits them; elements that are deleted after the call to `some` begins and before being visited are not visited. `some` acts like the "exists" quantifier in mathematics. In particular, for an empty array, it returns *false*.</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _kValue_ be ? Get(_O_, _Pk_).
              1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
              1. If _testResult_ is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.sort" oldids="sec-sortcompare">
        <h1>Array.prototype.sort ( _comparator_ )</h1>
        <p>This method sorts the elements of this array. If _comparator_ is not *undefined*, it should be a function that accepts two arguments _x_ and _y_ and returns a negative Number if _x_ &lt; _y_, a positive Number if _x_ > _y_, or a zero otherwise.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. [id="step-array-sort-comparefn"] If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be ? ToObject(*this* value).
          1. [id="step-array-sort-len"] Let _len_ be ? LengthOfArrayLike(_obj_).
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareArrayElements(_x_, _y_, _comparator_).
          1. [id="step-array-sortindexedproperties"] Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).
          1. Let _itemCount_ be the number of elements in _sortedList_.
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _itemCount_,
            1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).
            1. Set _j_ to _j_ + 1.
          1. NOTE: The call to SortIndexedProperties in step <emu-xref href="#step-array-sortindexedproperties"></emu-xref> uses ~skip-holes~. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).
            1. Set _j_ to _j_ + 1.
          1. Return _obj_.
        </emu-alg>
        <emu-note>
          <p>Because non-existent property values always compare greater than *undefined* property values, and *undefined* always compares greater than any other value (see CompareArrayElements), *undefined* property values always sort to the end of the result, followed by non-existent property values.</p>
        </emu-note>
        <emu-note>
          <p>Method calls performed by the ToString abstract operations in steps <emu-xref href="#step-sortcompare-tostring-x"></emu-xref> and <emu-xref href="#step-sortcompare-tostring-y"></emu-xref> have the potential to cause _SortCompare_ to not behave as a consistent comparator.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore, it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>

        <emu-clause id="sec-sortindexedproperties" type="abstract operation">
          <h1>
            SortIndexedProperties (
              _obj_: an Object,
              _len_: a non-negative integer,
              _SortCompare_: an Abstract Closure with two parameters,
              _holes_: ~skip-holes~ or ~read-through-holes~,
            ): either a normal completion containing a List of ECMAScript language values or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _items_ be a new empty List.
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. If _holes_ is ~skip-holes~, then
                1. Let _kRead_ be ? HasProperty(_obj_, _Pk_).
              1. Else,
                1. Assert: _holes_ is ~read-through-holes~.
                1. Let _kRead_ be *true*.
              1. If _kRead_ is *true*, then
                1. Let _kValue_ be ? Get(_obj_, _Pk_).
                1. Append _kValue_ to _items_.
              1. Set _k_ to _k_ + 1.
            1. [id="step-array-sort"] Sort _items_ using an implementation-defined sequence of <emu-meta effects="user-code">calls to _SortCompare_</emu-meta>. If any such call returns an abrupt completion, stop before performing any further calls to _SortCompare_ and return that Completion Record.
            1. Return _items_.
          </emu-alg>
          <p>The <dfn id="sort-order">sort order</dfn> is the ordering of _items_ after completion of step <emu-xref href="#step-array-sort"></emu-xref> of the algorithm above. The sort order is implementation-defined if _SortCompare_ is not a consistent comparator for the elements of _items_. When SortIndexedProperties is invoked by <emu-xref href="#sec-array.prototype.sort">Array.prototype.sort</emu-xref> or <emu-xref href="#sec-array.prototype.tosorted">Array.prototype.toSorted</emu-xref>, the sort order is also implementation-defined if _comparator_ is *undefined*, and all applications of ToString, to any specific value passed as an argument to _SortCompare_, do not produce the same result.</p>
          <p>Unless the sort order is specified to be implementation-defined, it must satisfy all of the following conditions:</p>
          <ul>
            <li>
              There must be some mathematical permutation π of the non-negative integers less than _itemCount_, such that for every non-negative integer _j_ less than _itemCount_, the element <emu-eqn>old[_j_]</emu-eqn> is exactly the same as <emu-eqn>new[π(_j_)]</emu-eqn>.
            </li>
            <li>
              Then for all non-negative integers _j_ and _k_, each less than _itemCount_, if <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) &lt; 0</emu-eqn>, then <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>.
            </li>
            <li>
              And for all non-negative integers _j_ and _k_ such that _j_ &lt; _k_ &lt; _itemCount_, if <emu-eqn>ℝ(_SortCompare_(old[_j_], old[_k_])) = 0</emu-eqn>, then <emu-eqn>π(_j_) &lt; π(_k_)</emu-eqn>; i.e., the sort is stable.
            </li>
          </ul>
          <p>Here the notation <emu-eqn>old[_j_]</emu-eqn> is used to refer to <emu-eqn>_items_[_j_]</emu-eqn> before step <emu-xref href="#step-array-sort"></emu-xref> is executed, and the notation <emu-eqn>new[_j_]</emu-eqn> to refer to <emu-eqn>_items_[_j_]</emu-eqn> after step <emu-xref href="#step-array-sort"></emu-xref> has been executed.</p>
          <p>An abstract closure or function _comparator_ is a <dfn id="consistent-comparator">consistent comparator</dfn> for a set of values _S_ if all of the requirements below are met for all values _a_, _b_, and _c_ (possibly the same value) in the set _S_: The notation <emu-eqn>_a_ &lt;<sub>C</sub> _b_</emu-eqn> means <emu-eqn>ℝ(_comparator_(_a_, _b_)) &lt; 0</emu-eqn>; <emu-eqn>_a_ =<sub>C</sub> _b_</emu-eqn> means <emu-eqn>ℝ(_comparator_(_a_, _b_)) = 0</emu-eqn>; and <emu-eqn>_a_ ><sub>C</sub> _b_</emu-eqn> means <emu-eqn>ℝ(_comparator_(_a_, _b_)) > 0</emu-eqn>.</p>
          <ul>
            <li>
              Calling _comparator_(_a_, _b_) always returns the same value _v_ when given a specific pair of values _a_ and _b_ as its two arguments. Furthermore, _v_ is a Number, and _v_ is not *NaN*. Note that this implies that exactly one of _a_ &lt;<sub>C</sub> _b_, _a_ =<sub>C</sub> _b_, and _a_ ><sub>C</sub> _b_ will be true for a given pair of _a_ and _b_.
            </li>
            <li>
              Calling _comparator_(_a_, _b_) does not modify _obj_ or any object on _obj_'s prototype chain.
            </li>
            <li>
              _a_ =<sub>C</sub> _a_ (reflexivity)
            </li>
            <li>
              If _a_ =<sub>C</sub> _b_, then _b_ =<sub>C</sub> _a_ (symmetry)
            </li>
            <li>
              If _a_ =<sub>C</sub> _b_ and _b_ =<sub>C</sub> _c_, then _a_ =<sub>C</sub> _c_ (transitivity of =<sub>C</sub>)
            </li>
            <li>
              If _a_ &lt;<sub>C</sub> _b_ and _b_ &lt;<sub>C</sub> _c_, then _a_ &lt;<sub>C</sub> _c_ (transitivity of &lt;<sub>C</sub>)
            </li>
            <li>
              If _a_ ><sub>C</sub> _b_ and _b_ ><sub>C</sub> _c_, then _a_ ><sub>C</sub> _c_ (transitivity of ><sub>C</sub>)
            </li>
          </ul>
          <emu-note>
            <p>The above conditions are necessary and sufficient to ensure that _comparator_ divides the set _S_ into equivalence classes and that these equivalence classes are totally ordered.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-comparearrayelements" type="abstract operation">
          <h1>
            CompareArrayElements (
              _x_: an ECMAScript language value,
              _y_: an ECMAScript language value,
              _comparator_: a function object or *undefined*,
            ): either a normal completion containing a Number or an abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If _x_ and _y_ are both *undefined*, return *+0*<sub>𝔽</sub>.
            1. If _x_ is *undefined*, return *1*<sub>𝔽</sub>.
            1. If _y_ is *undefined*, return *-1*<sub>𝔽</sub>.
            1. If _comparator_ is not *undefined*, then
              1. Let _v_ be ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »)).
              1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.
              1. Return _v_.
            1. [id="step-sortcompare-tostring-x"] Let _xString_ be ? ToString(_x_).
            1. [id="step-sortcompare-tostring-y"] Let _yString_ be ? ToString(_y_).
            1. Let _xSmaller_ be ! IsLessThan(_xString_, _yString_, *true*).
            1. If _xSmaller_ is *true*, return *-1*<sub>𝔽</sub>.
            1. Let _ySmaller_ be ! IsLessThan(_yString_, _xString_, *true*).
            1. If _ySmaller_ is *true*, return *1*<sub>𝔽</sub>.
            1. Return *+0*<sub>𝔽</sub>.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-array.prototype.splice">
        <h1>Array.prototype.splice ( _start_, _deleteCount_, ..._items_ )</h1>
        <emu-note>
          <p>This method deletes the _deleteCount_ elements of the array starting at integer index _start_ and replaces them with the elements of _items_. It returns an Array containing the deleted elements (if any).</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _actualStart_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _actualStart_ be min(_relativeStart_, _len_).
          1. Let _itemCount_ be the number of elements in _items_.
          1. If _start_ is not present, then
            1. Let _actualDeleteCount_ be 0.
          1. Else if _deleteCount_ is not present, then
            1. Let _actualDeleteCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).
            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.
          1. If _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _actualDeleteCount_,
            1. Let _from_ be ! ToString(𝔽(_actualStart_ + _k_)).
            1. If ? HasProperty(_O_, _from_) is *true*, then
              1. Let _fromValue_ be ? Get(_O_, _from_).
              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_).
            1. Set _k_ to _k_ + 1.
          1. [id="step-array-proto-splice-set-length"] Perform ? Set(_A_, *"length"*, 𝔽(_actualDeleteCount_), *true*).
          1. If _itemCount_ &lt; _actualDeleteCount_, then
            1. Set _k_ to _actualStart_.
            1. Repeat, while _k_ &lt; (_len_ - _actualDeleteCount_),
              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_)).
              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_)).
              1. If ? HasProperty(_O_, _from_) is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Set _k_ to _k_ + 1.
            1. Set _k_ to _len_.
            1. Repeat, while _k_ > (_len_ - _actualDeleteCount_ + _itemCount_),
              1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).
              1. Set _k_ to _k_ - 1.
          1. Else if _itemCount_ > _actualDeleteCount_, then
            1. Set _k_ to (_len_ - _actualDeleteCount_).
            1. Repeat, while _k_ > _actualStart_,
              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).
              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_ - 1)).
              1. If ? HasProperty(_O_, _from_) is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else,
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Set _k_ to _k_ - 1.
          1. Set _k_ to _actualStart_.
          1. For each element _E_ of _items_, do
            1. Perform ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).
            1. Set _k_ to _k_ + 1.
          1. [id="step-array-proto-splice-set-length-2"] Perform ? Set(_O_, *"length"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*).
          1. Return _A_.
        </emu-alg>
        <emu-note>
          <p>The explicit setting of the *"length"* property in steps <emu-xref href="#step-array-proto-splice-set-length"></emu-xref> and <emu-xref href="#step-array-proto-splice-set-length-2"></emu-xref> is intended to ensure the lengths are correct even when the objects are not built-in Arrays.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tolocalestring">
        <h1>Array.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement this method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of this method is used.</p>
        <emu-note>
          <p>The first edition of ECMA-402 did not include a replacement specification for this method.</p>
        </emu-note>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _array_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_array_).
          1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *", "*).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _separator_.
            1. Let _element_ be ? Get(_array_, ! ToString(𝔽(_k_))).
            1. If _element_ is neither *undefined* nor *null*, then
              1. Let _S_ be ? ToString(? Invoke(_element_, *"toLocaleString"*)).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>This method converts the elements of the array to Strings using their `toLocaleString` methods, and then concatenates these Strings, separated by occurrences of an implementation-defined locale-sensitive separator String. This method is analogous to `toString` except that it is intended to yield a locale-sensitive result corresponding with conventions of the host environment's current locale.</p>
        </emu-note>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.toreversed">
        <h1>Array.prototype.toReversed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _fromValue_ be ? Get(_O_, _from_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tosorted">
        <h1>Array.prototype.toSorted ( _comparator_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareArrayElements(_x_, _y_, _comparator_).
          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]).
            1. Set _j_ to _j_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tospliced">
        <h1>Array.prototype.toSpliced ( _start_, _skipCount_, ..._items_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _actualStart_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _actualStart_ be min(_relativeStart_, _len_).
          1. Let _insertCount_ be the number of elements in _items_.
          1. If _start_ is not present, then
            1. Let _actualSkipCount_ be 0.
          1. Else if _skipCount_ is not present, then
            1. Let _actualSkipCount_ be _len_ - _actualStart_.
          1. Else,
            1. Let _sc_ be ? ToIntegerOrInfinity(_skipCount_).
            1. Let _actualSkipCount_ be the result of clamping _sc_ between 0 and _len_ - _actualStart_.
          1. Let _newLen_ be _len_ + _insertCount_ - _actualSkipCount_.
          1. If _newLen_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
          1. Let _A_ be ? ArrayCreate(_newLen_).
          1. Let _i_ be 0.
          1. Let _r_ be _actualStart_ + _actualSkipCount_.
          1. Repeat, while _i_ &lt; _actualStart_,
            1. Let _Pi_ be ! ToString(𝔽(_i_)).
            1. Let _iValue_ be ? Get(_O_, _Pi_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_).
            1. Set _i_ to _i_ + 1.
          1. For each element _E_ of _items_, do
            1. Let _Pi_ be ! ToString(𝔽(_i_)).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_).
            1. Set _i_ to _i_ + 1.
          1. Repeat, while _i_ &lt; _newLen_,
            1. Let _Pi_ be ! ToString(𝔽(_i_)).
            1. Let _from_ be ! ToString(𝔽(_r_)).
            1. Let _fromValue_ be ? Get(_O_, _from_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_).
            1. Set _i_ to _i_ + 1.
            1. Set _r_ to _r_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.tostring">
        <h1>Array.prototype.toString ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _array_ be ? ToObject(*this* value).
          1. Let _func_ be ? Get(_array_, *"join"*).
          1. If IsCallable(_func_) is *false*, set _func_ to the intrinsic function %Object.prototype.toString%.
          1. Return ? Call(_func_, _array_).
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.unshift">
        <h1>Array.prototype.unshift ( ..._items_ )</h1>
        <p>This method prepends the arguments to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _argCount_ be the number of elements in _items_.
          1. If _argCount_ > 0, then
            1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.
            1. Let _k_ be _len_.
            1. Repeat, while _k_ > 0,
              1. Let _from_ be ! ToString(𝔽(_k_ - 1)).
              1. Let _to_ be ! ToString(𝔽(_k_ + _argCount_ - 1)).
              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).
              1. If _fromPresent_ is *true*, then
                1. Let _fromValue_ be ? Get(_O_, _from_).
                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).
              1. Else,
                1. Assert: _fromPresent_ is *false*.
                1. Perform ? DeletePropertyOrThrow(_O_, _to_).
              1. Set _k_ to _k_ - 1.
            1. Let _j_ be *+0*<sub>𝔽</sub>.
            1. For each element _E_ of _items_, do
              1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).
              1. Set _j_ to _j_ + *1*<sub>𝔽</sub>.
          1. Perform ? Set(_O_, *"length"*, 𝔽(_len_ + _argCount_), *true*).
          1. Return 𝔽(_len_ + _argCount_).
        </emu-alg>
        <p>The *"length"* property of this method is *1*<sub>𝔽</sub>.</p>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be an Array. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-array.prototype.values">
        <h1>Array.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Return CreateArrayIterator(_O_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-array.prototype.with">
        <h1>Array.prototype.with ( _index_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _len_ be ? LengthOfArrayLike(_O_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.
          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
          1. If _actualIndex_ ≥ _len_ or _actualIndex_ &lt; 0, throw a *RangeError* exception.
          1. Let _A_ be ? ArrayCreate(_len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. If _k_ = _actualIndex_, let _fromValue_ be _value_.
            1. Else, let _fromValue_ be ? Get(_O_, _Pk_).
            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@iterator" id="sec-array.prototype-%symbol.iterator%">
        <h1>Array.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %Array.prototype.values%, defined in <emu-xref href="#sec-array.prototype.values"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-array.prototype-@@unscopables" id="sec-array.prototype-%symbol.unscopables%">
        <h1>Array.prototype [ %Symbol.unscopables% ]</h1>
        <p>The initial value of the %Symbol.unscopables% data property is an object created by the following steps:</p>
        <emu-alg>
          1. Let _unscopableList_ be OrdinaryObjectCreate(*null*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"at"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"copyWithin"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"entries"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"fill"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"find"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findIndex"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findLast"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"findLastIndex"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flat"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"flatMap"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"includes"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"keys"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toReversed"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toSorted"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"toSpliced"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *"values"*, *true*).
          1. Return _unscopableList_.
        </emu-alg>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <emu-note>
          <p>The own property names of this object are property names that were not included as standard properties of `Array.prototype` prior to the ECMAScript 2015 specification. These names are ignored for `with` statement binding purposes in order to preserve the behaviour of existing code that might use one of these names as a binding in an outer scope that is shadowed by a `with` statement whose binding object is an Array.</p>
          <p>The reason that *"with"* is not included in the _unscopableList_ is because it is already a <emu-xref href="#sec-keywords-and-reserved-words">reserved word</emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-array-instances">
      <h1>Properties of Array Instances</h1>
      <p>Array instances are Array exotic objects and have the internal methods specified for such objects. Array instances inherit properties from the Array prototype object.</p>
      <p>Array instances have a *"length"* property, and a set of enumerable properties with array index names.</p>

      <emu-clause id="sec-properties-of-array-instances-length">
        <h1>length</h1>
        <p>The *"length"* property of an Array instance is a data property whose value is always numerically greater than the name of every configurable own property whose name is an array index.</p>
        <p>The *"length"* property initially has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Reducing the value of the *"length"* property has the side-effect of deleting own array elements whose array index is between the old and new length values. However, non-configurable properties can not be deleted. Attempting to set the *"length"* property of an Array to a value that is numerically less than or equal to the largest numeric own property name of an existing non-configurable <emu-xref href="#array-index">array-indexed</emu-xref> property of the array will result in the length being set to a numeric value that is one greater than that non-configurable numeric own property name. See <emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-array-iterator-objects">
      <h1>Array Iterator Objects</h1>
      <p>An <dfn variants="Array Iterators,Array Iterator object,Array Iterator objects">Array Iterator</dfn> is an object that represents a specific iteration over some specific Array instance object. There is not a named constructor for Array Iterator objects. Instead, Array Iterator objects are created by calling certain methods of Array instance objects.</p>

      <emu-clause id="sec-createarrayiterator" type="abstract operation">
        <h1>
          CreateArrayIterator (
            _array_: an Object,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): an Object
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create iterator objects for Array methods that return such iterators.</dd>
        </dl>
        <emu-alg>
          1. Let _iterator_ be OrdinaryObjectCreate(%ArrayIteratorPrototype%, « [[IteratedArrayLike]], [[ArrayLikeNextIndex]], [[ArrayLikeIterationKind]] »).
          1. Set _iterator_.[[IteratedArrayLike]] to _array_.
          1. Set _iterator_.[[ArrayLikeNextIndex]] to 0.
          1. Set _iterator_.[[ArrayLikeIterationKind]] to _kind_.
          1. Return _iterator_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%arrayiteratorprototype%-object">
        <h1>The %ArrayIteratorPrototype% Object</h1>
        <p>The <dfn>%ArrayIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Array Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%arrayiteratorprototype%.next">
          <h1>%ArrayIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. If _O_ is not an Object, throw a *TypeError* exception.
            1. If _O_ does not have all of the internal slots of an Array Iterator Instance (<emu-xref href="#sec-properties-of-array-iterator-instances"></emu-xref>), throw a *TypeError* exception.
            1. Let _array_ be _O_.[[IteratedArrayLike]].
            1. If _array_ is *undefined*, return CreateIteratorResultObject(*undefined*, *true*).
            1. Let _index_ be _O_.[[ArrayLikeNextIndex]].
            1. Let _kind_ be _O_.[[ArrayLikeIterationKind]].
            1. If _array_ has a [[TypedArrayName]] internal slot, then
              1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).
              1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
              1. Let _len_ be TypedArrayLength(_taRecord_).
            1. Else,
              1. Let _len_ be ? LengthOfArrayLike(_array_).
            1. If _index_ ≥ _len_, then
              1. Set _O_.[[IteratedArrayLike]] to *undefined*.
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. Set _O_.[[ArrayLikeNextIndex]] to _index_ + 1.
            1. Let _indexNumber_ be 𝔽(_index_).
            1. If _kind_ is ~key~, then
              1. Let _result_ be _indexNumber_.
            1. Else,
              1. Let _elementKey_ be ! ToString(_indexNumber_).
              1. Let _elementValue_ be ? Get(_array_, _elementKey_).
              1. If _kind_ is ~value~, then
                1. Let _result_ be _elementValue_.
              1. Else,
                1. Assert: _kind_ is ~key+value~.
                1. Let _result_ be CreateArrayFromList(« _indexNumber_, _elementValue_ »).
            1. Return CreateIteratorResultObject(_result_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%arrayiteratorprototype%-@@tostringtag" id="sec-%arrayiteratorprototype%-%symbol.tostringtag%">
          <h1>%ArrayIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Array Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-array-iterator-instances">
        <h1>Properties of Array Iterator Instances</h1>
        <p>Array Iterator instances are ordinary objects that inherit properties from the %ArrayIteratorPrototype% intrinsic object. Array Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-internal-slots-of-array-iterator-instances"></emu-xref>.</p>
        <emu-table id="table-internal-slots-of-array-iterator-instances" caption="Internal Slots of Array Iterator Instances" oldids="table-48">
          <table>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
            <tr>
              <td>
                [[IteratedArrayLike]]
              </td>
              <td>
                an Object or *undefined*
              </td>
              <td>
                The array-like object that is being iterated.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeNextIndex]]
              </td>
              <td>
                a non-negative integer
              </td>
              <td>
                The integer index of the next element to be examined by this iterator.
              </td>
            </tr>
            <tr>
              <td>
                [[ArrayLikeIterationKind]]
              </td>
              <td>
                ~key+value~, ~key~, or ~value~
              </td>
              <td>
                A value that identifies what is returned for each element of the iteration.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>
    <p>A _TypedArray_ presents an array-like view of an underlying binary data buffer (<emu-xref href="#sec-arraybuffer-objects"></emu-xref>). A <dfn variants="TypedArray element types">TypedArray element type</dfn> is the underlying binary scalar data type that all elements of a _TypedArray_ instance have. There is a distinct _TypedArray_ constructor, listed in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>, for each of the supported element types. Each constructor in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> has a corresponding distinct prototype object.</p>
    <emu-table id="table-the-typedarray-constructors" caption="The TypedArray Constructors" oldids="table-49">
      <table>
        <thead>
          <tr>
            <th>
              Constructor Name and Intrinsic
            </th>
            <th>
              Element Type
            </th>
            <th>
              Element Size
            </th>
            <th>
              Conversion Operation
            </th>
            <th>
              Description
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            Int8Array<br>
            <dfn>%Int8Array%</dfn>
          </td>
          <td>
            ~int8~
          </td>
          <td>
            1
          </td>
          <td>
            ToInt8
          </td>
          <td>
            8-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            Uint8Array<br>
            <dfn>%Uint8Array%</dfn>
          </td>
          <td>
            ~uint8~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8
          </td>
          <td>
            8-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            Uint8ClampedArray<br>
            <dfn>%Uint8ClampedArray%</dfn>
          </td>
          <td>
            ~uint8clamped~
          </td>
          <td>
            1
          </td>
          <td>
            ToUint8Clamp
          </td>
          <td>
            8-bit unsigned integer (clamped conversion)
          </td>
        </tr>
        <tr>
          <td>
            Int16Array<br>
            <dfn>%Int16Array%</dfn>
          </td>
          <td>
            ~int16~
          </td>
          <td>
            2
          </td>
          <td>
            ToInt16
          </td>
          <td>
            16-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            Uint16Array<br>
            <dfn>%Uint16Array%</dfn>
          </td>
          <td>
            ~uint16~
          </td>
          <td>
            2
          </td>
          <td>
            ToUint16
          </td>
          <td>
            16-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            Int32Array<br>
            <dfn>%Int32Array%</dfn>
          </td>
          <td>
            ~int32~
          </td>
          <td>
            4
          </td>
          <td>
            ToInt32
          </td>
          <td>
            32-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            Uint32Array<br>
            <dfn>%Uint32Array%</dfn>
          </td>
          <td>
            ~uint32~
          </td>
          <td>
            4
          </td>
          <td>
            ToUint32
          </td>
          <td>
            32-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            BigInt64Array<br>
            <dfn>%BigInt64Array%</dfn>
          </td>
          <td>
            ~bigint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigInt64
          </td>
          <td>
            64-bit two's complement signed integer
          </td>
        </tr>
        <tr>
          <td>
            BigUint64Array<br>
            <dfn>%BigUint64Array%</dfn>
          </td>
          <td>
            ~biguint64~
          </td>
          <td>
            8
          </td>
          <td>
            ToBigUint64
          </td>
          <td>
            64-bit unsigned integer
          </td>
        </tr>
        <tr>
          <td>
            Float16Array<br>
            <dfn>%Float16Array%</dfn>
          </td>
          <td>
            ~float16~
          </td>
          <td>
            2
          </td>
          <td>
          </td>
          <td>
            16-bit IEEE floating point
          </td>
        </tr>
        <tr>
          <td>
            Float32Array<br>
            <dfn>%Float32Array%</dfn>
          </td>
          <td>
            ~float32~
          </td>
          <td>
            4
          </td>
          <td>
          </td>
          <td>
            32-bit IEEE floating point
          </td>
        </tr>
        <tr>
          <td>
            Float64Array<br>
            <dfn>%Float64Array%</dfn>
          </td>
          <td>
            ~float64~
          </td>
          <td>
            8
          </td>
          <td>
          </td>
          <td>
            64-bit IEEE floating point
          </td>
        </tr>
      </table>
    </emu-table>
    <p>In the definitions below, references to _TypedArray_ should be replaced with the appropriate constructor name from the above table.</p>

    <emu-clause id="sec-%typedarray%-intrinsic-object">
      <h1>The %TypedArray% Intrinsic Object</h1>
      <p>The <dfn>%TypedArray%</dfn> intrinsic object:</p>
      <ul>
        <li>is a constructor function object that all of the _TypedArray_ constructor objects inherit from.</li>
        <li>along with its corresponding prototype object, provides common properties that are inherited by all _TypedArray_ constructors and their instances.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>acts as the abstract superclass of the various _TypedArray_ constructors.</li>
        <li>will throw an error when invoked, because it is an abstract class constructor. The _TypedArray_ constructors do not perform a `super` call to it.</li>
      </ul>

      <emu-clause id="sec-%typedarray%">
        <h1>%TypedArray% ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>The *"length"* property of this function is *+0*<sub>𝔽</sub>.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarray%-intrinsic-object">
      <h1>Properties of the %TypedArray% Intrinsic Object</h1>
      <p>The %TypedArray% intrinsic object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has a *"name"* property whose value is *"TypedArray"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-%typedarray%.from">
        <h1>%TypedArray%.from ( _source_ [ , _mapper_ [ , _thisArg_ ] ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. If _mapper_ is *undefined*, then
            1. Let _mapping_ be *false*.
          1. Else,
            1. If IsCallable(_mapper_) is *false*, throw a *TypeError* exception.
            1. Let _mapping_ be *true*.
          1. Let _usingIterator_ be ? GetMethod(_source_, %Symbol.iterator%).
          1. If _usingIterator_ is not *undefined*, then
            1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)).
            1. Let _len_ be the number of elements in _values_.
            1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _kValue_ be the first element of _values_.
              1. Remove the first element from _values_.
              1. If _mapping_ is *true*, then
                1. Let _mappedValue_ be ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
              1. Else,
                1. Let _mappedValue_ be _kValue_.
              1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).
              1. Set _k_ to _k_ + 1.
            1. Assert: _values_ is now an empty List.
            1. Return _targetObj_.
          1. NOTE: _source_ is not an iterable object, so assume it is already an array-like object.
          1. Let _arrayLike_ be ! ToObject(_source_).
          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
          1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
            1. If _mapping_ is *true*, then
              1. Let _mappedValue_ be ? Call(_mapper_, _thisArg_, « _kValue_, 𝔽(_k_) »).
            1. Else,
              1. Let _mappedValue_ be _kValue_.
            1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _targetObj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.of">
        <h1>%TypedArray%.of ( ..._items_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _len_ be the number of elements in _items_.
          1. Let _C_ be the *this* value.
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. Let _newObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _kValue_ be _items_[_k_].
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ? Set(_newObj_, _Pk_, _kValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _newObj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype">
        <h1>%TypedArray%.prototype</h1>
        <p>The initial value of %TypedArray%`.prototype` is the %TypedArray% prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%-@@species" id="sec-get-%typedarray%-%symbol.species%">
        <h1>get %TypedArray% [ %Symbol.species% ]</h1>
        <p>%TypedArray%`[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>%TypedArray.prototype% methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-%typedarrayprototype%-object">
      <h1>Properties of the %TypedArray% Prototype Object</h1>
      <p>The <dfn>%TypedArray% prototype object</dfn>:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is <dfn>%TypedArray.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to _TypedArray_ instance objects.</li>
      </ul>

      <emu-clause id="sec-%typedarray%.prototype.at">
        <h1>%TypedArray%.prototype.at ( _index_ )</h1>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, then
            1. Let _k_ be _relativeIndex_.
          1. Else,
            1. Let _k_ be _len_ + _relativeIndex_.
          1. If _k_ &lt; 0 or _k_ ≥ _len_, return *undefined*.
          1. Return ! Get(_O_, ! ToString(𝔽(_k_))).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.buffer">
        <h1>get %TypedArray%.prototype.buffer</h1>
        <p>%TypedArray%`.prototype.buffer` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.bytelength">
        <h1>get %TypedArray%.prototype.byteLength</h1>
        <p>%TypedArray%`.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. Let _size_ be TypedArrayByteLength(_taRecord_).
          1. Return 𝔽(_size_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.byteoffset">
        <h1>get %TypedArray%.prototype.byteOffset</h1>
        <p>%TypedArray%`.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Return 𝔽(_offset_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.constructor">
        <h1>%TypedArray%.prototype.constructor</h1>
        <p>The initial value of %TypedArray%`.prototype.constructor` is %TypedArray%.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.copywithin">
        <h1>%TypedArray%.prototype.copyWithin ( _target_, _start_ [ , _end_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.copyWithin` as defined in <emu-xref href="#sec-array.prototype.copywithin"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).
          1. If _relativeTarget_ = -∞, let _targetIndex_ be 0.
          1. Else if _relativeTarget_ &lt; 0, let _targetIndex_ be max(_len_ + _relativeTarget_, 0).
          1. Else, let _targetIndex_ be min(_relativeTarget_, _len_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).
          1. Let _count_ be min(_endIndex_ - _startIndex_, _len_ - _targetIndex_).
          1. If _count_ > 0, then
            1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.
            1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
            1. Set _len_ to TypedArrayLength(_taRecord_).
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _byteOffset_ be _O_.[[ByteOffset]].
            1. Let _bufferByteLimit_ be (_len_ × _elementSize_) + _byteOffset_.
            1. Let _toByteIndex_ be (_targetIndex_ × _elementSize_) + _byteOffset_.
            1. Let _fromByteIndex_ be (_startIndex_ × _elementSize_) + _byteOffset_.
            1. Let _countBytes_ be _count_ × _elementSize_.
            1. If _fromByteIndex_ &lt; _toByteIndex_ and _toByteIndex_ &lt; _fromByteIndex_ + _countBytes_, then
              1. Let _direction_ be -1.
              1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.
              1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.
            1. Else,
              1. Let _direction_ be 1.
            1. Repeat, while _countBytes_ > 0,
              1. If _fromByteIndex_ &lt; _bufferByteLimit_ and _toByteIndex_ &lt; _bufferByteLimit_, then
                1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~).
                1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.
                1. Set _toByteIndex_ to _toByteIndex_ + _direction_.
                1. Set _countBytes_ to _countBytes_ - 1.
              1. Else,
                1. Set _countBytes_ to 0.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.entries">
        <h1>%TypedArray%.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Return CreateArrayIterator(_O_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.every">
        <h1>%TypedArray%.prototype.every ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.every` as defined in <emu-xref href="#sec-array.prototype.every"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. If _testResult_ is *false*, return *false*.
            1. Set _k_ to _k_ + 1.
          1. Return *true*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.fill` as defined in <emu-xref href="#sec-array.prototype.fill"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _O_.[[ContentType]] is ~bigint~, set _value_ to ? ToBigInt(_value_).
          1. Otherwise, set _value_ to ? ToNumber(_value_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).
          1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
          1. Set _len_ to TypedArrayLength(_taRecord_).
          1. Set _endIndex_ to min(_endIndex_, _len_).
          1. Let _k_ be _startIndex_.
          1. Repeat, while _k_ &lt; _endIndex_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Perform ! Set(_O_, _Pk_, _value_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.filter">
        <h1>%TypedArray%.prototype.filter ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.filter` as defined in <emu-xref href="#sec-array.prototype.filter"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _kept_ be a new empty List.
          1. Let _captured_ be 0.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _selected_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. If _selected_ is *true*, then
              1. Append _kValue_ to _kept_.
              1. Set _captured_ to _captured_ + 1.
            1. Set _k_ to _k_ + 1.
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »).
          1. Let _n_ be 0.
          1. For each element _e_ of _kept_, do
            1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*).
            1. Set _n_ to _n_ + 1.
          1. Return _A_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.find">
        <h1>%TypedArray%.prototype.find ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.find` as defined in <emu-xref href="#sec-array.prototype.find"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findindex">
        <h1>%TypedArray%.prototype.findIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findIndex` as defined in <emu-xref href="#sec-array.prototype.findindex"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlast">
        <h1>%TypedArray%.prototype.findLast ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findLast` as defined in <emu-xref href="#sec-array.prototype.findlast"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Value]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.findlastindex">
        <h1>%TypedArray%.prototype.findLastIndex ( _predicate_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.findLastIndex` as defined in <emu-xref href="#sec-array.prototype.findlastindex"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).
          1. Return _findRec_.[[Index]].
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.foreach">
        <h1>%TypedArray%.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.forEach` as defined in <emu-xref href="#sec-array.prototype.foreach"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Perform ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return *undefined*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.includes">
        <h1>%TypedArray%.prototype.includes ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.includes` as defined in <emu-xref href="#sec-array.prototype.includes"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _len_ = 0, return *false*.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *false*.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).
            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.indexof">
        <h1>%TypedArray%.prototype.indexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.indexOf` as defined in <emu-xref href="#sec-array.prototype.indexof"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).
          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.
          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.
          1. Else if _n_ = -∞, set _n_ to 0.
          1. If _n_ ≥ 0, then
            1. Let _k_ be _n_.
          1. Else,
            1. Let _k_ be _len_ + _n_.
            1. If _k_ &lt; 0, set _k_ to 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ! HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ! Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ + 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.join">
        <h1>%TypedArray%.prototype.join ( _separator_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.join` as defined in <emu-xref href="#sec-array.prototype.join"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _separator_ is *undefined*, let _sep_ be *","*.
          1. Else, let _sep_ be ? ToString(_separator_).
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.
            1. Let _element_ be ! Get(_O_, ! ToString(𝔽(_k_))).
            1. If _element_ is not *undefined*, then
              1. Let _S_ be ! ToString(_element_).
              1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.keys">
        <h1>%TypedArray%.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Return CreateArrayIterator(_O_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.lastindexof">
        <h1>%TypedArray%.prototype.lastIndexOf ( _searchElement_ [ , _fromIndex_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.lastIndexOf` as defined in <emu-xref href="#sec-array.prototype.lastindexof"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.
          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.
          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.
          1. If _n_ ≥ 0, then
            1. Let _k_ be min(_n_, _len_ - 1).
          1. Else,
            1. Let _k_ be _len_ + _n_.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kPresent_ be ! HasProperty(_O_, _Pk_).
            1. If _kPresent_ is *true*, then
              1. Let _elementK_ be ! Get(_O_, _Pk_).
              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).
            1. Set _k_ to _k_ - 1.
          1. Return *-1*<sub>𝔽</sub>.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-get-%typedarray%.prototype.length">
        <h1>get %TypedArray%.prototype.length</h1>
        <p>%TypedArray%`.prototype.length` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.
          1. Let _length_ be TypedArrayLength(_taRecord_).
          1. Return 𝔽(_length_).
        </emu-alg>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.map">
        <h1>%TypedArray%.prototype.map ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.map` as defined in <emu-xref href="#sec-array.prototype.map"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _mappedValue_ be ? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).
            1. Perform ? Set(_A_, _Pk_, _mappedValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduce">
        <h1>%TypedArray%.prototype.reduce ( _callback_ [ , _initialValue_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reduce` as defined in <emu-xref href="#sec-array.prototype.reduce"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Set _accumulator_ to ! Get(_O_, _Pk_).
            1. Set _k_ to _k_ + 1.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ + 1.
          1. Return _accumulator_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reduceright">
        <h1>%TypedArray%.prototype.reduceRight ( _callback_ [ , _initialValue_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reduceRight` as defined in <emu-xref href="#sec-array.prototype.reduceright"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.
          1. Let _k_ be _len_ - 1.
          1. Let _accumulator_ be *undefined*.
          1. If _initialValue_ is present, then
            1. Set _accumulator_ to _initialValue_.
          1. Else,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Set _accumulator_ to ! Get(_O_, _Pk_).
            1. Set _k_ to _k_ - 1.
          1. Repeat, while _k_ ≥ 0,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Set _accumulator_ to ? Call(_callback_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).
            1. Set _k_ to _k_ - 1.
          1. Return _accumulator_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.reverse">
        <h1>%TypedArray%.prototype.reverse ( )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.reverse` as defined in <emu-xref href="#sec-array.prototype.reverse"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _middle_ be floor(_len_ / 2).
          1. Let _lower_ be 0.
          1. Repeat, while _lower_ ≠ _middle_,
            1. Let _upper_ be _len_ - _lower_ - 1.
            1. Let _upperP_ be ! ToString(𝔽(_upper_)).
            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).
            1. Let _lowerValue_ be ! Get(_O_, _lowerP_).
            1. Let _upperValue_ be ! Get(_O_, _upperP_).
            1. Perform ! Set(_O_, _lowerP_, _upperValue_, *true*).
            1. Perform ! Set(_O_, _upperP_, _lowerValue_, *true*).
            1. Set _lower_ to _lower_ + 1.
          1. Return _O_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.set" oldids="sec-%typedarray%.prototype.set-overloaded-offset">
        <h1>%TypedArray%.prototype.set ( _source_ [ , _offset_ ] )</h1>
        <p>This method sets multiple values in this _TypedArray_, reading the values from _source_. The details differ based upon the type of _source_. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _target_ be the *this* value.
          1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).
          1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _targetOffset_ be ? ToIntegerOrInfinity(_offset_).
          1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
          1. If _source_ is an Object that has a [[TypedArrayName]] internal slot, then
            1. Perform ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_).
          1. Else,
            1. Perform ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_).
          1. Return *undefined*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>

        <emu-clause id="sec-settypedarrayfromarraylike" type="abstract operation" oldids="sec-%typedarray%.prototype.set-array-offset">
          <h1>
            SetTypedArrayFromArrayLike (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: an ECMAScript language value, but not a TypedArray,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_.</dd>
          </dl>
          <emu-alg>
            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).
            1. Let _src_ be ? ToObject(_source_).
            1. Let _srcLength_ be ? LengthOfArrayLike(_src_).
            1. If _targetOffset_ = +∞, throw a *RangeError* exception.
            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _srcLength_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _value_ be ? Get(_src_, _Pk_).
              1. Let _targetIndex_ be 𝔽(_targetOffset_ + _k_).
              1. Perform ? TypedArraySetElement(_target_, _targetIndex_, _value_).
              1. Set _k_ to _k_ + 1.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-settypedarrayfromtypedarray" type="abstract operation" oldids="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>
            SetTypedArrayFromTypedArray (
              _target_: a TypedArray,
              _targetOffset_: a non-negative integer or +&infin;,
              _source_: a TypedArray,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It sets multiple values in _target_, starting at index _targetOffset_, reading the values from _source_.</dd>
          </dl>
          <emu-alg>
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).
            1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].
            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.
            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).
            1. Let _targetType_ be TypedArrayElementType(_target_).
            1. Let _targetElementSize_ be TypedArrayElementSize(_target_).
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcType_ be TypedArrayElementType(_source_).
            1. Let _srcElementSize_ be TypedArrayElementSize(_source_).
            1. Let _srcByteOffset_ be _source_.[[ByteOffset]].
            1. If _targetOffset_ = +∞, throw a *RangeError* exception.
            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.
            1. If _target_.[[ContentType]] is not _source_.[[ContentType]], throw a *TypeError* exception.
            1. If IsSharedArrayBuffer(_srcBuffer_) is *true*, IsSharedArrayBuffer(_targetBuffer_) is *true*, and _srcBuffer_.[[ArrayBufferData]] is _targetBuffer_.[[ArrayBufferData]], let _sameSharedArrayBuffer_ be *true*; otherwise let _sameSharedArrayBuffer_ be *false*.
            1. If SameValue(_srcBuffer_, _targetBuffer_) is *true* or _sameSharedArrayBuffer_ is *true*, then
              1. Let _srcByteLength_ be TypedArrayByteLength(_srcRecord_).
              1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).
              1. Let _srcByteIndex_ be 0.
            1. Else,
              1. Let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be (_targetOffset_ × _targetElementSize_) + _targetByteOffset_.
            1. Let _limit_ be _targetByteIndex_ + (_targetElementSize_ × _srcLength_).
            1. If _srcType_ is _targetType_, then
              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Repeat, while _targetByteIndex_ &lt; _limit_,
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
            1. Else,
              1. Repeat, while _targetByteIndex_ &lt; _limit_,
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.slice">
        <h1>%TypedArray%.prototype.slice ( _start_, _end_ )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.slice` as defined in <emu-xref href="#sec-array.prototype.slice"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _srcArrayLength_ be TypedArrayLength(_taRecord_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_srcArrayLength_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _srcArrayLength_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _srcArrayLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_srcArrayLength_ + _relativeEnd_, 0).
          1. Else, let _endIndex_ be min(_relativeEnd_, _srcArrayLength_).
          1. Let _countBytes_ be max(_endIndex_ - _startIndex_, 0).
          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »).
          1. If _countBytes_ > 0, then
            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
            1. Set _endIndex_ to min(_endIndex_, TypedArrayLength(_taRecord_)).
            1. Set _countBytes_ to max(_endIndex_ - _startIndex_, 0).
            1. Let _srcType_ be TypedArrayElementType(_O_).
            1. Let _targetType_ be TypedArrayElementType(_A_).
            1. If _srcType_ is _targetType_, then
              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].
              1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].
              1. Let _elementSize_ be TypedArrayElementSize(_O_).
              1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
              1. Let _srcByteIndex_ be (_startIndex_ × _elementSize_) + _srcByteOffset_.
              1. Let _targetByteIndex_ be _A_.[[ByteOffset]].
              1. Let _endByteIndex_ be _targetByteIndex_ + (_countBytes_ × _elementSize_).
              1. Repeat, while _targetByteIndex_ &lt; _endByteIndex_,
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
            1. Else,
              1. Let _n_ be 0.
              1. Let _k_ be _startIndex_.
              1. Repeat, while _k_ &lt; _endIndex_,
                1. Let _Pk_ be ! ToString(𝔽(_k_)).
                1. Let _kValue_ be ! Get(_O_, _Pk_).
                1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*).
                1. Set _k_ to _k_ + 1.
                1. Set _n_ to _n_ + 1.
          1. Return _A_.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.some">
        <h1>%TypedArray%.prototype.some ( _callback_ [ , _thisArg_ ] )</h1>
        <p>The interpretation and use of the arguments of this method are the same as for `Array.prototype.some` as defined in <emu-xref href="#sec-array.prototype.some"></emu-xref>.</p>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _kValue_ be ! Get(_O_, _Pk_).
            1. Let _testResult_ be ToBoolean(? Call(_callback_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).
            1. If _testResult_ is *true*, return *true*.
            1. Set _k_ to _k_ + 1.
          1. Return *false*.
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.sort" oldids="sec-typedarraysortcompare">
        <h1>%TypedArray%.prototype.sort ( _comparator_ )</h1>
        <p>This is a distinct method that, except as described below, implements the same requirements as those of `Array.prototype.sort` as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. The implementation of this method may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose integer-indexed properties are not sparse.</p>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_obj_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.sort"></emu-xref>.
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparator_).
          1. Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).
            1. Set _j_ to _j_ + 1.
          1. Return _obj_.
        </emu-alg>
        <emu-note>
          <p>Because *NaN* always compares greater than any other value (see CompareTypedArrayElements), *NaN* property values always sort to the end of the result when _comparator_ is not provided.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.subarray">
        <h1>%TypedArray%.prototype.subarray ( _start_, _end_ )</h1>
        <p>This method returns a new _TypedArray_ whose element type is the element type of this _TypedArray_ and whose ArrayBuffer is the ArrayBuffer of this _TypedArray_, referencing the elements in the interval from _start_ (inclusive) to _end_ (exclusive). If either _start_ or _end_ is negative, it refers to an index from the end of the array, as opposed to from the beginning.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, then
            1. Let _srcLength_ be 0.
          1. Else,
            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _startIndex_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _startIndex_ be max(_srcLength_ + _relativeStart_, 0).
          1. Else, let _startIndex_ be min(_relativeStart_, _srcLength_).
          1. Let _elementSize_ be TypedArrayElementSize(_O_).
          1. Let _srcByteOffset_ be _O_.[[ByteOffset]].
          1. Let _beginByteOffset_ be _srcByteOffset_ + (_startIndex_ × _elementSize_).
          1. If _O_.[[ArrayLength]] is ~auto~ and _end_ is *undefined*, then
            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_) ».
          1. Else,
            1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
            1. If _relativeEnd_ = -∞, let _endIndex_ be 0.
            1. Else if _relativeEnd_ &lt; 0, let _endIndex_ be max(_srcLength_ + _relativeEnd_, 0).
            1. Else, let _endIndex_ be min(_relativeEnd_, _srcLength_).
            1. Let _newLength_ be max(_endIndex_ - _startIndex_, 0).
            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) ».
          1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).
        </emu-alg>
        <p>This method is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tolocalestring">
        <h1>%TypedArray%.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>This is a distinct method that implements the same algorithm as `Array.prototype.toLocaleString` as defined in <emu-xref href="#sec-array.prototype.tolocalestring"></emu-xref> except that TypedArrayLength is called in place of performing a [[Get]] of *"length"*. The implementation of the algorithm may be optimized with the knowledge that the *this* value has a fixed length when the underlying buffer is not resizable and whose integer-indexed properties are not sparse. However, such optimization must not introduce any observable changes in the specified behaviour of the algorithm.</p>
        <p>This method is not generic. ValidateTypedArray is called with the *this* value and ~seq-cst~ as arguments prior to evaluating the algorithm. If its result is an abrupt completion that exception is thrown instead of evaluating the algorithm.</p>
        <emu-note>
          <p>If the ECMAScript implementation includes the ECMA-402 Internationalization API this method is based upon the algorithm for `Array.prototype.toLocaleString` that is in the ECMA-402 specification.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.toreversed">
        <h1>%TypedArray%.prototype.toReversed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _A_ be ? TypedArrayCreateSameType(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _fromValue_ be ! Get(_O_, _from_).
            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tosorted">
        <h1>%TypedArray%.prototype.toSorted ( _comparator_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. If _comparator_ is not *undefined* and IsCallable(_comparator_) is *false*, throw a *TypeError* exception.
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _A_ be ? TypedArrayCreateSameType(_O_, _len_).
          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.tosorted"></emu-xref>.
          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparator_ and performs the following steps when called:
            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparator_).
          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).
          1. Let _j_ be 0.
          1. Repeat, while _j_ &lt; _len_,
            1. Perform ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).
            1. Set _j_ to _j_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.tostring">
        <h1>%TypedArray%.prototype.toString ( )</h1>
        <p>The initial value of the *"toString"* property is %Array.prototype.toString%, defined in <emu-xref href="#sec-array.prototype.tostring"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.values">
        <h1>%TypedArray%.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Return CreateArrayIterator(_O_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%typedarray%.prototype.with">
        <h1>%TypedArray%.prototype.with ( _index_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).
          1. Let _len_ be TypedArrayLength(_taRecord_).
          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).
          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.
          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.
          1. If _O_.[[ContentType]] is ~bigint~, let _numericValue_ be ? ToBigInt(_value_).
          1. Else, let _numericValue_ be ? ToNumber(_value_).
          1. If IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) is *false*, throw a *RangeError* exception.
          1. Let _A_ be ? TypedArrayCreateSameType(_O_, _len_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. If _k_ = _actualIndex_, let _fromValue_ be _numericValue_.
            1. Else, let _fromValue_ be ! Get(_O_, _Pk_).
            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _A_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%typedarray%.prototype-@@iterator" id="sec-%typedarray%.prototype-%symbol.iterator%">
        <h1>%TypedArray%.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %TypedArray.prototype.values%, defined in <emu-xref href="#sec-%typedarray%.prototype.values"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-%typedarray%.prototype-@@tostringtag" id="sec-get-%typedarray%.prototype-%symbol.tostringtag%">
        <h1>get %TypedArray%.prototype [ %Symbol.toStringTag% ]</h1>
        <p>%TypedArray%`.prototype[%Symbol.toStringTag%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, return *undefined*.
          1. If _O_ does not have a [[TypedArrayName]] internal slot, return *undefined*.
          1. Let _name_ be _O_.[[TypedArrayName]].
          1. Assert: _name_ is a String.
          1. Return _name_.
        </emu-alg>
        <p>This property has the attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        <p>The initial value of the *"name"* property of this function is *"get [Symbol.toStringTag]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-typedarray-objects">
      <h1>Abstract Operations for TypedArray Objects</h1>

      <emu-clause id="sec-typedarraycreatefromconstructor" oldids="typedarray-create" type="abstract operation">
        <h1>
          TypedArrayCreateFromConstructor (
            _constructor_: a constructor,
            _argumentList_: a List of ECMAScript language values,
          ): either a normal completion containing a TypedArray or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to specify the creation of a new TypedArray using a constructor function.</dd>
        </dl>
        <emu-alg>
          1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).
          1. Let _taRecord_ be ? ValidateTypedArray(_newTypedArray_, ~seq-cst~).
          1. Assert: _newTypedArray_ has all the internal slots mentioned in <emu-xref href="#sec-properties-of-typedarray-instances" title></emu-xref>.
          1. If the number of elements in _argumentList_ is 1 and _argumentList_[0] is a Number, then
            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
            1. Let _length_ be TypedArrayLength(_taRecord_).
            1. If _length_ &lt; ℝ(_argumentList_[0]), throw a *TypeError* exception.
          1. Return _newTypedArray_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarray-create-same-type" type="abstract operation">
        <h1>
          TypedArrayCreateSameType (
            _exemplar_: a TypedArray,
            _length_: a non-negative integer,
          ): either a normal completion containing a TypedArray or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to specify the creation of a new TypedArray using a constructor function that is derived from _exemplar_, and a _length_. Unlike TypedArraySpeciesCreate, which can construct custom TypedArray subclasses through the use of %Symbol.species%, this operation always uses one of the built-in TypedArray constructors.</dd>
        </dl>
        <emu-alg>
          1. Let _constructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.
          1. Let _result_ be ? <emu-meta suppress-effects="user-code">TypedArrayCreateFromConstructor(_constructor_, « 𝔽(_length_) »)</emu-meta>.
          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.
          1. Assert: _result_.[[ContentType]] is _exemplar_.[[ContentType]].
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="typedarray-species-create" type="abstract operation">
        <h1>
          TypedArraySpeciesCreate (
            _exemplar_: a TypedArray,
            _argumentList_: a List of ECMAScript language values,
          ): either a normal completion containing a TypedArray or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to specify the creation of a new TypedArray using a constructor function that is derived from _exemplar_. Unlike ArraySpeciesCreate, which can create non-Array objects through the use of %Symbol.species%, this operation enforces that the constructor function creates an actual TypedArray.</dd>
        </dl>
        <emu-alg>
          1. Let _defaultConstructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.
          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).
          1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).
          1. If _result_.[[ContentType]] is not _exemplar_.[[ContentType]], throw a *TypeError* exception.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validatetypedarray" type="abstract operation">
        <h1>
          ValidateTypedArray (
            _O_: an ECMAScript language value,
            _order_: ~seq-cst~ or ~unordered~,
          ): either a normal completion containing a TypedArray With Buffer Witness Record or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, _order_).
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
          1. Return _taRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementsize" type="abstract operation">
        <h1>
          TypedArrayElementSize (
            _O_: a TypedArray,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-typedarrayelementtype" type="abstract operation">
        <h1>
          TypedArrayElementType (
            _O_: a TypedArray,
          ): a TypedArray element type
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Return the Element Type value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _O_.[[TypedArrayName]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-comparetypedarrayelements" type="abstract operation">
        <h1>
          CompareTypedArrayElements (
            _x_: a Number or a BigInt,
            _y_: a Number or a BigInt,
            _comparator_: a function object or *undefined*,
          ): either a normal completion containing a Number or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _x_ is a Number and _y_ is a Number, or _x_ is a BigInt and _y_ is a BigInt.
          1. If _comparator_ is not *undefined*, then
            1. Let _v_ be ? ToNumber(? Call(_comparator_, *undefined*, « _x_, _y_ »)).
            1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.
            1. Return _v_.
          1. If _x_ and _y_ are both *NaN*, return *+0*<sub>𝔽</sub>.
          1. If _x_ is *NaN*, return *1*<sub>𝔽</sub>.
          1. If _y_ is *NaN*, return *-1*<sub>𝔽</sub>.
          1. If _x_ &lt; _y_, return *-1*<sub>𝔽</sub>.
          1. If _x_ > _y_, return *1*<sub>𝔽</sub>.
          1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.
          1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.
          1. Return *+0*<sub>𝔽</sub>.
        </emu-alg>
        <emu-note>
          This performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-comparearrayelements"></emu-xref>.
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-typedarray-constructors">
      <h1>The _TypedArray_ Constructors</h1>
      <p>Each _TypedArray_ constructor:</p>
      <ul>
        <li>is an intrinsic object that has the structure described below, differing only in the name used as the constructor name instead of _TypedArray_, in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.</li>
        <li>is a function whose behaviour differs based upon the number and types of its arguments. The actual behaviour of a call of _TypedArray_ depends upon the number and kind of arguments that are passed to it.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified _TypedArray_ behaviour must include a `super` call to the _TypedArray_ constructor to create and initialize the subclass instance with the internal state necessary to support the %TypedArray%`.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-typedarray" oldids="sec-typedarray-length,sec-typedarray-object">
        <h1>_TypedArray_ ( ..._args_ )</h1>
        <p>Each _TypedArray_ constructor performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _proto_ be <code>"%<var>TypedArray</var>.prototype%"</code>.
          1. Let _numberOfArgs_ be the number of elements in _args_.
          1. If _numberOfArgs_ = 0, then
            1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0).
          1. Else,
            1. Let _firstArgument_ be _args_[0].
            1. If _firstArgument_ is an Object, then
              1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, _proto_).
              1. If _firstArgument_ has a [[TypedArrayName]] internal slot, then
                1. Perform ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_).
              1. Else if _firstArgument_ has an [[ArrayBufferData]] internal slot, then
                1. If _numberOfArgs_ > 1, let _byteOffset_ be _args_[1]; else let _byteOffset_ be *undefined*.
                1. If _numberOfArgs_ > 2, let _length_ be _args_[2]; else let _length_ be *undefined*.
                1. Perform ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_).
              1. Else,
                1. Assert: _firstArgument_ is an Object and _firstArgument_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.
                1. Let _usingIterator_ be ? GetMethod(_firstArgument_, %Symbol.iterator%).
                1. If _usingIterator_ is not *undefined*, then
                  1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_)).
                  1. Perform ? InitializeTypedArrayFromList(_O_, _values_).
                1. Else,
                  1. NOTE: _firstArgument_ is not an iterable object, so assume it is already an array-like object.
                  1. Perform ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_).
              1. Return _O_.
            1. Else,
              1. Assert: _firstArgument_ is not an Object.
              1. Let _elementLength_ be ? ToIndex(_firstArgument_).
              1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_).
        </emu-alg>

        <emu-clause id="sec-allocatetypedarray" type="abstract operation">
          <h1>
            AllocateTypedArray (
              _constructorName_: a String which is the name of a TypedArray constructor in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>,
              _newTarget_: a constructor,
              _defaultProto_: a String,
              optional _length_: a non-negative integer,
            ): either a normal completion containing a TypedArray or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It is used to validate and create an instance of a TypedArray constructor. If the _length_ argument is passed, an ArrayBuffer of that length is also allocated and associated with the new TypedArray instance. AllocateTypedArray provides common semantics that is used by _TypedArray_.</dd>
          </dl>
          <emu-alg>
            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).
            1. Let _obj_ be TypedArrayCreate(_proto_).
            1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.
            1. Set _obj_.[[TypedArrayName]] to _constructorName_.
            1. If _constructorName_ is either *"BigInt64Array"* or *"BigUint64Array"*, set _obj_.[[ContentType]] to ~bigint~.
            1. Otherwise, set _obj_.[[ContentType]] to ~number~.
            1. If _length_ is not present, then
              1. Set _obj_.[[ByteLength]] to 0.
              1. Set _obj_.[[ByteOffset]] to 0.
              1. Set _obj_.[[ArrayLength]] to 0.
            1. Else,
              1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).
            1. Return _obj_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromtypedarray" type="abstract operation" oldids="sec-typedarray-typedarray">
          <h1>
            InitializeTypedArrayFromTypedArray (
              _O_: a TypedArray,
              _srcArray_: a TypedArray,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
            1. Let _elementType_ be TypedArrayElementType(_O_).
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _srcType_ be TypedArrayElementType(_srcArray_).
            1. Let _srcElementSize_ be TypedArrayElementSize(_srcArray_).
            1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~).
            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.
            1. Let _elementLength_ be TypedArrayLength(_srcRecord_).
            1. Let _byteLength_ be _elementSize_ × _elementLength_.
            1. If _elementType_ is _srcType_, then
              1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).
            1. Else,
              1. Let _data_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
              1. If _srcArray_.[[ContentType]] is not _O_.[[ContentType]], throw a *TypeError* exception.
              1. Let _srcByteIndex_ be _srcByteOffset_.
              1. Let _targetByteIndex_ be 0.
              1. Let _count_ be _elementLength_.
              1. Repeat, while _count_ > 0,
                1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~).
                1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~).
                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
                1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
                1. Set _count_ to _count_ - 1.
            1. Set _O_.[[ViewedArrayBuffer]] to _data_.
            1. Set _O_.[[ByteLength]] to _byteLength_.
            1. Set _O_.[[ByteOffset]] to 0.
            1. Set _O_.[[ArrayLength]] to _elementLength_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraybuffer" type="abstract operation" oldids="sec-typedarray-buffer-byteoffset-length">
          <h1>
            InitializeTypedArrayFromArrayBuffer (
              _O_: a TypedArray,
              _buffer_: an ArrayBuffer or a SharedArrayBuffer,
              _byteOffset_: an ECMAScript language value,
              _length_: an ECMAScript language value,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _offset_ be ? ToIndex(_byteOffset_).
            1. If _offset_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.
            1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).
            1. If _length_ is not *undefined*, then
              1. Let _newLength_ be ? ToIndex(_length_).
            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
            1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).
            1. If _length_ is *undefined* and _bufferIsFixedLength_ is *false*, then
              1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.
              1. Set _O_.[[ByteLength]] to ~auto~.
              1. Set _O_.[[ArrayLength]] to ~auto~.
            1. Else,
              1. If _length_ is *undefined*, then
                1. If _bufferByteLength_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.
                1. Let _newByteLength_ be _bufferByteLength_ - _offset_.
                1. If _newByteLength_ &lt; 0, throw a *RangeError* exception.
              1. Else,
                1. Let _newByteLength_ be _newLength_ × _elementSize_.
                1. If _offset_ + _newByteLength_ > _bufferByteLength_, throw a *RangeError* exception.
              1. Set _O_.[[ByteLength]] to _newByteLength_.
              1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.
            1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
            1. Set _O_.[[ByteOffset]] to _offset_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromlist" type="abstract operation">
          <h1>
            InitializeTypedArrayFromList (
              _O_: a TypedArray,
              _values_: a List of ECMAScript language values,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _len_ be the number of elements in _values_.
            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _kValue_ be the first element of _values_.
              1. Remove the first element from _values_.
              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).
              1. Set _k_ to _k_ + 1.
            1. Assert: _values_ is now an empty List.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-initializetypedarrayfromarraylike" type="abstract operation">
          <h1>
            InitializeTypedArrayFromArrayLike (
              _O_: a TypedArray,
              _arrayLike_: an Object, but not a TypedArray or an ArrayBuffer,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).
            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).
            1. Let _k_ be 0.
            1. Repeat, while _k_ &lt; _len_,
              1. Let _Pk_ be ! ToString(𝔽(_k_)).
              1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).
              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).
              1. Set _k_ to _k_ + 1.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-allocatetypedarraybuffer" type="abstract operation">
          <h1>
            AllocateTypedArrayBuffer (
              _O_: a TypedArray,
              _length_: a non-negative integer,
            ): either a normal completion containing ~unused~ or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It allocates and associates an ArrayBuffer with _O_.</dd>
          </dl>
          <emu-alg>
            1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.
            1. Let _elementSize_ be TypedArrayElementSize(_O_).
            1. Let _byteLength_ be _elementSize_ × _length_.
            1. Let _data_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.
            1. Set _O_.[[ViewedArrayBuffer]] to _data_.
            1. Set _O_.[[ByteLength]] to _byteLength_.
            1. Set _O_.[[ByteOffset]] to 0.
            1. Set _O_.[[ArrayLength]] to _length_.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-typedarray-constructors">
      <h1>Properties of the _TypedArray_ Constructors</h1>
      <p>Each _TypedArray_ constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %TypedArray%.</li>
        <li>has a *"length"* property whose value is *3*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is the String value of the constructor name specified for it in <emu-xref href="#table-the-typedarray-constructors"></emu-xref>.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-typedarray.bytes_per_element">
        <h1>_TypedArray_.BYTES_PER_ELEMENT</h1>
        <p>The value of _TypedArray_`.BYTES_PER_ELEMENT` is the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _TypedArray_.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype">
        <h1>_TypedArray_.prototype</h1>
        <p>The initial value of _TypedArray_`.prototype` is the corresponding _TypedArray_ prototype intrinsic object (<emu-xref href="#sec-properties-of-typedarray-prototype-objects"></emu-xref>).</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-prototype-objects">
      <h1>Properties of the _TypedArray_ Prototype Objects</h1>
      <p>Each _TypedArray_ prototype object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %TypedArray.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[ViewedArrayBuffer]] or any other of the internal slots that are specific to _TypedArray_ instance objects.</li>
      </ul>

      <emu-clause id="sec-typedarray.prototype.bytes_per_element">
        <h1>_TypedArray_.prototype.BYTES_PER_ELEMENT</h1>
        <p>The value of _TypedArray_`.prototype.BYTES_PER_ELEMENT` is the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for _TypedArray_.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-typedarray.prototype.constructor">
        <h1>_TypedArray_.prototype.constructor</h1>
        <p>The initial value of the *"constructor"* property of the prototype for a given _TypedArray_ constructor is the constructor itself.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-typedarray-instances">
      <h1>Properties of _TypedArray_ Instances</h1>
      <p>_TypedArray_ instances are TypedArrays. Each _TypedArray_ instance inherits properties from the corresponding _TypedArray_ prototype object. Each _TypedArray_ instance has the following internal slots: [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], and [[ArrayLength]].</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-keyed-collections" oldids="sec-keyed-collection">
  <h1>Keyed Collections</h1>

  <emu-clause id="sec-map-objects">
    <h1>Map Objects</h1>
    <p>Maps are collections of key/value pairs where both the keys and values may be arbitrary ECMAScript language values. A distinct key value may only occur in one key/value pair within the Map's collection. Distinct key values are discriminated using the semantics of the SameValueZero comparison algorithm.</p>
    <p>Maps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Maps. It is not intended to be a viable implementation model.</p>

    <emu-clause id="sec-map-constructor">
      <h1>The Map Constructor</h1>
      <p>The Map constructor:</p>
      <ul>
        <li>is <dfn>%Map%</dfn>.</li>
        <li>is the initial value of the *"Map"* property of the global object.</li>
        <li>creates and initializes a new Map when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Map behaviour must include a `super` call to the Map constructor to create and initialize the subclass instance with the internal state necessary to support the `Map.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-map-iterable">
        <h1>Map ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Map.prototype%"*, « [[MapData]] »).
          1. Set _map_.[[MapData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _map_.
          1. Let _adder_ be ? Get(_map_, *"set"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>If the parameter _iterable_ is present, it is expected to be an object that implements a %Symbol.iterator% method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-add-entries-from-iterable" type="abstract operation">
        <h1>
          AddEntriesFromIterable (
            _target_: an Object,
            _iterable_: an ECMAScript language value, but not *undefined* or *null*,
            _adder_: a function object,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_adder_ will be invoked, with _target_ as the receiver.</dd>
        </dl>
        <emu-alg>
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _target_.
            1. If _next_ is not an Object, then
              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
              1. Return ? IteratorClose(_iteratorRecord_, _error_).
            1. Let _k_ be Completion(Get(_next_, *"0"*)).
            1. IfAbruptCloseIterator(_k_, _iteratorRecord_).
            1. Let _v_ be Completion(Get(_next_, *"1"*)).
            1. IfAbruptCloseIterator(_v_, _iteratorRecord_).
            1. Let _status_ be Completion(Call(_adder_, _target_, « _k_, _v_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
        <emu-note>
          <p>The parameter _iterable_ is expected to be an object that implements a %Symbol.iterator% method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a Map key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-constructor">
      <h1>Properties of the Map Constructor</h1>
      <p>The Map constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-map.groupby">
        <h1>Map.groupBy ( _items_, _callback_ )</h1>
        <emu-note>
          <p>_callback_ should be a function that accepts two arguments. `groupBy` calls _callback_ once for each element in _items_, in ascending order, and constructs a new Map. Each value returned by _callback_ is used as a key in the Map. For each such key, the result Map has an entry whose key is that key and whose value is an array containing all the elements for which _callback_ returned that key.</p>
          <p>_callback_ is called with two arguments: the value of the element and the index of the element.</p>
          <p>The return value of `groupBy` is a Map.</p>
        </emu-note>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _groups_ be ? GroupBy(_items_, _callback_, ~collection~).
          1. Let _map_ be ! Construct(%Map%).
          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do
            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).
            1. Let _entry_ be the Record { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }.
            1. Append _entry_ to _map_.[[MapData]].
          1. Return _map_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype">
        <h1>Map.prototype</h1>
        <p>The initial value of `Map.prototype` is the Map prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-map-@@species" id="sec-get-map-%symbol.species%">
        <h1>get Map [ %Symbol.species% ]</h1>
        <p>`Map[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Methods that create derived collection objects should call %Symbol.species% to determine the constructor to use to create the derived objects. Subclass constructor may over-ride %Symbol.species% to change the default constructor assignment.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-map-prototype-object">
      <h1>Properties of the Map Prototype Object</h1>
      <p>The <dfn>Map prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Map.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[MapData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-map.prototype.clear">
        <h1>Map.prototype.clear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. Set _p_.[[Key]] to ~empty~.
            1. Set _p_.[[Value]] to ~empty~.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The existing [[MapData]] List is preserved because there may be existing Map Iterator objects that are suspended midway through iterating over that List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.constructor">
        <h1>Map.prototype.constructor</h1>
        <p>The initial value of `Map.prototype.constructor` is %Map%.</p>
      </emu-clause>

      <emu-clause id="sec-map.prototype.delete">
        <h1>Map.prototype.delete ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Key]] to ~empty~.
              1. Set _p_.[[Value]] to ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.entries">
        <h1>Map.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, ~key+value~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.foreach">
        <h1>Map.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _entries_ be _M_.[[MapData]].
          1. Let _numEntries_ be the number of elements in _entries_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _numEntries_,
            1. Let _e_ be _entries_[_index_].
            1. Set _index_ to _index_ + 1.
            1. If _e_.[[Key]] is not ~empty~, then
              1. Perform ? Call(_callback_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »).
              1. NOTE: The number of elements in _entries_ may have increased during execution of _callback_.
              1. Set _numEntries_ to the number of elements in _entries_.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `forEach` calls _callback_ once for each key/value pair present in the Map, in key insertion order. _callback_ is called only for keys of the Map which actually exist; it is not called for keys that have been deleted from the Map.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the value of the item, the key of the item, and the Map being traversed.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_. Each entry of a map's [[MapData]] is only visited once. New keys added after the call to `forEach` begins are visited. A key will be revisited if it is deleted after it has been visited and then re-added before the `forEach` call completes. Keys that are deleted after the call to `forEach` begins and before being visited are not visited unless the key is added again before the `forEach` call completes.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-map.prototype.get">
        <h1>Map.prototype.get ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.has">
        <h1>Map.prototype.has ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.keys">
        <h1>Map.prototype.keys ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, ~key~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.set">
        <h1>Map.prototype.set ( _key_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Set _key_ to CanonicalizeKeyedCollectionKey(_key_).
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Value]] to _value_.
              1. Return _M_.
          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. Append _p_ to _M_.[[MapData]].
          1. Return _M_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-map.prototype.size">
        <h1>get Map.prototype.size</h1>
        <p>`Map.prototype.size` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
          1. Let _count_ be 0.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do
            1. If _p_.[[Key]] is not ~empty~, set _count_ to _count_ + 1.
          1. Return 𝔽(_count_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-map.prototype.values">
        <h1>Map.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Return ? CreateMapIterator(_M_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@iterator" id="sec-map.prototype-%symbol.iterator%">
        <h1>Map.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %Map.prototype.entries%, defined in <emu-xref href="#sec-map.prototype.entries"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-map.prototype-@@tostringtag" id="sec-map.prototype-%symbol.tostringtag%">
        <h1>Map.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Map"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-map-instances">
      <h1>Properties of Map Instances</h1>
      <p>Map instances are ordinary objects that inherit properties from the Map prototype object. Map instances also have a [[MapData]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-map-iterator-objects">
      <h1>Map Iterator Objects</h1>
      <p>A <dfn variants="Map Iterators,Map Iterator object,Map Iterator objects">Map Iterator</dfn> is an object that represents a specific iteration over some specific Map instance object. There is not a named constructor for Map Iterator objects. Instead, Map Iterator objects are created by calling certain methods of Map instance objects.</p>

      <emu-clause id="sec-createmapiterator" type="abstract operation" oldids="sec-properties-of-map-iterator-instances,table-50,table-internal-slots-of-map-iterator-instances">
        <h1>
          CreateMapIterator (
            _map_: an ECMAScript language value,
            _kind_: ~key+value~, ~key~, or ~value~,
          ): either a normal completion containing a Generator or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create iterator objects for Map methods that return such iterators.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:
            1. Let _entries_ be _map_.[[MapData]].
            1. Let _index_ be 0.
            1. Let _numEntries_ be the number of elements in _entries_.
            1. Repeat, while _index_ &lt; _numEntries_,
              1. Let _e_ be _entries_[_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_.[[Key]] is not ~empty~, then
                1. If _kind_ is ~key~, then
                  1. Let _result_ be _e_.[[Key]].
                1. Else if _kind_ is ~value~, then
                  1. Let _result_ be _e_.[[Value]].
                1. Else,
                  1. Assert: _kind_ is ~key+value~.
                  1. Let _result_ be CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).
                1. Perform ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)).
                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by GeneratorYield.
                1. Set _numEntries_ to the number of elements in _entries_.
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%MapIteratorPrototype%"*, %MapIteratorPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%mapiteratorprototype%-object">
        <h1>The %MapIteratorPrototype% Object</h1>
        <p>The <dfn>%MapIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Map Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%mapiteratorprototype%.next">
          <h1>%MapIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%MapIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%mapiteratorprototype%-@@tostringtag" id="sec-%mapiteratorprototype%-%symbol.tostringtag%">
          <h1>%MapIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Map Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-set-objects">
    <h1>Set Objects</h1>
    <p>Set objects are collections of ECMAScript language values. A distinct value may only occur once as an element of a Set's collection. Distinct values are discriminated using the semantics of the SameValueZero comparison algorithm.</p>
    <p>Set objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of Set objects. It is not intended to be a viable implementation model.</p>

    <emu-clause id="sec-abstract-operations-for-set-objects">
      <h1>Abstract Operations For Set Objects</h1>

      <emu-clause id="sec-set-records">
        <h1>Set Records</h1>
        <p>A <dfn variants="Set Records">Set Record</dfn> is a Record value used to encapsulate the interface of a Set or similar object.</p>
        <p>Set Records have the fields listed in <emu-xref href="#table-set-record-fields"></emu-xref>.</p>
        <emu-table id="table-set-record-fields" caption="Set Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[SetObject]]
              </td>
              <td>
                an Object
              </td>
              <td>
                the Set or similar object.
              </td>
            </tr>
            <tr>
              <td>
                [[Size]]
              </td>
              <td>
                a non-negative integer or +∞
              </td>
              <td>
                The reported size of the object.
              </td>
            </tr>
            <tr>
              <td>
                [[Has]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The `has` method of the object.
              </td>
            </tr>
            <tr>
              <td>
                [[Keys]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The `keys` method of the object.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-getsetrecord" type="abstract operation">
        <h1>
          GetSetRecord (
            _obj_: an ECMAScript language value,
          ): either a normal completion containing a Set Record or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _obj_ is not an Object, throw a *TypeError* exception.
          1. Let _rawSize_ be ? Get(_obj_, *"size"*).
          1. Let _numSize_ be ? ToNumber(_rawSize_).
          1. NOTE: If _rawSize_ is *undefined*, then _numSize_ will be *NaN*.
          1. If _numSize_ is *NaN*, throw a *TypeError* exception.
          1. Let _intSize_ be ! ToIntegerOrInfinity(_numSize_).
          1. If _intSize_ &lt; 0, throw a *RangeError* exception.
          1. Let _has_ be ? Get(_obj_, *"has"*).
          1. If IsCallable(_has_) is *false*, throw a *TypeError* exception.
          1. Let _keys_ be ? Get(_obj_, *"keys"*).
          1. If IsCallable(_keys_) is *false*, throw a *TypeError* exception.
          1. Return a new Set Record { [[SetObject]]: _obj_, [[Size]]: _intSize_, [[Has]]: _has_, [[Keys]]: _keys_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatahas" type="abstract operation">
        <h1>
          SetDataHas (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If SetDataIndex(_setData_, _value_) is ~not-found~, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdataindex" type="abstract operation">
        <h1>
          SetDataIndex (
            _setData_: a List of either ECMAScript language values or ~empty~,
            _value_: an ECMAScript language value,
          ): a non-negative integer or ~not-found~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. Let _size_ be the number of elements in _setData_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _size_,
            1. Let _e_ be _setData_[_index_].
            1. If _e_ is not ~empty~ and _e_ is _value_, then
              1. Return _index_.
            1. Set _index_ to _index_ + 1.
          1. Return ~not-found~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setdatasize" type="abstract operation">
        <h1>
          SetDataSize (
            _setData_: a List of either ECMAScript language values or ~empty~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _count_ be 0.
          1. For each element _e_ of _setData_, do
            1. If _e_ is not ~empty~, set _count_ to _count_ + 1.
          1. Return _count_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-set-constructor">
      <h1>The Set Constructor</h1>
      <p>The Set constructor:</p>
      <ul>
        <li>is <dfn>%Set%</dfn>.</li>
        <li>is the initial value of the *"Set"* property of the global object.</li>
        <li>creates and initializes a new Set object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Set behaviour must include a `super` call to the Set constructor to create and initialize the subclass instance with the internal state necessary to support the `Set.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-set-iterable">
        <h1>Set ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Set.prototype%"*, « [[SetData]] »).
          1. Set _set_.[[SetData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _set_.
          1. Let _adder_ be ? Get(_set_, *"add"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _set_.
            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-constructor">
      <h1>Properties of the Set Constructor</h1>
      <p>The Set constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-set.prototype">
        <h1>Set.prototype</h1>
        <p>The initial value of `Set.prototype` is the Set prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-set-@@species" id="sec-get-set-%symbol.species%">
        <h1>get Set [ %Symbol.species% ]</h1>
        <p>`Set[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Methods that create derived collection objects should call %Symbol.species% to determine the constructor to use to create the derived objects. Subclass constructor may over-ride %Symbol.species% to change the default constructor assignment.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-set-prototype-object">
      <h1>Properties of the Set Prototype Object</h1>
      <p>The <dfn>Set prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Set.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[SetData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-set.prototype.add">
        <h1>Set.prototype.add ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. For each element _e_ of _S_.[[SetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Return _S_.
          1. Append _value_ to _S_.[[SetData]].
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.clear">
        <h1>Set.prototype.clear ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. For each element _e_ of _S_.[[SetData]], do
            1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>The existing [[SetData]] List is preserved because there may be existing Set Iterator objects that are suspended midway through iterating over that List.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.constructor">
        <h1>Set.prototype.constructor</h1>
        <p>The initial value of `Set.prototype.constructor` is %Set%.</p>
      </emu-clause>

      <emu-clause id="sec-set.prototype.delete">
        <h1>Set.prototype.delete ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. For each element _e_ of _S_.[[SetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.difference">
        <h1>Set.prototype.difference ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _resultSetData_ be a copy of _O_.[[SetData]].
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]], then
            1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
            1. Let _index_ be 0.
            1. Repeat, while _index_ &lt; _thisSize_,
              1. Let _e_ be _resultSetData_[_index_].
              1. If _e_ is not ~empty~, then
                1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. If _inOther_ is *true*, then
                  1. Set _resultSetData_[_index_] to ~empty~.
              1. Set _index_ to _index_ + 1.
          1. Else,
            1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. Let _next_ be ~not-started~.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_keysIter_).
              1. If _next_ is not ~done~, then
                1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
                1. Let _valueIndex_ be SetDataIndex(_resultSetData_, _next_).
                1. If _valueIndex_ is not ~not-found~, then
                  1. Set _resultSetData_[_valueIndex_] to ~empty~.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.entries">
        <h1>Set.prototype.entries ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateSetIterator(_S_, ~key+value~).
        </emu-alg>
        <emu-note>
          <p>For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.foreach">
        <h1>Set.prototype.forEach ( _callback_ [ , _thisArg_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
          1. Let _entries_ be _S_.[[SetData]].
          1. Let _numEntries_ be the number of elements in _entries_.
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _numEntries_,
            1. Let _e_ be _entries_[_index_].
            1. Set _index_ to _index_ + 1.
            1. If _e_ is not ~empty~, then
              1. Perform ? Call(_callback_, _thisArg_, « _e_, _e_, _S_ »).
              1. NOTE: The number of elements in _entries_ may have increased during execution of _callback_.
              1. Set _numEntries_ to the number of elements in _entries_.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>_callback_ should be a function that accepts three arguments. `forEach` calls _callback_ once for each value present in the Set object, in value insertion order. _callback_ is called only for values of the Set which actually exist; it is not called for keys that have been deleted from the set.</p>
          <p>If a _thisArg_ parameter is provided, it will be used as the *this* value for each invocation of _callback_. If it is not provided, *undefined* is used instead.</p>
          <p>_callback_ is called with three arguments: the first two arguments are a value contained in the Set. The same value is passed for both arguments. The Set object being traversed is passed as the third argument.</p>
          <p>The _callback_ is called with three arguments to be consistent with the call back functions used by `forEach` methods for Map and Array. For Sets, each item value is considered to be both the key and the value.</p>
          <p>`forEach` does not directly mutate the object on which it is called but the object may be mutated by the calls to _callback_.</p>
          <p>Each value is normally visited only once. However, a value will be revisited if it is deleted after it has been visited and then re-added before the `forEach` call completes. Values that are deleted after the call to `forEach` begins and before being visited are not visited unless the value is added again before the `forEach` call completes. New values added after the call to `forEach` begins are visited.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-set.prototype.has">
        <h1>Set.prototype.has ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Set _value_ to CanonicalizeKeyedCollectionKey(_value_).
          1. For each element _e_ of _S_.[[SetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.intersection">
        <h1>Set.prototype.intersection ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _resultSetData_ be a new empty List.
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]], then
            1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
            1. Let _index_ be 0.
            1. Repeat, while _index_ &lt; _thisSize_,
              1. Let _e_ be _O_.[[SetData]][_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_ is not ~empty~, then
                1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. If _inOther_ is *true*, then
                  1. NOTE: It is possible for earlier calls to _otherRec_.[[Has]] to remove and re-add an element of _O_.[[SetData]], which can cause the same element to be visited twice during this iteration.
                  1. If SetDataHas(_resultSetData_, _e_) is *false*, then
                    1. Append _e_ to _resultSetData_.
                1. NOTE: The number of elements in _O_.[[SetData]] may have increased during execution of _otherRec_.[[Has]].
                1. Set _thisSize_ to the number of elements in _O_.[[SetData]].
          1. Else,
            1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. Let _next_ be ~not-started~.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_keysIter_).
              1. If _next_ is not ~done~, then
                1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
                1. Let _inThis_ be SetDataHas(_O_.[[SetData]], _next_).
                1. If _inThis_ is *true*, then
                  1. NOTE: Because _other_ is an arbitrary object, it is possible for its *"keys"* iterator to produce the same value more than once.
                  1. If SetDataHas(_resultSetData_, _next_) is *false*, then
                    1. Append _next_ to _resultSetData_.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.isdisjointfrom">
        <h1>Set.prototype.isDisjointFrom ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) ≤ _otherRec_.[[Size]], then
            1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
            1. Let _index_ be 0.
            1. Repeat, while _index_ &lt; _thisSize_,
              1. Let _e_ be _O_.[[SetData]][_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_ is not ~empty~, then
                1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
                1. If _inOther_ is *true*, return *false*.
                1. NOTE: The number of elements in _O_.[[SetData]] may have increased during execution of _otherRec_.[[Has]].
                1. Set _thisSize_ to the number of elements in _O_.[[SetData]].
          1. Else,
            1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
            1. Let _next_ be ~not-started~.
            1. Repeat, while _next_ is not ~done~,
              1. Set _next_ to ? IteratorStepValue(_keysIter_).
              1. If _next_ is not ~done~, then
                1. If SetDataHas(_O_.[[SetData]], _next_) is *true*, then
                  1. Perform ? IteratorClose(_keysIter_, NormalCompletion(~unused~)).
                  1. Return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issubsetof">
        <h1>Set.prototype.isSubsetOf ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) > _otherRec_.[[Size]], return *false*.
          1. Let _thisSize_ be the number of elements in _O_.[[SetData]].
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _thisSize_,
            1. Let _e_ be _O_.[[SetData]][_index_].
            1. Set _index_ to _index_ + 1.
            1. If _e_ is not ~empty~, then
              1. Let _inOther_ be ToBoolean(? Call(_otherRec_.[[Has]], _otherRec_.[[SetObject]], « _e_ »)).
              1. If _inOther_ is *false*, return *false*.
              1. NOTE: The number of elements in _O_.[[SetData]] may have increased during execution of _otherRec_.[[Has]].
              1. Set _thisSize_ to the number of elements in _O_.[[SetData]].
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.issupersetof">
        <h1>Set.prototype.isSupersetOf ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. If SetDataSize(_O_.[[SetData]]) &lt; _otherRec_.[[Size]], return *false*.
          1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_keysIter_).
            1. If _next_ is not ~done~, then
              1. If SetDataHas(_O_.[[SetData]], _next_) is *false*, then
                1. Perform ? IteratorClose(_keysIter_, NormalCompletion(~unused~)).
                1. Return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.keys">
        <h1>Set.prototype.keys ( )</h1>
        <p>The initial value of the *"keys"* property is %Set.prototype.values%, defined in <emu-xref href="#sec-set.prototype.values"></emu-xref>.</p>
        <emu-note>
          <p>For iteration purposes, a Set appears similar to a Map where each entry has the same value for its key and value.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-set.prototype.size">
        <h1>get Set.prototype.size</h1>
        <p>`Set.prototype.size` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).
          1. Let _size_ be SetDataSize(_S_.[[SetData]]).
          1. Return 𝔽(_size_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.symmetricdifference">
        <h1>Set.prototype.symmetricDifference ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. Let _resultSetData_ be a copy of _O_.[[SetData]].
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_keysIter_).
            1. If _next_ is not ~done~, then
              1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
              1. Let _resultIndex_ be SetDataIndex(_resultSetData_, _next_).
              1. If _resultIndex_ is ~not-found~, let _alreadyInResult_ be *false*; otherwise let _alreadyInResult_ be *true*.
              1. If SetDataHas(_O_.[[SetData]], _next_) is *true*, then
                1. If _alreadyInResult_ is *true*, set _resultSetData_[_resultIndex_] to ~empty~.
              1. Else,
                1. If _alreadyInResult_ is *false*, append _next_ to _resultSetData_.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.union">
        <h1>Set.prototype.union ( _other_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[SetData]]).
          1. Let _otherRec_ be ? GetSetRecord(_other_).
          1. Let _keysIter_ be ? GetIteratorFromMethod(_otherRec_.[[SetObject]], _otherRec_.[[Keys]]).
          1. Let _resultSetData_ be a copy of _O_.[[SetData]].
          1. Let _next_ be ~not-started~.
          1. Repeat, while _next_ is not ~done~,
            1. Set _next_ to ? IteratorStepValue(_keysIter_).
            1. If _next_ is not ~done~, then
              1. Set _next_ to CanonicalizeKeyedCollectionKey(_next_).
              1. If SetDataHas(_resultSetData_, _next_) is *false*, then
                1. Append _next_ to _resultSetData_.
          1. Let _result_ be OrdinaryObjectCreate(%Set.prototype%, « [[SetData]] »).
          1. Set _result_.[[SetData]] to _resultSetData_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-set.prototype.values">
        <h1>Set.prototype.values ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateSetIterator(_S_, ~value~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@iterator" id="sec-set.prototype-%symbol.iterator%">
        <h1>Set.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>The initial value of the %Symbol.iterator% property is %Set.prototype.values%, defined in <emu-xref href="#sec-set.prototype.values"></emu-xref>.</p>
      </emu-clause>

      <emu-clause oldids="sec-set.prototype-@@tostringtag" id="sec-set.prototype-%symbol.tostringtag%">
        <h1>Set.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Set"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-set-instances">
      <h1>Properties of Set Instances</h1>
      <p>Set instances are ordinary objects that inherit properties from the Set prototype object. Set instances also have a [[SetData]] internal slot.</p>
    </emu-clause>

    <emu-clause id="sec-set-iterator-objects">
      <h1>Set Iterator Objects</h1>
      <p>A <dfn variants="Set Iterators,Set Iterator object,Set Iterator objects">Set Iterator</dfn> is an ordinary object, with the structure defined below, that represents a specific iteration over some specific Set instance object. There is not a named constructor for Set Iterator objects. Instead, Set Iterator objects are created by calling certain methods of Set instance objects.</p>

      <emu-clause id="sec-createsetiterator" type="abstract operation" oldids="sec-properties-of-set-iterator-instances,table-51,table-internal-slots-of-set-iterator-instances">
        <h1>
          CreateSetIterator (
            _set_: an ECMAScript language value,
            _kind_: ~key+value~ or ~value~,
          ): either a normal completion containing a Generator or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create iterator objects for Set methods that return such iterators.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:
            1. Let _index_ be 0.
            1. Let _entries_ be _set_.[[SetData]].
            1. Let _numEntries_ be the number of elements in _entries_.
            1. Repeat, while _index_ &lt; _numEntries_,
              1. Let _e_ be _entries_[_index_].
              1. Set _index_ to _index_ + 1.
              1. If _e_ is not ~empty~, then
                1. If _kind_ is ~key+value~, then
                  1. Let _result_ be CreateArrayFromList(« _e_, _e_ »).
                  1. Perform ? GeneratorYield(CreateIteratorResultObject(_result_, *false*)).
                1. Else,
                  1. Assert: _kind_ is ~value~.
                  1. Perform ? GeneratorYield(CreateIteratorResultObject(_e_, *false*)).
                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by GeneratorYield.
                1. Set _numEntries_ to the number of elements in _entries_.
            1. Return NormalCompletion(~unused~).
          1. Return CreateIteratorFromClosure(_closure_, *"%SetIteratorPrototype%"*, %SetIteratorPrototype%).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%setiteratorprototype%-object">
        <h1>The %SetIteratorPrototype% Object</h1>
        <p>The <dfn>%SetIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Set Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%setiteratorprototype%.next">
          <h1>%SetIteratorPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? <emu-meta suppress-effects="user-code">GeneratorResume(*this* value, ~empty~, *"%SetIteratorPrototype%"*)</emu-meta>.
          </emu-alg>
        </emu-clause>

        <emu-clause oldids="sec-%setiteratorprototype%-@@tostringtag" id="sec-%setiteratorprototype%-%symbol.tostringtag%">
          <h1>%SetIteratorPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Set Iterator"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakmap-objects">
    <h1>WeakMap Objects</h1>
    <p>WeakMaps are collections of key/value pairs where the keys are objects and/or symbols and values may be arbitrary ECMAScript language values. A WeakMap may be queried to see if it contains a key/value pair with a specific key, but no mechanism is provided for enumerating the values it holds as keys. In certain conditions, values which are not live are removed as WeakMap keys, as described in <emu-xref href="#sec-weakref-execution"></emu-xref>.</p>
    <p>An implementation may impose an arbitrarily determined latency between the time a key/value pair of a WeakMap becomes inaccessible and the time when the key/value pair is removed from the WeakMap. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to observe a key of a WeakMap that does not require the observer to present the observed key.</p>
    <p>WeakMaps must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of key/value pairs in the collection. The data structure used in this specification is only intended to describe the required observable semantics of WeakMaps. It is not intended to be a viable implementation model.</p>
    <emu-note>
      <p>WeakMap and WeakSet are intended to provide mechanisms for dynamically associating state with an object or symbol in a manner that does not “leak” memory resources if, in the absence of the WeakMap or WeakSet instance, the object or symbol otherwise became inaccessible and subject to resource reclamation by the implementation's garbage collection mechanisms. This characteristic can be achieved by using an inverted per-object/symbol mapping of WeakMap or WeakSet instances to keys. Alternatively, each WeakMap or WeakSet instance may internally store its key and value data, but this approach requires coordination between the WeakMap or WeakSet implementation and the garbage collector. The following references describe mechanism that may be useful to implementations of WeakMap and WeakSet:</p>
      <p>Barry Hayes. 1997. Ephemerons: a new finalization mechanism. In <i>Proceedings of the 12th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA '97)</i>, A. Michael Berman (Ed.). ACM, New York, NY, USA, 176-183, <a href="http://doi.acm.org/10.1145/263698.263733">http://doi.acm.org/10.1145/263698.263733</a>.</p>
      <p>Alexandra Barros, Roberto Ierusalimschy, Eliminating Cycles in Weak Tables. Journal of Universal Computer Science - J.UCS, vol. 14, no. 21, pp. 3481-3497, 2008, <a href="http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak">http://www.jucs.org/jucs_14_21/eliminating_cycles_in_weak</a></p>
    </emu-note>

    <emu-clause id="sec-weakmap-constructor">
      <h1>The WeakMap Constructor</h1>
      <p>The WeakMap constructor:</p>
      <ul>
        <li>is <dfn>%WeakMap%</dfn>.</li>
        <li>is the initial value of the *"WeakMap"* property of the global object.</li>
        <li>creates and initializes a new WeakMap when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified WeakMap behaviour must include a `super` call to the WeakMap constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakMap.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-weakmap-iterable">
        <h1>WeakMap ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakMap.prototype%"*, « [[WeakMapData]] »).
          1. Set _map_.[[WeakMapData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _map_.
          1. Let _adder_ be ? Get(_map_, *"set"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).
        </emu-alg>
        <emu-note>
          <p>If the parameter _iterable_ is present, it is expected to be an object that implements a %Symbol.iterator% method that returns an iterator object that produces a two element array-like object whose first element is a value that will be used as a WeakMap key and whose second element is the value to associate with that key.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-constructor">
      <h1>Properties of the WeakMap Constructor</h1>
      <p>The WeakMap constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype">
        <h1>WeakMap.prototype</h1>
        <p>The initial value of `WeakMap.prototype` is the WeakMap prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakmap-prototype-object">
      <h1>Properties of the WeakMap Prototype Object</h1>
      <p>The <dfn>WeakMap prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%WeakMap.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakMapData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weakmap.prototype.constructor">
        <h1>WeakMap.prototype.constructor</h1>
        <p>The initial value of `WeakMap.prototype.constructor` is %WeakMap%.</p>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.delete">
        <h1>WeakMap.prototype.delete ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Key]] to ~empty~.
              1. Set _p_.[[Value]] to ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.get">
        <h1>WeakMap.prototype.get ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, return *undefined*.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.has">
        <h1>WeakMap.prototype.has ( _key_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakmap.prototype.set">
        <h1>WeakMap.prototype.set ( _key_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _M_ be the *this* value.
          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).
          1. If CanBeHeldWeakly(_key_) is *false*, throw a *TypeError* exception.
          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do
            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then
              1. Set _p_.[[Value]] to _value_.
              1. Return _M_.
          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.
          1. Append _p_ to _M_.[[WeakMapData]].
          1. Return _M_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakmap.prototype-@@tostringtag" id="sec-weakmap.prototype-%symbol.tostringtag%">
        <h1>WeakMap.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"WeakMap"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakmap-instances">
      <h1>Properties of WeakMap Instances</h1>
      <p>WeakMap instances are ordinary objects that inherit properties from the WeakMap prototype object. WeakMap instances also have a [[WeakMapData]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-weakset-objects">
    <h1>WeakSet Objects</h1>
    <p>WeakSets are collections of objects and/or symbols. A distinct object or symbol may only occur once as an element of a WeakSet's collection. A WeakSet may be queried to see if it contains a specific value, but no mechanism is provided for enumerating the values it holds. In certain conditions, values which are not live are removed as WeakSet elements, as described in <emu-xref href="#sec-weakref-execution"></emu-xref>.</p>
    <p>An implementation may impose an arbitrarily determined latency between the time a value contained in a WeakSet becomes inaccessible and the time when the value is removed from the WeakSet. If this latency was observable to ECMAScript program, it would be a source of indeterminacy that could impact program execution. For that reason, an ECMAScript implementation must not provide any means to determine if a WeakSet contains a particular value that does not require the observer to present the observed value.</p>
    <p>WeakSets must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this specification is only intended to describe the required observable semantics of WeakSets. It is not intended to be a viable implementation model.</p>
    <emu-note>
      <p>See the NOTE in <emu-xref href="#sec-weakmap-objects"></emu-xref>.</p>
    </emu-note>

    <emu-clause id="sec-weakset-constructor">
      <h1>The WeakSet Constructor</h1>
      <p>The WeakSet constructor:</p>
      <ul>
        <li>is <dfn>%WeakSet%</dfn>.</li>
        <li>is the initial value of the *"WeakSet"* property of the global object.</li>
        <li>creates and initializes a new WeakSet when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified WeakSet behaviour must include a `super` call to the WeakSet constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakSet.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-weakset-iterable">
        <h1>WeakSet ( [ _iterable_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakSet.prototype%"*, « [[WeakSetData]] »).
          1. Set _set_.[[WeakSetData]] to a new empty List.
          1. If _iterable_ is either *undefined* or *null*, return _set_.
          1. Let _adder_ be ? Get(_set_, *"add"*).
          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.
          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).
          1. Repeat,
            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
            1. If _next_ is ~done~, return _set_.
            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).
            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-constructor">
      <h1>Properties of the WeakSet Constructor</h1>
      <p>The WeakSet constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weakset.prototype">
        <h1>WeakSet.prototype</h1>
        <p>The initial value of `WeakSet.prototype` is the WeakSet prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weakset-prototype-object">
      <h1>Properties of the WeakSet Prototype Object</h1>
      <p>The <dfn>WeakSet prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%WeakSet.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakSetData]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weakset.prototype.add">
        <h1>WeakSet.prototype.add ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If CanBeHeldWeakly(_value_) is *false*, throw a *TypeError* exception.
          1. For each element _e_ of _S_.[[WeakSetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Return _S_.
          1. Append _value_ to _S_.[[WeakSetData]].
          1. Return _S_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.constructor">
        <h1>WeakSet.prototype.constructor</h1>
        <p>The initial value of `WeakSet.prototype.constructor` is %WeakSet%.</p>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.delete">
        <h1>WeakSet.prototype.delete ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.
          1. For each element _e_ of _S_.[[WeakSetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then
              1. Replace the element of _S_.[[WeakSetData]] whose value is _e_ with an element whose value is ~empty~.
              1. Return *true*.
          1. Return *false*.
        </emu-alg>
        <emu-note>
          <p>The value ~empty~ is used as a specification device to indicate that an entry has been deleted. Actual implementations may take other actions such as physically removing the entry from internal data structures.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-weakset.prototype.has">
        <h1>WeakSet.prototype.has ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).
          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.
          1. For each element _e_ of _S_.[[WeakSetData]], do
            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-weakset.prototype-@@tostringtag" id="sec-weakset.prototype-%symbol.tostringtag%">
        <h1>WeakSet.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"WeakSet"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weakset-instances">
      <h1>Properties of WeakSet Instances</h1>
      <p>WeakSet instances are ordinary objects that inherit properties from the WeakSet prototype object. WeakSet instances also have a [[WeakSetData]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-keyed-collections">
    <h1>Abstract Operations for Keyed Collections</h1>

    <emu-clause id="sec-canonicalizekeyedcollectionkey" type="abstract operation">
      <h1>
        CanonicalizeKeyedCollectionKey (
          _key_: an ECMAScript language value,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _key_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.
        1. Return _key_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-structured-data">
  <h1>Structured Data</h1>

  <emu-clause id="sec-arraybuffer-objects">
    <h1>ArrayBuffer Objects</h1>

    <emu-clause id="sec-arraybuffer-notation">
      <h1>Notation</h1>
      <p>The descriptions below in this section, <emu-xref href="#sec-atomics-object"></emu-xref>, and <emu-xref href="#sec-memory-model"></emu-xref> use the read-modify-write modification function internal data structure.</p>
      <p>A <dfn variants="read-modify-write modification functions">read-modify-write modification function</dfn> is a mathematical function that is represented as an abstract closure that takes two Lists of byte values as arguments and returns a List of byte values. These abstract closures satisfy all of the following properties:</p>
      <ul>
        <li>They perform all their algorithm steps atomically.</li>
        <li>Their individual algorithm steps are not observable.</li>
      </ul>
      <emu-note>
        <p>To aid verifying that a read-modify-write modification function's algorithm steps constitute a pure, mathematical function, the following editorial conventions are recommended:</p>
        <ul>
          <li>They do not access, directly or transitively via invoked abstract operations and abstract closures, any language or specification values except their parameters and captured values.</li>
          <li>They do not invoke, directly or transitively, abstract operations and abstract closures that return Completion Records.</li>
          <li>They do not return Completion Records.</li>
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-fixed-length-and-resizable-arraybuffer-objects">
      <h1>Fixed-length and Resizable ArrayBuffer Objects</h1>
      <p>A <dfn>fixed-length ArrayBuffer</dfn> is an ArrayBuffer whose byte length cannot change after creation.</p>
      <p>A <dfn>resizable ArrayBuffer</dfn> is an ArrayBuffer whose byte length may change after creation via calls to <emu-xref href="#sec-arraybuffer.prototype.resize" title></emu-xref>.</p>
      <p>The kind of ArrayBuffer object that is created depends on the arguments passed to <emu-xref href="#sec-arraybuffer-length" title></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-arraybuffer-objects">
      <h1>Abstract Operations For ArrayBuffer Objects</h1>

      <emu-clause id="sec-allocatearraybuffer" type="abstract operation">
        <h1>
          AllocateArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create an ArrayBuffer.</dd>
        </dl>
        <emu-alg>
          1. Let _slots_ be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».
          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingResizableBuffer_ be *true*; otherwise let _allocatingResizableBuffer_ be *false*.
          1. If _allocatingResizableBuffer_ is *true*, then
            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.
            1. Append [[ArrayBufferMaxByteLength]] to _slots_.
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%ArrayBuffer.prototype%"*, _slots_).
          1. Let _block_ be ? CreateByteDataBlock(_byteLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. If _allocatingResizableBuffer_ is *true*, then
            1. If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.
            1. NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations may throw if, for example, virtual memory cannot be reserved up front.
            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybufferbytelength" type="abstract operation">
        <h1>
          ArrayBufferByteLength (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _order_: ~seq-cst~ or ~unordered~,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then
            1. Let _bufferByteLengthBlock_ be _arrayBuffer_.[[ArrayBufferByteLengthData]].
            1. Let _rawLength_ be GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_).
            1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
            1. Return ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)).
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Return _arrayBuffer_.[[ArrayBufferByteLength]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffercopyanddetach" type="abstract operation">
        <h1>
          ArrayBufferCopyAndDetach (
            _arrayBuffer_: an ECMAScript language value,
            _newLength_: an ECMAScript language value,
            _preserveResizability_: ~preserve-resizability~ or ~fixed-length~,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.
          1. If _newLength_ is *undefined*, then
            1. Let _newByteLength_ be _arrayBuffer_.[[ArrayBufferByteLength]].
          1. Else,
            1. Let _newByteLength_ be ? ToIndex(_newLength_).
          1. If IsDetachedBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.
          1. If _preserveResizability_ is ~preserve-resizability~ and IsFixedLengthArrayBuffer(_arrayBuffer_) is *false*, then
            1. Let _newMaxByteLength_ be _arrayBuffer_.[[ArrayBufferMaxByteLength]].
          1. Else,
            1. Let _newMaxByteLength_ be ~empty~.
          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not *undefined*, throw a *TypeError* exception.
          1. Let _newBuffer_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta>.
          1. Let _copyLength_ be min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]).
          1. Let _fromBlock_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _toBlock_ be _newBuffer_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).
          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a `realloc`.
          1. Perform ! DetachArrayBuffer(_arrayBuffer_).
          1. Return _newBuffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isdetachedbuffer" type="abstract operation">
        <h1>
          IsDetachedBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-detacharraybuffer" type="abstract operation">
        <h1>
          DetachArrayBuffer (
            _arrayBuffer_: an ArrayBuffer,
            optional _key_: anything,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>skip global checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.
          1. If _key_ is not present, set _key_ to *undefined*.
          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not _key_, throw a *TypeError* exception.
          1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.
          1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>Detaching an ArrayBuffer instance disassociates the Data Block used as its backing store from the instance and sets the byte length of the buffer to 0.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-clonearraybuffer" type="abstract operation">
        <h1>
          CloneArrayBuffer (
            _srcBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _srcByteOffset_: a non-negative integer,
            _srcLength_: a non-negative integer,
          ): either a normal completion containing an ArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It creates a new ArrayBuffer whose data is a copy of _srcBuffer_'s data over the range starting at _srcByteOffset_ and continuing for _srcLength_ bytes.</dd>
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_srcBuffer_) is *false*.
          1. Let _targetBuffer_ be ? <emu-meta suppress-effects="user-code">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta>.
          1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].
          1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).
          1. Return _targetBuffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getarraybuffermaxbytelengthoption" type="abstract operation">
        <h1>
          GetArrayBufferMaxByteLengthOption (
            _options_: an ECMAScript language value,
          ): either a normal completion containing either a non-negative integer or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _options_ is not an Object, return ~empty~.
          1. Let _maxByteLength_ be ? Get(_options_, *"maxByteLength"*).
          1. If _maxByteLength_ is *undefined*, return ~empty~.
          1. Return ? ToIndex(_maxByteLength_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostresizearraybuffer" type="host-defined abstract operation">
        <h1>
          HostResizeArrayBuffer (
            _buffer_: an ArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It gives the host an opportunity to perform implementation-defined resizing of _buffer_. If the host chooses not to handle resizing of _buffer_, it may return ~unhandled~ for the default behaviour.</dd>
        </dl>

        <p>The implementation of HostResizeArrayBuffer must conform to the following requirements:</p>
        <ul>
          <li>The abstract operation does not detach _buffer_.</li>
          <li>If the abstract operation completes normally with ~handled~, _buffer_.[[ArrayBufferByteLength]] is _newByteLength_.</li>
        </ul>

        <p>The default implementation of HostResizeArrayBuffer is to return NormalCompletion(~unhandled~).</p>
      </emu-clause>

      <emu-clause id="sec-isfixedlengtharraybuffer" type="abstract operation">
        <h1>
          IsFixedLengthArrayBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _arrayBuffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunsignedelementtype" type="abstract operation">
        <h1>
          IsUnsignedElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It verifies if the argument _type_ is an unsigned TypedArray element type.</dd>
        </dl>
        <emu-alg>
          1. If _type_ is one of ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, or ~biguint64~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isunclampedintegerelementtype" type="abstract operation">
        <h1>
          IsUnclampedIntegerElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It verifies if the argument _type_ is an Integer TypedArray element type not including ~uint8clamped~.</dd>
        </dl>
        <emu-alg>
          1. If _type_ is one of ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, or ~uint32~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isbigintelementtype" type="abstract operation">
        <h1>
          IsBigIntElementType (
            _type_: a TypedArray element type,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It verifies if the argument _type_ is a BigInt TypedArray element type.</dd>
        </dl>
        <emu-alg>
          1. If _type_ is either ~biguint64~ or ~bigint64~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isnotearconfiguration" type="abstract operation">
        <h1>
          IsNoTearConfiguration (
            _type_: a TypedArray element type,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If IsUnclampedIntegerElementType(_type_) is *true*, return *true*.
          1. If IsBigIntElementType(_type_) is *true* and _order_ is neither ~init~ nor ~unordered~, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rawbytestonumeric" type="abstract operation" oldids="sec-rawbytestonumber">
        <h1>
          RawBytesToNumeric (
            _type_: a TypedArray element type,
            _rawBytes_: a List of byte values,
            _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. If _type_ is ~float16~, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary16 value.
            1. If _value_ is a NaN, return *NaN*.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is ~float32~, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.
            1. If _value_ is a NaN, return *NaN*.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is ~float64~, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.
            1. If _value_ is a NaN, return *NaN*.
            1. Return the Number value that corresponds to _value_.
          1. If IsUnsignedElementType(_type_) is *true*, then
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
          1. Else,
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ × 8.
          1. If IsBigIntElementType(_type_) is *true*, return the BigInt value that corresponds to _intValue_.
          1. Otherwise, return the Number value that corresponds to _intValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getrawbytesfromsharedblock" type="abstract operation">
        <h1>
          GetRawBytesFromSharedBlock (
            _block_: a Shared Data Block,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
          1. Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.
          1. Append _readEvent_ to _eventsRecord_.[[EventList]].
          1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].
          1. Return _rawValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getvaluefrombuffer" type="abstract operation">
        <h1>
          GetValueFromBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~ or ~unordered~,
            optional _isLittleEndian_: a Boolean,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Assert: _block_ is a Shared Data Block.
            1. Let _rawValue_ be GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_).
          1. Else,
            1. Let _rawValue_ be a List whose elements are bytes from _block_ at indices in the interval from _byteIndex_ (inclusive) to _byteIndex_ + _elementSize_ (exclusive).
          1. Assert: The number of elements in _rawValue_ is _elementSize_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numerictorawbytes" type="abstract operation" oldids="sec-numbertorawbytes">
        <h1>
          NumericToRawBytes (
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isLittleEndian_: a Boolean,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _type_ is ~float16~, then
            1. Let _rawBytes_ be a List whose elements are the 2 bytes that are the result of converting _value_ to IEEE 754-2019 binary16 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary16 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is ~float32~, then
            1. Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is ~float64~, then
            1. Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format NaN encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else,
            1. Let _n_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
            1. Let _conversionOperation_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
            1. Let _intValue_ be ℝ(! _conversionOperation_(_value_)).
            1. If _intValue_ ≥ 0, then
              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. The bytes are ordered in little endian order.
            1. Else,
              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. The bytes are ordered in little endian order.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. Return _rawBytes_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setvalueinbuffer" type="abstract operation">
        <h1>
          SetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _isTypedArray_: a Boolean,
            _order_: ~seq-cst~, ~unordered~, or ~init~,
            optional _isLittleEndian_: a Boolean,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
            1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventsRecord_.[[EventList]].
          1. Else,
            1. Store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" type="abstract operation">
        <h1>
          GetModifySetValueInBuffer (
            _arrayBuffer_: an ArrayBuffer or a SharedArrayBuffer,
            _byteIndex_: a non-negative integer,
            _type_: a TypedArray element type,
            _value_: a Number or a BigInt,
            _op_: a read-modify-write modification function,
          ): a Number or a BigInt
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
            1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
            1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.
            1. Append _rmwEvent_ to _eventsRecord_.[[EventList]].
            1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
          1. Else,
            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].
            1. Let _rawBytesModified_ be _op_(_rawBytesRead_, _rawBytes_).
            1. Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].
          1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-arraybuffer-constructor">
      <h1>The ArrayBuffer Constructor</h1>
      <p>The ArrayBuffer constructor:</p>
      <ul>
        <li>is <dfn>%ArrayBuffer%</dfn>.</li>
        <li>is the initial value of the *"ArrayBuffer"* property of the global object.</li>
        <li>creates and initializes a new ArrayBuffer when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified ArrayBuffer behaviour must include a `super` call to the ArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `ArrayBuffer.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-arraybuffer-length">
        <h1>ArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _byteLength_ be ? ToIndex(_length_).
          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).
          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-constructor">
      <h1>Properties of the ArrayBuffer Constructor</h1>
      <p>The ArrayBuffer constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-arraybuffer.isview">
        <h1>ArrayBuffer.isView ( _arg_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _arg_ is not an Object, return *false*.
          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype">
        <h1>ArrayBuffer.prototype</h1>
        <p>The initial value of `ArrayBuffer.prototype` is the ArrayBuffer prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-get-arraybuffer-@@species" id="sec-get-arraybuffer-%symbol.species%">
        <h1>get ArrayBuffer [ %Symbol.species% ]</h1>
        <p>`ArrayBuffer[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p><emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> normally uses its *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour for the <emu-xref href="#sec-arraybuffer.prototype.slice" title></emu-xref> method by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>Properties of the ArrayBuffer Prototype Object</h1>
      <p>The <dfn>ArrayBuffer prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%ArrayBuffer.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength</h1>
        <p>`ArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.constructor">
        <h1>ArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `ArrayBuffer.prototype.constructor` is %ArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.detached">
        <h1>get ArrayBuffer.prototype.detached</h1>
        <p>`ArrayBuffer.prototype.detached` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Return IsDetachedBuffer(_O_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.maxbytelength">
        <h1>get ArrayBuffer.prototype.maxByteLength</h1>
        <p>`ArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.
          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then
            1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Else,
            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-arraybuffer.prototype.resizable">
        <h1>get ArrayBuffer.prototype.resizable</h1>
        <p>`ArrayBuffer.prototype.resizable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.resize">
        <h1>ArrayBuffer.prototype.resize ( _newLength_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _newByteLength_ be ? ToIndex(_newLength_).
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
          1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).
          1. If _hostHandled_ is ~handled~, return *undefined*.
          1. Let _oldBlock_ be _O_.[[ArrayBufferData]].
          1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).
          1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).
          1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).
          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as in-place growth or shrinkage.
          1. Set _O_.[[ArrayBufferData]] to _newBlock_.
          1. Set _O_.[[ArrayBufferByteLength]] to _newByteLength_.
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _len_ be _O_.[[ArrayBufferByteLength]].
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _first_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _first_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).
          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.
          1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.
          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
          1. NOTE: Side-effects of the above steps may have detached or resized _O_.
          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Let _currentLen_ be _O_.[[ArrayBufferByteLength]].
          1. If _first_ &lt; _currentLen_, then
            1. Let _count_ be min(_newLen_, _currentLen_ - _first_).
            1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfer">
        <h1>ArrayBuffer.prototype.transfer ( [ _newLength_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.transfertofixedlength">
        <h1>ArrayBuffer.prototype.transferToFixedLength ( [ _newLength_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-arraybuffer.prototype-@@tostringtag" id="sec-arraybuffer.prototype-%symbol.tostringtag%">
        <h1>ArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"ArrayBuffer"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-arraybuffer-instances">
      <h1>Properties of ArrayBuffer Instances</h1>
      <p>ArrayBuffer instances inherit properties from the ArrayBuffer prototype object. ArrayBuffer instances each have an [[ArrayBufferData]] internal slot, an [[ArrayBufferByteLength]] internal slot, and an [[ArrayBufferDetachKey]] internal slot. ArrayBuffer instances which are resizable each have an [[ArrayBufferMaxByteLength]] internal slot.</p>
      <p>ArrayBuffer instances whose [[ArrayBufferData]] is *null* are considered to be detached and all operators to access or modify data contained in the ArrayBuffer instance will fail.</p>
      <p>ArrayBuffer instances whose [[ArrayBufferDetachKey]] is set to a value other than *undefined* need to have all DetachArrayBuffer calls passing that same "detach key" as an argument, otherwise a TypeError will result. This internal slot is only ever set by certain embedding environments, not by algorithms in this specification.</p>
    </emu-clause>

    <emu-clause id="sec-resizable-arraybuffer-guidelines">
      <h1>Resizable ArrayBuffer Guidelines</h1>
      <emu-note>
        <p>The following are guidelines for ECMAScript programmers working with resizable ArrayBuffer.</p>
        <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differs greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
        <p>When choosing a value for the *"maxByteLength"* option for resizable ArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that *"maxByteLength"* does not exceed 1,073,741,824 (2<sup>30</sup> bytes or 1GiB).</p>
        <p>Please note that successfully constructing a resizable ArrayBuffer for a particular maximum size does not guarantee that future resizes will succeed.</p>
      </emu-note>

      <emu-note>
        <p>The following are guidelines for ECMAScript implementers implementing resizable ArrayBuffer.</p>
        <p>Resizable ArrayBuffer can be implemented as copying upon resize, as in-place growth via reserving virtual memory up front, or as a combination of both for different values of the constructor's *"maxByteLength"* option.</p>
        <p>If a host is multi-tenanted (i.e. it runs many ECMAScript applications simultaneously), such as a web browser, and its implementations choose to implement in-place growth by reserving virtual memory, we recommend that both 32-bit and 64-bit implementations throw for values of *"maxByteLength"* ≥ 1GiB to 1.5GiB. This is to reduce the likelihood a single application can exhaust the virtual memory address space and to reduce interoperability risk.</p>
        <p>If a host does not have virtual memory, such as those running on embedded devices without an MMU, or if a host only implements resizing by copying, it may accept any <emu-not-ref>Number value for</emu-not-ref> the *"maxByteLength"* option. However, we recommend a *RangeError* be thrown if a memory block of the requested size can never be allocated. For example, if the requested size is greater than the maximum amount of usable memory on the device.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sharedarraybuffer-objects">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="sec-fixed-length-and-growable-sharedarraybuffer-objects">
      <h1>Fixed-length and Growable SharedArrayBuffer Objects</h1>
      <p>A <dfn>fixed-length SharedArrayBuffer</dfn> is a SharedArrayBuffer whose byte length cannot change after creation.</p>
      <p>A <dfn>growable SharedArrayBuffer</dfn> is a SharedArrayBuffer whose byte length may increase after creation via calls to <emu-xref href="#sec-sharedarraybuffer.prototype.grow" title></emu-xref>.</p>
      <p>The kind of SharedArrayBuffer object that is created depends on the arguments passed to <emu-xref href="#sec-sharedarraybuffer-length" title></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-sharedarraybuffer-objects">
      <h1>Abstract Operations for SharedArrayBuffer Objects</h1>

      <emu-clause id="sec-allocatesharedarraybuffer" type="abstract operation">
        <h1>
          AllocateSharedArrayBuffer (
            _constructor_: a constructor,
            _byteLength_: a non-negative integer,
            optional _maxByteLength_: a non-negative integer or ~empty~,
          ): either a normal completion containing a SharedArrayBuffer or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create a SharedArrayBuffer.</dd>
        </dl>
        <emu-alg>
          1. Let _slots_ be « [[ArrayBufferData]] ».
          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingGrowableBuffer_ be *true*; otherwise let _allocatingGrowableBuffer_ be *false*.
          1. If _allocatingGrowableBuffer_ is *true*, then
            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.
            1. Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.
          1. Else,
            1. Append [[ArrayBufferByteLength]] to _slots_.
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *"%SharedArrayBuffer.prototype%"*, _slots_).
          1. If _allocatingGrowableBuffer_ is *true*, let _allocLength_ be _maxByteLength_; otherwise let _allocLength_ be _byteLength_.
          1. Let _block_ be ? CreateSharedByteDataBlock(_allocLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. If _allocatingGrowableBuffer_ is *true*, then
            1. Assert: _byteLength_ ≤ _maxByteLength_.
            1. Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).
            1. Perform SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~).
            1. Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.
            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.
          1. Else,
            1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-issharedarraybuffer" type="abstract operation">
        <h1>
          IsSharedArrayBuffer (
            _obj_: an ArrayBuffer or a SharedArrayBuffer,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It tests whether an object is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either.</dd>
        </dl>
        <emu-alg>
          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].
          1. If _bufferData_ is *null*, return *false*.
          1. If _bufferData_ is a Data Block, return *false*.
          1. Assert: _bufferData_ is a Shared Data Block.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostgrowsharedarraybuffer" type="host-defined abstract operation">
        <h1>
          HostGrowSharedArrayBuffer (
            _buffer_: a SharedArrayBuffer,
            _newByteLength_: a non-negative integer,
          ): either a normal completion containing either ~handled~ or ~unhandled~, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It gives the host an opportunity to perform implementation-defined growing of _buffer_. If the host chooses not to handle growing of _buffer_, it may return ~unhandled~ for the default behaviour.</dd>
        </dl>
        <p>The implementation of HostGrowSharedArrayBuffer must conform to the following requirements:</p>
        <ul>
          <li>If the abstract operation does not complete normally with ~unhandled~, and _newByteLength_ &lt; the current byte length of the _buffer_ or _newByteLength_ > _buffer_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.</li>
          <li>Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record. If the abstract operation completes normally with ~handled~, a WriteSharedMemory or ReadModifyWriteSharedMemory event whose [[Order]] is ~seq-cst~, [[Payload]] is NumericToRawBytes(~biguint64~, _newByteLength_, _isLittleEndian_), [[Block]] is _buffer_.[[ArrayBufferByteLengthData]], [[ByteIndex]] is 0, and [[ElementSize]] is 8 is added to the surrounding agent's candidate execution such that racing calls to `SharedArrayBuffer.prototype.grow` are not "lost", i.e. silently do nothing.</li>
        </ul>

        <emu-note>
          <p>The second requirement above is intentionally vague about how or when the current byte length of _buffer_ is read. Because the byte length must be updated via an atomic read-modify-write operation on the underlying hardware, architectures that use load-link/store-conditional or load-exclusive/store-exclusive instruction pairs may wish to keep the paired instructions close in the instruction stream. As such, SharedArrayBuffer.prototype.grow itself does not perform bounds checking on _newByteLength_ before calling HostGrowSharedArrayBuffer, nor is there a requirement on when the current byte length is read.</p>
          <p>This is in contrast with HostResizeArrayBuffer, which is guaranteed that the value of _newByteLength_ is ≥ 0 and ≤ _buffer_.[[ArrayBufferMaxByteLength]].</p>
        </emu-note>

        <p>The default implementation of HostGrowSharedArrayBuffer is to return NormalCompletion(~unhandled~).</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-sharedarraybuffer-constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor:</p>
      <ul>
        <li>is <dfn>%SharedArrayBuffer%</dfn>.</li>
        <li>is the initial value of the *"SharedArrayBuffer"* property of the global object, if that property is present (see below).</li>
        <li>creates and initializes a new SharedArrayBuffer when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a `super` call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `SharedArrayBuffer.prototype` built-in methods.</li>
      </ul>

      <p>Whenever a host does not provide concurrent access to SharedArrayBuffers it may omit the *"SharedArrayBuffer"* property of the global object.</p>

      <emu-note>
        <p>Unlike an `ArrayBuffer`, a `SharedArrayBuffer` cannot become detached, and its internal [[ArrayBufferData]] slot is never *null*.</p>
      </emu-note>

      <emu-clause id="sec-sharedarraybuffer-length">
        <h1>SharedArrayBuffer ( _length_ [ , _options_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _byteLength_ be ? ToIndex(_length_).
          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).
          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-constructor">
      <h1>Properties of the SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-sharedarraybuffer.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>The initial value of `SharedArrayBuffer.prototype` is the SharedArrayBuffer prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer-@@species" id="sec-sharedarraybuffer-%symbol.species%">
        <h1>get SharedArrayBuffer [ %Symbol.species% ]</h1>
        <p>`SharedArrayBuffer[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-prototype-object">
      <h1>Properties of the SharedArrayBuffer Prototype Object</h1>
      <p>The <dfn>SharedArrayBuffer prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%SharedArrayBuffer.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.bytelength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>
        <p>`SharedArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _length_ be ArrayBufferByteLength(_O_, ~seq-cst~).
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `SharedArrayBuffer.prototype.constructor` is %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.grow">
        <h1>SharedArrayBuffer.prototype.grow ( _newLength_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _newByteLength_ be ? ToIndex(_newLength_).
          1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).
          1. If _hostHandled_ is ~handled~, return *undefined*.
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].
          1. Let _currentByteLengthRawBytes_ be GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~).
          1. Let _newByteLengthRawBytes_ be NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_).
          1. Repeat,
            1. NOTE: This is a compare-and-exchange loop to ensure that parallel, racing grows of the same buffer are totally ordered, are not lost, and do not silently do nothing. The loop exits if it was able to attempt to grow uncontended.
            1. Let _currentByteLength_ be ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)).
            1. If _newByteLength_ = _currentByteLength_, return *undefined*.
            1. If _newByteLength_ &lt; _currentByteLength_ or _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.
            1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.
            1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, throw a *RangeError* exception.
            1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step captures the requirement that implementations that run out of memory must throw a *RangeError*.
            1. Let _readByteLengthRawBytes_ be AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_).
            1. If ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) is *true*, return *undefined*.
            1. Set _currentByteLengthRawBytes_ to _readByteLengthRawBytes_.
        </emu-alg>
        <emu-note>
          <p>Spurious failures of the compare-exchange to update the length are prohibited. If the bounds checking for the new length passes and the implementation is not out of memory, a ReadModifyWriteSharedMemory event (i.e. a successful compare-exchange) is always added into the candidate execution.</p>
          <p>Parallel calls to SharedArrayBuffer.prototype.grow are totally ordered. For example, consider two racing calls: `sab.grow(10)` and `sab.grow(20)`. One of the two calls is guaranteed to win the race. The call to `sab.grow(10)` will never shrink `sab` even if `sab.grow(20)` happened first; in that case it will instead throw a RangeError.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.growable">
        <h1>get SharedArrayBuffer.prototype.growable</h1>
        <p>`SharedArrayBuffer.prototype.growable` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-sharedarraybuffer.prototype.maxbytelength">
        <h1>get SharedArrayBuffer.prototype.maxByteLength</h1>
        <p>`SharedArrayBuffer.prototype.maxByteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then
            1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Else,
            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].
          1. Return 𝔽(_length_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-sharedarraybuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice ( _start_, _end_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _len_ be ArrayBufferByteLength(_O_, ~seq-cst~).
          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _relativeStart_ = -∞, let _first_ be 0.
          1. Else if _relativeStart_ &lt; 0, let _first_ be max(_len_ + _relativeStart_, 0).
          1. Else, let _first_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).
          1. If _relativeEnd_ = -∞, let _final_ be 0.
          1. Else if _relativeEnd_ &lt; 0, let _final_ be max(_len_ + _relativeEnd_, 0).
          1. Else, let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).
          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).
          1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferData]] is _O_.[[ArrayBufferData]], throw a *TypeError* exception.
          1. If ArrayBufferByteLength(_new_, ~seq-cst~) &lt; _newLen_, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-sharedarraybuffer.prototype.toString,sec-sharedarraybuffer.prototype-@@tostringtag" id="sec-sharedarraybuffer.prototype-%symbol.tostringtag%">
        <h1>SharedArrayBuffer.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"SharedArrayBuffer"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-sharedarraybuffer-instances">
      <h1>Properties of SharedArrayBuffer Instances</h1>
      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot. SharedArrayBuffer instances which are not growable each have an [[ArrayBufferByteLength]] internal slot. SharedArrayBuffer instances which are growable each have an [[ArrayBufferByteLengthData]] internal slot and an [[ArrayBufferMaxByteLength]] internal slot.</p>

      <emu-note>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-growable-sharedarraybuffer-guidelines">
      <h1>Growable SharedArrayBuffer Guidelines</h1>
      <emu-note>
        <p>The following are guidelines for ECMAScript programmers working with growable SharedArrayBuffer.</p>
        <p>We recommend that programs be tested in their deployment environments where possible. The amount of available physical memory differ greatly between hardware devices. Similarly, virtual memory subsystems also differ greatly between hardware devices as well as operating systems. An application that runs without out-of-memory errors on a 64-bit desktop web browser could run out of memory on a 32-bit mobile web browser.</p>
        <p>When choosing a value for the *"maxByteLength"* option for growable SharedArrayBuffer, we recommend that the smallest possible size for the application be chosen. We recommend that *"maxByteLength"* does not exceed 1073741824, or 1GiB.</p>
        <p>Please note that successfully constructing a growable SharedArrayBuffer for a particular maximum size does not guarantee that future grows will succeed.</p>
        <p>Not all loads of a growable SharedArrayBuffer's length are synchronizing ~seq-cst~ loads. Loads of the length that are for bounds-checking of an integer-indexed property access, e.g. `u8[idx]`, are not synchronizing. In general, in the absence of explicit synchronization, one property access being in-bound does not imply a subsequent property access in the same agent is also in-bound. In contrast, explicit loads of the length via the `length` and `byteLength` getters on SharedArrayBuffer, %TypedArray%.prototype, and DataView.prototype are synchronizing. Loads of the length that are performed by built-in methods to check if a TypedArray is entirely out-of-bounds are also synchronizing.</p>
      </emu-note>

      <emu-note>
        <p>The following are guidelines for ECMAScript implementers implementing growable SharedArrayBuffer.</p>
        <p>We recommend growable SharedArrayBuffer be implemented as in-place growth via reserving virtual memory up front.</p>
        <p>Because grow operations can happen in parallel with memory accesses on a growable SharedArrayBuffer, the constraints of the memory model require that even unordered accesses do not "tear" (bits of their values will not be mixed). In practice, this means the underlying data block of a growable SharedArrayBuffer cannot be grown by being copied without stopping the world. We do not recommend stopping the world as an implementation strategy because it introduces a serialization point and is slow.</p>
        <p>Grown memory must appear zeroed from the moment of its creation, including to any racy accesses in parallel. This can be accomplished via zero-filled-on-demand virtual memory pages, or careful synchronization if manually zeroing memory.</p>
        <p>Integer-indexed property access on TypedArray views of growable SharedArrayBuffers is intended to be optimizable similarly to access on TypedArray views of non-growable SharedArrayBuffers, because integer-indexed property loads on are not synchronizing on the underlying buffer's length (see programmer guidelines above). For example, bounds checks for property accesses may still be hoisted out of loops.</p>
        <p>In practice it is difficult to implement growable SharedArrayBuffer by copying on hosts that do not have virtual memory, such as those running on embedded devices without an MMU. Memory usage behaviour of growable SharedArrayBuffers on such hosts may significantly differ from that of hosts with virtual memory. Such hosts should clearly communicate memory usage expectations to users.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-dataview-objects">
    <h1>DataView Objects</h1>

    <emu-clause id="sec-abstract-operations-for-dataview-objects">
      <h1>Abstract Operations For DataView Objects</h1>

      <emu-clause id="sec-dataview-with-buffer-witness-records">
        <h1>DataView With Buffer Witness Records</h1>
        <p>A <dfn variants="DataView With Buffer Witness Records">DataView With Buffer Witness Record</dfn> is a Record value used to encapsulate a DataView along with a cached byte length of the viewed buffer. It is used to help ensure there is a single shared memory read event of the byte length data block when the viewed buffer is a growable SharedArrayBuffers.</p>
        <p>DataView With Buffer Witness Records have the fields listed in <emu-xref href="#table-dataview-with-buffer-witness-record-fields"></emu-xref>.</p>
        <emu-table id="table-dataview-with-buffer-witness-record-fields" caption="DataView With Buffer Witness Record Fields">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Object]]
              </td>
              <td>
                a DataView
              </td>
              <td>
                The DataView object whose buffer's byte length is loaded.
              </td>
            </tr>
            <tr>
              <td>
                [[CachedBufferByteLength]]
              </td>
              <td>
                a non-negative integer or ~detached~
              </td>
              <td>
                The byte length of the object's [[ViewedArrayBuffer]] when the Record was created.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-makedataviewwithbufferwitnessrecord" type="abstract operation">
        <h1>
          MakeDataViewWithBufferWitnessRecord (
            _obj_: a DataView,
            _order_: ~seq-cst~ or ~unordered~,
          ): a DataView With Buffer Witness Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, then
            1. Let _byteLength_ be ~detached~.
          1. Else,
            1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).
          1. Return the DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewbytelength" type="abstract operation">
        <h1>
          GetViewByteLength (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a non-negative integer
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: IsViewOutOfBounds(_viewRecord_) is *false*.
          1. Let _view_ be _viewRecord_.[[Object]].
          1. If _view_.[[ByteLength]] is not ~auto~, return _view_.[[ByteLength]].
          1. Assert: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) is *false*.
          1. Let _byteOffset_ be _view_.[[ByteOffset]].
          1. Let _byteLength_ be _viewRecord_.[[CachedBufferByteLength]].
          1. Assert: _byteLength_ is not ~detached~.
          1. Return _byteLength_ - _byteOffset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-isviewoutofbounds" type="abstract operation">
        <h1>
          IsViewOutOfBounds (
            _viewRecord_: a DataView With Buffer Witness Record,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _view_ be _viewRecord_.[[Object]].
          1. Let _bufferByteLength_ be _viewRecord_.[[CachedBufferByteLength]].
          1. Assert: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.
          1. If _bufferByteLength_ is ~detached~, return *true*.
          1. Let _byteOffsetStart_ be _view_.[[ByteOffset]].
          1. If _view_.[[ByteLength]] is ~auto~, then
            1. Let _byteOffsetEnd_ be _bufferByteLength_.
          1. Else,
            1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _view_.[[ByteLength]].
          1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.
          1. NOTE: 0-length DataViews are not considered out-of-bounds.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getviewvalue" type="abstract operation">
        <h1>
          GetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
          ): either a normal completion containing either a Number or a BigInt, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used by functions on DataView instances to retrieve values from the view's buffer.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Return GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-setviewvalue" type="abstract operation">
        <h1>
          SetViewValue (
            _view_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
            _isLittleEndian_: an ECMAScript language value,
            _type_: a TypedArray element type,
            _value_: an ECMAScript language value,
          ): either a normal completion containing *undefined* or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used by functions on DataView instances to store values into the view's buffer.</dd>
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. If IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).
          1. Otherwise, let _numberValue_ be ? ToNumber(_value_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).
          1. Let _elementSize_ be the Element Size value specified in <emu-xref href="#table-the-typedarray-constructors"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Perform SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-dataview-constructor">
      <h1>The DataView Constructor</h1>
      <p>The DataView constructor:</p>
      <ul>
        <li>is <dfn>%DataView%</dfn>.</li>
        <li>is the initial value of the *"DataView"* property of the global object.</li>
        <li>creates and initializes a new DataView when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified DataView behaviour must include a `super` call to the DataView constructor to create and initialize subclass instances with the internal state necessary to support the `DataView.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-dataview-buffer-byteoffset-bytelength">
        <h1>DataView ( _buffer_ [ , _byteOffset_ [ , _byteLength_ ] ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).
          1. Let _offset_ be ? ToIndex(_byteOffset_).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).
          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.
          1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).
          1. If _byteLength_ is *undefined*, then
            1. If _bufferIsFixedLength_ is *true*, then
              1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.
            1. Else,
              1. Let _viewByteLength_ be ~auto~.
          1. Else,
            1. Let _viewByteLength_ be ? ToIndex(_byteLength_).
            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%DataView.prototype%"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Set _bufferByteLength_ to ArrayBufferByteLength(_buffer_, ~seq-cst~).
          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.
          1. If _byteLength_ is not *undefined*, then
            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.
          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.
          1. Set _O_.[[ByteLength]] to _viewByteLength_.
          1. Set _O_.[[ByteOffset]] to _offset_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-constructor">
      <h1>Properties of the DataView Constructor</h1>
      <p>The DataView constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-dataview.prototype">
        <h1>DataView.prototype</h1>
        <p>The initial value of `DataView.prototype` is the DataView prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-dataview-prototype-object">
      <h1>Properties of the DataView Prototype Object</h1>
      <p>The <dfn>DataView prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%DataView.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], or [[ByteOffset]] internal slot.</li>
      </ul>

      <emu-clause id="sec-get-dataview.prototype.buffer">
        <h1>get DataView.prototype.buffer</h1>
        <p>`DataView.prototype.buffer` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.bytelength">
        <h1>get DataView.prototype.byteLength</h1>
        <p>`DataView.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _size_ be GetViewByteLength(_viewRecord_).
          1. Return 𝔽(_size_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-get-dataview.prototype.byteoffset">
        <h1>get DataView.prototype.byteOffset</h1>
        <p>`DataView.prototype.byteOffset` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).
          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).
          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Return 𝔽(_offset_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.constructor">
        <h1>DataView.prototype.constructor</h1>
        <p>The initial value of `DataView.prototype.constructor` is %DataView%.</p>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbigint64">
        <h1>DataView.prototype.getBigInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbiguint64">
        <h1>DataView.prototype.getBigUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat16">
        <h1>DataView.prototype.getFloat16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat32">
        <h1>DataView.prototype.getFloat32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getfloat64">
        <h1>DataView.prototype.getFloat64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint8">
        <h1>DataView.prototype.getInt8 ( _byteOffset_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, *true*, ~int8~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint16">
        <h1>DataView.prototype.getInt16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getint32">
        <h1>DataView.prototype.getInt32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint8">
        <h1>DataView.prototype.getUint8 ( _byteOffset_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? GetViewValue(_view_, _byteOffset_, *true*, ~uint8~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint16">
        <h1>DataView.prototype.getUint16 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getuint32">
        <h1>DataView.prototype.getUint32 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? GetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbigint64">
        <h1>DataView.prototype.setBigInt64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~bigint64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbiguint64">
        <h1>DataView.prototype.setBigUint64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~biguint64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat16">
        <h1>DataView.prototype.setFloat16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat32">
        <h1>DataView.prototype.setFloat32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setfloat64">
        <h1>DataView.prototype.setFloat64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~float64~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint8">
        <h1>DataView.prototype.setInt8 ( _byteOffset_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, *true*, ~int8~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint16">
        <h1>DataView.prototype.setInt16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setint32">
        <h1>DataView.prototype.setInt32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~int32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint8">
        <h1>DataView.prototype.setUint8 ( _byteOffset_, _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. Return ? SetViewValue(_view_, _byteOffset_, *true*, ~uint8~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint16">
        <h1>DataView.prototype.setUint16 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint16~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setuint32">
        <h1>DataView.prototype.setUint32 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _view_ be the *this* value.
          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.
          1. Return ? SetViewValue(_view_, _byteOffset_, _littleEndian_, ~uint32~, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-dataview.prototype-@@tostringtag" id="sec-dataview.prototype-%symbol.tostringtag%">
        <h1>DataView.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"DataView"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-dataview-instances">
      <h1>Properties of DataView Instances</h1>
      <p>DataView instances are ordinary objects that inherit properties from the DataView prototype object. DataView instances each have [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], and [[ByteOffset]] internal slots.</p>
      <emu-note>
        <p>The value of the [[DataView]] internal slot is not used within this specification. The simple presence of that internal slot is used within the specification to identify objects created using the DataView constructor.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-atomics-object">
    <h1>The Atomics Object</h1>
    <p>The Atomics object:</p>
    <ul>
      <li>is <dfn>%Atomics%</dfn>.</li>
      <li>is the initial value of the *"Atomics"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events. When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs. The rules that govern shared-memory communication are provided by the memory model, defined below.</p>
    <emu-note>
      <p>For informative guidelines for programming and implementing shared memory in ECMAScript, please see the notes at the end of the memory model section.</p>
    </emu-note>

    <emu-clause id="sec-waiter-record">
      <h1>Waiter Record</h1>
      <p>A <dfn variants="Waiter Records">Waiter Record</dfn> is a Record value used to denote a particular call to `Atomics.wait` or `Atomics.waitAsync`.</p>
      <p>A Waiter Record has fields listed in <emu-xref href="#table-waiterrecord"></emu-xref>.</p>
      <emu-table id="table-waiterrecord" caption="Waiter Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[AgentSignifier]]
            </td>
            <td>
              an agent signifier
            </td>
            <td>
              The agent that called `Atomics.wait` or `Atomics.waitAsync`.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseCapability]]
            </td>
            <td>
              a PromiseCapability Record or ~blocking~
            </td>
            <td>
              If denoting a call to `Atomics.waitAsync`, the resulting promise, otherwise ~blocking~.
            </td>
          </tr>
          <tr>
            <td>
              [[TimeoutTime]]
            </td>
            <td>
              a non-negative extended mathematical value
            </td>
            <td>
              The earliest time by which timeout may be triggered; computed using time values.
            </td>
          </tr>
          <tr>
            <td>
              [[Result]]
            </td>
            <td>
              *"ok"* or *"timed-out"*
            </td>
            <td>
              The return value of the call.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-waiterlist-records" oldids="sec-waiterlist-objects">
      <h1>WaiterList Records</h1>
      <p>A <dfn variants="WaiterList Records">WaiterList Record</dfn> is used to explain waiting and notification of agents via `Atomics.wait`, `Atomics.waitAsync`, and `Atomics.notify`.</p>
      <p>A WaiterList Record has fields listed in <emu-xref href="#table-waiterlistrecord"></emu-xref>.</p>
      <emu-table id="table-waiterlistrecord" caption="WaiterList Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Waiters]]
            </td>
            <td>
              a List of Waiter Records
            </td>
            <td>
              The calls to `Atomics.wait` or `Atomics.waitAsync` that are waiting on the location with which this WaiterList is associated.
            </td>
          </tr>
          <tr>
            <td>
              [[MostRecentLeaveEvent]]
            </td>
            <td>
              a Synchronize event or ~empty~
            </td>
            <td>
              The event of the most recent leaving of its critical section, or ~empty~ if its critical section has never been entered.
            </td>
          </tr>
        </table>
      </emu-table>
      <p>There can be multiple Waiter Records in a WaiterList with the same agent signifier.</p>
      <p>The agent cluster has a store of WaiterList Records; the store is indexed by (_block_, _i_), where _block_ is a Shared Data Block and _i_ a byte offset into the memory of _block_. WaiterList Records are agent-independent: a lookup in the store of WaiterList Records by (_block_, _i_) will result in the same WaiterList Record in any agent in the agent cluster.</p>
      <p>Each WaiterList Record has a <dfn variants="critical sections">critical section</dfn> that controls exclusive access to that WaiterList Record during evaluation. Only a single agent may enter a WaiterList Record's critical section at one time. Entering and leaving a WaiterList Record's critical section is controlled by the abstract operations EnterCriticalSection and LeaveCriticalSection. Operations on a WaiterList Record—adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, setting and retrieving the Synchronize event—may only be performed by agents that have entered the WaiterList Record's critical section.</p>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-atomics">
      <h1>Abstract Operations for Atomics</h1>

      <emu-clause id="sec-validateintegertypedarray" type="abstract operation" oldids="sec-validatesharedintegertypedarray">
        <h1>
          ValidateIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _waitable_: a Boolean,
          ): either a normal completion containing a TypedArray With Buffer Witness Record, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _taRecord_ be ? ValidateTypedArray(_typedArray_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.
          1. If _waitable_ is *true*, then
            1. If _typedArray_.[[TypedArrayName]] is neither *"Int32Array"* nor *"BigInt64Array"*, throw a *TypeError* exception.
          1. Else,
            1. Let _type_ be TypedArrayElementType(_typedArray_).
            1. If IsUnclampedIntegerElementType(_type_) is *false* and IsBigIntElementType(_type_) is *false*, throw a *TypeError* exception.
          1. Return _taRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccess" type="abstract operation">
        <h1>
          ValidateAtomicAccess (
            _taRecord_: a TypedArray With Buffer Witness Record,
            _requestIndex_: an ECMAScript language value,
          ): either a normal completion containing an integer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _length_ be TypedArrayLength(_taRecord_).
          1. Let _accessIndex_ be ? ToIndex(_requestIndex_).
          1. Assert: _accessIndex_ ≥ 0.
          1. If _accessIndex_ ≥ _length_, throw a *RangeError* exception.
          1. Let _typedArray_ be _taRecord_.[[Object]].
          1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Return (_accessIndex_ × _elementSize_) + _offset_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validateatomicaccessonintegertypedarray" type="abstract operation">
        <h1>
          ValidateAtomicAccessOnIntegerTypedArray (
            _typedArray_: an ECMAScript language value,
            _requestIndex_: an ECMAScript language value,
          ): either a normal completion containing an integer or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *false*).
          1. Return ? ValidateAtomicAccess(_taRecord_, _requestIndex_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-revalidateatomicaccess" type="abstract operation">
        <h1>
          RevalidateAtomicAccess (
            _typedArray_: a TypedArray,
            _byteIndexInBuffer_: an integer,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>This operation revalidates the index within the backing buffer for atomic operations after all argument coercions are performed in Atomics methods, as argument coercions can have arbitrary side effects, which could cause the buffer to become out of bounds. This operation does not throw when _typedArray_'s backing buffer is a SharedArrayBuffer.</dd>
        </dl>
        <emu-alg>
          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~).
          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.
          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.
          1. Assert: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].
          1. If _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]], throw a *RangeError* exception.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getwaiterlist" type="abstract operation">
        <h1>
          GetWaiterList (
            _block_: a Shared Data Block,
            _i_: a non-negative integer that is evenly divisible by 4,
          ): a WaiterList Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.
          1. Return the WaiterList Record that is referenced by the pair (_block_, _i_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-entercriticalsection" type="abstract operation">
        <h1>
          EnterCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is not in the critical section for any WaiterList Record.
          1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).
          1. If _WL_.[[MostRecentLeaveEvent]] is not ~empty~, then
            1. NOTE: A _WL_ whose critical section has been entered at least once has a Synchronize event set by LeaveCriticalSection.
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
            1. Let _enterEvent_ be a new Synchronize event.
            1. Append _enterEvent_ to _eventsRecord_.[[EventList]].
            1. Append (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]].
          1. Return ~unused~.
        </emu-alg>
        <p>EnterCriticalSection has <dfn>contention</dfn> when an agent attempting to enter the critical section must wait for another agent to leave it. When there is no contention, FIFO order of EnterCriticalSection calls is observable. When there is contention, an implementation may choose an arbitrary order but may not cause an agent to wait indefinitely.</p>
      </emu-clause>

      <emu-clause id="sec-leavecriticalsection" type="abstract operation">
        <h1>
          LeaveCriticalSection (
            _WL_: a WaiterList Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _leaveEvent_ be a new Synchronize event.
          1. Append _leaveEvent_ to _eventsRecord_.[[EventList]].
          1. Set _WL_.[[MostRecentLeaveEvent]] to _leaveEvent_.
          1. Leave the critical section for _WL_.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-addwaiter" type="abstract operation">
        <h1>
          AddWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Assert: There is no Waiter Record in _WL_.[[Waiters]] whose [[PromiseCapability]] field is _waiterRecord_.[[PromiseCapability]] and whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]].
          1. Append _waiterRecord_ to _WL_.[[Waiters]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiter" type="abstract operation">
        <h1>
          RemoveWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.
          1. Remove _waiterRecord_ from _WL_.[[Waiters]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-removewaiters" type="abstract operation">
        <h1>
          RemoveWaiters (
            _WL_: a WaiterList Record,
            _c_: a non-negative integer or +&infin;,
          ): a List of Waiter Records
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Let _len_ be the number of elements in _WL_.[[Waiters]].
          1. Let _n_ be min(_c_, _len_).
          1. Let _L_ be a List whose elements are the first _n_ elements of _WL_.[[Waiters]].
          1. Remove the first _n_ elements of _WL_.[[Waiters]].
          1. Return _L_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-suspendthisagent" type="abstract operation" oldids="sec-suspend,sec-suspendagent">
        <h1>
          SuspendThisAgent (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.
          1. Let _thisAgent_ be AgentSignifier().
          1. Assert: _waiterRecord_.[[AgentSignifier]] is _thisAgent_.
          1. Assert: _waiterRecord_.[[PromiseCapability]] is ~blocking~.
          1. Assert: AgentCanSuspend() is *true*.
          1. Perform LeaveCriticalSection(_WL_) and suspend the surrounding agent until the time is _waiterRecord_.[[TimeoutTime]], performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. The surrounding agent can only wake from suspension due to a timeout or due to another agent calling NotifyWaiter with arguments _WL_ and _thisAgent_ (i.e. via a call to `Atomics.notify`).
          1. Perform EnterCriticalSection(_WL_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-notifywaiter" type="abstract operation">
        <h1>
          NotifyWaiter (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for _WL_.
          1. If _waiterRecord_.[[PromiseCapability]] is ~blocking~, then
            1. Wake the agent whose signifier is _waiterRecord_.[[AgentSignifier]] from suspension.
            1. NOTE: This causes the agent to resume execution in SuspendThisAgent.
          1. Else if AgentSignifier() is _waiterRecord_.[[AgentSignifier]], then
            1. Let _promiseCapability_ be _waiterRecord_.[[PromiseCapability]].
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] »).
          1. Else,
            1. Perform EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]).
          1. Return ~unused~.
        </emu-alg>
        <emu-note>
          <p>An agent must not access another agent's promise capability in any capacity beyond passing it to the host.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueresolveinagentjob" type="abstract operation">
        <h1>
          EnqueueResolveInAgentJob (
            _agentSignifier_: an agent signifier,
            _promiseCapability_: a PromiseCapability Record,
            _resolution_: *"ok"* or *"timed-out"*,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _resolveJob_ be a new Job Abstract Closure with no parameters that captures _agentSignifier_, _promiseCapability_, and _resolution_ and performs the following steps when called:
            1. Assert: AgentSignifier() is _agentSignifier_.
            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »).
            1. Return ~unused~.
          1. Let _realmInTargetAgent_ be ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).
          1. Assert: _agentSignifier_ is _realmInTargetAgent_.[[AgentSignifier]].
          1. Perform HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dowait" type="abstract operation">
        <h1>
          DoWait (
            _mode_: ~sync~ or ~async~,
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _timeout_: an ECMAScript language value,
          ): either a normal completion containing either an Object, *"not-equal"*, *"timed-out"*, or *"ok"*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).
          1. Let _buffer_ be _taRecord_.[[Object]].[[ViewedArrayBuffer]].
          1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.
          1. Let _i_ be ? ValidateAtomicAccess(_taRecord_, _index_).
          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
          1. If _arrayTypeName_ is *"BigInt64Array"*, let _v_ be ? ToBigInt64(_value_).
          1. Else, let _v_ be ? ToInt32(_value_).
          1. Let _q_ be ? ToNumber(_timeout_).
          1. If _q_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _t_ be +∞; else if _q_ is *-∞*<sub>𝔽</sub>, let _t_ be 0; else let _t_ be max(ℝ(_q_), 0).
          1. If _mode_ is ~sync~ and AgentCanSuspend() is *false*, throw a *TypeError* exception.
          1. Let _block_ be _buffer_.[[ArrayBufferData]].
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Let _byteIndexInBuffer_ be (_i_ × 4) + _offset_.
          1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).
          1. If _mode_ is ~sync~, then
            1. Let _promiseCapability_ be ~blocking~.
            1. Let _resultObject_ be *undefined*.
          1. Else,
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _resultObject_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform EnterCriticalSection(_WL_).
          1. Let _elementType_ be TypedArrayElementType(_typedArray_).
          1. Let _w_ be GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
          1. If _v_ ≠ _w_, then
            1. Perform LeaveCriticalSection(_WL_).
            1. If _mode_ is ~sync~, return *"not-equal"*.
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*).
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"not-equal"*).
            1. Return _resultObject_.
          1. If _t_ = 0 and _mode_ is ~async~, then
            1. NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid unnecessary Promise jobs.
            1. Perform LeaveCriticalSection(_WL_).
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *false*).
            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, *"timed-out"*).
            1. Return _resultObject_.
          1. Let _thisAgent_ be AgentSignifier().
          1. Let _now_ be the time value (UTC) identifying the current time.
          1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.
          1. Let _timeoutTime_ be ℝ(_now_) + _t_ + _additionalTimeout_.
          1. NOTE: When _t_ is +∞, _timeoutTime_ is also +∞.
          1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* }.
          1. Perform AddWaiter(_WL_, _waiterRecord_).
          1. If _mode_ is ~sync~, then
            1. Perform SuspendThisAgent(_WL_, _waiterRecord_).
          1. Else if _timeoutTime_ is finite, then
            1. Perform EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_).
          1. Perform LeaveCriticalSection(_WL_).
          1. If _mode_ is ~sync~, return _waiterRecord_.[[Result]].
          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"async"*, *true*).
          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *"value"*, _promiseCapability_.[[Promise]]).
          1. Return _resultObject_.
        </emu-alg>
        <emu-note>
          <p>_additionalTimeout_ allows implementations to pad timeouts as necessary, such as for reducing power consumption or coarsening timer resolution to mitigate timing attacks. This value may differ from call to call of DoWait.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-enqueueatomicswaitasynctimeoutjob" type="abstract operation">
        <h1>
          EnqueueAtomicsWaitAsyncTimeoutJob (
            _WL_: a WaiterList Record,
            _waiterRecord_: a Waiter Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _timeoutJob_ be a new Job Abstract Closure with no parameters that captures _WL_ and _waiterRecord_ and performs the following steps when called:
            1. Perform EnterCriticalSection(_WL_).
            1. If _WL_.[[Waiters]] contains _waiterRecord_, then
              1. Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.
              1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values).
              1. Set _waiterRecord_.[[Result]] to *"timed-out"*.
              1. Perform RemoveWaiter(_WL_, _waiterRecord_).
              1. Perform NotifyWaiter(_WL_, _waiterRecord_).
            1. Perform LeaveCriticalSection(_WL_).
            1. Return ~unused~.
          1. Let _now_ be the time value (UTC) identifying the current time.
          1. Let _currentRealm_ be the current Realm Record.
          1. Perform HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomiccompareexchangeinsharedblock" type="abstract operation">
        <h1>
          AtomicCompareExchangeInSharedBlock (
            _block_: a Shared Data Block,
            _byteIndexInBuffer_: an integer,
            _elementSize_: a non-negative integer,
            _expectedBytes_: a List of byte values,
            _replacementBytes_: a List of byte values,
          ): a List of byte values
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
              1. Return _newBytes_.
            1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.
          1. Else,
            1. Let _event_ be ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }.
          1. Append _event_ to _eventsRecord_.[[EventList]].
          1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
          1. Return _rawBytesRead_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" type="abstract operation">
        <h1>
          AtomicReadModifyWrite (
            _typedArray_: an ECMAScript language value,
            _index_: an ECMAScript language value,
            _value_: an ECMAScript language value,
            _op_: a read-modify-write modification function,
          ): either a normal completion containing either a Number or a BigInt, or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>_op_ takes two List of byte values arguments and returns a List of byte values. This operation atomically loads a value, combines it with another value, and stores the combination. It returns the loaded value.</dd>
        </dl>
        <emu-alg>
          1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
          1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).
          1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).
          1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
          1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
          1. Let _elementType_ be TypedArrayElementType(_typedArray_).
          1. Return GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistbitwiseop" type="abstract operation">
        <h1>
          ByteListBitwiseOp (
            _op_: `&amp;`, `^`, or `|`,
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): a List of byte values
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>The operation atomically performs a bitwise operation on all byte values of the arguments and returns a List of byte values.</dd>
        </dl>
        <emu-alg>
          1. Assert: _xBytes_ and _yBytes_ have the same number of elements.
          1. Let _result_ be a new empty List.
          1. Let _i_ be 0.
          1. For each element _xByte_ of _xBytes_, do
            1. Let _yByte_ be _yBytes_[_i_].
            1. If _op_ is `&amp;`, then
              1. Let _resultByte_ be the result of applying the bitwise AND operation to _xByte_ and _yByte_.
            1. Else if _op_ is `^`, then
              1. Let _resultByte_ be the result of applying the bitwise exclusive OR (XOR) operation to _xByte_ and _yByte_.
            1. Else,
              1. Assert: _op_ is `|`.
              1. Let _resultByte_ be the result of applying the bitwise inclusive OR operation to _xByte_ and _yByte_.
            1. Set _i_ to _i_ + 1.
            1. Append _resultByte_ to _result_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bytelistequal" type="abstract operation">
        <h1>
          ByteListEqual (
            _xBytes_: a List of byte values,
            _yBytes_: a List of byte values,
          ): a Boolean
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.
          1. Let _i_ be 0.
          1. For each element _xByte_ of _xBytes_, do
            1. Let _yByte_ be _yBytes_[_i_].
            1. If _xByte_ ≠ _yByte_, return *false*.
            1. Set _i_ to _i_ + 1.
          1. Return *true*.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-atomics.add">
      <h1>Atomics.add ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _typedArray_ and performs the following steps atomically when called:
          1. Let _type_ be TypedArrayElementType(_typedArray_).
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).
          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).
          1. If _x_ is a Number, then
            1. Let _sum_ be Number::add(_x_, _y_).
          1. Else,
            1. Assert: _x_ is a BigInt.
            1. Let _sum_ be BigInt::add(_x_, _y_).
          1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).
          1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements.
          1. Return _sumBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.and">
      <h1>Atomics.and ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return ByteListBitwiseOp(`&amp;`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.compareexchange">
      <h1>Atomics.compareExchange ( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. If _typedArray_.[[ContentType]] is ~bigint~, then
          1. Let _expected_ be ? ToBigInt(_expectedValue_).
          1. Let _replacement_ be ? ToBigInt(_replacementValue_).
        1. Else,
          1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).
          1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).
        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).
        1. If IsSharedArrayBuffer(_buffer_) is *true*, then
          1. Let _rawBytesRead_ be AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).
        1. Else,
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].
        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange">
      <h1>Atomics.exchange ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return _newBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree ( _size_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _n_ be ? ToIntegerOrInfinity(_size_).
        1. Let _AR_ be the Agent Record of the surrounding agent.
        1. If _n_ = 1, return _AR_.[[IsLockFree1]].
        1. If _n_ = 2, return _AR_.[[IsLockFree2]].
        1. If _n_ = 4, return *true*.
        1. If _n_ = 8, return _AR_.[[IsLockFree8]].
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>This function is an optimization primitive. The intuition is that if the atomic step of an atomic primitive (`compareExchange`, `load`, `store`, `add`, `sub`, `and`, `or`, `xor`, or `exchange`) on a datum of size _n_ bytes will be performed without the surrounding agent acquiring a lock outside the _n_ bytes comprising the datum, then `Atomics.isLockFree`(_n_) will return *true*. High-performance algorithms will use this function to determine whether to use locks or atomic operations in critical sections. If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</p>
        <p>`Atomics.isLockFree`(4) always returns *true* as that can be supported on all known relevant hardware. Being able to assume this will generally simplify programs.</p>
        <p>Regardless of the value returned by this function, all atomic operations are guaranteed to be atomic. For example, they will never have a visible operation take place in the middle of the operation (e.g., "tearing").</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-atomics.load" oldids="sec-atomicload">
      <h1>Atomics.load ( _typedArray_, _index_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.or">
      <h1>Atomics.or ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).
        1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Perform SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~).
        1. Return _v_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.sub">
      <h1>Atomics.sub ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _typedArray_ and performs the following steps atomically when called:
          1. Let _type_ be TypedArrayElementType(_typedArray_).
          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).
          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).
          1. If _x_ is a Number, then
            1. Let _difference_ be Number::subtract(_x_, _y_).
          1. Else,
            1. Assert: _x_ is a BigInt.
            1. Let _difference_ be BigInt::subtract(_x_, _y_).
          1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).
          1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements.
          1. Return _differenceBytes_.
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>This function puts the surrounding agent in a wait queue and suspends it until notified or until the wait times out, returning a String differentiating those cases.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.waitasync">
      <h1>Atomics.waitAsync ( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>This function returns a Promise that is resolved when the calling agent is notified or the timeout is reached.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.notify">
      <h1>Atomics.notify ( _typedArray_, _index_, _count_ )</h1>
      <p>This function notifies some agents that are sleeping in the wait queue.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccess(_taRecord_, _index_).
        1. If _count_ is *undefined*, then
          1. Let _c_ be +∞.
        1. Else,
          1. Let _intCount_ be ? ToIntegerOrInfinity(_count_).
          1. Let _c_ be max(_intCount_, 0).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. If IsSharedArrayBuffer(_buffer_) is *false*, return *+0*<sub>𝔽</sub>.
        1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, _c_).
        1. For each element _W_ of _S_, do
          1. Perform NotifyWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. Let _n_ be the number of elements in _S_.
        1. Return 𝔽(_n_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.xor">
      <h1>Atomics.xor ( _typedArray_, _index_, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:
          1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_).
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-atomics-@@tostringtag" id="sec-atomics-%symbol.tostringtag%">
      <h1>Atomics [ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Atomics"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-json-object">
    <h1>The JSON Object</h1>
    <p>The JSON object:</p>
    <ul>
      <li>is <dfn>%JSON%</dfn>.</li>
      <li>is the initial value of the *"JSON"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>contains two functions, `parse` and `stringify`, that are used to parse and construct JSON texts.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>
    <p>The JSON Data Interchange Format is defined in ECMA-404. The JSON interchange format used in this specification is exactly that described by ECMA-404. Conforming implementations of `JSON.parse` and `JSON.stringify` must support the exact interchange format described in the ECMA-404 specification without any deletions or extensions to the format.</p>

    <emu-clause id="sec-json.parse">
      <h1>JSON.parse ( _text_ [ , _reviver_ ] )</h1>
      <p>This function parses a JSON text (a JSON-formatted String) and produces an ECMAScript language value. The JSON format represents literals, arrays, and objects with a syntax similar to the syntax for ECMAScript literals, Array Initializers, and Object Initializers. After parsing, JSON objects are realized as ECMAScript objects. JSON arrays are realized as ECMAScript Array instances. JSON strings, numbers, booleans, and null are realized as ECMAScript Strings, Numbers, Booleans, and *null*.</p>
      <p>The optional _reviver_ parameter is a function that takes two parameters, _key_ and _value_. It can filter and transform the results. It is called with each of the _key_/_value_ pairs produced by the parse, and its return value is used instead of the original value. If it returns what it received, the structure is not modified. If it returns *undefined* then the property is deleted from the result.</p>
      <emu-alg>
        1. Let _jsonString_ be ? ToString(_text_).
        1. Let _unfiltered_ be ? ParseJSON(_jsonString_).
        1. If IsCallable(_reviver_) is *true*, then
          1. Let _root_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Let _rootName_ be the empty String.
          1. Perform ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_).
          1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).
        1. Else,
          1. Return _unfiltered_.
      </emu-alg>
      <p>The *"length"* property of this function is *2*<sub>𝔽</sub>.</p>

      <emu-clause id="sec-ParseJSON" type="abstract operation">
        <h1>
          ParseJSON (
            _text_: a String,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. [id="step-json-parse-validate"] If StringToCodePoints(_text_) is not a valid JSON text as specified in ECMA-404, throw a *SyntaxError* exception.
          1. Let _scriptString_ be the string-concatenation of *"("*, _text_, and *");"*.
          1. [id="step-json-parse-parse"] Let _script_ be ParseText(_scriptString_, |Script|).
          1. NOTE: The early error rules defined in <emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref> have special handling for the above invocation of ParseText.
          1. Assert: _script_ is a Parse Node.
          1. [id="step-json-parse-eval"] Let _result_ be ! <emu-meta suppress-effects="user-code">Evaluation of _script_</emu-meta>.
          1. NOTE: The PropertyDefinitionEvaluation semantics defined in <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> have special handling for the above evaluation.
          1. [id="step-json-parse-assert-type"] Assert: _result_ is either a String, a Number, a Boolean, an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|, or *null*.
          1. Return _result_.
        </emu-alg>
        <p>It is not permitted for a conforming implementation of `JSON.parse` to extend the JSON grammars. If an implementation wishes to support a modified or extended JSON interchange format it must do so by defining a different parse function.</p>
        <emu-note>
          <p>Valid JSON text is a subset of the ECMAScript |PrimaryExpression| syntax. Step <emu-xref href="#step-json-parse-validate"></emu-xref> verifies that _jsonString_ conforms to that subset, and step <emu-xref href="#step-json-parse-assert-type"></emu-xref> asserts that evaluation returns a value of an appropriate type.</p>
          <p>However, because <emu-xref href="#sec-runtime-semantics-propertydefinitionevaluation"></emu-xref> behaves differently during ParseJSON, the same source text can produce different results when evaluated as a |PrimaryExpression| rather than as JSON. Furthermore, the Early Error for duplicate *"__proto__"* properties in object literals, which likewise does not apply during ParseJSON, means that not all texts accepted by ParseJSON are valid as a |PrimaryExpression|, despite matching the grammar.</p>
        </emu-note>
        <emu-note>
          <p>In the case where there are duplicate name Strings within an object, lexically preceding values for the same key shall be overwritten.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-internalizejsonproperty" type="abstract operation">
        <h1>
          InternalizeJSONProperty (
            _holder_: an Object,
            _name_: a String,
            _reviver_: a function object,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-note>
          <p>This algorithm intentionally does not throw an exception if either [[Delete]] or CreateDataProperty return *false*.</p>
        </emu-note>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _val_ be ? Get(_holder_, _name_).
          1. If _val_ is an Object, then
            1. Let _isArray_ be ? IsArray(_val_).
            1. If _isArray_ is *true*, then
              1. Let _len_ be ? LengthOfArrayLike(_val_).
              1. Let _I_ be 0.
              1. Repeat, while _I_ &lt; _len_,
                1. Let _prop_ be ! ToString(𝔽(_I_)).
                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _prop_, _reviver_).
                1. If _newElement_ is *undefined*, then
                  1. Perform ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_prop_).
                1. Else,
                  1. Perform ? CreateDataProperty(_val_, _prop_, _newElement_).
                1. Set _I_ to _I_ + 1.
            1. Else,
              1. Let _keys_ be ? EnumerableOwnProperties(_val_, ~key~).
              1. For each String _P_ of _keys_, do
                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_, _reviver_).
                1. If _newElement_ is *undefined*, then
                  1. Perform ? <emu-meta effects="user-code">_val_.[[Delete]]</emu-meta>(_P_).
                1. Else,
                  1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).
          1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-json.stringify">
      <h1>JSON.stringify ( _value_ [ , _replacer_ [ , _space_ ] ] )</h1>
      <p>This function returns a String in UTF-16 encoded JSON format representing an ECMAScript language value, or *undefined*. It can take three parameters. The _value_ parameter is an ECMAScript language value, which is usually an object or array, although it can also be a String, Boolean, Number or *null*. The optional _replacer_ parameter is either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that acts as an inclusion list for selecting the object properties that will be stringified. The optional _space_ parameter is a String or Number that allows the result to have white space injected into it to improve human readability.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _stack_ be a new empty List.
        1. Let _indent_ be the empty String.
        1. Let _PropertyList_ be *undefined*.
        1. Let _ReplacerFunction_ be *undefined*.
        1. If _replacer_ is an Object, then
          1. If IsCallable(_replacer_) is *true*, then
            1. Set _ReplacerFunction_ to _replacer_.
          1. Else,
            1. Let _isArray_ be ? IsArray(_replacer_).
            1. If _isArray_ is *true*, then
              1. Set _PropertyList_ to a new empty List.
              1. Let _len_ be ? LengthOfArrayLike(_replacer_).
              1. Let _k_ be 0.
              1. Repeat, while _k_ &lt; _len_,
                1. Let _prop_ be ! ToString(𝔽(_k_)).
                1. Let _v_ be ? Get(_replacer_, _prop_).
                1. Let _item_ be *undefined*.
                1. If _v_ is a String, then
                  1. Set _item_ to _v_.
                1. Else if _v_ is a Number, then
                  1. Set _item_ to ! ToString(_v_).
                1. Else if _v_ is an Object, then
                  1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).
                1. If _item_ is not *undefined* and _PropertyList_ does not contain _item_, then
                  1. Append _item_ to _PropertyList_.
                1. Set _k_ to _k_ + 1.
        1. If _space_ is an Object, then
          1. If _space_ has a [[NumberData]] internal slot, then
            1. Set _space_ to ? ToNumber(_space_).
          1. Else if _space_ has a [[StringData]] internal slot, then
            1. Set _space_ to ? ToString(_space_).
        1. If _space_ is a Number, then
          1. Let _spaceMV_ be ! ToIntegerOrInfinity(_space_).
          1. Set _spaceMV_ to min(10, _spaceMV_).
          1. If _spaceMV_ &lt; 1, let _gap_ be the empty String; otherwise let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).
        1. Else if _space_ is a String, then
          1. If the length of _space_ ≤ 10, let _gap_ be _space_; otherwise let _gap_ be the substring of _space_ from 0 to 10.
        1. Else,
          1. Let _gap_ be the empty String.
        1. Let _wrapper_ be OrdinaryObjectCreate(%Object.prototype%).
        1. Perform ! CreateDataPropertyOrThrow(_wrapper_, the empty String, _value_).
        1. Let _state_ be the JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.
        1. Return ? SerializeJSONProperty(_state_, the empty String, _wrapper_).
      </emu-alg>
      <p>The *"length"* property of this function is *3*<sub>𝔽</sub>.</p>
      <emu-note>
        <p>JSON structures are allowed to be nested to any depth, but they must be acyclic. If _value_ is or contains a cyclic structure, then this function must throw a *TypeError* exception. This is an example of a value that cannot be stringified:</p>
        <pre><code class="javascript">
          a = [];
          a[0] = a;
          my_text = JSON.stringify(a); // This must throw a TypeError.
        </code></pre>
      </emu-note>
      <emu-note>
        <p>Symbolic primitive values are rendered as follows:</p>
        <ul>
          <li>
            The *null* value is rendered in JSON text as the String value *"null"*.
          </li>
          <li>
            The *undefined* value is not rendered.
          </li>
          <li>
            The *true* value is rendered in JSON text as the String value *"true"*.
          </li>
          <li>
            The *false* value is rendered in JSON text as the String value *"false"*.
          </li>
        </ul>
      </emu-note>
      <emu-note>
        <p>String values are wrapped in QUOTATION MARK (`"`) code units. The code units `"` and `\\` are escaped with `\\` prefixes. Control characters code units are replaced with escape sequences `\\u`HHHH, or with the shorter forms, `\\b` (BACKSPACE), `\\f` (FORM FEED), `\\n` (LINE FEED), `\\r` (CARRIAGE RETURN), `\\t` (CHARACTER TABULATION).</p>
      </emu-note>
      <emu-note>
        <p>Finite numbers are stringified as if by calling ToString(_number_). *NaN* and *Infinity* regardless of sign are represented as the String value *"null"*.</p>
      </emu-note>
      <emu-note>
        <p>Values that do not have a JSON representation (such as *undefined* and functions) do not produce a String. Instead they produce the *undefined* value. In arrays these values are represented as the String value *"null"*. In objects an unrepresentable value causes the property to be excluded from stringification.</p>
      </emu-note>
      <emu-note>
        <p>An object is rendered as U+007B (LEFT CURLY BRACKET) followed by zero or more properties, separated with a U+002C (COMMA), closed with a U+007D (RIGHT CURLY BRACKET). A property is a quoted String representing the property name, a U+003A (COLON), and then the stringified property value. An array is rendered as an opening U+005B (LEFT SQUARE BRACKET) followed by zero or more values, separated with a U+002C (COMMA), closed with a U+005D (RIGHT SQUARE BRACKET).</p>
      </emu-note>

      <emu-clause id="sec-json-serialization-record">
        <h1>JSON Serialization Record</h1>
        <p>A <dfn variants="JSON Serialization Records">JSON Serialization Record</dfn> is a Record value used to enable serialization to the JSON format.</p>
        <p>JSON Serialization Records have the fields listed in <emu-xref href="#table-json-serialization-record"></emu-xref>.</p>
        <emu-table id="table-json-serialization-record" caption="JSON Serialization Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[ReplacerFunction]]</td>
              <td>a function object or *undefined*</td>
              <td>A function that can supply replacement values for object properties (from JSON.stringify's _replacer_ parameter).</td>
            </tr>
            <tr>
              <td>[[PropertyList]]</td>
              <td>either a List of Strings or *undefined*</td>
              <td>The names of properties to include when serializing a non-array object (from JSON.stringify's _replacer_ parameter).</td>
            </tr>
            <tr>
              <td>[[Gap]]</td>
              <td>a String</td>
              <td>The unit of indentation (from JSON.stringify's _space_ parameter).</td>
            </tr>
            <tr>
              <td>[[Stack]]</td>
              <td>a List of Objects</td>
              <td>The set of nested objects that are in the process of being serialized. Used to detect cyclic structures.</td>
            </tr>
            <tr>
              <td>[[Indent]]</td>
              <td>a String</td>
              <td>The current indentation.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-serializejsonproperty" type="abstract operation">
        <h1>
          SerializeJSONProperty (
            _state_: a JSON Serialization Record,
            _key_: a String,
            _holder_: an Object,
          ): either a normal completion containing either a String or *undefined*, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _value_ be ? Get(_holder_, _key_).
          1. If _value_ is an Object or _value_ is a BigInt, then
            1. Let _toJSON_ be ? GetV(_value_, *"toJSON"*).
            1. If IsCallable(_toJSON_) is *true*, then
              1. Set _value_ to ? Call(_toJSON_, _value_, « _key_ »).
          1. If _state_.[[ReplacerFunction]] is not *undefined*, then
            1. Set _value_ to ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).
          1. If _value_ is an Object, then
            1. If _value_ has a [[NumberData]] internal slot, then
              1. Set _value_ to ? ToNumber(_value_).
            1. Else if _value_ has a [[StringData]] internal slot, then
              1. Set _value_ to ? ToString(_value_).
            1. Else if _value_ has a [[BooleanData]] internal slot, then
              1. Set _value_ to _value_.[[BooleanData]].
            1. Else if _value_ has a [[BigIntData]] internal slot, then
              1. Set _value_ to _value_.[[BigIntData]].
          1. If _value_ is *null*, return *"null"*.
          1. If _value_ is *true*, return *"true"*.
          1. If _value_ is *false*, return *"false"*.
          1. If _value_ is a String, return QuoteJSONString(_value_).
          1. If _value_ is a Number, then
            1. If _value_ is finite, return ! ToString(_value_).
            1. Return *"null"*.
          1. If _value_ is a BigInt, throw a *TypeError* exception.
          1. If _value_ is an Object and IsCallable(_value_) is *false*, then
            1. Let _isArray_ be ? IsArray(_value_).
            1. If _isArray_ is *true*, return ? SerializeJSONArray(_state_, _value_).
            1. Return ? SerializeJSONObject(_state_, _value_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-quotejsonstring" type="abstract operation">
        <h1>
          QuoteJSONString (
            _value_: a String,
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It wraps _value_ in 0x0022 (QUOTATION MARK) code units and escapes certain other code units within it. This operation interprets _value_ as a sequence of UTF-16 encoded code points, as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>.</dd>
        </dl>
        <emu-alg>
          1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).
          1. For each code point _C_ of StringToCodePoints(_value_), do
            1. If _C_ is listed in the “Code Point” column of <emu-xref href="#table-json-single-character-escapes"></emu-xref>, then
              1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the “Escape Sequence” column of the corresponding row.
            1. Else if _C_ has a numeric value less than 0x0020 (SPACE) or _C_ has the same numeric value as a leading surrogate or trailing surrogate, then
              1. Let _unit_ be the code unit whose numeric value is the numeric value of _C_.
              1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).
            1. Else,
              1. Set _product_ to the string-concatenation of _product_ and UTF16EncodeCodePoint(_C_).
          1. Set _product_ to the string-concatenation of _product_ and the code unit 0x0022 (QUOTATION MARK).
          1. Return _product_.
        </emu-alg>
        <emu-table id="table-json-single-character-escapes" caption="JSON Single Character Escape Sequences">
          <table>
            <thead>
              <tr>
                <th>
                  Code Point
                </th>
                <th>
                  Unicode Character Name
                </th>
                <th>
                  Escape Sequence
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                U+0008
              </td>
              <td>
                BACKSPACE
              </td>
              <td>
                `\\b`
              </td>
            </tr>
            <tr>
              <td>
                U+0009
              </td>
              <td>
                CHARACTER TABULATION
              </td>
              <td>
                `\\t`
              </td>
            </tr>
            <tr>
              <td>
                U+000A
              </td>
              <td>
                LINE FEED (LF)
              </td>
              <td>
                `\\n`
              </td>
            </tr>
            <tr>
              <td>
                U+000C
              </td>
              <td>
                FORM FEED (FF)
              </td>
              <td>
                `\\f`
              </td>
            </tr>
            <tr>
              <td>
                U+000D
              </td>
              <td>
                CARRIAGE RETURN (CR)
              </td>
              <td>
                `\\r`
              </td>
            </tr>
            <tr>
              <td>
                U+0022
              </td>
              <td>
                QUOTATION MARK
              </td>
              <td>
                `\\"`
              </td>
            </tr>
            <tr>
              <td>
                U+005C
              </td>
              <td>
                REVERSE SOLIDUS
              </td>
              <td>
                `\\\\`
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unicodeescape" type="abstract operation">
        <h1>
          UnicodeEscape (
            _C_: a code unit,
          ): a String
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It represents _C_ as a Unicode escape sequence.</dd>
        </dl>
        <emu-alg>
          1. Let _n_ be the numeric value of _C_.
          1. Assert: _n_ ≤ 0xFFFF.
          1. Let _hex_ be the String representation of _n_, formatted as a lowercase hexadecimal number.
          1. Return the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *"u"*, and StringPad(_hex_, 4, *"0"*, ~start~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonobject" type="abstract operation">
        <h1>
          SerializeJSONObject (
            _state_: a JSON Serialization Record,
            _value_: an Object,
          ): either a normal completion containing a String or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It serializes an object.</dd>
        </dl>
        <emu-alg>
          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.
          1. Append _value_ to _state_.[[Stack]].
          1. Let _stepBack_ be _state_.[[Indent]].
          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].
          1. If _state_.[[PropertyList]] is not *undefined*, then
            1. Let _K_ be _state_.[[PropertyList]].
          1. Else,
            1. Let _K_ be ? EnumerableOwnProperties(_value_, ~key~).
          1. Let _partial_ be a new empty List.
          1. For each element _P_ of _K_, do
            1. Let _strP_ be ? SerializeJSONProperty(_state_, _P_, _value_).
            1. If _strP_ is not *undefined*, then
              1. Let _member_ be QuoteJSONString(_P_).
              1. Set _member_ to the string-concatenation of _member_ and *":"*.
              1. If _state_.[[Gap]] is not the empty String, then
                1. Set _member_ to the string-concatenation of _member_ and the code unit 0x0020 (SPACE).
              1. Set _member_ to the string-concatenation of _member_ and _strP_.
              1. Append _member_ to _partial_.
          1. If _partial_ is empty, then
            1. Let _final_ be *"{}"*.
          1. Else,
            1. If _state_.[[Gap]] is the empty String, then
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"{"*, _properties_, and *"}"*.
            1. Else,
              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"{"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepBack_, and *"}"*.
          1. Remove the last element of _state_.[[Stack]].
          1. Set _state_.[[Indent]] to _stepBack_.
          1. Return _final_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-serializejsonarray" type="abstract operation">
        <h1>
          SerializeJSONArray (
            _state_: a JSON Serialization Record,
            _value_: an ECMAScript language value,
          ): either a normal completion containing a String or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It serializes an array.</dd>
        </dl>
        <emu-alg>
          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.
          1. Append _value_ to _state_.[[Stack]].
          1. Let _stepBack_ be _state_.[[Indent]].
          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].
          1. Let _partial_ be a new empty List.
          1. Let _len_ be ? LengthOfArrayLike(_value_).
          1. Let _index_ be 0.
          1. Repeat, while _index_ &lt; _len_,
            1. Let _strP_ be ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).
            1. If _strP_ is *undefined*, then
              1. Append *"null"* to _partial_.
            1. Else,
              1. Append _strP_ to _partial_.
            1. Set _index_ to _index_ + 1.
          1. If _partial_ is empty, then
            1. Let _final_ be *"[]"*.
          1. Else,
            1. If _state_.[[Gap]] is the empty String, then
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"["*, _properties_, and *"]"*.
            1. Else,
              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].
              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.
              1. Let _final_ be the string-concatenation of *"["*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepBack_, and *"]"*.
          1. Remove the last element of _state_.[[Stack]].
          1. Set _state_.[[Indent]] to _stepBack_.
          1. Return _final_.
        </emu-alg>
        <emu-note>
          <p>The representation of arrays includes only the elements in the interval from *+0*<sub>𝔽</sub> (inclusive) to `array.length` (exclusive). Properties whose keys are not array indices are excluded from the stringification. An array is stringified as an opening LEFT SQUARE BRACKET, elements separated by COMMA, and a closing RIGHT SQUARE BRACKET.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-json-@@tostringtag" id="sec-json-%symbol.tostringtag%">
      <h1>JSON [ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"JSON"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>Managing Memory</h1>

  <emu-clause id="sec-weak-ref-objects">
    <h1>WeakRef Objects</h1>
    <p>A WeakRef is an object that is used to refer to a target object or symbol without preserving it from garbage collection. WeakRefs can be dereferenced to allow access to the target value, if the target hasn't been reclaimed by garbage collection.</p>

    <emu-clause id="sec-weak-ref-constructor">
      <h1>The WeakRef Constructor</h1>
      <p>The <dfn variants="WeakRefs">WeakRef</dfn> constructor:</p>
      <ul>
        <li>is <dfn>%WeakRef%</dfn>.</li>
        <li>
          is the initial value of the *"WeakRef"* property of the global object.
        </li>
        <li>
          creates and initializes a new WeakRef when called as a constructor.
        </li>
        <li>
          is not intended to be called as a function and will throw an exception when called in that manner.
        </li>
        <li>
          may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `WeakRef` behaviour must include a `super` call to the `WeakRef` constructor to create and initialize the subclass instance with the internal state necessary to support the `WeakRef.prototype` built-in methods.
        </li>
      </ul>

      <emu-clause id="sec-weak-ref-target">
        <h1>WeakRef ( _target_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.
          1. Let _weakRef_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%WeakRef.prototype%"*, « [[WeakRefTarget]] »).
          1. Perform AddToKeptObjects(_target_).
          1. Set _weakRef_.[[WeakRefTarget]] to _target_.
          1. Return _weakRef_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-constructor">
      <h1>Properties of the WeakRef Constructor</h1>
      <p>The WeakRef constructor:</p>
      <ul>
        <li>
          has a [[Prototype]] internal slot whose value is %Function.prototype%.
        </li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype">
        <h1>WeakRef.prototype</h1>
        <p>The initial value of `WeakRef.prototype` is the WeakRef prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-weak-ref-prototype-object">
      <h1>Properties of the WeakRef Prototype Object</h1>
      <p>The <dfn>WeakRef prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%WeakRef.prototype%</dfn>.</li>
        <li>
          has a [[Prototype]] internal slot whose value is %Object.prototype%.
        </li>
        <li>is an ordinary object.</li>
        <li>does not have a [[WeakRefTarget]] internal slot.</li>
      </ul>

      <emu-clause id="sec-weak-ref.prototype.constructor" normative-optional>
        <h1>WeakRef.prototype.constructor</h1>

        <p>The initial value of `WeakRef.prototype.constructor` is %WeakRef%.</p>
      </emu-clause>

      <emu-clause id="sec-weak-ref.prototype.deref">
        <h1>WeakRef.prototype.deref ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _weakRef_ be the *this* value.
          1. Perform ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]).
          1. Return WeakRefDeref(_weakRef_).
        </emu-alg>

        <emu-note>
          <p>If the WeakRef returns a _target_ value that is not *undefined*, then this _target_ value should not be garbage collected until the current execution of ECMAScript code has completed. The AddToKeptObjects operation makes sure read consistency is maintained.</p>

          <pre><code class="javascript">
            let target = { foo() {} };
            let weakRef = new WeakRef(target);

            // ... later ...

            if (weakRef.deref()) {
              weakRef.deref().foo();
            }
          </code></pre>

          <p>In the above example, if the first deref does not evaluate to *undefined* then the second deref cannot either.</p>
        </emu-note>
      </emu-clause>

      <emu-clause oldids="sec-weak-ref.prototype-@@tostringtag" id="sec-weak-ref.prototype-%symbol.tostringtag%">
        <h1>WeakRef.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"WeakRef"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-weakref-abstract-operations">
      <h1>WeakRef Abstract Operations</h1>

      <emu-clause id="sec-weakrefderef" type="abstract operation">
        <h1>
          WeakRefDeref (
            _weakRef_: a WeakRef,
          ): an ECMAScript language value
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _target_ be _weakRef_.[[WeakRefTarget]].
          1. If _target_ is not ~empty~, then
            1. Perform AddToKeptObjects(_target_).
            1. Return _target_.
          1. Return *undefined*.
        </emu-alg>
        <emu-note>
          <p>This abstract operation is defined separately from WeakRef.prototype.deref strictly to make it possible to succinctly define liveness.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-weak-ref-instances">
      <h1>Properties of WeakRef Instances</h1>
      <p>WeakRef instances are ordinary objects that inherit properties from the WeakRef prototype object. WeakRef instances also have a [[WeakRefTarget]] internal slot.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry Objects</h1>
    <p>A FinalizationRegistry is an object that manages registration and unregistration of cleanup operations that are performed when target objects and symbols are garbage collected.</p>

    <emu-clause id="sec-finalization-registry-constructor">
      <h1>The FinalizationRegistry Constructor</h1>
      <p>The <dfn variants="FinalizationRegistrys">FinalizationRegistry</dfn> constructor:</p>
      <ul>
        <li>is <dfn>%FinalizationRegistry%</dfn>.</li>
        <li>
          is the initial value of the *"FinalizationRegistry"* property of the global object.
        </li>
        <li>
          creates and initializes a new FinalizationRegistry when called as a constructor.
        </li>
        <li>
          is not intended to be called as a function and will throw an exception when called in that manner.
        </li>
        <li>
          may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified `FinalizationRegistry` behaviour must include a `super` call to the `FinalizationRegistry` constructor to create and initialize the subclass instance with the internal state necessary to support the `FinalizationRegistry.prototype` built-in methods.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry-cleanup-callback">
        <h1>FinalizationRegistry ( _cleanupCallback_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If IsCallable(_cleanupCallback_) is *false*, throw a *TypeError* exception.
          1. Let _finalizationRegistry_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%FinalizationRegistry.prototype%"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).
          1. Let _fn_ be the active function object.
          1. Set _finalizationRegistry_.[[Realm]] to _fn_.[[Realm]].
          1. Set _finalizationRegistry_.[[CleanupCallback]] to HostMakeJobCallback(_cleanupCallback_).
          1. Set _finalizationRegistry_.[[Cells]] to a new empty List.
          1. Return _finalizationRegistry_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-constructor">
      <h1>Properties of the FinalizationRegistry Constructor</h1>
      <p>The FinalizationRegistry constructor:</p>
      <ul>
        <li>
          has a [[Prototype]] internal slot whose value is %Function.prototype%.
        </li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype">
        <h1>FinalizationRegistry.prototype</h1>
        <p>The initial value of `FinalizationRegistry.prototype` is the FinalizationRegistry prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-finalization-registry-prototype-object">
      <h1>Properties of the FinalizationRegistry Prototype Object</h1>
      <p>The <dfn>FinalizationRegistry prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%FinalizationRegistry.prototype%</dfn>.</li>
        <li>
          has a [[Prototype]] internal slot whose value is %Object.prototype%.
        </li>
        <li>is an ordinary object.</li>
        <li>
          does not have [[Cells]] and [[CleanupCallback]] internal slots.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype.constructor">
        <h1>FinalizationRegistry.prototype.constructor</h1>
        <p>The initial value of `FinalizationRegistry.prototype.constructor` is %FinalizationRegistry%.</p>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.register">
        <h1>FinalizationRegistry.prototype.register ( _target_, _heldValue_ [ , _unregisterToken_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _finalizationRegistry_ be the *this* value.
          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).
          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.
          1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.
          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, then
            1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.
            1. Set _unregisterToken_ to ~empty~.
          1. Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.
          1. Append _cell_ to _finalizationRegistry_.[[Cells]].
          1. Return *undefined*.
        </emu-alg>

        <emu-note>
          <p>Based on the algorithms and definitions in this specification, _cell_.[[HeldValue]] is live when _finalizationRegistry_.[[Cells]] contains _cell_; however, this does not necessarily mean that _cell_.[[UnregisterToken]] or _cell_.[[Target]] are live. For example, registering an object with itself as its unregister token would not keep the object alive forever.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.unregister">
        <h1>FinalizationRegistry.prototype.unregister ( _unregisterToken_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _finalizationRegistry_ be the *this* value.
          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).
          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, throw a *TypeError* exception.
          1. Let _removed_ be *false*.
          1. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_ of _finalizationRegistry_.[[Cells]], do
            1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then
              1. Remove _cell_ from _finalizationRegistry_.[[Cells]].
              1. Set _removed_ to *true*.
          1. Return _removed_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-finalization-registry.prototype-@@tostringtag" id="sec-finalization-registry.prototype-%symbol.tostringtag%">
        <h1>FinalizationRegistry.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"FinalizationRegistry"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-finalization-registry-instances">
      <h1>Properties of FinalizationRegistry Instances</h1>
      <p>FinalizationRegistry instances are ordinary objects that inherit properties from the FinalizationRegistry prototype object. FinalizationRegistry instances also have [[Cells]] and [[CleanupCallback]] internal slots.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-iteration">
    <h1>Iteration</h1>

    <emu-clause id="sec-common-iteration-interfaces">
      <h1>Common Iteration Interfaces</h1>
      <p>An interface is a set of property keys whose associated values match a specific specification. Any object that provides all the properties as described by an interface's specification <em>conforms</em> to that interface. An interface is not represented by a distinct object. There may be many separately implemented objects that conform to any interface. An individual object may conform to multiple interfaces.</p>

      <emu-clause id="sec-iterable-interface">
        <h1>The Iterable Interface</h1>
        <p>The <dfn variants="iterable,iterables,iterable object,iterable objects">iterable interface</dfn> includes the property described in <emu-xref href="#table-iterable-interface-required-properties"></emu-xref>:</p>
        <emu-table id="table-iterable-interface-required-properties" caption="Iterable Interface Required Properties" oldids="table-52">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                `%Symbol.iterator%`
              </td>
              <td>
                a function that returns an iterator object
              </td>
              <td>
                The returned object must conform to the iterator interface.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-iterator-interface">
        <h1>The Iterator Interface</h1>
        <p>An object that implements the <dfn variants="iterator object,iterator objects,iterator,iterators">iterator interface</dfn> must include the property in <emu-xref href="#table-iterator-interface-required-properties"></emu-xref>. Such objects may also implement the properties in <emu-xref href="#table-iterator-interface-optional-properties"></emu-xref>.</p>
        <emu-table id="table-iterator-interface-required-properties" caption="Iterator Interface Required Properties" oldids="table-53">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"next"*
              </td>
              <td>
                a function that returns an IteratorResult object
              </td>
              <td>
                The returned object must conform to the IteratorResult interface. If a previous call to the `next` method of an iterator has returned an IteratorResult object whose *"done"* property is *true*, then all subsequent calls to the `next` method of that object should also return an IteratorResult object whose *"done"* property is *true*. However, this requirement is not enforced.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Arguments may be passed to the `next` function but their interpretation and validity is dependent upon the target iterator. The for-of statement and other common users of iterators do not pass any arguments, so iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.</p>
        </emu-note>
        <emu-table id="table-iterator-interface-optional-properties" caption="Iterator Interface Optional Properties" oldids="table-54">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"return"*
              </td>
              <td>
                a function that returns an IteratorResult object
              </td>
              <td>
                The returned object must conform to the IteratorResult interface. Invoking this method notifies the iterator object that the caller does not intend to make any more `next` method calls to the iterator. The returned IteratorResult object will typically have a *"done"* property whose value is *true*, and a *"value"* property with the value passed as the argument of the `return` method. However, this requirement is not enforced.
              </td>
            </tr>
            <tr>
              <td>
                *"throw"*
              </td>
              <td>
                a function that returns an IteratorResult object
              </td>
              <td>
                The returned object must conform to the IteratorResult interface. Invoking this method notifies the iterator object that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to `throw` the value passed as the argument. If the method does not `throw`, the returned IteratorResult object will typically have a *"done"* property whose value is *true*.
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including `for`-`of`, `yield*`, and array destructuring call these methods after performing an existence check. Most ECMAScript library functions that accept iterable objects as arguments also conditionally call them.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-asynciterable-interface">
        <h1>The Async Iterable Interface</h1>
        <p>The <dfn variants="async iterable,async iterables,async iterable object,async iterable objects">async iterable interface</dfn> includes the properties described in <emu-xref href="#table-async-iterable"></emu-xref>:</p>
        <emu-table id="table-async-iterable" caption="Async Iterable Interface Required Properties">
          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
                <th>Requirements</th>
              </tr>
            </thead>
            <tr>
              <td>`%Symbol.asyncIterator%`</td>
              <td>a function that returns an async iterator object</td>
              <td>The returned object must conform to the async iterator interface.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asynciterator-interface">
        <h1>The Async Iterator Interface</h1>
        <p>An object that implements the <dfn variants="async iterator object,async iterator objects,async iterator,async iterators">async iterator interface</dfn> must include the properties in <emu-xref href="#table-async-iterator-required"></emu-xref>. Such objects may also implement the properties in <emu-xref href="#table-async-iterator-optional"></emu-xref>.</p>
        <emu-table id="table-async-iterator-required" caption="Async Iterator Interface Required Properties">
          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
                <th>Requirements</th>
              </tr>
            </thead>
            <tr>
              <td>*"next"*</td>
              <td>a function that returns a promise for an IteratorResult object</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object that conforms to the IteratorResult interface. If a previous call to the `next` method of an async iterator has returned a promise for an IteratorResult object whose *"done"* property is *true*, then all subsequent calls to the `next` method of that object should also return a promise for an IteratorResult object whose *"done"* property is *true*. However, this requirement is not enforced.</p>

                <p>Additionally, the IteratorResult object that serves as a fulfillment value should have a *"value"* property whose value is not a promise (or "thenable"). However, this requirement is also not enforced.</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Arguments may be passed to the `next` function but their interpretation and validity is dependent upon the target async iterator. The `for`-`await`-`of` statement and other common users of async iterators do not pass any arguments, so async iterator objects that expect to be used in such a manner must be prepared to deal with being called with no arguments.</p>
        </emu-note>
        <emu-table id="table-async-iterator-optional" caption="Async Iterator Interface Optional Properties">
          <table>
            <thead>
              <tr>
                <th>Property</th>
                <th>Value</th>
                <th>Requirements</th>
              </tr>
            </thead>
            <tr>
              <td>*"return"*</td>
              <td>a function that returns a promise for an IteratorResult object</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object that conforms to the IteratorResult interface. Invoking this method notifies the async iterator object that the caller does not intend to make any more `next` method calls to the async iterator. The returned promise will fulfill with an IteratorResult object which will typically have a *"done"* property whose value is *true*, and a *"value"* property with the value passed as the argument of the `return` method. However, this requirement is not enforced.</p>

                <p>Additionally, the IteratorResult object that serves as a fulfillment value should have a *"value"* property whose value is not a promise (or "thenable"). If the argument value is used in the typical manner, then if it is a rejected promise, a promise rejected with the same reason should be returned; if it is a fulfilled promise, then its fulfillment value should be used as the *"value"* property of the returned promise's IteratorResult object fulfillment value. However, these requirements are also not enforced.</p>
              </td>
            </tr>
            <tr>
              <td>*"throw"*</td>
              <td>a function that returns a promise for an IteratorResult object</td>
              <td>
                <p>The returned promise, when fulfilled, must fulfill with an object that conforms to the IteratorResult interface. Invoking this method notifies the async iterator object that the caller has detected an error condition. The argument may be used to identify the error condition and typically will be an exception object. A typical response is to return a rejected promise which rejects with the value passed as the argument.</p>

                <p>If the returned promise is fulfilled, the IteratorResult object fulfillment value will typically have a *"done"* property whose value is *true*. Additionally, it should have a *"value"* property whose value is not a promise (or "thenable"), but this requirement is not enforced.</p>
              </td>
            </tr>
          </table>
        </emu-table>
        <emu-note>
          <p>Typically callers of these methods should check for their existence before invoking them. Certain ECMAScript language features including `for`-`await`-`of` and `yield*` call these methods after performing an existence check.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iteratorresult-interface">
        <h1>The IteratorResult Interface</h1>
        <p>The <dfn variants="IteratorResult object,IteratorResult objects">IteratorResult interface</dfn> includes the properties listed in <emu-xref href="#table-iteratorresult-interface-properties"></emu-xref>:</p>
        <emu-table id="table-iteratorresult-interface-properties" caption="IteratorResult Interface Properties" oldids="table-55">
          <table>
            <thead>
              <tr>
                <th>
                  Property
                </th>
                <th>
                  Value
                </th>
                <th>
                  Requirements
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                *"done"*
              </td>
              <td>
                a Boolean
              </td>
              <td>
                This is the result status of an iterator `next` method call. If the end of the iterator was reached *"done"* is *true*. If the end was not reached *"done"* is *false* and a value is available. If a *"done"* property (either own or inherited) does not exist, it is considered to have the value *false*.
              </td>
            </tr>
            <tr>
              <td>
                *"value"*
              </td>
              <td>
                an ECMAScript language value
              </td>
              <td>
                If done is *false*, this is the current iteration element value. If done is *true*, this is the return value of the iterator, if it supplied one. If the iterator does not have a return value, *"value"* is *undefined*. In that case, the *"value"* property may be absent from the conforming object if it does not inherit an explicit *"value"* property.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-helper-objects">
      <h1>Iterator Helper Objects</h1>
      <p>An <dfn variants="Iterator Helper objects">Iterator Helper object</dfn> is an ordinary object that represents a lazy transformation of some specific source iterator object. There is not a named constructor for Iterator Helper objects. Instead, Iterator Helper objects are created by calling certain methods of Iterator instance objects.</p>

      <emu-clause id="sec-%iteratorhelperprototype%-object">
        <h1>The %IteratorHelperPrototype% Object</h1>
        <p>The <dfn>%IteratorHelperPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Iterator Helper objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%iteratorhelperprototype%.next">
          <h1>%IteratorHelperPrototype%.next ( )</h1>
          <emu-alg>
            1. Return ? GeneratorResume(*this* value, *undefined*, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%.return">
          <h1>%IteratorHelperPrototype%.return ( )</h1>
          <emu-alg>
            1. Let _O_ be *this* value.
            1. Perform ? RequireInternalSlot(_O_, [[UnderlyingIterator]]).
            1. Assert: _O_ has a [[GeneratorState]] internal slot.
            1. If _O_.[[GeneratorState]] is ~suspended-start~, then
              1. Set _O_.[[GeneratorState]] to ~completed~.
              1. NOTE: Once a generator enters the completed state it never leaves it and its associated execution context is never resumed. Any execution state associated with _O_ can be discarded at this point.
              1. Perform ? IteratorClose(_O_.[[UnderlyingIterator]], NormalCompletion(~unused~)).
              1. Return CreateIteratorResultObject(*undefined*, *true*).
            1. Let _C_ be ReturnCompletion(*undefined*).
            1. Return ? GeneratorResumeAbrupt(_O_, _C_, *"Iterator Helper"*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%iteratorhelperprototype%-%symbol.tostringtag%">
          <h1>%IteratorHelperPrototype% [ %Symbol.toStringTag% ]</h1>
          <p>The initial value of the %Symbol.toStringTag% property is the String value *"Iterator Helper"*.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-iterator-objects">
      <h1>Iterator Objects</h1>

      <emu-clause id="sec-iterator-constructor">
        <h1>The Iterator Constructor</h1>
        <p>The <dfn>Iterator</dfn> constructor:</p>
        <ul>
          <li>is <dfn>%Iterator%</dfn>.</li>
          <li>is the initial value of the *"Iterator"* property of the global object.</li>
          <li>is designed to be subclassable. It may be used as the value of an *extends* clause of a class definition.</li>
        </ul>

        <emu-clause id="sec-iterator">
          <h1>Iterator ( )</h1>
          <p>This function performs the following steps when called:</p>
          <emu-alg>
            1. If NewTarget is either *undefined* or the active function object, throw a *TypeError* exception.
            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *"%Iterator.prototype%"*).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-the-iterator-constructor">
        <h1>Properties of the Iterator Constructor</h1>
        <p>The Iterator constructor:</p>
        <ul>
          <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-iterator.from">
          <h1>Iterator.from ( _O_ )</h1>
          <emu-alg>
            1. Let _iteratorRecord_ be ? GetIteratorFlattenable(_O_, ~iterate-string-primitives~).
            1. Let _hasInstance_ be ? OrdinaryHasInstance(%Iterator%, _iteratorRecord_.[[Iterator]]).
            1. If _hasInstance_ is *true*, then
              1. Return _iteratorRecord_.[[Iterator]].
            1. Let _wrapper_ be OrdinaryObjectCreate(%WrapForValidIteratorPrototype%, « [[Iterated]] »).
            1. Set _wrapper_.[[Iterated]] to _iteratorRecord_.
            1. Return _wrapper_.
          </emu-alg>

          <emu-clause id="sec-%wrapforvaliditeratorprototype%-object">
            <h1>The %WrapForValidIteratorPrototype% Object</h1>
            <p>The <dfn>%WrapForValidIteratorPrototype%</dfn> object:</p>
            <ul>
              <li>is an ordinary object.</li>
              <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
            </ul>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.next">
              <h1>%WrapForValidIteratorPrototype%.next ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Perform ? RequireInternalSlot(_O_, [[Iterated]]).
                1. Let _iteratorRecord_ be _O_.[[Iterated]].
                1. Return ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).
              </emu-alg>
            </emu-clause>

            <emu-clause id="sec-%wrapforvaliditeratorprototype%.return">
              <h1>%WrapForValidIteratorPrototype%.return ( )</h1>
              <emu-alg>
                1. Let _O_ be *this* value.
                1. Perform ? RequireInternalSlot(_O_, [[Iterated]]).
                1. Let _iterator_ be _O_.[[Iterated]].[[Iterator]].
                1. Assert: _iterator_ is an Object.
                1. Let _returnMethod_ be ? GetMethod(_iterator_, *"return"*).
                1. If _returnMethod_ is *undefined*, then
                  1. Return CreateIteratorResultObject(*undefined*, *true*).
                1. Return ? Call(_returnMethod_, _iterator_).
              </emu-alg>
            </emu-clause>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-iterator.prototype">
          <h1>Iterator.prototype</h1>
          <p>The initial value of Iterator.prototype is the Iterator prototype object.</p>
          <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause oldids="sec-%iteratorprototype%-object" id="sec-%iterator.prototype%-object">
      <h1>Properties of the Iterator Prototype Object</h1>
      <p>The <dfn>Iterator prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Iterator.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
      </ul>
      <emu-note>
        <p>All objects defined in this specification that implement the iterator interface also inherit from %Iterator.prototype%. ECMAScript code may also define objects that inherit from %Iterator.prototype%. %Iterator.prototype% provides a place where additional methods that are applicable to all iterator objects may be added.</p>
        <p>The following expression is one way that ECMAScript code can access the %Iterator.prototype% object:</p>
        <pre><code class="javascript">Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))</code></pre>
      </emu-note>

      <emu-clause id="sec-iterator.prototype.constructor">
        <h1>Iterator.prototype.constructor</h1>
        <p>`Iterator.prototype.constructor` is an accessor property with attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }. The [[Get]] and [[Set]] attributes are defined as follows:</p>

        <emu-clause id="sec-get-iterator.prototype.constructor">
          <h1>get Iterator.prototype.constructor</h1>
          <p>The value of the [[Get]] attribute is a built-in function that requires no arguments. It performs the following steps when called:</p>
          <emu-alg>
            1. Return %Iterator%.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype.constructor">
          <h1>set Iterator.prototype.constructor</h1>
          <p>The value of the [[Set]] attribute is a built-in function that takes an argument _v_. It performs the following steps when called:</p>
          <emu-alg>
            1. Perform ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, *"constructor"*, _v_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>Unlike the *"constructor"* property on most built-in prototypes, for web-compatibility reasons this property must be an accessor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.drop">
        <h1>Iterator.prototype.drop ( _limit_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. Let _numLimit_ be Completion(ToNumber(_limit_)).
          1. IfAbruptCloseIterator(_numLimit_, _iterated_).
          1. If _numLimit_ is *NaN*, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat, while _remaining_ > 0,
              1. If _remaining_ ≠ +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _next_ be ? IteratorStep(_iterated_).
              1. If _next_ is ~done~, return ReturnCompletion(*undefined*).
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _completion_ be Completion(Yield(_value_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.every">
        <h1>Iterator.prototype.every ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *true*.
            1. Let _result_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *false*, return ? IteratorClose(_iterated_, NormalCompletion(*false*)).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.filter">
        <h1>Iterator.prototype.filter ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _predicate_ and performs the following steps when called:
            1. Let _counter_ be 0.
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _selected_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
              1. IfAbruptCloseIterator(_selected_, _iterated_).
              1. If ToBoolean(_selected_) is *true*, then
                1. Let _completion_ be Completion(Yield(_value_)).
                1. IfAbruptCloseIterator(_completion_, _iterated_).
              1. Set _counter_ to _counter_ + 1.
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.find">
        <h1>Iterator.prototype.find ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *undefined*.
            1. Let _result_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? IteratorClose(_iterated_, NormalCompletion(_value_)).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.flatmap">
        <h1>Iterator.prototype.flatMap ( _mapper_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_mapper_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Let _counter_ be 0.
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »)).
              1. IfAbruptCloseIterator(_mapped_, _iterated_).
              1. Let _innerIterator_ be Completion(GetIteratorFlattenable(_mapped_, ~reject-primitives~)).
              1. IfAbruptCloseIterator(_innerIterator_, _iterated_).
              1. Let _innerAlive_ be *true*.
              1. Repeat, while _innerAlive_ is *true*,
                1. Let _innerValue_ be Completion(IteratorStepValue(_innerIterator_)).
                1. IfAbruptCloseIterator(_innerValue_, _iterated_).
                1. If _innerValue_ is ~done~, then
                  1. Set _innerAlive_ to *false*.
                1. Else,
                  1. Let _completion_ be Completion(Yield(_innerValue_)).
                  1. If _completion_ is an abrupt completion, then
                    1. Let _backupCompletion_ be Completion(IteratorClose(_innerIterator_, _completion_)).
                    1. IfAbruptCloseIterator(_backupCompletion_, _iterated_).
                    1. Return ? IteratorClose(_iterated_, _completion_).
              1. Set _counter_ to _counter_ + 1.
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.foreach">
        <h1>Iterator.prototype.forEach ( _procedure_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_procedure_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *undefined*.
            1. Let _result_ be Completion(Call(_procedure_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.map">
        <h1>Iterator.prototype.map ( _mapper_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_mapper_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _mapper_ and performs the following steps when called:
            1. Let _counter_ be 0.
            1. Repeat,
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _mapped_ be Completion(Call(_mapper_, *undefined*, « _value_, 𝔽(_counter_) »)).
              1. IfAbruptCloseIterator(_mapped_, _iterated_).
              1. Let _completion_ be Completion(Yield(_mapped_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
              1. Set _counter_ to _counter_ + 1.
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.reduce">
        <h1>Iterator.prototype.reduce ( _reducer_ [ , _initialValue_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_reducer_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. If _initialValue_ is not present, then
            1. Let _accumulator_ be ? IteratorStepValue(_iterated_).
            1. If _accumulator_ is ~done~, throw a *TypeError* exception.
            1. Let _counter_ be 1.
          1. Else,
            1. Let _accumulator_ be _initialValue_.
            1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return _accumulator_.
            1. Let _result_ be Completion(Call(_reducer_, *undefined*, « _accumulator_, _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. Set _accumulator_ to _result_.
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.some">
        <h1>Iterator.prototype.some ( _predicate_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. If IsCallable(_predicate_) is *false*, then
            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _counter_ be 0.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return *false*.
            1. Let _result_ be Completion(Call(_predicate_, *undefined*, « _value_, 𝔽(_counter_) »)).
            1. IfAbruptCloseIterator(_result_, _iterated_).
            1. If ToBoolean(_result_) is *true*, return ? IteratorClose(_iterated_, NormalCompletion(*true*)).
            1. Set _counter_ to _counter_ + 1.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.take">
        <h1>Iterator.prototype.take ( _limit_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be the Iterator Record { [[Iterator]]: _O_, [[NextMethod]]: *undefined*, [[Done]]: *false* }.
          1. Let _numLimit_ be Completion(ToNumber(_limit_)).
          1. IfAbruptCloseIterator(_numLimit_, _iterated_).
          1. If _numLimit_ is *NaN*, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Let _integerLimit_ be ! ToIntegerOrInfinity(_numLimit_).
          1. If _integerLimit_ &lt; 0, then
            1. Let _error_ be ThrowCompletion(a newly created *RangeError* object).
            1. Return ? IteratorClose(_iterated_, _error_).
          1. Set _iterated_ to ? GetIteratorDirect(_O_).
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _iterated_ and _integerLimit_ and performs the following steps when called:
            1. Let _remaining_ be _integerLimit_.
            1. Repeat,
              1. If _remaining_ = 0, then
                1. Return ? IteratorClose(_iterated_, ReturnCompletion(*undefined*)).
              1. If _remaining_ ≠ +∞, then
                1. Set _remaining_ to _remaining_ - 1.
              1. Let _value_ be ? IteratorStepValue(_iterated_).
              1. If _value_ is ~done~, return ReturnCompletion(*undefined*).
              1. Let _completion_ be Completion(Yield(_value_)).
              1. IfAbruptCloseIterator(_completion_, _iterated_).
          1. Let _result_ be CreateIteratorFromClosure(_closure_, *"Iterator Helper"*, %IteratorHelperPrototype%, « [[UnderlyingIterator]] »).
          1. Set _result_.[[UnderlyingIterator]] to _iterated_.
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype.toarray">
        <h1>Iterator.prototype.toArray ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If _O_ is not an Object, throw a *TypeError* exception.
          1. Let _iterated_ be ? GetIteratorDirect(_O_).
          1. Let _items_ be a new empty List.
          1. Repeat,
            1. Let _value_ be ? IteratorStepValue(_iterated_).
            1. If _value_ is ~done~, return CreateArrayFromList(_items_).
            1. Append _value_ to _items_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-%iteratorprototype%-@@iterator,sec-%iteratorprototype%-%symbol.iterator%" id="sec-iterator.prototype-%symbol.iterator%">
        <h1>Iterator.prototype [ %Symbol.iterator% ] ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.iterator]"*.</p>
      </emu-clause>

      <emu-clause id="sec-iterator.prototype-%symbol.tostringtag%">
        <h1>Iterator.prototype [ %Symbol.toStringTag% ]</h1>
        <p>`Iterator.prototype[%Symbol.toStringTag%]` is an accessor property with attributes { [[Enumerable]]: *false*, [[Configurable]]: *true* }. The [[Get]] and [[Set]] attributes are defined as follows:</p>

        <emu-clause id="sec-get-iterator.prototype-%symbol.tostringtag%">
          <h1>get Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>The value of the [[Get]] attribute is a built-in function that requires no arguments. It performs the following steps when called:</p>
          <emu-alg>
            1. Return *"Iterator"*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-set-iterator.prototype-%symbol.tostringtag%">
          <h1>set Iterator.prototype [ %Symbol.toStringTag% ]</h1>
          <p>The value of the [[Set]] attribute is a built-in function that takes an argument _v_. It performs the following steps when called:</p>
          <emu-alg>
            1. Perform ? SetterThatIgnoresPrototypeProperties(*this* value, %Iterator.prototype%, %Symbol.toStringTag%, _v_).
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-note>
          <p>Unlike the %Symbol.toStringTag% property on most built-in prototypes, for web-compatibility reasons this property must be an accessor.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asynciteratorprototype">
      <h1>The %AsyncIteratorPrototype% Object</h1>
      <p>The <dfn>%AsyncIteratorPrototype%</dfn> object:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
      </ul>
      <emu-note>
        <p>All objects defined in this specification that implement the async iterator interface also inherit from %AsyncIteratorPrototype%. ECMAScript code may also define objects that inherit from %AsyncIteratorPrototype%. The %AsyncIteratorPrototype% object provides a place where additional methods that are applicable to all async iterator objects may be added.</p>
      </emu-note>

      <emu-clause oldids="sec-asynciteratorprototype-asynciterator" id="sec-%asynciteratorprototype%-%symbol.asynciterator%">
        <h1>%AsyncIteratorPrototype% [ %Symbol.asyncIterator% ] ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"[Symbol.asyncIterator]"*.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-from-sync-iterator-objects">
      <h1>Async-from-Sync Iterator Objects</h1>
      <p>An <dfn variants="Async-from-Sync Iterator objects">Async-from-Sync Iterator object</dfn> is an async iterator that adapts a specific synchronous iterator. Async-from-Sync Iterator objects are never directly accessible to ECMAScript code. There is not a named constructor for Async-from-Sync Iterator objects. Instead, Async-from-Sync Iterator objects are created by the CreateAsyncFromSyncIterator abstract operation as needed.</p>

      <emu-clause id="sec-createasyncfromsynciterator" type="abstract operation">
        <h1>
          CreateAsyncFromSyncIterator (
            _syncIteratorRecord_: an Iterator Record,
          ): an Iterator Record
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to create an async Iterator Record from a synchronous Iterator Record.</dd>
        </dl>
        <emu-alg>
          1. Let _asyncIterator_ be OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).
          1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.
          1. Let _nextMethod_ be ! Get(_asyncIterator_, *"next"*).
          1. Let _iteratorRecord_ be the Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.
          1. Return _iteratorRecord_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-%asyncfromsynciteratorprototype%-object">
        <h1>The %AsyncFromSyncIteratorPrototype% Object</h1>
        <p>The <dfn>%AsyncFromSyncIteratorPrototype%</dfn> object:</p>
        <ul>
          <li>has properties that are inherited by all Async-from-Sync Iterator objects.</li>
          <li>is an ordinary object.</li>
          <li>has a [[Prototype]] internal slot whose value is %AsyncIteratorPrototype%.</li>
          <li>is never directly accessible to ECMAScript code.</li>
          <li>has the following properties:</li>
        </ul>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.next">
          <h1>%AsyncFromSyncIteratorPrototype%.next ( [ _value_ ] )</h1>
          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. If _value_ is present, then
              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_, _value_)).
            1. Else,
              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.return">
          <h1>%AsyncFromSyncIteratorPrototype%.return ( [ _value_ ] )</h1>

          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. Let _syncIterator_ be _syncIteratorRecord_.[[Iterator]].
            1. Let _return_ be Completion(GetMethod(_syncIterator_, *"return"*)).
            1. IfAbruptRejectPromise(_return_, _promiseCapability_).
            1. If _return_ is *undefined*, then
              1. Let _iteratorResult_ be CreateIteratorResultObject(_value_, *true*).
              1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).
              1. Return _promiseCapability_.[[Promise]].
            1. If _value_ is present, then
              1. Let _result_ be Completion(Call(_return_, _syncIterator_, « _value_ »)).
            1. Else,
              1. Let _result_ be Completion(Call(_return_, _syncIterator_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. If _result_ is not an Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *false*).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-%asyncfromsynciteratorprototype%.throw">
          <h1>%AsyncFromSyncIteratorPrototype%.throw ( [ _value_ ] )</h1>
          <emu-note>In this specification, _value_ is always provided, but is left optional for consistency with <emu-xref title href="#sec-%asyncfromsynciteratorprototype%.return"></emu-xref>.</emu-note>

          <emu-alg>
            1. Let _O_ be the *this* value.
            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].
            1. Let _syncIterator_ be _syncIteratorRecord_.[[Iterator]].
            1. Let _throw_ be Completion(GetMethod(_syncIterator_, *"throw"*)).
            1. IfAbruptRejectPromise(_throw_, _promiseCapability_).
            1. If _throw_ is *undefined*, then
              1. NOTE: If _syncIterator_ does not have a `throw` method, close it to give it a chance to clean up before we reject the capability.
              1. Let _closeCompletion_ be NormalCompletion(~empty~).
              1. Let _result_ be Completion(IteratorClose(_syncIteratorRecord_, _closeCompletion_)).
              1. IfAbruptRejectPromise(_result_, _promiseCapability_).
              1. NOTE: The next step throws a *TypeError* to indicate that there was a protocol violation: _syncIterator_ does not have a `throw` method.
              1. NOTE: If closing _syncIterator_ does not throw then the result of that operation is ignored, even if it yields a rejected promise.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. If _value_ is present, then
              1. Let _result_ be Completion(Call(_throw_, _syncIterator_, « _value_ »)).
            1. Else,
              1. Let _result_ be Completion(Call(_throw_, _syncIterator_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
            1. If _result_ is not an Object, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).
              1. Return _promiseCapability_.[[Promise]].
            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_, _syncIteratorRecord_, *true*).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-properties-of-async-from-sync-iterator-instances">
        <h1>Properties of Async-from-Sync Iterator Instances</h1>
        <p>Async-from-Sync Iterator instances are ordinary objects that inherit properties from the %AsyncFromSyncIteratorPrototype% intrinsic object. Async-from-Sync Iterator instances are initially created with the internal slots listed in <emu-xref href="#table-async-from-sync-iterator-internal-slots"></emu-xref>.</p>
        <emu-table id="table-async-from-sync-iterator-internal-slots" caption="Internal Slots of Async-from-Sync Iterator Instances">
          <table>
            <thead>
              <tr>
                <th>
                  Internal Slot
                </th>
                <th>
                  Type
                </th>
                <th>
                  Description
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[SyncIteratorRecord]]
              </td>
              <td>
                an Iterator Record
              </td>
              <td>
                Represents the original synchronous iterator which is being adapted.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncfromsynciteratorcontinuation" type="abstract operation" oldids="sec-async-from-sync-iterator-value-unwrap-functions">
        <h1>
          AsyncFromSyncIteratorContinuation (
            _result_: an Object,
            _promiseCapability_: a PromiseCapability Record for an intrinsic %Promise%,
            _syncIteratorRecord_: an Iterator Record,
            _closeOnRejection_: a Boolean,
          ): a Promise
        </h1>
        <dl class="header">
        </dl>

        <emu-alg>
          1. NOTE: Because _promiseCapability_ is derived from the intrinsic %Promise%, the calls to _promiseCapability_.[[Reject]] entailed by the use IfAbruptRejectPromise below are guaranteed not to throw.
          1. Let _done_ be Completion(IteratorComplete(_result_)).
          1. IfAbruptRejectPromise(_done_, _promiseCapability_).
          1. Let _value_ be Completion(IteratorValue(_result_)).
          1. IfAbruptRejectPromise(_value_, _promiseCapability_).
          1. Let _valueWrapper_ be Completion(PromiseResolve(%Promise%, _value_)).
          1. If _valueWrapper_ is an abrupt completion, _done_ is *false*, and _closeOnRejection_ is *true*, then
            1. Set _valueWrapper_ to Completion(IteratorClose(_syncIteratorRecord_, _valueWrapper_)).
          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).
          1. Let _unwrap_ be a new Abstract Closure with parameters (_v_) that captures _done_ and performs the following steps when called:
            1. Return CreateIteratorResultObject(_v_, _done_).
          1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, *""*, « »).
          1. NOTE: _onFulfilled_ is used when processing the *"value"* property of an IteratorResult object in order to wait for its value if it is a promise and re-package the result in a new "unwrapped" IteratorResult object.
          1. If _done_ is *true*, or if _closeOnRejection_ is *false*, then
            1. Let _onRejected_ be *undefined*.
          1. Else,
            1. Let _closeIterator_ be a new Abstract Closure with parameters (_error_) that captures _syncIteratorRecord_ and performs the following steps when called:
              1. Return ? IteratorClose(_syncIteratorRecord_, ThrowCompletion(_error_)).
            1. Let _onRejected_ be CreateBuiltinFunction(_closeIterator_, 1, *""*, « »).
            1. NOTE: _onRejected_ is used to close the Iterator when the *"value"* property of an IteratorResult object it yields is a rejected promise.
          1. Perform PerformPromiseThen(_valueWrapper_, _onFulfilled_, _onRejected_, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-promise-objects">
    <h1>Promise Objects</h1>
    <p>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</p>
    <p>Any Promise is in one of three mutually exclusive states: <em>fulfilled</em>, <em>rejected</em>, and <em>pending</em>:</p>
    <ul>
      <li>
        A promise `p` is fulfilled if `p.then(f, r)` will immediately enqueue a Job to call the function `f`.
      </li>
      <li>
        A promise `p` is rejected if `p.then(f, r)` will immediately enqueue a Job to call the function `r`.
      </li>
      <li>
        A promise is pending if it is neither fulfilled nor rejected.
      </li>
    </ul>
    <p>A promise is said to be <em>settled</em> if it is not pending, i.e. if it is either fulfilled or rejected.</p>
    <p>A promise is <em>resolved</em> if it is settled or if it has been “locked in” to match the state of another promise. Attempting to resolve or reject a resolved promise has no effect. A promise is <em>unresolved</em> if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled or rejected.</p>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise Abstract Operations</h1>

      <emu-clause id="sec-promisecapability-records">
        <h1>PromiseCapability Records</h1>
        <p>A <dfn variants="PromiseCapability Records">PromiseCapability Record</dfn> is a Record value used to encapsulate a Promise or promise-like object along with the functions that are capable of resolving or rejecting that promise. PromiseCapability Records are produced by the NewPromiseCapability abstract operation.</p>
        <p>PromiseCapability Records have the fields listed in <emu-xref href="#table-promisecapability-record-fields"></emu-xref>.</p>
        <emu-table id="table-promisecapability-record-fields" caption="PromiseCapability Record Fields" oldids="table-57">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Promise]]
              </td>
              <td>
                an Object
              </td>
              <td>
                An object that is usable as a promise.
              </td>
            </tr>
            <tr>
              <td>
                [[Resolve]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The function that is used to resolve the given promise.
              </td>
            </tr>
            <tr>
              <td>
                [[Reject]]
              </td>
              <td>
                a function object
              </td>
              <td>
                The function that is used to reject the given promise.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-ifabruptrejectpromise" aoid="IfAbruptRejectPromise">
          <h1>IfAbruptRejectPromise ( _value_, _capability_ )</h1>
          <p>IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a PromiseCapability Record. An algorithm step of the form:</p>
          <emu-alg>
            1. IfAbruptRejectPromise(_value_, _capability_).
          </emu-alg>
          <p>means the same thing as:</p>
          <emu-alg>
            1. Assert: _value_ is a Completion Record.
            1. If _value_ is an abrupt completion, then
              1. Perform ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »).
              1. Return _capability_.[[Promise]].
            1. Else,
              1. Set _value_ to ! _value_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction Records</h1>
        <p>A <dfn variants="PromiseReaction Records">PromiseReaction Record</dfn> is a Record value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction Records are created by the PerformPromiseThen abstract operation, and are used by the Abstract Closure returned by NewPromiseReactionJob.</p>
        <p>PromiseReaction Records have the fields listed in <emu-xref href="#table-promisereaction-record-fields"></emu-xref>.</p>
        <emu-table id="table-promisereaction-record-fields" caption="PromiseReaction Record Fields" oldids="table-58">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                a PromiseCapability Record or *undefined*
              </td>
              <td>
                The capabilities of the promise for which this record provides a reaction handler.
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                ~fulfill~ or ~reject~
              </td>
              <td>
                The [[Type]] is used when [[Handler]] is ~empty~ to allow for behaviour specific to the settlement type.
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                a JobCallback Record or ~empty~
              </td>
              <td>
                The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is ~empty~, a function that depends on the value of [[Type]] will be used instead.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-createresolvingfunctions" type="abstract operation">
        <h1>
          CreateResolvingFunctions (
            _promise_: a Promise,
          ): a Record with fields [[Resolve]] (a function object) and [[Reject]] (a function object)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _alreadyResolved_ be the Record { [[Value]]: *false* }.
          1. Let _stepsResolve_ be the algorithm steps defined in <emu-xref href="#sec-promise-resolve-functions" title></emu-xref>.
          1. Let _lengthResolve_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise-resolve-functions" title></emu-xref>.
          1. Let _resolve_ be CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *""*, « [[Promise]], [[AlreadyResolved]] »).
          1. Set _resolve_.[[Promise]] to _promise_.
          1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.
          1. Let _stepsReject_ be the algorithm steps defined in <emu-xref href="#sec-promise-reject-functions" title></emu-xref>.
          1. Let _lengthReject_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise-reject-functions" title></emu-xref>.
          1. Let _reject_ be CreateBuiltinFunction(_stepsReject_, _lengthReject_, *""*, « [[Promise]], [[AlreadyResolved]] »).
          1. Set _reject_.[[Promise]] to _promise_.
          1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.
          1. Return the Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }.
        </emu-alg>

        <emu-clause id="sec-promise-reject-functions">
          <h1>Promise Reject Functions</h1>
          <p>A promise reject function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
          <p>When a promise reject function is called with argument _reason_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
            1. Let _promise_ be _F_.[[Promise]].
            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyResolved_.[[Value]] to *true*.
            1. Perform RejectPromise(_promise_, _reason_).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a promise reject function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>

        <emu-clause id="sec-promise-resolve-functions">
          <h1>Promise Resolve Functions</h1>
          <p>A promise resolve function is an anonymous built-in function that has [[Promise]] and [[AlreadyResolved]] internal slots.</p>
          <p>When a promise resolve function is called with argument _resolution_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.
            1. Let _promise_ be _F_.[[Promise]].
            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].
            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyResolved_.[[Value]] to *true*.
            1. If SameValue(_resolution_, _promise_) is *true*, then
              1. Let _selfResolutionError_ be a newly created *TypeError* object.
              1. Perform RejectPromise(_promise_, _selfResolutionError_).
              1. Return *undefined*.
            1. If _resolution_ is not an Object, then
              1. Perform FulfillPromise(_promise_, _resolution_).
              1. Return *undefined*.
            1. Let _then_ be Completion(Get(_resolution_, *"then"*)).
            1. If _then_ is an abrupt completion, then
              1. Perform RejectPromise(_promise_, _then_.[[Value]]).
              1. Return *undefined*.
            1. Let _thenAction_ be _then_.[[Value]].
            1. If IsCallable(_thenAction_) is *false*, then
              1. Perform FulfillPromise(_promise_, _resolution_).
              1. Return *undefined*.
            1. Let _thenJobCallback_ be HostMakeJobCallback(_thenAction_).
            1. Let _job_ be NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_).
            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a promise resolve function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-fulfillpromise" type="abstract operation">
        <h1>
          FulfillPromise (
            _promise_: a Promise,
            _value_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promise_.[[PromiseState]] is ~pending~.
          1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].
          1. Set _promise_.[[PromiseResult]] to _value_.
          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
          1. Set _promise_.[[PromiseState]] to ~fulfilled~.
          1. Perform TriggerPromiseReactions(_reactions_, _value_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromisecapability" type="abstract operation" oldids="sec-getcapabilitiesexecutor-functions">
        <h1>
          NewPromiseCapability (
            _C_: an ECMAScript language value,
          ): either a normal completion containing a PromiseCapability Record or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It attempts to use _C_ as a constructor in the fashion of the built-in Promise constructor to create a promise and extract its `resolve` and `reject` functions. The promise plus the `resolve` and `reject` functions are used to initialize a new PromiseCapability Record.</dd>
        </dl>
        <emu-alg>
          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.
          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href="#sec-promise-executor"></emu-xref>).
          1. Let _resolvingFunctions_ be the Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.
          1. Let _executorClosure_ be a new Abstract Closure with parameters (_resolve_, _reject_) that captures _resolvingFunctions_ and performs the following steps when called:
            1. If _resolvingFunctions_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.
            1. If _resolvingFunctions_.[[Reject]] is not *undefined*, throw a *TypeError* exception.
            1. Set _resolvingFunctions_.[[Resolve]] to _resolve_.
            1. Set _resolvingFunctions_.[[Reject]] to _reject_.
            1. Return NormalCompletion(*undefined*).
          1. Let _executor_ be CreateBuiltinFunction(_executorClosure_, 2, *""*, « »).
          1. Let _promise_ be ? Construct(_C_, « _executor_ »).
          1. If IsCallable(_resolvingFunctions_.[[Resolve]]) is *false*, throw a *TypeError* exception.
          1. If IsCallable(_resolvingFunctions_.[[Reject]]) is *false*, throw a *TypeError* exception.
          1. Return the PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }.
        </emu-alg>
        <emu-note>
          <p>This abstract operation supports Promise subclassing, as it is generic on any constructor that calls a passed executor function argument in the same way as the Promise constructor. It is used to generalize static methods of the Promise constructor to any subclass.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-ispromise" type="abstract operation">
        <h1>
          IsPromise (
            _x_: an ECMAScript language value,
          ): a Boolean
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It checks for the promise brand on an object.</dd>
        </dl>
        <emu-alg>
          1. If _x_ is not an Object, return *false*.
          1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-rejectpromise" type="abstract operation">
        <h1>
          RejectPromise (
            _promise_: a Promise,
            _reason_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _promise_.[[PromiseState]] is ~pending~.
          1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].
          1. Set _promise_.[[PromiseResult]] to _reason_.
          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.
          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.
          1. Set _promise_.[[PromiseState]] to ~rejected~.
          1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *"reject"*).
          1. Perform TriggerPromiseReactions(_reactions_, _reason_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-triggerpromisereactions" type="abstract operation">
        <h1>
          TriggerPromiseReactions (
            _reactions_: a List of PromiseReaction Records,
            _argument_: an ECMAScript language value,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It enqueues a new Job for each record in _reactions_. Each such Job processes the [[Type]] and [[Handler]] of the PromiseReaction Record, and if the [[Handler]] is not ~empty~, calls it passing the given argument. If the [[Handler]] is ~empty~, the behaviour is determined by the [[Type]].</dd>
        </dl>
        <emu-alg>
          1. For each element _reaction_ of _reactions_, do
            1. Let _job_ be NewPromiseReactionJob(_reaction_, _argument_).
            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" type="host-defined abstract operation">
        <h1>
          HostPromiseRejectionTracker (
            _promise_: a Promise,
            _operation_: *"reject"* or *"handle"*,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It allows host environments to track promise rejections.</dd>
        </dl>
        <p>The default implementation of HostPromiseRejectionTracker is to return ~unused~.</p>

        <emu-note>
          <p>HostPromiseRejectionTracker is called in two scenarios:</p>

          <ul>
            <li>When a promise is rejected without any handlers, it is called with its _operation_ argument set to *"reject"*.</li>
            <li>When a handler is added to a rejected promise for the first time, it is called with its _operation_ argument set to *"handle"*.</li>
          </ul>

          <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>
        </emu-note>

        <emu-note>
          <p>If _operation_ is *"handle"*, an implementation should not hold a reference to _promise_ in a way that would interfere with garbage collection. An implementation may hold a reference to _promise_ if _operation_ is *"reject"*, since it is expected that rejections will be rare and not on hot code paths.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise Jobs</h1>

      <emu-clause id="sec-newpromisereactionjob" type="abstract operation" oldids="sec-promisereactionjob">
        <h1>
          NewPromiseReactionJob (
            _reaction_: a PromiseReaction Record,
            _argument_: an ECMAScript language value,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record or *null*)
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns a new Job Abstract Closure that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.</dd>
        </dl>
        <emu-alg>
          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:
            1. Let _promiseCapability_ be _reaction_.[[Capability]].
            1. Let _type_ be _reaction_.[[Type]].
            1. Let _handler_ be _reaction_.[[Handler]].
            1. If _handler_ is ~empty~, then
              1. If _type_ is ~fulfill~, then
                1. Let _handlerResult_ be NormalCompletion(_argument_).
              1. Else,
                1. Assert: _type_ is ~reject~.
                1. Let _handlerResult_ be ThrowCompletion(_argument_).
            1. Else,
              1. Let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).
            1. If _promiseCapability_ is *undefined*, then
              1. Assert: _handlerResult_ is not an abrupt completion.
              1. Return ~empty~.
            1. Assert: _promiseCapability_ is a PromiseCapability Record.
            1. If _handlerResult_ is an abrupt completion, then
              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).
            1. Else,
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).
          1. Let _handlerRealm_ be *null*.
          1. If _reaction_.[[Handler]] is not ~empty~, then
            1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).
            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].
            1. Else, set _handlerRealm_ to the current Realm Record.
            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.
          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromiseresolvethenablejob" type="abstract operation" oldids="sec-promiseresolvethenablejob">
        <h1>
          NewPromiseResolveThenableJob (
            _promiseToResolve_: a Promise,
            _thenable_: an Object,
            _then_: a JobCallback Record,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:
            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).
            1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).
            1. If _thenCallResult_ is an abrupt completion, then
              1. Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).
            1. Return ! _thenCallResult_.
          1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).
          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].
          1. Else, let _thenRealm_ be the current Realm Record.
          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.
          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.
        </emu-alg>
        <emu-note>
          <p>This Job uses the supplied thenable and its `then` method to resolve the given promise. This process must take place as a Job to ensure that the evaluation of the `then` method occurs after evaluation of any surrounding code has completed.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-constructor">
      <h1>The Promise Constructor</h1>
      <p>The Promise constructor:</p>
      <ul>
        <li>is <dfn>%Promise%</dfn>.</li>
        <li>is the initial value of the *"Promise"* property of the global object.</li>
        <li>creates and initializes a new Promise when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified Promise behaviour must include a `super` call to the Promise constructor to create and initialize the subclass instance with the internal state necessary to support the `Promise` and `Promise.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-promise-executor">
        <h1>Promise ( _executor_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.
          1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Promise.prototype%"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).
          1. Set _promise_.[[PromiseState]] to ~pending~.
          1. Set _promise_.[[PromiseResult]] to ~empty~.
          1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.
          1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.
          1. Set _promise_.[[PromiseIsHandled]] to *false*.
          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).
          1. Let _completion_ be Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).
          1. If _completion_ is an abrupt completion, then
            1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »).
          1. Return _promise_.
        </emu-alg>
        <emu-note>
          <p>The _executor_ argument must be a function object. It is called for initiating and reporting completion of the possibly deferred action represented by this Promise. The executor is called with two arguments: _resolve_ and _reject_. These are functions that may be used by the _executor_ function to report eventual completion or failure of the deferred computation. Returning from the executor function does not mean that the deferred action has been completed but only that the request to eventually perform the deferred action has been accepted.</p>
          <p>The _resolve_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _resolve_ function to indicate that it wishes to resolve the associated Promise. The argument passed to the _resolve_ function represents the eventual value of the deferred action and can be either the actual fulfillment value or another promise which will provide the value if it is fulfilled.</p>
          <p>The _reject_ function that is passed to an _executor_ function accepts a single argument. The _executor_ code may eventually call the _reject_ function to indicate that the associated Promise is rejected and will never be fulfilled. The argument passed to the _reject_ function is used as the rejection value of the promise. Typically it will be an Error object.</p>
          <p>The resolve and reject functions passed to an _executor_ function by the Promise constructor have the capability to actually resolve and reject the associated promise. Subclasses may have different constructor behaviour that passes in customized values for resolve and reject.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-constructor">
      <h1>Properties of the Promise Constructor</h1>
      <p>The Promise constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-promise.all">
        <h1>Promise.all ( _iterable_ )</h1>
        <p>This function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>This function requires its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>

        <emu-clause id="sec-getpromiseresolve" type="abstract operation">
          <h1>
            GetPromiseResolve (
              _promiseConstructor_: a constructor,
            ): either a normal completion containing a function object or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _promiseResolve_ be ? Get(_promiseConstructor_, *"resolve"*).
            1. If IsCallable(_promiseResolve_) is *false*, throw a *TypeError* exception.
            1. Return _promiseResolve_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-performpromiseall" type="abstract operation">
          <h1>
            PerformPromiseAll (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _values_ be a new empty List.
            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] = 0, then
                  1. Let _valuesArray_ be CreateArrayFromList(_values_).
                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
                1. Return _resultCapability_.[[Promise]].
              1. Append *undefined* to _values_.
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref>.
              1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.all-resolve-element-functions" title></emu-xref>.
              1. Let _onFulfilled_ be CreateBuiltinFunction(_steps_, _length_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
              1. Set _onFulfilled_.[[AlreadyCalled]] to *false*.
              1. Set _onFulfilled_.[[Index]] to _index_.
              1. Set _onFulfilled_.[[Values]] to _values_.
              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.
              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _resultCapability_.[[Reject]] »).
              1. Set _index_ to _index_ + 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.all-resolve-element-functions">
          <h1>`Promise.all` Resolve Element Functions</h1>
          <p>A `Promise.all` resolve element function is an anonymous built-in function that is used to resolve a specific `Promise.all` element. Each `Promise.all` resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.all` resolve element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.
            1. Set _F_.[[AlreadyCalled]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Set _values_[_index_] to _x_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.all` resolve element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.allsettled">
        <h1>Promise.allSettled ( _iterable_ )</h1>
        <p>This function returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>This function requires its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseallsettled" type="abstract operation">
          <h1>
            PerformPromiseAllSettled (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _values_ be a new empty List.
            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] = 0, then
                  1. Let _valuesArray_ be CreateArrayFromList(_values_).
                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
                1. Return _resultCapability_.[[Promise]].
              1. Append *undefined* to _values_.
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref>.
              1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.allsettled-resolve-element-functions" title></emu-xref>.
              1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
              1. Let _alreadyCalled_ be the Record { [[Value]]: *false* }.
              1. Set _onFulfilled_.[[AlreadyCalled]] to _alreadyCalled_.
              1. Set _onFulfilled_.[[Index]] to _index_.
              1. Set _onFulfilled_.[[Values]] to _values_.
              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.
              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.
              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref>.
              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.allsettled-reject-element-functions" title></emu-xref>.
              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).
              1. Set _onRejected_.[[AlreadyCalled]] to _alreadyCalled_.
              1. Set _onRejected_.[[Index]] to _index_.
              1. Set _onRejected_.[[Values]] to _values_.
              1. Set _onRejected_.[[Capability]] to _resultCapability_.
              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _onFulfilled_, _onRejected_ »).
              1. Set _index_ to _index_ + 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-resolve-element-functions">
          <h1>`Promise.allSettled` Resolve Element Functions</h1>
          <p>A `Promise.allSettled` resolve element function is an anonymous built-in function that is used to resolve a specific `Promise.allSettled` element. Each `Promise.allSettled` resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.allSettled` resolve element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].
            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyCalled_.[[Value]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"fulfilled"*).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"value"*, _x_).
            1. Set _values_[_index_] to _obj_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.allSettled` resolve element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>

        <emu-clause id="sec-promise.allsettled-reject-element-functions">
          <h1>`Promise.allSettled` Reject Element Functions</h1>
          <p>A `Promise.allSettled` reject element function is an anonymous built-in function that is used to reject a specific `Promise.allSettled` element. Each `Promise.allSettled` reject element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.allSettled` reject element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].
            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.
            1. Set _alreadyCalled_.[[Value]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _values_ be _F_.[[Values]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"status"*, *"rejected"*).
            1. Perform ! CreateDataPropertyOrThrow(_obj_, *"reason"*, _x_).
            1. Set _values_[_index_] to _obj_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _valuesArray_ be CreateArrayFromList(_values_).
              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.allSettled` reject element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.any">
        <h1>Promise.any ( _iterable_ )</h1>
        <p>This function returns a promise that is fulfilled by the first given promise to be fulfilled, or rejected with an `AggregateError` holding the rejection reasons if all of the given promises are rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>This function requires its *this* value to be a constructor function that supports the parameter conventions of the `Promise` constructor.</p>
        </emu-note>

        <emu-clause id="sec-performpromiseany" type="abstract operation">
          <h1>
            PerformPromiseAny (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Let _errors_ be a new empty List.
            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.
            1. Let _index_ be 0.
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
                1. If _remainingElementsCount_.[[Value]] = 0, then
                  1. Let _error_ be a newly created *AggregateError* object.
                  1. Perform ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).
                  1. Return ThrowCompletion(_error_).
                1. Return _resultCapability_.[[Promise]].
              1. Append *undefined* to _errors_.
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref>.
              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href="#sec-promise.any-reject-element-functions" title></emu-xref>.
              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *""*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).
              1. Set _onRejected_.[[AlreadyCalled]] to *false*.
              1. Set _onRejected_.[[Index]] to _index_.
              1. Set _onRejected_.[[Errors]] to _errors_.
              1. Set _onRejected_.[[Capability]] to _resultCapability_.
              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.
              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _onRejected_ »).
              1. Set _index_ to _index_ + 1.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-promise.any-reject-element-functions">
          <h1>`Promise.any` Reject Element Functions</h1>
          <p>A `Promise.any` reject element function is an anonymous built-in function that is used to reject a specific `Promise.any` element. Each `Promise.any` reject element function has [[Index]], [[Errors]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>
          <p>When a `Promise.any` reject element function is called with argument _x_, the following steps are taken:</p>
          <emu-alg>
            1. Let _F_ be the active function object.
            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.
            1. Set _F_.[[AlreadyCalled]] to *true*.
            1. Let _index_ be _F_.[[Index]].
            1. Let _errors_ be _F_.[[Errors]].
            1. Let _promiseCapability_ be _F_.[[Capability]].
            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].
            1. Set _errors_[_index_] to _x_.
            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.
            1. If _remainingElementsCount_.[[Value]] = 0, then
              1. Let _error_ be a newly created *AggregateError* object.
              1. Perform ! DefinePropertyOrThrow(_error_, *"errors"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).
              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ »).
            1. Return *undefined*.
          </emu-alg>
          <p>The *"length"* property of a `Promise.any` reject element function is *1*<sub>𝔽</sub>.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.prototype">
        <h1>Promise.prototype</h1>
        <p>The initial value of `Promise.prototype` is the Promise prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="sec-promise.race">
        <h1>Promise.race ( _iterable_ )</h1>
        <p>This function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed _iterable_ to promises as it runs this algorithm.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).
          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).
          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).
          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).
          1. Let _result_ be Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).
          1. If _result_ is an abrupt completion, then
            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).
            1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Return ! _result_.
        </emu-alg>
        <emu-note>
          <p>If the _iterable_ argument yields no values or if none of the promises yielded by _iterable_ ever settle, then the pending promise returned by this method will never be settled.</p>
        </emu-note>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor. It also expects that its *this* value provides a `resolve` method.</p>
        </emu-note>

        <emu-clause id="sec-performpromiserace" type="abstract operation">
          <h1>
            PerformPromiseRace (
              _iteratorRecord_: an Iterator Record,
              _constructor_: a constructor,
              _resultCapability_: a PromiseCapability Record,
              _promiseResolve_: a function object,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Repeat,
              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).
              1. If _next_ is ~done~, then
                1. Return _resultCapability_.[[Promise]].
              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).
              1. Perform ? Invoke(_nextPromise_, *"then"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.reject">
        <h1>Promise.reject ( _r_ )</h1>
        <p>This function returns a new promise rejected with the passed argument.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.resolve">
        <h1>Promise.resolve ( _x_ )</h1>
        <p>This function returns either a new promise resolved with the passed argument, or the argument itself if the argument is a promise produced by this constructor.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _C_ is not an Object, throw a *TypeError* exception.
          1. Return ? PromiseResolve(_C_, _x_).
        </emu-alg>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>

        <emu-clause id="sec-promise-resolve" type="abstract operation">
          <h1>
            PromiseResolve (
              _C_: an Object,
              _x_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It returns a new promise resolved with _x_.</dd>
          </dl>
          <emu-alg>
            1. If IsPromise(_x_) is *true*, then
              1. Let _xConstructor_ be ? Get(_x_, *"constructor"*).
              1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.
            1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »).
            1. Return _promiseCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-promise.try">
        <h1>Promise.try ( _callback_, ..._args_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. If _C_ is not an Object, throw a *TypeError* exception.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _status_ be Completion(Call(_callback_, *undefined*, _args_)).
          1. If _status_ is an abrupt completion, then
            1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _status_.[[Value]] »).
          1. Else,
            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _status_.[[Value]] »).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
        <emu-note>
          <p>This function expects its *this* value to be a constructor function that supports the parameter conventions of the Promise constructor.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-promise.withResolvers">
        <h1>Promise.withResolvers ( )</h1>
        <p>This function returns an object with three properties: a new promise together with the `resolve` and `reject` functions associated with it.</p>
        <emu-alg>
          1. Let _C_ be the *this* value.
          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).
          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, *"promise"*, _promiseCapability_.[[Promise]]).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, *"resolve"*, _promiseCapability_.[[Resolve]]).
          1. Perform ! CreateDataPropertyOrThrow(_obj_, *"reject"*, _promiseCapability_.[[Reject]]).
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-get-promise-@@species" id="sec-get-promise-%symbol.species%">
        <h1>get Promise [ %Symbol.species% ]</h1>
        <p>`Promise[%Symbol.species%]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
        <emu-note>
          <p>Promise prototype methods normally use their *this* value's constructor to create a derived object. However, a subclass constructor may over-ride that default behaviour by redefining its %Symbol.species% property.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Properties of the Promise Prototype Object</h1>
      <p>The <dfn>Promise prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Promise.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[PromiseState]] internal slot or any of the other internal slots of Promise instances.</li>
      </ul>

      <emu-clause id="sec-promise.prototype.catch">
        <h1>Promise.prototype.catch ( _onRejected_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. Return ? Invoke(_promise_, *"then"*, « *undefined*, _onRejected_ »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.constructor">
        <h1>Promise.prototype.constructor</h1>
        <p>The initial value of `Promise.prototype.constructor` is %Promise%.</p>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.finally" oldids="sec-thenfinallyfunctions,sec-catchfinallyfunctions">
        <h1>Promise.prototype.finally ( _onFinally_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If _promise_ is not an Object, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Assert: IsConstructor(_C_) is *true*.
          1. If IsCallable(_onFinally_) is *false*, then
            1. Let _thenFinally_ be _onFinally_.
            1. Let _catchFinally_ be _onFinally_.
          1. Else,
            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:
              1. Let _result_ be ? Call(_onFinally_, *undefined*).
              1. Let _p_ be ? PromiseResolve(_C_, _result_).
              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:
                1. Return NormalCompletion(_value_).
              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *""*, « »).
              1. Return ? Invoke(_p_, *"then"*, « _valueThunk_ »).
            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *""*, « »).
            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:
              1. Let _result_ be ? Call(_onFinally_, *undefined*).
              1. Let _p_ be ? PromiseResolve(_C_, _result_).
              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:
                1. Return ThrowCompletion(_reason_).
              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *""*, « »).
              1. Return ? Invoke(_p_, *"then"*, « _thrower_ »).
            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *""*, « »).
          1. Return ? Invoke(_promise_, *"then"*, « _thenFinally_, _catchFinally_ »).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).
        </emu-alg>

        <emu-clause id="sec-performpromisethen" type="abstract operation">
          <h1>
            PerformPromiseThen (
              _promise_: a Promise,
              _onFulfilled_: an ECMAScript language value,
              _onRejected_: an ECMAScript language value,
              optional _resultCapability_: a PromiseCapability Record,
            ): an ECMAScript language value
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs the “then” operation on _promise_ using _onFulfilled_ and _onRejected_ as its settlement actions. If _resultCapability_ is passed, the result is stored by updating _resultCapability_'s promise. If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter.</dd>
          </dl>
          <emu-alg>
            1. Assert: IsPromise(_promise_) is *true*.
            1. If _resultCapability_ is not present, then
              1. Set _resultCapability_ to *undefined*.
            1. If IsCallable(_onFulfilled_) is *false*, then
              1. Let _onFulfilledJobCallback_ be ~empty~.
            1. Else,
              1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).
            1. If IsCallable(_onRejected_) is *false*, then
              1. Let _onRejectedJobCallback_ be ~empty~.
            1. Else,
              1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).
            1. Let _fulfillReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ }.
            1. Let _rejectReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ }.
            1. If _promise_.[[PromiseState]] is ~pending~, then
              1. Append _fulfillReaction_ to _promise_.[[PromiseFulfillReactions]].
              1. Append _rejectReaction_ to _promise_.[[PromiseRejectReactions]].
            1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then
              1. Let _value_ be _promise_.[[PromiseResult]].
              1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).
              1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).
            1. Else,
              1. Assert: _promise_.[[PromiseState]] is ~rejected~.
              1. Let _reason_ be _promise_.[[PromiseResult]].
              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *"handle"*).
              1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).
              1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).
            1. Set _promise_.[[PromiseIsHandled]] to *true*.
            1. If _resultCapability_ is *undefined*, then
              1. Return *undefined*.
            1. Else,
              1. Return _resultCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause oldids="sec-promise.prototype-@@tostringtag" id="sec-promise.prototype-%symbol.tostringtag%">
        <h1>Promise.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Promise"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-promise-instances">
      <h1>Properties of Promise Instances</h1>
      <p>Promise instances are ordinary objects that inherit properties from the Promise prototype object (the intrinsic, %Promise.prototype%). Promise instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-promise-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-promise-instances" caption="Internal Slots of Promise Instances" oldids="table-59">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[PromiseState]]
            </td>
            <td>
              ~pending~, ~fulfilled~, or ~rejected~
            </td>
            <td>
              Governs how a promise will react to incoming calls to its `then` method.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseResult]]
            </td>
            <td>
              an ECMAScript language value or ~empty~
            </td>
            <td>
              The value with which the promise has been fulfilled or rejected, if any. ~empty~ if and only if the [[PromiseState]] is ~pending~.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseFulfillReactions]]
            </td>
            <td>
              a List of PromiseReaction Records
            </td>
            <td>
              Records to be processed when/if the promise transitions from the ~pending~ state to the ~fulfilled~ state.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseRejectReactions]]
            </td>
            <td>
              a List of PromiseReaction Records
            </td>
            <td>
              Records to be processed when/if the promise transitions from the ~pending~ state to the ~rejected~ state.
            </td>
          </tr>
          <tr>
            <td>
              [[PromiseIsHandled]]
            </td>
            <td>
              a Boolean
            </td>
            <td>
              Indicates whether the promise has ever had a fulfillment or rejection handler; used in unhandled rejection tracking.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generatorfunction-objects">
    <h1>GeneratorFunction Objects</h1>
    <p>GeneratorFunctions are functions that are usually created by evaluating |GeneratorDeclaration|s, |GeneratorExpression|s, and |GeneratorMethod|s. They may also be created by calling the %GeneratorFunction% intrinsic.</p>
    <emu-figure id="figure-2" caption="Generator Objects Relationships" informative>
      <img alt="A staggering variety of boxes and arrows." height="700" src="img/figure-2.svg" width="900">
    </emu-figure>

    <emu-clause id="sec-generatorfunction-constructor">
      <h1>The GeneratorFunction Constructor</h1>
      <p>The GeneratorFunction constructor:</p>
      <ul>
        <li>is <dfn>%GeneratorFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new GeneratorFunction when called as a function rather than as a constructor. Thus the function call `GeneratorFunction (…)` is equivalent to the object creation expression `new GeneratorFunction (…)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified GeneratorFunction behaviour must include a `super` call to the GeneratorFunction constructor to create and initialize subclass instances with the internal slots necessary for built-in GeneratorFunction behaviour. All ECMAScript syntactic forms for defining generator function objects create direct instances of GeneratorFunction. There is no syntactic means to create instances of GeneratorFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-generatorfunction">
        <h1>GeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of a generator function; any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_).
        </emu-alg>
        <emu-note>
          <p>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-constructor">
      <h1>Properties of the GeneratorFunction Constructor</h1>
      <p>The GeneratorFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the Function constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function%.</li>
        <li oldids="sec-generatorfunction.length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is *"GeneratorFunction"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype">
        <h1>GeneratorFunction.prototype</h1>
        <p>The initial value of `GeneratorFunction.prototype` is the GeneratorFunction prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-generatorfunction-prototype-object">
      <h1>Properties of the GeneratorFunction Prototype Object</h1>
      <p>The <dfn>GeneratorFunction prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%GeneratorFunction.prototype%</dfn> (see <emu-xref href="#figure-2"></emu-xref>).</li>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> or <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <emu-clause id="sec-generatorfunction.prototype.constructor">
        <h1>GeneratorFunction.prototype.constructor</h1>
        <p>The initial value of `GeneratorFunction.prototype.constructor` is %GeneratorFunction%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction.prototype.prototype">
        <h1>GeneratorFunction.prototype.prototype</h1>
        <p>The initial value of `GeneratorFunction.prototype.prototype` is %GeneratorPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-generatorfunction.prototype-@@tostringtag" id="sec-generatorfunction.prototype-%symbol.tostringtag%">
        <h1>GeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"GeneratorFunction"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-generatorfunction-instances">
      <h1>GeneratorFunction Instances</h1>
      <p>Every GeneratorFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. The value of the [[IsClassConstructor]] internal slot for all such instances is *false*.</p>
      <p>Each GeneratorFunction instance has the following own properties:</p>

      <emu-clause id="sec-generatorfunction-instances-length">
        <h1>length</h1>
        <p>The specification for the *"length"* property of Function instances given in <emu-xref href="#sec-function-instances-length"></emu-xref> also applies to GeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-name">
        <h1>name</h1>
        <p>The specification for the *"name"* property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to GeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-generatorfunction-instances-prototype">
        <h1>prototype</h1>
        <p>Whenever a GeneratorFunction instance is created another ordinary object is also created and is the initial value of the generator function's *"prototype"* property. The value of the prototype property is used to initialize the [[Prototype]] internal slot of a newly created Generator when the generator function object is invoked using [[Call]].</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Unlike Function instances, the object that is the value of a GeneratorFunction's *"prototype"* property does not have a *"constructor"* property whose value is the GeneratorFunction instance.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgeneratorfunction-objects">
    <h1>AsyncGeneratorFunction Objects</h1>
    <p>AsyncGeneratorFunctions are functions that are usually created by evaluating |AsyncGeneratorDeclaration|, |AsyncGeneratorExpression|, and |AsyncGeneratorMethod| syntactic productions. They may also be created by calling the %AsyncGeneratorFunction% intrinsic.</p>

    <emu-clause id="sec-asyncgeneratorfunction-constructor">
      <h1>The AsyncGeneratorFunction Constructor</h1>
      <p>The AsyncGeneratorFunction constructor:</p>
      <ul>
        <li>is <dfn>%AsyncGeneratorFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new AsyncGeneratorFunction when called as a function rather than as a constructor. Thus the function call `AsyncGeneratorFunction (...)` is equivalent to the object creation expression `new AsyncGeneratorFunction (...)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncGeneratorFunction behaviour must include a `super` call to the AsyncGeneratorFunction constructor to create and initialize subclass instances with the internal slots necessary for built-in AsyncGeneratorFunction behaviour. All ECMAScript syntactic forms for defining async generator function objects create direct instances of AsyncGeneratorFunction. There is no syntactic means to create instances of AsyncGeneratorFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction">
        <h1>AsyncGeneratorFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of an async generator function; any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_).
        </emu-alg>
        <emu-note>
          <p>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction">
      <h1>Properties of the AsyncGeneratorFunction Constructor</h1>
      <p>The AsyncGeneratorFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the Function constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function%.</li>
        <li oldids="sec-asyncgeneratorfunction-length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is *"AsyncGeneratorFunction"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype">
        <h1>AsyncGeneratorFunction.prototype</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype` is the AsyncGeneratorFunction prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgeneratorfunction-prototype">
      <h1>Properties of the AsyncGeneratorFunction Prototype Object</h1>
      <p>The <dfn>AsyncGeneratorFunction prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncGeneratorFunction.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref> or <emu-xref href="#table-internal-slots-of-asyncgenerator-instances"></emu-xref>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-constructor">
        <h1>AsyncGeneratorFunction.prototype.constructor</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype.constructor` is %AsyncGeneratorFunction%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-prototype-prototype">
        <h1>AsyncGeneratorFunction.prototype.prototype</h1>
        <p>The initial value of `AsyncGeneratorFunction.prototype.prototype` is %AsyncGeneratorPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-asyncgeneratorfunction-prototype-tostringtag" id="sec-asyncgeneratorfunction-prototype-%symbol.tostringtag%">
        <h1>AsyncGeneratorFunction.prototype [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"AsyncGeneratorFunction"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-asyncgeneratorfunction-instances">
      <h1>AsyncGeneratorFunction Instances</h1>
      <p>Every AsyncGeneratorFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. The value of the [[IsClassConstructor]] internal slot for all such instances is *false*.</p>
      <p>Each AsyncGeneratorFunction instance has the following own properties:</p>

      <emu-clause id="sec-asyncgeneratorfunction-instance-length">
        <h1>length</h1>
        <p>The value of the *"length"* property is an integral Number that indicates the typical number of arguments expected by the AsyncGeneratorFunction. However, the language permits the function to be invoked with some other number of arguments. The behaviour of an AsyncGeneratorFunction when invoked on a number of arguments other than the number specified by its *"length"* property depends on the function.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-name">
        <h1>name</h1>
        <p>The specification for the *"name"* property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to AsyncGeneratorFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorfunction-instance-prototype">
        <h1>prototype</h1>
        <p>Whenever an AsyncGeneratorFunction instance is created, another ordinary object is also created and is the initial value of the async generator function's *"prototype"* property. The value of the prototype property is used to initialize the [[Prototype]] internal slot of a newly created AsyncGenerator when the generator function object is invoked using [[Call]].</p>
        <p>This property has the attributes { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
        <emu-note>
          <p>Unlike function instances, the object that is the value of an AsyncGeneratorFunction's *"prototype"* property does not have a *"constructor"* property whose value is the AsyncGeneratorFunction instance.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator Objects</h1>
    <p>A Generator is created by calling a generator function and conforms to both the iterator interface and the iterable interface.</p>
    <p>Generator instances directly inherit properties from the initial value of the *"prototype"* property of the generator function that created the instance. Generator instances indirectly inherit properties from %GeneratorPrototype%.</p>

    <emu-clause id="sec-properties-of-generator-prototype">
      <h1>The %GeneratorPrototype% Object</h1>
      <p>The <dfn>%GeneratorPrototype%</dfn> object:</p>
      <ul>
        <li>is <dfn>%GeneratorFunction.prototype.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a Generator instance and does not have a [[GeneratorState]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %Iterator.prototype%.</li>
        <li>has properties that are indirectly inherited by all Generator instances.</li>
      </ul>

      <emu-clause id="sec-generator.prototype.constructor">
        <h1>%GeneratorPrototype%.constructor</h1>
        <p>The initial value of %GeneratorPrototype%`.constructor` is %GeneratorFunction.prototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.next">
        <h1>%GeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. Return ? GeneratorResume(*this* value, _value_, ~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.return">
        <h1>%GeneratorPrototype%.return ( _value_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Let _C_ be ReturnCompletion(_value_).
          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generator.prototype.throw">
        <h1>%GeneratorPrototype%.throw ( _exception_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _g_ be the *this* value.
          1. Let _C_ be ThrowCompletion(_exception_).
          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-generator.prototype-@@tostringtag" id="sec-generator.prototype-%symbol.tostringtag%">
        <h1>%GeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"Generator"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Properties of Generator Instances</h1>
      <p>Generator instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Internal Slots of Generator Instances" oldids="table-56">
        <table>
          <thead>
            <tr>
              <th>
                Internal Slot
              </th>
              <th>
                Type
              </th>
              <th>
                Description
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              ~suspended-start~, ~suspended-yield~, ~executing~, or ~completed~
            </td>
            <td>
              The current execution state of the generator.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              an execution context
            </td>
            <td>
              The execution context that is used when executing the code of this generator.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              a String or ~empty~
            </td>
            <td>
              A brand used to distinguish different kinds of generators. The [[GeneratorBrand]] of generators declared by ECMAScript source text is always ~empty~.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator Abstract Operations</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[GeneratorState]] is ~suspended-start~.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.
            1. If _result_ is a normal completion, then
              1. Let _resultValue_ be *undefined*.
            1. Else if _result_ is a return completion, then
              1. Let _resultValue_ be _result_.[[Value]].
            1. Else,
              1. Assert: _result_ is a throw completion.
              1. Return ? _result_.
            1. Return NormalCompletion(CreateIteratorResultObject(_resultValue_, *true*)).
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[GeneratorContext]] to _genContext_.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing one of ~suspended-start~, ~suspended-yield~, or ~completed~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. Assert: _generator_ also has a [[GeneratorContext]] internal slot.
          1. Let _state_ be _generator_.[[GeneratorState]].
          1. If _state_ is ~executing~, throw a *TypeError* exception.
          1. Return _state_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~completed~, return CreateIteratorResultObject(*undefined*, *true*).
          1. Assert: _state_ is either ~suspended-start~ or ~suspended-yield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~suspended-start~, then
            1. Set _generator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. Set _state_ to ~completed~.
          1. If _state_ is ~completed~, then
            1. If _abruptCompletion_ is a return completion, then
              1. Return CreateIteratorResultObject(_abruptCompletion_.[[Value]], *true*).
            1. Return ? _abruptCompletion_.
          1. Assert: _state_ is ~suspended-yield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getgeneratorkind" type="abstract operation">
        <h1>GetGeneratorKind ( ): ~non-generator~, ~sync~, or ~async~</h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. If _genContext_ does not have a Generator component, return ~non-generator~.
          1. Let _generator_ be the Generator component of _genContext_.
          1. If _generator_ has an [[AsyncGeneratorState]] internal slot, return ~async~.
          1. Else, return ~sync~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatoryield" type="abstract operation">
        <h1>
          GeneratorYield (
            _iteratorResult_: an Object that conforms to the IteratorResult interface,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
          <dt>skip return checks</dt>
          <dd>true</dd>
        </dl>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. Assert: _genContext_ is the execution context of a generator.
          1. Let _generator_ be the value of the Generator component of _genContext_.
          1. Assert: GetGeneratorKind() is ~sync~.
          1. Set _generator_.[[GeneratorState]] to ~suspended-yield~.
          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Let _callerContext_ be the running execution context.
          1. Resume _callerContext_ passing NormalCompletion(_iteratorResult_). If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.
          1. Assert: If control reaches here, then _genContext_ is the running execution context again.
          1. Return _resumptionValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-yield" type="abstract operation">
        <h1>
          Yield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _generatorKind_ be GetGeneratorKind().
          1. If _generatorKind_ is ~async~, return ? AsyncGeneratorYield(? Await(_value_)).
          1. Otherwise, return ? GeneratorYield(CreateIteratorResultObject(_value_, *false*)).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
            optional _extraSlots_: a List of names of internal slots,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.
          1. If _extraSlots_ is not present, set _extraSlots_ to a new empty List.
          1. Let _internalSlotsList_ be the list-concatenation of _extraSlots_ and « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[GeneratorState]] to ~suspended-start~.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform GeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator Objects</h1>
    <p>An AsyncGenerator is created by calling an async generator function and conforms to both the async iterator interface and the async iterable interface.</p>

    <p>AsyncGenerator instances directly inherit properties from the initial value of the *"prototype"* property of the async generator function that created the instance. AsyncGenerator instances indirectly inherit properties from %AsyncGeneratorPrototype%.</p>

    <emu-clause id="sec-properties-of-asyncgenerator-prototype">
      <h1>The %AsyncGeneratorPrototype% Object</h1>
      <p>The <dfn>%AsyncGeneratorPrototype%</dfn> object:</p>
      <ul>
        <li>is <dfn>%AsyncGeneratorFunction.prototype.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not an AsyncGenerator instance and does not have an [[AsyncGeneratorState]] internal slot.</li>
        <li>has a [[Prototype]] internal slot whose value is %AsyncIteratorPrototype%.</li>
        <li>has properties that are indirectly inherited by all AsyncGenerator instances.</li>
      </ul>

      <emu-clause id="sec-asyncgenerator-prototype-constructor">
        <h1>%AsyncGeneratorPrototype%.constructor</h1>
        <p>The initial value of %AsyncGeneratorPrototype%`.constructor` is %AsyncGeneratorFunction.prototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-next">
        <h1>%AsyncGeneratorPrototype%.next ( _value_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is ~completed~, then
            1. Let _iteratorResult_ be CreateIteratorResultObject(*undefined*, *true*).
            1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).
            1. Return _promiseCapability_.[[Promise]].
          1. Let _completion_ be NormalCompletion(_value_).
          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
          1. If _state_ is either ~suspended-start~ or ~suspended-yield~, then
            1. Perform AsyncGeneratorResume(_generator_, _completion_).
          1. Else,
            1. Assert: _state_ is either ~executing~ or ~draining-queue~.
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-return">
        <h1>%AsyncGeneratorPrototype%.return ( _value_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Let _completion_ be ReturnCompletion(_value_).
          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is either ~suspended-start~ or ~completed~, then
            1. Set _generator_.[[AsyncGeneratorState]] to ~draining-queue~.
            1. Perform AsyncGeneratorAwaitReturn(_generator_).
          1. Else if _state_ is ~suspended-yield~, then
            1. Perform AsyncGeneratorResume(_generator_, _completion_).
          1. Else,
            1. Assert: _state_ is either ~executing~ or ~draining-queue~.
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgenerator-prototype-throw">
        <h1>%AsyncGeneratorPrototype%.throw ( _exception_ )</h1>
        <emu-alg>
          1. Let _generator_ be the *this* value.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).
          1. IfAbruptRejectPromise(_result_, _promiseCapability_).
          1. Let _state_ be _generator_.[[AsyncGeneratorState]].
          1. If _state_ is ~suspended-start~, then
            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.
            1. Set _state_ to ~completed~.
          1. If _state_ is ~completed~, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »).
            1. Return _promiseCapability_.[[Promise]].
          1. Let _completion_ be ThrowCompletion(_exception_).
          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).
          1. If _state_ is ~suspended-yield~, then
            1. Perform AsyncGeneratorResume(_generator_, _completion_).
          1. Else,
            1. Assert: _state_ is either ~executing~ or ~draining-queue~.
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <emu-clause oldids="sec-asyncgenerator-prototype-tostringtag" id="sec-asyncgenerator-prototype-%symbol.tostringtag%">
        <h1>%AsyncGeneratorPrototype% [ %Symbol.toStringTag% ]</h1>
        <p>The initial value of the %Symbol.toStringTag% property is the String value *"AsyncGenerator"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>Properties of AsyncGenerator Instances</h1>
      <p>AsyncGenerator instances are initially created with the internal slots described below:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="Internal Slots of AsyncGenerator Instances">
        <table>
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>~suspended-start~, ~suspended-yield~, ~executing~, ~draining-queue~, or ~completed~</td>
            <td>The current execution state of the async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>an execution context</td>
            <td>The execution context that is used when executing the code of this async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>a List of AsyncGeneratorRequest Records</td>
            <td>Records which represent requests to resume the async generator. Except during state transitions, it is non-empty if and only if [[AsyncGeneratorState]] is either ~executing~ or ~draining-queue~.</td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>a String or ~empty~</td>
            <td>A brand used to distinguish different kinds of async generators. The [[GeneratorBrand]] of async generators declared by ECMAScript source text is always ~empty~.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator Abstract Operations</h1>

      <emu-clause id="sec-asyncgeneratorrequest-records">
        <h1>AsyncGeneratorRequest Records</h1>
        <p>An <dfn variants="AsyncGeneratorRequests">AsyncGeneratorRequest</dfn> is a Record value used to store information about how an async generator should be resumed and contains capabilities for fulfilling or rejecting the corresponding promise.</p>
        <p>They have the following fields:</p>
        <emu-table caption="AsyncGeneratorRequest Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Completion]]</td>
              <td>a Completion Record</td>
              <td>The Completion Record which should be used to resume the async generator.</td>
            </tr>
            <tr>
              <td>[[Capability]]</td>
              <td>a PromiseCapability Record</td>
              <td>The promise capabilities associated with this request.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is ~suspended-start~.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~draining-queue~.
            1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).
            1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).
            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).
            1. Return NormalCompletion(*undefined*).
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.
          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorenqueue" type="abstract operation">
        <h1>
          AsyncGeneratorEnqueue (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _promiseCapability_: a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.
          1. Append _request_ to _generator_.[[AsyncGeneratorQueue]].
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorcompletestep" type="abstract operation">
        <h1>
          AsyncGeneratorCompleteStep (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
            _done_: a Boolean,
            optional _realm_: a Realm Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorQueue]] is not empty.
          1. Let _next_ be the first element of _generator_.[[AsyncGeneratorQueue]].
          1. Remove the first element from _generator_.[[AsyncGeneratorQueue]].
          1. Let _promiseCapability_ be _next_.[[Capability]].
          1. Let _value_ be _completion_.[[Value]].
          1. If _completion_ is a throw completion, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).
          1. Else,
            1. Assert: _completion_ is a normal completion.
            1. If _realm_ is present, then
              1. Let _oldRealm_ be the running execution context's Realm.
              1. Set the running execution context's Realm to _realm_.
              1. Let _iteratorResult_ be CreateIteratorResultObject(_value_, _done_).
              1. Set the running execution context's Realm to _oldRealm_.
            1. Else,
              1. Let _iteratorResult_ be CreateIteratorResultObject(_value_, _done_).
            1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspended-start~ or ~suspended-yield~.
          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].
          1. Let _callerContext_ be the running execution context.
          1. Suspend _callerContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: _result_ is never an abrupt completion.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorunwrapyieldresumption" type="abstract operation">
        <h1>
          AsyncGeneratorUnwrapYieldResumption (
            _resumptionValue_: a Completion Record,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _resumptionValue_ is not a return completion, return ? _resumptionValue_.
          1. Let _awaited_ be Completion(Await(_resumptionValue_.[[Value]])).
          1. If _awaited_ is a throw completion, return ? _awaited_.
          1. Assert: _awaited_ is a normal completion.
          1. Return ReturnCompletion(_awaited_.[[Value]]).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratoryield" type="abstract operation">
        <h1>
          AsyncGeneratorYield (
            _value_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _genContext_ be the running execution context.
          1. Assert: _genContext_ is the execution context of a generator.
          1. Let _generator_ be the value of the Generator component of _genContext_.
          1. Assert: GetGeneratorKind() is ~async~.
          1. Let _completion_ be NormalCompletion(_value_).
          1. Assert: The execution context stack has at least two elements.
          1. Let _previousContext_ be the second to top element of the execution context stack.
          1. Let _previousRealm_ be _previousContext_'s Realm.
          1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_).
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. If _queue_ is not empty, then
            1. NOTE: Execution continues without suspending the generator.
            1. Let _toYield_ be the first element of _queue_.
            1. Let _resumptionValue_ be Completion(_toYield_.[[Completion]]).
            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).
          1. Else,
            1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-yield~.
            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Let _callerContext_ be the running execution context.
            1. Resume _callerContext_ passing *undefined*. If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.
            1. Assert: If control reaches here, then _genContext_ is the running execution context again.
            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorawaitreturn" type="abstract operation">
        <h1>
          AsyncGeneratorAwaitReturn (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Assert: _queue_ is not empty.
          1. Let _next_ be the first element of _queue_.
          1. Let _completion_ be Completion(_next_.[[Completion]]).
          1. Assert: _completion_ is a return completion.
          1. Let _promiseCompletion_ be Completion(PromiseResolve(%Promise%, _completion_.[[Value]])).
          1. If _promiseCompletion_ is an abrupt completion, then
            1. Perform AsyncGeneratorCompleteStep(_generator_, _promiseCompletion_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return ~unused~.
          1. Assert: _promiseCompletion_ is a normal completion.
          1. Let _promise_ be _promiseCompletion_.[[Value]].
          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:
            1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
            1. Let _result_ be NormalCompletion(_value_).
            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return NormalCompletion(*undefined*).
          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « »).
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:
            1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
            1. Let _result_ be ThrowCompletion(_reason_).
            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_generator_).
            1. Return NormalCompletion(*undefined*).
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »).
          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratordrainqueue" type="abstract operation">
        <h1>
          AsyncGeneratorDrainQueue (
            _generator_: an AsyncGenerator,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It drains the generator's AsyncGeneratorQueue until it encounters an AsyncGeneratorRequest which holds a return completion.</dd>
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is ~draining-queue~.
          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].
          1. Repeat, while _queue_ is not empty,
            1. Let _next_ be the first element of _queue_.
            1. Let _completion_ be Completion(_next_.[[Completion]]).
            1. If _completion_ is a return completion, then
              1. Perform AsyncGeneratorAwaitReturn(_generator_).
              1. Return ~unused~.
            1. Else,
              1. If _completion_ is a normal completion, then
                1. Set _completion_ to NormalCompletion(*undefined*).
              1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *true*).
          1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.
          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform AsyncGeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-objects">
    <h1>AsyncFunction Objects</h1>
    <p>AsyncFunctions are functions that are usually created by evaluating |AsyncFunctionDeclaration|s, |AsyncFunctionExpression|s, |AsyncMethod|s, and |AsyncArrowFunction|s. They may also be created by calling the %AsyncFunction% intrinsic.</p>

    <emu-clause id="sec-async-function-constructor">
      <h1>The AsyncFunction Constructor</h1>

      <p>The AsyncFunction constructor:</p>
      <ul>
        <li>is <dfn>%AsyncFunction%</dfn>.</li>
        <li>is a subclass of `Function`.</li>
        <li>creates and initializes a new AsyncFunction when called as a function rather than as a constructor. Thus the function call `AsyncFunction(…)` is equivalent to the object creation expression `new AsyncFunction(…)` with the same arguments.</li>
        <li>may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncFunction behaviour must include a `super` call to the AsyncFunction constructor to create and initialize a subclass instance with the internal slots necessary for built-in async function behaviour. All ECMAScript syntactic forms for defining async function objects create direct instances of AsyncFunction. There is no syntactic means to create instances of AsyncFunction subclasses.</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-arguments">
        <h1>AsyncFunction ( ..._parameterArgs_, _bodyArg_ )</h1>
        <p>The last argument (if any) specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.</p>
        <p>This function performs the following steps when called:</p>

        <emu-alg>
          1. Let _C_ be the active function object.
          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.
          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_).
        </emu-alg>

        <emu-note>See NOTE for <emu-xref href="#sec-function-p1-p2-pn-body"></emu-xref>.</emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-constructor-properties">
      <h1>Properties of the AsyncFunction Constructor</h1>

      <p>The AsyncFunction constructor:</p>
      <ul>
        <li>is a standard built-in function object that inherits from the Function constructor.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function%.</li>
        <li oldids="sec-async-function-constructor-length">has a *"length"* property whose value is *1*<sub>𝔽</sub>.</li>
        <li>has a *"name"* property whose value is *"AsyncFunction"*.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-async-function-constructor-prototype">
        <h1>AsyncFunction.prototype</h1>
        <p>The initial value of `AsyncFunction.prototype` is the AsyncFunction prototype object.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-prototype-properties">
      <h1>Properties of the AsyncFunction Prototype Object</h1>
      <p>The <dfn>AsyncFunction prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncFunction.prototype%</dfn>.</li>
        <li>is an ordinary object.</li>
        <li>is not a function object and does not have an [[ECMAScriptCode]] internal slot or any other of the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      </ul>

      <emu-clause id="sec-async-function-prototype-properties-constructor">
        <h1>AsyncFunction.prototype.constructor</h1>

        <p>The initial value of `AsyncFunction.prototype.constructor` is %AsyncFunction%.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>

      <emu-clause oldids="sec-async-function-prototype-properties-toStringTag" id="sec-async-function-prototype-%symbol.tostringtag%">
        <h1>AsyncFunction.prototype [ %Symbol.toStringTag% ]</h1>

        <p>The initial value of the %Symbol.toStringTag% property is the String value *"AsyncFunction"*.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-function-instances">
      <h1>AsyncFunction Instances</h1>

      <p>Every AsyncFunction instance is an ECMAScript function object and has the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. The value of the [[IsClassConstructor]] internal slot for all such instances is *false*. AsyncFunction instances are not constructors and do not have a [[Construct]] internal method. AsyncFunction instances do not have a prototype property as they are not constructable.</p>
      <p>Each AsyncFunction instance has the following own properties:</p>

      <emu-clause id="sec-async-function-instances-length">
        <h1>length</h1>
        <p>The specification for the *"length"* property of Function instances given in <emu-xref href="#sec-function-instances-length"></emu-xref> also applies to AsyncFunction instances.</p>
      </emu-clause>

      <emu-clause id="sec-async-function-instances-name">
        <h1>name</h1>
        <p>The specification for the *"name"* property of Function instances given in <emu-xref href="#sec-function-instances-name"></emu-xref> also applies to AsyncFunction instances.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-async-functions-abstract-operations">
      <h1>Async Functions Abstract Operations</h1>

      <emu-clause id="sec-async-functions-abstract-operations-async-function-start" type="abstract operation">
        <h1>
          AsyncFunctionStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncFunctionBody_: a |FunctionBody| Parse Node, an |ExpressionBody| Parse Node, or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _runningContext_ be the running execution context.
          1. Let _asyncContext_ be a copy of _runningContext_.
          1. NOTE: Copying the execution state is required for AsyncBlockStart to resume its execution. It is ill-defined to resume a currently executing context.
          1. Perform AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncblockstart" type="abstract operation">
        <h1>
          AsyncBlockStart (
            _promiseCapability_: a PromiseCapability Record,
            _asyncBody_: a Parse Node or an Abstract Closure with no parameters,
            _asyncContext_: an execution context,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _runningContext_ be the running execution context.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:
            1. Let _acAsyncContext_ be the running execution context.
            1. If _asyncBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _asyncBody_).
            1. Else,
              1. Assert: _asyncBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_asyncBody_()).
            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.
            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. If _result_ is a normal completion, then
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).
            1. Else if _result_ is a return completion, then
              1. Perform ! <emu-meta effects="user-code">Call</emu-meta>(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).
            1. Else,
              1. Assert: _result_ is a throw completion.
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).
            1. [id="step-asyncblockstart-return-undefined"] Return NormalCompletion(~unused~).
          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.
          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href="#step-asyncblockstart-return-undefined"></emu-xref> above.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="await" oldids="await-fulfilled,await-rejected" type="abstract operation">
        <h1>
          Await (
            _value_: an ECMAScript language value,
          ): either a normal completion containing either an ECMAScript language value or ~empty~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _asyncContext_ be the running execution context.
          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).
          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:
            1. Let _prevContext_ be the running execution context.
            1. Suspend _prevContext_.
            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
            1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.
            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
            1. Return NormalCompletion(*undefined*).
          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *""*, « »).
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:
            1. Let _prevContext_ be the running execution context.
            1. Suspend _prevContext_.
            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.
            1. <emu-meta effects="user-code">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.
            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.
            1. Return NormalCompletion(*undefined*).
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, « »).
          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).
          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
          1. Let _callerContext_ be the running execution context.
          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.
          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.
          1. Return _completion_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-reflection">
  <h1>Reflection</h1>

  <emu-clause id="sec-reflect-object">
    <h1>The Reflect Object</h1>
    <p>The Reflect object:</p>
    <ul>
      <li>is <dfn>%Reflect%</dfn>.</li>
      <li>is the initial value of the *"Reflect"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>

    <emu-clause id="sec-reflect.apply">
      <h1>Reflect.apply ( _target_, _thisArgument_, _argumentsList_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.
        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).
        1. Perform PrepareForTailCall().
        1. Return ? Call(_target_, _thisArgument_, _args_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.construct">
      <h1>Reflect.construct ( _target_, _argumentsList_ [ , _newTarget_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.
        1. If _newTarget_ is not present, set _newTarget_ to _target_.
        1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.
        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).
        1. Return ? Construct(_target_, _args_, _newTarget_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.defineproperty">
      <h1>Reflect.defineProperty ( _target_, _propertyKey_, _attributes_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).
        1. Return ? <emu-meta effects="user-code">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.deleteproperty">
      <h1>Reflect.deleteProperty ( _target_, _propertyKey_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Return ? <emu-meta effects="user-code">_target_.[[Delete]]</emu-meta>(_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.get">
      <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. If _receiver_ is not present, then
          1. Set _receiver_ to _target_.
        1. Return ? <emu-meta effects="user-code">_target_.[[Get]]</emu-meta>(_key_, _receiver_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getownpropertydescriptor">
      <h1>Reflect.getOwnPropertyDescriptor ( _target_, _propertyKey_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Let _desc_ be ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_key_).
        1. Return FromPropertyDescriptor(_desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.getprototypeof">
      <h1>Reflect.getPrototypeOf ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[GetPrototypeOf]]()</emu-meta>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.has">
      <h1>Reflect.has ( _target_, _propertyKey_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. Return ? <emu-meta effects="user-code">_target_.[[HasProperty]]</emu-meta>(_key_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.isextensible">
      <h1>Reflect.isExtensible ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[IsExtensible]]()</emu-meta>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.ownkeys">
      <h1>Reflect.ownKeys ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _keys_ be ? <emu-meta effects="user-code">_target_.[[OwnPropertyKeys]]()</emu-meta>.
        1. Return CreateArrayFromList(_keys_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.preventextensions">
      <h1>Reflect.preventExtensions ( _target_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[PreventExtensions]]()</emu-meta>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.set">
      <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. Let _key_ be ? ToPropertyKey(_propertyKey_).
        1. If _receiver_ is not present, then
          1. Set _receiver_ to _target_.
        1. Return ? <emu-meta effects="user-code">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-reflect.setprototypeof">
      <h1>Reflect.setPrototypeOf ( _target_, _proto_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If _target_ is not an Object, throw a *TypeError* exception.
        1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.
        1. Return ? <emu-meta effects="user-code">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_).
      </emu-alg>
    </emu-clause>

    <emu-clause oldids="sec-reflect-@@tostringtag" id="sec-reflect-%symbol.tostringtag%">
      <h1>Reflect [ %Symbol.toStringTag% ]</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Reflect"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-proxy-objects">
    <h1>Proxy Objects</h1>

    <emu-clause id="sec-proxy-constructor">
      <h1>The Proxy Constructor</h1>
      <p>The Proxy constructor:</p>
      <ul>
        <li>is <dfn>%Proxy%</dfn>.</li>
        <li>is the initial value of the *"Proxy"* property of the global object.</li>
        <li>creates and initializes a new Proxy object when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      </ul>

      <emu-clause id="sec-proxy-target-handler">
        <h1>Proxy ( _target_, _handler_ )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Return ? ProxyCreate(_target_, _handler_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-proxy-constructor">
      <h1>Properties of the Proxy Constructor</h1>
      <p>The Proxy constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>does not have a *"prototype"* property because Proxy objects do not have a [[Prototype]] internal slot that requires initialization.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-proxy.revocable" oldids="sec-proxy-revocation-functions">
        <h1>Proxy.revocable ( _target_, _handler_ )</h1>
        <p>This function creates a revocable Proxy object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _proxy_ be ? ProxyCreate(_target_, _handler_).
          1. Let _revokerClosure_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _F_ be the active function object.
            1. Let _p_ be _F_.[[RevocableProxy]].
            1. If _p_ is *null*, return NormalCompletion(*undefined*).
            1. Set _F_.[[RevocableProxy]] to *null*.
            1. Assert: _p_ is a Proxy exotic object.
            1. Set _p_.[[ProxyTarget]] to *null*.
            1. Set _p_.[[ProxyHandler]] to *null*.
            1. Return NormalCompletion(*undefined*).
          1. Let _revoker_ be CreateBuiltinFunction(_revokerClosure_, 0, *""*, « [[RevocableProxy]] »).
          1. Set _revoker_.[[RevocableProxy]] to _proxy_.
          1. Let _result_ be OrdinaryObjectCreate(%Object.prototype%).
          1. Perform ! CreateDataPropertyOrThrow(_result_, *"proxy"*, _proxy_).
          1. Perform ! CreateDataPropertyOrThrow(_result_, *"revoke"*, _revoker_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-module-namespace-objects">
    <h1>Module Namespace Objects</h1>
    <p>A Module Namespace Object is a module namespace exotic object that provides runtime property-based access to a module's exported bindings. There is no constructor function for Module Namespace Objects. Instead, such an object is created for each module that is imported by an |ImportDeclaration| that contains a |NameSpaceImport|.</p>
    <p>In addition to the properties specified in <emu-xref href="#sec-module-namespace-exotic-objects"></emu-xref> each Module Namespace Object has the following own property:</p>

    <emu-clause oldids="sec-@@tostringtag" id="sec-%symbol.tostringtag%">
      <h1>%Symbol.toStringTag%</h1>
      <p>The initial value of the %Symbol.toStringTag% property is the String value *"Module"*.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-memory-model">
  <h1>Memory Model</h1>
  <p>The memory consistency model, or <dfn>memory model</dfn>, specifies the possible orderings of Shared Data Block events, arising via accessing TypedArray instances backed by a SharedArrayBuffer and via methods on the Atomics object. When the program has no data races (defined below), the ordering of events appears as sequentially consistent, i.e., as an interleaving of actions from each agent. When the program has data races, shared memory operations may appear sequentially inconsistent. For example, programs may exhibit causality-violating behaviour and other astonishments. These astonishments arise from compiler transforms and the design of CPUs (e.g., out-of-order execution and speculation). The memory model defines both the precise conditions under which a program exhibits sequentially consistent behaviour as well as the possible values read from data races. To wit, there is no undefined behaviour.</p>
  <p>The memory model is defined as relational constraints on events introduced by abstract operations on SharedArrayBuffer or by methods on the Atomics object during an evaluation.</p>
  <emu-note>
    <p>This section provides an axiomatic model on events introduced by the abstract operations on SharedArrayBuffers. It bears stressing that the model is not expressible algorithmically, unlike the rest of this specification. The nondeterministic introduction of events by abstract operations is the interface between the operational semantics of ECMAScript evaluation and the axiomatic semantics of the memory model. The semantics of these events is defined by considering graphs of all events in an evaluation. These are neither Static Semantics nor Runtime Semantics. There is no demonstrated algorithmic implementation, but instead a set of constraints that determine if a particular event graph is allowed or disallowed.</p>
  </emu-note>

  <emu-clause id="sec-memory-model-fundamentals">
    <h1>Memory Model Fundamentals</h1>
    <p>Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a strict total ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a strict total ordering agreed upon by all agents, i.e., unordered.</p>
    <emu-note>
      <p>No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.</p>
    </emu-note>
    <p>A <dfn variants="Shared Data Block events">Shared Data Block event</dfn> is either a <dfn>ReadSharedMemory</dfn>, <dfn>WriteSharedMemory</dfn>, or <dfn>ReadModifyWriteSharedMemory</dfn> Record.</p>

    <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory Event Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~ or ~unordered~</td>
          <td>The weakest ordering guaranteed by the memory model for the event.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>a Boolean</td>
          <td>Whether this event is allowed to read from multiple write events with equal range as this event.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>a Shared Data Block</td>
          <td>The block the event operates on.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>a non-negative integer</td>
          <td>The byte address of the read in [[Block]].</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>a non-negative integer</td>
          <td>The size of the read.</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory Event Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~, ~unordered~, or ~init~</td>
          <td>The weakest ordering guaranteed by the memory model for the event.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>a Boolean</td>
          <td>Whether this event is allowed to be read from multiple read events with equal range as this event.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>a Shared Data Block</td>
          <td>The block the event operates on.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>a non-negative integer</td>
          <td>The byte address of the write in [[Block]].</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>a non-negative integer</td>
          <td>The size of the write.</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>a List of byte values</td>
          <td>The List of byte values to be read by other events.</td>
        </tr>
      </table>
    </emu-table>

    <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory Event Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Order]]</td>
          <td>~seq-cst~</td>
          <td>Read-modify-write events are always sequentially consistent.</td>
        </tr>
        <tr>
          <td>[[NoTear]]</td>
          <td>*true*</td>
          <td>Read-modify-write events cannot tear.</td>
        </tr>
        <tr>
          <td>[[Block]]</td>
          <td>a Shared Data Block</td>
          <td>The block the event operates on.</td>
        </tr>
        <tr>
          <td>[[ByteIndex]]</td>
          <td>a non-negative integer</td>
          <td>The byte address of the read-modify-write in [[Block]].</td>
        </tr>
        <tr>
          <td>[[ElementSize]]</td>
          <td>a non-negative integer</td>
          <td>The size of the read-modify-write.</td>
        </tr>
        <tr>
          <td>[[Payload]]</td>
          <td>a List of byte values</td>
          <td>The List of byte values to be passed to [[ModifyOp]].</td>
        </tr>
        <tr>
          <td>[[ModifyOp]]</td>
          <td>a read-modify-write modification function</td>
          <td>An abstract closure that returns a modified List of byte values from a read List of byte values and [[Payload]].</td>
        </tr>
      </table>
    </emu-table>

    <p>These events are introduced by abstract operations or by methods on the Atomics object.</p>
    <p>Some operations may also introduce <dfn>Synchronize</dfn> events. A <dfn variants="Synchronize events">Synchronize event</dfn> has no fields, and exists purely to directly constrain the permitted orderings of other events.</p>
    <p>In addition to Shared Data Block and Synchronize events, there are host-specific events.</p>
    <p>Let the range of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event be the Set of contiguous integers from its [[ByteIndex]] to [[ByteIndex]] + [[ElementSize]] - 1. Two events' ranges are equal when the events have the same [[Block]], and the ranges are element-wise equal. Two events' ranges are overlapping when the events have the same [[Block]], the ranges are not equal and their intersection is non-empty. Two events' ranges are disjoint when the events do not have the same [[Block]] or their ranges are neither equal nor overlapping.</p>
    <emu-note>
      <p>Examples of host-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one agent to another (e.g., by `postMessage` in a browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory. For a particular execution _execution_, those events are provided by the host via the host-synchronizes-with strict partial order. Additionally, hosts can add host-specific synchronizing events to _execution_.[[EventList]] so as to participate in the is-agent-order-before Relation.</p>
    </emu-note>
    <p>Events are ordered within candidate executions by the relations defined below.</p>
  </emu-clause>

  <emu-clause id="sec-agent-event-records">
    <h1>Agent Events Records</h1>
    <p>An <dfn variants="Agent Events Records">Agent Events Record</dfn> is a Record with the following fields.</p>
    <emu-table id="table-agent-events-records" caption="Agent Events Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[AgentSignifier]]</td>
          <td>an agent signifier</td>
          <td>The agent whose evaluation resulted in this ordering.</td>
        </tr>
        <tr>
          <td>[[EventList]]</td>
          <td>a List of events</td>
          <td>Events are appended to the list during evaluation.</td>
        </tr>
        <tr>
          <td>[[AgentSynchronizesWith]]</td>
          <td>a List of pairs of Synchronize events</td>
          <td>Synchronize relationships introduced by the operational semantics.</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-chosen-value-records">
    <h1>Chosen Value Records</h1>
    <p>A <dfn variants="Chosen Value Records">Chosen Value Record</dfn> is a Record with the following fields.</p>
    <emu-table id="table-chosen-value-records" caption="Chosen Value Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[Event]]</td>
          <td>a Shared Data Block event</td>
          <td>The ReadSharedMemory or ReadModifyWriteSharedMemory event that was introduced for this chosen value.</td>
        </tr>
        <tr>
          <td>[[ChosenValue]]</td>
          <td>a List of byte values</td>
          <td>The bytes that were nondeterministically chosen during evaluation.</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-candidate-executions">
    <h1>Candidate Executions</h1>
    <p>A <dfn variants="candidate executions">candidate execution</dfn> of the evaluation of an agent cluster is a Record with the following fields.</p>
    <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tr>
          <td>[[EventsRecords]]</td>
          <td>a List of Agent Events Records</td>
          <td>Maps an agent to Lists of events appended during the evaluation.</td>
        </tr>
        <tr>
          <td>[[ChosenValues]]</td>
          <td>a List of Chosen Value Records</td>
          <td>Maps ReadSharedMemory or ReadModifyWriteSharedMemory events to the List of byte values chosen during the evaluation.</td>
        </tr>
      </table>
    </emu-table>

    <p>An <dfn variants="empty candidate executions">empty candidate execution</dfn> is a candidate execution Record whose fields are empty Lists.</p>
  </emu-clause>

  <emu-clause id="sec-abstract-operations-for-the-memory-model" oldids="sec-synchronizeeventset">
    <h1>Abstract Operations for the Memory Model</h1>

    <emu-clause id="sec-event-set" type="abstract operation">
      <h1>
        EventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each Agent Events Record _aer_ of _execution_.[[EventsRecords]], do
          1. For each event _E_ of _aer_.[[EventList]], do
            1. Add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedatablockeventset" type="abstract operation">
      <h1>
        SharedDataBlockEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ of EventSet(_execution_), do
          1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-hosteventset" type="abstract operation">
      <h1>
        HostEventSet (
          _execution_: a candidate execution,
        ): a Set of events
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _events_ be an empty Set.
        1. For each event _E_ of EventSet(_execution_), do
          1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.
        1. Return _events_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-composewriteeventbytes" type="abstract operation">
      <h1>
        ComposeWriteEventBytes (
          _execution_: a candidate execution,
          _byteIndex_: a non-negative integer,
          _Ws_: a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _byteLocation_ be _byteIndex_.
        1. Let _bytesRead_ be a new empty List.
        1. For each element _W_ of _Ws_, do
          1. Assert: _W_ has _byteLocation_ in its range.
          1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].
          1. If _W_ is a WriteSharedMemory event, then
            1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].
          1. Else,
            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.
            1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).
            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).
            1. Let _byte_ be _bytesModified_[_payloadIndex_].
          1. Append _byte_ to _bytesRead_.
          1. Set _byteLocation_ to _byteLocation_ + 1.
        1. Return _bytesRead_.
      </emu-alg>
      <emu-note>
        <p>The read-modify-write modification [[ModifyOp]] is given by the function properties on the Atomics object that introduce ReadModifyWriteSharedMemory events.</p>
      </emu-note>
      <emu-note>
        <p>This abstract operation composes a List of write events into a List of byte values. It is used in the event semantics of ReadSharedMemory and ReadModifyWriteSharedMemory events.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valueofreadevent" type="abstract operation">
      <h1>
        ValueOfReadEvent (
          _execution_: a candidate execution,
          _R_: a ReadSharedMemory or ReadModifyWriteSharedMemory event,
        ): a List of byte values
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _Ws_ be reads-bytes-from(_R_) in _execution_.
        1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].
        1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-relations-of-candidate-executions">
    <h1>Relations of Candidate Executions</h1>

    <p>The following relations and mathematical functions are parameterized over a particular candidate execution and order its events.</p>

    <emu-clause id="sec-agent-order">
      <h1>is-agent-order-before</h1>
      <p>For a candidate execution _execution_, its <dfn>is-agent-order-before</dfn> Relation is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>For events _E_ and _D_, _E_ is-agent-order-before _D_ in _execution_ if there is some Agent Events Record _aer_ in _execution_.[[EventsRecords]] such that _aer_.[[EventList]] contains both _E_ and _D_ and _E_ is before _D_ in List order of _aer_.[[EventList]].</li>
      </ul>

      <emu-note>
        <p>Each agent introduces events in a per-agent strict total order during the evaluation. This is the union of those strict total orders.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-reads-bytes-from" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>For a candidate execution _execution_, its <em>reads-bytes-from</em> function is a mathematical function mapping events in SharedDataBlockEventSet(_execution_) to Lists of events in SharedDataBlockEventSet(_execution_) that satisfies the following conditions.</p>
      <ul>
        <li>
          <p>For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in SharedDataBlockEventSet(_execution_), reads-bytes-from(_R_) in _execution_ is a List of length _R_.[[ElementSize]] whose elements are WriteSharedMemory or ReadModifyWriteSharedMemory events _Ws_ such that all of the following are true.</p>
          <ul>
            <li>Each event _W_ with index _i_ in _Ws_ has _R_.[[ByteIndex]] + _i_ in its range.</li>
            <li>_R_ is not in _Ws_.</li>
          </ul>
        </li>
      </ul>
      <p>A candidate execution always admits a reads-bytes-from function.</p>
    </emu-clause>

    <emu-clause id="sec-reads-from">
      <h1>reads-from</h1>
      <p>For a candidate execution _execution_, its <dfn>reads-from</dfn> Relation is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>For events _R_ and _W_, _R_ reads-from _W_ in _execution_ if SharedDataBlockEventSet(_execution_) contains both _R_ and _W_, and reads-bytes-from(_R_) in _execution_ contains _W_.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>For a candidate execution _execution_, its <dfn>host-synchronizes-with</dfn> Relation is a host-provided strict partial order on host-specific events that satisfies at least the following.</p>
      <ul>
        <li>If _E_ host-synchronizes-with _D_ in _execution_, HostEventSet(_execution_) contains _E_ and _D_.</li>
        <li>There is no cycle in the union of host-synchronizes-with and is-agent-order-before in _execution_.</li>
      </ul>

      <emu-note>
        <p>For two host-specific events _E_ and _D_ in a candidate execution _execution_, _E_ host-synchronizes-with _D_ in _execution_ implies _E_ happens-before _D_ in _execution_.</p>
      </emu-note>
      <emu-note>
        <p>This Relation allows the host to provide additional synchronization mechanisms, such as `postMessage` between HTML workers.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>For a candidate execution _execution_, its <dfn>synchronizes-with</dfn> Relation is the least Relation on events that satisfies the following.</p>
      <ul>
        <li>
          For events _R_ and _W_, _W_ synchronizes-with _R_ in _execution_ if _R_ reads-from _W_ in _execution_, _R_.[[Order]] is ~seq-cst~, _W_.[[Order]] is ~seq-cst~, and _R_ and _W_ have equal ranges.
        </li>
        <li>
          For each element _eventsRecord_ of _execution_.[[EventsRecords]], the following is true.
          <ul>
            <li>For events _S_ and _Sw_, _S_ synchronizes-with _Sw_ in _execution_ if _eventsRecord_.[[AgentSynchronizesWith]] contains (_S_, _Sw_).</li>
          </ul>
        </li>
        <li>For events _E_ and _D_, _E_ synchronizes-with _D_ in _execution_ if _execution_.[[HostSynchronizesWith]] contains (_E_, _D_).</li>
      </ul>

      <emu-note>
        <p>Owing to convention in memory model literature, in a candidate execution _execution_, write events synchronizes-with read events, instead of read events synchronizes-with write events.</p>
      </emu-note>

      <emu-note>
        <p>In a candidate execution _execution_, ~init~ events do not participate in this Relation and are instead constrained directly by happens-before.</p>
      </emu-note>

      <emu-note>
        <p>In a candidate execution _execution_, not all ~seq-cst~ events related by reads-from are related by synchronizes-with. Only events that also have equal ranges are related by synchronizes-with.</p>
      </emu-note>

      <emu-note>
        <p>For Shared Data Block events _R_ and _W_ in a candidate execution _execution_ such that _W_ synchronizes-with _R_, _R_ may reads-from other writes than _W_.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-happens-before">
      <h1>happens-before</h1>
      <p>For a candidate execution _execution_, its <dfn>happens-before</dfn> Relation is the least Relation on events that satisfies the following.</p>

      <ul>
        <li>
          <p>For events _E_ and _D_, _E_ happens-before _D_ in _execution_ if any of the following conditions are true.</p>
          <ul>
            <li>_E_ is-agent-order-before _D_ in _execution_.</li>
            <li>_E_ synchronizes-with _D_ in _execution_.</li>
            <li>SharedDataBlockEventSet(_execution_) contains both _E_ and _D_, _E_.[[Order]] is ~init~, and _E_ and _D_ have overlapping ranges.</li>
            <li>There is an event _F_ such that _E_ happens-before _F_ and _F_ happens-before _D_ in _execution_.</li>
          </ul>
        </li>
      </ul>

      <emu-note>
        <p>Because happens-before is a superset of agent-order, a candidate execution is consistent with the single-thread evaluation semantics of ECMAScript.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-valid-executions">
    <h1>Properties of Valid Executions</h1>

    <emu-clause id="sec-valid-chosen-reads">
      <h1>Valid Chosen Reads</h1>
      <p>A candidate execution _execution_ has valid chosen reads if the following algorithm returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do
          1. Let _chosenValueRecord_ be the element of _execution_.[[ChosenValues]] whose [[Event]] field is _R_.
          1. Let _chosenValue_ be _chosenValueRecord_.[[ChosenValue]].
          1. Let _readValue_ be ValueOfReadEvent(_execution_, _R_).
          1. Let _chosenLen_ be the number of elements in _chosenValue_.
          1. Let _readLen_ be the number of elements in _readValue_.
          1. If _chosenLen_ ≠ _readLen_, then
            1. Return *false*.
          1. If _chosenValue_[_i_] ≠ _readValue_[_i_] for some integer _i_ in the interval from 0 (inclusive) to _chosenLen_ (exclusive), then
            1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-coherent-reads">
      <h1>Coherent Reads</h1>
      <p>A candidate execution _execution_ has coherent reads if the following algorithm returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do
          1. Let _Ws_ be reads-bytes-from(_R_) in _execution_.
          1. Let _byteLocation_ be _R_.[[ByteIndex]].
          1. For each element _W_ of _Ws_, do
            1. If _R_ happens-before _W_ in _execution_, then
              1. Return *false*.
            1. If there exists a WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ that has _byteLocation_ in its range such that _W_ happens-before _V_ in _execution_ and _V_ happens-before _R_ in _execution_, then
              1. Return *false*.
            1. Set _byteLocation_ to _byteLocation_ + 1.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-tear-free-aligned-reads">
      <h1>Tear Free Reads</h1>
      <p>A candidate execution _execution_ has tear free reads if the following algorithm returns *true*.</p>
      <emu-alg>
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ of SharedDataBlockEventSet(_execution_), do
          1. If _R_.[[NoTear]] is *true*, then
            1. Assert: The remainder of dividing _R_.[[ByteIndex]] by _R_.[[ElementSize]] is 0.
            1. For each event _W_ such that _R_ reads-from _W_ in _execution_ and _W_.[[NoTear]] is *true*, do
              1. If _R_ and _W_ have equal ranges and there exists an event _V_ such that _V_ and _W_ have equal ranges, _V_.[[NoTear]] is *true*, _W_ and _V_ are not the same Shared Data Block event, and _R_ reads-from _V_ in _execution_, then
                1. Return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-note>
        <p>An event's [[NoTear]] field is *true* when that event was introduced via accessing an integer TypedArray, and *false* when introduced via accessing a floating point TypedArray or DataView.</p>
        <p>Intuitively, this requirement says when a memory range is accessed in an aligned fashion via an integer TypedArray, a single write event on that range must "win" when in a data race with other write events with equal ranges. More precisely, this requirement says an aligned read event cannot read a value composed of bytes from multiple, different write events all with equal ranges. It is possible, however, for an aligned read event to read from multiple write events with overlapping ranges.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-memory-order">
      <h1>Sequentially Consistent Atomics</h1>
      <p>For a candidate execution _execution_, <dfn>is-memory-order-before</dfn> is a strict total order of all events in EventSet(_execution_) that satisfies the following.</p>
      <ul>
        <li>For events _E_ and _D_, _E_ is-memory-order-before _D_ in _execution_ if _E_ happens-before _D_ in _execution_.</li>
        <li>
          <p>For events _R_ and _W_ such that _R_ reads-from _W_ in _execution_, there is no WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ in SharedDataBlockEventSet(_execution_) such that _V_.[[Order]] is ~seq-cst~, _W_ is-memory-order-before _V_ in _execution_, _V_ is-memory-order-before _R_ in _execution_, and any of the following conditions are true.</p>
          <ul>
            <li>_W_ synchronizes-with _R_ in _execution_, and _V_ and _R_ have equal ranges.</li>
            <li>_W_ happens-before _R_ and _V_ happens-before _R_ in _execution_, _W_.[[Order]] is ~seq-cst~, and _W_ and _V_ have equal ranges.</li>
            <li>_W_ happens-before _R_ and _W_ happens-before _V_ in _execution_, _R_.[[Order]] is ~seq-cst~, and _V_ and _R_ have equal ranges.</li>
          </ul>
          <emu-note>
            <p>This clause additionally constrains ~seq-cst~ events on equal ranges.</p>
          </emu-note>
        </li>
        <li>
          <p>For each WriteSharedMemory or ReadModifyWriteSharedMemory event _W_ in SharedDataBlockEventSet(_execution_), if _W_.[[Order]] is ~seq-cst~, then it is not the case that there is an infinite number of ReadSharedMemory or ReadModifyWriteSharedMemory events in SharedDataBlockEventSet(_execution_) with equal range that is memory-order before _W_.</p>
          <emu-note>
            <p>This clause together with the forward progress guarantee on agents ensure the liveness condition that ~seq-cst~ writes become visible to ~seq-cst~ reads with equal range in finite time.</p>
          </emu-note>
        </li>
      </ul>
      <p>A candidate execution has sequentially consistent atomics if it admits an is-memory-order-before Relation.</p>

      <emu-note>
        <p>While is-memory-order-before includes all events in EventSet(_execution_), those that are not constrained by happens-before or synchronizes-with in _execution_ are allowed to occur anywhere in the order.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-valid-executions">
      <h1>Valid Executions</h1>
      <p>A candidate execution _execution_ is a valid execution (or simply an execution) if all of the following are true.</p>
      <ul>
        <li>The host provides a host-synchronizes-with Relation for _execution_.</li>
        <li>_execution_ admits a happens-before Relation that is a strict partial order.</li>
        <li>_execution_ has valid chosen reads.</li>
        <li>_execution_ has coherent reads.</li>
        <li>_execution_ has tear free reads.</li>
        <li>_execution_ has sequentially consistent atomics.</li>
      </ul>
      <p>All programs have at least one valid execution.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-races">
    <h1>Races</h1>
    <p>For an execution _execution_ and events _E_ and _D_ that are contained in SharedDataBlockEventSet(_execution_), _E_ and _D_ are in a <em>race</em> if the following algorithm returns *true*.</p>
    <emu-alg>
      1. If _E_ and _D_ are not the same Shared Data Block event, then
        1. If it is not the case that both _E_ happens-before _D_ in _execution_ and _D_ happens-before _E_ in _execution_, then
          1. If _E_ and _D_ are both WriteSharedMemory or ReadModifyWriteSharedMemory events and _E_ and _D_ do not have disjoint ranges, then
            1. Return *true*.
          1. If _E_ reads-from _D_ in _execution_ or _D_ reads-from _E_ in _execution_, then
            1. Return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-races">
    <h1>Data Races</h1>
    <p>For an execution _execution_ and events _E_ and _D_ that are contained in SharedDataBlockEventSet(_execution_), _E_ and _D_ are in a <dfn>data race</dfn> if the following algorithm returns *true*.</p>
    <emu-alg>
      1. If _E_ and _D_ are in a <emu-xref href="#sec-races">race</emu-xref> in _execution_, then
        1. If _E_.[[Order]] is not ~seq-cst~ or _D_.[[Order]] is not ~seq-cst~, then
          1. Return *true*.
        1. If _E_ and _D_ have overlapping ranges, then
          1. Return *true*.
      1. Return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-data-race-freedom">
    <h1>Data Race Freedom</h1>
    <p>An execution _execution_ is <dfn>data race free</dfn> if there are no two events in SharedDataBlockEventSet(_execution_) that are in a data race.</p>
    <p>A program is data race free if all its executions are data race free.</p>
    <p>The memory model guarantees sequential consistency of all events for data race free programs.</p>
  </emu-clause>

  <emu-clause id="sec-shared-memory-guidelines">
    <h1>Shared Memory Guidelines</h1>
    <emu-note>
      <p>The following are guidelines for ECMAScript programmers working with shared memory.</p>
      <p>We recommend programs be kept data race free, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data race free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript.</p>
      <p>More generally, even if a program is not data race free it may have predictable behaviour, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not "tear" (bits of their values will not be mixed).</p>
    </emu-note>

    <emu-note>
      <p>The following are guidelines for ECMAScript implementers writing compiler transformations for programs using shared memory.</p>
      <p>It is desirable to allow most program transformations that are valid in a single-agent setting in a multi-agent setting, to ensure that the performance of each agent in a multi-agent program is as good as it would be in a single-agent setting. Frequently these transformations are hard to judge. We outline some rules about program transformations that are intended to be taken as normative (in that they are implied by the memory model or stronger than what the memory model implies) but which are likely not exhaustive. These rules are intended to apply to program transformations that precede the introductions of the events that make up the is-agent-order-before Relation.</p>
      <p>Let an <dfn variants="agent-order slices">agent-order slice</dfn> be the subset of the is-agent-order-before Relation pertaining to a single agent.</p>
      <p>Let <dfn>possible read values</dfn> of a read event be the set of all values of ValueOfReadEvent for that event across all valid executions.</p>
      <p>Any transformation of an agent-order slice that is valid in the absence of shared memory is valid in the presence of shared memory, with the following exceptions.</p>
      <ul>
        <li>
          <p><em>Atomics are carved in stone</em>: Program transformations must not cause the ~seq-cst~ events in an agent-order slice to be reordered with its ~unordered~ operations, nor its ~seq-cst~ operations to be reordered with each other, nor may a program transformation remove a ~seq-cst~ operation from the is-agent-order-before Relation.</p>
          <p>(In practice, the prohibition on reorderings forces a compiler to assume that every ~seq-cst~ operation is a synchronization and included in the final is-memory-order-before Relation, which it would usually have to assume anyway in the absence of inter-agent program analysis. It also forces the compiler to assume that every call where the callee's effects on the memory-order are unknown may contain ~seq-cst~ operations.)</p>
        </li>
        <li>
          <p><em>Reads must be stable</em>: Any given shared memory read must only observe a single value in an execution.</p>
          <p>(For example, if what is semantically a single read in the program is executed multiple times then the program is subsequently allowed to observe only one of the values read. A transformation known as rematerialization can violate this rule.)</p>
        </li>
        <li>
          <p><em>Writes must be stable</em>: All observable writes to shared memory must follow from program semantics in an execution.</p>
          <p>(For example, a transformation may not introduce certain observable writes, such as by using read-modify-write operations on a larger location to write a smaller datum, writing a value to memory that the program could not have written, or writing a just-read value back to the location it was read from, if that location could have been overwritten by another agent after the read.)</p>
        </li>
        <li>
          <p><em>Possible read values must be non-empty</em>: Program transformations cannot cause the possible read values of a shared memory read to become empty.</p>
          <p>(Counterintuitively, this rule in effect restricts transformations on writes, because writes have force in memory model insofar as to be read by read events. For example, writes may be moved and coalesced and sometimes reordered between two ~seq-cst~ operations, but the transformation may not remove every write that updates a location; some write must be preserved.)</p>
        </li>
      </ul>
      <p>Examples of transformations that remain valid are: merging multiple non-atomic reads from the same location, reordering non-atomic reads, introducing speculative non-atomic reads, merging multiple non-atomic writes to the same location, reordering non-atomic writes to different locations, and hoisting non-atomic reads out of loops even if that affects termination. Note in general that aliased TypedArrays make it hard to prove that locations are different.</p>
    </emu-note>

    <emu-note>
      <p>The following are guidelines for ECMAScript implementers generating machine code for shared memory accesses.</p>
      <p>For architectures with memory models no weaker than those of ARM or Power, non-atomic stores and loads may be compiled to bare stores and loads on the target architecture. Atomic stores and loads may be compiled down to instructions that guarantee sequential consistency. If no such instructions exist, memory barriers are to be employed, such as placing barriers on both sides of a bare store or load. Read-modify-write operations may be compiled to read-modify-write instructions on the target architecture, such as <code>LOCK</code>-prefixed instructions on x86, load-exclusive/store-exclusive instructions on ARM, and load-link/store-conditional instructions on Power.</p>
      <p>Specifically, the memory model is intended to allow code generation as follows.</p>
      <ul>
        <li>Every atomic operation in the program is assumed to be necessary.</li>
        <li>Atomic operations are never rearranged with each other or with non-atomic operations.</li>
        <li>Functions are always assumed to perform atomic operations.</li>
        <li>Atomic operations are never implemented as read-modify-write operations on larger data, but as non-lock-free atomics if the platform does not have atomic operations of the appropriate size. (We already assume that every platform has normal memory access operations of every interesting size.)</li>
      </ul>
      <p>Naive code generation uses these patterns:</p>
      <ul>
        <li>Regular loads and stores compile to single load and store instructions.</li>
        <li>Lock-free atomic loads and stores compile to a full (sequentially consistent) fence, a regular load or store, and a full fence.</li>
        <li>Lock-free atomic read-modify-write accesses compile to a full fence, an atomic read-modify-write instruction sequence, and a full fence.</li>
        <li>Non-lock-free atomics compile to a spinlock acquire, a full fence, a series of non-atomic load and store instructions, a full fence, and a spinlock release.</li>
      </ul>
      <p>That mapping is correct so long as an atomic operation on an address range does not race with a non-atomic write or with an atomic operation of different size. However, that is all we need: the memory model effectively demotes the atomic operations involved in a race to non-atomic status. On the other hand, the naive mapping is quite strong: it allows atomic operations to be used as sequentially consistent fences, which the memory model does not actually guarantee.</p>
      <p>Local improvements to those basic patterns are also allowed, subject to the constraints of the memory model. For example:</p>
      <ul>
        <li>There are obvious platform-dependent improvements that remove redundant fences. For example, on x86 the fences around lock-free atomic loads and stores can always be omitted except for the fence following a store, and no fence is needed for lock-free read-modify-write instructions, as these all use <code>LOCK</code>-prefixed instructions. On many platforms there are fences of several strengths, and weaker fences can be used in certain contexts without destroying sequential consistency.</li>
        <li>Most modern platforms support lock-free atomics for all the data sizes required by ECMAScript atomics. Should non-lock-free atomics be needed, the fences surrounding the body of the atomic operation can usually be folded into the lock and unlock steps. The simplest solution for non-lock-free atomics is to have a single lock word per SharedArrayBuffer.</li>
        <li>There are also more complicated platform-dependent local improvements, requiring some code analysis. For example, two back-to-back fences often have the same effect as a single fence, so if code is generated for two atomic operations in sequence, only a single fence need separate them. On x86, even a single fence separating atomic stores can be omitted, as the fence following a store is only needed to separate the store from a subsequent load.</li>
      </ul>
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-grammar-summary">
  <h1>Grammar Summary</h1>

  <emu-annex id="sec-lexical-grammar">
    <h1>Lexical Grammar</h1>
    <emu-prodref name="SourceCharacter"></emu-prodref>
    <emu-prodref name="InputElementDiv"></emu-prodref>
    <emu-prodref name="InputElementRegExp"></emu-prodref>
    <emu-prodref name="InputElementRegExpOrTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementTemplateTail"></emu-prodref>
    <emu-prodref name="InputElementHashbangOrRegExp"></emu-prodref>
    <emu-prodref name="WhiteSpace"></emu-prodref>
    <emu-prodref name="LineTerminator"></emu-prodref>
    <emu-prodref name="LineTerminatorSequence"></emu-prodref>
    <emu-prodref name="Comment"></emu-prodref>
    <emu-prodref name="MultiLineComment"></emu-prodref>
    <emu-prodref name="MultiLineCommentChars"></emu-prodref>
    <emu-prodref name="PostAsteriskCommentChars"></emu-prodref>
    <emu-prodref name="MultiLineNotAsteriskChar"></emu-prodref>
    <emu-prodref name="MultiLineNotForwardSlashOrAsteriskChar"></emu-prodref>
    <emu-prodref name="SingleLineComment"></emu-prodref>
    <emu-prodref name="SingleLineCommentChars"></emu-prodref>
    <emu-prodref name="SingleLineCommentChar"></emu-prodref>
    <emu-prodref name="HashbangComment"></emu-prodref>
    <emu-prodref name="CommonToken"></emu-prodref>
    <emu-prodref name="PrivateIdentifier"></emu-prodref>
    <emu-prodref name="IdentifierName"></emu-prodref>
    <emu-prodref name="IdentifierStart"></emu-prodref>
    <emu-prodref name="IdentifierPart"></emu-prodref>
    <emu-prodref name="IdentifierStartChar"></emu-prodref>
    <emu-prodref name="IdentifierPartChar"></emu-prodref>
    <emu-prodref name="AsciiLetter"></emu-prodref>
    <emu-prodref name="UnicodeIDStart"></emu-prodref>
    <emu-prodref name="UnicodeIDContinue"></emu-prodref>
    <emu-prodref name="ReservedWord"></emu-prodref>
    <emu-prodref name="Punctuator"></emu-prodref>
    <emu-prodref name="OptionalChainingPunctuator"></emu-prodref>
    <emu-prodref name="OtherPunctuator"></emu-prodref>
    <emu-prodref name="DivPunctuator"></emu-prodref>
    <emu-prodref name="RightBracePunctuator"></emu-prodref>
    <emu-prodref name="NullLiteral"></emu-prodref>
    <emu-prodref name="BooleanLiteral"></emu-prodref>
    <emu-prodref name="NumericLiteralSeparator"></emu-prodref>
    <emu-prodref name="NumericLiteral"></emu-prodref>
    <emu-prodref name="DecimalBigIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="BigIntLiteralSuffix"></emu-prodref>
    <emu-prodref name="DecimalLiteral"></emu-prodref>
    <emu-prodref name="DecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="DecimalDigits"></emu-prodref>
    <emu-prodref name="DecimalDigit"></emu-prodref>
    <emu-prodref name="NonZeroDigit"></emu-prodref>
    <emu-prodref name="ExponentPart"></emu-prodref>
    <emu-prodref name="ExponentIndicator"></emu-prodref>
    <emu-prodref name="SignedInteger"></emu-prodref>
    <emu-prodref name="BinaryIntegerLiteral"></emu-prodref>
    <emu-prodref name="BinaryDigits"></emu-prodref>
    <emu-prodref name="BinaryDigit"></emu-prodref>
    <emu-prodref name="OctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigits"></emu-prodref>
    <emu-prodref name="LegacyOctalIntegerLiteral"></emu-prodref>
    <emu-prodref name="NonOctalDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="LegacyOctalLikeDecimalIntegerLiteral"></emu-prodref>
    <emu-prodref name="OctalDigit"></emu-prodref>
    <emu-prodref name="NonOctalDigit"></emu-prodref>
    <emu-prodref name="HexIntegerLiteral"></emu-prodref>
    <emu-prodref name="HexDigits"></emu-prodref>
    <emu-prodref name="HexDigit"></emu-prodref>
    <emu-prodref name="StringLiteral"></emu-prodref>
    <emu-prodref name="DoubleStringCharacters"></emu-prodref>
    <emu-prodref name="SingleStringCharacters"></emu-prodref>
    <emu-prodref name="DoubleStringCharacter"></emu-prodref>
    <emu-prodref name="SingleStringCharacter"></emu-prodref>
    <emu-prodref name="LineContinuation"></emu-prodref>
    <emu-prodref name="EscapeSequence"></emu-prodref>
    <emu-prodref name="CharacterEscapeSequence"></emu-prodref>
    <emu-prodref name="SingleEscapeCharacter"></emu-prodref>
    <emu-prodref name="NonEscapeCharacter"></emu-prodref>
    <emu-prodref name="EscapeCharacter"></emu-prodref>
    <emu-prodref name="LegacyOctalEscapeSequence"></emu-prodref>
    <emu-prodref name="NonZeroOctalDigit"></emu-prodref>
    <emu-prodref name="ZeroToThree"></emu-prodref>
    <emu-prodref name="FourToSeven"></emu-prodref>
    <emu-prodref name="NonOctalDecimalEscapeSequence"></emu-prodref>
    <emu-prodref name="HexEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="Hex4Digits"></emu-prodref>
    <emu-prodref name="RegularExpressionLiteral"></emu-prodref>
    <emu-prodref name="RegularExpressionBody"></emu-prodref>
    <emu-prodref name="RegularExpressionChars"></emu-prodref>
    <emu-prodref name="RegularExpressionFirstChar"></emu-prodref>
    <emu-prodref name="RegularExpressionChar"></emu-prodref>
    <emu-prodref name="RegularExpressionBackslashSequence"></emu-prodref>
    <emu-prodref name="RegularExpressionNonTerminator"></emu-prodref>
    <emu-prodref name="RegularExpressionClass"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChars"></emu-prodref>
    <emu-prodref name="RegularExpressionClassChar"></emu-prodref>
    <emu-prodref name="RegularExpressionFlags"></emu-prodref>
    <emu-prodref name="Template"></emu-prodref>
    <emu-prodref name="NoSubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateHead"></emu-prodref>
    <emu-prodref name="TemplateSubstitutionTail"></emu-prodref>
    <emu-prodref name="TemplateMiddle"></emu-prodref>
    <emu-prodref name="TemplateTail"></emu-prodref>
    <emu-prodref name="TemplateCharacters"></emu-prodref>
    <emu-prodref name="TemplateCharacter"></emu-prodref>
    <emu-prodref name="TemplateEscapeSequence"></emu-prodref>
    <emu-prodref name="NotEscapeSequence"></emu-prodref>
    <emu-prodref name="NotCodePoint"></emu-prodref>
    <emu-prodref name="CodePoint"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-expressions">
    <h1>Expressions</h1>
    <emu-prodref name="IdentifierReference"></emu-prodref>
    <emu-prodref name="BindingIdentifier"></emu-prodref>
    <emu-prodref name="LabelIdentifier"></emu-prodref>
    <emu-prodref name="Identifier"></emu-prodref>
    <emu-prodref name="PrimaryExpression"></emu-prodref>
    <emu-prodref name="CoverParenthesizedExpressionAndArrowParameterList"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="PrimaryExpression" a="parencover"></emu-prodref><br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:
    </p>
    <emu-prodref name="ParenthesizedExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Literal"></emu-prodref>
    <emu-prodref name="ArrayLiteral"></emu-prodref>
    <emu-prodref name="ElementList"></emu-prodref>
    <emu-prodref name="Elision"></emu-prodref>
    <emu-prodref name="SpreadElement"></emu-prodref>
    <emu-prodref name="ObjectLiteral"></emu-prodref>
    <emu-prodref name="PropertyDefinitionList"></emu-prodref>
    <emu-prodref name="PropertyDefinition"></emu-prodref>
    <emu-prodref name="PropertyName"></emu-prodref>
    <emu-prodref name="LiteralPropertyName"></emu-prodref>
    <emu-prodref name="ComputedPropertyName"></emu-prodref>
    <emu-prodref name="CoverInitializedName"></emu-prodref>
    <emu-prodref name="Initializer"></emu-prodref>
    <emu-prodref name="TemplateLiteral"></emu-prodref>
    <emu-prodref name="SubstitutionTemplate"></emu-prodref>
    <emu-prodref name="TemplateSpans"></emu-prodref>
    <emu-prodref name="TemplateMiddleList"></emu-prodref>
    <emu-prodref name="MemberExpression"></emu-prodref>
    <emu-prodref name="SuperProperty"></emu-prodref>
    <emu-prodref name="MetaProperty"></emu-prodref>
    <emu-prodref name="NewTarget"></emu-prodref>
    <emu-prodref name="ImportMeta"></emu-prodref>
    <emu-prodref name="NewExpression"></emu-prodref>
    <emu-prodref name="CallExpression"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="CallExpression" a="callcover"></emu-prodref><br>
      the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:
    </p>
    <emu-prodref name="CallMemberExpression"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="SuperCall"></emu-prodref>
    <emu-prodref name="ImportCall"></emu-prodref>
    <emu-prodref name="Arguments"></emu-prodref>
    <emu-prodref name="ArgumentList"></emu-prodref>
    <emu-prodref name="OptionalExpression"></emu-prodref>
    <emu-prodref name="OptionalChain"></emu-prodref>
    <emu-prodref name="LeftHandSideExpression"></emu-prodref>
    <emu-prodref name="UpdateExpression"></emu-prodref>
    <emu-prodref name="UnaryExpression"></emu-prodref>
    <emu-prodref name="ExponentiationExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeExpression"></emu-prodref>
    <emu-prodref name="MultiplicativeOperator"></emu-prodref>
    <emu-prodref name="AdditiveExpression"></emu-prodref>
    <emu-prodref name="ShiftExpression"></emu-prodref>
    <emu-prodref name="RelationalExpression"></emu-prodref>
    <emu-prodref name="EqualityExpression"></emu-prodref>
    <emu-prodref name="BitwiseANDExpression"></emu-prodref>
    <emu-prodref name="BitwiseXORExpression"></emu-prodref>
    <emu-prodref name="BitwiseORExpression"></emu-prodref>
    <emu-prodref name="LogicalANDExpression"></emu-prodref>
    <emu-prodref name="LogicalORExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpression"></emu-prodref>
    <emu-prodref name="CoalesceExpressionHead"></emu-prodref>
    <emu-prodref name="ShortCircuitExpression"></emu-prodref>
    <emu-prodref name="ConditionalExpression"></emu-prodref>
    <emu-prodref name="AssignmentExpression"></emu-prodref>
    <emu-prodref name="AssignmentOperator"></emu-prodref>
    <p>
      In certain circumstances when processing an instance of the production<br>
      <emu-prodref name="AssignmentExpression" a="assignment"></emu-prodref><br>
      the interpretation of |LeftHandSideExpression| is refined using the following grammar:
    </p>
    <emu-prodref name="AssignmentPattern"></emu-prodref>
    <emu-prodref name="ObjectAssignmentPattern"></emu-prodref>
    <emu-prodref name="ArrayAssignmentPattern"></emu-prodref>
    <emu-prodref name="AssignmentRestProperty"></emu-prodref>
    <emu-prodref name="AssignmentPropertyList"></emu-prodref>
    <emu-prodref name="AssignmentElementList"></emu-prodref>
    <emu-prodref name="AssignmentElisionElement"></emu-prodref>
    <emu-prodref name="AssignmentProperty"></emu-prodref>
    <emu-prodref name="AssignmentElement"></emu-prodref>
    <emu-prodref name="AssignmentRestElement"></emu-prodref>
    <emu-prodref name="DestructuringAssignmentTarget"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="Expression"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-statements">
    <h1>Statements</h1>
    <emu-prodref name="Statement"></emu-prodref>
    <emu-prodref name="Declaration"></emu-prodref>
    <emu-prodref name="HoistableDeclaration"></emu-prodref>
    <emu-prodref name="BreakableStatement"></emu-prodref>
    <emu-prodref name="BlockStatement"></emu-prodref>
    <emu-prodref name="Block"></emu-prodref>
    <emu-prodref name="StatementList"></emu-prodref>
    <emu-prodref name="StatementListItem"></emu-prodref>
    <emu-prodref name="LexicalDeclaration"></emu-prodref>
    <emu-prodref name="LetOrConst"></emu-prodref>
    <emu-prodref name="BindingList"></emu-prodref>
    <emu-prodref name="LexicalBinding"></emu-prodref>
    <emu-prodref name="VariableStatement"></emu-prodref>
    <emu-prodref name="VariableDeclarationList"></emu-prodref>
    <emu-prodref name="VariableDeclaration"></emu-prodref>
    <emu-prodref name="BindingPattern"></emu-prodref>
    <emu-prodref name="ObjectBindingPattern"></emu-prodref>
    <emu-prodref name="ArrayBindingPattern"></emu-prodref>
    <emu-prodref name="BindingRestProperty"></emu-prodref>
    <emu-prodref name="BindingPropertyList"></emu-prodref>
    <emu-prodref name="BindingElementList"></emu-prodref>
    <emu-prodref name="BindingElisionElement"></emu-prodref>
    <emu-prodref name="BindingProperty"></emu-prodref>
    <emu-prodref name="BindingElement"></emu-prodref>
    <emu-prodref name="SingleNameBinding"></emu-prodref>
    <emu-prodref name="BindingRestElement"></emu-prodref>
    <emu-prodref name="EmptyStatement"></emu-prodref>
    <emu-prodref name="ExpressionStatement"></emu-prodref>
    <emu-prodref name="IfStatement"></emu-prodref>
    <emu-prodref name="IterationStatement"></emu-prodref>
    <emu-prodref name="DoWhileStatement"></emu-prodref>
    <emu-prodref name="WhileStatement"></emu-prodref>
    <emu-prodref name="ForStatement"></emu-prodref>
    <emu-prodref name="ForInOfStatement"></emu-prodref>
    <emu-prodref name="ForDeclaration"></emu-prodref>
    <emu-prodref name="ForBinding"></emu-prodref>
    <emu-prodref name="ContinueStatement"></emu-prodref>
    <emu-prodref name="BreakStatement"></emu-prodref>
    <emu-prodref name="ReturnStatement"></emu-prodref>
    <emu-prodref name="WithStatement"></emu-prodref>
    <emu-prodref name="SwitchStatement"></emu-prodref>
    <emu-prodref name="CaseBlock"></emu-prodref>
    <emu-prodref name="CaseClauses"></emu-prodref>
    <emu-prodref name="CaseClause"></emu-prodref>
    <emu-prodref name="DefaultClause"></emu-prodref>
    <emu-prodref name="LabelledStatement"></emu-prodref>
    <emu-prodref name="LabelledItem"></emu-prodref>
    <emu-prodref name="ThrowStatement"></emu-prodref>
    <emu-prodref name="TryStatement"></emu-prodref>
    <emu-prodref name="Catch"></emu-prodref>
    <emu-prodref name="Finally"></emu-prodref>
    <emu-prodref name="CatchParameter"></emu-prodref>
    <emu-prodref name="DebuggerStatement"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-functions-and-classes">
    <h1>Functions and Classes</h1>
    <emu-prodref name="UniqueFormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameters"></emu-prodref>
    <emu-prodref name="FormalParameterList"></emu-prodref>
    <emu-prodref name="FunctionRestParameter"></emu-prodref>
    <emu-prodref name="FormalParameter"></emu-prodref>
    <emu-prodref name="FunctionDeclaration"></emu-prodref>
    <emu-prodref name="FunctionExpression"></emu-prodref>
    <emu-prodref name="FunctionBody"></emu-prodref>
    <emu-prodref name="FunctionStatementList"></emu-prodref>
    <emu-prodref name="ArrowFunction"></emu-prodref>
    <emu-prodref name="ArrowParameters"></emu-prodref>
    <emu-prodref name="ConciseBody"></emu-prodref>
    <emu-prodref name="ExpressionBody"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="ArrowParameters" a="parencover"></emu-prodref><br>
      the interpretation of |CoverParenthesizedExpressionAndArrowParameterList| is refined using the following grammar:
    </p>
    <emu-prodref name="ArrowFormalParameters"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="AsyncArrowFunction"></emu-prodref>
    <emu-prodref name="AsyncConciseBody"></emu-prodref>
    <emu-prodref name="AsyncArrowBindingIdentifier"></emu-prodref>
    <emu-prodref name="CoverCallExpressionAndAsyncArrowHead"></emu-prodref>
    <p>
      When processing an instance of the production<br>
      <emu-prodref name="AsyncArrowFunction" a="callcover"></emu-prodref><br>
      the interpretation of |CoverCallExpressionAndAsyncArrowHead| is refined using the following grammar:
    </p>
    <emu-prodref name="AsyncArrowHead"></emu-prodref>
    <p>&nbsp;</p>
    <emu-prodref name="MethodDefinition"></emu-prodref>
    <emu-prodref name="PropertySetParameterList"></emu-prodref>
    <emu-prodref name="GeneratorDeclaration"></emu-prodref>
    <emu-prodref name="GeneratorExpression"></emu-prodref>
    <emu-prodref name="GeneratorMethod"></emu-prodref>
    <emu-prodref name="GeneratorBody"></emu-prodref>
    <emu-prodref name="YieldExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorDeclaration"></emu-prodref>
    <emu-prodref name="AsyncGeneratorExpression"></emu-prodref>
    <emu-prodref name="AsyncGeneratorMethod"></emu-prodref>
    <emu-prodref name="AsyncGeneratorBody"></emu-prodref>
    <emu-prodref name="AsyncFunctionDeclaration"></emu-prodref>
    <emu-prodref name="AsyncFunctionExpression"></emu-prodref>
    <emu-prodref name="AsyncMethod"></emu-prodref>
    <emu-prodref name="AsyncFunctionBody"></emu-prodref>
    <emu-prodref name="AwaitExpression"></emu-prodref>
    <emu-prodref name="ClassDeclaration"></emu-prodref>
    <emu-prodref name="ClassExpression"></emu-prodref>
    <emu-prodref name="ClassTail"></emu-prodref>
    <emu-prodref name="ClassHeritage"></emu-prodref>
    <emu-prodref name="ClassBody"></emu-prodref>
    <emu-prodref name="ClassElementList"></emu-prodref>
    <emu-prodref name="ClassElement"></emu-prodref>
    <emu-prodref name="FieldDefinition"></emu-prodref>
    <emu-prodref name="ClassElementName"></emu-prodref>
    <emu-prodref name="ClassStaticBlock"></emu-prodref>
    <emu-prodref name="ClassStaticBlockBody"></emu-prodref>
    <emu-prodref name="ClassStaticBlockStatementList"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-scripts-and-modules">
    <h1>Scripts and Modules</h1>
    <emu-prodref name="Script"></emu-prodref>
    <emu-prodref name="ScriptBody"></emu-prodref>
    <emu-prodref name="Module"></emu-prodref>
    <emu-prodref name="ModuleBody"></emu-prodref>
    <emu-prodref name="ModuleItemList"></emu-prodref>
    <emu-prodref name="ModuleItem"></emu-prodref>
    <emu-prodref name="ModuleExportName"></emu-prodref>
    <emu-prodref name="ImportDeclaration"></emu-prodref>
    <emu-prodref name="ImportClause"></emu-prodref>
    <emu-prodref name="ImportedDefaultBinding"></emu-prodref>
    <emu-prodref name="NameSpaceImport"></emu-prodref>
    <emu-prodref name="NamedImports"></emu-prodref>
    <emu-prodref name="FromClause"></emu-prodref>
    <emu-prodref name="ImportsList"></emu-prodref>
    <emu-prodref name="ImportSpecifier"></emu-prodref>
    <emu-prodref name="ModuleSpecifier"></emu-prodref>
    <emu-prodref name="ImportedBinding"></emu-prodref>
    <emu-prodref name="WithClause"></emu-prodref>
    <emu-prodref name="WithEntries"></emu-prodref>
    <emu-prodref name="AttributeKey"></emu-prodref>
    <emu-prodref name="ExportDeclaration"></emu-prodref>
    <emu-prodref name="ExportFromClause"></emu-prodref>
    <emu-prodref name="NamedExports"></emu-prodref>
    <emu-prodref name="ExportsList"></emu-prodref>
    <emu-prodref name="ExportSpecifier"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-number-conversions">
    <h1>Number Conversions</h1>
    <emu-prodref name="StringNumericLiteral"></emu-prodref>
    <emu-prodref name="StrWhiteSpace"></emu-prodref>
    <emu-prodref name="StrWhiteSpaceChar"></emu-prodref>
    <emu-prodref name="StrNumericLiteral"></emu-prodref>
    <emu-prodref name="StrDecimalLiteral"></emu-prodref>
    <emu-prodref name="StrUnsignedDecimalLiteral"></emu-prodref>
    <p>All grammar symbols not explicitly defined by the |StringNumericLiteral| grammar have the definitions used in the <emu-xref href="#sec-literals-numeric-literals">Lexical Grammar for numeric literals</emu-xref>.</p>
    <emu-prodref name="StringIntegerLiteral"></emu-prodref>
    <emu-prodref name="StrIntegerLiteral"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-time-zone-offset-string-format">
    <h1>Time Zone Offset String Format</h1>
    <emu-prodref name="UTCOffset"></emu-prodref>
    <emu-prodref name="ASCIISign"></emu-prodref>
    <emu-prodref name="Hour"></emu-prodref>
    <emu-prodref name="HourSubcomponents"></emu-prodref>
    <emu-prodref name="TimeSeparator"></emu-prodref>
    <emu-prodref name="MinuteSecond"></emu-prodref>
    <emu-prodref name="TemporalDecimalFraction"></emu-prodref>
    <emu-prodref name="TemporalDecimalSeparator"></emu-prodref>
  </emu-annex>

  <emu-annex id="sec-regular-expressions">
    <h1>Regular Expressions</h1>
    <emu-prodref name="Pattern"></emu-prodref>
    <emu-prodref name="Disjunction"></emu-prodref>
    <emu-prodref name="Alternative"></emu-prodref>
    <emu-prodref name="Term"></emu-prodref>
    <emu-prodref name="Assertion"></emu-prodref>
    <emu-prodref name="Quantifier"></emu-prodref>
    <emu-prodref name="QuantifierPrefix"></emu-prodref>
    <emu-prodref name="Atom"></emu-prodref>
    <emu-prodref name="RegularExpressionModifiers"></emu-prodref>
    <emu-prodref name="RegularExpressionModifier"></emu-prodref>
    <emu-prodref name="SyntaxCharacter"></emu-prodref>
    <emu-prodref name="PatternCharacter"></emu-prodref>
    <emu-prodref name="AtomEscape"></emu-prodref>
    <emu-prodref name="CharacterEscape"></emu-prodref>
    <emu-prodref name="ControlEscape"></emu-prodref>
    <emu-prodref name="GroupSpecifier"></emu-prodref>
    <emu-prodref name="GroupName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierName"></emu-prodref>
    <emu-prodref name="RegExpIdentifierStart"></emu-prodref>
    <emu-prodref name="RegExpIdentifierPart"></emu-prodref>
    <emu-prodref name="RegExpUnicodeEscapeSequence"></emu-prodref>
    <emu-prodref name="UnicodeLeadSurrogate"></emu-prodref>
    <emu-prodref name="UnicodeTrailSurrogate"></emu-prodref>
    <p>Each `\\u` |HexTrailSurrogate| for which the choice of associated `u` |HexLeadSurrogate| is ambiguous shall be associated with the nearest possible `u` |HexLeadSurrogate| that would otherwise have no corresponding `\\u` |HexTrailSurrogate|.</p>
    <p>&nbsp;</p>
    <emu-prodref name="HexLeadSurrogate"></emu-prodref>
    <emu-prodref name="HexTrailSurrogate"></emu-prodref>
    <emu-prodref name="HexNonSurrogate"></emu-prodref>
    <emu-prodref name="IdentityEscape"></emu-prodref>
    <emu-prodref name="DecimalEscape"></emu-prodref>
    <emu-prodref name="CharacterClassEscape"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueExpression"></emu-prodref>
    <emu-prodref name="UnicodePropertyName"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValue"></emu-prodref>
    <emu-prodref name="LoneUnicodePropertyNameOrValue"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacters"></emu-prodref>
    <emu-prodref name="UnicodePropertyValueCharacter"></emu-prodref>
    <emu-prodref name="UnicodePropertyNameCharacter"></emu-prodref>
    <emu-prodref name="CharacterClass"></emu-prodref>
    <emu-prodref name="ClassContents"></emu-prodref>
    <emu-prodref name="NonemptyClassRanges"></emu-prodref>
    <emu-prodref name="NonemptyClassRangesNoDash"></emu-prodref>
    <emu-prodref name="ClassAtom"></emu-prodref>
    <emu-prodref name="ClassAtomNoDash"></emu-prodref>
    <emu-prodref name="ClassEscape"></emu-prodref>
    <emu-prodref name="ClassSetExpression"></emu-prodref>
    <emu-prodref name="ClassUnion"></emu-prodref>
    <emu-prodref name="ClassIntersection"></emu-prodref>
    <emu-prodref name="ClassSubtraction"></emu-prodref>
    <emu-prodref name="ClassSetRange"></emu-prodref>
    <emu-prodref name="ClassSetOperand"></emu-prodref>
    <emu-prodref name="NestedClass"></emu-prodref>
    <emu-prodref name="ClassStringDisjunction"></emu-prodref>
    <emu-prodref name="ClassStringDisjunctionContents"></emu-prodref>
    <emu-prodref name="ClassString"></emu-prodref>
    <emu-prodref name="NonEmptyClassString"></emu-prodref>
    <emu-prodref name="ClassSetCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedDoublePunctuator"></emu-prodref>
    <emu-prodref name="ClassSetSyntaxCharacter"></emu-prodref>
    <emu-prodref name="ClassSetReservedPunctuator"></emu-prodref>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-additional-ecmascript-features-for-web-browsers" namespace="annexB" normative>
  <h1>Additional ECMAScript Features for Web Browsers</h1>
  <p>The ECMAScript language syntax and semantics defined in this annex are required when the ECMAScript host is a web browser. The content of this annex is normative but optional if the ECMAScript host is not a web browser.</p>
  <p>Some features defined in this annex are specified in this annex, and some are specified in the main body of this document.</p>
  <p>When a feature is specified in the main body, each point where it affects the document is marked with the words "Normative Optional" in a coloured box. Moreover, where the feature involves particular wording in an algorithm or early error rule, this is guarded by the condition that “<dfn variants="otherwise supports">the host supports</dfn>” the relevant feature. Web browsers are required to support all such features.</p>
  <emu-note>
    <p>This annex describes various legacy features and other characteristics of web browser ECMAScript hosts. All of the language features and behaviours specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. However, the usage of these features by large numbers of existing web pages means that web browsers must continue to support them. The specifications in this annex define the requirements for interoperable implementations of these legacy features.</p>
    <p>These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ECMAScript implementations are discouraged from implementing these features unless the implementation is part of a web browser or is required to run the same legacy ECMAScript code that web browsers encounter.</p>
  </emu-note>

  <emu-annex id="sec-additional-syntax">
    <h1>Additional Syntax</h1>

    <emu-annex id="sec-html-like-comments">
      <h1>HTML-like Comments</h1>
      <p>The syntax and semantics of <emu-xref href="#sec-comments"></emu-xref> is extended as follows except that this extension is not allowed when parsing source text using the goal symbol |Module|:</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        InputElementHashbangOrRegExp ::
          WhiteSpace
          LineTerminator
          Comment
          CommonToken
          HashbangComment
          RegularExpressionLiteral
          HTMLCloseComment

        Comment ::
          MultiLineComment
          SingleLineComment
          SingleLineHTMLOpenComment
          SingleLineHTMLCloseComment
          SingleLineDelimitedComment

        MultiLineComment ::
          `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

        FirstCommentLine ::
          SingleLineDelimitedCommentChars

        SingleLineHTMLOpenComment ::
          `&lt;!--` SingleLineCommentChars?

        SingleLineHTMLCloseComment ::
          LineTerminatorSequence HTMLCloseComment

        SingleLineDelimitedComment ::
          `/*` SingleLineDelimitedCommentChars? `*/`

        HTMLCloseComment ::
          WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `--&gt;` SingleLineCommentChars?

        SingleLineDelimitedCommentChars ::
          SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotAsteriskChar ::
          SourceCharacter but not one of `*` or LineTerminator

        SingleLinePostAsteriskCommentChars ::
          SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
          `*` SingleLinePostAsteriskCommentChars?

        SingleLineNotForwardSlashOrAsteriskChar ::
          SourceCharacter but not one of `/` or `*` or LineTerminator

        WhiteSpaceSequence ::
          WhiteSpace WhiteSpaceSequence?

        SingleLineDelimitedCommentSequence ::
          SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?
      </emu-grammar>
      <p>Similar to a |MultiLineComment| that contains a line terminator code point, a |SingleLineHTMLCloseComment| is considered to be a |LineTerminator| for purposes of parsing by the syntactic grammar.</p>
    </emu-annex>

    <emu-annex id="sec-regular-expressions-patterns">
      <h1>Regular Expressions Patterns</h1>
      <p>The syntax of <emu-xref href="#sec-patterns"></emu-xref> is modified and extended as follows. These changes introduce ambiguities that are broken by the ordering of grammar productions and by contextual information. When parsing using the following grammar, each alternative is considered only if previous production alternatives do not match.</p>
      <p>This alternative pattern grammar and semantics only changes the syntax and semantics of BMP patterns. The following grammar extensions include productions parameterized with the [UnicodeMode] parameter. However, none of these extensions change the syntax of Unicode patterns recognized when parsing with the [UnicodeMode] parameter present on the goal symbol.</p>
      <h2>Syntax</h2>
      <emu-grammar type="definition">
        Term[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          [+UnicodeMode] Assertion[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] Quantifier
          [+UnicodeMode] Atom[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] Assertion[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups]
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups] Quantifier
          [~UnicodeMode] ExtendedAtom[?NamedCaptureGroups]

        Assertion[UnicodeMode, UnicodeSetsMode, NamedCaptureGroups] ::
          `^`
          `$`
          `\b`
          `\B`
          [+UnicodeMode] `(?=` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [+UnicodeMode] `(?!` Disjunction[+UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          [~UnicodeMode] QuantifiableAssertion[?NamedCaptureGroups]
          `(?&lt;=` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?&lt;!` Disjunction[?UnicodeMode, ?UnicodeSetsMode, ?NamedCaptureGroups] `)`

        QuantifiableAssertion[NamedCaptureGroups] ::
          `(?=` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?!` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`

        ExtendedAtom[NamedCaptureGroups] ::
          `.`
          `\` AtomEscape[~UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]
          CharacterClass[~UnicodeMode, ~UnicodeSetsMode]
          `(` GroupSpecifier[~UnicodeMode]? Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          `(?` RegularExpressionModifiers `-` RegularExpressionModifiers `:` Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] `)`
          InvalidBracedQuantifier
          ExtendedPatternCharacter

        InvalidBracedQuantifier ::
          `{` DecimalDigits[~Sep] `}`
          `{` DecimalDigits[~Sep] `,}`
          `{` DecimalDigits[~Sep] `,` DecimalDigits[~Sep] `}`

        ExtendedPatternCharacter ::
          SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

        AtomEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] DecimalEscape
          [~UnicodeMode] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is &le; CountLeftCapturingParensWithin(the |Pattern| containing |DecimalEscape|)]
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]
          [+NamedCaptureGroups] `k` GroupName[?UnicodeMode]

        CharacterEscape[UnicodeMode, NamedCaptureGroups] ::
          ControlEscape
          `c` AsciiLetter
          `0` [lookahead &notin; DecimalDigit]
          HexEscapeSequence
          RegExpUnicodeEscapeSequence[?UnicodeMode]
          [~UnicodeMode] LegacyOctalEscapeSequence
          IdentityEscape[?UnicodeMode, ?NamedCaptureGroups]

        IdentityEscape[UnicodeMode, NamedCaptureGroups] ::
          [+UnicodeMode] SyntaxCharacter
          [+UnicodeMode] `/`
          [~UnicodeMode] SourceCharacterIdentityEscape[?NamedCaptureGroups]

        SourceCharacterIdentityEscape[NamedCaptureGroups] ::
          [~NamedCaptureGroups] SourceCharacter but not `c`
          [+NamedCaptureGroups] SourceCharacter but not one of `c` or `k`

        ClassAtomNoDash[UnicodeMode, NamedCaptureGroups] ::
          SourceCharacter but not one of `\` or `]` or `-`
          `\` ClassEscape[?UnicodeMode, ?NamedCaptureGroups]
          `\` [lookahead == `c`]

        ClassEscape[UnicodeMode, NamedCaptureGroups] ::
          `b`
          [+UnicodeMode] `-`
          [~UnicodeMode] `c` ClassControlLetter
          CharacterClassEscape[?UnicodeMode]
          CharacterEscape[?UnicodeMode, ?NamedCaptureGroups]

        ClassControlLetter ::
          DecimalDigit
          `_`
      </emu-grammar>
      <emu-note>
        <p>When the same left-hand sides occurs with both [+UnicodeMode] and [\~UnicodeMode] guards it is to control the disambiguation priority.</p>
      </emu-note>

      <emu-annex id="sec-patterns-static-semantics-early-errors-annexb">
        <h1>Static Semantics: Early Errors</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-early-errors"></emu-xref> is extended as follows:</p>
        <emu-grammar>ExtendedAtom :: InvalidBracedQuantifier</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if any source text is matched by this production.
          </li>
        </ul>
        <p>Additionally, the rules for the following productions are modified with the addition of the <ins>highlighted</ins> text:</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *true* or IsCharacterClass of the second |ClassAtom| is *true* <ins>and this production has a <sub>[UnicodeMode]</sub> parameter</ins>.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of the first |ClassAtom| is *false*, IsCharacterClass of the second |ClassAtom| is *false*, and the CharacterValue of the first |ClassAtom| is strictly greater than the CharacterValue of the second |ClassAtom|.
          </li>
        </ul>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *true* or IsCharacterClass of |ClassAtom| is *true* <ins>and this production has a <sub>[UnicodeMode]</sub> parameter</ins>.
          </li>
          <li>
            It is a Syntax Error if IsCharacterClass of |ClassAtomNoDash| is *false*, IsCharacterClass of |ClassAtom| is *false*, and the CharacterValue of |ClassAtomNoDash| is strictly greater than the CharacterValue of |ClassAtom|.
          </li>
        </ul>
      </emu-annex>

      <emu-annex id="sec-countleftcapturingparens-annexb">
        <h1>Static Semantics: CountLeftCapturingParensWithin and CountLeftCapturingParensBefore</h1>
        <p>In the definitions of CountLeftCapturingParensWithin and CountLeftCapturingParensBefore, references to “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ” are to be interpreted as meaning “<emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ” or “<emu-grammar>ExtendedAtom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> ”.</p>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-is-character-class-annexb">
        <h1>Static Semantics: IsCharacterClass</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-is-character-class"></emu-xref> is extended as follows:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-patterns-static-semantics-character-value-annexb">
        <h1>Static Semantics: CharacterValue</h1>
        <p>The semantics of <emu-xref href="#sec-patterns-static-semantics-character-value"></emu-xref> is extended as follows:</p>
        <emu-grammar>
          ClassAtomNoDash :: `\` [lookahead == `c`]
        </emu-grammar>
        <emu-alg>
          1. Return the numeric value of U+005C (REVERSE SOLIDUS).
        </emu-alg>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the code point matched by |ClassControlLetter|.
          1. Let _i_ be the numeric value of _ch_.
          1. Return the remainder of dividing _i_ by 32.
        </emu-alg>
        <emu-grammar>CharacterEscape :: LegacyOctalEscapeSequence</emu-grammar>
        <emu-alg>
          1. Return the MV of |LegacyOctalEscapeSequence| (see <emu-xref href="#sec-string-literals-static-semantics-mv"></emu-xref>).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compilesubpattern-annexb" oldids="sec-regular-expression-patterns-semantics">
        <h1>Runtime Semantics: CompileSubpattern</h1>
        <p>The semantics of CompileSubpattern is extended as follows:</p>

        <p>The rule for <emu-grammar>Term :: QuantifiableAssertion Quantifier</emu-grammar> is the same as for <emu-grammar>Term :: Atom Quantifier</emu-grammar> but with |QuantifiableAssertion| substituted for |Atom|.</p>
        <p>The rule for <emu-grammar>Term :: ExtendedAtom Quantifier</emu-grammar> is the same as for <emu-grammar>Term :: Atom Quantifier</emu-grammar> but with |ExtendedAtom| substituted for |Atom|.</p>
        <p>The rule for <emu-grammar>Term :: ExtendedAtom</emu-grammar> is the same as for <emu-grammar>Term :: Atom</emu-grammar> but with |ExtendedAtom| substituted for |Atom|.</p>
      </emu-annex>

      <emu-annex id="sec-compileassertion-annexb">
        <h1>Runtime Semantics: CompileAssertion</h1>
        <p>CompileAssertion rules for the <emu-grammar>Assertion :: `(?=` Disjunction `)`</emu-grammar> and <emu-grammar>Assertion :: `(?!` Disjunction `)`</emu-grammar> productions are also used for the |QuantifiableAssertion| productions, but with |QuantifiableAssertion| substituted for |Assertion|.</p>
      </emu-annex>

      <emu-annex id="sec-compileatom-annexb">
        <h1>Runtime Semantics: CompileAtom</h1>
        <p>CompileAtom rules for the |Atom| productions except for <emu-grammar>Atom :: PatternCharacter</emu-grammar> are also used for the |ExtendedAtom| productions, but with |ExtendedAtom| substituted for |Atom|. The following rules, with parameter _direction_, are also added:</p>
        <emu-grammar>ExtendedAtom :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. Let _A_ be the CharSet containing the single character `\\` U+005C (REVERSE SOLIDUS).
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
        <emu-grammar>ExtendedAtom :: ExtendedPatternCharacter</emu-grammar>
        <emu-alg>
          1. Let _ch_ be the character represented by |ExtendedPatternCharacter|.
          1. Let _A_ be a one-element CharSet containing the character _ch_.
          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-compiletocharset-annexb">
        <h1>Runtime Semantics: CompileToCharSet</h1>
        <p>The semantics of <emu-xref href="#sec-compiletocharset"></emu-xref> is extended as follows:</p>

        <p>The following two rules replace the corresponding rules of CompileToCharSet.</p>
        <emu-grammar>NonemptyClassRanges :: ClassAtom `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.
          1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRangeOrUnion(_rer_, _A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>
        <emu-grammar>NonemptyClassRangesNoDash :: ClassAtomNoDash `-` ClassAtom ClassContents</emu-grammar>
        <emu-alg>
          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.
          1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.
          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.
          1. Let _D_ be CharacterRangeOrUnion(_rer_, _A_, _B_).
          1. Return the union of _D_ and _C_.
        </emu-alg>

        <p>In addition, the following rules are added to CompileToCharSet.</p>
        <emu-grammar>ClassEscape :: `c` ClassControlLetter</emu-grammar>
        <emu-alg>
          1. Let _cv_ be the CharacterValue of this |ClassEscape|.
          1. Let _c_ be the character whose character value is _cv_.
          1. Return the CharSet containing the single character _c_.
        </emu-alg>
        <emu-grammar>ClassAtomNoDash :: `\` [lookahead == `c`]</emu-grammar>
        <emu-alg>
          1. Return the CharSet containing the single character `\\` U+005C (REVERSE SOLIDUS).
        </emu-alg>

        <emu-note>This production can only be reached from the sequence `\c` within a character class where it is not followed by an acceptable control character.</emu-note>

        <emu-annex id="sec-runtime-semantics-characterrangeorunion-abstract-operation" type="abstract operation">
          <h1>
            CharacterRangeOrUnion (
              _rer_: a RegExp Record,
              _A_: a CharSet,
              _B_: a CharSet,
            ): a CharSet
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. If HasEitherUnicodeFlag(_rer_) is *false*, then
              1. If _A_ does not contain exactly one character or _B_ does not contain exactly one character, then
                1. Let _C_ be the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).
                1. Return the union of CharSets _A_, _B_ and _C_.
            1. Return CharacterRange(_A_, _B_).
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-parsepattern-annexb">
        <h1>Static Semantics: ParsePattern ( _patternText_, _u_, _v_ )</h1>
        <p>The semantics of <emu-xref href="#sec-parsepattern"></emu-xref> is extended as follows:</p>
        <p>The abstract operation ParsePattern takes arguments _patternText_ (a sequence of Unicode code points), _u_ (a Boolean), and _v_ (a Boolean). It performs the following steps when called:</p>
        <emu-alg>
          1. If _v_ is *true* and _u_ is *true*, then
            1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.
          1. Else if _v_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else if _u_ is *true*, then
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Else,
            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, ~NamedCaptureGroups]|).
            1. If _parseResult_ is a Parse Node and _parseResult_ contains a |GroupName|, then
              1. Set _parseResult_ to ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).
          1. Return _parseResult_.
        </emu-alg>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-additional-built-in-properties">
    <h1>Additional Built-in Properties</h1>
    <p>When the ECMAScript host is a web browser the following additional properties of the standard built-in objects are defined.</p>

    <emu-annex id="sec-additional-properties-of-the-global-object">
      <h1>Additional Properties of the Global Object</h1>
      <p>The entries in <emu-xref href="#table-additional-well-known-intrinsic-objects"></emu-xref> are added to <emu-xref href="#table-well-known-intrinsic-objects"></emu-xref>.</p>
      <emu-table id="table-additional-well-known-intrinsic-objects" caption="Additional Well-known Intrinsic Objects" oldids="table-60">
        <table>
          <thead>
            <tr>
              <th>
                Intrinsic Name
              </th>
              <th>
                Global Name
              </th>
              <th>
                ECMAScript Language Association
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              %escape%
            </td>
            <td>
              `escape`
            </td>
            <td>
              The `escape` function (<emu-xref href="#sec-escape-string"></emu-xref>)
            </td>
          </tr>
          <tr>
            <td>
              %unescape%
            </td>
            <td>
              `unescape`
            </td>
            <td>
              The `unescape` function (<emu-xref href="#sec-unescape-string"></emu-xref>)
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-annex id="sec-escape-string">
        <h1>escape ( _string_ )</h1>
        <p>This function is a property of the global object. It computes a new version of a String value in which certain code units have been replaced by a hexadecimal escape sequence.</p>
        <p>When replacing a code unit of numeric value less than or equal to 0x00FF, a two-digit escape sequence of the form <code>%<var>xx</var></code> is used. When replacing a code unit of numeric value strictly greater than 0x00FF, a four-digit escape sequence of the form <code>%u<var>xxxx</var></code> is used.</p>
        <p>It is the <dfn>%escape%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Set _string_ to ? ToString(_string_).
          1. Let _len_ be the length of _string_.
          1. Let _R_ be the empty String.
          1. Let _unescapedSet_ be the string-concatenation of the ASCII word characters and *"@\*+-./"*.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _C_ be the code unit at index _k_ within _string_.
            1. If _unescapedSet_ contains _C_, then
              1. Let _S_ be _C_.
            1. Else,
              1. Let _n_ be the numeric value of _C_.
              1. If _n_ &lt; 256, then
                1. Let _hex_ be the String representation of _n_, formatted as an uppercase hexadecimal number.
                1. Let _S_ be the string-concatenation of *"%"* and StringPad(_hex_, 2, *"0"*, ~start~).
              1. Else,
                1. Let _hex_ be the String representation of _n_, formatted as an uppercase hexadecimal number.
                1. Let _S_ be the string-concatenation of *"%u"* and StringPad(_hex_, 4, *"0"*, ~start~).
            1. Set _R_ to the string-concatenation of _R_ and _S_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
        <emu-note>
          <p>The encoding is partly based on the encoding described in RFC 1738, but the entire encoding specified in this standard is described above without regard to the contents of RFC 1738. This encoding does not reflect changes to RFC 1738 made by RFC 3986.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-unescape-string">
        <h1>unescape ( _string_ )</h1>
        <p>This function is a property of the global object. It computes a new version of a String value in which each escape sequence of the sort that might be introduced by the `escape` function is replaced with the code unit that it represents.</p>
        <p>It is the <dfn>%unescape%</dfn> intrinsic object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Set _string_ to ? ToString(_string_).
          1. Let _len_ be the length of _string_.
          1. Let _R_ be the empty String.
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _len_,
            1. Let _C_ be the code unit at index _k_ within _string_.
            1. If _C_ is the code unit 0x0025 (PERCENT SIGN), then
              1. Let _hexDigits_ be the empty String.
              1. Let _optionalAdvance_ be 0.
              1. If _k_ + 5 &lt; _len_ and the code unit at index _k_ + 1 within _string_ is the code unit 0x0075 (LATIN SMALL LETTER U), then
                1. Set _hexDigits_ to the substring of _string_ from _k_ + 2 to _k_ + 6.
                1. Set _optionalAdvance_ to 5.
              1. Else if _k_ + 3 ≤ _len_, then
                1. Set _hexDigits_ to the substring of _string_ from _k_ + 1 to _k_ + 3.
                1. Set _optionalAdvance_ to 2.
              1. Let _parseResult_ be ParseText(_hexDigits_, |HexDigits[~Sep]|).
              1. If _parseResult_ is a Parse Node, then
                1. Let _n_ be the MV of _parseResult_.
                1. Set _C_ to the code unit whose numeric value is _n_.
                1. Set _k_ to _k_ + _optionalAdvance_.
            1. Set _R_ to the string-concatenation of _R_ and _C_.
            1. Set _k_ to _k_ + 1.
          1. Return _R_.
        </emu-alg>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-string.prototype-object">
      <h1>Additional Properties of the String.prototype Object</h1>

      <emu-annex id="sec-string.prototype.substr">
        <h1>String.prototype.substr ( _start_, _length_ )</h1>
        <p>This method returns a <emu-not-ref>substring</emu-not-ref> of the result of converting the *this* value to a String, starting from index _start_ and running for _length_ code units (or through the end of the String if _length_ is *undefined*). If _start_ is negative, it is treated as <emu-eqn>_sourceLength_ + _start_</emu-eqn> where _sourceLength_ is the length of the String. The result is a String value, not a String object.</p>
        <p>It performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireObjectCoercible(_O_).
          1. Let _S_ be ? ToString(_O_).
          1. Let _size_ be the length of _S_.
          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).
          1. If _intStart_ = -∞, set _intStart_ to 0.
          1. Else if _intStart_ &lt; 0, set _intStart_ to max(_size_ + _intStart_, 0).
          1. Else, set _intStart_ to min(_intStart_, _size_).
          1. If _length_ is *undefined*, let _intLength_ be _size_; otherwise let _intLength_ be ? ToIntegerOrInfinity(_length_).
          1. Set _intLength_ to the result of clamping _intLength_ between 0 and _size_.
          1. Let _intEnd_ be min(_intStart_ + _intLength_, _size_).
          1. Return the substring of _S_ from _intStart_ to _intEnd_.
        </emu-alg>
        <emu-note>
          <p>This method is intentionally generic; it does not require that its *this* value be a String object. Therefore it can be transferred to other kinds of objects for use as a method.</p>
        </emu-note>
      </emu-annex>

      <emu-annex id="sec-string.prototype.anchor">
        <h1>String.prototype.anchor ( _name_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"a"*, *"name"*, _name_).
        </emu-alg>

        <emu-annex id="sec-createhtml" type="abstract operation">
          <h1>
            CreateHTML (
              _string_: an ECMAScript language value,
              _tag_: a String,
              _attribute_: a String,
              _value_: an ECMAScript language value,
            ): either a normal completion containing a String or a throw completion
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. Perform ? RequireObjectCoercible(_string_).
            1. Let _S_ be ? ToString(_string_).
            1. Let _p1_ be the string-concatenation of *"&lt;"* and _tag_.
            1. If _attribute_ is not the empty String, then
              1. Let _V_ be ? ToString(_value_).
              1. Let _escapedV_ be the String value that is the same as _V_ except that each occurrence of the code unit 0x0022 (QUOTATION MARK) in _V_ has been replaced with the six code unit sequence *"&amp;quot;"*.
              1. Set _p1_ to the string-concatenation of:
                * _p1_
                * the code unit 0x0020 (SPACE)
                * _attribute_
                * the code unit 0x003D (EQUALS SIGN)
                * the code unit 0x0022 (QUOTATION MARK)
                * _escapedV_
                * the code unit 0x0022 (QUOTATION MARK)
            1. Let _p2_ be the string-concatenation of _p1_ and *">"*.
            1. Let _p3_ be the string-concatenation of _p2_ and _S_.
            1. Let _p4_ be the string-concatenation of _p3_, *"&lt;/"*, _tag_, and *">"*.
            1. Return _p4_.
          </emu-alg>
        </emu-annex>
      </emu-annex>

      <emu-annex id="sec-string.prototype.big">
        <h1>String.prototype.big ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"big"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.blink">
        <h1>String.prototype.blink ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"blink"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.bold">
        <h1>String.prototype.bold ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"b"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fixed">
        <h1>String.prototype.fixed ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"tt"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontcolor">
        <h1>String.prototype.fontcolor ( _colour_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"font"*, *"color"*, _colour_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.fontsize">
        <h1>String.prototype.fontsize ( _size_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"font"*, *"size"*, _size_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.italics">
        <h1>String.prototype.italics ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"i"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.link">
        <h1>String.prototype.link ( _url_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"a"*, *"href"*, _url_).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.small">
        <h1>String.prototype.small ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"small"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.strike">
        <h1>String.prototype.strike ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"strike"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sub">
        <h1>String.prototype.sub ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"sub"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-string.prototype.sup">
        <h1>String.prototype.sup ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _S_ be the *this* value.
          1. Return ? CreateHTML(_S_, *"sup"*, *""*, *""*).
        </emu-alg>
      </emu-annex>

      <emu-annex id="String.prototype.trimleft">
        <h1>String.prototype.trimLeft ( )</h1>
        <emu-note>
          <p>The property *"trimStart"* is preferred. The *"trimLeft"* property is provided principally for compatibility with old code. It is recommended that the *"trimStart"* property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The initial value of the *"trimLeft"* property is %String.prototype.trimStart%, defined in <emu-xref href="#sec-string.prototype.trimstart"></emu-xref>.</p>
      </emu-annex>

      <emu-annex id="String.prototype.trimright">
        <h1>String.prototype.trimRight ( )</h1>
        <emu-note>
          <p>The property *"trimEnd"* is preferred. The *"trimRight"* property is provided principally for compatibility with old code. It is recommended that the *"trimEnd"* property be used in new ECMAScript code.</p>
        </emu-note>
        <p>The initial value of the *"trimRight"* property is %String.prototype.trimEnd%, defined in <emu-xref href="#sec-string.prototype.trimend"></emu-xref>.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-date.prototype-object">
      <h1>Additional Properties of the Date.prototype Object</h1>

      <emu-annex id="sec-date.prototype.getyear">
        <h1>Date.prototype.getYear ( )</h1>
        <emu-note>
          <p>The `getFullYear` method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. If _t_ is *NaN*, return *NaN*.
          1. Return YearFromTime(LocalTime(_t_)) - *1900*<sub>𝔽</sub>.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.setyear">
        <h1>Date.prototype.setYear ( _year_ )</h1>
        <emu-note>
          <p>The `setFullYear` method is preferred for nearly all purposes, because it avoids the “year 2000 problem.”</p>
        </emu-note>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _dateObject_ be the *this* value.
          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).
          1. Let _t_ be _dateObject_.[[DateValue]].
          1. Let _y_ be ? ToNumber(_year_).
          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise set _t_ to LocalTime(_t_).
          1. Let _yyyy_ be MakeFullYear(_y_).
          1. Let _d_ be MakeDay(_yyyy_, MonthFromTime(_t_), DateFromTime(_t_)).
          1. Let _date_ be MakeDate(_d_, TimeWithinDay(_t_)).
          1. Let _u_ be TimeClip(UTC(_date_)).
          1. Set _dateObject_.[[DateValue]] to _u_.
          1. Return _u_.
        </emu-alg>
      </emu-annex>

      <emu-annex id="sec-date.prototype.togmtstring">
        <h1>Date.prototype.toGMTString ( )</h1>
        <emu-note>
          <p>The `toUTCString` method is preferred. This method is provided principally for compatibility with old code.</p>
        </emu-note>
        <p>The initial value of the *"toGMTString"* property is %Date.prototype.toUTCString%, defined in <emu-xref href="#sec-date.prototype.toutcstring"></emu-xref>.</p>
      </emu-annex>
    </emu-annex>

    <emu-annex id="sec-additional-properties-of-the-regexp.prototype-object">
      <h1>Additional Properties of the RegExp.prototype Object</h1>

      <emu-annex id="sec-regexp.prototype.compile">
        <h1>RegExp.prototype.compile ( _pattern_, _flags_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? RequireInternalSlot(_O_, [[RegExpMatcher]]).
          1. If _pattern_ is an Object and _pattern_ has a [[RegExpMatcher]] internal slot, then
            1. If _flags_ is not *undefined*, throw a *TypeError* exception.
            1. Let _P_ be _pattern_.[[OriginalSource]].
            1. Let _F_ be _pattern_.[[OriginalFlags]].
          1. Else,
            1. Let _P_ be _pattern_.
            1. Let _F_ be _flags_.
          1. Return ? RegExpInitialize(_O_, _P_, _F_).
        </emu-alg>
        <emu-note>
          <p>This method completely reinitializes the *this* value RegExp with a new pattern and flags. An implementation may interpret use of this method as an assertion that the resulting RegExp object will be used multiple times and hence is a candidate for extra optimization.</p>
        </emu-note>
      </emu-annex>
    </emu-annex>
  </emu-annex>

  <emu-annex id="sec-other-additional-features">
    <h1>Other Additional Features</h1>

    <emu-annex id="sec-labelled-function-declarations">
      <h1>Labelled Function Declarations</h1>
      <p>Prior to ECMAScript 2015, the specification of |LabelledStatement| did not allow for the association of a statement label with a |FunctionDeclaration|. However, a labelled |FunctionDeclaration| was an allowable extension for non-strict code and most browser-hosted ECMAScript implementations supported that extension. In ECMAScript 2015 and later, the grammar production for |LabelledStatement| permits use of |FunctionDeclaration| as a |LabelledItem| but <emu-xref href="#sec-labelled-statements-static-semantics-early-errors"></emu-xref> includes an Early Error rule that produces a Syntax Error if that occurs. That rule is then modified to suppress the Syntax Error in non-strict code if the host supports this feature.</p>
      <emu-note>
        <p>The early error rules for |WithStatement|, |IfStatement|, and |IterationStatement| prevent these statements from containing a labelled |FunctionDeclaration| in non-strict code.</p>
      </emu-note>
    </emu-annex>

    <emu-annex id="sec-block-level-function-declarations-web-legacy-compatibility-semantics">
      <h1>Block-Level Function Declarations Web Legacy Compatibility Semantics</h1>
      <p>Prior to ECMAScript 2015, the ECMAScript specification did not define the occurrence of a |FunctionDeclaration| as an element of a |Block| statement's |StatementList|. However, support for that form of |FunctionDeclaration| was an allowable extension and most browser-hosted ECMAScript implementations permitted them. Unfortunately, the semantics of such declarations differ among those implementations. Because of these semantic differences, existing web ECMAScript source text that uses |Block| level function declarations is only portable among browser implementations if the usage only depends upon the semantic intersection of all of the browser implementations for such declarations. The following are the use cases that fall within that intersection semantics:</p>
      <ol>
        <li>
          <p>A function is declared and only referenced within a single block.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration|s whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_.
            </li>
            <li>
              All occurrences of _f_ as an |IdentifierReference| are within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
          </ul>
        </li>
        <li>
          <p>A function is declared and possibly used within a single |Block| but also referenced by an inner function definition that is not contained within that same |Block|.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration|s whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_.
            </li>
            <li>
              There may be occurrences of _f_ as an |IdentifierReference| within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
            <li>
              There is at least one occurrence of _f_ as an |IdentifierReference| within another function _h_ that is nested within _g_ and no other declaration of _f_ shadows the references to _f_ from within _h_.
            </li>
            <li>
              All invocations of _h_ occur after the declaration of _f_ has been evaluated.
            </li>
          </ul>
        </li>
        <li>
          <p>A function is declared and possibly used within a single block but also referenced within subsequent blocks.</p>
          <ul>
            <li>
              One or more |FunctionDeclaration| whose |BindingIdentifier| is the name _f_ occur within the function code of an enclosing function _g_ and that declaration is nested within a |Block|.
            </li>
            <li>
              No other declaration of _f_ that is not a `var` declaration occurs within the function code of _g_.
            </li>
            <li>
              There may be occurrences of _f_ as an |IdentifierReference| within the |StatementList| of the |Block| containing the declaration of _f_.
            </li>
            <li>
              There is at least one occurrence of _f_ as an |IdentifierReference| within the function code of _g_ that lexically follows the |Block| containing the declaration of _f_.
            </li>
          </ul>
        </li>
      </ol>
      <p>The first use case is interoperable with the semantics of |Block| level function declarations provided by ECMAScript 2015. Any pre-existing ECMAScript source text that employs that use case will operate using the Block level function declarations semantics defined by clauses <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>, <emu-xref href="#sec-ecmascript-language-statements-and-declarations"></emu-xref>, and <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>.</p>
      <p>ECMAScript 2015 interoperability for the second and third use cases requires the following extensions to the clause <emu-xref href="#sec-ordinary-and-exotic-objects-behaviours"></emu-xref>, clause <emu-xref href="#sec-ecmascript-language-functions-and-classes"></emu-xref>, clause <emu-xref href="#sec-eval-x"></emu-xref> and clause <emu-xref href="#sec-globaldeclarationinstantiation"></emu-xref> semantics.</p>
      <p>If an ECMAScript implementation has a mechanism for reporting diagnostic warning messages, a warning should be produced when code contains a |FunctionDeclaration| for which these compatibility semantics are applied and introduce observable differences from non-compatibility semantics. For example, if a var binding is not introduced because its introduction would create an early error, a warning message should not be produced.</p>
      <p>This feature involves special semantics at the following points:</p>
      <ul>
        <li>one of the early error rules for <emu-grammar>Block : `{` StatementList `}`</emu-grammar> in <emu-xref href="#sec-block-static-semantics-early-errors"></emu-xref></li>
        <li>one of the early error rules for <emu-grammar>SwitchStatement : `switch` `(` Expression `)` CaseBlock</emu-grammar> in <emu-xref href="#sec-switch-statement-static-semantics-early-errors"></emu-xref></li>
        <li>step <emu-xref href="#step-functiondeclarationinstantiation-web-compat-insertion-point"></emu-xref> in FunctionDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-blockdeclarationinstantiation-createmutablebinding"></emu-xref> in BlockDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-blockdeclarationinstantiation-initializebinding"></emu-xref> in BlockDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-globaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> in GlobalDeclarationInstantiation</li>
        <li>step <emu-xref href="#step-evaldeclarationinstantiation-web-compat-insertion-point"></emu-xref> in EvalDeclarationInstantiation</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-functiondeclarations-in-ifstatement-statement-clauses">
      <h1>FunctionDeclarations in IfStatement Statement Clauses</h1>
      <p>The following augments the |IfStatement| production in <emu-xref href="#sec-if-statement"></emu-xref>:</p>
      <emu-grammar type="definition">
        IfStatement[Yield, Await, Return] :
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` Statement[?Yield, ?Await, ?Return]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] `else` FunctionDeclaration[?Yield, ?Await, ~Default]
          `if` `(` Expression[+In, ?Yield, ?Await] `)` FunctionDeclaration[?Yield, ?Await, ~Default] [lookahead != `else`]
      </emu-grammar>
      <p>This production only applies when parsing non-strict code. Source text matched by this production is processed as if each matching occurrence of |FunctionDeclaration[?Yield, ?Await, ~Default]| was the sole |StatementListItem| of a |BlockStatement| occupying that position in the source text. The semantics of such a synthetic |BlockStatement| includes the web legacy compatibility semantics specified in <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>.</p>
    </emu-annex>

    <emu-annex id="sec-variablestatements-in-catch-blocks">
      <h1>VariableStatements in Catch Blocks</h1>
      <p>In this feature, the |Block| of a |Catch| clause may contain `var` declarations that bind a name that is also bound by the |CatchParameter|. This is accomplished by modifying an early error rule for <emu-grammar>Catch : `catch` `(` CatchParameter `)` Block</emu-grammar> in <emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>.</p>
      <emu-note>
        <p>At runtime, such bindings are instantiated in the VariableDeclarationEnvironment. They do not shadow the same-named bindings introduced by the |CatchParameter| and hence the |Initializer| for such `var` declarations will assign to the corresponding catch parameter rather than the `var` binding.</p>
      </emu-note>
      <p>This modified behaviour also applies to `var` and `function` declarations introduced by direct eval calls contained within the |Block| of a |Catch| clause. This change is accomplished by modifying steps <emu-xref href="#step-evaldeclarationinstantiation-throw-duplicate-binding"></emu-xref> and <emu-xref href="#step-evaldeclarationinstantiation-web-compat-bindingexists"></emu-xref> in EvalDeclarationInstantiation.</p>
    </emu-annex>

    <emu-annex id="sec-initializers-in-forin-statement-heads">
      <h1>Initializers in ForIn Statement Heads</h1>
      <p>The following augments the |ForInOfStatement| production in <emu-xref href="#sec-for-in-and-for-of-statements"></emu-xref>:</p>
      <emu-grammar type="definition">
        ForInOfStatement[Yield, Await, Return] :
          `for` `(` `var` BindingIdentifier[?Yield, ?Await] Initializer[~In, ?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
      </emu-grammar>
      <p>This production only applies when parsing non-strict code.</p>
      <p>The static semantics of ContainsDuplicateLabels in <emu-xref href="#sec-static-semantics-containsduplicatelabels"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.
      </emu-alg>
      <p>The static semantics of ContainsUndefinedBreakTarget in <emu-xref href="#sec-static-semantics-containsundefinedbreaktarget"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.
      </emu-alg>
      <p>The static semantics of ContainsUndefinedContinueTarget in <emu-xref href="#sec-static-semantics-containsundefinedcontinuetarget"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».
      </emu-alg>
      <p>The static semantics of IsDestructuring in <emu-xref href="#sec-static-semantics-isdestructuring"></emu-xref> are augmented with the following:</p>
      <emu-grammar>
        BindingIdentifier :
          Identifier
          `yield`
          `await`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
      <p>The static semantics of VarDeclaredNames in <emu-xref href="#sec-static-semantics-vardeclarednames"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _names1_ be the BoundNames of |BindingIdentifier|.
        1. Let _names2_ be the VarDeclaredNames of |Statement|.
        1. Return the list-concatenation of _names1_ and _names2_.
      </emu-alg>
      <p>The static semantics of VarScopedDeclarations in <emu-xref href="#sec-static-semantics-varscopeddeclarations"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _declarations1_ be « |BindingIdentifier| ».
        1. Let _declarations2_ be the VarScopedDeclarations of |Statement|.
        1. Return the list-concatenation of _declarations1_ and _declarations2_.
      </emu-alg>
      <p>The runtime semantics of ForInOfLoopEvaluation in <emu-xref href="#sec-runtime-semantics-forinofloopevaluation"></emu-xref> are augmented with the following:</p>
      <emu-grammar>ForInOfStatement : `for` `(` `var` BindingIdentifier Initializer `in` Expression `)` Statement</emu-grammar>
      <emu-alg>
        1. Let _bindingId_ be the StringValue of |BindingIdentifier|.
        1. Let _lhs_ be ? ResolveBinding(_bindingId_).
        1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then
          1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.
        1. Else,
          1. Let _rhs_ be ? Evaluation of |Initializer|.
          1. Let _value_ be ? GetValue(_rhs_).
        1. Perform ? PutValue(_lhs_, _value_).
        1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).
        1. Return ? ForIn/OfBodyEvaluation(|BindingIdentifier|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_).
      </emu-alg>
    </emu-annex>

    <emu-annex id="sec-IsHTMLDDA-internal-slot">
      <h1>The [[IsHTMLDDA]] Internal Slot</h1>
      <p>An <dfn>[[IsHTMLDDA]] internal slot</dfn> may exist on host-defined objects. Objects with an [[IsHTMLDDA]] internal slot behave like *undefined* in the <emu-xref href="#sec-toboolean">ToBoolean</emu-xref> and IsLooselyEqual abstract operations and when used as an operand for the <emu-xref href="#sec-typeof-operator">`typeof` operator</emu-xref>.</p>
      <emu-note>
        <p>Objects with an [[IsHTMLDDA]] internal slot are never created by this specification. However, the <a href="https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all"><code>document.all</code> object</a> in web browsers is a host-defined exotic object with this slot that exists for web compatibility purposes. There are no other known examples of this type of object and implementations should not create any with the exception of `document.all`.</p>
      </emu-note>
      <p>This feature involves special semantics at the following points:</p>
      <ul>
        <li>step <emu-xref href="#step-to-boolean-web-compat-insertion-point"></emu-xref> in ToBoolean</li>
        <li>step <emu-xref href="#step-abstract-equality-comparison-web-compat-insertion-point"></emu-xref> in IsLooselyEqual</li>
        <li>step <emu-xref href="#step-typeof-web-compat-insertion-point"></emu-xref> in the evaluation semantics for `typeof`</li>
      </ul>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-make-job-callback">
      <h1>Non-default behaviour in HostMakeJobCallback</h1>
      <p>The HostMakeJobCallback abstract operation allows hosts which are web browsers to specify non-default behaviour.</p>
    </emu-annex>

    <emu-annex id="sec-web-compat-host-ensure-can-add-private-field">
      <h1>Non-default behaviour in HostEnsureCanAddPrivateElement</h1>
      <p>The HostEnsureCanAddPrivateElement abstract operation allows hosts which are web browsers to specify non-default behaviour.</p>
    </emu-annex>

    <emu-annex id="sec-runtime-errors-for-function-call-assignment-targets">
      <h1>Runtime Errors for Function Call Assignment Targets</h1>
      <p>When a function call (<emu-xref href="#sec-function-calls"></emu-xref>) is used as an assignment target in non-strict code, instead of producing an early error, a *ReferenceError* exception is thrown during evaluation of the assignment.</p>
      <emu-note>
        <p>When the assignment target is the |LeftHandSideExpression| of an |AssignmentExpression|, the assignment operator must be `=` or an |AssignmentOperator|; in particular, the allowance here does not apply to the logical assignment operators (`??=`, `&&=`, `||=`).</p>
      </emu-note>
      <p>See step <emu-xref href="#step-assignmenttargettype-web-compat"></emu-xref> of AssignmentTargetType for <emu-grammar>CallExpression : CoverCallExpressionAndAsyncArrowHead</emu-grammar> and <emu-grammar>CallExpression : CallExpression Arguments</emu-grammar>.</p>
    </emu-annex>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-strict-mode-of-ecmascript">
  <h1>The Strict Mode of ECMAScript</h1>
  <p><b>The strict mode restriction and exceptions</b></p>
  <ul>
    <li>
      `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, and `yield` are reserved words within strict mode code. (<emu-xref href="#sec-keywords-and-reserved-words"></emu-xref>).
    </li>
    <li>
      A conforming implementation, when processing strict mode code, must disallow instances of the productions <emu-grammar>NumericLiteral :: LegacyOctalIntegerLiteral</emu-grammar> and <emu-grammar>DecimalIntegerLiteral :: NonOctalDecimalIntegerLiteral</emu-grammar>.
    </li>
    <li>
      A conforming implementation, when processing strict mode code, must disallow instances of the productions <emu-grammar>EscapeSequence :: LegacyOctalEscapeSequence</emu-grammar> and <emu-grammar>EscapeSequence :: NonOctalDecimalEscapeSequence</emu-grammar>.
    </li>
    <li>
      Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within strict mode code, its |LeftHandSideExpression| must not evaluate to an unresolvable Reference. If it does a *ReferenceError* exception is thrown (<emu-xref href="#sec-putvalue"></emu-xref>). The |LeftHandSideExpression| also may not be a reference to a data property with the attribute value { [[Writable]]: *false* }, to an accessor property with the attribute value { [[Set]]: *undefined* }, nor to a non-existent property of an object whose [[Extensible]] internal slot is *false*. In these cases a `TypeError` exception is thrown (<emu-xref href="#sec-assignment-operators"></emu-xref>).
    </li>
    <li>
      An |IdentifierReference| with the StringValue *"eval"* or *"arguments"* may not appear as the |LeftHandSideExpression| of an Assignment operator (<emu-xref href="#sec-assignment-operators"></emu-xref>) or of an |UpdateExpression| (<emu-xref href="#sec-update-expressions"></emu-xref>) or as the |UnaryExpression| operated upon by a Prefix Increment (<emu-xref href="#sec-prefix-increment-operator"></emu-xref>) or a Prefix Decrement (<emu-xref href="#sec-prefix-decrement-operator"></emu-xref>) operator.
    </li>
    <li>
      Arguments objects for strict functions define a non-configurable accessor property *"callee"* which throws a *TypeError* exception on access (<emu-xref href="#sec-createunmappedargumentsobject"></emu-xref>).
    </li>
    <li>
      Arguments objects for strict functions do not dynamically share their <emu-xref href="#array-index">array-indexed</emu-xref> property values with the corresponding formal parameter bindings of their functions. (<emu-xref href="#sec-arguments-exotic-objects"></emu-xref>).
    </li>
    <li>
      For strict functions, if an arguments object is created the binding of the local identifier `arguments` to the arguments object is immutable and hence may not be the target of an assignment expression. (<emu-xref href="#sec-functiondeclarationinstantiation"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if the StringValue of a |BindingIdentifier| is either *"eval"* or *"arguments"* within strict mode code (<emu-xref href="#sec-identifiers-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code (<emu-xref href="#sec-eval-x"></emu-xref>).
    </li>
    <li>
      If *this* is evaluated within strict mode code, then the *this* value is not coerced to an object. A *this* value of either *undefined* or *null* is not converted to the global object and primitive values are not converted to wrapper objects. The *this* value passed via a function call (including calls made using `Function.prototype.apply` and `Function.prototype.call`) do not coerce the passed *this* value to an object (<emu-xref href="#sec-ordinarycallbindthis"></emu-xref>, <emu-xref href="#sec-function.prototype.apply"></emu-xref>, <emu-xref href="#sec-function.prototype.call"></emu-xref>).
    </li>
    <li>
      When a `delete` operator occurs within strict mode code, a *SyntaxError* is thrown if its |UnaryExpression| is a direct reference to a variable, function argument, or function name (<emu-xref href="#sec-delete-operator-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      When a `delete` operator occurs within strict mode code, a *TypeError* is thrown if the property to be deleted has the attribute { [[Configurable]]: *false* } or otherwise cannot be deleted (<emu-xref href="#sec-delete-operator-runtime-semantics-evaluation"></emu-xref>).
    </li>
    <li>
      Strict mode code may not include a |WithStatement|. The occurrence of a |WithStatement| in such a context is a *SyntaxError* (<emu-xref href="#sec-with-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if a |CatchParameter| occurs within strict mode code and the BoundNames of |CatchParameter| contains either `eval` or `arguments` (<emu-xref href="#sec-try-statement-static-semantics-early-errors"></emu-xref>).
    </li>
    <li>
      It is a *SyntaxError* if the same |BindingIdentifier| appears more than once in the |FormalParameters| of a strict function. An attempt to create such a function using a Function, Generator, or AsyncFunction constructor is a *SyntaxError* (<emu-xref href="#sec-function-definitions-static-semantics-early-errors"></emu-xref>, <emu-xref href="#sec-createdynamicfunction"></emu-xref>).
    </li>
    <li>
      An implementation may not extend, beyond that defined in this specification, the meanings within strict functions of properties named *"caller"* or *"arguments"* of function instances.
    </li>
  </ul>
</emu-annex>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>
  <p>See <emu-xref href="#sec-hosts-and-implementations"></emu-xref> for the definition of host.</p>

  <emu-annex id="sec-host-hooks-summary">
    <h1>Host Hooks</h1>
    <p><b>HostCallJobCallback(...)</b></p>
    <p><b>HostEnqueueFinalizationRegistryCleanupJob(...)</b></p>
    <p><b>HostEnqueueGenericJob(...)</b></p>
    <p><b>HostEnqueuePromiseJob(...)</b></p>
    <p><b>HostEnqueueTimeoutJob(...)</b></p>
    <p><b>HostEnsureCanCompileStrings(...)</b></p>
    <p><b>HostFinalizeImportMeta(...)</b></p>
    <p><b>HostGetImportMetaProperties(...)</b></p>
    <p><b>HostGrowSharedArrayBuffer(...)</b></p>
    <p><b>HostHasSourceTextAvailable(...)</b></p>
    <p><b>HostLoadImportedModule(...)</b></p>
    <p><b>HostGetSupportedImportAttributes(...)</b></p>
    <p><b>HostMakeJobCallback(...)</b></p>
    <p><b>HostPromiseRejectionTracker(...)</b></p>
    <p><b>HostResizeArrayBuffer(...)</b></p>
    <p><b>InitializeHostDefinedRealm(...)</b></p>
  </emu-annex>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>Host-defined Fields</h1>
    <p>[[HostDefined]] on Realm Records: See <emu-xref href="#table-realm-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on Script Records: See <emu-xref href="#table-script-records"></emu-xref>.</p>
    <p>[[HostDefined]] on Module Records: See <emu-xref href="#table-module-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on JobCallback Records: See <emu-xref href="#table-jobcallback-records"></emu-xref>.</p>
    <p>[[HostSynchronizesWith]] on Candidate Executions: See <emu-xref href="#table-candidate-execution-records"></emu-xref>.</p>
    <p>[[IsHTMLDDA]]: See <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-host-defined-objects-summary">
    <h1>Host-defined Objects</h1>
    <p>The global object: See clause <emu-xref href="#sec-global-object"></emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-host-running-jobs">
    <h1>Running Jobs</h1>
    <p>Preparation steps before, and cleanup steps after, invocation of Job Abstract Closures. See <emu-xref href="#sec-jobs"></emu-xref>.</p>
  </emu-annex>

  <emu-annex id="sec-host-internal-methods-of-exotic-objects">
    <h1>Internal Methods of Exotic Objects</h1>
    <p>Any of the essential internal methods in <emu-xref href="#table-essential-internal-methods"></emu-xref> for any exotic object not specified within this specification.</p>
  </emu-annex>

  <emu-annex id="sec-host-built-in-objects-and-methods">
    <h1>Built-in Objects and Methods</h1>
    <p>Any built-in objects and methods not defined within this specification, except as restricted in <emu-xref href="#sec-forbidden-extensions"></emu-xref>.</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact">
  <h1>Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact</h1>
  <p><emu-xref href="#sec-candeclareglobalvar"></emu-xref>-<emu-xref href="#sec-createglobalfunctionbinding"></emu-xref> Edition 5 and 5.1 used a property existence test to determine whether a global object property corresponding to a new global declaration already existed. ECMAScript 2015 uses an own property existence test. This corresponds to what has been most commonly implemented by web browsers.</p>
  <p><emu-xref href="#sec-array-exotic-objects-defineownproperty-p-desc"></emu-xref>: The 5<sup>th</sup> Edition moved the capture of the current array length prior to the integer conversion of the array index or new length value. However, the captured length value could become invalid if the conversion process has the side-effect of changing the array length. ECMAScript 2015 specifies that the current array length must be captured after the possible occurrence of such side-effects.</p>
  <p><emu-xref href="#sec-timeclip"></emu-xref>: Previous editions permitted the TimeClip abstract operation to return either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub> as the representation of a 0 time value. ECMAScript 2015 specifies that *+0*<sub>𝔽</sub> always returned. This means that for ECMAScript 2015 the time value of a Date is never observably *-0*<sub>𝔽</sub> and methods that return time values never return *-0*<sub>𝔽</sub>.</p>
  <p><emu-xref href="#sec-date-time-string-format"></emu-xref>: If a UTC offset representation is not present, the local time zone is used. Edition 5.1 incorrectly stated that a missing time zone should be interpreted as *"z"*.</p>
  <p><emu-xref href="#sec-date.prototype.toisostring"></emu-xref>: If the year cannot be represented using the Date Time String Format specified in <emu-xref href="#sec-date-time-string-format"></emu-xref> a RangeError exception is thrown. Previous editions did not specify the behaviour for that case.</p>
  <p><emu-xref href="#sec-date.prototype.tostring"></emu-xref>: Previous editions did not specify the value returned by `Date.prototype.toString` when the time value is *NaN*. ECMAScript 2015 specifies the result to be the String value *"Invalid Date"*.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref>, <emu-xref href="#sec-escaperegexppattern"></emu-xref>: Any LineTerminator code points in the value of the *"source"* property of a RegExp instance must be expressed using an escape sequence. Edition 5.1 only required the escaping of `/`.</p>
  <p><emu-xref href="#sec-regexp.prototype-%symbol.match%"></emu-xref>, <emu-xref href="#sec-regexp.prototype-%symbol.replace%"></emu-xref>: In previous editions, the specifications for `String.prototype.match` and `String.prototype.replace` was incorrect for cases where the pattern argument was a RegExp value whose `global` flag is set. The previous specifications stated that for each attempt to match the pattern, if `lastIndex` did not change, it should be incremented by 1. The correct behaviour is that `lastIndex` should be incremented by 1 only if the pattern matched the empty String.</p>
  <p><emu-xref href="#sec-array.prototype.sort"></emu-xref>: Previous editions did not specify how a *NaN* value returned by a _comparator_ was interpreted by `Array.prototype.sort`. ECMAScript 2015 specifies that such as value is treated as if *+0*<sub>𝔽</sub> was returned from the _comparator_. ECMAScript 2015 also specifies that ToNumber is applied to the result returned by a _comparator_. In previous editions, the effect of a _comparator_ result that is not a Number value was implementation-defined. In practice, implementations call ToNumber.</p>
</emu-annex>

<emu-annex id="sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions">
  <h1>Additions and Changes That Introduce Incompatibilities with Prior Editions</h1>
  <p><emu-xref href="#sec-reference-record-specification-type"></emu-xref>: In ECMAScript 2015, Function calls are not allowed to return a Reference Record.</p>
  <p><emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>: In ECMAScript 2015, ToNumber applied to a String value now recognizes and converts |BinaryIntegerLiteral| and |OctalIntegerLiteral| numeric strings. In previous editions such strings were converted to *NaN*.</p>
  <p><emu-xref href="#sec-code-realms"></emu-xref>: In ECMAScript 2018, Template objects are canonicalized based on Parse Node (source location), instead of across all occurrences of that template literal or tagged template in a Realm in previous editions.</p>
  <p><emu-xref href="#sec-white-space"></emu-xref>: In ECMAScript 2016, Unicode 8.0.0 or higher is mandated, as opposed to ECMAScript 2015 which mandated Unicode 5.1. In particular, this caused U+180E MONGOLIAN VOWEL SEPARATOR, which was in the `Space_Separator` (`Zs`) category and thus treated as whitespace in ECMAScript 2015, to be moved to the `Format` (`Cf`) category (as of Unicode 6.3.0). This causes whitespace-sensitive methods to behave differently. For example, `"\u180E".trim().length` was `0` in previous editions, but `1` in ECMAScript 2016 and later. Additionally, ECMAScript 2017 mandated always using the latest version of the Unicode Standard.</p>
  <p><emu-xref href="#sec-names-and-keywords"></emu-xref>: In ECMAScript 2015, the valid code points for an |IdentifierName| are specified in terms of the Unicode properties “ID_Start” and “ID_Continue”. In previous editions, the valid |IdentifierName| or |Identifier| code points were specified by enumerating various Unicode code point categories.</p>
  <p><emu-xref href="#sec-rules-of-automatic-semicolon-insertion"></emu-xref>: In ECMAScript 2015, Automatic Semicolon Insertion adds a semicolon at the end of a do-while statement if the semicolon is missing. This change aligns the specification with the actual behaviour of most existing implementations.</p>
  <p><emu-xref href="#sec-object-initializer-static-semantics-early-errors"></emu-xref>: In ECMAScript 2015, it is no longer an early error to have duplicate property names in Object Initializers.</p>
  <p><emu-xref href="#sec-assignment-operators-static-semantics-early-errors"></emu-xref>: In ECMAScript 2015, strict mode code containing an assignment to an immutable binding such as the function name of a |FunctionExpression| does not produce an early error. Instead it produces a runtime error.</p>
  <p><emu-xref href="#sec-block"></emu-xref>: In ECMAScript 2015, a |StatementList| beginning with the token let followed by the input elements |LineTerminator| then |Identifier| is the start of a |LexicalDeclaration|. In previous editions, automatic semicolon insertion would always insert a semicolon before the |Identifier| input element.</p>
  <p><emu-xref href="#sec-expression-statement"></emu-xref>: In ECMAScript 2015, a |StatementListItem| beginning with the token `let` followed by the token `[` is the start of a |LexicalDeclaration|. In previous editions such a sequence would be the start of an |ExpressionStatement|.</p>
  <p><emu-xref href="#sec-if-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the normal result of an |IfStatement| is never the value ~empty~. If no |Statement| part is evaluated or if the evaluated |Statement| part produces a normal completion containing ~empty~, the result of the |IfStatement| is *undefined*.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, if the `(` token of a for statement is immediately followed by the token sequence `let [` then the `let` is treated as the start of a |LexicalDeclaration|. In previous editions such a token sequence would be the start of an |Expression|.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, if the ( token of a for-in statement is immediately followed by the token sequence `let [` then the `let` is treated as the start of a |ForDeclaration|. In previous editions such a token sequence would be the start of an |LeftHandSideExpression|.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: Prior to ECMAScript 2015, an initialization expression could appear as part of the |VariableDeclaration| that precedes the `in` keyword. In ECMAScript 2015, the |ForBinding| in that same position does not allow the occurrence of such an initializer. In ECMAScript 2017, such an initializer is permitted only in non-strict code.</p>
  <p><emu-xref href="#sec-iteration-statements"></emu-xref>: In ECMAScript 2015, the result of evaluating an |IterationStatement| is never a normal completion whose [[Value]] is ~empty~. If the |Statement| part of an |IterationStatement| is not evaluated or if the final evaluation of the |Statement| part produces a normal completion whose [[Value]] is ~empty~, the result of evaluating the |IterationStatement| is a normal completion whose [[Value]] is *undefined*.</p>
  <p><emu-xref href="#sec-with-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the result of evaluating a |WithStatement| is never a normal completion whose [[Value]] is ~empty~. If evaluation of the |Statement| part of a |WithStatement| produces a normal completion whose [[Value]] is ~empty~, the result of evaluating the |WithStatement| is a normal completion whose [[Value]] is *undefined*.</p>
  <p><emu-xref href="#sec-switch-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the result of evaluating a |SwitchStatement| is never a normal completion whose [[Value]] is ~empty~. If evaluation of the |CaseBlock| part of a |SwitchStatement| produces a normal completion whose [[Value]] is ~empty~, the result of evaluating the |SwitchStatement| is a normal completion whose [[Value]] is *undefined*.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>: In ECMAScript 2015, it is an early error for a |Catch| clause to contain a `var` declaration for the same |Identifier| that appears as the |Catch| clause parameter. In previous editions, such a variable declaration would be instantiated in the enclosing variable environment but the declaration's |Initializer| value would be assigned to the |Catch| parameter.</p>
  <p><emu-xref href="#sec-try-statement"></emu-xref>, <emu-xref href="#sec-evaldeclarationinstantiation"></emu-xref>: In ECMAScript 2015, a runtime *SyntaxError* is thrown if a |Catch| clause evaluates a non-strict direct `eval` whose eval code includes a `var` or `FunctionDeclaration` declaration that binds the same |Identifier| that appears as the |Catch| clause parameter.</p>
  <p><emu-xref href="#sec-try-statement-runtime-semantics-evaluation"></emu-xref>: In ECMAScript 2015, the result of a |TryStatement| is never the value ~empty~. If the |Block| part of a |TryStatement| evaluates to a normal completion containing ~empty~, the result of the |TryStatement| is *undefined*. If the |Block| part of a |TryStatement| evaluates to a throw completion and it has a |Catch| part that evaluates to a normal completion containing ~empty~, the result of the |TryStatement| is *undefined* if there is no |Finally| clause or if its |Finally| clause evaluates to an ~empty~ normal completion.</p>
  <p><emu-xref href="#sec-runtime-semantics-methoddefinitionevaluation"></emu-xref> In ECMAScript 2015, the function objects that are created as the values of the [[Get]] or [[Set]] attribute of accessor properties in an |ObjectLiteral| are not constructor functions and they do not have a *"prototype"* own property. In the previous edition, they were constructors and had a *"prototype"* property.</p>
  <p><emu-xref href="#sec-object.freeze"></emu-xref>: In ECMAScript 2015, if the argument to `Object.freeze` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getownpropertydescriptor"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getOwnPropertyDescriptor` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getownpropertynames"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getOwnPropertyNames` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.getprototypeof"></emu-xref>: In ECMAScript 2015, if the argument to `Object.getPrototypeOf` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.isextensible"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isExtensible` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.isfrozen"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isFrozen` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.issealed"></emu-xref>: In ECMAScript 2015, if the argument to `Object.isSealed` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.keys"></emu-xref>: In ECMAScript 2015, if the argument to `Object.keys` is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.preventextensions"></emu-xref>: In ECMAScript 2015, if the argument to `Object.preventExtensions` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-object.seal"></emu-xref>: In ECMAScript 2015, if the argument to `Object.seal` is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a *TypeError* to be thrown.</p>
  <p><emu-xref href="#sec-function.prototype.bind"></emu-xref>: In ECMAScript 2015, the [[Prototype]] internal slot of a bound function is set to the [[GetPrototypeOf]] value of its target function. In the previous edition, [[Prototype]] was always set to %Function.prototype%.</p>
  <p><emu-xref href="#sec-function-instances-length"></emu-xref>: In ECMAScript 2015, the *"length"* property of function instances is configurable. In previous editions it was non-configurable.</p>
  <p><emu-xref href="#sec-properties-of-the-nativeerror-constructors"></emu-xref>: In ECMAScript 2015, the [[Prototype]] internal slot of a _NativeError_ constructor is the Error constructor. In previous editions it was the Function prototype object.</p>
  <p><emu-xref href="#sec-properties-of-the-date-prototype-object"></emu-xref> In ECMAScript 2015, the Date prototype object is not a Date instance. In previous editions it was a Date instance whose TimeValue was *NaN*.</p>
  <p><emu-xref href="#sec-string.prototype.localecompare"></emu-xref> In ECMAScript 2015, the `String.prototype.localeCompare` function must treat Strings that are canonically equivalent according to the Unicode Standard as being identical. In previous editions implementations were permitted to ignore canonical equivalence and could instead use a bit-wise comparison.</p>
  <p><emu-xref href="#sec-string.prototype.tolowercase"></emu-xref> and <emu-xref href="#sec-string.prototype.touppercase"></emu-xref> In ECMAScript 2015, lowercase/upper conversion processing operates on code points. In previous editions such the conversion processing was only applied to individual code units. The only affected code points are those in the Deseret block of Unicode.</p>
  <p><emu-xref href="#sec-string.prototype.trim"></emu-xref> In ECMAScript 2015, the `String.prototype.trim` method is defined to recognize white space code points that may exist outside of the Unicode BMP. However, as of Unicode 7 no such code points are defined. In previous editions such code points would not have been recognized as white space.</p>
  <p><emu-xref href="#sec-regexp-pattern-flags"></emu-xref> In ECMAScript 2015, If the _pattern_ argument is a RegExp instance and the _flags_ argument is not *undefined*, a new RegExp instance is created just like _pattern_ except that _pattern_'s flags are replaced by the argument _flags_. In previous editions a *TypeError* exception was thrown when _pattern_ was a RegExp instance and _flags_ was not *undefined*.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> In ECMAScript 2015, the RegExp prototype object is not a RegExp instance. In previous editions it was a RegExp instance whose pattern is the empty String.</p>
  <p><emu-xref href="#sec-properties-of-the-regexp-prototype-object"></emu-xref> In ECMAScript 2015, *"source"*, *"global"*, *"ignoreCase"*, and *"multiline"* are accessor properties defined on the RegExp prototype object. In previous editions they were data properties defined on RegExp instances.</p>
  <p><emu-xref href="#sec-atomics.notify"></emu-xref>: In ECMAScript 2019, `Atomics.wake` has been renamed to `Atomics.notify` to prevent confusion with `Atomics.wait`.</p>
  <p><emu-xref href="#sec-asyncfromsynciteratorcontinuation"></emu-xref>, <emu-xref href="#sec-asyncgeneratorresume"></emu-xref>: In ECMAScript 2019, the number of Jobs enqueued by `await` was reduced, which could create an observable difference in resolution order between a `then()` call and an `await` expression.</p>
</emu-annex>

<emu-annex id="sec-bibliography" back-matter>
  <h1>Bibliography</h1>
  <ol>
    <li>
      <dfn>IEEE 754-2019</dfn>: <i>IEEE Standard for Floating-Point Arithmetic</i>. Institute of Electrical and Electronic Engineers, New York (2019)
      <emu-note>
        <p>There are no normative changes between IEEE 754-2008 and IEEE 754-2019 that affect the ECMA-262 specification.</p>
      </emu-note>
    </li>
    <li>
      <i>The Unicode Standard</i>, available at &lt;<a href="https://unicode.org/versions/latest">https://unicode.org/versions/latest</a>>
    </li>
    <li>
      <i>Unicode Technical Note #5: Canonical Equivalence in Applications</i>, available at &lt;<a href="https://unicode.org/notes/tn5/">https://unicode.org/notes/tn5/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #10: Unicode Collation Algorithm</i>, available at &lt;<a href="https://unicode.org/reports/tr10/">https://unicode.org/reports/tr10/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #15, Unicode Normalization Forms</i>, available at &lt;<a href="https://unicode.org/reports/tr15/">https://unicode.org/reports/tr15/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #18: Unicode Regular Expressions</i>, available at &lt;<a href="https://unicode.org/reports/tr18/">https://unicode.org/reports/tr18/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #24: Unicode `Script` Property</i>, available at &lt;<a href="https://unicode.org/reports/tr24/">https://unicode.org/reports/tr24/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #31, Unicode Identifiers and Pattern Syntax</i>, available at &lt;<a href="https://unicode.org/reports/tr31/">https://unicode.org/reports/tr31/</a>>
    </li>
    <li>
      <i>Unicode Standard Annex #44: Unicode Character Database</i>, available at &lt;<a href="https://unicode.org/reports/tr44/">https://unicode.org/reports/tr44/</a>>
    </li>
    <li>
      <i>Unicode Technical Standard #51: Unicode Emoji</i>, available at &lt;<a href="https://unicode.org/reports/tr51/">https://unicode.org/reports/tr51/</a>>
    </li>
    <li>
      <i>IANA Time Zone Database</i>, available at &lt;<a href="https://www.iana.org/time-zones">https://www.iana.org/time-zones</a>>
    </li>
    <li>
      ISO 8601:2004(E) <i>Data elements and interchange formats — Information interchange — Representation of dates and times</i>
    </li>
    <li>
      <i>RFC 1738 “Uniform Resource Locators (URL)”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc1738">https://tools.ietf.org/html/rfc1738</a>>
    </li>
    <li>
      <i>RFC 2396 “Uniform Resource Identifiers (URI): Generic Syntax”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc2396">https://tools.ietf.org/html/rfc2396</a>>
    </li>
    <li>
      <i>RFC 3629 “UTF-8, a transformation format of ISO 10646”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>>
    </li>
    <li>
      <i>RFC 7231 “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”</i>, available at &lt;<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>>
    </li>
  </ol>
</emu-annex>

<emu-annex id="sec-colophon" back-matter>
  <h1>Colophon</h1>
  <p>This specification is authored on <a href="https://github.com/tc39/ecma262">GitHub</a> in a plaintext source format called <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a>. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring Ecma specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a> for defining syntax and <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> for authoring algorithm steps. PDF renderings of this specification are produced using a print stylesheet which takes advantage of the CSS Paged Media specification and is converted using <a href="https://www.princexml.com/">PrinceXML</a>.</p>
  <p>Prior editions of this specification were authored using Word—the Ecmarkup source text that formed the basis of this edition was produced by converting the ECMAScript 2015 Word document to Ecmarkup using an automated conversion tool.</p>
</emu-annex>
